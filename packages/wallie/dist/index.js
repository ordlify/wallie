(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=Poppins:wght@400;500;600;700&display=swap";@tailwind base;@tailwind components;@tailwind utilities;html,body{padding:0;margin:0;font-family:Outfit,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;scroll-behavior:smooth}')),document.head.appendChild(t)}}catch(i){console.error("vite-plugin-css-injected-by-js",i)}})();
var rn = Object.defineProperty;
var nn = (B, L, W) => L in B ? rn(B, L, { enumerable: !0, configurable: !0, writable: !0, value: W }) : B[L] = W;
var Cr = (B, L, W) => nn(B, typeof L != "symbol" ? L + "" : L, W);
import * as C$3 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { createPortal } from "react-dom";
function _mergeNamespaces(B, L) {
  for (var W = 0; W < L.length; W++) {
    const K = L[W];
    if (typeof K != "string" && !Array.isArray(K)) {
      for (const J in K)
        if (J !== "default" && !(J in B)) {
          const V = Object.getOwnPropertyDescriptor(K, J);
          V && Object.defineProperty(B, J, V.get ? V : {
            enumerable: !0,
            get: () => K[J]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(B, Symbol.toStringTag, { value: "Module" }));
}
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var L = queue.length; L; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < L; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, L = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var L = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var W = 1; W < arguments.length; W++)
      L[W - 1] = arguments[W];
  queue.push(new Item(B, L)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, L) {
  this.fun = B, this.array = L;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
function getAugmentedNamespace(B) {
  if (B.__esModule) return B;
  var L = B.default;
  if (typeof L == "function") {
    var W = function K() {
      return this instanceof K ? Reflect.construct(L, arguments, this.constructor) : L.apply(this, arguments);
    };
    W.prototype = L.prototype;
  } else W = {};
  return Object.defineProperty(W, "__esModule", { value: !0 }), Object.keys(B).forEach(function(K) {
    var J = Object.getOwnPropertyDescriptor(B, K);
    Object.defineProperty(W, K, J.get ? J : {
      enumerable: !0,
      get: function() {
        return B[K];
      }
    });
  }), W;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = C__default, L = Symbol.for("react.element"), W = Symbol.for("react.fragment"), K = Object.prototype.hasOwnProperty, J = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, V = { key: !0, ref: !0, __self: !0, __source: !0 };
  function re(ie, oe, pe) {
    var ne, ce = {}, Ce = null, Oe = null;
    pe !== void 0 && (Ce = "" + pe), oe.key !== void 0 && (Ce = "" + oe.key), oe.ref !== void 0 && (Oe = oe.ref);
    for (ne in oe) K.call(oe, ne) && !V.hasOwnProperty(ne) && (ce[ne] = oe[ne]);
    if (ie && ie.defaultProps) for (ne in oe = ie.defaultProps, oe) ce[ne] === void 0 && (ce[ne] = oe[ne]);
    return { $$typeof: L, type: ie, key: Ce, ref: Oe, props: ce, _owner: J.current };
  }
  return reactJsxRuntime_production_min.Fragment = W, reactJsxRuntime_production_min.jsx = re, reactJsxRuntime_production_min.jsxs = re, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = C__default, L = Symbol.for("react.element"), W = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), V = Symbol.for("react.profiler"), re = Symbol.for("react.provider"), ie = Symbol.for("react.context"), oe = Symbol.for("react.forward_ref"), pe = Symbol.for("react.suspense"), ne = Symbol.for("react.suspense_list"), ce = Symbol.for("react.memo"), Ce = Symbol.for("react.lazy"), Oe = Symbol.for("react.offscreen"), st = Symbol.iterator, at = "@@iterator";
    function lt(Lt) {
      if (Lt === null || typeof Lt != "object")
        return null;
      var Zt = st && Lt[st] || Lt[at];
      return typeof Zt == "function" ? Zt : null;
    }
    var pt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ht(Lt) {
      {
        for (var Zt = arguments.length, tr = new Array(Zt > 1 ? Zt - 1 : 0), fr = 1; fr < Zt; fr++)
          tr[fr - 1] = arguments[fr];
        yt("error", Lt, tr);
      }
    }
    function yt(Lt, Zt, tr) {
      {
        var fr = pt.ReactDebugCurrentFrame, gr = fr.getStackAddendum();
        gr !== "" && (Zt += "%s", tr = tr.concat([gr]));
        var Er = tr.map(function(Ir) {
          return String(Ir);
        });
        Er.unshift("Warning: " + Zt), Function.prototype.apply.call(console[Lt], console, Er);
      }
    }
    var vt = !1, $t = !1, xt = !1, Ct = !1, Et = !1, St;
    St = Symbol.for("react.module.reference");
    function It(Lt) {
      return !!(typeof Lt == "string" || typeof Lt == "function" || Lt === K || Lt === V || Et || Lt === J || Lt === pe || Lt === ne || Ct || Lt === Oe || vt || $t || xt || typeof Lt == "object" && Lt !== null && (Lt.$$typeof === Ce || Lt.$$typeof === ce || Lt.$$typeof === re || Lt.$$typeof === ie || Lt.$$typeof === oe || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Lt.$$typeof === St || Lt.getModuleId !== void 0));
    }
    function Tt(Lt, Zt, tr) {
      var fr = Lt.displayName;
      if (fr)
        return fr;
      var gr = Zt.displayName || Zt.name || "";
      return gr !== "" ? tr + "(" + gr + ")" : tr;
    }
    function nt(Lt) {
      return Lt.displayName || "Context";
    }
    function it(Lt) {
      if (Lt == null)
        return null;
      if (typeof Lt.tag == "number" && ht("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Lt == "function")
        return Lt.displayName || Lt.name || null;
      if (typeof Lt == "string")
        return Lt;
      switch (Lt) {
        case K:
          return "Fragment";
        case W:
          return "Portal";
        case V:
          return "Profiler";
        case J:
          return "StrictMode";
        case pe:
          return "Suspense";
        case ne:
          return "SuspenseList";
      }
      if (typeof Lt == "object")
        switch (Lt.$$typeof) {
          case ie:
            var Zt = Lt;
            return nt(Zt) + ".Consumer";
          case re:
            var tr = Lt;
            return nt(tr._context) + ".Provider";
          case oe:
            return Tt(Lt, Lt.render, "ForwardRef");
          case ce:
            var fr = Lt.displayName || null;
            return fr !== null ? fr : it(Lt.type) || "Memo";
          case Ce: {
            var gr = Lt, Er = gr._payload, Ir = gr._init;
            try {
              return it(Ir(Er));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ke = Object.assign, rt = 0, ot, ft, ct, bt, ut, gt, dt;
    function wt() {
    }
    wt.__reactDisabledLog = !0;
    function Ft() {
      {
        if (rt === 0) {
          ot = console.log, ft = console.info, ct = console.warn, bt = console.error, ut = console.group, gt = console.groupCollapsed, dt = console.groupEnd;
          var Lt = {
            configurable: !0,
            enumerable: !0,
            value: wt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Lt,
            log: Lt,
            warn: Lt,
            error: Lt,
            group: Lt,
            groupCollapsed: Lt,
            groupEnd: Lt
          });
        }
        rt++;
      }
    }
    function jt() {
      {
        if (rt--, rt === 0) {
          var Lt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ke({}, Lt, {
              value: ot
            }),
            info: ke({}, Lt, {
              value: ft
            }),
            warn: ke({}, Lt, {
              value: ct
            }),
            error: ke({}, Lt, {
              value: bt
            }),
            group: ke({}, Lt, {
              value: ut
            }),
            groupCollapsed: ke({}, Lt, {
              value: gt
            }),
            groupEnd: ke({}, Lt, {
              value: dt
            })
          });
        }
        rt < 0 && ht("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Nt = pt.ReactCurrentDispatcher, Bt;
    function Rt(Lt, Zt, tr) {
      {
        if (Bt === void 0)
          try {
            throw Error();
          } catch (gr) {
            var fr = gr.stack.trim().match(/\n( *(at )?)/);
            Bt = fr && fr[1] || "";
          }
        return `
` + Bt + Lt;
      }
    }
    var Ut = !1, zt;
    {
      var Mt = typeof WeakMap == "function" ? WeakMap : Map;
      zt = new Mt();
    }
    function kt(Lt, Zt) {
      if (!Lt || Ut)
        return "";
      {
        var tr = zt.get(Lt);
        if (tr !== void 0)
          return tr;
      }
      var fr;
      Ut = !0;
      var gr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Er;
      Er = Nt.current, Nt.current = null, Ft();
      try {
        if (Zt) {
          var Ir = function() {
            throw Error();
          };
          if (Object.defineProperty(Ir.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ir, []);
            } catch (Lr) {
              fr = Lr;
            }
            Reflect.construct(Lt, [], Ir);
          } else {
            try {
              Ir.call();
            } catch (Lr) {
              fr = Lr;
            }
            Lt.call(Ir.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Lr) {
            fr = Lr;
          }
          Lt();
        }
      } catch (Lr) {
        if (Lr && fr && typeof Lr.stack == "string") {
          for (var Br = Lr.stack.split(`
`), Ur = fr.stack.split(`
`), Fr = Br.length - 1, Dr = Ur.length - 1; Fr >= 1 && Dr >= 0 && Br[Fr] !== Ur[Dr]; )
            Dr--;
          for (; Fr >= 1 && Dr >= 0; Fr--, Dr--)
            if (Br[Fr] !== Ur[Dr]) {
              if (Fr !== 1 || Dr !== 1)
                do
                  if (Fr--, Dr--, Dr < 0 || Br[Fr] !== Ur[Dr]) {
                    var Hr = `
` + Br[Fr].replace(" at new ", " at ");
                    return Lt.displayName && Hr.includes("<anonymous>") && (Hr = Hr.replace("<anonymous>", Lt.displayName)), typeof Lt == "function" && zt.set(Lt, Hr), Hr;
                  }
                while (Fr >= 1 && Dr >= 0);
              break;
            }
        }
      } finally {
        Ut = !1, Nt.current = Er, jt(), Error.prepareStackTrace = gr;
      }
      var Wr = Lt ? Lt.displayName || Lt.name : "", jr = Wr ? Rt(Wr) : "";
      return typeof Lt == "function" && zt.set(Lt, jr), jr;
    }
    function Gt(Lt, Zt, tr) {
      return kt(Lt, !1);
    }
    function Qt(Lt) {
      var Zt = Lt.prototype;
      return !!(Zt && Zt.isReactComponent);
    }
    function nr(Lt, Zt, tr) {
      if (Lt == null)
        return "";
      if (typeof Lt == "function")
        return kt(Lt, Qt(Lt));
      if (typeof Lt == "string")
        return Rt(Lt);
      switch (Lt) {
        case pe:
          return Rt("Suspense");
        case ne:
          return Rt("SuspenseList");
      }
      if (typeof Lt == "object")
        switch (Lt.$$typeof) {
          case oe:
            return Gt(Lt.render);
          case ce:
            return nr(Lt.type, Zt, tr);
          case Ce: {
            var fr = Lt, gr = fr._payload, Er = fr._init;
            try {
              return nr(Er(gr), Zt, tr);
            } catch {
            }
          }
        }
      return "";
    }
    var ar = Object.prototype.hasOwnProperty, cr = {}, hr = pt.ReactDebugCurrentFrame;
    function Jt(Lt) {
      if (Lt) {
        var Zt = Lt._owner, tr = nr(Lt.type, Lt._source, Zt ? Zt.type : null);
        hr.setExtraStackFrame(tr);
      } else
        hr.setExtraStackFrame(null);
    }
    function Pr(Lt, Zt, tr, fr, gr) {
      {
        var Er = Function.call.bind(ar);
        for (var Ir in Lt)
          if (Er(Lt, Ir)) {
            var Br = void 0;
            try {
              if (typeof Lt[Ir] != "function") {
                var Ur = Error((fr || "React class") + ": " + tr + " type `" + Ir + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Lt[Ir] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ur.name = "Invariant Violation", Ur;
              }
              Br = Lt[Ir](Zt, Ir, fr, tr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Fr) {
              Br = Fr;
            }
            Br && !(Br instanceof Error) && (Jt(gr), ht("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", fr || "React class", tr, Ir, typeof Br), Jt(null)), Br instanceof Error && !(Br.message in cr) && (cr[Br.message] = !0, Jt(gr), ht("Failed %s type: %s", tr, Br.message), Jt(null));
          }
      }
    }
    var dr = Array.isArray;
    function Tr(Lt) {
      return dr(Lt);
    }
    function Rr(Lt) {
      {
        var Zt = typeof Symbol == "function" && Symbol.toStringTag, tr = Zt && Lt[Symbol.toStringTag] || Lt.constructor.name || "Object";
        return tr;
      }
    }
    function pr(Lt) {
      try {
        return $r(Lt), !1;
      } catch {
        return !0;
      }
    }
    function $r(Lt) {
      return "" + Lt;
    }
    function kr(Lt) {
      if (pr(Lt))
        return ht("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Rr(Lt)), $r(Lt);
    }
    var vr = pt.ReactCurrentOwner, Mr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Nr, Pt, mt;
    mt = {};
    function At(Lt) {
      if (ar.call(Lt, "ref")) {
        var Zt = Object.getOwnPropertyDescriptor(Lt, "ref").get;
        if (Zt && Zt.isReactWarning)
          return !1;
      }
      return Lt.ref !== void 0;
    }
    function qt(Lt) {
      if (ar.call(Lt, "key")) {
        var Zt = Object.getOwnPropertyDescriptor(Lt, "key").get;
        if (Zt && Zt.isReactWarning)
          return !1;
      }
      return Lt.key !== void 0;
    }
    function Kt(Lt, Zt) {
      if (typeof Lt.ref == "string" && vr.current && Zt && vr.current.stateNode !== Zt) {
        var tr = it(vr.current.type);
        mt[tr] || (ht('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', it(vr.current.type), Lt.ref), mt[tr] = !0);
      }
    }
    function Vt(Lt, Zt) {
      {
        var tr = function() {
          Nr || (Nr = !0, ht("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Zt));
        };
        tr.isReactWarning = !0, Object.defineProperty(Lt, "key", {
          get: tr,
          configurable: !0
        });
      }
    }
    function Xt(Lt, Zt) {
      {
        var tr = function() {
          Pt || (Pt = !0, ht("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Zt));
        };
        tr.isReactWarning = !0, Object.defineProperty(Lt, "ref", {
          get: tr,
          configurable: !0
        });
      }
    }
    var yr = function(Lt, Zt, tr, fr, gr, Er, Ir) {
      var Br = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: L,
        // Built-in properties that belong on the element
        type: Lt,
        key: Zt,
        ref: tr,
        props: Ir,
        // Record the component responsible for creating this element.
        _owner: Er
      };
      return Br._store = {}, Object.defineProperty(Br._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Br, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: fr
      }), Object.defineProperty(Br, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: gr
      }), Object.freeze && (Object.freeze(Br.props), Object.freeze(Br)), Br;
    };
    function Ar(Lt, Zt, tr, fr, gr) {
      {
        var Er, Ir = {}, Br = null, Ur = null;
        tr !== void 0 && (kr(tr), Br = "" + tr), qt(Zt) && (kr(Zt.key), Br = "" + Zt.key), At(Zt) && (Ur = Zt.ref, Kt(Zt, gr));
        for (Er in Zt)
          ar.call(Zt, Er) && !Mr.hasOwnProperty(Er) && (Ir[Er] = Zt[Er]);
        if (Lt && Lt.defaultProps) {
          var Fr = Lt.defaultProps;
          for (Er in Fr)
            Ir[Er] === void 0 && (Ir[Er] = Fr[Er]);
        }
        if (Br || Ur) {
          var Dr = typeof Lt == "function" ? Lt.displayName || Lt.name || "Unknown" : Lt;
          Br && Vt(Ir, Dr), Ur && Xt(Ir, Dr);
        }
        return yr(Lt, Br, Ur, gr, fr, vr.current, Ir);
      }
    }
    var lr = pt.ReactCurrentOwner, xr = pt.ReactDebugCurrentFrame;
    function wr(Lt) {
      if (Lt) {
        var Zt = Lt._owner, tr = nr(Lt.type, Lt._source, Zt ? Zt.type : null);
        xr.setExtraStackFrame(tr);
      } else
        xr.setExtraStackFrame(null);
    }
    var Sr;
    Sr = !1;
    function Or(Lt) {
      return typeof Lt == "object" && Lt !== null && Lt.$$typeof === L;
    }
    function qr() {
      {
        if (lr.current) {
          var Lt = it(lr.current.type);
          if (Lt)
            return `

Check the render method of \`` + Lt + "`.";
        }
        return "";
      }
    }
    function Dt(Lt) {
      return "";
    }
    var Ot = {};
    function Ht(Lt) {
      {
        var Zt = qr();
        if (!Zt) {
          var tr = typeof Lt == "string" ? Lt : Lt.displayName || Lt.name;
          tr && (Zt = `

Check the top-level render call using <` + tr + ">.");
        }
        return Zt;
      }
    }
    function Wt(Lt, Zt) {
      {
        if (!Lt._store || Lt._store.validated || Lt.key != null)
          return;
        Lt._store.validated = !0;
        var tr = Ht(Zt);
        if (Ot[tr])
          return;
        Ot[tr] = !0;
        var fr = "";
        Lt && Lt._owner && Lt._owner !== lr.current && (fr = " It was passed a child from " + it(Lt._owner.type) + "."), wr(Lt), ht('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', tr, fr), wr(null);
      }
    }
    function Yt(Lt, Zt) {
      {
        if (typeof Lt != "object")
          return;
        if (Tr(Lt))
          for (var tr = 0; tr < Lt.length; tr++) {
            var fr = Lt[tr];
            Or(fr) && Wt(fr, Zt);
          }
        else if (Or(Lt))
          Lt._store && (Lt._store.validated = !0);
        else if (Lt) {
          var gr = lt(Lt);
          if (typeof gr == "function" && gr !== Lt.entries)
            for (var Er = gr.call(Lt), Ir; !(Ir = Er.next()).done; )
              Or(Ir.value) && Wt(Ir.value, Zt);
        }
      }
    }
    function er(Lt) {
      {
        var Zt = Lt.type;
        if (Zt == null || typeof Zt == "string")
          return;
        var tr;
        if (typeof Zt == "function")
          tr = Zt.propTypes;
        else if (typeof Zt == "object" && (Zt.$$typeof === oe || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Zt.$$typeof === ce))
          tr = Zt.propTypes;
        else
          return;
        if (tr) {
          var fr = it(Zt);
          Pr(tr, Lt.props, "prop", fr, Lt);
        } else if (Zt.PropTypes !== void 0 && !Sr) {
          Sr = !0;
          var gr = it(Zt);
          ht("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", gr || "Unknown");
        }
        typeof Zt.getDefaultProps == "function" && !Zt.getDefaultProps.isReactClassApproved && ht("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function rr(Lt) {
      {
        for (var Zt = Object.keys(Lt.props), tr = 0; tr < Zt.length; tr++) {
          var fr = Zt[tr];
          if (fr !== "children" && fr !== "key") {
            wr(Lt), ht("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", fr), wr(null);
            break;
          }
        }
        Lt.ref !== null && (wr(Lt), ht("Invalid attribute `ref` supplied to `React.Fragment`."), wr(null));
      }
    }
    var ir = {};
    function ur(Lt, Zt, tr, fr, gr, Er) {
      {
        var Ir = It(Lt);
        if (!Ir) {
          var Br = "";
          (Lt === void 0 || typeof Lt == "object" && Lt !== null && Object.keys(Lt).length === 0) && (Br += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ur = Dt();
          Ur ? Br += Ur : Br += qr();
          var Fr;
          Lt === null ? Fr = "null" : Tr(Lt) ? Fr = "array" : Lt !== void 0 && Lt.$$typeof === L ? (Fr = "<" + (it(Lt.type) || "Unknown") + " />", Br = " Did you accidentally export a JSX literal instead of a component?") : Fr = typeof Lt, ht("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Fr, Br);
        }
        var Dr = Ar(Lt, Zt, tr, gr, Er);
        if (Dr == null)
          return Dr;
        if (Ir) {
          var Hr = Zt.children;
          if (Hr !== void 0)
            if (fr)
              if (Tr(Hr)) {
                for (var Wr = 0; Wr < Hr.length; Wr++)
                  Yt(Hr[Wr], Lt);
                Object.freeze && Object.freeze(Hr);
              } else
                ht("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Yt(Hr, Lt);
        }
        if (ar.call(Zt, "key")) {
          var jr = it(Lt), Lr = Object.keys(Zt).filter(function(Vr) {
            return Vr !== "key";
          }), Gr = Lr.length > 0 ? "{key: someKey, " + Lr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ir[jr + Gr]) {
            var zr = Lr.length > 0 ? "{" + Lr.join(": ..., ") + ": ...}" : "{}";
            ht(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Gr, jr, zr, jr), ir[jr + Gr] = !0;
          }
        }
        return Lt === K ? rr(Dr) : er(Dr), Dr;
      }
    }
    function sr(Lt, Zt, tr) {
      return ur(Lt, Zt, tr, !0);
    }
    function br(Lt, Zt, tr) {
      return ur(Lt, Zt, tr, !1);
    }
    var _r = br, or = sr;
    reactJsxRuntime_development.Fragment = K, reactJsxRuntime_development.jsx = _r, reactJsxRuntime_development.jsxs = or;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, L] = useState(!1);
  return useEffect(() => {
    L(!0);
  }, []), B;
}
const KEY_PREFIX = "wallie";
function isBrowser() {
  return typeof window < "u";
}
function getItemFromLocalStorage(B) {
  if (!isBrowser())
    return null;
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${B}`;
  try {
    const W = window.localStorage.getItem(L);
    return W != null ? JSON.parse(W) : null;
  } catch (W) {
    return console.error(`Error retrieving ${L} from localStorage`, W), null;
  }
}
function setItemToLocalStorage(B, L) {
  if (!isBrowser())
    return;
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const W = `${KEY_PREFIX}_${B}`;
  try {
    L ? window.localStorage.setItem(W, JSON.stringify(L)) : window.localStorage.removeItem(W);
  } catch (K) {
    console.error(`Error saving ${W} to localStorage`, K);
  }
}
function useLocalStorage(B, L, W = {}) {
  const { initializeWithValue: K = !0 } = W, J = useCallback(() => {
    const oe = getItemFromLocalStorage(B);
    return oe || (setItemToLocalStorage(B, L), L);
  }, [L, B]), [V, re] = useState(() => K ? J() : L), ie = useCallback(
    (oe) => {
      setItemToLocalStorage(B, oe), re(oe);
    },
    [B]
  );
  return useEffect(() => {
    re(J());
  }, [B]), [V, ie];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, WallieContext = createContext(void 0), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function WallieProvider({
  children: B,
  initialNetwork: L,
  ssr: W = !1
}) {
  if (!L)
    throw new Error("Initial network cannot be empty");
  const [K, J] = useState(L), [V, re] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !W }
  ), [ie, oe] = useLocalStorage(WALLET, null, {
    initializeWithValue: !W
  }), [pe, ne] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !W }
  ), [ce, Ce] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !W }
  ), [Oe, st] = useState(!1), at = useCallback(() => st(!0), []), lt = useCallback(() => st(!1), []), pt = useCallback(() => {
    re(EMPTY_BIADDRESS_OBJECT), ne(EMPTY_BIADDRESS_OBJECT), Ce(EMPTY_BIADDRESS_OBJECT), oe(null);
  }, [re, Ce, ne, oe]), ht = useMemo(
    () => ({
      address: V,
      updateAddress: re,
      publicKey: pe,
      updatePublicKey: ne,
      network: K,
      updateNetwork: J,
      wallet: ie,
      updateWallet: oe,
      isModalOpen: Oe,
      openModal: at,
      closeModal: lt,
      format: ce,
      updateFormat: Ce,
      disconnectWallet: pt
    }),
    [
      V,
      re,
      pe,
      ne,
      K,
      J,
      ie,
      oe,
      Oe,
      at,
      lt,
      ce,
      Ce,
      pt
    ]
  );
  return useEffect(() => {
    J(L);
  }, [L]), /* @__PURE__ */ jsxRuntimeExports.jsx(WallieContext.Provider, { value: ht, children: B });
}
function useWallie() {
  const B = useContext(WallieContext);
  if (!B)
    throw new Error("useWallie must be used within WallieProvider");
  return B;
}
var i$7 = Object.defineProperty, d$6 = (B, L, W) => L in B ? i$7(B, L, { enumerable: !0, configurable: !0, writable: !0, value: W }) : B[L] = W, r$4 = (B, L, W) => (d$6(B, typeof L != "symbol" ? L + "" : L, W), W);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(L) {
    this.current !== L && (this.handoffState = "pending", this.currentId = 0, this.current = L);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$6 = (B, L) => {
  s$a.isServer ? useEffect(B, L) : useLayoutEffect(B, L);
};
function s$9(B) {
  let L = useRef(B);
  return l$6(() => {
    L.current = B;
  }, [B]), L;
}
let o$6 = function(B) {
  let L = s$9(B);
  return C__default.useCallback((...W) => L.current(...W), [L]);
};
function t$8(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((L) => setTimeout(() => {
    throw L;
  }));
}
function o$5() {
  let B = [], L = { addEventListener(W, K, J, V) {
    return W.addEventListener(K, J, V), L.add(() => W.removeEventListener(K, J, V));
  }, requestAnimationFrame(...W) {
    let K = requestAnimationFrame(...W);
    return L.add(() => cancelAnimationFrame(K));
  }, nextFrame(...W) {
    return L.requestAnimationFrame(() => L.requestAnimationFrame(...W));
  }, setTimeout(...W) {
    let K = setTimeout(...W);
    return L.add(() => clearTimeout(K));
  }, microTask(...W) {
    let K = { current: !0 };
    return t$8(() => {
      K.current && W[0]();
    }), L.add(() => {
      K.current = !1;
    });
  }, style(W, K, J) {
    let V = W.style.getPropertyValue(K);
    return Object.assign(W.style, { [K]: J }), this.add(() => {
      Object.assign(W.style, { [K]: V });
    });
  }, group(W) {
    let K = o$5();
    return W(K), this.add(() => K.dispose());
  }, add(W) {
    return B.push(W), () => {
      let K = B.indexOf(W);
      if (K >= 0) for (let J of B.splice(K, 1)) J();
    };
  }, dispose() {
    for (let W of B.splice(0)) W();
  } };
  return L;
}
function p$4() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
function s$8() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in C$3 ? ((L) => L.useSyncExternalStore)(C$3)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$5() {
  let B = s$8(), [L, W] = C$3.useState(s$a.isHandoffComplete);
  return L && s$a.isHandoffComplete === !1 && W(!1), C$3.useEffect(() => {
    L !== !0 && W(!0);
  }, [L]), C$3.useEffect(() => s$a.handoff(), []), B ? !1 : L;
}
var o$4;
let I$6 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let B = l$5(), [L, W] = C__default.useState(B ? () => s$a.nextId() : null);
  return l$6(() => {
    L === null && W(s$a.nextId());
  }, [L]), L != null ? "" + L : void 0;
};
function u$7(B, L, ...W) {
  if (B in L) {
    let J = L[B];
    return typeof J == "function" ? J(...W) : J;
  }
  let K = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(L).map((J) => `"${J}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(K, u$7), K;
}
function o$3(B) {
  return s$a.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
let c$6 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var M$2 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B))(M$2 || {}), N$2 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(N$2 || {}), F$3 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(F$3 || {});
function f$7(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(c$6)).sort((L, W) => Math.sign((L.tabIndex || Number.MAX_SAFE_INTEGER) - (W.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(T$2 || {});
function h$6(B, L = 0) {
  var W;
  return B === ((W = o$3(B)) == null ? void 0 : W.body) ? !1 : u$7(L, { 0() {
    return B.matches(c$6);
  }, 1() {
    let K = B;
    for (; K !== null; ) {
      if (K.matches(c$6)) return !0;
      K = K.parentElement;
    }
    return !1;
  } });
}
function D$3(B) {
  let L = o$3(B);
  o$5().nextFrame(() => {
    L && !h$6(L.activeElement, 0) && y$4(B);
  });
}
var w$3 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(w$3 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$4(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(B) {
  var L, W;
  return (W = (L = B == null ? void 0 : B.matches) == null ? void 0 : L.call(B, S$5)) != null ? W : !1;
}
function I$5(B, L = (W) => W) {
  return B.slice().sort((W, K) => {
    let J = L(W), V = L(K);
    if (J === null || V === null) return 0;
    let re = J.compareDocumentPosition(V);
    return re & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : re & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$3(B, L) {
  return O$2(f$7(), L, { relativeTo: B });
}
function O$2(B, L, { sorted: W = !0, relativeTo: K = null, skipElements: J = [] } = {}) {
  let V = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, re = Array.isArray(B) ? W ? I$5(B) : B : f$7(B);
  J.length > 0 && re.length > 1 && (re = re.filter((Oe) => !J.includes(Oe))), K = K ?? V.activeElement;
  let ie = (() => {
    if (L & 5) return 1;
    if (L & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), oe = (() => {
    if (L & 1) return 0;
    if (L & 2) return Math.max(0, re.indexOf(K)) - 1;
    if (L & 4) return Math.max(0, re.indexOf(K)) + 1;
    if (L & 8) return re.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), pe = L & 32 ? { preventScroll: !0 } : {}, ne = 0, ce = re.length, Ce;
  do {
    if (ne >= ce || ne + ce <= 0) return 0;
    let Oe = oe + ne;
    if (L & 16) Oe = (Oe + ce) % ce;
    else {
      if (Oe < 0) return 3;
      if (Oe >= ce) return 1;
    }
    Ce = re[Oe], Ce == null || Ce.focus(pe), ne += ie;
  } while (Ce !== V.activeElement);
  return L & 6 && H(Ce) && Ce.select(), 2;
}
function t$7() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$4() {
  return t$7() || i$6();
}
function d$5(B, L, W) {
  let K = s$9(L);
  useEffect(() => {
    function J(V) {
      K.current(V);
    }
    return document.addEventListener(B, J, W), () => document.removeEventListener(B, J, W);
  }, [B, W]);
}
function s$7(B, L, W) {
  let K = s$9(L);
  useEffect(() => {
    function J(V) {
      K.current(V);
    }
    return window.addEventListener(B, J, W), () => window.removeEventListener(B, J, W);
  }, [B, W]);
}
function y$3(B, L, W = !0) {
  let K = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      K.current = W;
    });
  }, [W]);
  function J(re, ie) {
    if (!K.current || re.defaultPrevented) return;
    let oe = ie(re);
    if (oe === null || !oe.getRootNode().contains(oe) || !oe.isConnected) return;
    let pe = function ne(ce) {
      return typeof ce == "function" ? ne(ce()) : Array.isArray(ce) || ce instanceof Set ? ce : [ce];
    }(B);
    for (let ne of pe) {
      if (ne === null) continue;
      let ce = ne instanceof HTMLElement ? ne : ne.current;
      if (ce != null && ce.contains(oe) || re.composed && re.composedPath().includes(ce)) return;
    }
    return !h$6(oe, T$2.Loose) && oe.tabIndex !== -1 && re.preventDefault(), L(re, oe);
  }
  let V = useRef(null);
  d$5("pointerdown", (re) => {
    var ie, oe;
    K.current && (V.current = ((oe = (ie = re.composedPath) == null ? void 0 : ie.call(re)) == null ? void 0 : oe[0]) || re.target);
  }, !0), d$5("mousedown", (re) => {
    var ie, oe;
    K.current && (V.current = ((oe = (ie = re.composedPath) == null ? void 0 : ie.call(re)) == null ? void 0 : oe[0]) || re.target);
  }, !0), d$5("click", (re) => {
    n$4() || V.current && (J(re, () => V.current), V.current = null);
  }, !0), d$5("touchend", (re) => J(re, () => re.target instanceof HTMLElement ? re.target : null), !0), s$7("blur", (re) => J(re, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$3(...B) {
  return useMemo(() => o$3(...B), [...B]);
}
function i$5(B) {
  var L;
  if (B.type) return B.type;
  let W = (L = B.as) != null ? L : "button";
  if (typeof W == "string" && W.toLowerCase() === "button") return "button";
}
function T$1(B, L) {
  let [W, K] = useState(() => i$5(B));
  return l$6(() => {
    K(i$5(B));
  }, [B.type, B.as]), l$6(() => {
    W || L.current && L.current instanceof HTMLButtonElement && !L.current.hasAttribute("type") && K("button");
  }, [W, L]), W;
}
let u$6 = Symbol();
function T(B, L = !0) {
  return Object.assign(B, { [u$6]: L });
}
function y$2(...B) {
  let L = useRef(B);
  useEffect(() => {
    L.current = B;
  }, [B]);
  let W = o$6((K) => {
    for (let J of L.current) J != null && (typeof J == "function" ? J(K) : J.current = K);
  });
  return B.every((K) => K == null || (K == null ? void 0 : K[u$6])) ? void 0 : W;
}
function t$6(B) {
  return [B.screenX, B.screenY];
}
function u$5() {
  let B = useRef([-1, -1]);
  return { wasMoved(L) {
    let W = t$6(L);
    return B.current[0] === W[0] && B.current[1] === W[1] ? !1 : (B.current = W, !0);
  }, update(L) {
    B.current = t$6(L);
  } };
}
function F$2({ container: B, accept: L, walk: W, enabled: K = !0 }) {
  let J = useRef(L), V = useRef(W);
  useEffect(() => {
    J.current = L, V.current = W;
  }, [L, W]), l$6(() => {
    if (!B || !K) return;
    let re = o$3(B);
    if (!re) return;
    let ie = J.current, oe = V.current, pe = Object.assign((ce) => ie(ce), { acceptNode: ie }), ne = re.createTreeWalker(B, NodeFilter.SHOW_ELEMENT, pe, !1);
    for (; ne.nextNode(); ) oe(ne.currentNode);
  }, [B, K, J, V]);
}
function m$3(B, L) {
  let W = useRef([]), K = o$6(B);
  useEffect(() => {
    let J = [...W.current];
    for (let [V, re] of L.entries()) if (W.current[V] !== re) {
      let ie = K(L, J);
      return W.current = L, ie;
    }
  }, [K, ...L]);
}
function t$5(...B) {
  return Array.from(new Set(B.flatMap((L) => typeof L == "string" ? L.split(" ") : []))).filter(Boolean).join(" ");
}
var O$1 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$1 || {}), v$2 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(v$2 || {});
function C$2({ ourProps: B, theirProps: L, slot: W, defaultTag: K, features: J, visible: V = !0, name: re, mergeRefs: ie }) {
  ie = ie ?? k$1;
  let oe = R(L, B);
  if (V) return m$2(oe, W, K, re, ie);
  let pe = J ?? 0;
  if (pe & 2) {
    let { static: ne = !1, ...ce } = oe;
    if (ne) return m$2(ce, W, K, re, ie);
  }
  if (pe & 1) {
    let { unmount: ne = !0, ...ce } = oe;
    return u$7(ne ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$2({ ...ce, hidden: !0, style: { display: "none" } }, W, K, re, ie);
    } });
  }
  return m$2(oe, W, K, re, ie);
}
function m$2(B, L = {}, W, K, J) {
  let { as: V = W, children: re, refName: ie = "ref", ...oe } = F$1(B, ["unmount", "static"]), pe = B.ref !== void 0 ? { [ie]: B.ref } : {}, ne = typeof re == "function" ? re(L) : re;
  "className" in oe && oe.className && typeof oe.className == "function" && (oe.className = oe.className(L));
  let ce = {};
  if (L) {
    let Ce = !1, Oe = [];
    for (let [st, at] of Object.entries(L)) typeof at == "boolean" && (Ce = !0), at === !0 && Oe.push(st);
    Ce && (ce["data-headlessui-state"] = Oe.join(" "));
  }
  if (V === Fragment && Object.keys(x$2(oe)).length > 0) {
    if (!isValidElement(ne) || Array.isArray(ne) && ne.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${K} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(oe).map((at) => `  - ${at}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((at) => `  - ${at}`).join(`
`)].join(`
`));
    let Ce = ne.props, Oe = typeof (Ce == null ? void 0 : Ce.className) == "function" ? (...at) => t$5(Ce == null ? void 0 : Ce.className(...at), oe.className) : t$5(Ce == null ? void 0 : Ce.className, oe.className), st = Oe ? { className: Oe } : {};
    return cloneElement(ne, Object.assign({}, R(ne.props, x$2(F$1(oe, ["ref"]))), ce, pe, { ref: J(ne.ref, pe.ref) }, st));
  }
  return createElement(V, Object.assign({}, F$1(oe, ["ref"]), V !== Fragment && pe, V !== Fragment && ce), ne);
}
function k$1(...B) {
  return B.every((L) => L == null) ? void 0 : (L) => {
    for (let W of B) W != null && (typeof W == "function" ? W(L) : W.current = L);
  };
}
function R(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let L = {}, W = {};
  for (let K of B) for (let J in K) J.startsWith("on") && typeof K[J] == "function" ? (W[J] != null || (W[J] = []), W[J].push(K[J])) : L[J] = K[J];
  if (L.disabled || L["aria-disabled"]) return Object.assign(L, Object.fromEntries(Object.keys(W).map((K) => [K, void 0])));
  for (let K in W) Object.assign(L, { [K](J, ...V) {
    let re = W[K];
    for (let ie of re) {
      if ((J instanceof Event || (J == null ? void 0 : J.nativeEvent) instanceof Event) && J.defaultPrevented) return;
      ie(J, ...V);
    }
  } });
  return L;
}
function U$3(B) {
  var L;
  return Object.assign(forwardRef(B), { displayName: (L = B.displayName) != null ? L : B.name });
}
function x$2(B) {
  let L = Object.assign({}, B);
  for (let W in L) L[W] === void 0 && delete L[W];
  return L;
}
function F$1(B, L = []) {
  let W = Object.assign({}, B);
  for (let K of L) K in W && delete W[K];
  return W;
}
let p$3 = "div";
var s$6 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$6 || {});
function l$4(B, L) {
  var W;
  let { features: K = 1, ...J } = B, V = { ref: L, "aria-hidden": (K & 2) === 2 ? !0 : (W = J["aria-hidden"]) != null ? W : void 0, hidden: (K & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(K & 4) === 4 && (K & 2) !== 2 && { display: "none" } } };
  return C$2({ ourProps: V, theirProps: J, slot: {}, defaultTag: p$3, name: "Hidden" });
}
let u$4 = U$3(l$4), n$2 = createContext(null);
n$2.displayName = "OpenClosedContext";
var d$4 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(d$4 || {});
function u$3() {
  return useContext(n$2);
}
function s$5({ value: B, children: L }) {
  return C__default.createElement(n$2.Provider, { value: B }, L);
}
function t$4(B) {
  function L() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", L));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", L), L());
}
let t$3 = [];
t$4(() => {
  function B(L) {
    L.target instanceof HTMLElement && L.target !== document.body && t$3[0] !== L.target && (t$3.unshift(L.target), t$3 = t$3.filter((W) => W != null && W.isConnected), t$3.splice(10));
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function r$3(B) {
  let L = B.parentElement, W = null;
  for (; L && !(L instanceof HTMLFieldSetElement); ) L instanceof HTMLLegendElement && (W = L), L = L.parentElement;
  let K = (L == null ? void 0 : L.getAttribute("disabled")) === "";
  return K && i$4(W) ? !1 : K;
}
function i$4(B) {
  if (!B) return !1;
  let L = B.previousElementSibling;
  for (; L !== null; ) {
    if (L instanceof HTMLLegendElement) return !1;
    L = L.previousElementSibling;
  }
  return !0;
}
function u$2(B) {
  throw new Error("Unexpected object: " + B);
}
var c$5 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$5 || {});
function f$6(B, L) {
  let W = L.resolveItems();
  if (W.length <= 0) return null;
  let K = L.resolveActiveIndex(), J = K ?? -1;
  switch (B.focus) {
    case 0: {
      for (let V = 0; V < W.length; ++V) if (!L.resolveDisabled(W[V], V, W)) return V;
      return K;
    }
    case 1: {
      for (let V = J - 1; V >= 0; --V) if (!L.resolveDisabled(W[V], V, W)) return V;
      return K;
    }
    case 2: {
      for (let V = J + 1; V < W.length; ++V) if (!L.resolveDisabled(W[V], V, W)) return V;
      return K;
    }
    case 3: {
      for (let V = W.length - 1; V >= 0; --V) if (!L.resolveDisabled(W[V], V, W)) return V;
      return K;
    }
    case 4: {
      for (let V = 0; V < W.length; ++V) if (L.resolveId(W[V], V, W) === B.id) return V;
      return K;
    }
    case 5:
      return null;
    default:
      u$2(B);
  }
}
var o$2 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$2 || {});
function E$1(B, L, W, K) {
  let J = s$9(W);
  useEffect(() => {
    B = B ?? window;
    function V(re) {
      J.current(re);
    }
    return B.addEventListener(L, V, K), () => B.removeEventListener(L, V, K);
  }, [B, L, K]);
}
function f$5() {
  let B = useRef(!1);
  return l$6(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
function c$4(B) {
  let L = o$6(B), W = useRef(!1);
  useEffect(() => (W.current = !1, () => {
    W.current = !0, t$8(() => {
      W.current && L();
    });
  }), [L]);
}
var s$4 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(s$4 || {});
function n$1() {
  let B = useRef(0);
  return s$7("keydown", (L) => {
    L.key === "Tab" && (B.current = L.shiftKey ? 1 : 0);
  }, !0), B;
}
function P(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let L = /* @__PURE__ */ new Set();
  for (let W of B.current) W.current instanceof HTMLElement && L.add(W.current);
  return L;
}
let X = "div";
var _$2 = ((B) => (B[B.None = 1] = "None", B[B.InitialFocus = 2] = "InitialFocus", B[B.TabLock = 4] = "TabLock", B[B.FocusLock = 8] = "FocusLock", B[B.RestoreFocus = 16] = "RestoreFocus", B[B.All = 30] = "All", B))(_$2 || {});
function z$1(B, L) {
  let W = useRef(null), K = y$2(W, L), { initialFocus: J, containers: V, features: re = 30, ...ie } = B;
  l$5() || (re = 1);
  let oe = n$3(W);
  Y({ ownerDocument: oe }, !!(re & 16));
  let pe = Z({ ownerDocument: oe, container: W, initialFocus: J }, !!(re & 2));
  $({ ownerDocument: oe, container: W, containers: V, previousActiveElement: pe }, !!(re & 8));
  let ne = n$1(), ce = o$6((at) => {
    let lt = W.current;
    lt && ((pt) => pt())(() => {
      u$7(ne.current, { [s$4.Forwards]: () => {
        O$2(lt, M$2.First, { skipElements: [at.relatedTarget] });
      }, [s$4.Backwards]: () => {
        O$2(lt, M$2.Last, { skipElements: [at.relatedTarget] });
      } });
    });
  }), Ce = p$4(), Oe = useRef(!1), st = { ref: K, onKeyDown(at) {
    at.key == "Tab" && (Oe.current = !0, Ce.requestAnimationFrame(() => {
      Oe.current = !1;
    }));
  }, onBlur(at) {
    let lt = P(V);
    W.current instanceof HTMLElement && lt.add(W.current);
    let pt = at.relatedTarget;
    pt instanceof HTMLElement && pt.dataset.headlessuiFocusGuard !== "true" && (S$4(lt, pt) || (Oe.current ? O$2(W.current, u$7(ne.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: at.target }) : at.target instanceof HTMLElement && y$4(at.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(re & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: ce, features: s$6.Focusable }), C$2({ ourProps: st, theirProps: ie, defaultTag: X, name: "FocusTrap" }), !!(re & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: ce, features: s$6.Focusable }));
}
let D$2 = U$3(z$1), de$1 = Object.assign(D$2, { features: _$2 });
function Q(B = !0) {
  let L = useRef(t$3.slice());
  return m$3(([W], [K]) => {
    K === !0 && W === !1 && t$8(() => {
      L.current.splice(0);
    }), K === !1 && W === !0 && (L.current = t$3.slice());
  }, [B, t$3, L]), o$6(() => {
    var W;
    return (W = L.current.find((K) => K != null && K.isConnected)) != null ? W : null;
  });
}
function Y({ ownerDocument: B }, L) {
  let W = Q(L);
  m$3(() => {
    L || (B == null ? void 0 : B.activeElement) === (B == null ? void 0 : B.body) && y$4(W());
  }, [L]), c$4(() => {
    L && y$4(W());
  });
}
function Z({ ownerDocument: B, container: L, initialFocus: W }, K) {
  let J = useRef(null), V = f$5();
  return m$3(() => {
    if (!K) return;
    let re = L.current;
    re && t$8(() => {
      if (!V.current) return;
      let ie = B == null ? void 0 : B.activeElement;
      if (W != null && W.current) {
        if ((W == null ? void 0 : W.current) === ie) {
          J.current = ie;
          return;
        }
      } else if (re.contains(ie)) {
        J.current = ie;
        return;
      }
      W != null && W.current ? y$4(W.current) : O$2(re, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), J.current = B == null ? void 0 : B.activeElement;
    });
  }, [K]), J;
}
function $({ ownerDocument: B, container: L, containers: W, previousActiveElement: K }, J) {
  let V = f$5();
  E$1(B == null ? void 0 : B.defaultView, "focus", (re) => {
    if (!J || !V.current) return;
    let ie = P(W);
    L.current instanceof HTMLElement && ie.add(L.current);
    let oe = K.current;
    if (!oe) return;
    let pe = re.target;
    pe && pe instanceof HTMLElement ? S$4(ie, pe) ? (K.current = pe, y$4(pe)) : (re.preventDefault(), re.stopPropagation(), y$4(oe)) : y$4(K.current);
  }, !0);
}
function S$4(B, L) {
  for (let W of B) if (W.contains(L)) return !0;
  return !1;
}
let e$1 = createContext(!1);
function a$6() {
  return useContext(e$1);
}
function l$3(B) {
  return C__default.createElement(e$1.Provider, { value: B.force }, B.children);
}
function F(B) {
  let L = a$6(), W = useContext(_$1), K = n$3(B), [J, V] = useState(() => {
    if (!L && W !== null || s$a.isServer) return null;
    let re = K == null ? void 0 : K.getElementById("headlessui-portal-root");
    if (re) return re;
    if (K === null) return null;
    let ie = K.createElement("div");
    return ie.setAttribute("id", "headlessui-portal-root"), K.body.appendChild(ie);
  });
  return useEffect(() => {
    J !== null && (K != null && K.body.contains(J) || K == null || K.body.appendChild(J));
  }, [J, K]), useEffect(() => {
    L || W !== null && V(W.current);
  }, [W, V, L]), J;
}
let U$2 = Fragment;
function N$1(B, L) {
  let W = B, K = useRef(null), J = y$2(T((ne) => {
    K.current = ne;
  }), L), V = n$3(K), re = F(K), [ie] = useState(() => {
    var ne;
    return s$a.isServer ? null : (ne = V == null ? void 0 : V.createElement("div")) != null ? ne : null;
  }), oe = useContext(f$4), pe = l$5();
  return l$6(() => {
    !re || !ie || re.contains(ie) || (ie.setAttribute("data-headlessui-portal", ""), re.appendChild(ie));
  }, [re, ie]), l$6(() => {
    if (ie && oe) return oe.register(ie);
  }, [oe, ie]), c$4(() => {
    var ne;
    !re || !ie || (ie instanceof Node && re.contains(ie) && re.removeChild(ie), re.childNodes.length <= 0 && ((ne = re.parentElement) == null || ne.removeChild(re)));
  }), pe ? !re || !ie ? null : createPortal(C$2({ ourProps: { ref: J }, theirProps: W, defaultTag: U$2, name: "Portal" }), ie) : null;
}
let S$3 = Fragment, _$1 = createContext(null);
function j(B, L) {
  let { target: W, ...K } = B, J = { ref: y$2(L) };
  return C__default.createElement(_$1.Provider, { value: W }, C$2({ ourProps: J, theirProps: K, defaultTag: S$3, name: "Popover.Group" }));
}
let f$4 = createContext(null);
function ee() {
  let B = useContext(f$4), L = useRef([]), W = o$6((V) => (L.current.push(V), B && B.register(V), () => K(V))), K = o$6((V) => {
    let re = L.current.indexOf(V);
    re !== -1 && L.current.splice(re, 1), B && B.unregister(V);
  }), J = useMemo(() => ({ register: W, unregister: K, portals: L }), [W, K, L]);
  return [L, useMemo(() => function({ children: V }) {
    return C__default.createElement(f$4.Provider, { value: J }, V);
  }, [J])];
}
let D$1 = U$3(N$1), I$4 = U$3(j), te = Object.assign(D$1, { Group: I$4 });
function i$3(B, L) {
  return B === L && (B !== 0 || 1 / B === 1 / L) || B !== B && L !== L;
}
const d$3 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$5, useLayoutEffect: f$3, useDebugValue: p$2 } = C$3;
function y$1(B, L, W) {
  const K = L(), [{ inst: J }, V] = u$1({ inst: { value: K, getSnapshot: L } });
  return f$3(() => {
    J.value = K, J.getSnapshot = L, r$2(J) && V({ inst: J });
  }, [B, K, L]), h$5(() => (r$2(J) && V({ inst: J }), B(() => {
    r$2(J) && V({ inst: J });
  })), [B]), p$2(K), K;
}
function r$2(B) {
  const L = B.getSnapshot, W = B.value;
  try {
    const K = L();
    return !d$3(W, K);
  } catch {
    return !0;
  }
}
function t$2(B, L, W) {
  return L();
}
const r$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$3 = !r$1, c$3 = s$3 ? t$2 : y$1, a$5 = "useSyncExternalStore" in C$3 ? ((B) => B.useSyncExternalStore)(C$3) : c$3;
function S$2(B) {
  return a$5(B.subscribe, B.getSnapshot, B.getSnapshot);
}
function a$4(B, L) {
  let W = B(), K = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return W;
  }, subscribe(J) {
    return K.add(J), () => K.delete(J);
  }, dispatch(J, ...V) {
    let re = L[J].call(W, ...V);
    re && (W = re, K.forEach((ie) => ie()));
  } };
}
function c$2() {
  let B;
  return { before({ doc: L }) {
    var W;
    let K = L.documentElement;
    B = ((W = L.defaultView) != null ? W : window).innerWidth - K.clientWidth;
  }, after({ doc: L, d: W }) {
    let K = L.documentElement, J = K.clientWidth - K.offsetWidth, V = B - J;
    W.style(K, "paddingRight", `${V}px`);
  } };
}
function d$2() {
  return t$7() ? { before({ doc: B, d: L, meta: W }) {
    function K(J) {
      return W.containers.flatMap((V) => V()).some((V) => V.contains(J));
    }
    L.microTask(() => {
      var J;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let ie = o$5();
        ie.style(B.documentElement, "scrollBehavior", "auto"), L.add(() => L.microTask(() => ie.dispose()));
      }
      let V = (J = window.scrollY) != null ? J : window.pageYOffset, re = null;
      L.addEventListener(B, "click", (ie) => {
        if (ie.target instanceof HTMLElement) try {
          let oe = ie.target.closest("a");
          if (!oe) return;
          let { hash: pe } = new URL(oe.href), ne = B.querySelector(pe);
          ne && !K(ne) && (re = ne);
        } catch {
        }
      }, !0), L.addEventListener(B, "touchstart", (ie) => {
        if (ie.target instanceof HTMLElement) if (K(ie.target)) {
          let oe = ie.target;
          for (; oe.parentElement && K(oe.parentElement); ) oe = oe.parentElement;
          L.style(oe, "overscrollBehavior", "contain");
        } else L.style(ie.target, "touchAction", "none");
      }), L.addEventListener(B, "touchmove", (ie) => {
        if (ie.target instanceof HTMLElement) if (K(ie.target)) {
          let oe = ie.target;
          for (; oe.parentElement && oe.dataset.headlessuiPortal !== "" && !(oe.scrollHeight > oe.clientHeight || oe.scrollWidth > oe.clientWidth); ) oe = oe.parentElement;
          oe.dataset.headlessuiPortal === "" && ie.preventDefault();
        } else ie.preventDefault();
      }, { passive: !1 }), L.add(() => {
        var ie;
        let oe = (ie = window.scrollY) != null ? ie : window.pageYOffset;
        V !== oe && window.scrollTo(0, V), re && re.isConnected && (re.scrollIntoView({ block: "nearest" }), re = null);
      });
    });
  } } : {};
}
function l$2() {
  return { before({ doc: B, d: L }) {
    L.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let L = {};
  for (let W of B) Object.assign(L, W(L));
  return L;
}
let a$3 = a$4(() => /* @__PURE__ */ new Map(), { PUSH(B, L) {
  var W;
  let K = (W = this.get(B)) != null ? W : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return K.count++, K.meta.add(L), this.set(B, K), this;
}, POP(B, L) {
  let W = this.get(B);
  return W && (W.count--, W.meta.delete(L)), this;
}, SCROLL_PREVENT({ doc: B, d: L, meta: W }) {
  let K = { doc: B, d: L, meta: m$1(W) }, J = [d$2(), c$2(), l$2()];
  J.forEach(({ before: V }) => V == null ? void 0 : V(K)), J.forEach(({ after: V }) => V == null ? void 0 : V(K));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$3.subscribe(() => {
  let B = a$3.getSnapshot(), L = /* @__PURE__ */ new Map();
  for (let [W] of B) L.set(W, W.documentElement.style.overflow);
  for (let W of B.values()) {
    let K = L.get(W.doc) === "hidden", J = W.count !== 0;
    (J && !K || !J && K) && a$3.dispatch(W.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", W), W.count === 0 && a$3.dispatch("TEARDOWN", W);
  }
});
function p$1(B, L, W) {
  let K = S$2(a$3), J = B ? K.get(B) : void 0, V = J ? J.count > 0 : !1;
  return l$6(() => {
    if (!(!B || !L)) return a$3.dispatch("PUSH", B, W), () => a$3.dispatch("POP", B, W);
  }, [L, B]), V;
}
let u = /* @__PURE__ */ new Map(), t$1 = /* @__PURE__ */ new Map();
function b$4(B, L = !0) {
  l$6(() => {
    var W;
    if (!L) return;
    let K = typeof B == "function" ? B() : B.current;
    if (!K) return;
    function J() {
      var re;
      if (!K) return;
      let ie = (re = t$1.get(K)) != null ? re : 1;
      if (ie === 1 ? t$1.delete(K) : t$1.set(K, ie - 1), ie !== 1) return;
      let oe = u.get(K);
      oe && (oe["aria-hidden"] === null ? K.removeAttribute("aria-hidden") : K.setAttribute("aria-hidden", oe["aria-hidden"]), K.inert = oe.inert, u.delete(K));
    }
    let V = (W = t$1.get(K)) != null ? W : 0;
    return t$1.set(K, V + 1), V !== 0 || (u.set(K, { "aria-hidden": K.getAttribute("aria-hidden"), inert: K.inert }), K.setAttribute("aria-hidden", "true"), K.inert = !0), J;
  }, [B, L]);
}
function N({ defaultContainers: B = [], portals: L, mainTreeNodeRef: W } = {}) {
  var K;
  let J = useRef((K = W == null ? void 0 : W.current) != null ? K : null), V = n$3(J), re = o$6(() => {
    var ie, oe, pe;
    let ne = [];
    for (let ce of B) ce !== null && (ce instanceof HTMLElement ? ne.push(ce) : "current" in ce && ce.current instanceof HTMLElement && ne.push(ce.current));
    if (L != null && L.current) for (let ce of L.current) ne.push(ce);
    for (let ce of (ie = V == null ? void 0 : V.querySelectorAll("html > *, body > *")) != null ? ie : []) ce !== document.body && ce !== document.head && ce instanceof HTMLElement && ce.id !== "headlessui-portal-root" && (ce.contains(J.current) || ce.contains((pe = (oe = J.current) == null ? void 0 : oe.getRootNode()) == null ? void 0 : pe.host) || ne.some((Ce) => ce.contains(Ce)) || ne.push(ce));
    return ne;
  });
  return { resolveContainers: re, contains: o$6((ie) => re().some((oe) => oe.contains(ie))), mainTreeNodeRef: J, MainTreeNode: useMemo(() => function() {
    return W != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: J });
  }, [J, W]) };
}
let a$2 = createContext(() => {
});
a$2.displayName = "StackContext";
var s$2 = ((B) => (B[B.Add = 0] = "Add", B[B.Remove = 1] = "Remove", B))(s$2 || {});
function x$1() {
  return useContext(a$2);
}
function b$3({ children: B, onUpdate: L, type: W, element: K, enabled: J }) {
  let V = x$1(), re = o$6((...ie) => {
    L == null || L(...ie), V(...ie);
  });
  return l$6(() => {
    let ie = J === void 0 || J === !0;
    return ie && re(0, W, K), () => {
      ie && re(1, W, K);
    };
  }, [re, W, K, J]), C__default.createElement(a$2.Provider, { value: re }, B);
}
let d$1 = createContext(null);
function f$2() {
  let B = useContext(d$1);
  if (B === null) {
    let L = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(L, f$2), L;
  }
  return B;
}
function w$2() {
  let [B, L] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(W) {
    let K = o$6((V) => (L((re) => [...re, V]), () => L((re) => {
      let ie = re.slice(), oe = ie.indexOf(V);
      return oe !== -1 && ie.splice(oe, 1), ie;
    }))), J = useMemo(() => ({ register: K, slot: W.slot, name: W.name, props: W.props }), [K, W.slot, W.name, W.props]);
    return C__default.createElement(d$1.Provider, { value: J }, W.children);
  }, [L])];
}
let I$3 = "p";
function S$1(B, L) {
  let W = I$6(), { id: K = `headlessui-description-${W}`, ...J } = B, V = f$2(), re = y$2(L);
  l$6(() => V.register(K), [K, V.register]);
  let ie = { ref: re, ...V.props, id: K };
  return C$2({ ourProps: ie, theirProps: J, slot: V.slot || {}, defaultTag: I$3, name: V.name || "Description" });
}
let h$4 = U$3(S$1), G = Object.assign(h$4, {});
var Me$1 = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Me$1 || {}), we = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(we || {});
let He$1 = { 0(B, L) {
  return B.titleId === L.id ? B : { ...B, titleId: L.id };
} }, I$2 = createContext(null);
I$2.displayName = "DialogContext";
function b$2(B) {
  let L = useContext(I$2);
  if (L === null) {
    let W = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(W, b$2), W;
  }
  return L;
}
function Be(B, L, W = () => [document.body]) {
  p$1(B, L, (K) => {
    var J;
    return { containers: [...(J = K.containers) != null ? J : [], W] };
  });
}
function Ge(B, L) {
  return u$7(L.type, He$1, B, L);
}
let Ne$1 = "div", Ue = O$1.RenderStrategy | O$1.Static;
function We(B, L) {
  let W = I$6(), { id: K = `headlessui-dialog-${W}`, open: J, onClose: V, initialFocus: re, role: ie = "dialog", __demoMode: oe = !1, ...pe } = B, [ne, ce] = useState(0), Ce = useRef(!1);
  ie = function() {
    return ie === "dialog" || ie === "alertdialog" ? ie : (Ce.current || (Ce.current = !0, console.warn(`Invalid role [${ie}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Oe = u$3();
  J === void 0 && Oe !== null && (J = (Oe & d$4.Open) === d$4.Open);
  let st = useRef(null), at = y$2(st, L), lt = n$3(st), pt = B.hasOwnProperty("open") || Oe !== null, ht = B.hasOwnProperty("onClose");
  if (!pt && !ht) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!pt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!ht) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof J != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${J}`);
  if (typeof V != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${V}`);
  let yt = J ? 0 : 1, [vt, $t] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), xt = o$6(() => V(!1)), Ct = o$6((Mt) => $t({ type: 0, id: Mt })), Et = l$5() ? oe ? !1 : yt === 0 : !1, St = ne > 1, It = useContext(I$2) !== null, [Tt, nt] = ee(), it = { get current() {
    var Mt;
    return (Mt = vt.panelRef.current) != null ? Mt : st.current;
  } }, { resolveContainers: ke, mainTreeNodeRef: rt, MainTreeNode: ot } = N({ portals: Tt, defaultContainers: [it] }), ft = St ? "parent" : "leaf", ct = Oe !== null ? (Oe & d$4.Closing) === d$4.Closing : !1, bt = It || ct ? !1 : Et, ut = useCallback(() => {
    var Mt, kt;
    return (kt = Array.from((Mt = lt == null ? void 0 : lt.querySelectorAll("body > *")) != null ? Mt : []).find((Gt) => Gt.id === "headlessui-portal-root" ? !1 : Gt.contains(rt.current) && Gt instanceof HTMLElement)) != null ? kt : null;
  }, [rt]);
  b$4(ut, bt);
  let gt = St ? !0 : Et, dt = useCallback(() => {
    var Mt, kt;
    return (kt = Array.from((Mt = lt == null ? void 0 : lt.querySelectorAll("[data-headlessui-portal]")) != null ? Mt : []).find((Gt) => Gt.contains(rt.current) && Gt instanceof HTMLElement)) != null ? kt : null;
  }, [rt]);
  b$4(dt, gt), y$3(ke, (Mt) => {
    Mt.preventDefault(), xt();
  }, !(!Et || St));
  let Ft = !(St || yt !== 0);
  E$1(lt == null ? void 0 : lt.defaultView, "keydown", (Mt) => {
    Ft && (Mt.defaultPrevented || Mt.key === o$2.Escape && (Mt.preventDefault(), Mt.stopPropagation(), xt()));
  }), Be(lt, !(ct || yt !== 0 || It), ke), useEffect(() => {
    if (yt !== 0 || !st.current) return;
    let Mt = new ResizeObserver((kt) => {
      for (let Gt of kt) {
        let Qt = Gt.target.getBoundingClientRect();
        Qt.x === 0 && Qt.y === 0 && Qt.width === 0 && Qt.height === 0 && xt();
      }
    });
    return Mt.observe(st.current), () => Mt.disconnect();
  }, [yt, st, xt]);
  let [Nt, Bt] = w$2(), Rt = useMemo(() => [{ dialogState: yt, close: xt, setTitleId: Ct }, vt], [yt, vt, xt, Ct]), Ut = useMemo(() => ({ open: yt === 0 }), [yt]), zt = { ref: at, id: K, role: ie, "aria-modal": yt === 0 ? !0 : void 0, "aria-labelledby": vt.titleId, "aria-describedby": Nt };
  return C__default.createElement(b$3, { type: "Dialog", enabled: yt === 0, element: st, onUpdate: o$6((Mt, kt) => {
    kt === "Dialog" && u$7(Mt, { [s$2.Add]: () => ce((Gt) => Gt + 1), [s$2.Remove]: () => ce((Gt) => Gt - 1) });
  }) }, C__default.createElement(l$3, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$2.Provider, { value: Rt }, C__default.createElement(te.Group, { target: st }, C__default.createElement(l$3, { force: !1 }, C__default.createElement(Bt, { slot: Ut, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: re, containers: ke, features: Et ? u$7(ft, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(nt, null, C$2({ ourProps: zt, theirProps: pe, slot: Ut, defaultTag: Ne$1, features: Ue, visible: yt === 0, name: "Dialog" }))))))))), C__default.createElement(ot, null));
}
let $e = "div";
function Ye(B, L) {
  let W = I$6(), { id: K = `headlessui-dialog-overlay-${W}`, ...J } = B, [{ dialogState: V, close: re }] = b$2("Dialog.Overlay"), ie = y$2(L), oe = o$6((ne) => {
    if (ne.target === ne.currentTarget) {
      if (r$3(ne.currentTarget)) return ne.preventDefault();
      ne.preventDefault(), ne.stopPropagation(), re();
    }
  }), pe = useMemo(() => ({ open: V === 0 }), [V]);
  return C$2({ ourProps: { ref: ie, id: K, "aria-hidden": !0, onClick: oe }, theirProps: J, slot: pe, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(B, L) {
  let W = I$6(), { id: K = `headlessui-dialog-backdrop-${W}`, ...J } = B, [{ dialogState: V }, re] = b$2("Dialog.Backdrop"), ie = y$2(L);
  useEffect(() => {
    if (re.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [re.panelRef]);
  let oe = useMemo(() => ({ open: V === 0 }), [V]);
  return C__default.createElement(l$3, { force: !0 }, C__default.createElement(te, null, C$2({ ourProps: { ref: ie, id: K, "aria-hidden": !0 }, theirProps: J, slot: oe, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(B, L) {
  let W = I$6(), { id: K = `headlessui-dialog-panel-${W}`, ...J } = B, [{ dialogState: V }, re] = b$2("Dialog.Panel"), ie = y$2(L, re.panelRef), oe = useMemo(() => ({ open: V === 0 }), [V]), pe = o$6((ne) => {
    ne.stopPropagation();
  });
  return C$2({ ourProps: { ref: ie, id: K, onClick: pe }, theirProps: J, slot: oe, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(B, L) {
  let W = I$6(), { id: K = `headlessui-dialog-title-${W}`, ...J } = B, [{ dialogState: V, setTitleId: re }] = b$2("Dialog.Title"), ie = y$2(L);
  useEffect(() => (re(K), () => re(null)), [K, re]);
  let oe = useMemo(() => ({ open: V === 0 }), [V]);
  return C$2({ ourProps: { ref: ie, id: K }, theirProps: J, slot: oe, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a$1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var L, W;
  let K = (L = B.innerText) != null ? L : "", J = B.cloneNode(!0);
  if (!(J instanceof HTMLElement)) return K;
  let V = !1;
  for (let ie of J.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ie.remove(), V = !0;
  let re = V ? (W = J.innerText) != null ? W : "" : K;
  return a$1.test(re) && (re = re.replace(a$1, "")), re;
}
function g$2(B) {
  let L = B.getAttribute("aria-label");
  if (typeof L == "string") return L.trim();
  let W = B.getAttribute("aria-labelledby");
  if (W) {
    let K = W.split(" ").map((J) => {
      let V = document.getElementById(J);
      if (V) {
        let re = V.getAttribute("aria-label");
        return typeof re == "string" ? re.trim() : o$1(V).trim();
      }
      return null;
    }).filter(Boolean);
    if (K.length > 0) return K.join(", ");
  }
  return o$1(B).trim();
}
function s$1(B) {
  let L = useRef(""), W = useRef("");
  return o$6(() => {
    let K = B.current;
    if (!K) return "";
    let J = K.innerText;
    if (L.current === J) return W.current;
    let V = g$2(K).trim().toLowerCase();
    return L.current = J, W.current = V, V;
  });
}
var me = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(me || {}), de = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(de || {}), fe = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B))(fe || {});
function w$1(B, L = (W) => W) {
  let W = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, K = I$5(L(B.items.slice()), (V) => V.dataRef.current.domRef.current), J = W ? K.indexOf(W) : null;
  return J === -1 && (J = null), { items: K, activeItemIndex: J };
}
let Te = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, L) => {
  var W;
  let K = w$1(B), J = f$6(L, { resolveItems: () => K.items, resolveActiveIndex: () => K.activeItemIndex, resolveId: (V) => V.id, resolveDisabled: (V) => V.dataRef.current.disabled });
  return { ...B, ...K, searchQuery: "", activeItemIndex: J, activationTrigger: (W = L.trigger) != null ? W : 1 };
}, 3: (B, L) => {
  let W = B.searchQuery !== "" ? 0 : 1, K = B.searchQuery + L.value.toLowerCase(), J = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + W).concat(B.items.slice(0, B.activeItemIndex + W)) : B.items).find((re) => {
    var ie;
    return ((ie = re.dataRef.current.textValue) == null ? void 0 : ie.startsWith(K)) && !re.dataRef.current.disabled;
  }), V = J ? B.items.indexOf(J) : -1;
  return V === -1 || V === B.activeItemIndex ? { ...B, searchQuery: K } : { ...B, searchQuery: K, activeItemIndex: V, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, L) => {
  let W = w$1(B, (K) => [...K, { id: L.id, dataRef: L.dataRef }]);
  return { ...B, ...W };
}, 6: (B, L) => {
  let W = w$1(B, (K) => {
    let J = K.findIndex((V) => V.id === L.id);
    return J !== -1 && K.splice(J, 1), K;
  });
  return { ...B, ...W, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C$1(B) {
  let L = useContext(U$1);
  if (L === null) {
    let W = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(W, C$1), W;
  }
  return L;
}
function ye$1(B, L) {
  return u$7(L.type, Te, B, L);
}
let Ie = Fragment;
function Me(B, L) {
  let { __demoMode: W = !1, ...K } = B, J = useReducer(ye$1, { __demoMode: W, menuState: W ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: V, itemsRef: re, buttonRef: ie }, oe] = J, pe = y$2(L);
  y$3([ie, re], (Oe, st) => {
    var at;
    oe({ type: 1 }), h$6(st, T$2.Loose) || (Oe.preventDefault(), (at = ie.current) == null || at.focus());
  }, V === 0);
  let ne = o$6(() => {
    oe({ type: 1 });
  }), ce = useMemo(() => ({ open: V === 0, close: ne }), [V, ne]), Ce = { ref: pe };
  return C__default.createElement(U$1.Provider, { value: J }, C__default.createElement(s$5, { value: u$7(V, { 0: d$4.Open, 1: d$4.Closed }) }, C$2({ ourProps: Ce, theirProps: K, slot: ce, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(B, L) {
  var W;
  let K = I$6(), { id: J = `headlessui-menu-button-${K}`, ...V } = B, [re, ie] = C$1("Menu.Button"), oe = y$2(re.buttonRef, L), pe = p$4(), ne = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        at.preventDefault(), at.stopPropagation(), ie({ type: 0 }), pe.nextFrame(() => ie({ type: 2, focus: c$5.First }));
        break;
      case o$2.ArrowUp:
        at.preventDefault(), at.stopPropagation(), ie({ type: 0 }), pe.nextFrame(() => ie({ type: 2, focus: c$5.Last }));
        break;
    }
  }), ce = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
        at.preventDefault();
        break;
    }
  }), Ce = o$6((at) => {
    if (r$3(at.currentTarget)) return at.preventDefault();
    B.disabled || (re.menuState === 0 ? (ie({ type: 1 }), pe.nextFrame(() => {
      var lt;
      return (lt = re.buttonRef.current) == null ? void 0 : lt.focus({ preventScroll: !0 });
    })) : (at.preventDefault(), ie({ type: 0 })));
  }), Oe = useMemo(() => ({ open: re.menuState === 0 }), [re]), st = { ref: oe, id: J, type: T$1(B, re.buttonRef), "aria-haspopup": "menu", "aria-controls": (W = re.itemsRef.current) == null ? void 0 : W.id, "aria-expanded": re.menuState === 0, onKeyDown: ne, onKeyUp: ce, onClick: Ce };
  return C$2({ ourProps: st, theirProps: V, slot: Oe, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O$1.RenderStrategy | O$1.Static;
function Ee(B, L) {
  var W, K;
  let J = I$6(), { id: V = `headlessui-menu-items-${J}`, ...re } = B, [ie, oe] = C$1("Menu.Items"), pe = y$2(ie.itemsRef, L), ne = n$3(ie.itemsRef), ce = p$4(), Ce = u$3(), Oe = Ce !== null ? (Ce & d$4.Open) === d$4.Open : ie.menuState === 0;
  useEffect(() => {
    let ht = ie.itemsRef.current;
    ht && ie.menuState === 0 && ht !== (ne == null ? void 0 : ne.activeElement) && ht.focus({ preventScroll: !0 });
  }, [ie.menuState, ie.itemsRef, ne]), F$2({ container: ie.itemsRef.current, enabled: ie.menuState === 0, accept(ht) {
    return ht.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : ht.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(ht) {
    ht.setAttribute("role", "none");
  } });
  let st = o$6((ht) => {
    var yt, vt;
    switch (ce.dispose(), ht.key) {
      case o$2.Space:
        if (ie.searchQuery !== "") return ht.preventDefault(), ht.stopPropagation(), oe({ type: 3, value: ht.key });
      case o$2.Enter:
        if (ht.preventDefault(), ht.stopPropagation(), oe({ type: 1 }), ie.activeItemIndex !== null) {
          let { dataRef: $t } = ie.items[ie.activeItemIndex];
          (vt = (yt = $t.current) == null ? void 0 : yt.domRef.current) == null || vt.click();
        }
        D$3(ie.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return ht.preventDefault(), ht.stopPropagation(), oe({ type: 2, focus: c$5.Next });
      case o$2.ArrowUp:
        return ht.preventDefault(), ht.stopPropagation(), oe({ type: 2, focus: c$5.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return ht.preventDefault(), ht.stopPropagation(), oe({ type: 2, focus: c$5.First });
      case o$2.End:
      case o$2.PageDown:
        return ht.preventDefault(), ht.stopPropagation(), oe({ type: 2, focus: c$5.Last });
      case o$2.Escape:
        ht.preventDefault(), ht.stopPropagation(), oe({ type: 1 }), o$5().nextFrame(() => {
          var $t;
          return ($t = ie.buttonRef.current) == null ? void 0 : $t.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        ht.preventDefault(), ht.stopPropagation(), oe({ type: 1 }), o$5().nextFrame(() => {
          _$3(ie.buttonRef.current, ht.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        ht.key.length === 1 && (oe({ type: 3, value: ht.key }), ce.setTimeout(() => oe({ type: 4 }), 350));
        break;
    }
  }), at = o$6((ht) => {
    switch (ht.key) {
      case o$2.Space:
        ht.preventDefault();
        break;
    }
  }), lt = useMemo(() => ({ open: ie.menuState === 0 }), [ie]), pt = { "aria-activedescendant": ie.activeItemIndex === null || (W = ie.items[ie.activeItemIndex]) == null ? void 0 : W.id, "aria-labelledby": (K = ie.buttonRef.current) == null ? void 0 : K.id, id: V, onKeyDown: st, onKeyUp: at, role: "menu", tabIndex: 0, ref: pe };
  return C$2({ ourProps: pt, theirProps: re, slot: lt, defaultTag: Ae, features: be, visible: Oe, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(B, L) {
  let W = I$6(), { id: K = `headlessui-menu-item-${W}`, disabled: J = !1, ...V } = B, [re, ie] = C$1("Menu.Item"), oe = re.activeItemIndex !== null ? re.items[re.activeItemIndex].id === K : !1, pe = useRef(null), ne = y$2(L, pe);
  l$6(() => {
    if (re.__demoMode || re.menuState !== 0 || !oe || re.activationTrigger === 0) return;
    let $t = o$5();
    return $t.requestAnimationFrame(() => {
      var xt, Ct;
      (Ct = (xt = pe.current) == null ? void 0 : xt.scrollIntoView) == null || Ct.call(xt, { block: "nearest" });
    }), $t.dispose;
  }, [re.__demoMode, pe, oe, re.menuState, re.activationTrigger, re.activeItemIndex]);
  let ce = s$1(pe), Ce = useRef({ disabled: J, domRef: pe, get textValue() {
    return ce();
  } });
  l$6(() => {
    Ce.current.disabled = J;
  }, [Ce, J]), l$6(() => (ie({ type: 5, id: K, dataRef: Ce }), () => ie({ type: 6, id: K })), [Ce, K]);
  let Oe = o$6(() => {
    ie({ type: 1 });
  }), st = o$6(($t) => {
    if (J) return $t.preventDefault();
    ie({ type: 1 }), D$3(re.buttonRef.current);
  }), at = o$6(() => {
    if (J) return ie({ type: 2, focus: c$5.Nothing });
    ie({ type: 2, focus: c$5.Specific, id: K });
  }), lt = u$5(), pt = o$6(($t) => lt.update($t)), ht = o$6(($t) => {
    lt.wasMoved($t) && (J || oe || ie({ type: 2, focus: c$5.Specific, id: K, trigger: 0 }));
  }), yt = o$6(($t) => {
    lt.wasMoved($t) && (J || oe && ie({ type: 2, focus: c$5.Nothing }));
  }), vt = useMemo(() => ({ active: oe, disabled: J, close: Oe }), [oe, J, Oe]);
  return C$2({ ourProps: { id: K, ref: ne, role: "menuitem", tabIndex: J === !0 ? void 0 : -1, "aria-disabled": J === !0 ? !0 : void 0, disabled: void 0, onClick: st, onFocus: at, onPointerEnter: pt, onMouseEnter: pt, onPointerMove: ht, onMouseMove: ht, onPointerLeave: yt, onMouseLeave: yt }, theirProps: V, slot: vt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c$1(B = 0) {
  let [L, W] = useState(B), K = f$5(), J = useCallback((oe) => {
    K.current && W((pe) => pe | oe);
  }, [L, K]), V = useCallback((oe) => !!(L & oe), [L]), re = useCallback((oe) => {
    K.current && W((pe) => pe & ~oe);
  }, [W, K]), ie = useCallback((oe) => {
    K.current && W((pe) => pe ^ oe);
  }, [W]);
  return { flags: L, addFlag: J, hasFlag: V, removeFlag: re, toggleFlag: ie };
}
function l$1(B) {
  let L = { called: !1 };
  return (...W) => {
    if (!L.called) return L.called = !0, B(...W);
  };
}
function g$1(B, ...L) {
  B && L.length > 0 && B.classList.add(...L);
}
function v$1(B, ...L) {
  B && L.length > 0 && B.classList.remove(...L);
}
function b$1(B, L) {
  let W = o$5();
  if (!B) return W.dispose;
  let { transitionDuration: K, transitionDelay: J } = getComputedStyle(B), [V, re] = [K, J].map((oe) => {
    let [pe = 0] = oe.split(",").filter(Boolean).map((ne) => ne.includes("ms") ? parseFloat(ne) : parseFloat(ne) * 1e3).sort((ne, ce) => ce - ne);
    return pe;
  }), ie = V + re;
  if (ie !== 0) {
    W.group((pe) => {
      pe.setTimeout(() => {
        L(), pe.dispose();
      }, ie), pe.addEventListener(B, "transitionrun", (ne) => {
        ne.target === ne.currentTarget && pe.dispose();
      });
    });
    let oe = W.addEventListener(B, "transitionend", (pe) => {
      pe.target === pe.currentTarget && (L(), oe());
    });
  } else L();
  return W.add(() => L()), W.dispose;
}
function M$1(B, L, W, K) {
  let J = W ? "enter" : "leave", V = o$5(), re = K !== void 0 ? l$1(K) : () => {
  };
  J === "enter" && (B.removeAttribute("hidden"), B.style.display = "");
  let ie = u$7(J, { enter: () => L.enter, leave: () => L.leave }), oe = u$7(J, { enter: () => L.enterTo, leave: () => L.leaveTo }), pe = u$7(J, { enter: () => L.enterFrom, leave: () => L.leaveFrom });
  return v$1(B, ...L.base, ...L.enter, ...L.enterTo, ...L.enterFrom, ...L.leave, ...L.leaveFrom, ...L.leaveTo, ...L.entered), g$1(B, ...L.base, ...ie, ...pe), V.nextFrame(() => {
    v$1(B, ...L.base, ...ie, ...pe), g$1(B, ...L.base, ...ie, ...oe), b$1(B, () => (v$1(B, ...L.base, ...ie), g$1(B, ...L.base, ...L.entered), re()));
  }), V.dispose;
}
function D({ immediate: B, container: L, direction: W, classes: K, onStart: J, onStop: V }) {
  let re = f$5(), ie = p$4(), oe = s$9(W);
  l$6(() => {
    B && (oe.current = "enter");
  }, [B]), l$6(() => {
    let pe = o$5();
    ie.add(pe.dispose);
    let ne = L.current;
    if (ne && oe.current !== "idle" && re.current) return pe.dispose(), J.current(oe.current), pe.add(M$1(ne, K.current, oe.current === "enter", () => {
      pe.dispose(), V.current(oe.current);
    })), pe.dispose;
  }, [W]);
}
function S(B = "") {
  return B.split(/\s+/).filter((L) => L.length > 1);
}
let I$1 = createContext(null);
I$1.displayName = "TransitionContext";
var Se = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(Se || {});
function ye() {
  let B = useContext(I$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function xe() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: L }) => L.current !== null).filter(({ state: L }) => L === "visible").length > 0;
}
function se(B, L) {
  let W = s$9(B), K = useRef([]), J = f$5(), V = p$4(), re = o$6((Oe, st = v$2.Hidden) => {
    let at = K.current.findIndex(({ el: lt }) => lt === Oe);
    at !== -1 && (u$7(st, { [v$2.Unmount]() {
      K.current.splice(at, 1);
    }, [v$2.Hidden]() {
      K.current[at].state = "hidden";
    } }), V.microTask(() => {
      var lt;
      !U(K) && J.current && ((lt = W.current) == null || lt.call(W));
    }));
  }), ie = o$6((Oe) => {
    let st = K.current.find(({ el: at }) => at === Oe);
    return st ? st.state !== "visible" && (st.state = "visible") : K.current.push({ el: Oe, state: "visible" }), () => re(Oe, v$2.Unmount);
  }), oe = useRef([]), pe = useRef(Promise.resolve()), ne = useRef({ enter: [], leave: [], idle: [] }), ce = o$6((Oe, st, at) => {
    oe.current.splice(0), L && (L.chains.current[st] = L.chains.current[st].filter(([lt]) => lt !== Oe)), L == null || L.chains.current[st].push([Oe, new Promise((lt) => {
      oe.current.push(lt);
    })]), L == null || L.chains.current[st].push([Oe, new Promise((lt) => {
      Promise.all(ne.current[st].map(([pt, ht]) => ht)).then(() => lt());
    })]), st === "enter" ? pe.current = pe.current.then(() => L == null ? void 0 : L.wait.current).then(() => at(st)) : at(st);
  }), Ce = o$6((Oe, st, at) => {
    Promise.all(ne.current[st].splice(0).map(([lt, pt]) => pt)).then(() => {
      var lt;
      (lt = oe.current.shift()) == null || lt();
    }).then(() => at(st));
  });
  return useMemo(() => ({ children: K, register: ie, unregister: re, onStart: ce, onStop: Ce, wait: pe, chains: ne }), [ie, re, K, ce, Ce, ne, pe]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(B) {
  var L;
  let W = {};
  for (let K of Pe) W[K] = (L = B[K]) != null ? L : Ne;
  return W;
}
function Re(B) {
  let L = useRef(ae(B));
  return useEffect(() => {
    L.current = ae(B);
  }, [B]), L;
}
let De = "div", le = O$1.RenderStrategy;
function He(B, L) {
  var W, K;
  let { beforeEnter: J, afterEnter: V, beforeLeave: re, afterLeave: ie, enter: oe, enterFrom: pe, enterTo: ne, entered: ce, leave: Ce, leaveFrom: Oe, leaveTo: st, ...at } = B, lt = useRef(null), pt = y$2(lt, L), ht = (W = at.unmount) == null || W ? v$2.Unmount : v$2.Hidden, { show: yt, appear: vt, initial: $t } = ye(), [xt, Ct] = useState(yt ? "visible" : "hidden"), Et = xe(), { register: St, unregister: It } = Et;
  useEffect(() => St(lt), [St, lt]), useEffect(() => {
    if (ht === v$2.Hidden && lt.current) {
      if (yt && xt !== "visible") {
        Ct("visible");
        return;
      }
      return u$7(xt, { hidden: () => It(lt), visible: () => St(lt) });
    }
  }, [xt, lt, St, It, yt, ht]);
  let Tt = s$9({ base: S(at.className), enter: S(oe), enterFrom: S(pe), enterTo: S(ne), entered: S(ce), leave: S(Ce), leaveFrom: S(Oe), leaveTo: S(st) }), nt = Re({ beforeEnter: J, afterEnter: V, beforeLeave: re, afterLeave: ie }), it = l$5();
  useEffect(() => {
    if (it && xt === "visible" && lt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [lt, xt, it]);
  let ke = $t && !vt, rt = vt && yt && $t, ot = !it || ke ? "idle" : yt ? "enter" : "leave", ft = c$1(0), ct = o$6((Ft) => u$7(Ft, { enter: () => {
    ft.addFlag(d$4.Opening), nt.current.beforeEnter();
  }, leave: () => {
    ft.addFlag(d$4.Closing), nt.current.beforeLeave();
  }, idle: () => {
  } })), bt = o$6((Ft) => u$7(Ft, { enter: () => {
    ft.removeFlag(d$4.Opening), nt.current.afterEnter();
  }, leave: () => {
    ft.removeFlag(d$4.Closing), nt.current.afterLeave();
  }, idle: () => {
  } })), ut = se(() => {
    Ct("hidden"), It(lt);
  }, Et), gt = useRef(!1);
  D({ immediate: rt, container: lt, classes: Tt, direction: ot, onStart: s$9((Ft) => {
    gt.current = !0, ut.onStart(lt, Ft, ct);
  }), onStop: s$9((Ft) => {
    gt.current = !1, ut.onStop(lt, Ft, bt), Ft === "leave" && !U(ut) && (Ct("hidden"), It(lt));
  }) });
  let dt = at, wt = { ref: pt };
  return rt ? dt = { ...dt, className: t$5(at.className, ...Tt.current.enter, ...Tt.current.enterFrom) } : gt.current && (dt.className = t$5(at.className, (K = lt.current) == null ? void 0 : K.className), dt.className === "" && delete dt.className), C__default.createElement(M.Provider, { value: ut }, C__default.createElement(s$5, { value: u$7(xt, { visible: d$4.Open, hidden: d$4.Closed }) | ft.flags }, C$2({ ourProps: wt, theirProps: dt, defaultTag: De, features: le, visible: xt === "visible", name: "Transition.Child" })));
}
function Fe(B, L) {
  let { show: W, appear: K = !1, unmount: J = !0, ...V } = B, re = useRef(null), ie = y$2(re, L);
  l$5();
  let oe = u$3();
  if (W === void 0 && oe !== null && (W = (oe & d$4.Open) === d$4.Open), ![!0, !1].includes(W)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [pe, ne] = useState(W ? "visible" : "hidden"), ce = se(() => {
    ne("hidden");
  }), [Ce, Oe] = useState(!0), st = useRef([W]);
  l$6(() => {
    Ce !== !1 && st.current[st.current.length - 1] !== W && (st.current.push(W), Oe(!1));
  }, [st, W]);
  let at = useMemo(() => ({ show: W, appear: K, initial: Ce }), [W, K, Ce]);
  useEffect(() => {
    if (W) ne("visible");
    else if (!U(ce)) ne("hidden");
    else {
      let yt = re.current;
      if (!yt) return;
      let vt = yt.getBoundingClientRect();
      vt.x === 0 && vt.y === 0 && vt.width === 0 && vt.height === 0 && ne("hidden");
    }
  }, [W, ce]);
  let lt = { unmount: J }, pt = o$6(() => {
    var yt;
    Ce && Oe(!1), (yt = B.beforeEnter) == null || yt.call(B);
  }), ht = o$6(() => {
    var yt;
    Ce && Oe(!1), (yt = B.beforeLeave) == null || yt.call(B);
  });
  return C__default.createElement(M.Provider, { value: ce }, C__default.createElement(I$1.Provider, { value: at }, C$2({ ourProps: { ...lt, as: Fragment, children: C__default.createElement(ue, { ref: ie, ...lt, ...V, beforeEnter: pt, beforeLeave: ht }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: pe === "visible", name: "Transition" })));
}
function _e(B, L) {
  let W = useContext(I$1) !== null, K = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !W && K ? C__default.createElement(q, { ref: L, ...B }) : C__default.createElement(ue, { ref: L, ...B }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.2692%206.04835H10.6729C7.79592%2012.2004%2012.4577%2014.8894%2015.1483%2015.4648L13.9495%2019.3884C12.7348%2018.4467%2010.7795%2018.0282%209.79384%2017.8974C5.55824%2017.662%204.20118%2020.7103%204.03982%2021.9779C3.72015%2024.4889%205.31849%2026.9215%209.07459%2026.9215C12.0795%2026.9215%2014.3758%2025.2998%2015.1483%2024.4889C18.0892%2027%2020.7958%2027.1569%2021.7814%2026.9215C26.7043%2026.5449%2027.5621%2022.004%2027.3756%2019.7807H24.1789C23.4117%2025.8072%2019.0642%2023.338%2016.9864%2021.3501L18.6646%2015.7002C30.0128%2013.1892%2029.9329%204.322%2024.1789%204.00811C19.5757%203.75701%2016.8265%209.39643%2016.0274%2012.2475C12.1914%2011.6198%2013.2569%207.85317%2014.2692%206.04835Z'%20fill='white'/%3e%3cpath%20d='M19.5437%2012.2475C19.9699%2010.6258%2021.7814%206.99461%2023.7793%207.2254C26.4965%207.53927%2022.6605%2011.5413%2019.5437%2012.2475Z'%20fill='%23303746'/%3e%3cpath%20d='M12.8307%2022.2918C11.7918%2021.2716%208.03567%2020.0946%207.31642%2022.2918C7.00817%2023.2334%209.47418%2024.8813%2012.8307%2022.2918Z'%20fill='%23303746'/%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21.403%2011.0761L22.9233%2012.9126C23.0973%2013.1219%2023.2486%2013.2846%2023.3167%2013.3853C23.7705%2013.8503%2024.0277%2014.478%2024.0277%2015.1289C23.9823%2015.8961%2023.4982%2016.423%2023.0444%2016.9887L21.9779%2018.2673L21.4257%2018.9338C21.403%2018.957%2021.3954%2018.988%2021.3879%2019.019C21.3803%2019.05%2021.3879%2019.081%2021.403%2019.1043C21.4181%2019.1353%2021.4332%2019.1585%2021.4635%2019.174C21.4862%2019.1895%2021.5165%2019.1973%2021.5467%2019.1973H27.0986C27.9458%2019.1973%2029.0123%2019.9257%2028.9518%2021.0338C28.9518%2021.5375%2028.7476%2022.018%2028.3996%2022.3744C28.0441%2022.7309%2027.5676%2022.9324%2027.0684%2022.9324H18.3699C17.795%2022.9324%2016.2595%2022.9944%2015.8284%2021.6538C15.7376%2021.3748%2015.7225%2021.0726%2015.7906%2020.7858C15.9192%2020.3596%2016.1158%2019.9567%2016.373%2019.6002C16.8117%2018.9338%2017.2807%2018.2751%2017.7496%2017.6319C18.3547%2016.7872%2018.9674%2015.9736%2019.5801%2015.1134C19.6028%2015.0824%2019.6103%2015.0514%2019.6103%2015.0127C19.6103%2014.9739%2019.5952%2014.9429%2019.5801%2014.9119L17.3714%2012.254C17.3563%2012.2385%2017.3412%2012.223%2017.3185%2012.2075C17.2958%2012.1997%2017.2731%2012.192%2017.2504%2012.192C17.2277%2012.192%2017.205%2012.1997%2017.1823%2012.2075C17.1596%2012.2152%2017.1445%2012.2307%2017.1294%2012.254C16.5394%2013.0599%2013.945%2016.6323%2013.3928%2017.3607C12.8406%2018.0814%2011.4791%2018.1279%2010.7228%2017.3607L7.26605%2013.8581C7.24335%2013.8348%207.2131%2013.8193%207.18284%2013.8116C7.15259%2013.8038%207.12233%2013.8116%207.09208%2013.8193C7.06182%2013.8348%207.03913%2013.8503%207.024%2013.8813C7.00887%2013.9045%206.99374%2013.9355%207.00131%2013.9665V20.7006C7.00887%2021.181%206.87272%2021.646%206.60042%2022.0412C6.32812%2022.4364%205.94993%2022.7309%205.50365%2022.8936C5.21623%2022.9944%204.91367%2023.0254%204.61868%2022.9789C4.32368%2022.9324%204.03626%2022.8239%203.79421%2022.6456C3.5446%2022.4674%203.34794%2022.2349%203.21179%2021.9637C3.07564%2021.6925%203%2021.3903%203%2021.0881V8.97605C3.02269%208.54209%203.17397%208.12364%203.44627%207.77492C3.71857%207.43396%204.08164%207.18598%204.49765%207.06974C4.85316%206.97675%205.23135%206.97675%205.58686%207.06974C5.94236%207.17048%206.26761%207.35646%206.53235%207.62769L11.8498%2012.9979C11.8649%2013.0134%2011.8876%2013.0289%2011.9027%2013.0366C11.9254%2013.0444%2011.9481%2013.0444%2011.9708%2013.0444C11.9935%2013.0444%2012.0162%2013.0366%2012.0313%2013.0211C12.054%2013.0134%2012.0691%2012.9979%2012.0843%2012.9746L15.8586%207.69743C16.0326%207.48045%2016.252%207.30997%2016.5016%207.19373C16.7512%207.07749%2017.0235%207.00775%2017.2958%207.00775H27.1137C27.386%207.00775%2027.6508%207.06974%2027.8928%207.17823C28.1349%207.29447%2028.3542%207.4572%2028.5358%207.65868C28.7097%207.86016%2028.8459%208.10039%2028.9215%208.36386C28.9972%208.62733%2029.0199%208.89856%2028.982%209.16978C28.914%209.63473%2028.6795%2010.0609%2028.324%2010.3632C27.9685%2010.6654%2027.5146%2010.8359%2027.0457%2010.8281H21.5467C21.5165%2010.8281%2021.4938%2010.8359%2021.4711%2010.8514C21.4484%2010.8669%2021.4257%2010.8901%2021.4181%2010.9134C21.403%2010.9366%2021.403%2010.9676%2021.403%2010.9908C21.3803%2011.0218%2021.3879%2011.0528%2021.403%2011.0761Z'%20fill='url(%23paint0_linear_3119_13568)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13568'%20x1='4.08333'%20y1='11'%20x2='29'%20y2='11'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23EF2690'/%3e%3cstop%20offset='1'%20stop-color='%23AB27FE'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11.8444%205H5.48893C5.21893%205%205%205.21883%205%205.48892V11.8444C5%2012.1144%205.21893%2012.3334%205.48893%2012.3334H11.8444C12.1145%2012.3334%2012.3334%2012.1144%2012.3334%2011.8444V5.48892C12.3334%205.21883%2012.1145%205%2011.8444%205ZM19.1807%2012.3336H12.8252C12.5552%2012.3336%2012.3363%2012.5524%2012.3363%2012.8224V19.178C12.3363%2019.448%2012.5552%2019.6669%2012.8252%2019.6669H19.1807C19.4507%2019.6669%2019.6697%2019.448%2019.6697%2019.178V12.8224C19.6697%2012.5524%2019.4507%2012.3336%2019.1807%2012.3336ZM20.1556%205.00001H26.5112C26.7812%205.00001%2027%205.21884%2027%205.48893V11.8444C27%2012.1144%2026.7812%2012.3334%2026.5112%2012.3334H20.1556C19.8856%2012.3334%2019.6666%2012.1144%2019.6666%2011.8444V5.48893C19.6666%205.21884%2019.8856%205.00001%2020.1556%205.00001ZM11.8445%2019.6665H5.48895C5.21895%2019.6665%205.00002%2019.8853%205.00002%2020.1553V26.511C5.00002%2026.781%205.21895%2026.9999%205.48895%2026.9999H11.8445C12.1146%2026.9999%2012.3334%2026.781%2012.3334%2026.511V20.1553C12.3334%2019.8853%2012.1146%2019.6665%2011.8445%2019.6665ZM20.1556%2019.6665H26.5112C26.7812%2019.6665%2027%2019.8853%2027%2020.1553V26.511C27%2026.781%2026.7812%2026.9999%2026.5112%2026.9999H20.1556C19.8856%2026.9999%2019.6666%2026.781%2019.6666%2026.511V20.1553C19.6666%2019.8853%2019.8856%2019.6665%2020.1556%2019.6665Z'%20fill='white'/%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.2892%204.87219L26.2505%2010.3415C26.7579%2010.8061%2027.0077%2011.2762%2026.9998%2011.7498C26.992%2012.2235%2026.7737%2012.6553%2026.3469%2013.047C25.9004%2013.457%2025.4185%2013.6647%2024.9032%2013.6738C24.3879%2013.6811%2023.8766%2013.4515%2023.3691%2012.9869L17.2721%207.39369C16.5798%206.75785%2015.9111%206.30785%2015.268%206.04367C14.6248%205.7795%2013.9482%205.73759%2013.2402%205.91978C12.5302%206.10015%2011.769%206.56473%2010.9528%207.31171C9.82782%208.34472%209.29089%209.31397%209.34596%2010.2195C9.40103%2011.1249%209.9596%2012.065%2011.0197%2013.0361L17.1659%2018.6767C17.6792%2019.1467%2017.931%2019.6168%2017.9231%2020.0832C17.9152%2020.5514%2017.695%2020.9832%2017.2603%2021.3822C16.8276%2021.7794%2016.3497%2021.9871%2015.8305%2022.0035C15.3112%2022.0199%2014.794%2021.7921%2014.2826%2021.3221L8.32127%2015.8528C7.35164%2014.9637%206.65146%2014.122%206.22074%2013.3276C5.79001%2012.5333%205.62874%2011.6351%205.74084%2010.633C5.84115%209.77491%206.13813%208.94413%206.63376%208.13885C7.12743%207.33357%207.83547%206.51008%208.75396%205.66654C9.84749%204.66268%2010.8919%203.89384%2011.887%203.3582C12.8803%202.82256%2013.842%202.52559%2014.7704%202.46365C15.7006%202.4017%2016.6172%202.57296%2017.5239%202.97742C18.4305%203.38188%2019.351%204.01226%2020.2872%204.87219H20.2892Z'%20fill='url(%23paint0_linear_3119_13572)'/%3e%3cpath%20d='M10.9371%2026.9408L4.97771%2021.4714C4.47027%2021.005%204.22049%2020.5368%204.22836%2020.0631C4.23623%2019.5894%204.45454%2019.1576%204.88133%2018.7659C5.32779%2018.356%205.80966%2018.1483%206.32495%2018.1392C6.84025%2018.1319%207.35162%2018.3596%207.85905%2018.826L13.9541%2024.4193C14.6484%2025.0551%2015.3151%2025.5051%2015.9583%2025.7693C16.6014%2026.0335%2017.278%2026.0735%2017.988%2025.8932C18.698%2025.7128%2019.4591%2025.2482%2020.2754%2024.4994C21.4004%2023.4664%2021.9373%2022.4972%2021.8822%2021.5917C21.8272%2020.6862%2021.2686%2019.7461%2020.2085%2018.7732L16.9338%2015.7944C16.4205%2015.3244%2016.1687%2014.8543%2016.1766%2014.3879C16.1845%2013.9197%2016.4047%2013.4879%2016.8394%2013.0889C17.2721%2012.6917%2017.75%2012.484%2018.2692%2012.4676C18.7885%2012.4512%2019.3057%2012.679%2019.8171%2013.149L22.905%2015.9566C23.8746%2016.8457%2024.5748%2017.6874%2025.0055%2018.4817C25.4362%2019.2761%2025.5975%2020.1743%2025.4854%2021.1763C25.3851%2022.0344%2025.0881%2022.8652%2024.5925%2023.6705C24.0988%2024.4757%2023.3908%2025.2992%2022.4723%2026.1428C21.3787%2027.1466%2020.3344%2027.9155%2019.3392%2028.4511C18.344%2028.9868%2017.3822%2029.2856%2016.4519%2029.3475C15.5216%2029.4094%2014.6051%2029.2382%2013.6984%2028.8337C12.7917%2028.4293%2011.8713%2027.7989%2010.9351%2026.9389L10.9371%2026.9408Z'%20fill='url(%23paint1_linear_3119_13572)'/%3e%3cpath%20d='M14.6543%2012.8284C15.8633%2012.8284%2016.8433%2011.9205%2016.8433%2010.8006C16.8433%209.6807%2015.8633%208.77284%2014.6543%208.77284C13.4453%208.77284%2012.4653%209.6807%2012.4653%2010.8006C12.4653%2011.9205%2013.4453%2012.8284%2014.6543%2012.8284Z'%20fill='url(%23paint2_radial_3119_13572)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13572'%20x1='25.27'%20y1='8.05866'%20x2='7.28614'%20y2='16.6864'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_3119_13572'%20x1='6.4668'%20y1='23.9797'%20x2='27.5911'%20y2='17.1926'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_3119_13572'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(14.6543%2010.8024)%20scale(2.18903%202.02777)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M27.0042%2026.6428V22.6649C27.0042%2022.5072%2026.9416%2022.3568%2026.8298%2022.245L9.90453%205.31965C9.79276%205.20788%209.64232%205.14521%209.4846%205.14521H5.50684C5.31046%205.14521%205.15063%205.30503%205.15063%205.50141V9.19714C5.15063%209.35487%205.21331%209.50528%205.32508%209.61706L11.4004%2015.6923C11.5393%2015.8313%2011.5393%2016.0569%2011.4004%2016.1959L5.25509%2022.3411C5.18824%2022.4079%205.15063%2022.4988%205.15063%2022.5929V26.6428C5.15063%2026.839%205.31046%2026.999%205.50684%2026.999H12.1535C12.3499%2026.999%2012.5097%2026.839%2012.5097%2026.6428V24.2569C12.5097%2024.1629%2012.5473%2024.072%2012.6142%2024.0051L15.9108%2020.7084C16.0498%2020.5695%2016.2754%2020.5695%2016.4144%2020.7084L22.5314%2026.8256C22.6432%2026.9373%2022.7936%2027%2022.9513%2027H26.647C26.8434%2027%2027.0032%2026.8401%2027.0032%2026.6438L27.0042%2026.6428Z'%20fill='white'/%3e%3cpath%20d='M18.1379%2010.413H21.467C21.6644%2010.413%2021.8253%2010.5739%2021.8253%2010.7713V14.1003C21.8253%2014.42%2022.2118%2014.5799%2022.4374%2014.3531L27.0043%209.77894C27.0711%209.71207%2027.1088%209.62121%2027.1088%209.52614V5.52017C27.1088%205.32275%2026.9488%205.16188%2026.7504%205.16188L22.6849%205.15666C22.5899%205.15666%2022.4991%205.19426%2022.4311%205.26112L17.8841%209.80087C17.6585%2010.0265%2017.8182%2010.413%2018.1369%2010.413H18.1379Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, L = 4, W = 5) {
  if (B.length <= L + W)
    return B;
  const K = B.slice(0, L), J = B.slice(B.length - W);
  return `${K}...${J}`;
}
const WALLET_TO_ICON = {
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: L,
  onViewProfile: W,
  onChangeWallet: K,
  onDisconnectWallet: J
}) {
  const { wallet: V } = useWallie();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    qe$1,
    {
      as: "section",
      className: "wallie-relative wallie-inline-block wallie-text-left",
      children: ({ open: re }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-identifier-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: WALLET_TO_ICON[V],
              alt: `${V} is connected`
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[L] ?? L })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${re ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: "ord connect dropdown"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => W == null ? void 0 : W(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => K == null ? void 0 : K(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => J == null ? void 0 : J(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "logout" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
const WalletIcon = "data:image/svg+xml,%3csvg%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3cpath%20d='M9%206.25C7.61929%206.25%206.5%207.36929%206.5%208.75V21.25C6.5%2022.6308%207.61929%2023.75%209%2023.75H25C26.3808%2023.75%2027.5%2022.6308%2027.5%2021.25V18.75H23.75C21.6789%2018.75%2020%2017.0711%2020%2015C20%2012.9289%2021.6789%2011.25%2023.75%2011.25H27.5V8.75C27.5%207.36929%2026.3808%206.25%2025%206.25H9Z'%20fill='%231C2033'%20/%3e%3cpath%20d='M25%2015C25%2015.6904%2024.4404%2016.25%2023.75%2016.25C23.0596%2016.25%2022.5%2015.6904%2022.5%2015C22.5%2014.3096%2023.0596%2013.75%2023.75%2013.75C24.4404%2013.75%2025%2014.3096%2025%2015Z'%20fill='%231C2033'%20/%3e%3c/svg%3e";
function PreConnectButton({
  openModal: B,
  disabled: L,
  connectButton: W = "Wallet Connect",
  connectButtonComponent: K
}) {
  return K ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: B, "aria-label": "Connect Button", type: "button", className: "wallie-w-full", children: K }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: L,
      className: "wallie-bg-ord-orange wallie-rounded-full wallie-flex wallie-flex-row md:wallie-space-x-2 wallie-items-center wallie-p-1 wallie-pr-2 wallie-px-1 md:wallie-pr-3 md:wallie-px-3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallie-w-6 md:wallie-w-7", src: WalletIcon, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-hidden md:wallie-block wallie-text-ord-blue wallie-mb-1 wallie-pr-2", children: W })
      ]
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='19'%20height='19'%20viewBox='0%200%2019%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.07844%204.07811C4.25659%203.90001%204.49818%203.79996%204.75009%203.79996C5.002%203.79996%205.24359%203.90001%205.42174%204.07811L9.50009%208.15646L13.5784%204.07811C13.6661%203.98738%2013.7709%203.915%2013.8868%203.86521C14.0027%203.81542%2014.1274%203.78922%2014.2535%203.78812C14.3796%203.78703%2014.5047%203.81106%2014.6215%203.85883C14.7382%203.9066%2014.8443%203.97714%2014.9335%204.06633C15.0227%204.15553%2015.0933%204.2616%2015.141%204.37835C15.1888%204.4951%2015.2128%204.6202%2015.2117%204.74634C15.2106%204.87248%2015.1844%204.99714%2015.1346%205.11304C15.0848%205.22895%2015.0125%205.33378%2014.9217%205.42141L10.8434%209.49976L14.9217%2013.5781C15.0948%2013.7573%2015.1905%2013.9973%2015.1884%2014.2463C15.1862%2014.4954%2015.0863%2014.7337%2014.9102%2014.9098C14.734%2015.086%2014.4958%2015.1859%2014.2467%2015.1881C13.9976%2015.1902%2013.7576%2015.0945%2013.5784%2014.9214L9.50009%2010.8431L5.42174%2014.9214C5.24257%2015.0945%205.0026%2015.1902%204.75351%2015.1881C4.50442%2015.1859%204.26615%2015.086%204.09001%2014.9098C3.91387%2014.7337%203.81396%2014.4954%203.8118%2014.2463C3.80964%2013.9973%203.90539%2013.7573%204.07844%2013.5781L8.15679%209.49976L4.07844%205.42141C3.90034%205.24326%203.80029%205.00167%203.80029%204.74976C3.80029%204.49785%203.90034%204.25626%204.07844%204.07811Z'%20fill='%23D9D5D2'/%3e%3c/svg%3e";
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var L = B.length;
  if (L % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var W = B.indexOf("=");
  W === -1 && (W = L);
  var K = W === L ? 0 : 4 - W % 4;
  return [W, K];
}
function byteLength$1(B) {
  var L = getLens$1(B), W = L[0], K = L[1];
  return (W + K) * 3 / 4 - K;
}
function _byteLength$1(B, L, W) {
  return (L + W) * 3 / 4 - W;
}
function toByteArray$1(B) {
  var L, W = getLens$1(B), K = W[0], J = W[1], V = new Arr$1(_byteLength$1(B, K, J)), re = 0, ie = J > 0 ? K - 4 : K, oe;
  for (oe = 0; oe < ie; oe += 4)
    L = revLookup$1[B.charCodeAt(oe)] << 18 | revLookup$1[B.charCodeAt(oe + 1)] << 12 | revLookup$1[B.charCodeAt(oe + 2)] << 6 | revLookup$1[B.charCodeAt(oe + 3)], V[re++] = L >> 16 & 255, V[re++] = L >> 8 & 255, V[re++] = L & 255;
  return J === 2 && (L = revLookup$1[B.charCodeAt(oe)] << 2 | revLookup$1[B.charCodeAt(oe + 1)] >> 4, V[re++] = L & 255), J === 1 && (L = revLookup$1[B.charCodeAt(oe)] << 10 | revLookup$1[B.charCodeAt(oe + 1)] << 4 | revLookup$1[B.charCodeAt(oe + 2)] >> 2, V[re++] = L >> 8 & 255, V[re++] = L & 255), V;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, L, W) {
  for (var K, J = [], V = L; V < W; V += 3)
    K = (B[V] << 16 & 16711680) + (B[V + 1] << 8 & 65280) + (B[V + 2] & 255), J.push(tripletToBase64$1(K));
  return J.join("");
}
function fromByteArray$1(B) {
  for (var L, W = B.length, K = W % 3, J = [], V = 16383, re = 0, ie = W - K; re < ie; re += V)
    J.push(encodeChunk$1(B, re, re + V > ie ? ie : re + V));
  return K === 1 ? (L = B[W - 1], J.push(
    lookup$1[L >> 2] + lookup$1[L << 4 & 63] + "=="
  )) : K === 2 && (L = (B[W - 2] << 8) + B[W - 1], J.push(
    lookup$1[L >> 10] + lookup$1[L >> 4 & 63] + lookup$1[L << 2 & 63] + "="
  )), J.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, L, W, K, J) {
  var V, re, ie = J * 8 - K - 1, oe = (1 << ie) - 1, pe = oe >> 1, ne = -7, ce = W ? J - 1 : 0, Ce = W ? -1 : 1, Oe = B[L + ce];
  for (ce += Ce, V = Oe & (1 << -ne) - 1, Oe >>= -ne, ne += ie; ne > 0; V = V * 256 + B[L + ce], ce += Ce, ne -= 8)
    ;
  for (re = V & (1 << -ne) - 1, V >>= -ne, ne += K; ne > 0; re = re * 256 + B[L + ce], ce += Ce, ne -= 8)
    ;
  if (V === 0)
    V = 1 - pe;
  else {
    if (V === oe)
      return re ? NaN : (Oe ? -1 : 1) * (1 / 0);
    re = re + Math.pow(2, K), V = V - pe;
  }
  return (Oe ? -1 : 1) * re * Math.pow(2, V - K);
};
ieee754.write = function(B, L, W, K, J, V) {
  var re, ie, oe, pe = V * 8 - J - 1, ne = (1 << pe) - 1, ce = ne >> 1, Ce = J === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Oe = K ? 0 : V - 1, st = K ? 1 : -1, at = L < 0 || L === 0 && 1 / L < 0 ? 1 : 0;
  for (L = Math.abs(L), isNaN(L) || L === 1 / 0 ? (ie = isNaN(L) ? 1 : 0, re = ne) : (re = Math.floor(Math.log(L) / Math.LN2), L * (oe = Math.pow(2, -re)) < 1 && (re--, oe *= 2), re + ce >= 1 ? L += Ce / oe : L += Ce * Math.pow(2, 1 - ce), L * oe >= 2 && (re++, oe /= 2), re + ce >= ne ? (ie = 0, re = ne) : re + ce >= 1 ? (ie = (L * oe - 1) * Math.pow(2, J), re = re + ce) : (ie = L * Math.pow(2, ce - 1) * Math.pow(2, J), re = 0)); J >= 8; B[W + Oe] = ie & 255, Oe += st, ie /= 256, J -= 8)
    ;
  for (re = re << J | ie, pe += J; pe > 0; B[W + Oe] = re & 255, Oe += st, re /= 256, pe -= 8)
    ;
  B[W + Oe - st] |= at * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const L = base64Js$1, W = ieee754, K = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = ne, B.SlowBuffer = $t, B.INSPECT_MAX_BYTES = 50;
  const J = 2147483647;
  B.kMaxLength = J;
  const { Uint8Array: V, ArrayBuffer: re, SharedArrayBuffer: ie } = globalThis;
  ne.TYPED_ARRAY_SUPPORT = oe(), !ne.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function oe() {
    try {
      const Pt = new V(1), mt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(mt, V.prototype), Object.setPrototypeOf(Pt, mt), Pt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(ne.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (ne.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(ne.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (ne.isBuffer(this))
        return this.byteOffset;
    }
  });
  function pe(Pt) {
    if (Pt > J)
      throw new RangeError('The value "' + Pt + '" is invalid for option "size"');
    const mt = new V(Pt);
    return Object.setPrototypeOf(mt, ne.prototype), mt;
  }
  function ne(Pt, mt, At) {
    if (typeof Pt == "number") {
      if (typeof mt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return st(Pt);
    }
    return ce(Pt, mt, At);
  }
  ne.poolSize = 8192;
  function ce(Pt, mt, At) {
    if (typeof Pt == "string")
      return at(Pt, mt);
    if (re.isView(Pt))
      return pt(Pt);
    if (Pt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Pt
      );
    if ($r(Pt, re) || Pt && $r(Pt.buffer, re) || typeof ie < "u" && ($r(Pt, ie) || Pt && $r(Pt.buffer, ie)))
      return ht(Pt, mt, At);
    if (typeof Pt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const qt = Pt.valueOf && Pt.valueOf();
    if (qt != null && qt !== Pt)
      return ne.from(qt, mt, At);
    const Kt = yt(Pt);
    if (Kt) return Kt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Pt[Symbol.toPrimitive] == "function")
      return ne.from(Pt[Symbol.toPrimitive]("string"), mt, At);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Pt
    );
  }
  ne.from = function(Pt, mt, At) {
    return ce(Pt, mt, At);
  }, Object.setPrototypeOf(ne.prototype, V.prototype), Object.setPrototypeOf(ne, V);
  function Ce(Pt) {
    if (typeof Pt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Pt < 0)
      throw new RangeError('The value "' + Pt + '" is invalid for option "size"');
  }
  function Oe(Pt, mt, At) {
    return Ce(Pt), Pt <= 0 ? pe(Pt) : mt !== void 0 ? typeof At == "string" ? pe(Pt).fill(mt, At) : pe(Pt).fill(mt) : pe(Pt);
  }
  ne.alloc = function(Pt, mt, At) {
    return Oe(Pt, mt, At);
  };
  function st(Pt) {
    return Ce(Pt), pe(Pt < 0 ? 0 : vt(Pt) | 0);
  }
  ne.allocUnsafe = function(Pt) {
    return st(Pt);
  }, ne.allocUnsafeSlow = function(Pt) {
    return st(Pt);
  };
  function at(Pt, mt) {
    if ((typeof mt != "string" || mt === "") && (mt = "utf8"), !ne.isEncoding(mt))
      throw new TypeError("Unknown encoding: " + mt);
    const At = xt(Pt, mt) | 0;
    let qt = pe(At);
    const Kt = qt.write(Pt, mt);
    return Kt !== At && (qt = qt.slice(0, Kt)), qt;
  }
  function lt(Pt) {
    const mt = Pt.length < 0 ? 0 : vt(Pt.length) | 0, At = pe(mt);
    for (let qt = 0; qt < mt; qt += 1)
      At[qt] = Pt[qt] & 255;
    return At;
  }
  function pt(Pt) {
    if ($r(Pt, V)) {
      const mt = new V(Pt);
      return ht(mt.buffer, mt.byteOffset, mt.byteLength);
    }
    return lt(Pt);
  }
  function ht(Pt, mt, At) {
    if (mt < 0 || Pt.byteLength < mt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Pt.byteLength < mt + (At || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let qt;
    return mt === void 0 && At === void 0 ? qt = new V(Pt) : At === void 0 ? qt = new V(Pt, mt) : qt = new V(Pt, mt, At), Object.setPrototypeOf(qt, ne.prototype), qt;
  }
  function yt(Pt) {
    if (ne.isBuffer(Pt)) {
      const mt = vt(Pt.length) | 0, At = pe(mt);
      return At.length === 0 || Pt.copy(At, 0, 0, mt), At;
    }
    if (Pt.length !== void 0)
      return typeof Pt.length != "number" || kr(Pt.length) ? pe(0) : lt(Pt);
    if (Pt.type === "Buffer" && Array.isArray(Pt.data))
      return lt(Pt.data);
  }
  function vt(Pt) {
    if (Pt >= J)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + J.toString(16) + " bytes");
    return Pt | 0;
  }
  function $t(Pt) {
    return +Pt != Pt && (Pt = 0), ne.alloc(+Pt);
  }
  ne.isBuffer = function(mt) {
    return mt != null && mt._isBuffer === !0 && mt !== ne.prototype;
  }, ne.compare = function(mt, At) {
    if ($r(mt, V) && (mt = ne.from(mt, mt.offset, mt.byteLength)), $r(At, V) && (At = ne.from(At, At.offset, At.byteLength)), !ne.isBuffer(mt) || !ne.isBuffer(At))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (mt === At) return 0;
    let qt = mt.length, Kt = At.length;
    for (let Vt = 0, Xt = Math.min(qt, Kt); Vt < Xt; ++Vt)
      if (mt[Vt] !== At[Vt]) {
        qt = mt[Vt], Kt = At[Vt];
        break;
      }
    return qt < Kt ? -1 : Kt < qt ? 1 : 0;
  }, ne.isEncoding = function(mt) {
    switch (String(mt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, ne.concat = function(mt, At) {
    if (!Array.isArray(mt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (mt.length === 0)
      return ne.alloc(0);
    let qt;
    if (At === void 0)
      for (At = 0, qt = 0; qt < mt.length; ++qt)
        At += mt[qt].length;
    const Kt = ne.allocUnsafe(At);
    let Vt = 0;
    for (qt = 0; qt < mt.length; ++qt) {
      let Xt = mt[qt];
      if ($r(Xt, V))
        Vt + Xt.length > Kt.length ? (ne.isBuffer(Xt) || (Xt = ne.from(Xt)), Xt.copy(Kt, Vt)) : V.prototype.set.call(
          Kt,
          Xt,
          Vt
        );
      else if (ne.isBuffer(Xt))
        Xt.copy(Kt, Vt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Vt += Xt.length;
    }
    return Kt;
  };
  function xt(Pt, mt) {
    if (ne.isBuffer(Pt))
      return Pt.length;
    if (re.isView(Pt) || $r(Pt, re))
      return Pt.byteLength;
    if (typeof Pt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Pt
      );
    const At = Pt.length, qt = arguments.length > 2 && arguments[2] === !0;
    if (!qt && At === 0) return 0;
    let Kt = !1;
    for (; ; )
      switch (mt) {
        case "ascii":
        case "latin1":
        case "binary":
          return At;
        case "utf8":
        case "utf-8":
          return Pr(Pt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return At * 2;
        case "hex":
          return At >>> 1;
        case "base64":
          return Rr(Pt).length;
        default:
          if (Kt)
            return qt ? -1 : Pr(Pt).length;
          mt = ("" + mt).toLowerCase(), Kt = !0;
      }
  }
  ne.byteLength = xt;
  function Ct(Pt, mt, At) {
    let qt = !1;
    if ((mt === void 0 || mt < 0) && (mt = 0), mt > this.length || ((At === void 0 || At > this.length) && (At = this.length), At <= 0) || (At >>>= 0, mt >>>= 0, At <= mt))
      return "";
    for (Pt || (Pt = "utf8"); ; )
      switch (Pt) {
        case "hex":
          return dt(this, mt, At);
        case "utf8":
        case "utf-8":
          return ft(this, mt, At);
        case "ascii":
          return ut(this, mt, At);
        case "latin1":
        case "binary":
          return gt(this, mt, At);
        case "base64":
          return ot(this, mt, At);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return wt(this, mt, At);
        default:
          if (qt) throw new TypeError("Unknown encoding: " + Pt);
          Pt = (Pt + "").toLowerCase(), qt = !0;
      }
  }
  ne.prototype._isBuffer = !0;
  function Et(Pt, mt, At) {
    const qt = Pt[mt];
    Pt[mt] = Pt[At], Pt[At] = qt;
  }
  ne.prototype.swap16 = function() {
    const mt = this.length;
    if (mt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let At = 0; At < mt; At += 2)
      Et(this, At, At + 1);
    return this;
  }, ne.prototype.swap32 = function() {
    const mt = this.length;
    if (mt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let At = 0; At < mt; At += 4)
      Et(this, At, At + 3), Et(this, At + 1, At + 2);
    return this;
  }, ne.prototype.swap64 = function() {
    const mt = this.length;
    if (mt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let At = 0; At < mt; At += 8)
      Et(this, At, At + 7), Et(this, At + 1, At + 6), Et(this, At + 2, At + 5), Et(this, At + 3, At + 4);
    return this;
  }, ne.prototype.toString = function() {
    const mt = this.length;
    return mt === 0 ? "" : arguments.length === 0 ? ft(this, 0, mt) : Ct.apply(this, arguments);
  }, ne.prototype.toLocaleString = ne.prototype.toString, ne.prototype.equals = function(mt) {
    if (!ne.isBuffer(mt)) throw new TypeError("Argument must be a Buffer");
    return this === mt ? !0 : ne.compare(this, mt) === 0;
  }, ne.prototype.inspect = function() {
    let mt = "";
    const At = B.INSPECT_MAX_BYTES;
    return mt = this.toString("hex", 0, At).replace(/(.{2})/g, "$1 ").trim(), this.length > At && (mt += " ... "), "<Buffer " + mt + ">";
  }, K && (ne.prototype[K] = ne.prototype.inspect), ne.prototype.compare = function(mt, At, qt, Kt, Vt) {
    if ($r(mt, V) && (mt = ne.from(mt, mt.offset, mt.byteLength)), !ne.isBuffer(mt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof mt
      );
    if (At === void 0 && (At = 0), qt === void 0 && (qt = mt ? mt.length : 0), Kt === void 0 && (Kt = 0), Vt === void 0 && (Vt = this.length), At < 0 || qt > mt.length || Kt < 0 || Vt > this.length)
      throw new RangeError("out of range index");
    if (Kt >= Vt && At >= qt)
      return 0;
    if (Kt >= Vt)
      return -1;
    if (At >= qt)
      return 1;
    if (At >>>= 0, qt >>>= 0, Kt >>>= 0, Vt >>>= 0, this === mt) return 0;
    let Xt = Vt - Kt, yr = qt - At;
    const Ar = Math.min(Xt, yr), lr = this.slice(Kt, Vt), xr = mt.slice(At, qt);
    for (let wr = 0; wr < Ar; ++wr)
      if (lr[wr] !== xr[wr]) {
        Xt = lr[wr], yr = xr[wr];
        break;
      }
    return Xt < yr ? -1 : yr < Xt ? 1 : 0;
  };
  function St(Pt, mt, At, qt, Kt) {
    if (Pt.length === 0) return -1;
    if (typeof At == "string" ? (qt = At, At = 0) : At > 2147483647 ? At = 2147483647 : At < -2147483648 && (At = -2147483648), At = +At, kr(At) && (At = Kt ? 0 : Pt.length - 1), At < 0 && (At = Pt.length + At), At >= Pt.length) {
      if (Kt) return -1;
      At = Pt.length - 1;
    } else if (At < 0)
      if (Kt) At = 0;
      else return -1;
    if (typeof mt == "string" && (mt = ne.from(mt, qt)), ne.isBuffer(mt))
      return mt.length === 0 ? -1 : It(Pt, mt, At, qt, Kt);
    if (typeof mt == "number")
      return mt = mt & 255, typeof V.prototype.indexOf == "function" ? Kt ? V.prototype.indexOf.call(Pt, mt, At) : V.prototype.lastIndexOf.call(Pt, mt, At) : It(Pt, [mt], At, qt, Kt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function It(Pt, mt, At, qt, Kt) {
    let Vt = 1, Xt = Pt.length, yr = mt.length;
    if (qt !== void 0 && (qt = String(qt).toLowerCase(), qt === "ucs2" || qt === "ucs-2" || qt === "utf16le" || qt === "utf-16le")) {
      if (Pt.length < 2 || mt.length < 2)
        return -1;
      Vt = 2, Xt /= 2, yr /= 2, At /= 2;
    }
    function Ar(xr, wr) {
      return Vt === 1 ? xr[wr] : xr.readUInt16BE(wr * Vt);
    }
    let lr;
    if (Kt) {
      let xr = -1;
      for (lr = At; lr < Xt; lr++)
        if (Ar(Pt, lr) === Ar(mt, xr === -1 ? 0 : lr - xr)) {
          if (xr === -1 && (xr = lr), lr - xr + 1 === yr) return xr * Vt;
        } else
          xr !== -1 && (lr -= lr - xr), xr = -1;
    } else
      for (At + yr > Xt && (At = Xt - yr), lr = At; lr >= 0; lr--) {
        let xr = !0;
        for (let wr = 0; wr < yr; wr++)
          if (Ar(Pt, lr + wr) !== Ar(mt, wr)) {
            xr = !1;
            break;
          }
        if (xr) return lr;
      }
    return -1;
  }
  ne.prototype.includes = function(mt, At, qt) {
    return this.indexOf(mt, At, qt) !== -1;
  }, ne.prototype.indexOf = function(mt, At, qt) {
    return St(this, mt, At, qt, !0);
  }, ne.prototype.lastIndexOf = function(mt, At, qt) {
    return St(this, mt, At, qt, !1);
  };
  function Tt(Pt, mt, At, qt) {
    At = Number(At) || 0;
    const Kt = Pt.length - At;
    qt ? (qt = Number(qt), qt > Kt && (qt = Kt)) : qt = Kt;
    const Vt = mt.length;
    qt > Vt / 2 && (qt = Vt / 2);
    let Xt;
    for (Xt = 0; Xt < qt; ++Xt) {
      const yr = parseInt(mt.substr(Xt * 2, 2), 16);
      if (kr(yr)) return Xt;
      Pt[At + Xt] = yr;
    }
    return Xt;
  }
  function nt(Pt, mt, At, qt) {
    return pr(Pr(mt, Pt.length - At), Pt, At, qt);
  }
  function it(Pt, mt, At, qt) {
    return pr(dr(mt), Pt, At, qt);
  }
  function ke(Pt, mt, At, qt) {
    return pr(Rr(mt), Pt, At, qt);
  }
  function rt(Pt, mt, At, qt) {
    return pr(Tr(mt, Pt.length - At), Pt, At, qt);
  }
  ne.prototype.write = function(mt, At, qt, Kt) {
    if (At === void 0)
      Kt = "utf8", qt = this.length, At = 0;
    else if (qt === void 0 && typeof At == "string")
      Kt = At, qt = this.length, At = 0;
    else if (isFinite(At))
      At = At >>> 0, isFinite(qt) ? (qt = qt >>> 0, Kt === void 0 && (Kt = "utf8")) : (Kt = qt, qt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Vt = this.length - At;
    if ((qt === void 0 || qt > Vt) && (qt = Vt), mt.length > 0 && (qt < 0 || At < 0) || At > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Kt || (Kt = "utf8");
    let Xt = !1;
    for (; ; )
      switch (Kt) {
        case "hex":
          return Tt(this, mt, At, qt);
        case "utf8":
        case "utf-8":
          return nt(this, mt, At, qt);
        case "ascii":
        case "latin1":
        case "binary":
          return it(this, mt, At, qt);
        case "base64":
          return ke(this, mt, At, qt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return rt(this, mt, At, qt);
        default:
          if (Xt) throw new TypeError("Unknown encoding: " + Kt);
          Kt = ("" + Kt).toLowerCase(), Xt = !0;
      }
  }, ne.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ot(Pt, mt, At) {
    return mt === 0 && At === Pt.length ? L.fromByteArray(Pt) : L.fromByteArray(Pt.slice(mt, At));
  }
  function ft(Pt, mt, At) {
    At = Math.min(Pt.length, At);
    const qt = [];
    let Kt = mt;
    for (; Kt < At; ) {
      const Vt = Pt[Kt];
      let Xt = null, yr = Vt > 239 ? 4 : Vt > 223 ? 3 : Vt > 191 ? 2 : 1;
      if (Kt + yr <= At) {
        let Ar, lr, xr, wr;
        switch (yr) {
          case 1:
            Vt < 128 && (Xt = Vt);
            break;
          case 2:
            Ar = Pt[Kt + 1], (Ar & 192) === 128 && (wr = (Vt & 31) << 6 | Ar & 63, wr > 127 && (Xt = wr));
            break;
          case 3:
            Ar = Pt[Kt + 1], lr = Pt[Kt + 2], (Ar & 192) === 128 && (lr & 192) === 128 && (wr = (Vt & 15) << 12 | (Ar & 63) << 6 | lr & 63, wr > 2047 && (wr < 55296 || wr > 57343) && (Xt = wr));
            break;
          case 4:
            Ar = Pt[Kt + 1], lr = Pt[Kt + 2], xr = Pt[Kt + 3], (Ar & 192) === 128 && (lr & 192) === 128 && (xr & 192) === 128 && (wr = (Vt & 15) << 18 | (Ar & 63) << 12 | (lr & 63) << 6 | xr & 63, wr > 65535 && wr < 1114112 && (Xt = wr));
        }
      }
      Xt === null ? (Xt = 65533, yr = 1) : Xt > 65535 && (Xt -= 65536, qt.push(Xt >>> 10 & 1023 | 55296), Xt = 56320 | Xt & 1023), qt.push(Xt), Kt += yr;
    }
    return bt(qt);
  }
  const ct = 4096;
  function bt(Pt) {
    const mt = Pt.length;
    if (mt <= ct)
      return String.fromCharCode.apply(String, Pt);
    let At = "", qt = 0;
    for (; qt < mt; )
      At += String.fromCharCode.apply(
        String,
        Pt.slice(qt, qt += ct)
      );
    return At;
  }
  function ut(Pt, mt, At) {
    let qt = "";
    At = Math.min(Pt.length, At);
    for (let Kt = mt; Kt < At; ++Kt)
      qt += String.fromCharCode(Pt[Kt] & 127);
    return qt;
  }
  function gt(Pt, mt, At) {
    let qt = "";
    At = Math.min(Pt.length, At);
    for (let Kt = mt; Kt < At; ++Kt)
      qt += String.fromCharCode(Pt[Kt]);
    return qt;
  }
  function dt(Pt, mt, At) {
    const qt = Pt.length;
    (!mt || mt < 0) && (mt = 0), (!At || At < 0 || At > qt) && (At = qt);
    let Kt = "";
    for (let Vt = mt; Vt < At; ++Vt)
      Kt += vr[Pt[Vt]];
    return Kt;
  }
  function wt(Pt, mt, At) {
    const qt = Pt.slice(mt, At);
    let Kt = "";
    for (let Vt = 0; Vt < qt.length - 1; Vt += 2)
      Kt += String.fromCharCode(qt[Vt] + qt[Vt + 1] * 256);
    return Kt;
  }
  ne.prototype.slice = function(mt, At) {
    const qt = this.length;
    mt = ~~mt, At = At === void 0 ? qt : ~~At, mt < 0 ? (mt += qt, mt < 0 && (mt = 0)) : mt > qt && (mt = qt), At < 0 ? (At += qt, At < 0 && (At = 0)) : At > qt && (At = qt), At < mt && (At = mt);
    const Kt = this.subarray(mt, At);
    return Object.setPrototypeOf(Kt, ne.prototype), Kt;
  };
  function Ft(Pt, mt, At) {
    if (Pt % 1 !== 0 || Pt < 0) throw new RangeError("offset is not uint");
    if (Pt + mt > At) throw new RangeError("Trying to access beyond buffer length");
  }
  ne.prototype.readUintLE = ne.prototype.readUIntLE = function(mt, At, qt) {
    mt = mt >>> 0, At = At >>> 0, qt || Ft(mt, At, this.length);
    let Kt = this[mt], Vt = 1, Xt = 0;
    for (; ++Xt < At && (Vt *= 256); )
      Kt += this[mt + Xt] * Vt;
    return Kt;
  }, ne.prototype.readUintBE = ne.prototype.readUIntBE = function(mt, At, qt) {
    mt = mt >>> 0, At = At >>> 0, qt || Ft(mt, At, this.length);
    let Kt = this[mt + --At], Vt = 1;
    for (; At > 0 && (Vt *= 256); )
      Kt += this[mt + --At] * Vt;
    return Kt;
  }, ne.prototype.readUint8 = ne.prototype.readUInt8 = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 1, this.length), this[mt];
  }, ne.prototype.readUint16LE = ne.prototype.readUInt16LE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 2, this.length), this[mt] | this[mt + 1] << 8;
  }, ne.prototype.readUint16BE = ne.prototype.readUInt16BE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 2, this.length), this[mt] << 8 | this[mt + 1];
  }, ne.prototype.readUint32LE = ne.prototype.readUInt32LE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 4, this.length), (this[mt] | this[mt + 1] << 8 | this[mt + 2] << 16) + this[mt + 3] * 16777216;
  }, ne.prototype.readUint32BE = ne.prototype.readUInt32BE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 4, this.length), this[mt] * 16777216 + (this[mt + 1] << 16 | this[mt + 2] << 8 | this[mt + 3]);
  }, ne.prototype.readBigUInt64LE = Mr(function(mt) {
    mt = mt >>> 0, ar(mt, "offset");
    const At = this[mt], qt = this[mt + 7];
    (At === void 0 || qt === void 0) && cr(mt, this.length - 8);
    const Kt = At + this[++mt] * 2 ** 8 + this[++mt] * 2 ** 16 + this[++mt] * 2 ** 24, Vt = this[++mt] + this[++mt] * 2 ** 8 + this[++mt] * 2 ** 16 + qt * 2 ** 24;
    return BigInt(Kt) + (BigInt(Vt) << BigInt(32));
  }), ne.prototype.readBigUInt64BE = Mr(function(mt) {
    mt = mt >>> 0, ar(mt, "offset");
    const At = this[mt], qt = this[mt + 7];
    (At === void 0 || qt === void 0) && cr(mt, this.length - 8);
    const Kt = At * 2 ** 24 + this[++mt] * 2 ** 16 + this[++mt] * 2 ** 8 + this[++mt], Vt = this[++mt] * 2 ** 24 + this[++mt] * 2 ** 16 + this[++mt] * 2 ** 8 + qt;
    return (BigInt(Kt) << BigInt(32)) + BigInt(Vt);
  }), ne.prototype.readIntLE = function(mt, At, qt) {
    mt = mt >>> 0, At = At >>> 0, qt || Ft(mt, At, this.length);
    let Kt = this[mt], Vt = 1, Xt = 0;
    for (; ++Xt < At && (Vt *= 256); )
      Kt += this[mt + Xt] * Vt;
    return Vt *= 128, Kt >= Vt && (Kt -= Math.pow(2, 8 * At)), Kt;
  }, ne.prototype.readIntBE = function(mt, At, qt) {
    mt = mt >>> 0, At = At >>> 0, qt || Ft(mt, At, this.length);
    let Kt = At, Vt = 1, Xt = this[mt + --Kt];
    for (; Kt > 0 && (Vt *= 256); )
      Xt += this[mt + --Kt] * Vt;
    return Vt *= 128, Xt >= Vt && (Xt -= Math.pow(2, 8 * At)), Xt;
  }, ne.prototype.readInt8 = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 1, this.length), this[mt] & 128 ? (255 - this[mt] + 1) * -1 : this[mt];
  }, ne.prototype.readInt16LE = function(mt, At) {
    mt = mt >>> 0, At || Ft(mt, 2, this.length);
    const qt = this[mt] | this[mt + 1] << 8;
    return qt & 32768 ? qt | 4294901760 : qt;
  }, ne.prototype.readInt16BE = function(mt, At) {
    mt = mt >>> 0, At || Ft(mt, 2, this.length);
    const qt = this[mt + 1] | this[mt] << 8;
    return qt & 32768 ? qt | 4294901760 : qt;
  }, ne.prototype.readInt32LE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 4, this.length), this[mt] | this[mt + 1] << 8 | this[mt + 2] << 16 | this[mt + 3] << 24;
  }, ne.prototype.readInt32BE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 4, this.length), this[mt] << 24 | this[mt + 1] << 16 | this[mt + 2] << 8 | this[mt + 3];
  }, ne.prototype.readBigInt64LE = Mr(function(mt) {
    mt = mt >>> 0, ar(mt, "offset");
    const At = this[mt], qt = this[mt + 7];
    (At === void 0 || qt === void 0) && cr(mt, this.length - 8);
    const Kt = this[mt + 4] + this[mt + 5] * 2 ** 8 + this[mt + 6] * 2 ** 16 + (qt << 24);
    return (BigInt(Kt) << BigInt(32)) + BigInt(At + this[++mt] * 2 ** 8 + this[++mt] * 2 ** 16 + this[++mt] * 2 ** 24);
  }), ne.prototype.readBigInt64BE = Mr(function(mt) {
    mt = mt >>> 0, ar(mt, "offset");
    const At = this[mt], qt = this[mt + 7];
    (At === void 0 || qt === void 0) && cr(mt, this.length - 8);
    const Kt = (At << 24) + // Overflow
    this[++mt] * 2 ** 16 + this[++mt] * 2 ** 8 + this[++mt];
    return (BigInt(Kt) << BigInt(32)) + BigInt(this[++mt] * 2 ** 24 + this[++mt] * 2 ** 16 + this[++mt] * 2 ** 8 + qt);
  }), ne.prototype.readFloatLE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 4, this.length), W.read(this, mt, !0, 23, 4);
  }, ne.prototype.readFloatBE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 4, this.length), W.read(this, mt, !1, 23, 4);
  }, ne.prototype.readDoubleLE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 8, this.length), W.read(this, mt, !0, 52, 8);
  }, ne.prototype.readDoubleBE = function(mt, At) {
    return mt = mt >>> 0, At || Ft(mt, 8, this.length), W.read(this, mt, !1, 52, 8);
  };
  function jt(Pt, mt, At, qt, Kt, Vt) {
    if (!ne.isBuffer(Pt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (mt > Kt || mt < Vt) throw new RangeError('"value" argument is out of bounds');
    if (At + qt > Pt.length) throw new RangeError("Index out of range");
  }
  ne.prototype.writeUintLE = ne.prototype.writeUIntLE = function(mt, At, qt, Kt) {
    if (mt = +mt, At = At >>> 0, qt = qt >>> 0, !Kt) {
      const yr = Math.pow(2, 8 * qt) - 1;
      jt(this, mt, At, qt, yr, 0);
    }
    let Vt = 1, Xt = 0;
    for (this[At] = mt & 255; ++Xt < qt && (Vt *= 256); )
      this[At + Xt] = mt / Vt & 255;
    return At + qt;
  }, ne.prototype.writeUintBE = ne.prototype.writeUIntBE = function(mt, At, qt, Kt) {
    if (mt = +mt, At = At >>> 0, qt = qt >>> 0, !Kt) {
      const yr = Math.pow(2, 8 * qt) - 1;
      jt(this, mt, At, qt, yr, 0);
    }
    let Vt = qt - 1, Xt = 1;
    for (this[At + Vt] = mt & 255; --Vt >= 0 && (Xt *= 256); )
      this[At + Vt] = mt / Xt & 255;
    return At + qt;
  }, ne.prototype.writeUint8 = ne.prototype.writeUInt8 = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 1, 255, 0), this[At] = mt & 255, At + 1;
  }, ne.prototype.writeUint16LE = ne.prototype.writeUInt16LE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 2, 65535, 0), this[At] = mt & 255, this[At + 1] = mt >>> 8, At + 2;
  }, ne.prototype.writeUint16BE = ne.prototype.writeUInt16BE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 2, 65535, 0), this[At] = mt >>> 8, this[At + 1] = mt & 255, At + 2;
  }, ne.prototype.writeUint32LE = ne.prototype.writeUInt32LE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 4, 4294967295, 0), this[At + 3] = mt >>> 24, this[At + 2] = mt >>> 16, this[At + 1] = mt >>> 8, this[At] = mt & 255, At + 4;
  }, ne.prototype.writeUint32BE = ne.prototype.writeUInt32BE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 4, 4294967295, 0), this[At] = mt >>> 24, this[At + 1] = mt >>> 16, this[At + 2] = mt >>> 8, this[At + 3] = mt & 255, At + 4;
  };
  function Nt(Pt, mt, At, qt, Kt) {
    nr(mt, qt, Kt, Pt, At, 7);
    let Vt = Number(mt & BigInt(4294967295));
    Pt[At++] = Vt, Vt = Vt >> 8, Pt[At++] = Vt, Vt = Vt >> 8, Pt[At++] = Vt, Vt = Vt >> 8, Pt[At++] = Vt;
    let Xt = Number(mt >> BigInt(32) & BigInt(4294967295));
    return Pt[At++] = Xt, Xt = Xt >> 8, Pt[At++] = Xt, Xt = Xt >> 8, Pt[At++] = Xt, Xt = Xt >> 8, Pt[At++] = Xt, At;
  }
  function Bt(Pt, mt, At, qt, Kt) {
    nr(mt, qt, Kt, Pt, At, 7);
    let Vt = Number(mt & BigInt(4294967295));
    Pt[At + 7] = Vt, Vt = Vt >> 8, Pt[At + 6] = Vt, Vt = Vt >> 8, Pt[At + 5] = Vt, Vt = Vt >> 8, Pt[At + 4] = Vt;
    let Xt = Number(mt >> BigInt(32) & BigInt(4294967295));
    return Pt[At + 3] = Xt, Xt = Xt >> 8, Pt[At + 2] = Xt, Xt = Xt >> 8, Pt[At + 1] = Xt, Xt = Xt >> 8, Pt[At] = Xt, At + 8;
  }
  ne.prototype.writeBigUInt64LE = Mr(function(mt, At = 0) {
    return Nt(this, mt, At, BigInt(0), BigInt("0xffffffffffffffff"));
  }), ne.prototype.writeBigUInt64BE = Mr(function(mt, At = 0) {
    return Bt(this, mt, At, BigInt(0), BigInt("0xffffffffffffffff"));
  }), ne.prototype.writeIntLE = function(mt, At, qt, Kt) {
    if (mt = +mt, At = At >>> 0, !Kt) {
      const Ar = Math.pow(2, 8 * qt - 1);
      jt(this, mt, At, qt, Ar - 1, -Ar);
    }
    let Vt = 0, Xt = 1, yr = 0;
    for (this[At] = mt & 255; ++Vt < qt && (Xt *= 256); )
      mt < 0 && yr === 0 && this[At + Vt - 1] !== 0 && (yr = 1), this[At + Vt] = (mt / Xt >> 0) - yr & 255;
    return At + qt;
  }, ne.prototype.writeIntBE = function(mt, At, qt, Kt) {
    if (mt = +mt, At = At >>> 0, !Kt) {
      const Ar = Math.pow(2, 8 * qt - 1);
      jt(this, mt, At, qt, Ar - 1, -Ar);
    }
    let Vt = qt - 1, Xt = 1, yr = 0;
    for (this[At + Vt] = mt & 255; --Vt >= 0 && (Xt *= 256); )
      mt < 0 && yr === 0 && this[At + Vt + 1] !== 0 && (yr = 1), this[At + Vt] = (mt / Xt >> 0) - yr & 255;
    return At + qt;
  }, ne.prototype.writeInt8 = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 1, 127, -128), mt < 0 && (mt = 255 + mt + 1), this[At] = mt & 255, At + 1;
  }, ne.prototype.writeInt16LE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 2, 32767, -32768), this[At] = mt & 255, this[At + 1] = mt >>> 8, At + 2;
  }, ne.prototype.writeInt16BE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 2, 32767, -32768), this[At] = mt >>> 8, this[At + 1] = mt & 255, At + 2;
  }, ne.prototype.writeInt32LE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 4, 2147483647, -2147483648), this[At] = mt & 255, this[At + 1] = mt >>> 8, this[At + 2] = mt >>> 16, this[At + 3] = mt >>> 24, At + 4;
  }, ne.prototype.writeInt32BE = function(mt, At, qt) {
    return mt = +mt, At = At >>> 0, qt || jt(this, mt, At, 4, 2147483647, -2147483648), mt < 0 && (mt = 4294967295 + mt + 1), this[At] = mt >>> 24, this[At + 1] = mt >>> 16, this[At + 2] = mt >>> 8, this[At + 3] = mt & 255, At + 4;
  }, ne.prototype.writeBigInt64LE = Mr(function(mt, At = 0) {
    return Nt(this, mt, At, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), ne.prototype.writeBigInt64BE = Mr(function(mt, At = 0) {
    return Bt(this, mt, At, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Rt(Pt, mt, At, qt, Kt, Vt) {
    if (At + qt > Pt.length) throw new RangeError("Index out of range");
    if (At < 0) throw new RangeError("Index out of range");
  }
  function Ut(Pt, mt, At, qt, Kt) {
    return mt = +mt, At = At >>> 0, Kt || Rt(Pt, mt, At, 4), W.write(Pt, mt, At, qt, 23, 4), At + 4;
  }
  ne.prototype.writeFloatLE = function(mt, At, qt) {
    return Ut(this, mt, At, !0, qt);
  }, ne.prototype.writeFloatBE = function(mt, At, qt) {
    return Ut(this, mt, At, !1, qt);
  };
  function zt(Pt, mt, At, qt, Kt) {
    return mt = +mt, At = At >>> 0, Kt || Rt(Pt, mt, At, 8), W.write(Pt, mt, At, qt, 52, 8), At + 8;
  }
  ne.prototype.writeDoubleLE = function(mt, At, qt) {
    return zt(this, mt, At, !0, qt);
  }, ne.prototype.writeDoubleBE = function(mt, At, qt) {
    return zt(this, mt, At, !1, qt);
  }, ne.prototype.copy = function(mt, At, qt, Kt) {
    if (!ne.isBuffer(mt)) throw new TypeError("argument should be a Buffer");
    if (qt || (qt = 0), !Kt && Kt !== 0 && (Kt = this.length), At >= mt.length && (At = mt.length), At || (At = 0), Kt > 0 && Kt < qt && (Kt = qt), Kt === qt || mt.length === 0 || this.length === 0) return 0;
    if (At < 0)
      throw new RangeError("targetStart out of bounds");
    if (qt < 0 || qt >= this.length) throw new RangeError("Index out of range");
    if (Kt < 0) throw new RangeError("sourceEnd out of bounds");
    Kt > this.length && (Kt = this.length), mt.length - At < Kt - qt && (Kt = mt.length - At + qt);
    const Vt = Kt - qt;
    return this === mt && typeof V.prototype.copyWithin == "function" ? this.copyWithin(At, qt, Kt) : V.prototype.set.call(
      mt,
      this.subarray(qt, Kt),
      At
    ), Vt;
  }, ne.prototype.fill = function(mt, At, qt, Kt) {
    if (typeof mt == "string") {
      if (typeof At == "string" ? (Kt = At, At = 0, qt = this.length) : typeof qt == "string" && (Kt = qt, qt = this.length), Kt !== void 0 && typeof Kt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Kt == "string" && !ne.isEncoding(Kt))
        throw new TypeError("Unknown encoding: " + Kt);
      if (mt.length === 1) {
        const Xt = mt.charCodeAt(0);
        (Kt === "utf8" && Xt < 128 || Kt === "latin1") && (mt = Xt);
      }
    } else typeof mt == "number" ? mt = mt & 255 : typeof mt == "boolean" && (mt = Number(mt));
    if (At < 0 || this.length < At || this.length < qt)
      throw new RangeError("Out of range index");
    if (qt <= At)
      return this;
    At = At >>> 0, qt = qt === void 0 ? this.length : qt >>> 0, mt || (mt = 0);
    let Vt;
    if (typeof mt == "number")
      for (Vt = At; Vt < qt; ++Vt)
        this[Vt] = mt;
    else {
      const Xt = ne.isBuffer(mt) ? mt : ne.from(mt, Kt), yr = Xt.length;
      if (yr === 0)
        throw new TypeError('The value "' + mt + '" is invalid for argument "value"');
      for (Vt = 0; Vt < qt - At; ++Vt)
        this[Vt + At] = Xt[Vt % yr];
    }
    return this;
  };
  const Mt = {};
  function kt(Pt, mt, At) {
    Mt[Pt] = class extends At {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: mt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Pt}]`, this.stack, delete this.name;
      }
      get code() {
        return Pt;
      }
      set code(Kt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Kt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Pt}]: ${this.message}`;
      }
    };
  }
  kt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Pt) {
      return Pt ? `${Pt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), kt(
    "ERR_INVALID_ARG_TYPE",
    function(Pt, mt) {
      return `The "${Pt}" argument must be of type number. Received type ${typeof mt}`;
    },
    TypeError
  ), kt(
    "ERR_OUT_OF_RANGE",
    function(Pt, mt, At) {
      let qt = `The value of "${Pt}" is out of range.`, Kt = At;
      return Number.isInteger(At) && Math.abs(At) > 2 ** 32 ? Kt = Gt(String(At)) : typeof At == "bigint" && (Kt = String(At), (At > BigInt(2) ** BigInt(32) || At < -(BigInt(2) ** BigInt(32))) && (Kt = Gt(Kt)), Kt += "n"), qt += ` It must be ${mt}. Received ${Kt}`, qt;
    },
    RangeError
  );
  function Gt(Pt) {
    let mt = "", At = Pt.length;
    const qt = Pt[0] === "-" ? 1 : 0;
    for (; At >= qt + 4; At -= 3)
      mt = `_${Pt.slice(At - 3, At)}${mt}`;
    return `${Pt.slice(0, At)}${mt}`;
  }
  function Qt(Pt, mt, At) {
    ar(mt, "offset"), (Pt[mt] === void 0 || Pt[mt + At] === void 0) && cr(mt, Pt.length - (At + 1));
  }
  function nr(Pt, mt, At, qt, Kt, Vt) {
    if (Pt > At || Pt < mt) {
      const Xt = typeof mt == "bigint" ? "n" : "";
      let yr;
      throw mt === 0 || mt === BigInt(0) ? yr = `>= 0${Xt} and < 2${Xt} ** ${(Vt + 1) * 8}${Xt}` : yr = `>= -(2${Xt} ** ${(Vt + 1) * 8 - 1}${Xt}) and < 2 ** ${(Vt + 1) * 8 - 1}${Xt}`, new Mt.ERR_OUT_OF_RANGE("value", yr, Pt);
    }
    Qt(qt, Kt, Vt);
  }
  function ar(Pt, mt) {
    if (typeof Pt != "number")
      throw new Mt.ERR_INVALID_ARG_TYPE(mt, "number", Pt);
  }
  function cr(Pt, mt, At) {
    throw Math.floor(Pt) !== Pt ? (ar(Pt, At), new Mt.ERR_OUT_OF_RANGE("offset", "an integer", Pt)) : mt < 0 ? new Mt.ERR_BUFFER_OUT_OF_BOUNDS() : new Mt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${mt}`,
      Pt
    );
  }
  const hr = /[^+/0-9A-Za-z-_]/g;
  function Jt(Pt) {
    if (Pt = Pt.split("=")[0], Pt = Pt.trim().replace(hr, ""), Pt.length < 2) return "";
    for (; Pt.length % 4 !== 0; )
      Pt = Pt + "=";
    return Pt;
  }
  function Pr(Pt, mt) {
    mt = mt || 1 / 0;
    let At;
    const qt = Pt.length;
    let Kt = null;
    const Vt = [];
    for (let Xt = 0; Xt < qt; ++Xt) {
      if (At = Pt.charCodeAt(Xt), At > 55295 && At < 57344) {
        if (!Kt) {
          if (At > 56319) {
            (mt -= 3) > -1 && Vt.push(239, 191, 189);
            continue;
          } else if (Xt + 1 === qt) {
            (mt -= 3) > -1 && Vt.push(239, 191, 189);
            continue;
          }
          Kt = At;
          continue;
        }
        if (At < 56320) {
          (mt -= 3) > -1 && Vt.push(239, 191, 189), Kt = At;
          continue;
        }
        At = (Kt - 55296 << 10 | At - 56320) + 65536;
      } else Kt && (mt -= 3) > -1 && Vt.push(239, 191, 189);
      if (Kt = null, At < 128) {
        if ((mt -= 1) < 0) break;
        Vt.push(At);
      } else if (At < 2048) {
        if ((mt -= 2) < 0) break;
        Vt.push(
          At >> 6 | 192,
          At & 63 | 128
        );
      } else if (At < 65536) {
        if ((mt -= 3) < 0) break;
        Vt.push(
          At >> 12 | 224,
          At >> 6 & 63 | 128,
          At & 63 | 128
        );
      } else if (At < 1114112) {
        if ((mt -= 4) < 0) break;
        Vt.push(
          At >> 18 | 240,
          At >> 12 & 63 | 128,
          At >> 6 & 63 | 128,
          At & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Vt;
  }
  function dr(Pt) {
    const mt = [];
    for (let At = 0; At < Pt.length; ++At)
      mt.push(Pt.charCodeAt(At) & 255);
    return mt;
  }
  function Tr(Pt, mt) {
    let At, qt, Kt;
    const Vt = [];
    for (let Xt = 0; Xt < Pt.length && !((mt -= 2) < 0); ++Xt)
      At = Pt.charCodeAt(Xt), qt = At >> 8, Kt = At % 256, Vt.push(Kt), Vt.push(qt);
    return Vt;
  }
  function Rr(Pt) {
    return L.toByteArray(Jt(Pt));
  }
  function pr(Pt, mt, At, qt) {
    let Kt;
    for (Kt = 0; Kt < qt && !(Kt + At >= mt.length || Kt >= Pt.length); ++Kt)
      mt[Kt + At] = Pt[Kt];
    return Kt;
  }
  function $r(Pt, mt) {
    return Pt instanceof mt || Pt != null && Pt.constructor != null && Pt.constructor.name != null && Pt.constructor.name === mt.name;
  }
  function kr(Pt) {
    return Pt !== Pt;
  }
  const vr = function() {
    const Pt = "0123456789abcdef", mt = new Array(256);
    for (let At = 0; At < 16; ++At) {
      const qt = At * 16;
      for (let Kt = 0; Kt < 16; ++Kt)
        mt[qt + Kt] = Pt[At] + Pt[Kt];
    }
    return mt;
  }();
  function Mr(Pt) {
    return typeof BigInt > "u" ? Nr : Pt;
  }
  function Nr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$2 = buffer$1.Buffer, Blob$1 = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$2,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var src$4 = {}, address = {}, networks$2 = {};
Object.defineProperty(networks$2, "__esModule", { value: !0 });
networks$2.testnet = networks$2.regtest = networks$2.bitcoin = void 0;
networks$2.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks$2.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks$2.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const L = B[3];
  if (L === 0 || 5 + L >= B.length || B[4 + L] !== 2) return !1;
  const W = B[5 + L];
  return !(W === 0 || 6 + L + W !== B.length || B[4] & 128 || L > 1 && B[4] === 0 && !(B[5] & 128) || B[L + 6] & 128 || W > 1 && B[L + 6] === 0 && !(B[L + 7] & 128));
}
bip66.check = check$d;
function decode$k(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const L = B[3];
  if (L === 0) throw new Error("R length is zero");
  if (5 + L >= B.length) throw new Error("R length is too long");
  if (B[4 + L] !== 2) throw new Error("Expected DER integer (2)");
  const W = B[5 + L];
  if (W === 0) throw new Error("S length is zero");
  if (6 + L + W !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (L > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[L + 6] & 128) throw new Error("S value is negative");
  if (W > 1 && B[L + 6] === 0 && !(B[L + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + L),
    s: B.slice(6 + L)
  };
}
bip66.decode = decode$k;
function encode$k(B, L) {
  const W = B.length, K = L.length;
  if (W === 0) throw new Error("R length is zero");
  if (K === 0) throw new Error("S length is zero");
  if (W > 33) throw new Error("R length is too long");
  if (K > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (L[0] & 128) throw new Error("S value is negative");
  if (W > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (K > 1 && L[0] === 0 && !(L[1] & 128))
    throw new Error("S value excessively padded");
  const J = Buffer$2.allocUnsafe(6 + W + K);
  return J[0] = 48, J[1] = J.length - 2, J[2] = 2, J[3] = B.length, B.copy(J, 4), J[4 + W] = 2, J[5 + W] = L.length, L.copy(J, 6 + W), J;
}
bip66.encode = encode$k;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const L = OPS$7[B];
  REVERSE_OPS[L] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$j(B, L, W) {
  const K = encodingLength$2(L);
  return K === 1 ? B.writeUInt8(L, W) : K === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, W), B.writeUInt8(L, W + 1)) : K === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, W), B.writeUInt16LE(L, W + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, W), B.writeUInt32LE(L, W + 1)), K;
}
push_data.encode = encode$j;
function decode$j(B, L) {
  const W = B.readUInt8(L);
  let K, J;
  if (W < ops_1.OPS.OP_PUSHDATA1)
    K = W, J = 1;
  else if (W === ops_1.OPS.OP_PUSHDATA1) {
    if (L + 2 > B.length) return null;
    K = B.readUInt8(L + 1), J = 2;
  } else if (W === ops_1.OPS.OP_PUSHDATA2) {
    if (L + 3 > B.length) return null;
    K = B.readUInt16LE(L + 1), J = 3;
  } else {
    if (L + 5 > B.length) return null;
    if (W !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    K = B.readUInt32LE(L + 1), J = 5;
  }
  return {
    opcode: W,
    number: K,
    size: J
  };
}
push_data.decode = decode$j;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$i(B, L, W) {
  L = L || 4, W = W === void 0 ? !0 : W;
  const K = B.length;
  if (K === 0) return 0;
  if (K > L) throw new TypeError("Script number overflow");
  if (W && !(B[K - 1] & 127) && (K <= 1 || !(B[K - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (K === 5) {
    const V = B.readUInt32LE(0), re = B.readUInt8(4);
    return re & 128 ? -((re & -129) * 4294967296 + V) : re * 4294967296 + V;
  }
  let J = 0;
  for (let V = 0; V < K; ++V)
    J |= B[V] << 8 * V;
  return B[K - 1] & 128 ? -(J & ~(128 << 8 * (K - 1))) : J;
}
script_number.decode = decode$i;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$i(B) {
  let L = Math.abs(B);
  const W = scriptNumSize(L), K = Buffer$2.allocUnsafe(W), J = B < 0;
  for (let V = 0; V < W; ++V)
    K.writeUInt8(L & 255, V), L >>= 8;
  return K[W - 1] & 128 ? K.writeUInt8(J ? 128 : 0, W - 1) : J && (K[W - 1] |= 128), K;
}
script_number.encode = encode$i;
var script_signature = {}, types$7 = {};
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist$2);
var types$6 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$6.Null = types$6.Nil;
for (var typeName$1 in types$6)
  types$6[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$6, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue$1(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, L) {
  Error.captureStackTrace && Error.captureStackTrace(B, L);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, L, W) {
  var K = getValue$1(L);
  return "Expected " + tfJSON$1(B) + ", got" + (W !== "" ? " " + W : "") + (K !== "" ? " " + K : "");
}
function TfTypeError$1(B, L, W) {
  W = W || getValueTypeName$1(L), this.message = tfErrorString(B, L, W), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = L, this.__valueTypeName = W;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, L, W, K, J) {
  var V = '" of type ';
  return L === "key" && (V = '" with key type '), tfErrorString('property "' + tfJSON$1(W) + V + tfJSON$1(B), K, J);
}
function TfPropertyTypeError$1(B, L, W, K, J) {
  B ? (J = J || getValueTypeName$1(K), this.message = tfPropertyErrorString(B, W, L, K, J)) : this.message = 'Unexpected property "' + L + '"', captureStackTrace(this, TfTypeError$1), this.__label = W, this.__property = L, this.__type = B, this.__value = K, this.__valueTypeName = J;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, L) {
  return new TfTypeError$1(B, {}, L);
}
function tfSubError$1(B, L, W) {
  return B instanceof TfPropertyTypeError$1 ? (L = L + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    L,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    L,
    W,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors$1 = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, L = errors$1;
  function W(xt) {
    return Buffer$2.isBuffer(xt);
  }
  function K(xt) {
    return typeof xt == "string" && /^([0-9a-f]{2})+$/i.test(xt);
  }
  function J(xt, Ct) {
    var Et = xt.toJSON();
    function St(It) {
      if (!xt(It)) return !1;
      if (It.length === Ct) return !0;
      throw L.tfCustomError(Et + "(Length: " + Ct + ")", Et + "(Length: " + It.length + ")");
    }
    return St.toJSON = function() {
      return Et;
    }, St;
  }
  var V = J.bind(null, B.Array), re = J.bind(null, W), ie = J.bind(null, K), oe = J.bind(null, B.String);
  function pe(xt, Ct, Et) {
    Et = Et || B.Number;
    function St(It, Tt) {
      return Et(It, Tt) && It > xt && It < Ct;
    }
    return St.toJSON = function() {
      return `${Et.toJSON()} between [${xt}, ${Ct}]`;
    }, St;
  }
  var ne = Math.pow(2, 53) - 1;
  function ce(xt) {
    return typeof xt == "number" && isFinite(xt);
  }
  function Ce(xt) {
    return xt << 24 >> 24 === xt;
  }
  function Oe(xt) {
    return xt << 16 >> 16 === xt;
  }
  function st(xt) {
    return (xt | 0) === xt;
  }
  function at(xt) {
    return typeof xt == "number" && xt >= -ne && xt <= ne && Math.floor(xt) === xt;
  }
  function lt(xt) {
    return (xt & 255) === xt;
  }
  function pt(xt) {
    return (xt & 65535) === xt;
  }
  function ht(xt) {
    return xt >>> 0 === xt;
  }
  function yt(xt) {
    return typeof xt == "number" && xt >= 0 && xt <= ne && Math.floor(xt) === xt;
  }
  var vt = {
    ArrayN: V,
    Buffer: W,
    BufferN: re,
    Finite: ce,
    Hex: K,
    HexN: ie,
    Int8: Ce,
    Int16: Oe,
    Int32: st,
    Int53: at,
    Range: pe,
    StringN: oe,
    UInt8: lt,
    UInt16: pt,
    UInt32: ht,
    UInt53: yt
  };
  for (var $t in vt)
    vt[$t].toJSON = (function(xt) {
      return xt;
    }).bind(null, $t);
  return extra = vt, extra;
}
var ERRORS = errors$1, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function(L, W) {
    L = compile(L), W = W || {};
    function K(J, V) {
      return !NATIVE.Array(J) || NATIVE.Nil(J) || W.minLength !== void 0 && J.length < W.minLength || W.maxLength !== void 0 && J.length > W.maxLength || W.length !== void 0 && J.length !== W.length ? !1 : J.every(function(re, ie) {
        try {
          return typeforce$4(L, re, V);
        } catch (oe) {
          throw tfSubError(oe, ie);
        }
      });
    }
    return K.toJSON = function() {
      var J = "[" + tfJSON(L) + "]";
      return W.length !== void 0 ? J += "{" + W.length + "}" : (W.minLength !== void 0 || W.maxLength !== void 0) && (J += "{" + (W.minLength === void 0 ? 0 : W.minLength) + "," + (W.maxLength === void 0 ? 1 / 0 : W.maxLength) + "}"), J;
    }, K;
  },
  maybe: function B(L) {
    L = compile(L);
    function W(K, J) {
      return NATIVE.Nil(K) || L(K, J, B);
    }
    return W.toJSON = function() {
      return "?" + tfJSON(L);
    }, W;
  },
  map: function(L, W) {
    L = compile(L), W && (W = compile(W));
    function K(J, V) {
      if (!NATIVE.Object(J) || NATIVE.Nil(J)) return !1;
      for (var re in J) {
        try {
          W && typeforce$4(W, re, V);
        } catch (oe) {
          throw tfSubError(oe, re, "key");
        }
        try {
          var ie = J[re];
          typeforce$4(L, ie, V);
        } catch (oe) {
          throw tfSubError(oe, re);
        }
      }
      return !0;
    }
    return W ? K.toJSON = function() {
      return "{" + tfJSON(W) + ": " + tfJSON(L) + "}";
    } : K.toJSON = function() {
      return "{" + tfJSON(L) + "}";
    }, K;
  },
  object: function(L) {
    var W = {};
    for (var K in L)
      W[K] = compile(L[K]);
    function J(V, re) {
      if (!NATIVE.Object(V) || NATIVE.Nil(V)) return !1;
      var ie;
      try {
        for (ie in W) {
          var oe = W[ie], pe = V[ie];
          typeforce$4(oe, pe, re);
        }
      } catch (ne) {
        throw tfSubError(ne, ie);
      }
      if (re) {
        for (ie in V)
          if (!W[ie])
            throw new TfPropertyTypeError(void 0, ie);
      }
      return !0;
    }
    return J.toJSON = function() {
      return tfJSON(W);
    }, J;
  },
  anyOf: function() {
    var L = [].slice.call(arguments).map(compile);
    function W(K, J) {
      return L.some(function(V) {
        try {
          return typeforce$4(V, K, J);
        } catch {
          return !1;
        }
      });
    }
    return W.toJSON = function() {
      return L.map(tfJSON).join("|");
    }, W;
  },
  allOf: function() {
    var L = [].slice.call(arguments).map(compile);
    function W(K, J) {
      return L.every(function(V) {
        try {
          return typeforce$4(V, K, J);
        } catch {
          return !1;
        }
      });
    }
    return W.toJSON = function() {
      return L.map(tfJSON).join(" & ");
    }, W;
  },
  quacksLike: function(L) {
    function W(K) {
      return L === getValueTypeName(K);
    }
    return W.toJSON = function() {
      return L;
    }, W;
  },
  tuple: function() {
    var L = [].slice.call(arguments).map(compile);
    function W(K, J) {
      return NATIVE.Nil(K) || NATIVE.Nil(K.length) || J && K.length !== L.length ? !1 : L.every(function(V, re) {
        try {
          return typeforce$4(V, K[re], J);
        } catch (ie) {
          throw tfSubError(ie, re);
        }
      });
    }
    return W.toJSON = function() {
      return "(" + L.map(tfJSON).join(", ") + ")";
    }, W;
  },
  value: function(L) {
    function W(K) {
      return K === L;
    }
    return W.toJSON = function() {
      return L;
    }, W;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$4(B, L, W, K) {
  if (NATIVE.Function(B)) {
    if (B(L, W)) return !0;
    throw new TfTypeError(K || B, L);
  }
  return typeforce$4(compile(B), L, W);
}
for (var typeName in NATIVE)
  typeforce$4[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$4[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$4[typeName] = EXTRA[typeName];
typeforce$4.compile = compile;
typeforce$4.TfTypeError = TfTypeError;
typeforce$4.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$4;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const L = require$$1$2;
  B.typeforce = typeforce_1;
  const W = L.Buffer.alloc(32, 0), K = L.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function J(ne, ce) {
    return ne.length !== ce.length ? !1 : ne.every((Ce, Oe) => Ce.equals(ce[Oe]));
  }
  B.stacksEqual = J;
  function V(ne) {
    if (!L.Buffer.isBuffer(ne) || ne.length < 33) return !1;
    const ce = ne[0], Ce = ne.slice(1, 33);
    if (Ce.compare(W) === 0 || Ce.compare(K) >= 0) return !1;
    if ((ce === 2 || ce === 3) && ne.length === 33)
      return !0;
    const Oe = ne.slice(33);
    return Oe.compare(W) === 0 || Oe.compare(K) >= 0 ? !1 : ce === 4 && ne.length === 65;
  }
  B.isPoint = V;
  const re = 21 * 1e14;
  function ie(ne) {
    return B.typeforce.UInt53(ne) && ne <= re;
  }
  B.Satoshi = ie, B.TAPLEAF_VERSION_MASK = 254;
  function oe(ne) {
    return !ne || !("output" in ne) || !L.Buffer.isBuffer(ne.output) ? !1 : ne.version !== void 0 ? (ne.version & B.TAPLEAF_VERSION_MASK) === ne.version : !0;
  }
  B.isTapleaf = oe;
  function pe(ne) {
    return (0, B.Array)(ne) ? ne.length !== 2 ? !1 : ne.every((ce) => pe(ce)) : oe(ne);
  }
  B.isTaptree = pe, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$7);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, L = requireScript(), W = types$7, { typeforce: K } = W, J = Buffer$2.alloc(1, 0);
  function V(pe) {
    let ne = 0;
    for (; pe[ne] === 0; ) ++ne;
    return ne === pe.length ? J : (pe = pe.slice(ne), pe[0] & 128 ? Buffer$2.concat([J, pe], 1 + pe.length) : pe);
  }
  function re(pe) {
    pe[0] === 0 && (pe = pe.slice(1));
    const ne = Buffer$2.alloc(32, 0), ce = Math.max(0, 32 - pe.length);
    return pe.copy(ne, ce), ne;
  }
  function ie(pe) {
    const ne = pe.readUInt8(pe.length - 1);
    if (!(0, L.isDefinedHashType)(ne))
      throw new Error("Invalid hashType " + ne);
    const ce = B.decode(pe.slice(0, -1)), Ce = re(ce.r), Oe = re(ce.s);
    return { signature: Buffer$2.concat([Ce, Oe], 64), hashType: ne };
  }
  script_signature.decode = ie;
  function oe(pe, ne) {
    if (K(
      {
        signature: W.BufferN(64),
        hashType: W.UInt8
      },
      { signature: pe, hashType: ne }
    ), !(0, L.isDefinedHashType)(ne))
      throw new Error("Invalid hashType " + ne);
    const ce = Buffer$2.allocUnsafe(1);
    ce.writeUInt8(ne, 0);
    const Ce = V(pe.slice(0, 32)), Oe = V(pe.slice(32, 64));
    return Buffer$2.concat([B.encode(Ce, Oe), ce]);
  }
  return script_signature.encode = oe, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const L = bip66, W = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return W.OPS;
      }
    });
    const K = push_data, J = script_number, V = requireScript_signature(), re = types$7, { typeforce: ie } = re, oe = W.OPS.OP_RESERVED;
    function pe(St) {
      return re.Number(St) && (St === W.OPS.OP_0 || St >= W.OPS.OP_1 && St <= W.OPS.OP_16 || St === W.OPS.OP_1NEGATE);
    }
    function ne(St) {
      return re.Buffer(St) || pe(St);
    }
    function ce(St) {
      return re.Array(St) && St.every(ne);
    }
    B.isPushOnly = ce;
    function Ce(St) {
      return St.length - St.filter(ne).length;
    }
    B.countNonPushOnlyOPs = Ce;
    function Oe(St) {
      if (St.length === 0) return W.OPS.OP_0;
      if (St.length === 1) {
        if (St[0] >= 1 && St[0] <= 16) return oe + St[0];
        if (St[0] === 129) return W.OPS.OP_1NEGATE;
      }
    }
    function st(St) {
      return Buffer$2.isBuffer(St);
    }
    function at(St) {
      return re.Array(St);
    }
    function lt(St) {
      return Buffer$2.isBuffer(St);
    }
    function pt(St) {
      if (st(St)) return St;
      ie(re.Array, St);
      const It = St.reduce((it, ke) => lt(ke) ? ke.length === 1 && Oe(ke) !== void 0 ? it + 1 : it + K.encodingLength(ke.length) + ke.length : it + 1, 0), Tt = Buffer$2.allocUnsafe(It);
      let nt = 0;
      if (St.forEach((it) => {
        if (lt(it)) {
          const ke = Oe(it);
          if (ke !== void 0) {
            Tt.writeUInt8(ke, nt), nt += 1;
            return;
          }
          nt += K.encode(Tt, it.length, nt), it.copy(Tt, nt), nt += it.length;
        } else
          Tt.writeUInt8(it, nt), nt += 1;
      }), nt !== Tt.length) throw new Error("Could not decode chunks");
      return Tt;
    }
    B.compile = pt;
    function ht(St) {
      if (at(St)) return St;
      ie(re.Buffer, St);
      const It = [];
      let Tt = 0;
      for (; Tt < St.length; ) {
        const nt = St[Tt];
        if (nt > W.OPS.OP_0 && nt <= W.OPS.OP_PUSHDATA4) {
          const it = K.decode(St, Tt);
          if (it === null || (Tt += it.size, Tt + it.number > St.length)) return null;
          const ke = St.slice(Tt, Tt + it.number);
          Tt += it.number;
          const rt = Oe(ke);
          rt !== void 0 ? It.push(rt) : It.push(ke);
        } else
          It.push(nt), Tt += 1;
      }
      return It;
    }
    B.decompile = ht;
    function yt(St) {
      if (st(St) && (St = ht(St)), !St)
        throw new Error("Could not convert invalid chunks to ASM");
      return St.map((It) => {
        if (lt(It)) {
          const Tt = Oe(It);
          if (Tt === void 0) return It.toString("hex");
          It = Tt;
        }
        return W.REVERSE_OPS[It];
      }).join(" ");
    }
    B.toASM = yt;
    function vt(St) {
      return ie(re.String, St), pt(
        St.split(" ").map((It) => W.OPS[It] !== void 0 ? W.OPS[It] : (ie(re.Hex, It), Buffer$2.from(It, "hex")))
      );
    }
    B.fromASM = vt;
    function $t(St) {
      return St = ht(St), ie(ce, St), St.map((It) => lt(It) ? It : It === W.OPS.OP_0 ? Buffer$2.allocUnsafe(0) : J.encode(It - oe));
    }
    B.toStack = $t;
    function xt(St) {
      return re.isPoint(St);
    }
    B.isCanonicalPubKey = xt;
    function Ct(St) {
      const It = St & -129;
      return It > 0 && It < 4;
    }
    B.isDefinedHashType = Ct;
    function Et(St) {
      return !Buffer$2.isBuffer(St) || !Ct(St[St.length - 1]) ? !1 : L.check(St.slice(0, -1));
    }
    B.isCanonicalScriptSignature = Et, B.number = J, B.signature = V;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, L, W) {
  Object.defineProperty(B, L, {
    configurable: !0,
    enumerable: !0,
    get() {
      const K = W.call(this);
      return this[L] = K, K;
    },
    set(K) {
      Object.defineProperty(this, L, {
        configurable: !0,
        enumerable: !0,
        value: K,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let L;
  return () => (L !== void 0 || (L = B()), L);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks$2, bscript$9 = requireScript(), types_1$7 = types$7, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, L) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const K = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(K, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), L.validate && B.output) {
    const J = bscript$9.decompile(B.output);
    if (J[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!J.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, K.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(K, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks$2, bscript$8 = requireScript(), types_1$6 = types$7, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, L) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {});
  function W(oe) {
    return bscript$8.isCanonicalScriptSignature(oe) || (L.allowIncomplete && oe === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(W)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const J = { network: B.network || networks_1$6.bitcoin };
  let V = [], re = !1;
  function ie(oe) {
    re || (re = !0, V = bscript$8.decompile(oe), J.m = V[0] - OP_INT_BASE, J.n = V[V.length - 2] - OP_INT_BASE, J.pubkeys = V.slice(1, -2));
  }
  if (lazy$5.prop(J, "output", () => {
    if (B.m && J.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + J.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(J, "m", () => {
    if (J.output)
      return ie(J.output), J.m;
  }), lazy$5.prop(J, "n", () => {
    if (J.pubkeys)
      return J.pubkeys.length;
  }), lazy$5.prop(J, "pubkeys", () => {
    if (B.output)
      return ie(B.output), J.pubkeys;
  }), lazy$5.prop(J, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(J, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), lazy$5.prop(J, "name", () => {
    if (!(!J.m || !J.n))
      return `p2ms(${J.m} of ${J.n})`;
  }), L.validate) {
    if (B.output) {
      if (ie(B.output), !types_1$6.typeforce.Number(V[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(V[V.length - 2]))
        throw new TypeError("Output is invalid");
      if (V[V.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (J.m <= 0 || J.n > 16 || J.m > J.n || J.n !== V.length - 3)
        throw new TypeError("Output is invalid");
      if (!J.pubkeys.every((oe) => (0, types_1$6.isPoint)(oe)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== J.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== J.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, J.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (J.n = B.pubkeys.length, J.n < J.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < J.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > J.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (J.signatures.length === 0 || !J.signatures.every(W))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, J.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(J, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks$2, bscript$7 = requireScript(), types_1$5 = types$7, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, L) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const W = lazy$4.value(() => bscript$7.decompile(B.input)), J = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(J, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(J, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(J, "signature", () => {
    if (B.input)
      return W()[0];
  }), lazy$4.prop(J, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), L.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(J.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(J.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(J.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (W().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(J.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(J, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$4 = {}, ripemd160$1 = {}, _md = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.isBytes = isBytes;
_assert.number = number$1;
_assert.bool = bool;
_assert.bytes = bytes;
_assert.hash = hash$2;
_assert.exists = exists;
_assert.output = output;
function number$1(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error(`positive integer expected, not ${B}`);
}
function bool(B) {
  if (typeof B != "boolean")
    throw new Error(`boolean expected, not ${B}`);
}
function isBytes(B) {
  return B instanceof Uint8Array || B != null && typeof B == "object" && B.constructor.name === "Uint8Array";
}
function bytes(B, ...L) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (L.length > 0 && !L.includes(B.length))
    throw new Error(`Uint8Array expected of length ${L}, not of length=${B.length}`);
}
function hash$2(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(B.outputLen), number$1(B.blockLen);
}
function exists(B, L = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (L && B.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(B, L) {
  bytes(B);
  const W = L.outputLen;
  if (B.length < W)
    throw new Error(`digestInto() expects output buffer of length at least ${W}`);
}
const assert$3 = { number: number$1, bool, bytes, hash: hash$2, exists, output };
_assert.default = assert$3;
var utils$5 = {}, crypto$3 = {};
Object.defineProperty(crypto$3, "__esModule", { value: !0 });
crypto$3.crypto = void 0;
crypto$3.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.byteSwap = B.isLE = B.rotl = B.rotr = B.createView = B.u32 = B.u8 = void 0, B.isBytes = K, B.byteSwap32 = ne, B.bytesToHex = Ce, B.hexToBytes = at, B.asyncLoop = pt, B.utf8ToBytes = ht, B.toBytes = yt, B.concatBytes = vt, B.checkOpts = Ct, B.wrapConstructor = Et, B.wrapConstructorWithOpts = St, B.wrapXOFConstructorWithOpts = It, B.randomBytes = Tt;
  const L = crypto$3, W = _assert;
  function K(nt) {
    return nt instanceof Uint8Array || nt != null && typeof nt == "object" && nt.constructor.name === "Uint8Array";
  }
  const J = (nt) => new Uint8Array(nt.buffer, nt.byteOffset, nt.byteLength);
  B.u8 = J;
  const V = (nt) => new Uint32Array(nt.buffer, nt.byteOffset, Math.floor(nt.byteLength / 4));
  B.u32 = V;
  const re = (nt) => new DataView(nt.buffer, nt.byteOffset, nt.byteLength);
  B.createView = re;
  const ie = (nt, it) => nt << 32 - it | nt >>> it;
  B.rotr = ie;
  const oe = (nt, it) => nt << it | nt >>> 32 - it >>> 0;
  B.rotl = oe, B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const pe = (nt) => nt << 24 & 4278190080 | nt << 8 & 16711680 | nt >>> 8 & 65280 | nt >>> 24 & 255;
  B.byteSwap = pe, B.byteSwapIfBE = B.isLE ? (nt) => nt : (nt) => (0, B.byteSwap)(nt);
  function ne(nt) {
    for (let it = 0; it < nt.length; it++)
      nt[it] = (0, B.byteSwap)(nt[it]);
  }
  const ce = /* @__PURE__ */ Array.from({ length: 256 }, (nt, it) => it.toString(16).padStart(2, "0"));
  function Ce(nt) {
    (0, W.bytes)(nt);
    let it = "";
    for (let ke = 0; ke < nt.length; ke++)
      it += ce[nt[ke]];
    return it;
  }
  const Oe = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function st(nt) {
    if (nt >= Oe._0 && nt <= Oe._9)
      return nt - Oe._0;
    if (nt >= Oe._A && nt <= Oe._F)
      return nt - (Oe._A - 10);
    if (nt >= Oe._a && nt <= Oe._f)
      return nt - (Oe._a - 10);
  }
  function at(nt) {
    if (typeof nt != "string")
      throw new Error("hex string expected, got " + typeof nt);
    const it = nt.length, ke = it / 2;
    if (it % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + it);
    const rt = new Uint8Array(ke);
    for (let ot = 0, ft = 0; ot < ke; ot++, ft += 2) {
      const ct = st(nt.charCodeAt(ft)), bt = st(nt.charCodeAt(ft + 1));
      if (ct === void 0 || bt === void 0) {
        const ut = nt[ft] + nt[ft + 1];
        throw new Error('hex string expected, got non-hex character "' + ut + '" at index ' + ft);
      }
      rt[ot] = ct * 16 + bt;
    }
    return rt;
  }
  const lt = async () => {
  };
  B.nextTick = lt;
  async function pt(nt, it, ke) {
    let rt = Date.now();
    for (let ot = 0; ot < nt; ot++) {
      ke(ot);
      const ft = Date.now() - rt;
      ft >= 0 && ft < it || (await (0, B.nextTick)(), rt += ft);
    }
  }
  function ht(nt) {
    if (typeof nt != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof nt}`);
    return new Uint8Array(new TextEncoder().encode(nt));
  }
  function yt(nt) {
    return typeof nt == "string" && (nt = ht(nt)), (0, W.bytes)(nt), nt;
  }
  function vt(...nt) {
    let it = 0;
    for (let rt = 0; rt < nt.length; rt++) {
      const ot = nt[rt];
      (0, W.bytes)(ot), it += ot.length;
    }
    const ke = new Uint8Array(it);
    for (let rt = 0, ot = 0; rt < nt.length; rt++) {
      const ft = nt[rt];
      ke.set(ft, ot), ot += ft.length;
    }
    return ke;
  }
  class $t {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = $t;
  const xt = {}.toString;
  function Ct(nt, it) {
    if (it !== void 0 && xt.call(it) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(nt, it);
  }
  function Et(nt) {
    const it = (rt) => nt().update(yt(rt)).digest(), ke = nt();
    return it.outputLen = ke.outputLen, it.blockLen = ke.blockLen, it.create = () => nt(), it;
  }
  function St(nt) {
    const it = (rt, ot) => nt(ot).update(yt(rt)).digest(), ke = nt({});
    return it.outputLen = ke.outputLen, it.blockLen = ke.blockLen, it.create = (rt) => nt(rt), it;
  }
  function It(nt) {
    const it = (rt, ot) => nt(ot).update(yt(rt)).digest(), ke = nt({});
    return it.outputLen = ke.outputLen, it.blockLen = ke.blockLen, it.create = (rt) => nt(rt), it;
  }
  function Tt(nt = 32) {
    if (L.crypto && typeof L.crypto.getRandomValues == "function")
      return L.crypto.getRandomValues(new Uint8Array(nt));
    if (L.crypto && typeof L.crypto.randomBytes == "function")
      return L.crypto.randomBytes(nt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = _md.Maj = _md.Chi = void 0;
const _assert_js_1 = _assert, utils_js_1$4 = utils$5;
function setBigUint64(B, L, W, K) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(L, W, K);
  const J = BigInt(32), V = BigInt(4294967295), re = Number(W >> J & V), ie = Number(W & V), oe = K ? 4 : 0, pe = K ? 0 : 4;
  B.setUint32(L + oe, re, K), B.setUint32(L + pe, ie, K);
}
const Chi = (B, L, W) => B & L ^ ~B & W;
_md.Chi = Chi;
const Maj = (B, L, W) => B & L ^ B & W ^ L & W;
_md.Maj = Maj;
class HashMD extends utils_js_1$4.Hash {
  constructor(L, W, K, J) {
    super(), this.blockLen = L, this.outputLen = W, this.padOffset = K, this.isLE = J, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(L), this.view = (0, utils_js_1$4.createView)(this.buffer);
  }
  update(L) {
    (0, _assert_js_1.exists)(this);
    const { view: W, buffer: K, blockLen: J } = this;
    L = (0, utils_js_1$4.toBytes)(L);
    const V = L.length;
    for (let re = 0; re < V; ) {
      const ie = Math.min(J - this.pos, V - re);
      if (ie === J) {
        const oe = (0, utils_js_1$4.createView)(L);
        for (; J <= V - re; re += J)
          this.process(oe, re);
        continue;
      }
      K.set(L.subarray(re, re + ie), this.pos), this.pos += ie, re += ie, this.pos === J && (this.process(W, 0), this.pos = 0);
    }
    return this.length += L.length, this.roundClean(), this;
  }
  digestInto(L) {
    (0, _assert_js_1.exists)(this), (0, _assert_js_1.output)(L, this), this.finished = !0;
    const { buffer: W, view: K, blockLen: J, isLE: V } = this;
    let { pos: re } = this;
    W[re++] = 128, this.buffer.subarray(re).fill(0), this.padOffset > J - re && (this.process(K, 0), re = 0);
    for (let ce = re; ce < J; ce++)
      W[ce] = 0;
    setBigUint64(K, J - 8, BigInt(this.length * 8), V), this.process(K, 0);
    const ie = (0, utils_js_1$4.createView)(L), oe = this.outputLen;
    if (oe % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const pe = oe / 4, ne = this.get();
    if (pe > ne.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let ce = 0; ce < pe; ce++)
      ie.setUint32(4 * ce, ne[ce], V);
  }
  digest() {
    const { buffer: L, outputLen: W } = this;
    this.digestInto(L);
    const K = L.slice(0, W);
    return this.destroy(), K;
  }
  _cloneInto(L) {
    L || (L = new this.constructor()), L.set(...this.get());
    const { blockLen: W, buffer: K, length: J, finished: V, destroyed: re, pos: ie } = this;
    return L.length = J, L.pos = ie, L.finished = V, L.destroyed = re, J % W && L.buffer.set(K), L;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(ripemd160$1, "__esModule", { value: !0 });
ripemd160$1.ripemd160 = ripemd160$1.RIPEMD160 = void 0;
const _md_js_1$3 = _md, utils_js_1$3 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, L) => L)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let L of [idxL, idxR])
    L.push(L[B].map((W) => Rho[W]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, L) => B.map((W) => shifts[L][W])), shiftsR = /* @__PURE__ */ idxR.map((B, L) => B.map((W) => shifts[L][W])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f$1(B, L, W, K) {
  return B === 0 ? L ^ W ^ K : B === 1 ? L & W | ~L & K : B === 2 ? (L | ~W) ^ K : B === 3 ? L & K | W & ~K : L ^ (W | ~K);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$3.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: L, h1: W, h2: K, h3: J, h4: V } = this;
    return [L, W, K, J, V];
  }
  set(L, W, K, J, V) {
    this.h0 = L | 0, this.h1 = W | 0, this.h2 = K | 0, this.h3 = J | 0, this.h4 = V | 0;
  }
  process(L, W) {
    for (let Oe = 0; Oe < 16; Oe++, W += 4)
      R_BUF[Oe] = L.getUint32(W, !0);
    let K = this.h0 | 0, J = K, V = this.h1 | 0, re = V, ie = this.h2 | 0, oe = ie, pe = this.h3 | 0, ne = pe, ce = this.h4 | 0, Ce = ce;
    for (let Oe = 0; Oe < 5; Oe++) {
      const st = 4 - Oe, at = Kl[Oe], lt = Kr[Oe], pt = idxL[Oe], ht = idxR[Oe], yt = shiftsL[Oe], vt = shiftsR[Oe];
      for (let $t = 0; $t < 16; $t++) {
        const xt = (0, utils_js_1$3.rotl)(K + f$1(Oe, V, ie, pe) + R_BUF[pt[$t]] + at, yt[$t]) + ce | 0;
        K = ce, ce = pe, pe = (0, utils_js_1$3.rotl)(ie, 10) | 0, ie = V, V = xt;
      }
      for (let $t = 0; $t < 16; $t++) {
        const xt = (0, utils_js_1$3.rotl)(J + f$1(st, re, oe, ne) + R_BUF[ht[$t]] + lt, vt[$t]) + Ce | 0;
        J = Ce, Ce = ne, ne = (0, utils_js_1$3.rotl)(oe, 10) | 0, oe = re, re = xt;
      }
    }
    this.set(this.h1 + ie + ne | 0, this.h2 + pe + Ce | 0, this.h3 + ce + J | 0, this.h4 + K + re | 0, this.h0 + V + oe | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160$1.RIPEMD160 = RIPEMD160;
ripemd160$1.ripemd160 = (0, utils_js_1$3.wrapConstructor)(() => new RIPEMD160());
var sha1$1 = {};
Object.defineProperty(sha1$1, "__esModule", { value: !0 });
sha1$1.sha1 = sha1$1.SHA1 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: L, B: W, C: K, D: J, E: V } = this;
    return [L, W, K, J, V];
  }
  set(L, W, K, J, V) {
    this.A = L | 0, this.B = W | 0, this.C = K | 0, this.D = J | 0, this.E = V | 0;
  }
  process(L, W) {
    for (let oe = 0; oe < 16; oe++, W += 4)
      SHA1_W[oe] = L.getUint32(W, !1);
    for (let oe = 16; oe < 80; oe++)
      SHA1_W[oe] = (0, utils_js_1$2.rotl)(SHA1_W[oe - 3] ^ SHA1_W[oe - 8] ^ SHA1_W[oe - 14] ^ SHA1_W[oe - 16], 1);
    let { A: K, B: J, C: V, D: re, E: ie } = this;
    for (let oe = 0; oe < 80; oe++) {
      let pe, ne;
      oe < 20 ? (pe = (0, _md_js_1$2.Chi)(J, V, re), ne = 1518500249) : oe < 40 ? (pe = J ^ V ^ re, ne = 1859775393) : oe < 60 ? (pe = (0, _md_js_1$2.Maj)(J, V, re), ne = 2400959708) : (pe = J ^ V ^ re, ne = 3395469782);
      const ce = (0, utils_js_1$2.rotl)(K, 5) + pe + ie + ne + SHA1_W[oe] | 0;
      ie = re, re = V, V = (0, utils_js_1$2.rotl)(J, 30), J = K, K = ce;
    }
    K = K + this.A | 0, J = J + this.B | 0, V = V + this.C | 0, re = re + this.D | 0, ie = ie + this.E | 0, this.set(K, J, V, re, ie);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1$1.SHA1 = SHA1;
sha1$1.sha1 = (0, utils_js_1$2.wrapConstructor)(() => new SHA1());
var sha256$5 = {};
Object.defineProperty(sha256$5, "__esModule", { value: !0 });
sha256$5.sha224 = sha256$5.sha256 = sha256$5.SHA256 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: L, B: W, C: K, D: J, E: V, F: re, G: ie, H: oe } = this;
    return [L, W, K, J, V, re, ie, oe];
  }
  // prettier-ignore
  set(L, W, K, J, V, re, ie, oe) {
    this.A = L | 0, this.B = W | 0, this.C = K | 0, this.D = J | 0, this.E = V | 0, this.F = re | 0, this.G = ie | 0, this.H = oe | 0;
  }
  process(L, W) {
    for (let ce = 0; ce < 16; ce++, W += 4)
      SHA256_W[ce] = L.getUint32(W, !1);
    for (let ce = 16; ce < 64; ce++) {
      const Ce = SHA256_W[ce - 15], Oe = SHA256_W[ce - 2], st = (0, utils_js_1$1.rotr)(Ce, 7) ^ (0, utils_js_1$1.rotr)(Ce, 18) ^ Ce >>> 3, at = (0, utils_js_1$1.rotr)(Oe, 17) ^ (0, utils_js_1$1.rotr)(Oe, 19) ^ Oe >>> 10;
      SHA256_W[ce] = at + SHA256_W[ce - 7] + st + SHA256_W[ce - 16] | 0;
    }
    let { A: K, B: J, C: V, D: re, E: ie, F: oe, G: pe, H: ne } = this;
    for (let ce = 0; ce < 64; ce++) {
      const Ce = (0, utils_js_1$1.rotr)(ie, 6) ^ (0, utils_js_1$1.rotr)(ie, 11) ^ (0, utils_js_1$1.rotr)(ie, 25), Oe = ne + Ce + (0, _md_js_1$1.Chi)(ie, oe, pe) + SHA256_K[ce] + SHA256_W[ce] | 0, at = ((0, utils_js_1$1.rotr)(K, 2) ^ (0, utils_js_1$1.rotr)(K, 13) ^ (0, utils_js_1$1.rotr)(K, 22)) + (0, _md_js_1$1.Maj)(K, J, V) | 0;
      ne = pe, pe = oe, oe = ie, ie = re + Oe | 0, re = V, V = J, J = K, K = Oe + at | 0;
    }
    K = K + this.A | 0, J = J + this.B | 0, V = V + this.C | 0, re = re + this.D | 0, ie = ie + this.E | 0, oe = oe + this.F | 0, pe = pe + this.G | 0, ne = ne + this.H | 0, this.set(K, J, V, re, ie, oe, pe, ne);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$5.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$5.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256());
sha256$5.sha224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA224());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const L = ripemd160$1, W = sha1$1, K = sha256$5;
  function J(ne) {
    return Buffer$2.from((0, L.ripemd160)(Uint8Array.from(ne)));
  }
  B.ripemd160 = J;
  function V(ne) {
    return Buffer$2.from((0, W.sha1)(Uint8Array.from(ne)));
  }
  B.sha1 = V;
  function re(ne) {
    return Buffer$2.from((0, K.sha256)(Uint8Array.from(ne)));
  }
  B.sha256 = re;
  function ie(ne) {
    return Buffer$2.from(
      (0, L.ripemd160)((0, K.sha256)(Uint8Array.from(ne)))
    );
  }
  B.hash160 = ie;
  function oe(ne) {
    return Buffer$2.from(
      (0, K.sha256)((0, K.sha256)(Uint8Array.from(ne)))
    );
  }
  B.hash256 = oe, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$2.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$2.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$2.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$2.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$2.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$2.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$2.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$2.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$2.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function pe(ne, ce) {
    return re(Buffer$2.concat([B.TAGGED_HASH_PREFIXES[ne], ce]));
  }
  B.taggedHash = pe;
})(crypto$4);
function base$5(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var L = new Uint8Array(256), W = 0; W < L.length; W++)
    L[W] = 255;
  for (var K = 0; K < B.length; K++) {
    var J = B.charAt(K), V = J.charCodeAt(0);
    if (L[V] !== 255)
      throw new TypeError(J + " is ambiguous");
    L[V] = K;
  }
  var re = B.length, ie = B.charAt(0), oe = Math.log(re) / Math.log(256), pe = Math.log(256) / Math.log(re);
  function ne(Oe) {
    if (Oe instanceof Uint8Array || (ArrayBuffer.isView(Oe) ? Oe = new Uint8Array(Oe.buffer, Oe.byteOffset, Oe.byteLength) : Array.isArray(Oe) && (Oe = Uint8Array.from(Oe))), !(Oe instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Oe.length === 0)
      return "";
    for (var st = 0, at = 0, lt = 0, pt = Oe.length; lt !== pt && Oe[lt] === 0; )
      lt++, st++;
    for (var ht = (pt - lt) * pe + 1 >>> 0, yt = new Uint8Array(ht); lt !== pt; ) {
      for (var vt = Oe[lt], $t = 0, xt = ht - 1; (vt !== 0 || $t < at) && xt !== -1; xt--, $t++)
        vt += 256 * yt[xt] >>> 0, yt[xt] = vt % re >>> 0, vt = vt / re >>> 0;
      if (vt !== 0)
        throw new Error("Non-zero carry");
      at = $t, lt++;
    }
    for (var Ct = ht - at; Ct !== ht && yt[Ct] === 0; )
      Ct++;
    for (var Et = ie.repeat(st); Ct < ht; ++Ct)
      Et += B.charAt(yt[Ct]);
    return Et;
  }
  function ce(Oe) {
    if (typeof Oe != "string")
      throw new TypeError("Expected String");
    if (Oe.length === 0)
      return new Uint8Array();
    for (var st = 0, at = 0, lt = 0; Oe[st] === ie; )
      at++, st++;
    for (var pt = (Oe.length - st) * oe + 1 >>> 0, ht = new Uint8Array(pt); Oe[st]; ) {
      var yt = L[Oe.charCodeAt(st)];
      if (yt === 255)
        return;
      for (var vt = 0, $t = pt - 1; (yt !== 0 || vt < lt) && $t !== -1; $t--, vt++)
        yt += re * ht[$t] >>> 0, ht[$t] = yt % 256 >>> 0, yt = yt / 256 >>> 0;
      if (yt !== 0)
        throw new Error("Non-zero carry");
      lt = vt, st++;
    }
    for (var xt = pt - lt; xt !== pt && ht[xt] === 0; )
      xt++;
    for (var Ct = new Uint8Array(at + (pt - xt)), Et = at; xt !== pt; )
      Ct[Et++] = ht[xt++];
    return Ct;
  }
  function Ce(Oe) {
    var st = ce(Oe);
    if (st)
      return st;
    throw new Error("Non-base" + re + " character");
  }
  return {
    encode: ne,
    decodeUnsafe: ce,
    decode: Ce
  };
}
var src$3 = base$5;
const basex$1 = src$3, ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$1 = basex$1(ALPHABET$2), base58$1 = bs58$1, base$4 = function(B) {
  function L(V) {
    var re = Uint8Array.from(V), ie = B(re), oe = re.length + 4, pe = new Uint8Array(oe);
    return pe.set(re, 0), pe.set(ie.subarray(0, 4), re.length), base58$1.encode(pe, oe);
  }
  function W(V) {
    var re = V.slice(0, -4), ie = V.slice(-4), oe = B(re);
    if (!(ie[0] ^ oe[0] | ie[1] ^ oe[1] | ie[2] ^ oe[2] | ie[3] ^ oe[3]))
      return re;
  }
  function K(V) {
    var re = base58$1.decodeUnsafe(V);
    if (re)
      return W(re);
  }
  function J(V) {
    var re = base58$1.decode(V), ie = W(re);
    if (!ie) throw new Error("Invalid checksum");
    return ie;
  }
  return {
    encode: L,
    decode: J,
    decodeUnsafe: K
  };
}, { sha256: sha256$4 } = sha256$5, bs58checkBase$1 = base$4;
function sha256x2$1(B) {
  return sha256$4(sha256$4(B));
}
var bs58check$5 = bs58checkBase$1(sha256x2$1);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$4, networks_1$4 = networks$2, bscript$6 = requireScript(), types_1$4 = types$7, lazy$3 = lazy$7, bs58check$4 = bs58check$5, OPS$3 = bscript$6.OPS;
function p2pkh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const W = lazy$3.value(() => {
    const re = Buffer$2.from(bs58check$4.decode(B.address)), ie = re.readUInt8(0), oe = re.slice(1);
    return { version: ie, hash: oe };
  }), K = lazy$3.value(() => bscript$6.decompile(B.input)), J = B.network || networks_1$4.bitcoin, V = { name: "p2pkh", network: J };
  if (lazy$3.prop(V, "address", () => {
    if (!V.hash) return;
    const re = Buffer$2.allocUnsafe(21);
    return re.writeUInt8(J.pubKeyHash, 0), V.hash.copy(re, 1), bs58check$4.encode(re);
  }), lazy$3.prop(V, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return W().hash;
    if (B.pubkey || V.pubkey) return bcrypto$5.hash160(B.pubkey || V.pubkey);
  }), lazy$3.prop(V, "output", () => {
    if (V.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        V.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(V, "pubkey", () => {
    if (B.input)
      return K()[1];
  }), lazy$3.prop(V, "signature", () => {
    if (B.input)
      return K()[0];
  }), lazy$3.prop(V, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(V, "witness", () => {
    if (V.input)
      return [];
  }), L.validate) {
    let re = Buffer$2.from([]);
    if (B.address) {
      if (W().version !== J.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (W().hash.length !== 20) throw new TypeError("Invalid address");
      re = W().hash;
    }
    if (B.hash) {
      if (re.length > 0 && !re.equals(B.hash))
        throw new TypeError("Hash mismatch");
      re = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ie = B.output.slice(3, 23);
      if (re.length > 0 && !re.equals(ie))
        throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (B.pubkey) {
      const ie = bcrypto$5.hash160(B.pubkey);
      if (re.length > 0 && !re.equals(ie))
        throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (B.input) {
      const ie = K();
      if (ie.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ie[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ie[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(ie[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(ie[1]))
        throw new TypeError("Pubkey mismatch");
      const oe = bcrypto$5.hash160(ie[1]);
      if (re.length > 0 && !re.equals(oe))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(V, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$4, networks_1$3 = networks$2, bscript$5 = requireScript(), types_1$3 = types$7, lazy$2 = lazy$7, bs58check$3 = bs58check$5, OPS$2 = bscript$5.OPS;
function p2sh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let W = B.network;
  W || (W = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const K = { network: W }, J = lazy$2.value(() => {
    const ie = Buffer$2.from(bs58check$3.decode(B.address)), oe = ie.readUInt8(0), pe = ie.slice(1);
    return { version: oe, hash: pe };
  }), V = lazy$2.value(() => bscript$5.decompile(B.input)), re = lazy$2.value(() => {
    const ie = V(), oe = ie[ie.length - 1];
    return {
      network: W,
      output: oe === OPS$2.OP_FALSE ? Buffer$2.from([]) : oe,
      input: bscript$5.compile(ie.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(K, "address", () => {
    if (!K.hash) return;
    const ie = Buffer$2.allocUnsafe(21);
    return ie.writeUInt8(K.network.scriptHash, 0), K.hash.copy(ie, 1), bs58check$3.encode(ie);
  }), lazy$2.prop(K, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return J().hash;
    if (K.redeem && K.redeem.output) return bcrypto$4.hash160(K.redeem.output);
  }), lazy$2.prop(K, "output", () => {
    if (K.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, K.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(K, "redeem", () => {
    if (B.input)
      return re();
  }), lazy$2.prop(K, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(K, "witness", () => {
    if (K.redeem && K.redeem.witness) return K.redeem.witness;
    if (K.input) return [];
  }), lazy$2.prop(K, "name", () => {
    const ie = ["p2sh"];
    return K.redeem !== void 0 && K.redeem.name !== void 0 && ie.push(K.redeem.name), ie.join("-");
  }), L.validate) {
    let ie = Buffer$2.from([]);
    if (B.address) {
      if (J().version !== W.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (J().hash.length !== 20) throw new TypeError("Invalid address");
      ie = J().hash;
    }
    if (B.hash) {
      if (ie.length > 0 && !ie.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ie = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const pe = B.output.slice(2, 22);
      if (ie.length > 0 && !ie.equals(pe))
        throw new TypeError("Hash mismatch");
      ie = pe;
    }
    const oe = (pe) => {
      if (pe.output) {
        const ne = bscript$5.decompile(pe.output);
        if (!ne || ne.length < 1)
          throw new TypeError("Redeem.output too short");
        if (pe.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(ne) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ce = bcrypto$4.hash160(pe.output);
        if (ie.length > 0 && !ie.equals(ce))
          throw new TypeError("Hash mismatch");
        ie = ce;
      }
      if (pe.input) {
        const ne = pe.input.length > 0, ce = pe.witness && pe.witness.length > 0;
        if (!ne && !ce) throw new TypeError("Empty input");
        if (ne && ce)
          throw new TypeError("Input and witness provided");
        if (ne) {
          const Ce = bscript$5.decompile(pe.input);
          if (!bscript$5.isPushOnly(Ce))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const pe = V();
      if (!pe || pe.length < 1) throw new TypeError("Input too short");
      if (!Buffer$2.isBuffer(re().output))
        throw new TypeError("Input is invalid");
      oe(re());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== W)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const pe = re();
        if (B.redeem.output && !B.redeem.output.equals(pe.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(pe.input))
          throw new TypeError("Redeem.input mismatch");
      }
      oe(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(K, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: !0 });
dist$1.bech32m = dist$1.bech32 = void 0;
const ALPHABET$1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET$1.length; B++) {
  const L = ALPHABET$1.charAt(B);
  ALPHABET_MAP[L] = B;
}
function polymodStep(B) {
  const L = B >> 25;
  return (B & 33554431) << 5 ^ -(L >> 0 & 1) & 996825010 ^ -(L >> 1 & 1) & 642813549 ^ -(L >> 2 & 1) & 513874426 ^ -(L >> 3 & 1) & 1027748829 ^ -(L >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let L = 1;
  for (let W = 0; W < B.length; ++W) {
    const K = B.charCodeAt(W);
    if (K < 33 || K > 126)
      return "Invalid prefix (" + B + ")";
    L = polymodStep(L) ^ K >> 5;
  }
  L = polymodStep(L);
  for (let W = 0; W < B.length; ++W) {
    const K = B.charCodeAt(W);
    L = polymodStep(L) ^ K & 31;
  }
  return L;
}
function convert$2(B, L, W, K) {
  let J = 0, V = 0;
  const re = (1 << W) - 1, ie = [];
  for (let oe = 0; oe < B.length; ++oe)
    for (J = J << L | B[oe], V += L; V >= W; )
      V -= W, ie.push(J >> V & re);
  if (K)
    V > 0 && ie.push(J << W - V & re);
  else {
    if (V >= L)
      return "Excess padding";
    if (J << W - V & re)
      return "Non-zero padding";
  }
  return ie;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const L = convert$2(B, 5, 8, !1);
  if (Array.isArray(L))
    return L;
}
function fromWords(B) {
  const L = convert$2(B, 5, 8, !1);
  if (Array.isArray(L))
    return L;
  throw new Error(L);
}
function getLibraryFromEncoding(B) {
  let L;
  B === "bech32" ? L = 1 : L = 734539939;
  function W(re, ie, oe) {
    if (oe = oe || 90, re.length + 7 + ie.length > oe)
      throw new TypeError("Exceeds length limit");
    re = re.toLowerCase();
    let pe = prefixChk(re);
    if (typeof pe == "string")
      throw new Error(pe);
    let ne = re + "1";
    for (let ce = 0; ce < ie.length; ++ce) {
      const Ce = ie[ce];
      if (Ce >> 5)
        throw new Error("Non 5-bit word");
      pe = polymodStep(pe) ^ Ce, ne += ALPHABET$1.charAt(Ce);
    }
    for (let ce = 0; ce < 6; ++ce)
      pe = polymodStep(pe);
    pe ^= L;
    for (let ce = 0; ce < 6; ++ce) {
      const Ce = pe >> (5 - ce) * 5 & 31;
      ne += ALPHABET$1.charAt(Ce);
    }
    return ne;
  }
  function K(re, ie) {
    if (ie = ie || 90, re.length < 8)
      return re + " too short";
    if (re.length > ie)
      return "Exceeds length limit";
    const oe = re.toLowerCase(), pe = re.toUpperCase();
    if (re !== oe && re !== pe)
      return "Mixed-case string " + re;
    re = oe;
    const ne = re.lastIndexOf("1");
    if (ne === -1)
      return "No separator character for " + re;
    if (ne === 0)
      return "Missing prefix for " + re;
    const ce = re.slice(0, ne), Ce = re.slice(ne + 1);
    if (Ce.length < 6)
      return "Data too short";
    let Oe = prefixChk(ce);
    if (typeof Oe == "string")
      return Oe;
    const st = [];
    for (let at = 0; at < Ce.length; ++at) {
      const lt = Ce.charAt(at), pt = ALPHABET_MAP[lt];
      if (pt === void 0)
        return "Unknown character " + lt;
      Oe = polymodStep(Oe) ^ pt, !(at + 6 >= Ce.length) && st.push(pt);
    }
    return Oe !== L ? "Invalid checksum for " + re : { prefix: ce, words: st };
  }
  function J(re, ie) {
    const oe = K(re, ie);
    if (typeof oe == "object")
      return oe;
  }
  function V(re, ie) {
    const oe = K(re, ie);
    if (typeof oe == "object")
      return oe;
    throw new Error(oe);
  }
  return {
    decodeUnsafe: J,
    decode: V,
    encode: W,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist$1.bech32 = getLibraryFromEncoding("bech32");
dist$1.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$4, networks_1$2 = networks$2, bscript$4 = requireScript(), types_1$2 = types$7, lazy$1 = lazy$7, bech32_1$1 = dist$1, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$2.alloc(0);
function p2wpkh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const W = lazy$1.value(() => {
    const V = bech32_1$1.bech32.decode(B.address), re = V.words.shift(), ie = bech32_1$1.bech32.fromWords(V.words);
    return {
      version: re,
      prefix: V.prefix,
      data: Buffer$2.from(ie)
    };
  }), K = B.network || networks_1$2.bitcoin, J = { name: "p2wpkh", network: K };
  if (lazy$1.prop(J, "address", () => {
    if (!J.hash) return;
    const V = bech32_1$1.bech32.toWords(J.hash);
    return V.unshift(0), bech32_1$1.bech32.encode(K.bech32, V);
  }), lazy$1.prop(J, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return W().data;
    if (B.pubkey || J.pubkey) return bcrypto$3.hash160(B.pubkey || J.pubkey);
  }), lazy$1.prop(J, "output", () => {
    if (J.hash)
      return bscript$4.compile([OPS$1.OP_0, J.hash]);
  }), lazy$1.prop(J, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(J, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(J, "input", () => {
    if (J.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(J, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), L.validate) {
    let V = Buffer$2.from([]);
    if (B.address) {
      if (K && K.bech32 !== W().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (W().version !== 0)
        throw new TypeError("Invalid address version");
      if (W().data.length !== 20)
        throw new TypeError("Invalid address data");
      V = W().data;
    }
    if (B.hash) {
      if (V.length > 0 && !V.equals(B.hash))
        throw new TypeError("Hash mismatch");
      V = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (V.length > 0 && !V.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      V = B.output.slice(2);
    }
    if (B.pubkey) {
      const re = bcrypto$3.hash160(B.pubkey);
      if (V.length > 0 && !V.equals(re))
        throw new TypeError("Hash mismatch");
      if (V = re, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const re = bcrypto$3.hash160(B.witness[1]);
      if (V.length > 0 && !V.equals(re))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(J, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$4, networks_1$1 = networks$2, bscript$3 = requireScript(), types_1$1 = types$7, lazy = lazy$7, bech32_1 = dist$1, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$2.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$2.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const W = lazy.value(() => {
    const re = bech32_1.bech32.decode(B.address), ie = re.words.shift(), oe = bech32_1.bech32.fromWords(re.words);
    return {
      version: ie,
      prefix: re.prefix,
      data: Buffer$2.from(oe)
    };
  }), K = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let J = B.network;
  J || (J = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const V = { network: J };
  if (lazy.prop(V, "address", () => {
    if (!V.hash) return;
    const re = bech32_1.bech32.toWords(V.hash);
    return re.unshift(0), bech32_1.bech32.encode(J.bech32, re);
  }), lazy.prop(V, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return W().data;
    if (V.redeem && V.redeem.output) return bcrypto$2.sha256(V.redeem.output);
  }), lazy.prop(V, "output", () => {
    if (V.hash)
      return bscript$3.compile([OPS.OP_0, V.hash]);
  }), lazy.prop(V, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(V, "input", () => {
    if (V.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(V, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const re = bscript$3.toStack(K());
      return V.redeem = Object.assign({ witness: re }, B.redeem), V.redeem.input = EMPTY_BUFFER$1, [].concat(re, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(V, "name", () => {
    const re = ["p2wsh"];
    return V.redeem !== void 0 && V.redeem.name !== void 0 && re.push(V.redeem.name), re.join("-");
  }), L.validate) {
    let re = Buffer$2.from([]);
    if (B.address) {
      if (W().prefix !== J.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (W().version !== 0)
        throw new TypeError("Invalid address version");
      if (W().data.length !== 32)
        throw new TypeError("Invalid address data");
      re = W().data;
    }
    if (B.hash) {
      if (re.length > 0 && !re.equals(B.hash))
        throw new TypeError("Hash mismatch");
      re = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ie = B.output.slice(2);
      if (re.length > 0 && !re.equals(ie))
        throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== J)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const ie = bscript$3.decompile(B.redeem.output);
        if (!ie || ie.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ie) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const oe = bcrypto$2.sha256(B.redeem.output);
        if (re.length > 0 && !re.equals(oe))
          throw new TypeError("Hash mismatch");
        re = oe;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(K()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && K().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const ie = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(ie))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ie) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(V, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h$3 = (B) => Buffer$2.from(B, "hex");
function verifyEcc(B) {
  assert$2(typeof B.isXOnlyPoint == "function"), assert$2(
    B.isXOnlyPoint(
      h$3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert$2(
    B.isXOnlyPoint(
      h$3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert$2(
    B.isXOnlyPoint(
      h$3("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert$2(
    B.isXOnlyPoint(
      h$3("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert$2(
    !B.isXOnlyPoint(
      h$3("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert$2(
    !B.isXOnlyPoint(
      h$3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert$2(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((L) => {
    const W = B.xOnlyPointAddTweak(h$3(L.pubkey), h$3(L.tweak));
    L.result === null ? assert$2(W === null) : (assert$2(W !== null), assert$2(W.parity === L.parity), assert$2(Buffer$2.from(W.xOnlyPubkey).equals(h$3(L.result))));
  });
}
function assert$2(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, L) {
  var W = require$$1$2, K = W.Buffer;
  function J(re, ie) {
    for (var oe in re)
      ie[oe] = re[oe];
  }
  K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? B.exports = W : (J(W, L), L.Buffer = V);
  function V(re, ie, oe) {
    return K(re, ie, oe);
  }
  V.prototype = Object.create(K.prototype), J(K, V), V.from = function(re, ie, oe) {
    if (typeof re == "number")
      throw new TypeError("Argument must not be a number");
    return K(re, ie, oe);
  }, V.alloc = function(re, ie, oe) {
    if (typeof re != "number")
      throw new TypeError("Argument must be a number");
    var pe = K(re);
    return ie !== void 0 ? typeof oe == "string" ? pe.fill(ie, oe) : pe.fill(ie) : pe.fill(0), pe;
  }, V.allocUnsafe = function(re) {
    if (typeof re != "number")
      throw new TypeError("Argument must be a number");
    return K(re);
  }, V.allocUnsafeSlow = function(re) {
    if (typeof re != "number")
      throw new TypeError("Argument must be a number");
    return W.SlowBuffer(re);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, Buffer$1 = safeBufferExports.Buffer, MAX_SAFE_INTEGER$2 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$2 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$h(B, L, W) {
  if (checkUInt53$1(B), L || (L = Buffer$1.allocUnsafe(encodingLength$1(B))), !Buffer$1.isBuffer(L)) throw new TypeError("buffer must be a Buffer instance");
  return W || (W = 0), B < 253 ? (L.writeUInt8(B, W), encode$h.bytes = 1) : B <= 65535 ? (L.writeUInt8(253, W), L.writeUInt16LE(B, W + 1), encode$h.bytes = 3) : B <= 4294967295 ? (L.writeUInt8(254, W), L.writeUInt32LE(B, W + 1), encode$h.bytes = 5) : (L.writeUInt8(255, W), L.writeUInt32LE(B >>> 0, W + 1), L.writeUInt32LE(B / 4294967296 | 0, W + 5), encode$h.bytes = 9), L;
}
function decode$h(B, L) {
  if (!Buffer$1.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  L || (L = 0);
  var W = B.readUInt8(L);
  if (W < 253)
    return decode$h.bytes = 1, W;
  if (W === 253)
    return decode$h.bytes = 3, B.readUInt16LE(L + 1);
  if (W === 254)
    return decode$h.bytes = 5, B.readUInt32LE(L + 1);
  decode$h.bytes = 9;
  var K = B.readUInt32LE(L + 1), J = B.readUInt32LE(L + 5), V = J * 4294967296 + K;
  return checkUInt53$1(V), V;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$h, decode: decode$h, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$5 = types$7, { typeforce: typeforce$3 } = types$5, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, L) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > L) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, L) {
  const W = B.readUInt32LE(L);
  let K = B.readUInt32LE(L + 4);
  return K *= 4294967296, verifuint$1(K + W, 9007199254740991), K + W;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, L, W) {
  return verifuint$1(L, 9007199254740991), B.writeInt32LE(L & -1, W), B.writeUInt32LE(Math.floor(L / 4294967296), W + 4), W + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$2(B) {
  if (B.length < 1) return B;
  let L = B.length - 1, W = 0;
  for (let K = 0; K < B.length / 2; K++)
    W = B[K], B[K] = B[L], B[L] = W, L--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$2;
function cloneBuffer(B) {
  const L = Buffer$2.allocUnsafe(B.length);
  return B.copy(L), L;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(L) {
    return new BufferWriter(Buffer$2.alloc(L));
  }
  constructor(L, W = 0) {
    this.buffer = L, this.offset = W, typeforce$3(types$5.tuple(types$5.Buffer, types$5.UInt32), [L, W]);
  }
  writeUInt8(L) {
    this.offset = this.buffer.writeUInt8(L, this.offset);
  }
  writeInt32(L) {
    this.offset = this.buffer.writeInt32LE(L, this.offset);
  }
  writeUInt32(L) {
    this.offset = this.buffer.writeUInt32LE(L, this.offset);
  }
  writeUInt64(L) {
    this.offset = writeUInt64LE$1(this.buffer, L, this.offset);
  }
  writeVarInt(L) {
    varuint$7.encode(L, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(L) {
    if (this.buffer.length < this.offset + L.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += L.copy(this.buffer, this.offset);
  }
  writeVarSlice(L) {
    this.writeVarInt(L.length), this.writeSlice(L);
  }
  writeVector(L) {
    this.writeVarInt(L.length), L.forEach((W) => this.writeVarSlice(W));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(L, W = 0) {
    this.buffer = L, this.offset = W, typeforce$3(types$5.tuple(types$5.Buffer, types$5.UInt32), [L, W]);
  }
  readUInt8() {
    const L = this.buffer.readUInt8(this.offset);
    return this.offset++, L;
  }
  readInt32() {
    const L = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, L;
  }
  readUInt32() {
    const L = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, L;
  }
  readUInt64() {
    const L = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, L;
  }
  readVarInt() {
    const L = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, L;
  }
  readSlice(L) {
    if (this.buffer.length < this.offset + L)
      throw new Error("Cannot read slice out of bounds");
    const W = this.buffer.slice(this.offset, this.offset + L);
    return this.offset += L, W;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const L = this.readVarInt(), W = [];
    for (let K = 0; K < L; K++) W.push(this.readVarSlice());
    return W;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const L = require$$1$2, W = ecc_lib, K = crypto$4, J = bufferutils, V = types$7;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const re = (at) => "left" in at && "right" in at;
  function ie(at, lt) {
    if (at.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${at.length}, expected min 33.`
      );
    const pt = (at.length - 33) / 32;
    let ht = lt;
    for (let yt = 0; yt < pt; yt++) {
      const vt = at.slice(33 + 32 * yt, 65 + 32 * yt);
      ht.compare(vt) < 0 ? ht = Oe(ht, vt) : ht = Oe(vt, ht);
    }
    return ht;
  }
  B.rootHashFromPath = ie;
  function oe(at) {
    if ((0, V.isTapleaf)(at))
      return { hash: ne(at) };
    const lt = [oe(at[0]), oe(at[1])];
    lt.sort((yt, vt) => yt.hash.compare(vt.hash));
    const [pt, ht] = lt;
    return {
      hash: Oe(pt.hash, ht.hash),
      left: pt,
      right: ht
    };
  }
  B.toHashTree = oe;
  function pe(at, lt) {
    if (re(at)) {
      const pt = pe(at.left, lt);
      if (pt !== void 0) return [...pt, at.right.hash];
      const ht = pe(at.right, lt);
      if (ht !== void 0) return [...ht, at.left.hash];
    } else if (at.hash.equals(lt))
      return [];
  }
  B.findScriptPath = pe;
  function ne(at) {
    const lt = at.version || B.LEAF_VERSION_TAPSCRIPT;
    return K.taggedHash(
      "TapLeaf",
      L.Buffer.concat([
        L.Buffer.from([lt]),
        st(at.output)
      ])
    );
  }
  B.tapleafHash = ne;
  function ce(at, lt) {
    return K.taggedHash(
      "TapTweak",
      L.Buffer.concat(lt ? [at, lt] : [at])
    );
  }
  B.tapTweakHash = ce;
  function Ce(at, lt) {
    if (!L.Buffer.isBuffer(at) || at.length !== 32 || lt && lt.length !== 32) return null;
    const pt = ce(at, lt), ht = (0, W.getEccLib)().xOnlyPointAddTweak(at, pt);
    return !ht || ht.xOnlyPubkey === null ? null : {
      parity: ht.parity,
      x: L.Buffer.from(ht.xOnlyPubkey)
    };
  }
  B.tweakKey = Ce;
  function Oe(at, lt) {
    return K.taggedHash("TapBranch", L.Buffer.concat([at, lt]));
  }
  function st(at) {
    const lt = J.varuint.encodingLength(at.length), pt = L.Buffer.allocUnsafe(lt);
    return J.varuint.encode(at.length, pt), L.Buffer.concat([pt, at]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = require$$1$2, L = networks$2, W = requireScript(), K = types$7, J = ecc_lib, V = bip341, re = lazy$7, ie = dist$1, oe = requireAddress(), pe = W.OPS, ne = 1, ce = 80;
  function Ce(Oe, st) {
    if (!Oe.address && !Oe.output && !Oe.pubkey && !Oe.internalPubkey && !(Oe.witness && Oe.witness.length > 1))
      throw new TypeError("Not enough data");
    st = Object.assign({ validate: !0 }, st || {}), (0, K.typeforce)(
      {
        address: K.typeforce.maybe(K.typeforce.String),
        input: K.typeforce.maybe(K.typeforce.BufferN(0)),
        network: K.typeforce.maybe(K.typeforce.Object),
        output: K.typeforce.maybe(K.typeforce.BufferN(34)),
        internalPubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        hash: K.typeforce.maybe(K.typeforce.BufferN(32)),
        pubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        signature: K.typeforce.maybe(
          K.typeforce.anyOf(
            K.typeforce.BufferN(64),
            K.typeforce.BufferN(65)
          )
        ),
        witness: K.typeforce.maybe(
          K.typeforce.arrayOf(K.typeforce.Buffer)
        ),
        scriptTree: K.typeforce.maybe(K.isTaptree),
        redeem: K.typeforce.maybe({
          output: K.typeforce.maybe(K.typeforce.Buffer),
          redeemVersion: K.typeforce.maybe(K.typeforce.Number),
          witness: K.typeforce.maybe(
            K.typeforce.arrayOf(K.typeforce.Buffer)
          )
        }),
        redeemVersion: K.typeforce.maybe(K.typeforce.Number)
      },
      Oe
    );
    const at = re.value(() => (0, oe.fromBech32)(Oe.address)), lt = re.value(() => {
      if (!(!Oe.witness || !Oe.witness.length))
        return Oe.witness.length >= 2 && Oe.witness[Oe.witness.length - 1][0] === ce ? Oe.witness.slice(0, -1) : Oe.witness.slice();
    }), pt = re.value(() => {
      if (Oe.scriptTree) return (0, V.toHashTree)(Oe.scriptTree);
      if (Oe.hash) return { hash: Oe.hash };
    }), ht = Oe.network || L.bitcoin, yt = { name: "p2tr", network: ht };
    if (re.prop(yt, "address", () => {
      if (!yt.pubkey) return;
      const vt = ie.bech32m.toWords(yt.pubkey);
      return vt.unshift(ne), ie.bech32m.encode(ht.bech32, vt);
    }), re.prop(yt, "hash", () => {
      const vt = pt();
      if (vt) return vt.hash;
      const $t = lt();
      if ($t && $t.length > 1) {
        const xt = $t[$t.length - 1], Ct = xt[0] & K.TAPLEAF_VERSION_MASK, Et = $t[$t.length - 2], St = (0, V.tapleafHash)({
          output: Et,
          version: Ct
        });
        return (0, V.rootHashFromPath)(xt, St);
      }
      return null;
    }), re.prop(yt, "output", () => {
      if (yt.pubkey)
        return W.compile([pe.OP_1, yt.pubkey]);
    }), re.prop(yt, "redeemVersion", () => Oe.redeemVersion ? Oe.redeemVersion : Oe.redeem && Oe.redeem.redeemVersion !== void 0 && Oe.redeem.redeemVersion !== null ? Oe.redeem.redeemVersion : V.LEAF_VERSION_TAPSCRIPT), re.prop(yt, "redeem", () => {
      const vt = lt();
      if (!(!vt || vt.length < 2))
        return {
          output: vt[vt.length - 2],
          witness: vt.slice(0, -2),
          redeemVersion: vt[vt.length - 1][0] & K.TAPLEAF_VERSION_MASK
        };
    }), re.prop(yt, "pubkey", () => {
      if (Oe.pubkey) return Oe.pubkey;
      if (Oe.output) return Oe.output.slice(2);
      if (Oe.address) return at().data;
      if (yt.internalPubkey) {
        const vt = (0, V.tweakKey)(yt.internalPubkey, yt.hash);
        if (vt) return vt.x;
      }
    }), re.prop(yt, "internalPubkey", () => {
      if (Oe.internalPubkey) return Oe.internalPubkey;
      const vt = lt();
      if (vt && vt.length > 1)
        return vt[vt.length - 1].slice(1, 33);
    }), re.prop(yt, "signature", () => {
      if (Oe.signature) return Oe.signature;
      const vt = lt();
      if (!(!vt || vt.length !== 1))
        return vt[0];
    }), re.prop(yt, "witness", () => {
      if (Oe.witness) return Oe.witness;
      const vt = pt();
      if (vt && Oe.redeem && Oe.redeem.output && Oe.internalPubkey) {
        const $t = (0, V.tapleafHash)({
          output: Oe.redeem.output,
          version: yt.redeemVersion
        }), xt = (0, V.findScriptPath)(vt, $t);
        if (!xt) return;
        const Ct = (0, V.tweakKey)(Oe.internalPubkey, vt.hash);
        if (!Ct) return;
        const Et = B.Buffer.concat(
          [
            B.Buffer.from([yt.redeemVersion | Ct.parity]),
            Oe.internalPubkey
          ].concat(xt)
        );
        return [Oe.redeem.output, Et];
      }
      if (Oe.signature) return [Oe.signature];
    }), st.validate) {
      let vt = B.Buffer.from([]);
      if (Oe.address) {
        if (ht && ht.bech32 !== at().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (at().version !== ne)
          throw new TypeError("Invalid address version");
        if (at().data.length !== 32)
          throw new TypeError("Invalid address data");
        vt = at().data;
      }
      if (Oe.pubkey) {
        if (vt.length > 0 && !vt.equals(Oe.pubkey))
          throw new TypeError("Pubkey mismatch");
        vt = Oe.pubkey;
      }
      if (Oe.output) {
        if (Oe.output.length !== 34 || Oe.output[0] !== pe.OP_1 || Oe.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (vt.length > 0 && !vt.equals(Oe.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        vt = Oe.output.slice(2);
      }
      if (Oe.internalPubkey) {
        const Ct = (0, V.tweakKey)(Oe.internalPubkey, yt.hash);
        if (vt.length > 0 && !vt.equals(Ct.x))
          throw new TypeError("Pubkey mismatch");
        vt = Ct.x;
      }
      if (vt && vt.length && !(0, J.getEccLib)().isXOnlyPoint(vt))
        throw new TypeError("Invalid pubkey for p2tr");
      const $t = pt();
      if (Oe.hash && $t && !Oe.hash.equals($t.hash))
        throw new TypeError("Hash mismatch");
      if (Oe.redeem && Oe.redeem.output && $t) {
        const Ct = (0, V.tapleafHash)({
          output: Oe.redeem.output,
          version: yt.redeemVersion
        });
        if (!(0, V.findScriptPath)($t, Ct))
          throw new TypeError("Redeem script not in tree");
      }
      const xt = lt();
      if (Oe.redeem && yt.redeem) {
        if (Oe.redeem.redeemVersion && Oe.redeem.redeemVersion !== yt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Oe.redeem.output) {
          if (W.decompile(Oe.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (yt.redeem.output && !Oe.redeem.output.equals(yt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Oe.redeem.witness && yt.redeem.witness && !(0, K.stacksEqual)(Oe.redeem.witness, yt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (xt && xt.length)
        if (xt.length === 1) {
          if (Oe.signature && !Oe.signature.equals(xt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Ct = xt[xt.length - 1];
          if (Ct.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Ct.length}, expected min 33.`
            );
          if ((Ct.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Ct.length} is incorrect!`
            );
          const Et = (Ct.length - 33) / 32;
          if (Et > 128)
            throw new TypeError(
              `The script path is too long. Got ${Et}, expected max 128.`
            );
          const St = Ct.slice(1, 33);
          if (Oe.internalPubkey && !Oe.internalPubkey.equals(St))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, J.getEccLib)().isXOnlyPoint(St))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const It = Ct[0] & K.TAPLEAF_VERSION_MASK, Tt = xt[xt.length - 2], nt = (0, V.tapleafHash)({
            output: Tt,
            version: It
          }), it = (0, V.rootHashFromPath)(Ct, nt), ke = (0, V.tweakKey)(St, it);
          if (!ke)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (vt.length && !vt.equals(ke.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (ke.parity !== (Ct[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(yt, Oe);
  }
  return p2tr.p2tr = Ce, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const L = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return L.p2data;
      }
    });
    const W = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return W.p2ms;
      }
    });
    const K = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return K.p2pk;
      }
    });
    const J = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return J.p2pkh;
      }
    });
    const V = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return V.p2sh;
      }
    });
    const re = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return re.p2wpkh;
      }
    });
    const ie = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ie.p2wsh;
      }
    });
    const oe = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return oe.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks$2, L = requirePayments(), W = requireScript(), K = types$7, J = dist$1, V = bs58check$5, re = 40, ie = 2, oe = 16, pe = 2, ne = 80, ce = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Ce(yt, vt) {
    const $t = yt.slice(2);
    if ($t.length < ie || $t.length > re)
      throw new TypeError("Invalid program length for segwit address");
    const xt = yt[0] - ne;
    if (xt < pe || xt > oe)
      throw new TypeError("Invalid version for segwit address");
    if (yt[1] !== $t.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(ce), lt($t, xt, vt.bech32);
  }
  function Oe(yt) {
    const vt = Buffer$2.from(V.decode(yt));
    if (vt.length < 21) throw new TypeError(yt + " is too short");
    if (vt.length > 21) throw new TypeError(yt + " is too long");
    const $t = vt.readUInt8(0), xt = vt.slice(1);
    return { version: $t, hash: xt };
  }
  address.fromBase58Check = Oe;
  function st(yt) {
    let vt, $t;
    try {
      vt = J.bech32.decode(yt);
    } catch {
    }
    if (vt) {
      if ($t = vt.words[0], $t !== 0) throw new TypeError(yt + " uses wrong encoding");
    } else if (vt = J.bech32m.decode(yt), $t = vt.words[0], $t === 0) throw new TypeError(yt + " uses wrong encoding");
    const xt = J.bech32.fromWords(vt.words.slice(1));
    return {
      version: $t,
      prefix: vt.prefix,
      data: Buffer$2.from(xt)
    };
  }
  address.fromBech32 = st;
  function at(yt, vt) {
    (0, K.typeforce)(
      (0, K.tuple)(K.Hash160bit, K.UInt8),
      arguments
    );
    const $t = Buffer$2.allocUnsafe(21);
    return $t.writeUInt8(vt, 0), yt.copy($t, 1), V.encode($t);
  }
  address.toBase58Check = at;
  function lt(yt, vt, $t) {
    const xt = J.bech32.toWords(yt);
    return xt.unshift(vt), vt === 0 ? J.bech32.encode($t, xt) : J.bech32m.encode($t, xt);
  }
  address.toBech32 = lt;
  function pt(yt, vt) {
    vt = vt || B.bitcoin;
    try {
      return L.p2pkh({ output: yt, network: vt }).address;
    } catch {
    }
    try {
      return L.p2sh({ output: yt, network: vt }).address;
    } catch {
    }
    try {
      return L.p2wpkh({ output: yt, network: vt }).address;
    } catch {
    }
    try {
      return L.p2wsh({ output: yt, network: vt }).address;
    } catch {
    }
    try {
      return L.p2tr({ output: yt, network: vt }).address;
    } catch {
    }
    try {
      return Ce(yt, vt);
    } catch {
    }
    throw new Error(W.toASM(yt) + " has no matching Address");
  }
  address.fromOutputScript = pt;
  function ht(yt, vt) {
    vt = vt || B.bitcoin;
    let $t, xt;
    try {
      $t = Oe(yt);
    } catch {
    }
    if ($t) {
      if ($t.version === vt.pubKeyHash)
        return L.p2pkh({ hash: $t.hash }).output;
      if ($t.version === vt.scriptHash)
        return L.p2sh({ hash: $t.hash }).output;
    } else {
      try {
        xt = st(yt);
      } catch {
      }
      if (xt) {
        if (xt.prefix !== vt.bech32)
          throw new Error(yt + " has an invalid prefix");
        if (xt.version === 0) {
          if (xt.data.length === 20)
            return L.p2wpkh({ hash: xt.data }).output;
          if (xt.data.length === 32)
            return L.p2wsh({ hash: xt.data }).output;
        } else if (xt.version === 1) {
          if (xt.data.length === 32)
            return L.p2tr({ pubkey: xt.data }).output;
        } else if (xt.version >= pe && xt.version <= oe && xt.data.length >= ie && xt.data.length <= re)
          return console.warn(ce), W.compile([
            xt.version + ne,
            xt.data
          ]);
      }
    }
    throw new Error(yt + " has no matching Script");
  }
  return address.toOutputScript = ht, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, L) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof L != "function")
    throw TypeError("Expected digest Function");
  let W = B.length;
  const K = B.concat();
  for (; W > 1; ) {
    let J = 0;
    for (let V = 0; V < W; V += 2, ++J) {
      const re = K[V], ie = V + 1 === W ? re : K[V + 1], oe = Buffer$2.concat([re, ie]);
      K[J] = L(oe);
    }
    W = J;
  }
  return K[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$4, bscript$2 = requireScript(), script_1 = requireScript(), types$4 = types$7, { typeforce: typeforce$2 } = types$4;
function varSliceSize(B) {
  const L = B.length;
  return bufferutils_1$2.varuint.encodingLength(L) + L;
}
function vectorSize(B) {
  const L = B.length;
  return bufferutils_1$2.varuint.encodingLength(L) + B.reduce((W, K) => W + varSliceSize(K), 0);
}
const EMPTY_BUFFER = Buffer$2.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$2.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$2.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$2.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(L, W) {
    const K = new bufferutils_1$2.BufferReader(L), J = new Transaction();
    J.version = K.readInt32();
    const V = K.readUInt8(), re = K.readUInt8();
    let ie = !1;
    V === Transaction.ADVANCED_TRANSACTION_MARKER && re === Transaction.ADVANCED_TRANSACTION_FLAG ? ie = !0 : K.offset -= 2;
    const oe = K.readVarInt();
    for (let ne = 0; ne < oe; ++ne)
      J.ins.push({
        hash: K.readSlice(32),
        index: K.readUInt32(),
        script: K.readVarSlice(),
        sequence: K.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const pe = K.readVarInt();
    for (let ne = 0; ne < pe; ++ne)
      J.outs.push({
        value: K.readUInt64(),
        script: K.readVarSlice()
      });
    if (ie) {
      for (let ne = 0; ne < oe; ++ne)
        J.ins[ne].witness = K.readVector();
      if (!J.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (J.locktime = K.readUInt32(), W) return J;
    if (K.offset !== L.length)
      throw new Error("Transaction has unexpected data");
    return J;
  }
  static fromHex(L) {
    return Transaction.fromBuffer(Buffer$2.from(L, "hex"), !1);
  }
  static isCoinbaseHash(L) {
    typeforce$2(types$4.Hash256bit, L);
    for (let W = 0; W < 32; ++W)
      if (L[W] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(L, W, K, J) {
    return typeforce$2(
      types$4.tuple(
        types$4.Hash256bit,
        types$4.UInt32,
        types$4.maybe(types$4.UInt32),
        types$4.maybe(types$4.Buffer)
      ),
      arguments
    ), types$4.Null(K) && (K = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: L,
      index: W,
      script: J || EMPTY_BUFFER,
      sequence: K,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(L, W) {
    return typeforce$2(types$4.tuple(types$4.Buffer, types$4.Satoshi), arguments), this.outs.push({
      script: L,
      value: W
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((L) => L.witness.length !== 0);
  }
  weight() {
    const L = this.byteLength(!1), W = this.byteLength(!0);
    return L * 3 + W;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(L = !0) {
    const W = L && this.hasWitnesses();
    return (W ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((K, J) => K + 40 + varSliceSize(J.script), 0) + this.outs.reduce((K, J) => K + 8 + varSliceSize(J.script), 0) + (W ? this.ins.reduce((K, J) => K + vectorSize(J.witness), 0) : 0);
  }
  clone() {
    const L = new Transaction();
    return L.version = this.version, L.locktime = this.locktime, L.ins = this.ins.map((W) => ({
      hash: W.hash,
      index: W.index,
      script: W.script,
      sequence: W.sequence,
      witness: W.witness
    })), L.outs = this.outs.map((W) => ({
      script: W.script,
      value: W.value
    })), L;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(L, W, K) {
    if (typeforce$2(
      types$4.tuple(
        types$4.UInt32,
        types$4.Buffer,
        /* types.UInt8 */
        types$4.Number
      ),
      arguments
    ), L >= this.ins.length) return ONE;
    const J = bscript$2.compile(
      bscript$2.decompile(W).filter((ie) => ie !== script_1.OPS.OP_CODESEPARATOR)
    ), V = this.clone();
    if ((K & 31) === Transaction.SIGHASH_NONE)
      V.outs = [], V.ins.forEach((ie, oe) => {
        oe !== L && (ie.sequence = 0);
      });
    else if ((K & 31) === Transaction.SIGHASH_SINGLE) {
      if (L >= this.outs.length) return ONE;
      V.outs.length = L + 1;
      for (let ie = 0; ie < L; ie++)
        V.outs[ie] = BLANK_OUTPUT;
      V.ins.forEach((ie, oe) => {
        oe !== L && (ie.sequence = 0);
      });
    }
    K & Transaction.SIGHASH_ANYONECANPAY ? (V.ins = [V.ins[L]], V.ins[0].script = J) : (V.ins.forEach((ie) => {
      ie.script = EMPTY_BUFFER;
    }), V.ins[L].script = J);
    const re = Buffer$2.allocUnsafe(V.byteLength(!1) + 4);
    return re.writeInt32LE(K, re.length - 4), V.__toBuffer(re, 0, !1), bcrypto$1.hash256(re);
  }
  hashForWitnessV1(L, W, K, J, V, re) {
    if (typeforce$2(
      types$4.tuple(
        types$4.UInt32,
        typeforce$2.arrayOf(types$4.Buffer),
        typeforce$2.arrayOf(types$4.Satoshi),
        types$4.UInt32
      ),
      arguments
    ), K.length !== this.ins.length || W.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ie = J === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : J & Transaction.SIGHASH_OUTPUT_MASK, pe = (J & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, ne = ie === Transaction.SIGHASH_NONE, ce = ie === Transaction.SIGHASH_SINGLE;
    let Ce = EMPTY_BUFFER, Oe = EMPTY_BUFFER, st = EMPTY_BUFFER, at = EMPTY_BUFFER, lt = EMPTY_BUFFER;
    if (!pe) {
      let vt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach(($t) => {
        vt.writeSlice($t.hash), vt.writeUInt32($t.index);
      }), Ce = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), K.forEach(($t) => vt.writeUInt64($t)), Oe = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        W.map(varSliceSize).reduce(($t, xt) => $t + xt)
      ), W.forEach(
        ($t) => vt.writeVarSlice($t)
      ), st = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach(($t) => vt.writeUInt32($t.sequence)), at = bcrypto$1.sha256(vt.end());
    }
    if (ne || ce) {
      if (ce && L < this.outs.length) {
        const vt = this.outs[L], $t = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(vt.script)
        );
        $t.writeUInt64(vt.value), $t.writeVarSlice(vt.script), lt = bcrypto$1.sha256($t.end());
      }
    } else {
      const vt = this.outs.map((xt) => 8 + varSliceSize(xt.script)).reduce((xt, Ct) => xt + Ct), $t = bufferutils_1$2.BufferWriter.withCapacity(vt);
      this.outs.forEach((xt) => {
        $t.writeUInt64(xt.value), $t.writeVarSlice(xt.script);
      }), lt = bcrypto$1.sha256($t.end());
    }
    const pt = (V ? 2 : 0) + (re ? 1 : 0), ht = 174 - (pe ? 49 : 0) - (ne ? 32 : 0) + (re ? 32 : 0) + (V ? 37 : 0), yt = bufferutils_1$2.BufferWriter.withCapacity(ht);
    if (yt.writeUInt8(J), yt.writeInt32(this.version), yt.writeUInt32(this.locktime), yt.writeSlice(Ce), yt.writeSlice(Oe), yt.writeSlice(st), yt.writeSlice(at), ne || ce || yt.writeSlice(lt), yt.writeUInt8(pt), pe) {
      const vt = this.ins[L];
      yt.writeSlice(vt.hash), yt.writeUInt32(vt.index), yt.writeUInt64(K[L]), yt.writeVarSlice(W[L]), yt.writeUInt32(vt.sequence);
    } else
      yt.writeUInt32(L);
    if (re) {
      const vt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(re)
      );
      vt.writeVarSlice(re), yt.writeSlice(bcrypto$1.sha256(vt.end()));
    }
    return ce && yt.writeSlice(lt), V && (yt.writeSlice(V), yt.writeUInt8(0), yt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$2.concat([Buffer$2.from([0]), yt.end()])
    );
  }
  hashForWitnessV0(L, W, K, J) {
    typeforce$2(
      types$4.tuple(types$4.UInt32, types$4.Buffer, types$4.Satoshi, types$4.UInt32),
      arguments
    );
    let V = Buffer$2.from([]), re, ie = ZERO, oe = ZERO, pe = ZERO;
    if (J & Transaction.SIGHASH_ANYONECANPAY || (V = Buffer$2.allocUnsafe(36 * this.ins.length), re = new bufferutils_1$2.BufferWriter(V, 0), this.ins.forEach((ce) => {
      re.writeSlice(ce.hash), re.writeUInt32(ce.index);
    }), oe = bcrypto$1.hash256(V)), !(J & Transaction.SIGHASH_ANYONECANPAY) && (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE && (V = Buffer$2.allocUnsafe(4 * this.ins.length), re = new bufferutils_1$2.BufferWriter(V, 0), this.ins.forEach((ce) => {
      re.writeUInt32(ce.sequence);
    }), pe = bcrypto$1.hash256(V)), (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE) {
      const ce = this.outs.reduce((Ce, Oe) => Ce + 8 + varSliceSize(Oe.script), 0);
      V = Buffer$2.allocUnsafe(ce), re = new bufferutils_1$2.BufferWriter(V, 0), this.outs.forEach((Ce) => {
        re.writeUInt64(Ce.value), re.writeVarSlice(Ce.script);
      }), ie = bcrypto$1.hash256(V);
    } else if ((J & 31) === Transaction.SIGHASH_SINGLE && L < this.outs.length) {
      const ce = this.outs[L];
      V = Buffer$2.allocUnsafe(8 + varSliceSize(ce.script)), re = new bufferutils_1$2.BufferWriter(V, 0), re.writeUInt64(ce.value), re.writeVarSlice(ce.script), ie = bcrypto$1.hash256(V);
    }
    V = Buffer$2.allocUnsafe(156 + varSliceSize(W)), re = new bufferutils_1$2.BufferWriter(V, 0);
    const ne = this.ins[L];
    return re.writeInt32(this.version), re.writeSlice(oe), re.writeSlice(pe), re.writeSlice(ne.hash), re.writeUInt32(ne.index), re.writeVarSlice(W), re.writeUInt64(K), re.writeUInt32(ne.sequence), re.writeSlice(ie), re.writeUInt32(this.locktime), re.writeUInt32(J), bcrypto$1.hash256(V);
  }
  getHash(L) {
    return L && this.isCoinbase() ? Buffer$2.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, L));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(L, W) {
    return this.__toBuffer(L, W, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(L, W) {
    typeforce$2(types$4.tuple(types$4.Number, types$4.Buffer), arguments), this.ins[L].script = W;
  }
  setWitness(L, W) {
    typeforce$2(types$4.tuple(types$4.Number, [types$4.Buffer]), arguments), this.ins[L].witness = W;
  }
  __toBuffer(L, W, K = !1) {
    L || (L = Buffer$2.allocUnsafe(this.byteLength(K)));
    const J = new bufferutils_1$2.BufferWriter(
      L,
      W || 0
    );
    J.writeInt32(this.version);
    const V = K && this.hasWitnesses();
    return V && (J.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), J.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), J.writeVarInt(this.ins.length), this.ins.forEach((re) => {
      J.writeSlice(re.hash), J.writeUInt32(re.index), J.writeVarSlice(re.script), J.writeUInt32(re.sequence);
    }), J.writeVarInt(this.outs.length), this.outs.forEach((re) => {
      isOutput(re) ? J.writeUInt64(re.value) : J.writeSlice(re.valueBuffer), J.writeVarSlice(re.script);
    }), V && this.ins.forEach((re) => {
      J.writeVector(re.witness);
    }), J.writeUInt32(this.locktime), W !== void 0 ? L.slice(W, J.offset) : L;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$4, merkle_1 = merkle, transaction_1$3 = transaction, types$3 = types$7, { typeforce: typeforce$1 } = types$3, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(L) {
    if (L.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const W = new bufferutils_1$1.BufferReader(L), K = new Block();
    if (K.version = W.readInt32(), K.prevHash = W.readSlice(32), K.merkleRoot = W.readSlice(32), K.timestamp = W.readUInt32(), K.bits = W.readUInt32(), K.nonce = W.readUInt32(), L.length === 80) return K;
    const J = () => {
      const ie = transaction_1$3.Transaction.fromBuffer(
        W.buffer.slice(W.offset),
        !0
      );
      return W.offset += ie.byteLength(), ie;
    }, V = W.readVarInt();
    K.transactions = [];
    for (let ie = 0; ie < V; ++ie) {
      const oe = J();
      K.transactions.push(oe);
    }
    const re = K.getWitnessCommit();
    return re && (K.witnessCommit = re), K;
  }
  static fromHex(L) {
    return Block.fromBuffer(Buffer$2.from(L, "hex"));
  }
  static calculateTarget(L) {
    const W = ((L & 4278190080) >> 24) - 3, K = L & 8388607, J = Buffer$2.alloc(32, 0);
    return J.writeUIntBE(K, 29 - W, 3), J;
  }
  static calculateMerkleRoot(L, W) {
    if (typeforce$1([{ getHash: types$3.Function }], L), L.length === 0) throw errorMerkleNoTxes;
    if (W && !txesHaveWitnessCommit(L))
      throw errorWitnessNotSegwit;
    const K = L.map(
      (V) => V.getHash(W)
    ), J = (0, merkle_1.fastMerkleRoot)(K, bcrypto.hash256);
    return W ? bcrypto.hash256(
      Buffer$2.concat([J, L[0].ins[0].witness[0]])
    ) : J;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const L = this.transactions[0].outs.filter(
      (K) => K.script.slice(0, 6).equals(Buffer$2.from("6a24aa21a9ed", "hex"))
    ).map((K) => K.script.slice(6, 38));
    if (L.length === 0) return null;
    const W = L[L.length - 1];
    return W instanceof Buffer$2 && W.length === 32 ? W : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$2 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const L = this.byteLength(!1, !1), W = this.byteLength(!1, !0);
    return L * 3 + W;
  }
  byteLength(L, W = !0) {
    return L || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((K, J) => K + J.byteLength(W), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const L = /* @__PURE__ */ new Date(0);
    return L.setUTCSeconds(this.timestamp), L;
  }
  // TODO: buffer, offset compatibility
  toBuffer(L) {
    const W = Buffer$2.allocUnsafe(this.byteLength(L)), K = new bufferutils_1$1.BufferWriter(W);
    return K.writeInt32(this.version), K.writeSlice(this.prevHash), K.writeSlice(this.merkleRoot), K.writeUInt32(this.timestamp), K.writeUInt32(this.bits), K.writeUInt32(this.nonce), L || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      W,
      K.offset
    ), K.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((J) => {
      const V = J.byteLength();
      J.toBuffer(W, K.offset), K.offset += V;
    })), W;
  }
  toHex(L) {
    return this.toBuffer(L).toString("hex");
  }
  checkTxRoots() {
    const L = this.hasWitnessCommit();
    return !L && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (L ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const L = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), W = Block.calculateTarget(this.bits);
    return L.compare(W) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const L = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(L) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const L = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(L) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (L) => typeof L == "object" && L.ins instanceof Array && L.ins.some(
      (W) => typeof W == "object" && W.witness instanceof Array && W.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(L) {
    L[L.UNSIGNED_TX = 0] = "UNSIGNED_TX", L[L.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(L) {
    L[L.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", L[L.WITNESS_UTXO = 1] = "WITNESS_UTXO", L[L.PARTIAL_SIG = 2] = "PARTIAL_SIG", L[L.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", L[L.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", L[L.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", L[L.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", L[L.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", L[L.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", L[L.POR_COMMITMENT = 9] = "POR_COMMITMENT", L[L.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", L[L.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", L[L.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", L[L.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", L[L.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", L[L.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(L) {
    L[L.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", L[L.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", L[L.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", L[L.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", L[L.TAP_TREE = 6] = "TAP_TREE", L[L.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$3 = (B) => [...Array(B).keys()];
function decode$g(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const L = B.key.slice(1), W = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: L,
    path: "m"
  };
  for (const K of range$3(B.value.length / 4 - 1)) {
    const J = B.value.readUInt32LE(K * 4 + 4), V = !!(J & 2147483648), re = J & 2147483647;
    W.path += "/" + re.toString(10) + (V ? "'" : "");
  }
  return W;
}
globalXpub$1.decode = decode$g;
function encode$g(B) {
  const L = Buffer$2.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), W = Buffer$2.concat([L, B.extendedPubkey]), K = B.path.split("/"), J = Buffer$2.allocUnsafe(K.length * 4);
  B.masterFingerprint.copy(J, 0);
  let V = 4;
  return K.slice(1).forEach((re) => {
    const ie = re.slice(-1) === "'";
    let oe = 2147483647 & parseInt(ie ? re.slice(0, -1) : re, 10);
    ie && (oe += 2147483648), J.writeUInt32LE(oe, V), V += 4;
  }), {
    key: W,
    value: J
  };
}
globalXpub$1.encode = encode$g;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const L = B.extendedPubkey, W = B.masterFingerprint, K = B.path;
  return Buffer$2.isBuffer(L) && L.length === 78 && [2, 3].indexOf(L[45]) > -1 && Buffer$2.isBuffer(W) && W.length === 4 && typeof K == "string" && !!K.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, L, W) {
  const K = L.extendedPubkey.toString("hex");
  return W.has(K) ? !1 : (W.add(K), B.filter((J) => J.extendedPubkey.equals(L.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$f(B) {
  return {
    key: Buffer$2.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$f;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$f(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$f;
function encode$e(B) {
  return {
    key: Buffer$2.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$e;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$2.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, L) {
  return !!B && !!L && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$e(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$e;
function encode$d(B) {
  return {
    key: Buffer$2.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$d;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$2.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, L) {
  return !!B && !!L && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$d(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$d;
function encode$c(B) {
  return {
    key: Buffer$2.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$c;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$2.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, L) {
  return !!B && !!L && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$c;
function encode$b(B) {
  const L = Buffer$2.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$2.concat([L, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$b;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$2.isBuffer(B.pubkey) && Buffer$2.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$2.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const L = B[3];
  if (L > 33 || L < 1 || B[3 + L + 1] !== 2) return !1;
  const W = B[3 + L + 2];
  return !(W > 33 || W < 1 || B.length !== 3 + L + 2 + W + 2);
}
function canAddToArray$2(B, L, W) {
  const K = L.pubkey.toString("hex");
  return W.has(K) ? !1 : (W.add(K), B.filter((J) => J.pubkey.equals(L.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$b;
function encode$a(B) {
  return {
    key: Buffer$2.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$2.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$a;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, L) {
  return !!B && !!L && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$a;
function encode$9(B) {
  const L = Buffer$2.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), W = Buffer$2.allocUnsafe(4);
  return W.writeUInt32LE(B, 0), {
    key: L,
    value: W
  };
}
sighashType$1.encode = encode$9;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, L) {
  return !!B && !!L && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$9;
function encode$8(B) {
  return { key: Buffer$2.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$8;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$2.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, L) {
  return !!B && !!L && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const L = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== L)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const W = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: W, leafVersion: L };
}
tapLeafScript$1.decode = decode$8;
function encode$7(B) {
  const L = Buffer$2.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), W = Buffer$2.from([B.leafVersion]);
  return {
    key: Buffer$2.concat([L, B.controlBlock]),
    value: Buffer$2.concat([B.script, W])
  };
}
tapLeafScript$1.encode = encode$7;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$2.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$2.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, L, W) {
  const K = L.controlBlock.toString("hex");
  return W.has(K) ? !1 : (W.add(K), B.filter((J) => J.controlBlock.equals(L.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$7;
function encode$6(B) {
  return { key: Buffer$2.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$6;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$2.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, L) {
  return !!B && !!L && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const L = B.key.slice(1, 33), W = B.key.slice(33);
  return {
    pubkey: L,
    leafHash: W,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$6;
function encode$5(B) {
  const L = Buffer$2.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$2.concat([L, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$5;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$2.isBuffer(B.pubkey) && Buffer$2.isBuffer(B.leafHash) && Buffer$2.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, L, W) {
  const K = L.pubkey.toString("hex") + L.leafHash.toString("hex");
  return W.has(K) ? !1 : (W.add(K), B.filter(
    (J) => J.pubkey.equals(L.pubkey) && J.leafHash.equals(L.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$4(B, L, W) {
  if (checkUInt53(B), L || (L = Buffer$2.allocUnsafe(encodingLength(B))), !Buffer$2.isBuffer(L))
    throw new TypeError("buffer must be a Buffer instance");
  return W || (W = 0), B < 253 ? (L.writeUInt8(B, W), Object.assign(encode$4, { bytes: 1 })) : B <= 65535 ? (L.writeUInt8(253, W), L.writeUInt16LE(B, W + 1), Object.assign(encode$4, { bytes: 3 })) : B <= 4294967295 ? (L.writeUInt8(254, W), L.writeUInt32LE(B, W + 1), Object.assign(encode$4, { bytes: 5 })) : (L.writeUInt8(255, W), L.writeUInt32LE(B >>> 0, W + 1), L.writeUInt32LE(B / 4294967296 | 0, W + 5), Object.assign(encode$4, { bytes: 9 })), L;
}
varint.encode = encode$4;
function decode$5(B, L) {
  if (!Buffer$2.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  L || (L = 0);
  const W = B.readUInt8(L);
  if (W < 253)
    return Object.assign(decode$5, { bytes: 1 }), W;
  if (W === 253)
    return Object.assign(decode$5, { bytes: 3 }), B.readUInt16LE(L + 1);
  if (W === 254)
    return Object.assign(decode$5, { bytes: 5 }), B.readUInt32LE(L + 1);
  {
    Object.assign(decode$5, { bytes: 9 });
    const K = B.readUInt32LE(L + 1), V = B.readUInt32LE(L + 5) * 4294967296 + K;
    return checkUInt53(V), V;
  }
}
varint.decode = decode$5;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let L = B.length - 1, W = 0;
  for (let K = 0; K < B.length / 2; K++)
    W = B[K], B[K] = B[L], B[L] = W, L--;
  return B;
}
tools.reverseBuffer = reverseBuffer$1;
function keyValsToBuffer(B) {
  const L = B.map(keyValToBuffer);
  return L.push(Buffer$2.from([0])), Buffer$2.concat(L);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const L = B.key.length, W = B.value.length, K = varuint$6.encodingLength(L), J = varuint$6.encodingLength(W), V = Buffer$2.allocUnsafe(
    K + L + J + W
  );
  return varuint$6.encode(L, V, 0), B.key.copy(V, K), varuint$6.encode(W, V, K + L), B.value.copy(V, K + L + J), V;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, L) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > L) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, L) {
  const W = B.readUInt32LE(L);
  let K = B.readUInt32LE(L + 4);
  return K *= 4294967296, verifuint(K + W, 9007199254740991), K + W;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, L, W) {
  return verifuint(L, 9007199254740991), B.writeInt32LE(L & -1, W), B.writeUInt32LE(Math.floor(L / 4294967296), W + 4), W + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const L = tools_1$2.readUInt64LE(B.value, 0);
  let W = 8;
  const K = varuint$5.decode(B.value, W);
  W += varuint$5.encodingLength(K);
  const J = B.value.slice(W);
  if (J.length !== K)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: J,
    value: L
  };
}
witnessUtxo$1.decode = decode$4;
function encode$3(B) {
  const { script: L, value: W } = B, K = varuint$5.encodingLength(L.length), J = Buffer$2.allocUnsafe(8 + K + L.length);
  return tools_1$2.writeUInt64LE(J, W, 0), varuint$5.encode(L.length, J, 8), L.copy(J, 8 + K), {
    key: Buffer$2.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: J
  };
}
witnessUtxo$1.encode = encode$3;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$2.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, L) {
  return !!B && !!L && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let L = 0;
  const W = [];
  for (; L < B.value.length; ) {
    const K = B.value[L++], J = B.value[L++], V = varuint$4.decode(B.value, L);
    L += varuint$4.encodingLength(V), W.push({
      depth: K,
      leafVersion: J,
      script: B.value.slice(L, L + V)
    }), L += V;
  }
  return { leaves: W };
}
tapTree$1.decode = decode$3;
function encode$2(B) {
  const L = Buffer$2.from([typeFields_1$3.OutputTypes.TAP_TREE]), W = [].concat(
    ...B.leaves.map((K) => [
      Buffer$2.of(K.depth, K.leafVersion),
      varuint$4.encode(K.script.length),
      K.script
    ])
  );
  return {
    key: L,
    value: Buffer$2.concat(W)
  };
}
tapTree$1.encode = encode$2;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (L) => L.depth >= 0 && L.depth <= 128 && (L.leafVersion & 254) === L.leafVersion && Buffer$2.isBuffer(L.script)
  );
}
tapTree$1.check = check;
function canAdd(B, L) {
  return !!B && !!L && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$2 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, L = isValidDERKey) {
  function W(ie) {
    if (ie.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ie.key.toString("hex")
      );
    const oe = ie.key.slice(1);
    if (!L(oe))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ie.key.toString("hex")
      );
    if (ie.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const pe = {
      masterFingerprint: ie.value.slice(0, 4),
      pubkey: oe,
      path: "m"
    };
    for (const ne of range$2(ie.value.length / 4 - 1)) {
      const ce = ie.value.readUInt32LE(ne * 4 + 4), Ce = !!(ce & 2147483648), Oe = ce & 2147483647;
      pe.path += "/" + Oe.toString(10) + (Ce ? "'" : "");
    }
    return pe;
  }
  function K(ie) {
    const oe = Buffer$2.from([B]), pe = Buffer$2.concat([oe, ie.pubkey]), ne = ie.path.split("/"), ce = Buffer$2.allocUnsafe(ne.length * 4);
    ie.masterFingerprint.copy(ce, 0);
    let Ce = 4;
    return ne.slice(1).forEach((Oe) => {
      const st = Oe.slice(-1) === "'";
      let at = 2147483647 & parseInt(st ? Oe.slice(0, -1) : Oe, 10);
      st && (at += 2147483648), ce.writeUInt32LE(at, Ce), Ce += 4;
    }), {
      key: pe,
      value: ce
    };
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function V(ie) {
    return Buffer$2.isBuffer(ie.pubkey) && Buffer$2.isBuffer(ie.masterFingerprint) && typeof ie.path == "string" && L(ie.pubkey) && ie.masterFingerprint.length === 4;
  }
  function re(ie, oe, pe) {
    const ne = oe.pubkey.toString("hex");
    return pe.has(ne) ? !1 : (pe.add(ne), ie.filter((ce) => ce.pubkey.equals(oe.pubkey)).length === 0);
  }
  return {
    decode: W,
    encode: K,
    check: V,
    expected: J,
    canAddToArray: re
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return L;
  function L(W) {
    let K;
    if (B.includes(W.key[0]) && (K = W.key.slice(1), !(K.length === 33 || K.length === 65) || ![2, 3, 4].includes(K[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + W.key.toString("hex")
      );
    return K;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function L(re) {
    if (re.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + re.key.toString("hex")
      );
    return re.value;
  }
  function W(re) {
    return {
      key: Buffer$2.from([B]),
      value: re
    };
  }
  const K = "Buffer";
  function J(re) {
    return Buffer$2.isBuffer(re);
  }
  function V(re, ie) {
    return !!re && !!ie && re.redeemScript === void 0;
  }
  return {
    decode: L,
    encode: W,
    check: J,
    expected: K,
    canAdd: V
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const L = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function W(re) {
    const ie = varuint$3.decode(re.value), oe = varuint$3.encodingLength(ie), pe = L.decode({
      key: re.key,
      value: re.value.slice(oe + ie * 32)
    }), ne = new Array(ie);
    for (let ce = 0, Ce = oe; ce < ie; ce++, Ce += 32)
      ne[ce] = re.value.slice(Ce, Ce + 32);
    return Object.assign({}, pe, { leafHashes: ne });
  }
  function K(re) {
    const ie = L.encode(re), oe = varuint$3.encodingLength(re.leafHashes.length), pe = Buffer$2.allocUnsafe(oe);
    varuint$3.encode(re.leafHashes.length, pe);
    const ne = Buffer$2.concat([pe, ...re.leafHashes, ie.value]);
    return Object.assign({}, ie, { value: ne });
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function V(re) {
    return Array.isArray(re.leafHashes) && re.leafHashes.every(
      (ie) => Buffer$2.isBuffer(ie) && ie.length === 32
    ) && L.check(re);
  }
  return {
    decode: W,
    encode: K,
    check: V,
    expected: J,
    canAddToArray: L.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function L(re) {
    if (re.key[0] !== B || re.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + re.key.toString("hex")
      );
    if (re.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return re.value;
  }
  function W(re) {
    return { key: Buffer$2.from([B]), value: re };
  }
  const K = "Buffer";
  function J(re) {
    return Buffer$2.isBuffer(re) && re.length === 32;
  }
  function V(re, ie) {
    return !!re && !!ie && re.tapInternalKey === void 0;
  }
  return {
    decode: L,
    encode: W,
    check: J,
    expected: K,
    canAdd: V
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function L(re) {
    if (re.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + re.key.toString("hex")
      );
    return re.value;
  }
  function W(re) {
    return {
      key: Buffer$2.from([B]),
      value: re
    };
  }
  const K = "Buffer";
  function J(re) {
    return Buffer$2.isBuffer(re);
  }
  function V(re, ie) {
    return !!re && !!ie && re.witnessScript === void 0;
  }
  return {
    decode: L,
    encode: W,
    check: J,
    expected: K,
    canAdd: V
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, L) {
  let W = 0;
  function K() {
    const lt = varuint$2.decode(B, W);
    W += varuint$2.encodingLength(lt);
    const pt = B.slice(W, W + lt);
    return W += lt, pt;
  }
  function J() {
    const lt = B.readUInt32BE(W);
    return W += 4, lt;
  }
  function V() {
    const lt = B.readUInt8(W);
    return W += 1, lt;
  }
  function re() {
    const lt = K(), pt = K();
    return {
      key: lt,
      value: pt
    };
  }
  function ie() {
    if (W >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const lt = B.readUInt8(W) === 0;
    return lt && W++, lt;
  }
  if (J() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (V() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const oe = [], pe = {};
  for (; !ie(); ) {
    const lt = re(), pt = lt.key.toString("hex");
    if (pe[pt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + pt
      );
    pe[pt] = 1, oe.push(lt);
  }
  const ne = oe.filter(
    (lt) => lt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (ne.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const ce = L(ne[0].value), { inputCount: Ce, outputCount: Oe } = ce.getInputOutputCounts(), st = [], at = [];
  for (const lt of tools_1$1.range(Ce)) {
    const pt = {}, ht = [];
    for (; !ie(); ) {
      const yt = re(), vt = yt.key.toString("hex");
      if (pt[vt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + lt + " key " + vt
        );
      pt[vt] = 1, ht.push(yt);
    }
    st.push(ht);
  }
  for (const lt of tools_1$1.range(Oe)) {
    const pt = {}, ht = [];
    for (; !ie(); ) {
      const yt = re(), vt = yt.key.toString("hex");
      if (pt[vt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + lt + " key " + vt
        );
      pt[vt] = 1, ht.push(yt);
    }
    at.push(ht);
  }
  return psbtFromKeyVals(ce, {
    globalMapKeyVals: oe,
    inputKeyVals: st,
    outputKeyVals: at
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, L, W) {
  if (!L.equals(Buffer$2.from([W])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${L.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: L, inputKeyVals: W, outputKeyVals: K }) {
  const J = {
    unsignedTx: B
  };
  let V = 0;
  for (const ne of L)
    switch (ne.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          ne.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), V > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        V++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        J.globalXpub === void 0 && (J.globalXpub = []), J.globalXpub.push(convert$1.globals.globalXpub.decode(ne));
        break;
      default:
        J.unknownKeyVals || (J.unknownKeyVals = []), J.unknownKeyVals.push(ne);
    }
  const re = W.length, ie = K.length, oe = [], pe = [];
  for (const ne of tools_1$1.range(re)) {
    const ce = {};
    for (const Ce of W[ne])
      switch (convert$1.inputs.checkPubkey(Ce), Ce.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), ce.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          ce.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), ce.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          ce.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          ce.partialSig === void 0 && (ce.partialSig = []), ce.partialSig.push(convert$1.inputs.partialSig.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), ce.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          ce.sighashType = convert$1.inputs.sighashType.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), ce.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          ce.redeemScript = convert$1.inputs.redeemScript.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), ce.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          ce.witnessScript = convert$1.inputs.witnessScript.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          ce.bip32Derivation === void 0 && (ce.bip32Derivation = []), ce.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), ce.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), ce.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Ce
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), ce.porCommitment = convert$1.inputs.porCommitment.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), ce.tapKeySig = convert$1.inputs.tapKeySig.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          ce.tapScriptSig === void 0 && (ce.tapScriptSig = []), ce.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          ce.tapLeafScript === void 0 && (ce.tapLeafScript = []), ce.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          ce.tapBip32Derivation === void 0 && (ce.tapBip32Derivation = []), ce.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), ce.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), ce.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Ce);
          break;
        default:
          ce.unknownKeyVals || (ce.unknownKeyVals = []), ce.unknownKeyVals.push(Ce);
      }
    oe.push(ce);
  }
  for (const ne of tools_1$1.range(ie)) {
    const ce = {};
    for (const Ce of K[ne])
      switch (convert$1.outputs.checkPubkey(Ce), Ce.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), ce.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          ce.redeemScript = convert$1.outputs.redeemScript.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), ce.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          ce.witnessScript = convert$1.outputs.witnessScript.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          ce.bip32Derivation === void 0 && (ce.bip32Derivation = []), ce.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), ce.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), ce.tapTree = convert$1.outputs.tapTree.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          ce.tapBip32Derivation === void 0 && (ce.tapBip32Derivation = []), ce.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Ce)
          );
          break;
        default:
          ce.unknownKeyVals || (ce.unknownKeyVals = []), ce.unknownKeyVals.push(Ce);
      }
    pe.push(ce);
  }
  return { globalMap: J, inputs: oe, outputs: pe };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer$1 = {};
Object.defineProperty(toBuffer$1, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: L, outputs: W }) {
  const { globalKeyVals: K, inputKeyVals: J, outputKeyVals: V } = psbtToKeyVals({
    globalMap: B,
    inputs: L,
    outputs: W
  }), re = tools_1.keyValsToBuffer(K), ie = (ce) => ce.length === 0 ? [Buffer$2.from([0])] : ce.map(tools_1.keyValsToBuffer), oe = ie(J), pe = ie(V), ne = Buffer$2.allocUnsafe(5);
  return ne.writeUIntBE(482972169471, 0, 5), Buffer$2.concat(
    [ne, re].concat(oe, pe)
  );
}
toBuffer$1.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, L) => B.key.compare(L.key);
function keyValsFromMap(B, L) {
  const W = /* @__PURE__ */ new Set(), K = Object.entries(B).reduce((V, [re, ie]) => {
    if (re === "unknownKeyVals") return V;
    const oe = L[re];
    if (oe === void 0) return V;
    const pe = (Array.isArray(ie) ? ie : [ie]).map(
      oe.encode
    );
    return pe.map((ce) => ce.key.toString("hex")).forEach((ce) => {
      if (W.has(ce))
        throw new Error("Serialize Error: Duplicate key: " + ce);
      W.add(ce);
    }), V.concat(pe);
  }, []), J = B.unknownKeyVals ? B.unknownKeyVals.filter((V) => !W.has(V.key.toString("hex"))) : [];
  return K.concat(J).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: L, outputs: W }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: L.map((K) => keyValsFromMap(K, convert.inputs)),
    outputKeyVals: W.map((K) => keyValsFromMap(K, convert.outputs))
  };
}
toBuffer$1.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function L(W) {
    for (var K in W) B.hasOwnProperty(K) || (B[K] = W[K]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), L(fromBuffer), L(toBuffer$1);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const L = B[0], W = parser_1$1.psbtToKeyVals(L), K = B.slice(1);
  if (K.length === 0) throw new Error("Combine: Nothing to combine");
  const J = getTx(L);
  if (J === void 0)
    throw new Error("Combine: Self missing transaction");
  const V = getKeySet(W.globalKeyVals), re = W.inputKeyVals.map(getKeySet), ie = W.outputKeyVals.map(getKeySet);
  for (const oe of K) {
    const pe = getTx(oe);
    if (pe === void 0 || !pe.toBuffer().equals(J.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const ne = parser_1$1.psbtToKeyVals(oe);
    getKeySet(ne.globalKeyVals).forEach(
      keyPusher(
        V,
        W.globalKeyVals,
        ne.globalKeyVals
      )
    ), ne.inputKeyVals.map(getKeySet).forEach(
      (st, at) => st.forEach(
        keyPusher(
          re[at],
          W.inputKeyVals[at],
          ne.inputKeyVals[at]
        )
      )
    ), ne.outputKeyVals.map(getKeySet).forEach(
      (st, at) => st.forEach(
        keyPusher(
          ie[at],
          W.outputKeyVals[at],
          ne.outputKeyVals[at]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(J, {
    globalMapKeyVals: W.globalKeyVals,
    inputKeyVals: W.inputKeyVals,
    outputKeyVals: W.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, L, W) {
  return (K) => {
    if (B.has(K)) return;
    const J = W.filter((V) => V.key.toString("hex") === K)[0];
    L.push(J), B.add(K);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const L = /* @__PURE__ */ new Set();
  return B.forEach((W) => {
    const K = W.key.toString("hex");
    if (L.has(K))
      throw new Error("Combine: KeyValue Map keys should be unique");
    L.add(K);
  }), L;
}
var utils$4 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const L = converter;
  function W(Oe, st) {
    const at = Oe[st];
    if (at === void 0) throw new Error(`No input #${st}`);
    return at;
  }
  B.checkForInput = W;
  function K(Oe, st) {
    const at = Oe[st];
    if (at === void 0) throw new Error(`No output #${st}`);
    return at;
  }
  B.checkForOutput = K;
  function J(Oe, st, at) {
    if (Oe.key[0] < at)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (st && st.filter((lt) => lt.key.equals(Oe.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Oe.key.toString("hex")}`);
  }
  B.checkHasKey = J;
  function V(Oe) {
    let st = 0;
    return Object.keys(Oe).forEach((at) => {
      Number(isNaN(Number(at))) && st++;
    }), st;
  }
  B.getEnumLength = V;
  function re(Oe, st) {
    let at = !1;
    if (st.nonWitnessUtxo || st.witnessUtxo) {
      const lt = !!st.redeemScript, pt = !!st.witnessScript, ht = !lt || !!st.finalScriptSig, yt = !pt || !!st.finalScriptWitness, vt = !!st.finalScriptSig || !!st.finalScriptWitness;
      at = ht && yt && vt;
    }
    if (at === !1)
      throw new Error(
        `Input #${Oe} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = re;
  function ie(Oe, st, at, lt) {
    throw new Error(
      `Data for ${Oe} key ${st} is incorrect: Expected ${at} and got ${JSON.stringify(lt)}`
    );
  }
  function oe(Oe) {
    return (st, at) => {
      for (const lt of Object.keys(st)) {
        const pt = st[lt], { canAdd: ht, canAddToArray: yt, check: vt, expected: $t } = (
          // @ts-ignore
          L[Oe + "s"][lt] || {}
        ), xt = !!yt;
        if (vt)
          if (xt) {
            if (!Array.isArray(pt) || // @ts-ignore
            at[lt] && !Array.isArray(at[lt]))
              throw new Error(`Key type ${lt} must be an array`);
            pt.every(vt) || ie(Oe, lt, $t, pt);
            const Ct = at[lt] || [], Et = /* @__PURE__ */ new Set();
            if (!pt.every((St) => yt(Ct, St, Et)))
              throw new Error("Can not add duplicate data to array");
            at[lt] = Ct.concat(pt);
          } else {
            if (vt(pt) || ie(Oe, lt, $t, pt), !ht(at, pt))
              throw new Error(`Can not add duplicate data to ${Oe}`);
            at[lt] = pt;
          }
      }
    };
  }
  B.updateGlobal = oe("global"), B.updateInput = oe("input"), B.updateOutput = oe("output");
  function pe(Oe, st) {
    const at = Oe.length - 1, lt = W(Oe, at);
    B.updateInput(st, lt);
  }
  B.addInputAttributes = pe;
  function ne(Oe, st) {
    const at = Oe.length - 1, lt = K(Oe, at);
    B.updateOutput(st, lt);
  }
  B.addOutputAttributes = ne;
  function ce(Oe, st) {
    if (!Buffer$2.isBuffer(st) || st.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return st.writeUInt32LE(Oe, 0), st;
  }
  B.defaultVersionSetter = ce;
  function Ce(Oe, st) {
    if (!Buffer$2.isBuffer(st) || st.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return st.writeUInt32LE(Oe, st.length - 4), st;
  }
  B.defaultLocktimeSetter = Ce;
})(utils$4);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$2 = utils$4;
let Psbt$1 = class {
  constructor(L) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: L
    };
  }
  static fromBase64(L, W) {
    const K = Buffer$2.from(L, "base64");
    return this.fromBuffer(K, W);
  }
  static fromHex(L, W) {
    const K = Buffer$2.from(L, "hex");
    return this.fromBuffer(K, W);
  }
  static fromBuffer(L, W) {
    const K = parser_1.psbtFromBuffer(L, W), J = new this(K.globalMap.unsignedTx);
    return Object.assign(J, K), J;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(L) {
    return utils_1$2.updateGlobal(L, this.globalMap), this;
  }
  updateInput(L, W) {
    const K = utils_1$2.checkForInput(this.inputs, L);
    return utils_1$2.updateInput(W, K), this;
  }
  updateOutput(L, W) {
    const K = utils_1$2.checkForOutput(this.outputs, L);
    return utils_1$2.updateOutput(W, K), this;
  }
  addUnknownKeyValToGlobal(L) {
    return utils_1$2.checkHasKey(
      L,
      this.globalMap.unknownKeyVals,
      utils_1$2.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToInput(L, W) {
    const K = utils_1$2.checkForInput(this.inputs, L);
    return utils_1$2.checkHasKey(
      W,
      K.unknownKeyVals,
      utils_1$2.getEnumLength(typeFields_1.InputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(W), this;
  }
  addUnknownKeyValToOutput(L, W) {
    const K = utils_1$2.checkForOutput(this.outputs, L);
    return utils_1$2.checkHasKey(
      W,
      K.unknownKeyVals,
      utils_1$2.getEnumLength(typeFields_1.OutputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(W), this;
  }
  addInput(L) {
    this.globalMap.unsignedTx.addInput(L), this.inputs.push({
      unknownKeyVals: []
    });
    const W = L.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(W))
      throw new Error("unknownKeyVals must be an Array");
    return W.forEach(
      (J) => this.addUnknownKeyValToInput(K, J)
    ), utils_1$2.addInputAttributes(this.inputs, L), this;
  }
  addOutput(L) {
    this.globalMap.unsignedTx.addOutput(L), this.outputs.push({
      unknownKeyVals: []
    });
    const W = L.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(W))
      throw new Error("unknownKeyVals must be an Array");
    return W.forEach(
      (J) => this.addUnknownKeyValToOutput(K, J)
    ), utils_1$2.addOutputAttributes(this.outputs, L), this;
  }
  clearFinalizedInput(L) {
    const W = utils_1$2.checkForInput(this.inputs, L);
    utils_1$2.inputCheckUncleanFinalized(L, W);
    for (const K of Object.keys(W))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(K) || delete W[K];
    return this;
  }
  combine(...L) {
    const W = combiner_1.combine([this].concat(L));
    return Object.assign(this, W), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$4, payments$1 = requirePayments();
function isPaymentFactory$1(B) {
  return (L) => {
    try {
      return B({ output: L }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory$1(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory$1(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory$1(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory$1(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory$1(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory$1(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory$1(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let L = Buffer$2.allocUnsafe(0);
  function W(re) {
    L = Buffer$2.concat([L, Buffer$2.from(re)]);
  }
  function K(re) {
    const ie = L.length, oe = varuint$1.encodingLength(re);
    L = Buffer$2.concat([L, Buffer$2.allocUnsafe(oe)]), varuint$1.encode(re, L, ie);
  }
  function J(re) {
    K(re.length), W(re);
  }
  function V(re) {
    K(re.length), re.forEach(J);
  }
  return V(B), L;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, L) {
  const W = (0, crypto_1.hash160)(B), K = B.slice(1, 33), J = bscript$1.decompile(L);
  if (J === null) throw new Error("Unknown script error");
  return J.findIndex((V) => typeof V == "number" ? !1 : V.equals(B) || V.equals(W) || V.equals(K));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, L) {
  return pubkeyPositionInScript(B, L) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, L) {
  return extractPartialSigs(B).some(
    (K) => signatureBlocksAction(K, bscript$1.signature.decode, L)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, L, W) {
  const { hashType: K } = L(B), J = [];
  switch (K & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && J.push("addInput"), K & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      J.push("addOutput"), J.push("setInputSequence");
      break;
  }
  return J.indexOf(W) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let L = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    L = getPsigsFromInputFinalScripts(B);
  } else
    L = B.partialSig;
  return L.map((W) => W.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const L = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], W = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return L.concat(W).filter((K) => Buffer$2.isBuffer(K) && bscript$1.isCanonicalScriptSignature(K)).map((K) => ({ signature: K }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$7, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly$2 = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly$2;
function tapScriptFinalizer(B, L, W) {
  const K = findTapLeafToFinalize(
    L,
    B,
    W
  );
  try {
    const V = sortSignatures(L, K).concat(K.script).concat(K.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(V)
    };
  } catch (J) {
    throw new Error(`Can not finalize taproot input #${B}: ${J}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, L) {
  const W = L ? Buffer$2.from([L]) : Buffer$2.from([]);
  return Buffer$2.concat([B, W]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, L) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || L && (0, psbtutils_1$1.isP2TR)(L));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, L, W) {
  checkMixedTaprootAndNonTaprootInputFields(B, L, W), checkIfTapLeafInTree(B, L, W);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, L, W) {
  checkMixedTaprootAndNonTaprootOutputFields(B, L, W), checkTaprootScriptPubkey(B, L);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, L) {
  if (!L.tapTree && !L.tapInternalKey) return;
  const W = L.tapInternalKey || B.tapInternalKey, K = L.tapTree || B.tapTree;
  if (W) {
    const { script: J } = B, V = getTaprootScripPubkey(W, K);
    if (J && !J.equals(V))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, L) {
  const W = L && tapTreeFromList(L.leaves), { output: K } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: W
  });
  return K;
}
function tweakInternalPubKey(B, L) {
  const W = L.tapInternalKey, K = W && (0, bip341_1$1.tweakKey)(W, L.tapMerkleRoot);
  if (!K)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${W && W.toString("hex")}`
    );
  return K.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, L) {
  return extractTaprootSigs(B).some(
    (K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, L)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const L = [];
  if (B.tapKeySig && L.push(B.tapKeySig), B.tapScriptSig && L.push(...B.tapScriptSig.map((W) => W.signature)), !L.length) {
    const W = getTapKeySigFromWithness(B.finalScriptWitness);
    W && L.push(W);
  }
  return L;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const L = B.slice(2);
  if (L.length === 64 || L.length === 65) return L;
}
function _tapTreeToList(B, L = [], W = 0) {
  if (W > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (L.push({
    depth: W,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), L) : (B[0] && _tapTreeToList(B[0], L, W + 1), B[1] && _tapTreeToList(B[1], L, W + 1), L) : [];
}
function instertLeavesInTree(B) {
  let L;
  for (const W of B)
    if (L = instertLeafInTree(W, L), !L) throw new Error("No room left to insert tapleaf in tree");
  return L;
}
function instertLeafInTree(B, L, W = 0) {
  if (W > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === W)
    return L ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(L)) return;
  const K = instertLeafInTree(B, L && L[0], W + 1);
  if (K) return [K, L && L[1]];
  const J = instertLeafInTree(B, L && L[1], W + 1);
  if (J) return [L && L[0], J];
}
function checkMixedTaprootAndNonTaprootInputFields(B, L, W) {
  const K = isTaprootInput(B) && hasNonTaprootFields(L), J = hasNonTaprootFields(B) && isTaprootInput(L), V = B === L && isTaprootInput(L) && hasNonTaprootFields(L);
  if (K || J || V)
    throw new Error(
      `Invalid arguments for Psbt.${W}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, L, W) {
  const K = isTaprootOutput(B) && hasNonTaprootFields(L), J = hasNonTaprootFields(B) && isTaprootOutput(L), V = B === L && isTaprootOutput(L) && hasNonTaprootFields(L);
  if (K || J || V)
    throw new Error(
      `Invalid arguments for Psbt.${W}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, L, W) {
  if (L.tapMerkleRoot) {
    const K = (L.tapLeafScript || []).every(
      (V) => isTapLeafInTree(V, L.tapMerkleRoot)
    ), J = (B.tapLeafScript || []).every(
      (V) => isTapLeafInTree(V, L.tapMerkleRoot)
    );
    if (!K || !J)
      throw new Error(
        `Invalid arguments for Psbt.${W}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(L.tapLeafScript || []).every(
    (J) => isTapLeafInTree(J, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${W}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, L) {
  if (!L) return !0;
  const W = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    W
  ).equals(L);
}
function sortSignatures(B, L) {
  const W = (0, bip341_1$1.tapleafHash)({
    output: L.script,
    version: L.leafVersion
  });
  return (B.tapScriptSig || []).filter((K) => K.leafHash.equals(W)).map((K) => addPubkeyPositionInScript(L.script, K)).sort((K, J) => J.positionInScript - K.positionInScript).map((K) => K.signature);
}
function addPubkeyPositionInScript(B, L) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        L.pubkey,
        B
      )
    },
    L
  );
}
function findTapLeafToFinalize(B, L, W) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${L}. No tapleaf script signature provided.`
    );
  const K = (B.tapLeafScript || []).sort((J, V) => J.controlBlock.length - V.controlBlock.length).find(
    (J) => canFinalizeLeaf(J, B.tapScriptSig, W)
  );
  if (!K)
    throw new Error(
      `Can not finalize taproot input #${L}. Signature for tapleaf script not found.`
    );
  return K;
}
function canFinalizeLeaf(B, L, W) {
  const K = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!W || W.equals(K)) && L.find((V) => V.leafHash.equals(K)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1$1 = utils$4, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks$2, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(L, W = {}) {
    const K = Buffer$2.from(L, "base64");
    return this.fromBuffer(K, W);
  }
  static fromHex(L, W = {}) {
    const K = Buffer$2.from(L, "hex");
    return this.fromBuffer(K, W);
  }
  static fromBuffer(L, W = {}) {
    const K = bip174_1.Psbt.fromBuffer(L, transactionFromBuffer), J = new Psbt(W, K);
    return checkTxForDupeIns(J.__CACHE.__TX, J.__CACHE), J;
  }
  constructor(L = {}, W = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = W, this.opts = Object.assign({}, DEFAULT_OPTS, L), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const K = (J, V, re, ie) => Object.defineProperty(J, V, {
      enumerable: re,
      writable: ie
    });
    K(this, "__CACHE", !1, !0), K(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(L) {
    this.setVersion(L);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(L) {
    this.setLocktime(L);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((L) => ({
      hash: (0, bufferutils_1.cloneBuffer)(L.hash),
      index: L.index,
      sequence: L.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((L) => {
      let W;
      try {
        W = (0, address_1.fromOutputScript)(
          L.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(L.script),
        value: L.value,
        address: W
      };
    });
  }
  combine(...L) {
    return this.data.combine(...L.map((W) => W.data)), this;
  }
  clone() {
    const L = Psbt.fromBuffer(this.data.toBuffer());
    return L.opts = JSON.parse(JSON.stringify(this.opts)), L;
  }
  setMaximumFeeRate(L) {
    check32Bit(L), this.opts.maximumFeeRate = L;
  }
  setVersion(L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const W = this.__CACHE;
    return W.__TX.version = L, W.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const W = this.__CACHE;
    return W.__TX.locktime = L, W.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(L, W) {
    check32Bit(W), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const K = this.__CACHE;
    if (K.__TX.ins.length <= L)
      throw new Error("Input index too high");
    return K.__TX.ins[L].sequence = W, K.__EXTRACTED_TX = void 0, this;
  }
  addInputs(L) {
    return L.forEach((W) => this.addInput(W)), this;
  }
  addInput(L) {
    if (arguments.length > 1 || !L || L.hash === void 0 || L.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(L, L, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), L.witnessScript && checkInvalidP2WSH(L.witnessScript);
    const W = this.__CACHE;
    this.data.addInput(L);
    const K = W.__TX.ins[W.__TX.ins.length - 1];
    checkTxInputCache(W, K);
    const J = this.data.inputs.length - 1, V = this.data.inputs[J];
    return V.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, V, J), W.__FEE = void 0, W.__FEE_RATE = void 0, W.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(L) {
    return L.forEach((W) => this.addOutput(W)), this;
  }
  addOutput(L) {
    if (arguments.length > 1 || !L || L.value === void 0 || L.address === void 0 && L.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: W } = L;
    if (typeof W == "string") {
      const { network: J } = this.opts, V = (0, address_1.toOutputScript)(W, J);
      L = Object.assign({}, L, { script: V });
    }
    (0, bip371_1.checkTaprootOutputFields)(L, L, "addOutput");
    const K = this.__CACHE;
    return this.data.addOutput(L), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(L) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const W = this.__CACHE;
    if (L || checkFees(this, W, this.opts), W.__EXTRACTED_TX) return W.__EXTRACTED_TX;
    const K = W.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, K, W, !0), K;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1$1.checkForInput)(this.data.inputs, 0), range$1(this.data.inputs.length).forEach((L) => this.finalizeInput(L)), this;
  }
  finalizeInput(L, W) {
    const K = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return (0, bip371_1.isTaprootInput)(K) ? this._finalizeTaprootInput(
      L,
      K,
      void 0,
      W
    ) : this._finalizeInput(L, K, W);
  }
  finalizeTaprootInput(L, W, K = bip371_1.tapScriptFinalizer) {
    const J = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    if ((0, bip371_1.isTaprootInput)(J))
      return this._finalizeTaprootInput(
        L,
        J,
        W,
        K
      );
    throw new Error(`Cannot finalize input #${L}. Not Taproot.`);
  }
  _finalizeInput(L, W, K = getFinalScripts) {
    const { script: J, isP2SH: V, isP2WSH: re, isSegwit: ie } = getScriptFromInput(
      L,
      W,
      this.__CACHE
    );
    if (!J) throw new Error(`No script found for input #${L}`);
    checkPartialSigSighashes(W);
    const { finalScriptSig: oe, finalScriptWitness: pe } = K(
      L,
      W,
      J,
      ie,
      V,
      re
    );
    if (oe && this.data.updateInput(L, { finalScriptSig: oe }), pe && this.data.updateInput(L, { finalScriptWitness: pe }), !oe && !pe)
      throw new Error(`Unknown error finalizing input #${L}`);
    return this.data.clearFinalizedInput(L), this;
  }
  _finalizeTaprootInput(L, W, K, J = bip371_1.tapScriptFinalizer) {
    if (!W.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${L}. Missing withness utxo.`
      );
    if (W.tapKeySig) {
      const V = payments.p2tr({
        output: W.witnessUtxo.script,
        signature: W.tapKeySig
      }), re = (0, psbtutils_1.witnessStackToScriptWitness)(
        V.witness
      );
      this.data.updateInput(L, { finalScriptWitness: re });
    } else {
      const { finalScriptWitness: V } = J(
        L,
        W,
        K
      );
      this.data.updateInput(L, { finalScriptWitness: V });
    }
    return this.data.clearFinalizedInput(L), this;
  }
  getInputType(L) {
    const W = (0, utils_1$1.checkForInput)(this.data.inputs, L), K = getScriptFromUtxo(L, W, this.__CACHE), J = getMeaningfulScript(
      K,
      L,
      "input",
      W.redeemScript || redeemFromFinalScriptSig(W.finalScriptSig),
      W.witnessScript || redeemFromFinalWitnessScript(W.finalScriptWitness)
    ), V = J.type === "raw" ? "" : J.type + "-", re = classifyScript(J.meaningfulScript);
    return V + re;
  }
  inputHasPubkey(L, W) {
    const K = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return pubkeyInInput(W, K, L, this.__CACHE);
  }
  inputHasHDKey(L, W) {
    const K = (0, utils_1$1.checkForInput)(this.data.inputs, L), J = bip32DerivationIsMine(W);
    return !!K.bip32Derivation && K.bip32Derivation.some(J);
  }
  outputHasPubkey(L, W) {
    const K = (0, utils_1$1.checkForOutput)(this.data.outputs, L);
    return pubkeyInOutput(W, K, L, this.__CACHE);
  }
  outputHasHDKey(L, W) {
    const K = (0, utils_1$1.checkForOutput)(this.data.outputs, L), J = bip32DerivationIsMine(W);
    return !!K.bip32Derivation && K.bip32Derivation.some(J);
  }
  validateSignaturesOfAllInputs(L) {
    return (0, utils_1$1.checkForInput)(this.data.inputs, 0), range$1(this.data.inputs.length).map(
      (K) => this.validateSignaturesOfInput(K, L)
    ).reduce((K, J) => J === !0 && K, !0);
  }
  validateSignaturesOfInput(L, W, K) {
    const J = this.data.inputs[L];
    return (0, bip371_1.isTaprootInput)(J) ? this.validateSignaturesOfTaprootInput(
      L,
      W,
      K
    ) : this._validateSignaturesOfInput(L, W, K);
  }
  _validateSignaturesOfInput(L, W, K) {
    const J = this.data.inputs[L], V = (J || {}).partialSig;
    if (!J || !V || V.length < 1)
      throw new Error("No signatures to validate");
    if (typeof W != "function")
      throw new Error("Need validator function to validate signatures");
    const re = K ? V.filter((ce) => ce.pubkey.equals(K)) : V;
    if (re.length < 1) throw new Error("No signatures for this pubkey");
    const ie = [];
    let oe, pe, ne;
    for (const ce of re) {
      const Ce = bscript.signature.decode(ce.signature), { hash: Oe, script: st } = ne !== Ce.hashType ? getHashForSig(
        L,
        Object.assign({}, J, { sighashType: Ce.hashType }),
        this.__CACHE,
        !0
      ) : { hash: oe, script: pe };
      ne = Ce.hashType, oe = Oe, pe = st, checkScriptForPubkey(ce.pubkey, st, "verify"), ie.push(W(ce.pubkey, Oe, Ce.signature));
    }
    return ie.every((ce) => ce === !0);
  }
  validateSignaturesOfTaprootInput(L, W, K) {
    const J = this.data.inputs[L], V = (J || {}).tapKeySig, re = (J || {}).tapScriptSig;
    if (!J && !V && !(re && !re.length))
      throw new Error("No signatures to validate");
    if (typeof W != "function")
      throw new Error("Need validator function to validate signatures");
    K = K && (0, bip371_1.toXOnly)(K);
    const ie = K ? getTaprootHashesForSig(
      L,
      J,
      this.data.inputs,
      K,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      L,
      J,
      this.data.inputs,
      this.__CACHE
    );
    if (!ie.length) throw new Error("No signatures for this pubkey");
    const oe = ie.find((ne) => !ne.leafHash);
    let pe = 0;
    if (V && oe) {
      if (!W(
        oe.pubkey,
        oe.hash,
        trimTaprootSig(V)
      )) return !1;
      pe++;
    }
    if (re)
      for (const ne of re) {
        const ce = ie.find((Ce) => ne.pubkey.equals(Ce.pubkey));
        if (ce) {
          if (!W(
            ne.pubkey,
            ce.hash,
            trimTaprootSig(ne.signature)
          )) return !1;
          pe++;
        }
      }
    return pe > 0;
  }
  signAllInputsHD(L, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const K = [];
    for (const J of range$1(this.data.inputs.length))
      try {
        this.signInputHD(J, L, W), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(L, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((K, J) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return J(new Error("Need HDSigner to sign input"));
      const V = [], re = [];
      for (const ie of range$1(this.data.inputs.length))
        re.push(
          this.signInputHDAsync(ie, L, W).then(
            () => {
              V.push(!0);
            },
            () => {
              V.push(!1);
            }
          )
        );
      return Promise.all(re).then(() => {
        if (V.every((ie) => ie === !1))
          return J(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInputHD(L, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!W || !W.publicKey || !W.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(L, this.data.inputs, W).forEach((V) => this.signInput(L, V, K)), this;
  }
  signInputHDAsync(L, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((J, V) => {
      if (!W || !W.publicKey || !W.fingerprint)
        return V(new Error("Need HDSigner to sign input"));
      const ie = getSignersFromHD(L, this.data.inputs, W).map(
        (oe) => this.signInputAsync(L, oe, K)
      );
      return Promise.all(ie).then(() => {
        J();
      }).catch(V);
    });
  }
  signAllInputs(L, W) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const K = [];
    for (const J of range$1(this.data.inputs.length))
      try {
        this.signInput(J, L, W), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(L, W) {
    return new Promise((K, J) => {
      if (!L || !L.publicKey)
        return J(new Error("Need Signer to sign input"));
      const V = [], re = [];
      for (const [ie] of this.data.inputs.entries())
        re.push(
          this.signInputAsync(ie, L, W).then(
            () => {
              V.push(!0);
            },
            () => {
              V.push(!1);
            }
          )
        );
      return Promise.all(re).then(() => {
        if (V.every((ie) => ie === !1))
          return J(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInput(L, W, K) {
    if (!W || !W.publicKey)
      throw new Error("Need Signer to sign input");
    const J = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInput(
      L,
      J,
      W,
      void 0,
      K
    ) : this._signInput(L, W, K);
  }
  signTaprootInput(L, W, K, J) {
    if (!W || !W.publicKey)
      throw new Error("Need Signer to sign input");
    const V = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    if ((0, bip371_1.isTaprootInput)(V))
      return this._signTaprootInput(
        L,
        V,
        W,
        K,
        J
      );
    throw new Error(`Input #${L} is not of type Taproot.`);
  }
  _signInput(L, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: V } = getHashAndSighashType(
      this.data.inputs,
      L,
      W.publicKey,
      this.__CACHE,
      K
    ), re = [
      {
        pubkey: W.publicKey,
        signature: bscript.signature.encode(W.sign(J), V)
      }
    ];
    return this.data.updateInput(L, { partialSig: re }), this;
  }
  _signTaprootInput(L, W, K, J, V = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const re = this.checkTaprootHashesForSig(
      L,
      W,
      K,
      J,
      V
    ), ie = re.filter((pe) => !pe.leafHash).map(
      (pe) => (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(pe.hash),
        W.sighashType
      )
    )[0], oe = re.filter((pe) => !!pe.leafHash).map((pe) => ({
      pubkey: (0, bip371_1.toXOnly)(K.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(pe.hash),
        W.sighashType
      ),
      leafHash: pe.leafHash
    }));
    return ie && this.data.updateInput(L, { tapKeySig: ie }), oe.length && this.data.updateInput(L, { tapScriptSig: oe }), this;
  }
  signInputAsync(L, W, K) {
    return Promise.resolve().then(() => {
      if (!W || !W.publicKey)
        throw new Error("Need Signer to sign input");
      const J = (0, utils_1$1.checkForInput)(this.data.inputs, L);
      return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInputAsync(
        L,
        J,
        W,
        void 0,
        K
      ) : this._signInputAsync(L, W, K);
    });
  }
  signTaprootInputAsync(L, W, K, J) {
    return Promise.resolve().then(() => {
      if (!W || !W.publicKey)
        throw new Error("Need Signer to sign input");
      const V = (0, utils_1$1.checkForInput)(this.data.inputs, L);
      if ((0, bip371_1.isTaprootInput)(V))
        return this._signTaprootInputAsync(
          L,
          V,
          W,
          K,
          J
        );
      throw new Error(`Input #${L} is not of type Taproot.`);
    });
  }
  _signInputAsync(L, W, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: V } = getHashAndSighashType(
      this.data.inputs,
      L,
      W.publicKey,
      this.__CACHE,
      K
    );
    return Promise.resolve(W.sign(J)).then((re) => {
      const ie = [
        {
          pubkey: W.publicKey,
          signature: bscript.signature.encode(re, V)
        }
      ];
      this.data.updateInput(L, { partialSig: ie });
    });
  }
  async _signTaprootInputAsync(L, W, K, J, V = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const re = this.checkTaprootHashesForSig(
      L,
      W,
      K,
      J,
      V
    ), ie = [], oe = re.filter((ne) => !ne.leafHash)[0];
    if (oe) {
      const ne = Promise.resolve(
        K.signSchnorr(oe.hash)
      ).then((ce) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          ce,
          W.sighashType
        )
      }));
      ie.push(ne);
    }
    const pe = re.filter((ne) => !!ne.leafHash);
    if (pe.length) {
      const ne = pe.map((ce) => Promise.resolve(K.signSchnorr(ce.hash)).then(
        (Ce) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(K.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Ce,
              W.sighashType
            ),
            leafHash: ce.leafHash
          }
        ] })
      ));
      ie.push(...ne);
    }
    return Promise.all(ie).then((ne) => {
      ne.forEach((ce) => this.data.updateInput(L, ce));
    });
  }
  checkTaprootHashesForSig(L, W, K, J, V) {
    if (typeof K.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${L}.`
      );
    const re = getTaprootHashesForSig(
      L,
      W,
      this.data.inputs,
      K.publicKey,
      this.__CACHE,
      J,
      V
    );
    if (!re || !re.length)
      throw new Error(
        `Can not sign for input #${L} with the key ${K.publicKey.toString(
          "hex"
        )}`
      );
    return re;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(L) {
    return this.data.updateGlobal(L), this;
  }
  updateInput(L, W) {
    return W.witnessScript && checkInvalidP2WSH(W.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[L],
      W,
      "updateInput"
    ), this.data.updateInput(L, W), W.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[L],
      L
    ), this;
  }
  updateOutput(L, W) {
    const K = this.data.outputs[L];
    return (0, bip371_1.checkTaprootOutputFields)(
      K,
      W,
      "updateOutput"
    ), this.data.updateOutput(L, W), this;
  }
  addUnknownKeyValToGlobal(L) {
    return this.data.addUnknownKeyValToGlobal(L), this;
  }
  addUnknownKeyValToInput(L, W) {
    return this.data.addUnknownKeyValToInput(L, W), this;
  }
  addUnknownKeyValToOutput(L, W) {
    return this.data.addUnknownKeyValToOutput(L, W), this;
  }
  clearFinalizedInput(L) {
    return this.data.clearFinalizedInput(L), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(L = Buffer$2.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(L), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(L) {
    if (L.hash === void 0 || L.index === void 0 || !Buffer$2.isBuffer(L.hash) && typeof L.hash != "string" || typeof L.index != "number")
      throw new Error("Error adding input.");
    const W = typeof L.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$2.from(L.hash, "hex")) : L.hash;
    this.tx.addInput(W, L.index, L.sequence);
  }
  addOutput(L) {
    if (L.script === void 0 || L.value === void 0 || !Buffer$2.isBuffer(L.script) || typeof L.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(L.script, L.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, L, W) {
  switch (W) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const K = payments.p2ms({ output: L });
      return hasSigs(K.m, B.partialSig, K.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, L, W) {
  if (!L) return !1;
  let K;
  if (W ? K = W.map((J) => {
    const V = compressPubkey(J);
    return L.find((re) => re.pubkey.equals(V));
  }).filter((J) => !!J) : K = L, K.length > B) throw new Error("Too many signatures");
  return K.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (L) => !(!L.masterFingerprint.equals(B.fingerprint) || !B.derivePath(L.path).publicKey.equals(L.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, L, W) {
  const K = L.__FEE_RATE || B.getFeeRate(), J = L.__EXTRACTED_TX.virtualSize(), V = K * J;
  if (K >= W.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(V / 1e8).toFixed(8)} in fees, which is ${K} satoshi per byte for a transaction with a VSize of ${J} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, L) {
  B.forEach((W) => {
    if ((0, bip371_1.isTaprootInput)(W) ? (0, bip371_1.checkTaprootInputForSigs)(W, L) : (0, psbtutils_1.checkInputForSig)(W, L))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: L, sighashType: W } = B;
  L.forEach((K) => {
    const { hashType: J } = bscript.signature.decode(K.signature);
    if (W !== J)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, L, W) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, L))
    throw new Error(
      `Can not ${W} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (W) => W.script && W.script.length === 0 && W.witness && W.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, L) {
  B.ins.forEach((W) => {
    checkTxInputCache(L, W);
  });
}
function checkTxInputCache(B, L) {
  const W = (0, bufferutils_1.reverseBuffer)(Buffer$2.from(L.hash)).toString("hex") + ":" + L.index;
  if (B.__TX_IN_CACHE[W]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[W] = 1;
}
function scriptCheckerFactory(B, L) {
  return (W, K, J, V) => {
    const re = B({
      redeem: { output: J }
    }).output;
    if (!K.equals(re))
      throw new Error(
        `${L} for ${V} #${W} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, L, W, K) {
  if (!W.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${L}`);
  if (B === "__FEE_RATE" && K.__FEE_RATE) return K.__FEE_RATE;
  if (B === "__FEE" && K.__FEE) return K.__FEE;
  let J, V = !0;
  if (K.__EXTRACTED_TX ? (J = K.__EXTRACTED_TX, V = !1) : J = K.__TX.clone(), inputFinalizeGetAmts(W, J, K, V), B === "__FEE_RATE") return K.__FEE_RATE;
  if (B === "__FEE") return K.__FEE;
}
function getFinalScripts(B, L, W, K, J, V) {
  const re = classifyScript(W);
  if (!canFinalize(L, W, re))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    W,
    re,
    L.partialSig,
    K,
    J,
    V
  );
}
function prepareFinalScripts(B, L, W, K, J, V) {
  let re, ie;
  const oe = getPayment(B, L, W), pe = V ? payments.p2wsh({ redeem: oe }) : null, ne = J ? payments.p2sh({ redeem: pe || oe }) : null;
  return K ? (pe ? ie = (0, psbtutils_1.witnessStackToScriptWitness)(
    pe.witness
  ) : ie = (0, psbtutils_1.witnessStackToScriptWitness)(
    oe.witness
  ), ne && (re = ne.input)) : ne ? re = ne.input : re = oe.input, {
    finalScriptSig: re,
    finalScriptWitness: ie
  };
}
function getHashAndSighashType(B, L, W, K, J) {
  const V = (0, utils_1$1.checkForInput)(B, L), { hash: re, sighashType: ie, script: oe } = getHashForSig(
    L,
    V,
    K,
    !1,
    J
  );
  return checkScriptForPubkey(W, oe, "sign"), {
    hash: re,
    sighashType: ie
  };
}
function getHashForSig(B, L, W, K, J) {
  const V = W.__TX, re = L.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(re, J);
  let ie, oe;
  if (L.nonWitnessUtxo) {
    const ce = nonWitnessUtxoTxFromCache(
      W,
      L,
      B
    ), Ce = V.ins[B].hash, Oe = ce.getHash();
    if (!Ce.equals(Oe))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const st = V.ins[B].index;
    oe = ce.outs[st];
  } else if (L.witnessUtxo)
    oe = L.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: pe, type: ne } = getMeaningfulScript(
    oe.script,
    B,
    "input",
    L.redeemScript,
    L.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(ne) >= 0)
    ie = V.hashForWitnessV0(
      B,
      pe,
      oe.value,
      re
    );
  else if ((0, psbtutils_1.isP2WPKH)(pe)) {
    const ce = payments.p2pkh({
      hash: pe.slice(2)
    }).output;
    ie = V.hashForWitnessV0(
      B,
      ce,
      oe.value,
      re
    );
  } else {
    if (L.nonWitnessUtxo === void 0 && W.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${pe.toString("hex")}`
      );
    !K && W.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ie = V.hashForSignature(
      B,
      pe,
      re
    );
  }
  return {
    script: pe,
    sighashType: re,
    hash: ie
  };
}
function getAllTaprootHashesForSig(B, L, W, K) {
  const J = [];
  if (L.tapInternalKey) {
    const re = getPrevoutTaprootKey(B, L, K);
    re && J.push(re);
  }
  if (L.tapScriptSig) {
    const re = L.tapScriptSig.map((ie) => ie.pubkey);
    J.push(...re);
  }
  return J.map(
    (re) => getTaprootHashesForSig(B, L, W, re, K)
  ).flat();
}
function getPrevoutTaprootKey(B, L, W) {
  const { script: K } = getScriptAndAmountFromUtxo(B, L, W);
  return (0, psbtutils_1.isP2TR)(K) ? K.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, L, W, K, J, V, re) {
  const ie = J.__TX, oe = L.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(oe, re);
  const pe = W.map(
    (st, at) => getScriptAndAmountFromUtxo(at, st, J)
  ), ne = pe.map((st) => st.script), ce = pe.map((st) => st.value), Ce = [];
  if (L.tapInternalKey && !V) {
    const st = getPrevoutTaprootKey(B, L, J) || Buffer$2.from([]);
    if ((0, bip371_1.toXOnly)(K).equals(st)) {
      const at = ie.hashForWitnessV1(
        B,
        ne,
        ce,
        oe
      );
      Ce.push({ pubkey: K, hash: at });
    }
  }
  const Oe = (L.tapLeafScript || []).filter((st) => (0, psbtutils_1.pubkeyInScript)(K, st.script)).map((st) => {
    const at = (0, bip341_1.tapleafHash)({
      output: st.script,
      version: st.leafVersion
    });
    return Object.assign({ hash: at }, st);
  }).filter(
    (st) => !V || V.equals(st.hash)
  ).map((st) => {
    const at = ie.hashForWitnessV1(
      B,
      ne,
      ce,
      oe,
      st.hash
    );
    return {
      pubkey: K,
      hash: at,
      leafHash: st.hash
    };
  });
  return Ce.concat(Oe);
}
function checkSighashTypeAllowed(B, L) {
  if (L && L.indexOf(B) < 0) {
    const W = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${W}`
    );
  }
}
function getPayment(B, L, W) {
  let K;
  switch (L) {
    case "multisig":
      const J = getSortedSigs(B, W);
      K = payments.p2ms({
        output: B,
        signatures: J
      });
      break;
    case "pubkey":
      K = payments.p2pk({
        output: B,
        signature: W[0].signature
      });
      break;
    case "pubkeyhash":
      K = payments.p2pkh({
        output: B,
        pubkey: W[0].pubkey,
        signature: W[0].signature
      });
      break;
    case "witnesspubkeyhash":
      K = payments.p2wpkh({
        output: B,
        pubkey: W[0].pubkey,
        signature: W[0].signature
      });
      break;
  }
  return K;
}
function getScriptFromInput(B, L, W) {
  const K = W.__TX, J = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (J.isP2SH = !!L.redeemScript, J.isP2WSH = !!L.witnessScript, L.witnessScript)
    J.script = L.witnessScript;
  else if (L.redeemScript)
    J.script = L.redeemScript;
  else if (L.nonWitnessUtxo) {
    const V = nonWitnessUtxoTxFromCache(
      W,
      L,
      B
    ), re = K.ins[B].index;
    J.script = V.outs[re].script;
  } else L.witnessUtxo && (J.script = L.witnessUtxo.script);
  return (L.witnessScript || (0, psbtutils_1.isP2WPKH)(J.script)) && (J.isSegwit = !0), J;
}
function getSignersFromHD(B, L, W) {
  const K = (0, utils_1$1.checkForInput)(L, B);
  if (!K.bip32Derivation || K.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const J = K.bip32Derivation.map((re) => {
    if (re.masterFingerprint.equals(W.fingerprint))
      return re;
  }).filter((re) => !!re);
  if (J.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return J.map((re) => {
    const ie = W.derivePath(re.path);
    if (!re.pubkey.equals(ie.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ie;
  });
}
function getSortedSigs(B, L) {
  return payments.p2ms({ output: B }).pubkeys.map((K) => (L.filter((J) => J.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(B) {
  let L = 0;
  function W(re) {
    return L += re, B.slice(L - re, L);
  }
  function K() {
    const re = varuint.decode(B, L);
    return L += varuint.decode.bytes, re;
  }
  function J() {
    return W(K());
  }
  function V() {
    const re = K(), ie = [];
    for (let oe = 0; oe < re; oe++) ie.push(J());
    return ie;
  }
  return V();
}
function sighashTypeToString(B) {
  let L = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      L += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      L += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      L += "SIGHASH_NONE";
      break;
  }
  return L;
}
function addNonWitnessTxCache(B, L, W) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[W] = L.nonWitnessUtxo;
  const K = transaction_1.Transaction.fromBuffer(L.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[W] = K;
  const J = B, V = W;
  delete L.nonWitnessUtxo, Object.defineProperty(L, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const re = J.__NON_WITNESS_UTXO_BUF_CACHE[V], ie = J.__NON_WITNESS_UTXO_TX_CACHE[V];
      if (re !== void 0)
        return re;
      {
        const oe = ie.toBuffer();
        return J.__NON_WITNESS_UTXO_BUF_CACHE[V] = oe, oe;
      }
    },
    set(re) {
      J.__NON_WITNESS_UTXO_BUF_CACHE[V] = re;
    }
  });
}
function inputFinalizeGetAmts(B, L, W, K) {
  let J = 0;
  B.forEach((oe, pe) => {
    if (K && oe.finalScriptSig && (L.ins[pe].script = oe.finalScriptSig), K && oe.finalScriptWitness && (L.ins[pe].witness = scriptWitnessToWitnessStack(
      oe.finalScriptWitness
    )), oe.witnessUtxo)
      J += oe.witnessUtxo.value;
    else if (oe.nonWitnessUtxo) {
      const ne = nonWitnessUtxoTxFromCache(W, oe, pe), ce = L.ins[pe].index, Ce = ne.outs[ce];
      J += Ce.value;
    }
  });
  const V = L.outs.reduce((oe, pe) => oe + pe.value, 0), re = J - V;
  if (re < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ie = L.virtualSize();
  W.__FEE = re, W.__EXTRACTED_TX = L, W.__FEE_RATE = Math.floor(re / ie);
}
function nonWitnessUtxoTxFromCache(B, L, W) {
  const K = B.__NON_WITNESS_UTXO_TX_CACHE;
  return K[W] || addNonWitnessTxCache(B, L, W), K[W];
}
function getScriptFromUtxo(B, L, W) {
  const { script: K } = getScriptAndAmountFromUtxo(B, L, W);
  return K;
}
function getScriptAndAmountFromUtxo(B, L, W) {
  if (L.witnessUtxo !== void 0)
    return {
      script: L.witnessUtxo.script,
      value: L.witnessUtxo.value
    };
  if (L.nonWitnessUtxo !== void 0) {
    const J = nonWitnessUtxoTxFromCache(
      W,
      L,
      B
    ).outs[W.__TX.ins[B].index];
    return { script: J.script, value: J.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, L, W, K) {
  const J = getScriptFromUtxo(W, L, K), { meaningfulScript: V } = getMeaningfulScript(
    J,
    W,
    "input",
    L.redeemScript,
    L.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, V);
}
function pubkeyInOutput(B, L, W, K) {
  const J = K.__TX.outs[W].script, { meaningfulScript: V } = getMeaningfulScript(
    J,
    W,
    "output",
    L.redeemScript,
    L.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, V);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const L = bscript.decompile(B);
  if (!L) return;
  const W = L[L.length - 1];
  if (!(!Buffer$2.isBuffer(W) || isPubkeyLike(W) || isSigLike(W) || !bscript.decompile(W)))
    return W;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const L = scriptWitnessToWitnessStack(B), W = L[L.length - 1];
  if (!(isPubkeyLike(W) || !bscript.decompile(W)))
    return W;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const L = B[64] & 1, W = B.slice(0, 33);
    return W[0] = 2 | L, W;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, L, W, K, J) {
  const V = (0, psbtutils_1.isP2SHScript)(B), re = V && K && (0, psbtutils_1.isP2WSHScript)(K), ie = (0, psbtutils_1.isP2WSHScript)(B);
  if (V && K === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ie || re) && J === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let oe;
  return re ? (oe = J, checkRedeemScript(L, B, K, W), checkWitnessScript(L, K, J, W), checkInvalidP2WSH(oe)) : ie ? (oe = J, checkWitnessScript(L, B, J, W), checkInvalidP2WSH(oe)) : V ? (oe = K, checkRedeemScript(L, B, K, W)) : oe = B, {
    meaningfulScript: oe,
    type: re ? "p2sh-p2wsh" : V ? "p2sh" : ie ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range$1(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const L = requireAddress();
  B.address = L;
  const W = crypto$4;
  B.crypto = W;
  const K = networks$2;
  B.networks = K;
  const J = requirePayments();
  B.payments = J;
  const V = requireScript();
  B.script = V;
  var re = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return re.Block;
    }
  });
  var ie = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return ie.Psbt;
    }
  });
  var oe = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return oe.OPS;
    }
  });
  var pe = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return pe.Transaction;
    }
  });
  var ne = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return ne.initEccLib;
    }
  });
})(src$4);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t = function() {
  return t = Object.assign || function(B) {
    for (var L, W = 1, K = arguments.length; W < K; W++) for (var J in L = arguments[W]) Object.prototype.hasOwnProperty.call(L, J) && (B[J] = L[J]);
    return B;
  }, t.apply(this, arguments);
}, r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", e = (B) => {
  if (!B || typeof B != "string") throw new Error(`Expected base58 string but got “${B}”`);
  if (B.match(/[IOl0]/gmu)) throw new Error(`Invalid base58 character “${B.match(/[IOl0]/gmu)}”`);
  const L = B.match(/^1+/gmu), W = L ? L[0].length : 0, K = (B.length - W) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
  return new Uint8Array([...new Uint8Array(W), ...B.match(/.{1}/gmu).map((V) => r.indexOf(V)).reduce((V, re) => V = V.map((ie) => {
    const oe = 58 * ie + re;
    return re = oe >> 8, oe;
  }), new Uint8Array(K)).reverse().filter((J = !1, (V) => J = J || V))]);
  var J;
};
(() => {
  const B = Array(256).fill(-1);
  for (let L = 0; L < r.length; ++L) B[r.charCodeAt(L)] = L;
})();
var n = e, s, i$1, o, h$2 = (s = function(B, L) {
  Object.defineProperty(L, "__esModule", { value: !0 }), L.bech32m = L.bech32 = void 0;
  const W = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", K = {};
  for (let ce = 0; ce < 32; ce++) {
    const Ce = W.charAt(ce);
    K[Ce] = ce;
  }
  function J(ce) {
    const Ce = ce >> 25;
    return (33554431 & ce) << 5 ^ 996825010 & -(Ce >> 0 & 1) ^ 642813549 & -(Ce >> 1 & 1) ^ 513874426 & -(Ce >> 2 & 1) ^ 1027748829 & -(Ce >> 3 & 1) ^ 705979059 & -(Ce >> 4 & 1);
  }
  function V(ce) {
    let Ce = 1;
    for (let Oe = 0; Oe < ce.length; ++Oe) {
      const st = ce.charCodeAt(Oe);
      if (st < 33 || st > 126) return "Invalid prefix (" + ce + ")";
      Ce = J(Ce) ^ st >> 5;
    }
    Ce = J(Ce);
    for (let Oe = 0; Oe < ce.length; ++Oe) {
      const st = ce.charCodeAt(Oe);
      Ce = J(Ce) ^ 31 & st;
    }
    return Ce;
  }
  function re(ce, Ce, Oe, st) {
    let at = 0, lt = 0;
    const pt = (1 << Oe) - 1, ht = [];
    for (let yt = 0; yt < ce.length; ++yt) for (at = at << Ce | ce[yt], lt += Ce; lt >= Oe; ) lt -= Oe, ht.push(at >> lt & pt);
    if (st) lt > 0 && ht.push(at << Oe - lt & pt);
    else {
      if (lt >= Ce) return "Excess padding";
      if (at << Oe - lt & pt) return "Non-zero padding";
    }
    return ht;
  }
  function ie(ce) {
    return re(ce, 8, 5, !0);
  }
  function oe(ce) {
    const Ce = re(ce, 5, 8, !1);
    if (Array.isArray(Ce)) return Ce;
  }
  function pe(ce) {
    const Ce = re(ce, 5, 8, !1);
    if (Array.isArray(Ce)) return Ce;
    throw new Error(Ce);
  }
  function ne(ce) {
    let Ce;
    function Oe(st, at) {
      if (at = at || 90, st.length < 8) return st + " too short";
      if (st.length > at) return "Exceeds length limit";
      const lt = st.toLowerCase(), pt = st.toUpperCase();
      if (st !== lt && st !== pt) return "Mixed-case string " + st;
      const ht = (st = lt).lastIndexOf("1");
      if (ht === -1) return "No separator character for " + st;
      if (ht === 0) return "Missing prefix for " + st;
      const yt = st.slice(0, ht), vt = st.slice(ht + 1);
      if (vt.length < 6) return "Data too short";
      let $t = V(yt);
      if (typeof $t == "string") return $t;
      const xt = [];
      for (let Ct = 0; Ct < vt.length; ++Ct) {
        const Et = vt.charAt(Ct), St = K[Et];
        if (St === void 0) return "Unknown character " + Et;
        $t = J($t) ^ St, Ct + 6 >= vt.length || xt.push(St);
      }
      return $t !== Ce ? "Invalid checksum for " + st : { prefix: yt, words: xt };
    }
    return Ce = ce === "bech32" ? 1 : 734539939, { decodeUnsafe: function(st, at) {
      const lt = Oe(st, at);
      if (typeof lt == "object") return lt;
    }, decode: function(st, at) {
      const lt = Oe(st, at);
      if (typeof lt == "object") return lt;
      throw new Error(lt);
    }, encode: function(st, at, lt) {
      if (lt = lt || 90, st.length + 7 + at.length > lt) throw new TypeError("Exceeds length limit");
      let pt = V(st = st.toLowerCase());
      if (typeof pt == "string") throw new Error(pt);
      let ht = st + "1";
      for (let yt = 0; yt < at.length; ++yt) {
        const vt = at[yt];
        if (vt >> 5) throw new Error("Non 5-bit word");
        pt = J(pt) ^ vt, ht += W.charAt(vt);
      }
      for (let yt = 0; yt < 6; ++yt) pt = J(pt);
      pt ^= Ce;
      for (let yt = 0; yt < 6; ++yt) ht += W.charAt(pt >> 5 * (5 - yt) & 31);
      return ht;
    }, toWords: ie, fromWordsUnsafe: oe, fromWords: pe };
  }
  L.bech32 = ne("bech32"), L.bech32m = ne("bech32m");
}, s(i$1 = { exports: {} }, i$1.exports), i$1.exports);
(o = h$2) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
var c = h$2.bech32m, a = h$2.bech32;
const f = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];
class l {
  constructor() {
    this.A = 1779033703, this.B = -1150833019, this.C = 1013904242, this.D = -1521486534, this.E = 1359893119, this.F = -1694144372, this.G = 528734635, this.H = 1541459225, this._size = 0, this._sp = 0, (!p || w >= 8e3) && (p = new ArrayBuffer(8e3), w = 0), this._byte = new Uint8Array(p, w, 80), this._word = new Int32Array(p, w, 20), w += 80;
  }
  update(L) {
    if (typeof L == "string") return this._utf8(L);
    if (L == null) throw new TypeError("Invalid type: " + typeof L);
    const W = L.byteOffset, K = L.byteLength;
    let J = K / 64 | 0, V = 0;
    if (J && !(3 & W) && !(this._size % 64)) {
      const re = new Int32Array(L.buffer, W, 16 * J);
      for (; J--; ) this._int32(re, V >> 2), V += 64;
      this._size += V;
    }
    if (L.BYTES_PER_ELEMENT !== 1 && L.buffer) {
      const re = new Uint8Array(L.buffer, W + V, K - V);
      return this._uint8(re);
    }
    return V === K ? this : this._uint8(L, V);
  }
  _uint8(L, W) {
    const { _byte: K, _word: J } = this, V = L.length;
    for (W |= 0; W < V; ) {
      const re = this._size % 64;
      let ie = re;
      for (; W < V && ie < 64; ) K[ie++] = L[W++];
      ie >= 64 && this._int32(J), this._size += ie - re;
    }
    return this;
  }
  _utf8(L) {
    const { _byte: W, _word: K } = this, J = L.length;
    let V = this._sp;
    for (let re = 0; re < J; ) {
      const ie = this._size % 64;
      let oe = ie;
      for (; re < J && oe < 64; ) {
        let pe = 0 | L.charCodeAt(re++);
        pe < 128 ? W[oe++] = pe : pe < 2048 ? (W[oe++] = 192 | pe >>> 6, W[oe++] = 128 | 63 & pe) : pe < 55296 || pe > 57343 ? (W[oe++] = 224 | pe >>> 12, W[oe++] = 128 | pe >>> 6 & 63, W[oe++] = 128 | 63 & pe) : V ? (pe = ((1023 & V) << 10) + (1023 & pe) + 65536, W[oe++] = 240 | pe >>> 18, W[oe++] = 128 | pe >>> 12 & 63, W[oe++] = 128 | pe >>> 6 & 63, W[oe++] = 128 | 63 & pe, V = 0) : V = pe;
      }
      oe >= 64 && (this._int32(K), K[0] = K[16]), this._size += oe - ie;
    }
    return this._sp = V, this;
  }
  _int32(L, W) {
    let { A: K, B: J, C: V, D: re, E: ie, F: oe, G: pe, H: ne } = this, ce = 0;
    for (W |= 0; ce < 16; ) d[ce++] = g(L[W++]);
    for (ce = 16; ce < 64; ce++) d[ce] = A(d[ce - 2]) + d[ce - 7] + m(d[ce - 15]) + d[ce - 16] | 0;
    for (ce = 0; ce < 64; ce++) {
      const Ce = ne + E(ie) + b(ie, oe, pe) + f[ce] + d[ce] | 0, Oe = v(K) + _(K, J, V) | 0;
      ne = pe, pe = oe, oe = ie, ie = re + Ce | 0, re = V, V = J, J = K, K = Ce + Oe | 0;
    }
    this.A = K + this.A | 0, this.B = J + this.B | 0, this.C = V + this.C | 0, this.D = re + this.D | 0, this.E = ie + this.E | 0, this.F = oe + this.F | 0, this.G = pe + this.G | 0, this.H = ne + this.H | 0;
  }
  digest(L) {
    const { _byte: W, _word: K } = this;
    let J = this._size % 64 | 0;
    for (W[J++] = 128; 3 & J; ) W[J++] = 0;
    if (J >>= 2, J > 14) {
      for (; J < 16; ) K[J++] = 0;
      J = 0, this._int32(K);
    }
    for (; J < 16; ) K[J++] = 0;
    const V = 8 * this._size, re = (4294967295 & V) >>> 0, ie = (V - re) / 4294967296;
    return ie && (K[14] = g(ie)), re && (K[15] = g(re)), this._int32(K), L === "hex" ? this._hex() : this._bin();
  }
  _hex() {
    const { A: L, B: W, C: K, D: J, E: V, F: re, G: ie, H: oe } = this;
    return y(L) + y(W) + y(K) + y(J) + y(V) + y(re) + y(ie) + y(oe);
  }
  _bin() {
    const { A: L, B: W, C: K, D: J, E: V, F: re, G: ie, H: oe, _byte: pe, _word: ne } = this;
    return ne[0] = g(L), ne[1] = g(W), ne[2] = g(K), ne[3] = g(J), ne[4] = g(V), ne[5] = g(re), ne[6] = g(ie), ne[7] = g(oe), pe.slice(0, 32);
  }
}
const d = new Int32Array(64);
let p, w = 0;
const y = (B) => (B + 4294967296).toString(16).substr(-8), g = new Uint8Array(new Uint16Array([65279]).buffer)[0] === 254 ? (B) => B : (B) => B << 24 & 4278190080 | B << 8 & 16711680 | B >> 8 & 65280 | B >> 24 & 255, b = (B, L, W) => W ^ B & (L ^ W), _ = (B, L, W) => B & L | W & (B | L), v = (B) => (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10), E = (B) => (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7), m = (B) => (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3, A = (B) => (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
var x, k, I = function(B) {
  return function(L) {
    return new l();
  }().update(B).digest();
};
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
var C = { 0: { type: k.p2pkh, network: x.mainnet }, 111: { type: k.p2pkh, network: x.testnet }, 5: { type: k.p2sh, network: x.mainnet }, 196: { type: k.p2sh, network: x.testnet } }, z = function(B) {
  var L, W = B.substr(0, 2).toLowerCase();
  if (W === "bc" || W === "tb") return function(oe) {
    var pe;
    try {
      pe = oe.startsWith("bc1p") || oe.startsWith("tb1p") || oe.startsWith("bcrt1p") ? c.decode(oe) : a.decode(oe);
    } catch {
      throw new Error("Invalid address");
    }
    var ne = { bc: x.mainnet, tb: x.testnet, bcrt: x.regtest }[pe.prefix];
    if (ne === void 0) throw new Error("Invalid address");
    var ce = pe.words[0];
    if (ce < 0 || ce > 16) throw new Error("Invalid address");
    return { bech32: !0, network: ne, address: oe, type: a.fromWords(pe.words.slice(1)).length === 20 ? k.p2wpkh : ce === 1 ? k.p2tr : k.p2wsh };
  }(B);
  try {
    L = n(B);
  } catch {
    throw new Error("Invalid address");
  }
  var K = L.length;
  if (K !== 25) throw new Error("Invalid address");
  var J = L[0], V = L.slice(K - 4, K), re = L.slice(0, K - 4), ie = I(I(re)).slice(0, 4);
  if (V.some(function(oe, pe) {
    return oe !== ie[pe];
  })) throw new Error("Invalid address");
  if (!Object.keys(C).map(Number).includes(J)) throw new Error("Invalid address");
  return t(t({}, C[J]), { address: B, bech32: !1 });
}, O = function(B, L) {
  try {
    var W = z(B);
    return !L || L === W.network;
  } catch {
    return !1;
  }
}, src$2 = {}, bip32 = {}, crypto$2 = {}, hmac$2 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const L = _assert, W = utils$5;
  class K extends W.Hash {
    constructor(re, ie) {
      super(), this.finished = !1, this.destroyed = !1, (0, L.hash)(re);
      const oe = (0, W.toBytes)(ie);
      if (this.iHash = re.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const pe = this.blockLen, ne = new Uint8Array(pe);
      ne.set(oe.length > pe ? re.create().update(oe).digest() : oe);
      for (let ce = 0; ce < ne.length; ce++)
        ne[ce] ^= 54;
      this.iHash.update(ne), this.oHash = re.create();
      for (let ce = 0; ce < ne.length; ce++)
        ne[ce] ^= 106;
      this.oHash.update(ne), ne.fill(0);
    }
    update(re) {
      return (0, L.exists)(this), this.iHash.update(re), this;
    }
    digestInto(re) {
      (0, L.exists)(this), (0, L.bytes)(re, this.outputLen), this.finished = !0, this.iHash.digestInto(re), this.oHash.update(re), this.oHash.digestInto(re), this.destroy();
    }
    digest() {
      const re = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(re), re;
    }
    _cloneInto(re) {
      re || (re = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ie, iHash: oe, finished: pe, destroyed: ne, blockLen: ce, outputLen: Ce } = this;
      return re = re, re.finished = pe, re.destroyed = ne, re.blockLen = ce, re.outputLen = Ce, re.oHash = ie._cloneInto(re.oHash), re.iHash = oe._cloneInto(re.iHash), re;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = K;
  const J = (V, re, ie) => new K(V, re).update(ie).digest();
  B.hmac = J, B.hmac.create = (V, re) => new K(V, re);
})(hmac$2);
var sha512$2 = {}, _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: !0 });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = void 0;
_u64.fromBig = fromBig;
_u64.split = split;
_u64.add = add;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(B, L = !1) {
  return L ? { h: Number(B & U32_MASK64), l: Number(B >> _32n & U32_MASK64) } : { h: Number(B >> _32n & U32_MASK64) | 0, l: Number(B & U32_MASK64) | 0 };
}
function split(B, L = !1) {
  let W = new Uint32Array(B.length), K = new Uint32Array(B.length);
  for (let J = 0; J < B.length; J++) {
    const { h: V, l: re } = fromBig(B[J], L);
    [W[J], K[J]] = [V, re];
  }
  return [W, K];
}
const toBig = (B, L) => BigInt(B >>> 0) << _32n | BigInt(L >>> 0);
_u64.toBig = toBig;
const shrSH = (B, L, W) => B >>> W;
_u64.shrSH = shrSH;
const shrSL = (B, L, W) => B << 32 - W | L >>> W;
_u64.shrSL = shrSL;
const rotrSH = (B, L, W) => B >>> W | L << 32 - W;
_u64.rotrSH = rotrSH;
const rotrSL = (B, L, W) => B << 32 - W | L >>> W;
_u64.rotrSL = rotrSL;
const rotrBH = (B, L, W) => B << 64 - W | L >>> W - 32;
_u64.rotrBH = rotrBH;
const rotrBL = (B, L, W) => B >>> W - 32 | L << 64 - W;
_u64.rotrBL = rotrBL;
const rotr32H = (B, L) => L;
_u64.rotr32H = rotr32H;
const rotr32L = (B, L) => B;
_u64.rotr32L = rotr32L;
const rotlSH = (B, L, W) => B << W | L >>> 32 - W;
_u64.rotlSH = rotlSH;
const rotlSL = (B, L, W) => L << W | B >>> 32 - W;
_u64.rotlSL = rotlSL;
const rotlBH = (B, L, W) => L << W - 32 | B >>> 64 - W;
_u64.rotlBH = rotlBH;
const rotlBL = (B, L, W) => B << W - 32 | L >>> 64 - W;
_u64.rotlBL = rotlBL;
function add(B, L, W, K) {
  const J = (L >>> 0) + (K >>> 0);
  return { h: B + W + (J / 2 ** 32 | 0) | 0, l: J | 0 };
}
const add3L = (B, L, W) => (B >>> 0) + (L >>> 0) + (W >>> 0);
_u64.add3L = add3L;
const add3H = (B, L, W, K) => L + W + K + (B / 2 ** 32 | 0) | 0;
_u64.add3H = add3H;
const add4L = (B, L, W, K) => (B >>> 0) + (L >>> 0) + (W >>> 0) + (K >>> 0);
_u64.add4L = add4L;
const add4H = (B, L, W, K, J) => L + W + K + J + (B / 2 ** 32 | 0) | 0;
_u64.add4H = add4H;
const add5L = (B, L, W, K, J) => (B >>> 0) + (L >>> 0) + (W >>> 0) + (K >>> 0) + (J >>> 0);
_u64.add5L = add5L;
const add5H = (B, L, W, K, J, V) => L + W + K + J + V + (B / 2 ** 32 | 0) | 0;
_u64.add5H = add5H;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
_u64.default = u64;
Object.defineProperty(sha512$2, "__esModule", { value: !0 });
sha512$2.sha384 = sha512$2.sha512_256 = sha512$2.sha512_224 = sha512$2.sha512 = sha512$2.SHA384 = sha512$2.SHA512_256 = sha512$2.SHA512_224 = sha512$2.SHA512 = void 0;
const _md_js_1 = _md, _u64_js_1 = _u64, utils_js_1 = utils$5, [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((B) => BigInt(B))), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_js_1.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: L, Al: W, Bh: K, Bl: J, Ch: V, Cl: re, Dh: ie, Dl: oe, Eh: pe, El: ne, Fh: ce, Fl: Ce, Gh: Oe, Gl: st, Hh: at, Hl: lt } = this;
    return [L, W, K, J, V, re, ie, oe, pe, ne, ce, Ce, Oe, st, at, lt];
  }
  // prettier-ignore
  set(L, W, K, J, V, re, ie, oe, pe, ne, ce, Ce, Oe, st, at, lt) {
    this.Ah = L | 0, this.Al = W | 0, this.Bh = K | 0, this.Bl = J | 0, this.Ch = V | 0, this.Cl = re | 0, this.Dh = ie | 0, this.Dl = oe | 0, this.Eh = pe | 0, this.El = ne | 0, this.Fh = ce | 0, this.Fl = Ce | 0, this.Gh = Oe | 0, this.Gl = st | 0, this.Hh = at | 0, this.Hl = lt | 0;
  }
  process(L, W) {
    for (let yt = 0; yt < 16; yt++, W += 4)
      SHA512_W_H[yt] = L.getUint32(W), SHA512_W_L[yt] = L.getUint32(W += 4);
    for (let yt = 16; yt < 80; yt++) {
      const vt = SHA512_W_H[yt - 15] | 0, $t = SHA512_W_L[yt - 15] | 0, xt = _u64_js_1.default.rotrSH(vt, $t, 1) ^ _u64_js_1.default.rotrSH(vt, $t, 8) ^ _u64_js_1.default.shrSH(vt, $t, 7), Ct = _u64_js_1.default.rotrSL(vt, $t, 1) ^ _u64_js_1.default.rotrSL(vt, $t, 8) ^ _u64_js_1.default.shrSL(vt, $t, 7), Et = SHA512_W_H[yt - 2] | 0, St = SHA512_W_L[yt - 2] | 0, It = _u64_js_1.default.rotrSH(Et, St, 19) ^ _u64_js_1.default.rotrBH(Et, St, 61) ^ _u64_js_1.default.shrSH(Et, St, 6), Tt = _u64_js_1.default.rotrSL(Et, St, 19) ^ _u64_js_1.default.rotrBL(Et, St, 61) ^ _u64_js_1.default.shrSL(Et, St, 6), nt = _u64_js_1.default.add4L(Ct, Tt, SHA512_W_L[yt - 7], SHA512_W_L[yt - 16]), it = _u64_js_1.default.add4H(nt, xt, It, SHA512_W_H[yt - 7], SHA512_W_H[yt - 16]);
      SHA512_W_H[yt] = it | 0, SHA512_W_L[yt] = nt | 0;
    }
    let { Ah: K, Al: J, Bh: V, Bl: re, Ch: ie, Cl: oe, Dh: pe, Dl: ne, Eh: ce, El: Ce, Fh: Oe, Fl: st, Gh: at, Gl: lt, Hh: pt, Hl: ht } = this;
    for (let yt = 0; yt < 80; yt++) {
      const vt = _u64_js_1.default.rotrSH(ce, Ce, 14) ^ _u64_js_1.default.rotrSH(ce, Ce, 18) ^ _u64_js_1.default.rotrBH(ce, Ce, 41), $t = _u64_js_1.default.rotrSL(ce, Ce, 14) ^ _u64_js_1.default.rotrSL(ce, Ce, 18) ^ _u64_js_1.default.rotrBL(ce, Ce, 41), xt = ce & Oe ^ ~ce & at, Ct = Ce & st ^ ~Ce & lt, Et = _u64_js_1.default.add5L(ht, $t, Ct, SHA512_Kl[yt], SHA512_W_L[yt]), St = _u64_js_1.default.add5H(Et, pt, vt, xt, SHA512_Kh[yt], SHA512_W_H[yt]), It = Et | 0, Tt = _u64_js_1.default.rotrSH(K, J, 28) ^ _u64_js_1.default.rotrBH(K, J, 34) ^ _u64_js_1.default.rotrBH(K, J, 39), nt = _u64_js_1.default.rotrSL(K, J, 28) ^ _u64_js_1.default.rotrBL(K, J, 34) ^ _u64_js_1.default.rotrBL(K, J, 39), it = K & V ^ K & ie ^ V & ie, ke = J & re ^ J & oe ^ re & oe;
      pt = at | 0, ht = lt | 0, at = Oe | 0, lt = st | 0, Oe = ce | 0, st = Ce | 0, { h: ce, l: Ce } = _u64_js_1.default.add(pe | 0, ne | 0, St | 0, It | 0), pe = ie | 0, ne = oe | 0, ie = V | 0, oe = re | 0, V = K | 0, re = J | 0;
      const rt = _u64_js_1.default.add3L(It, nt, ke);
      K = _u64_js_1.default.add3H(rt, St, Tt, it), J = rt | 0;
    }
    ({ h: K, l: J } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, K | 0, J | 0)), { h: V, l: re } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, V | 0, re | 0), { h: ie, l: oe } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, ie | 0, oe | 0), { h: pe, l: ne } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, pe | 0, ne | 0), { h: ce, l: Ce } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, ce | 0, Ce | 0), { h: Oe, l: st } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Oe | 0, st | 0), { h: at, l: lt } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, at | 0, lt | 0), { h: pt, l: ht } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, pt | 0, ht | 0), this.set(K, J, V, re, ie, oe, pe, ne, ce, Ce, Oe, st, at, lt, pt, ht);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
sha512$2.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
sha512$2.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
sha512$2.SHA512_256 = SHA512_256;
class SHA384 extends SHA512 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
sha512$2.SHA384 = SHA384;
sha512$2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
sha512$2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
sha512$2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
sha512$2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.hmacSHA512 = crypto$2.hash160 = void 0;
const hmac_1$1 = hmac$2, ripemd160_1 = ripemd160$1, sha256_1$5 = sha256$5, sha512_1 = sha512$2;
function hash160(B) {
  const L = (0, sha256_1$5.sha256)(Uint8Array.from(B));
  return Buffer$2.from((0, ripemd160_1.ripemd160)(L));
}
crypto$2.hash160 = hash160;
function hmacSHA512(B, L) {
  return Buffer$2.from((0, hmac_1$1.hmac)(sha512_1.sha512, B, L));
}
crypto$2.hmacSHA512 = hmacSHA512;
var testecc$1 = {};
Object.defineProperty(testecc$1, "__esModule", { value: !0 });
testecc$1.testEcc = void 0;
const h$1 = (B) => Buffer$2.from(B, "hex");
function testEcc$1(B) {
  if (assert$1(B.isPoint(h$1("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$1(!B.isPoint(h$1("030000000000000000000000000000000000000000000000000000000000000005"))), assert$1(B.isPrivate(h$1("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$1(B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert$1(!B.isPrivate(h$1("0000000000000000000000000000000000000000000000000000000000000000"))), assert$1(!B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), assert$1(!B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), assert$1(Buffer$2.from(B.pointFromScalar(h$1("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h$1("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99"))), B.xOnlyPointAddTweak) {
    assert$1(B.xOnlyPointAddTweak(h$1("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let L = B.xOnlyPointAddTweak(h$1("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h$1("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    assert$1(Buffer$2.from(L.xOnlyPubkey).equals(h$1("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) && L.parity === 1), L = B.xOnlyPointAddTweak(h$1("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h$1("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  assert$1(Buffer$2.from(B.pointAddScalar(h$1("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("0000000000000000000000000000000000000000000000000000000000000003"))).equals(h$1("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5"))), assert$1(Buffer$2.from(B.privateAdd(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h$1("0000000000000000000000000000000000000000000000000000000000000002"))).equals(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), B.privateNegate && (assert$1(Buffer$2.from(B.privateNegate(h$1("0000000000000000000000000000000000000000000000000000000000000001"))).equals(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert$1(Buffer$2.from(B.privateNegate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"))).equals(h$1("0000000000000000000000000000000000000000000000000000000000000003"))), assert$1(Buffer$2.from(B.privateNegate(h$1("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h$1("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")))), assert$1(Buffer$2.from(B.sign(h$1("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))).equals(h$1("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), assert$1(B.verify(h$1("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h$1("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), B.signSchnorr && assert$1(Buffer$2.from(B.signSchnorr(h$1("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h$1("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h$1("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906"))).equals(h$1("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"))), B.verifySchnorr && assert$1(B.verifySchnorr(h$1("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h$1("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h$1("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
testecc$1.testEcc = testEcc$1;
function assert$1(B) {
  if (!B)
    throw new Error("ecc library invalid");
}
var lib$2 = {};
(function(B) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bytes = B.stringToBytes = B.str = B.bytesToString = B.hex = B.utf8 = B.bech32m = B.bech32 = B.base58check = B.createBase58check = B.base58xmr = B.base58xrp = B.base58flickr = B.base58 = B.base64urlnopad = B.base64url = B.base64nopad = B.base64 = B.base32crockford = B.base32hexnopad = B.base32hex = B.base32nopad = B.base32 = B.base16 = B.utils = void 0, B.assertNumber = L;
  // @__NO_SIDE_EFFECTS__
  function L(nt) {
    if (!Number.isSafeInteger(nt))
      throw new Error(`Wrong integer: ${nt}`);
  }
  function W(nt) {
    return nt instanceof Uint8Array || nt != null && typeof nt == "object" && nt.constructor.name === "Uint8Array";
  }
  // @__NO_SIDE_EFFECTS__
  function K(...nt) {
    const it = (ft) => ft, ke = (ft, ct) => (bt) => ft(ct(bt)), rt = nt.map((ft) => ft.encode).reduceRight(ke, it), ot = nt.map((ft) => ft.decode).reduce(ke, it);
    return { encode: rt, decode: ot };
  }
  // @__NO_SIDE_EFFECTS__
  function J(nt) {
    return {
      encode: (it) => {
        if (!Array.isArray(it) || it.length && typeof it[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return it.map((ke) => {
          if (ke < 0 || ke >= nt.length)
            throw new Error(`Digit index outside alphabet: ${ke} (alphabet: ${nt.length})`);
          return nt[ke];
        });
      },
      decode: (it) => {
        if (!Array.isArray(it) || it.length && typeof it[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return it.map((ke) => {
          if (typeof ke != "string")
            throw new Error(`alphabet.decode: not string element=${ke}`);
          const rt = nt.indexOf(ke);
          if (rt === -1)
            throw new Error(`Unknown letter: "${ke}". Allowed: ${nt}`);
          return rt;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function V(nt = "") {
    if (typeof nt != "string")
      throw new Error("join separator should be string");
    return {
      encode: (it) => {
        if (!Array.isArray(it) || it.length && typeof it[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let ke of it)
          if (typeof ke != "string")
            throw new Error(`join.encode: non-string input=${ke}`);
        return it.join(nt);
      },
      decode: (it) => {
        if (typeof it != "string")
          throw new Error("join.decode input should be string");
        return it.split(nt);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function re(nt, it = "=") {
    if (typeof it != "string")
      throw new Error("padding chr should be string");
    return {
      encode(ke) {
        if (!Array.isArray(ke) || ke.length && typeof ke[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let rt of ke)
          if (typeof rt != "string")
            throw new Error(`padding.encode: non-string input=${rt}`);
        for (; ke.length * nt % 8; )
          ke.push(it);
        return ke;
      },
      decode(ke) {
        if (!Array.isArray(ke) || ke.length && typeof ke[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let ot of ke)
          if (typeof ot != "string")
            throw new Error(`padding.decode: non-string input=${ot}`);
        let rt = ke.length;
        if (rt * nt % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; rt > 0 && ke[rt - 1] === it; rt--)
          if (!((rt - 1) * nt % 8))
            throw new Error("Invalid padding: string has too much padding");
        return ke.slice(0, rt);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function ie(nt) {
    if (typeof nt != "function")
      throw new Error("normalize fn should be function");
    return { encode: (it) => it, decode: (it) => nt(it) };
  }
  // @__NO_SIDE_EFFECTS__
  function oe(nt, it, ke) {
    if (it < 2)
      throw new Error(`convertRadix: wrong from=${it}, base cannot be less than 2`);
    if (ke < 2)
      throw new Error(`convertRadix: wrong to=${ke}, base cannot be less than 2`);
    if (!Array.isArray(nt))
      throw new Error("convertRadix: data should be array");
    if (!nt.length)
      return [];
    let rt = 0;
    const ot = [], ft = Array.from(nt);
    for (ft.forEach((ct) => {
      if (ct < 0 || ct >= it)
        throw new Error(`Wrong integer: ${ct}`);
    }); ; ) {
      let ct = 0, bt = !0;
      for (let ut = rt; ut < ft.length; ut++) {
        const gt = ft[ut], dt = it * ct + gt;
        if (!Number.isSafeInteger(dt) || it * ct / it !== ct || dt - gt !== it * ct)
          throw new Error("convertRadix: carry overflow");
        ct = dt % ke;
        const wt = Math.floor(dt / ke);
        if (ft[ut] = wt, !Number.isSafeInteger(wt) || wt * ke + ct !== dt)
          throw new Error("convertRadix: carry overflow");
        if (bt)
          wt ? bt = !1 : rt = ut;
        else continue;
      }
      if (ot.push(ct), bt)
        break;
    }
    for (let ct = 0; ct < nt.length - 1 && nt[ct] === 0; ct++)
      ot.push(0);
    return ot.reverse();
  }
  const pe = /* @__NO_SIDE_EFFECTS__ */ (nt, it) => it ? /* @__PURE__ */ pe(it, nt % it) : nt, ne = /* @__NO_SIDE_EFFECTS__ */ (nt, it) => nt + (it - /* @__PURE__ */ pe(nt, it));
  // @__NO_SIDE_EFFECTS__
  function ce(nt, it, ke, rt) {
    if (!Array.isArray(nt))
      throw new Error("convertRadix2: data should be array");
    if (it <= 0 || it > 32)
      throw new Error(`convertRadix2: wrong from=${it}`);
    if (ke <= 0 || ke > 32)
      throw new Error(`convertRadix2: wrong to=${ke}`);
    if (/* @__PURE__ */ ne(it, ke) > 32)
      throw new Error(`convertRadix2: carry overflow from=${it} to=${ke} carryBits=${/* @__PURE__ */ ne(it, ke)}`);
    let ot = 0, ft = 0;
    const ct = 2 ** ke - 1, bt = [];
    for (const ut of nt) {
      if (ut >= 2 ** it)
        throw new Error(`convertRadix2: invalid data word=${ut} from=${it}`);
      if (ot = ot << it | ut, ft + it > 32)
        throw new Error(`convertRadix2: carry overflow pos=${ft} from=${it}`);
      for (ft += it; ft >= ke; ft -= ke)
        bt.push((ot >> ft - ke & ct) >>> 0);
      ot &= 2 ** ft - 1;
    }
    if (ot = ot << ke - ft & ct, !rt && ft >= it)
      throw new Error("Excess padding");
    if (!rt && ot)
      throw new Error(`Non-zero padding: ${ot}`);
    return rt && ft > 0 && bt.push(ot >>> 0), bt;
  }
  // @__NO_SIDE_EFFECTS__
  function Ce(nt) {
    return {
      encode: (it) => {
        if (!W(it))
          throw new Error("radix.encode input should be Uint8Array");
        return /* @__PURE__ */ oe(Array.from(it), 2 ** 8, nt);
      },
      decode: (it) => {
        if (!Array.isArray(it) || it.length && typeof it[0] != "number")
          throw new Error("radix.decode input should be array of numbers");
        return Uint8Array.from(/* @__PURE__ */ oe(it, nt, 2 ** 8));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function Oe(nt, it = !1) {
    if (nt <= 0 || nt > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ ne(8, nt) > 32 || /* @__PURE__ */ ne(nt, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (ke) => {
        if (!W(ke))
          throw new Error("radix2.encode input should be Uint8Array");
        return /* @__PURE__ */ ce(Array.from(ke), 8, nt, !it);
      },
      decode: (ke) => {
        if (!Array.isArray(ke) || ke.length && typeof ke[0] != "number")
          throw new Error("radix2.decode input should be array of numbers");
        return Uint8Array.from(/* @__PURE__ */ ce(ke, nt, 8, it));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function st(nt) {
    if (typeof nt != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...it) {
      try {
        return nt.apply(null, it);
      } catch {
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function at(nt, it) {
    if (typeof it != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(ke) {
        if (!W(ke))
          throw new Error("checksum.encode: input should be Uint8Array");
        const rt = it(ke).slice(0, nt), ot = new Uint8Array(ke.length + nt);
        return ot.set(ke), ot.set(rt, ke.length), ot;
      },
      decode(ke) {
        if (!W(ke))
          throw new Error("checksum.decode: input should be Uint8Array");
        const rt = ke.slice(0, -nt), ot = it(rt).slice(0, nt), ft = ke.slice(-nt);
        for (let ct = 0; ct < nt; ct++)
          if (ot[ct] !== ft[ct])
            throw new Error("Invalid checksum");
        return rt;
      }
    };
  }
  B.utils = {
    alphabet: J,
    chain: K,
    checksum: at,
    convertRadix: oe,
    convertRadix2: ce,
    radix: Ce,
    radix2: Oe,
    join: V,
    padding: re
  }, B.base16 = /* @__PURE__ */ K(/* @__PURE__ */ Oe(4), /* @__PURE__ */ J("0123456789ABCDEF"), /* @__PURE__ */ V("")), B.base32 = /* @__PURE__ */ K(/* @__PURE__ */ Oe(5), /* @__PURE__ */ J("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ re(5), /* @__PURE__ */ V("")), B.base32nopad = /* @__PURE__ */ K(/* @__PURE__ */ Oe(5), /* @__PURE__ */ J("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ V("")), B.base32hex = /* @__PURE__ */ K(/* @__PURE__ */ Oe(5), /* @__PURE__ */ J("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ re(5), /* @__PURE__ */ V("")), B.base32hexnopad = /* @__PURE__ */ K(/* @__PURE__ */ Oe(5), /* @__PURE__ */ J("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ V("")), B.base32crockford = /* @__PURE__ */ K(/* @__PURE__ */ Oe(5), /* @__PURE__ */ J("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ V(""), /* @__PURE__ */ ie((nt) => nt.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), B.base64 = /* @__PURE__ */ K(/* @__PURE__ */ Oe(6), /* @__PURE__ */ J("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ re(6), /* @__PURE__ */ V("")), B.base64nopad = /* @__PURE__ */ K(/* @__PURE__ */ Oe(6), /* @__PURE__ */ J("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ V("")), B.base64url = /* @__PURE__ */ K(/* @__PURE__ */ Oe(6), /* @__PURE__ */ J("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ re(6), /* @__PURE__ */ V("")), B.base64urlnopad = /* @__PURE__ */ K(/* @__PURE__ */ Oe(6), /* @__PURE__ */ J("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ V(""));
  const lt = (nt) => /* @__PURE__ */ K(/* @__PURE__ */ Ce(58), /* @__PURE__ */ J(nt), /* @__PURE__ */ V(""));
  B.base58 = lt("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), B.base58flickr = lt("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), B.base58xrp = lt("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const pt = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  B.base58xmr = {
    encode(nt) {
      let it = "";
      for (let ke = 0; ke < nt.length; ke += 8) {
        const rt = nt.subarray(ke, ke + 8);
        it += B.base58.encode(rt).padStart(pt[rt.length], "1");
      }
      return it;
    },
    decode(nt) {
      let it = [];
      for (let ke = 0; ke < nt.length; ke += 11) {
        const rt = nt.slice(ke, ke + 11), ot = pt.indexOf(rt.length), ft = B.base58.decode(rt);
        for (let ct = 0; ct < ft.length - ot; ct++)
          if (ft[ct] !== 0)
            throw new Error("base58xmr: wrong padding");
        it = it.concat(Array.from(ft.slice(ft.length - ot)));
      }
      return Uint8Array.from(it);
    }
  };
  const ht = (nt) => /* @__PURE__ */ K(/* @__PURE__ */ at(4, (it) => nt(nt(it))), B.base58);
  B.createBase58check = ht, B.base58check = B.createBase58check;
  const yt = /* @__PURE__ */ K(/* @__PURE__ */ J("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ V("")), vt = [996825010, 642813549, 513874426, 1027748829, 705979059];
  // @__NO_SIDE_EFFECTS__
  function $t(nt) {
    const it = nt >> 25;
    let ke = (nt & 33554431) << 5;
    for (let rt = 0; rt < vt.length; rt++)
      (it >> rt & 1) === 1 && (ke ^= vt[rt]);
    return ke;
  }
  // @__NO_SIDE_EFFECTS__
  function xt(nt, it, ke = 1) {
    const rt = nt.length;
    let ot = 1;
    for (let ft = 0; ft < rt; ft++) {
      const ct = nt.charCodeAt(ft);
      if (ct < 33 || ct > 126)
        throw new Error(`Invalid prefix (${nt})`);
      ot = /* @__PURE__ */ $t(ot) ^ ct >> 5;
    }
    ot = /* @__PURE__ */ $t(ot);
    for (let ft = 0; ft < rt; ft++)
      ot = /* @__PURE__ */ $t(ot) ^ nt.charCodeAt(ft) & 31;
    for (let ft of it)
      ot = /* @__PURE__ */ $t(ot) ^ ft;
    for (let ft = 0; ft < 6; ft++)
      ot = /* @__PURE__ */ $t(ot);
    return ot ^= ke, yt.encode(/* @__PURE__ */ ce([ot % 2 ** 30], 30, 5, !1));
  }
  // @__NO_SIDE_EFFECTS__
  function Ct(nt) {
    const it = nt === "bech32" ? 1 : 734539939, ke = /* @__PURE__ */ Oe(5), rt = ke.decode, ot = ke.encode, ft = /* @__PURE__ */ st(rt);
    function ct(dt, wt, Ft = 90) {
      if (typeof dt != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof dt}`);
      if (!Array.isArray(wt) || wt.length && typeof wt[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof wt}`);
      if (dt.length === 0)
        throw new TypeError(`Invalid prefix length ${dt.length}`);
      const jt = dt.length + 7 + wt.length;
      if (Ft !== !1 && jt > Ft)
        throw new TypeError(`Length ${jt} exceeds limit ${Ft}`);
      const Nt = dt.toLowerCase(), Bt = /* @__PURE__ */ xt(Nt, wt, it);
      return `${Nt}1${yt.encode(wt)}${Bt}`;
    }
    function bt(dt, wt = 90) {
      if (typeof dt != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof dt}`);
      if (dt.length < 8 || wt !== !1 && dt.length > wt)
        throw new TypeError(`Wrong string length: ${dt.length} (${dt}). Expected (8..${wt})`);
      const Ft = dt.toLowerCase();
      if (dt !== Ft && dt !== dt.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      const jt = Ft.lastIndexOf("1");
      if (jt === 0 || jt === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const Nt = Ft.slice(0, jt), Bt = Ft.slice(jt + 1);
      if (Bt.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const Rt = yt.decode(Bt).slice(0, -6), Ut = /* @__PURE__ */ xt(Nt, Rt, it);
      if (!Bt.endsWith(Ut))
        throw new Error(`Invalid checksum in ${dt}: expected "${Ut}"`);
      return { prefix: Nt, words: Rt };
    }
    const ut = /* @__PURE__ */ st(bt);
    function gt(dt) {
      const { prefix: wt, words: Ft } = bt(dt, !1);
      return { prefix: wt, words: Ft, bytes: rt(Ft) };
    }
    return { encode: ct, decode: bt, decodeToBytes: gt, decodeUnsafe: ut, fromWords: rt, fromWordsUnsafe: ft, toWords: ot };
  }
  B.bech32 = /* @__PURE__ */ Ct("bech32"), B.bech32m = /* @__PURE__ */ Ct("bech32m"), B.utf8 = {
    encode: (nt) => new TextDecoder().decode(nt),
    decode: (nt) => new TextEncoder().encode(nt)
  }, B.hex = /* @__PURE__ */ K(/* @__PURE__ */ Oe(4), /* @__PURE__ */ J("0123456789abcdef"), /* @__PURE__ */ V(""), /* @__PURE__ */ ie((nt) => {
    if (typeof nt != "string" || nt.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof nt} with length ${nt.length}`);
    return nt.toLowerCase();
  }));
  const Et = {
    utf8: B.utf8,
    hex: B.hex,
    base16: B.base16,
    base32: B.base32,
    base64: B.base64,
    base64url: B.base64url,
    base58: B.base58,
    base58xmr: B.base58xmr
  }, St = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", It = (nt, it) => {
    if (typeof nt != "string" || !Et.hasOwnProperty(nt))
      throw new TypeError(St);
    if (!W(it))
      throw new TypeError("bytesToString() expects Uint8Array");
    return Et[nt].encode(it);
  };
  B.bytesToString = It, B.str = B.bytesToString;
  const Tt = (nt, it) => {
    if (!Et.hasOwnProperty(nt))
      throw new TypeError(St);
    if (typeof it != "string")
      throw new TypeError("stringToBytes() expects string");
    return Et[nt].decode(it);
  };
  B.stringToBytes = Tt, B.bytes = B.stringToBytes;
})(lib$2);
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(L, W) {
    W && (L.super_ = W, L.prototype = Object.create(W.prototype, {
      constructor: {
        value: L,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(L, W) {
    if (W) {
      L.super_ = W;
      var K = function() {
      };
      K.prototype = W.prototype, L.prototype = new K(), L.prototype.constructor = L;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var B = typeof Reflect == "object" ? Reflect : null, L = B && typeof B.apply == "function" ? B.apply : function($t, xt, Ct) {
    return Function.prototype.apply.call($t, xt, Ct);
  }, W;
  B && typeof B.ownKeys == "function" ? W = B.ownKeys : Object.getOwnPropertySymbols ? W = function($t) {
    return Object.getOwnPropertyNames($t).concat(Object.getOwnPropertySymbols($t));
  } : W = function($t) {
    return Object.getOwnPropertyNames($t);
  };
  function K(vt) {
    console && console.warn && console.warn(vt);
  }
  var J = Number.isNaN || function($t) {
    return $t !== $t;
  };
  function V() {
    V.init.call(this);
  }
  events.exports = V, events.exports.once = pt, V.EventEmitter = V, V.prototype._events = void 0, V.prototype._eventsCount = 0, V.prototype._maxListeners = void 0;
  var re = 10;
  function ie(vt) {
    if (typeof vt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof vt);
  }
  Object.defineProperty(V, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return re;
    },
    set: function(vt) {
      if (typeof vt != "number" || vt < 0 || J(vt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + vt + ".");
      re = vt;
    }
  }), V.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, V.prototype.setMaxListeners = function($t) {
    if (typeof $t != "number" || $t < 0 || J($t))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + $t + ".");
    return this._maxListeners = $t, this;
  };
  function oe(vt) {
    return vt._maxListeners === void 0 ? V.defaultMaxListeners : vt._maxListeners;
  }
  V.prototype.getMaxListeners = function() {
    return oe(this);
  }, V.prototype.emit = function($t) {
    for (var xt = [], Ct = 1; Ct < arguments.length; Ct++) xt.push(arguments[Ct]);
    var Et = $t === "error", St = this._events;
    if (St !== void 0)
      Et = Et && St.error === void 0;
    else if (!Et)
      return !1;
    if (Et) {
      var It;
      if (xt.length > 0 && (It = xt[0]), It instanceof Error)
        throw It;
      var Tt = new Error("Unhandled error." + (It ? " (" + It.message + ")" : ""));
      throw Tt.context = It, Tt;
    }
    var nt = St[$t];
    if (nt === void 0)
      return !1;
    if (typeof nt == "function")
      L(nt, this, xt);
    else
      for (var it = nt.length, ke = st(nt, it), Ct = 0; Ct < it; ++Ct)
        L(ke[Ct], this, xt);
    return !0;
  };
  function pe(vt, $t, xt, Ct) {
    var Et, St, It;
    if (ie(xt), St = vt._events, St === void 0 ? (St = vt._events = /* @__PURE__ */ Object.create(null), vt._eventsCount = 0) : (St.newListener !== void 0 && (vt.emit(
      "newListener",
      $t,
      xt.listener ? xt.listener : xt
    ), St = vt._events), It = St[$t]), It === void 0)
      It = St[$t] = xt, ++vt._eventsCount;
    else if (typeof It == "function" ? It = St[$t] = Ct ? [xt, It] : [It, xt] : Ct ? It.unshift(xt) : It.push(xt), Et = oe(vt), Et > 0 && It.length > Et && !It.warned) {
      It.warned = !0;
      var Tt = new Error("Possible EventEmitter memory leak detected. " + It.length + " " + String($t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Tt.name = "MaxListenersExceededWarning", Tt.emitter = vt, Tt.type = $t, Tt.count = It.length, K(Tt);
    }
    return vt;
  }
  V.prototype.addListener = function($t, xt) {
    return pe(this, $t, xt, !1);
  }, V.prototype.on = V.prototype.addListener, V.prototype.prependListener = function($t, xt) {
    return pe(this, $t, xt, !0);
  };
  function ne() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function ce(vt, $t, xt) {
    var Ct = { fired: !1, wrapFn: void 0, target: vt, type: $t, listener: xt }, Et = ne.bind(Ct);
    return Et.listener = xt, Ct.wrapFn = Et, Et;
  }
  V.prototype.once = function($t, xt) {
    return ie(xt), this.on($t, ce(this, $t, xt)), this;
  }, V.prototype.prependOnceListener = function($t, xt) {
    return ie(xt), this.prependListener($t, ce(this, $t, xt)), this;
  }, V.prototype.removeListener = function($t, xt) {
    var Ct, Et, St, It, Tt;
    if (ie(xt), Et = this._events, Et === void 0)
      return this;
    if (Ct = Et[$t], Ct === void 0)
      return this;
    if (Ct === xt || Ct.listener === xt)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Et[$t], Et.removeListener && this.emit("removeListener", $t, Ct.listener || xt));
    else if (typeof Ct != "function") {
      for (St = -1, It = Ct.length - 1; It >= 0; It--)
        if (Ct[It] === xt || Ct[It].listener === xt) {
          Tt = Ct[It].listener, St = It;
          break;
        }
      if (St < 0)
        return this;
      St === 0 ? Ct.shift() : at(Ct, St), Ct.length === 1 && (Et[$t] = Ct[0]), Et.removeListener !== void 0 && this.emit("removeListener", $t, Tt || xt);
    }
    return this;
  }, V.prototype.off = V.prototype.removeListener, V.prototype.removeAllListeners = function($t) {
    var xt, Ct, Et;
    if (Ct = this._events, Ct === void 0)
      return this;
    if (Ct.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Ct[$t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Ct[$t]), this;
    if (arguments.length === 0) {
      var St = Object.keys(Ct), It;
      for (Et = 0; Et < St.length; ++Et)
        It = St[Et], It !== "removeListener" && this.removeAllListeners(It);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (xt = Ct[$t], typeof xt == "function")
      this.removeListener($t, xt);
    else if (xt !== void 0)
      for (Et = xt.length - 1; Et >= 0; Et--)
        this.removeListener($t, xt[Et]);
    return this;
  };
  function Ce(vt, $t, xt) {
    var Ct = vt._events;
    if (Ct === void 0)
      return [];
    var Et = Ct[$t];
    return Et === void 0 ? [] : typeof Et == "function" ? xt ? [Et.listener || Et] : [Et] : xt ? lt(Et) : st(Et, Et.length);
  }
  V.prototype.listeners = function($t) {
    return Ce(this, $t, !0);
  }, V.prototype.rawListeners = function($t) {
    return Ce(this, $t, !1);
  }, V.listenerCount = function(vt, $t) {
    return typeof vt.listenerCount == "function" ? vt.listenerCount($t) : Oe.call(vt, $t);
  }, V.prototype.listenerCount = Oe;
  function Oe(vt) {
    var $t = this._events;
    if ($t !== void 0) {
      var xt = $t[vt];
      if (typeof xt == "function")
        return 1;
      if (xt !== void 0)
        return xt.length;
    }
    return 0;
  }
  V.prototype.eventNames = function() {
    return this._eventsCount > 0 ? W(this._events) : [];
  };
  function st(vt, $t) {
    for (var xt = new Array($t), Ct = 0; Ct < $t; ++Ct)
      xt[Ct] = vt[Ct];
    return xt;
  }
  function at(vt, $t) {
    for (; $t + 1 < vt.length; $t++)
      vt[$t] = vt[$t + 1];
    vt.pop();
  }
  function lt(vt) {
    for (var $t = new Array(vt.length), xt = 0; xt < $t.length; ++xt)
      $t[xt] = vt[xt].listener || vt[xt];
    return $t;
  }
  function pt(vt, $t) {
    return new Promise(function(xt, Ct) {
      function Et(It) {
        vt.removeListener($t, St), Ct(It);
      }
      function St() {
        typeof vt.removeListener == "function" && vt.removeListener("error", Et), xt([].slice.call(arguments));
      }
      yt(vt, $t, St, { once: !0 }), $t !== "error" && ht(vt, Et, { once: !0 });
    });
  }
  function ht(vt, $t, xt) {
    typeof vt.on == "function" && yt(vt, "error", $t, xt);
  }
  function yt(vt, $t, xt, Ct) {
    if (typeof vt.on == "function")
      Ct.once ? vt.once($t, xt) : vt.on($t, xt);
    else if (typeof vt.addEventListener == "function")
      vt.addEventListener($t, function Et(St) {
        Ct.once && vt.removeEventListener($t, Et), xt(St);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof vt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$2 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var L = {}, W = Symbol("test"), K = Object(W);
    if (typeof W == "string" || Object.prototype.toString.call(W) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]")
      return !1;
    var J = 42;
    L[W] = J;
    for (W in L)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(L).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(L).length !== 0)
      return !1;
    var V = Object.getOwnPropertySymbols(L);
    if (V.length !== 1 || V[0] !== W || !Object.prototype.propertyIsEnumerable.call(L, W))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var re = Object.getOwnPropertyDescriptor(L, W);
      if (re.value !== J || re.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var B = requireShams$1();
  return shams = function() {
    return B() && !!Symbol.toStringTag;
  }, shams;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, L = requireShams$1();
  return hasSymbols = function() {
    return typeof B != "function" || typeof Symbol != "function" || typeof B("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : L();
  }, hasSymbols;
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var B = {
    __proto__: null,
    foo: {}
  }, L = Object;
  return hasProto = function() {
    return { __proto__: B }.foo === B.foo && !(B instanceof L);
  }, hasProto;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var B = "Function.prototype.bind called on incompatible ", L = Object.prototype.toString, W = Math.max, K = "[object Function]", J = function(oe, pe) {
    for (var ne = [], ce = 0; ce < oe.length; ce += 1)
      ne[ce] = oe[ce];
    for (var Ce = 0; Ce < pe.length; Ce += 1)
      ne[Ce + oe.length] = pe[Ce];
    return ne;
  }, V = function(oe, pe) {
    for (var ne = [], ce = pe, Ce = 0; ce < oe.length; ce += 1, Ce += 1)
      ne[Ce] = oe[ce];
    return ne;
  }, re = function(ie, oe) {
    for (var pe = "", ne = 0; ne < ie.length; ne += 1)
      pe += ie[ne], ne + 1 < ie.length && (pe += oe);
    return pe;
  };
  return implementation = function(oe) {
    var pe = this;
    if (typeof pe != "function" || L.apply(pe) !== K)
      throw new TypeError(B + pe);
    for (var ne = V(arguments, 1), ce, Ce = function() {
      if (this instanceof ce) {
        var pt = pe.apply(
          this,
          J(ne, arguments)
        );
        return Object(pt) === pt ? pt : this;
      }
      return pe.apply(
        oe,
        J(ne, arguments)
      );
    }, Oe = W(0, pe.length - ne.length), st = [], at = 0; at < Oe; at++)
      st[at] = "$" + at;
    if (ce = Function("binder", "return function (" + re(st, ",") + "){ return binder.apply(this,arguments); }")(Ce), pe.prototype) {
      var lt = function() {
      };
      lt.prototype = pe.prototype, ce.prototype = new lt(), lt.prototype = null;
    }
    return ce;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var B = requireImplementation();
  return functionBind = Function.prototype.bind || B, functionBind;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var B = Function.prototype.call, L = Object.prototype.hasOwnProperty, W = requireFunctionBind();
  return hasown = W.call(B, L), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var B, L = requireEsErrors(), W = require_eval(), K = requireRange(), J = requireRef(), V = requireSyntax(), re = requireType(), ie = requireUri(), oe = Function, pe = function(ft) {
    try {
      return oe('"use strict"; return (' + ft + ").constructor;")();
    } catch {
    }
  }, ne = Object.getOwnPropertyDescriptor;
  if (ne)
    try {
      ne({}, "");
    } catch {
      ne = null;
    }
  var ce = function() {
    throw new re();
  }, Ce = ne ? function() {
    try {
      return arguments.callee, ce;
    } catch {
      try {
        return ne(arguments, "callee").get;
      } catch {
        return ce;
      }
    }
  }() : ce, Oe = requireHasSymbols()(), st = requireHasProto()(), at = Object.getPrototypeOf || (st ? function(ft) {
    return ft.__proto__;
  } : null), lt = {}, pt = typeof Uint8Array > "u" || !at ? B : at(Uint8Array), ht = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? B : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? B : ArrayBuffer,
    "%ArrayIteratorPrototype%": Oe && at ? at([][Symbol.iterator]()) : B,
    "%AsyncFromSyncIteratorPrototype%": B,
    "%AsyncFunction%": lt,
    "%AsyncGenerator%": lt,
    "%AsyncGeneratorFunction%": lt,
    "%AsyncIteratorPrototype%": lt,
    "%Atomics%": typeof Atomics > "u" ? B : Atomics,
    "%BigInt%": typeof BigInt > "u" ? B : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? B : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? B : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? B : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": L,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": W,
    "%Float32Array%": typeof Float32Array > "u" ? B : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? B : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? B : FinalizationRegistry,
    "%Function%": oe,
    "%GeneratorFunction%": lt,
    "%Int8Array%": typeof Int8Array > "u" ? B : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? B : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? B : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Oe && at ? at(at([][Symbol.iterator]())) : B,
    "%JSON%": typeof JSON == "object" ? JSON : B,
    "%Map%": typeof Map > "u" ? B : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Oe || !at ? B : at((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? B : Promise,
    "%Proxy%": typeof Proxy > "u" ? B : Proxy,
    "%RangeError%": K,
    "%ReferenceError%": J,
    "%Reflect%": typeof Reflect > "u" ? B : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? B : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Oe || !at ? B : at((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? B : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Oe && at ? at(""[Symbol.iterator]()) : B,
    "%Symbol%": Oe ? Symbol : B,
    "%SyntaxError%": V,
    "%ThrowTypeError%": Ce,
    "%TypedArray%": pt,
    "%TypeError%": re,
    "%Uint8Array%": typeof Uint8Array > "u" ? B : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? B : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? B : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? B : Uint32Array,
    "%URIError%": ie,
    "%WeakMap%": typeof WeakMap > "u" ? B : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? B : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? B : WeakSet
  };
  if (at)
    try {
      null.error;
    } catch (ft) {
      var yt = at(at(ft));
      ht["%Error.prototype%"] = yt;
    }
  var vt = function ft(ct) {
    var bt;
    if (ct === "%AsyncFunction%")
      bt = pe("async function () {}");
    else if (ct === "%GeneratorFunction%")
      bt = pe("function* () {}");
    else if (ct === "%AsyncGeneratorFunction%")
      bt = pe("async function* () {}");
    else if (ct === "%AsyncGenerator%") {
      var ut = ft("%AsyncGeneratorFunction%");
      ut && (bt = ut.prototype);
    } else if (ct === "%AsyncIteratorPrototype%") {
      var gt = ft("%AsyncGenerator%");
      gt && at && (bt = at(gt.prototype));
    }
    return ht[ct] = bt, bt;
  }, $t = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, xt = requireFunctionBind(), Ct = requireHasown(), Et = xt.call(Function.call, Array.prototype.concat), St = xt.call(Function.apply, Array.prototype.splice), It = xt.call(Function.call, String.prototype.replace), Tt = xt.call(Function.call, String.prototype.slice), nt = xt.call(Function.call, RegExp.prototype.exec), it = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ke = /\\(\\)?/g, rt = function(ct) {
    var bt = Tt(ct, 0, 1), ut = Tt(ct, -1);
    if (bt === "%" && ut !== "%")
      throw new V("invalid intrinsic syntax, expected closing `%`");
    if (ut === "%" && bt !== "%")
      throw new V("invalid intrinsic syntax, expected opening `%`");
    var gt = [];
    return It(ct, it, function(dt, wt, Ft, jt) {
      gt[gt.length] = Ft ? It(jt, ke, "$1") : wt || dt;
    }), gt;
  }, ot = function(ct, bt) {
    var ut = ct, gt;
    if (Ct($t, ut) && (gt = $t[ut], ut = "%" + gt[0] + "%"), Ct(ht, ut)) {
      var dt = ht[ut];
      if (dt === lt && (dt = vt(ut)), typeof dt > "u" && !bt)
        throw new re("intrinsic " + ct + " exists, but is not available. Please file an issue!");
      return {
        alias: gt,
        name: ut,
        value: dt
      };
    }
    throw new V("intrinsic " + ct + " does not exist!");
  };
  return getIntrinsic = function(ct, bt) {
    if (typeof ct != "string" || ct.length === 0)
      throw new re("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof bt != "boolean")
      throw new re('"allowMissing" argument must be a boolean');
    if (nt(/^%?[^%]*%?$/, ct) === null)
      throw new V("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ut = rt(ct), gt = ut.length > 0 ? ut[0] : "", dt = ot("%" + gt + "%", bt), wt = dt.name, Ft = dt.value, jt = !1, Nt = dt.alias;
    Nt && (gt = Nt[0], St(ut, Et([0, 1], Nt)));
    for (var Bt = 1, Rt = !0; Bt < ut.length; Bt += 1) {
      var Ut = ut[Bt], zt = Tt(Ut, 0, 1), Mt = Tt(Ut, -1);
      if ((zt === '"' || zt === "'" || zt === "`" || Mt === '"' || Mt === "'" || Mt === "`") && zt !== Mt)
        throw new V("property names with quotes must have matching quotes");
      if ((Ut === "constructor" || !Rt) && (jt = !0), gt += "." + Ut, wt = "%" + gt + "%", Ct(ht, wt))
        Ft = ht[wt];
      else if (Ft != null) {
        if (!(Ut in Ft)) {
          if (!bt)
            throw new re("base intrinsic for " + ct + " exists, but the property is not available.");
          return;
        }
        if (ne && Bt + 1 >= ut.length) {
          var kt = ne(Ft, Ut);
          Rt = !!kt, Rt && "get" in kt && !("originalValue" in kt.get) ? Ft = kt.get : Ft = Ft[Ut];
        } else
          Rt = Ct(Ft, Ut), Ft = Ft[Ut];
        Rt && !jt && (ht[wt] = Ft);
      }
    }
    return Ft;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var B = requireGetIntrinsic(), L = B("%Object.defineProperty%", !0) || !1;
  if (L)
    try {
      L({}, "a", { value: 1 });
    } catch {
      L = !1;
    }
  return esDefineProperty = L, esDefineProperty;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var B = requireGetIntrinsic(), L = B("%Object.getOwnPropertyDescriptor%", !0);
  if (L)
    try {
      L([], "length");
    } catch {
      L = null;
    }
  return gopd = L, gopd;
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var B = requireEsDefineProperty(), L = requireSyntax(), W = requireType(), K = requireGopd();
  return defineDataProperty = function(V, re, ie) {
    if (!V || typeof V != "object" && typeof V != "function")
      throw new W("`obj` must be an object or a function`");
    if (typeof re != "string" && typeof re != "symbol")
      throw new W("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new W("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new W("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new W("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new W("`loose`, if provided, must be a boolean");
    var oe = arguments.length > 3 ? arguments[3] : null, pe = arguments.length > 4 ? arguments[4] : null, ne = arguments.length > 5 ? arguments[5] : null, ce = arguments.length > 6 ? arguments[6] : !1, Ce = !!K && K(V, re);
    if (B)
      B(V, re, {
        configurable: ne === null && Ce ? Ce.configurable : !ne,
        enumerable: oe === null && Ce ? Ce.enumerable : !oe,
        value: ie,
        writable: pe === null && Ce ? Ce.writable : !pe
      });
    else if (ce || !oe && !pe && !ne)
      V[re] = ie;
    else
      throw new L("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var B = requireEsDefineProperty(), L = function() {
    return !!B;
  };
  return L.hasArrayLengthDefineBug = function() {
    if (!B)
      return null;
    try {
      return B([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = L, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var B = requireGetIntrinsic(), L = requireDefineDataProperty(), W = requireHasPropertyDescriptors()(), K = requireGopd(), J = requireType(), V = B("%Math.floor%");
  return setFunctionLength = function(ie, oe) {
    if (typeof ie != "function")
      throw new J("`fn` is not a function");
    if (typeof oe != "number" || oe < 0 || oe > 4294967295 || V(oe) !== oe)
      throw new J("`length` must be a positive 32-bit integer");
    var pe = arguments.length > 2 && !!arguments[2], ne = !0, ce = !0;
    if ("length" in ie && K) {
      var Ce = K(ie, "length");
      Ce && !Ce.configurable && (ne = !1), Ce && !Ce.writable && (ce = !1);
    }
    return (ne || ce || !pe) && (W ? L(
      /** @type {Parameters<define>[0]} */
      ie,
      "length",
      oe,
      !0,
      !0
    ) : L(
      /** @type {Parameters<define>[0]} */
      ie,
      "length",
      oe
    )), ie;
  }, setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(B) {
    var L = requireFunctionBind(), W = requireGetIntrinsic(), K = requireSetFunctionLength(), J = requireType(), V = W("%Function.prototype.apply%"), re = W("%Function.prototype.call%"), ie = W("%Reflect.apply%", !0) || L.call(re, V), oe = requireEsDefineProperty(), pe = W("%Math.max%");
    B.exports = function(Ce) {
      if (typeof Ce != "function")
        throw new J("a function is required");
      var Oe = ie(L, re, arguments);
      return K(
        Oe,
        1 + pe(0, Ce.length - (arguments.length - 1)),
        !0
      );
    };
    var ne = function() {
      return ie(L, V, arguments);
    };
    oe ? oe(B.exports, "apply", { value: ne }) : B.exports.apply = ne;
  }(callBind)), callBind.exports;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var B = requireGetIntrinsic(), L = requireCallBind(), W = L(B("String.prototype.indexOf"));
  return callBound = function(J, V) {
    var re = B(J, !!V);
    return typeof re == "function" && W(J, ".prototype.") > -1 ? L(re) : re;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var B = requireShams()(), L = requireCallBound(), W = L("Object.prototype.toString"), K = function(ie) {
    return B && ie && typeof ie == "object" && Symbol.toStringTag in ie ? !1 : W(ie) === "[object Arguments]";
  }, J = function(ie) {
    return K(ie) ? !0 : ie !== null && typeof ie == "object" && typeof ie.length == "number" && ie.length >= 0 && W(ie) !== "[object Array]" && W(ie.callee) === "[object Function]";
  }, V = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = J, isArguments = V ? K : J, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var B = Object.prototype.toString, L = Function.prototype.toString, W = /^\s*(?:function)?\*/, K = requireShams()(), J = Object.getPrototypeOf, V = function() {
    if (!K)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, re;
  return isGeneratorFunction = function(oe) {
    if (typeof oe != "function")
      return !1;
    if (W.test(L.call(oe)))
      return !0;
    if (!K) {
      var pe = B.call(oe);
      return pe === "[object GeneratorFunction]";
    }
    if (!J)
      return !1;
    if (typeof re > "u") {
      var ne = V();
      re = ne ? J(ne) : !1;
    }
    return J(oe) === re;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var B = Function.prototype.toString, L = typeof Reflect == "object" && Reflect !== null && Reflect.apply, W, K;
  if (typeof L == "function" && typeof Object.defineProperty == "function")
    try {
      W = Object.defineProperty({}, "length", {
        get: function() {
          throw K;
        }
      }), K = {}, L(function() {
        throw 42;
      }, null, W);
    } catch (ht) {
      ht !== K && (L = null);
    }
  else
    L = null;
  var J = /^\s*class\b/, V = function(yt) {
    try {
      var vt = B.call(yt);
      return J.test(vt);
    } catch {
      return !1;
    }
  }, re = function(yt) {
    try {
      return V(yt) ? !1 : (B.call(yt), !0);
    } catch {
      return !1;
    }
  }, ie = Object.prototype.toString, oe = "[object Object]", pe = "[object Function]", ne = "[object GeneratorFunction]", ce = "[object HTMLAllCollection]", Ce = "[object HTML document.all class]", Oe = "[object HTMLCollection]", st = typeof Symbol == "function" && !!Symbol.toStringTag, at = !(0 in [,]), lt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var pt = document.all;
    ie.call(pt) === ie.call(document.all) && (lt = function(yt) {
      if ((at || !yt) && (typeof yt > "u" || typeof yt == "object"))
        try {
          var vt = ie.call(yt);
          return (vt === ce || vt === Ce || vt === Oe || vt === oe) && yt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = L ? function(yt) {
    if (lt(yt))
      return !0;
    if (!yt || typeof yt != "function" && typeof yt != "object")
      return !1;
    try {
      L(yt, null, W);
    } catch (vt) {
      if (vt !== K)
        return !1;
    }
    return !V(yt) && re(yt);
  } : function(yt) {
    if (lt(yt))
      return !0;
    if (!yt || typeof yt != "function" && typeof yt != "object")
      return !1;
    if (st)
      return re(yt);
    if (V(yt))
      return !1;
    var vt = ie.call(yt);
    return vt !== pe && vt !== ne && !/^\[object HTML/.test(vt) ? !1 : re(yt);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var B = requireIsCallable(), L = Object.prototype.toString, W = Object.prototype.hasOwnProperty, K = function(oe, pe, ne) {
    for (var ce = 0, Ce = oe.length; ce < Ce; ce++)
      W.call(oe, ce) && (ne == null ? pe(oe[ce], ce, oe) : pe.call(ne, oe[ce], ce, oe));
  }, J = function(oe, pe, ne) {
    for (var ce = 0, Ce = oe.length; ce < Ce; ce++)
      ne == null ? pe(oe.charAt(ce), ce, oe) : pe.call(ne, oe.charAt(ce), ce, oe);
  }, V = function(oe, pe, ne) {
    for (var ce in oe)
      W.call(oe, ce) && (ne == null ? pe(oe[ce], ce, oe) : pe.call(ne, oe[ce], ce, oe));
  }, re = function(oe, pe, ne) {
    if (!B(pe))
      throw new TypeError("iterator must be a function");
    var ce;
    arguments.length >= 3 && (ce = ne), L.call(oe) === "[object Array]" ? K(oe, pe, ce) : typeof oe == "string" ? J(oe, pe, ce) : V(oe, pe, ce);
  };
  return forEach_1 = re, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var B = requirePossibleTypedArrayNames(), L = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], J = 0; J < B.length; J++)
      typeof L[B[J]] == "function" && (K[K.length] = B[J]);
    return K;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var B = requireForEach(), L = requireAvailableTypedArrays(), W = requireCallBind(), K = requireCallBound(), J = requireGopd(), V = K("Object.prototype.toString"), re = requireShams()(), ie = typeof globalThis > "u" ? commonjsGlobal : globalThis, oe = L(), pe = K("String.prototype.slice"), ne = Object.getPrototypeOf, ce = K("Array.prototype.indexOf", !0) || function(lt, pt) {
    for (var ht = 0; ht < lt.length; ht += 1)
      if (lt[ht] === pt)
        return ht;
    return -1;
  }, Ce = { __proto__: null };
  re && J && ne ? B(oe, function(at) {
    var lt = new ie[at]();
    if (Symbol.toStringTag in lt) {
      var pt = ne(lt), ht = J(pt, Symbol.toStringTag);
      if (!ht) {
        var yt = ne(pt);
        ht = J(yt, Symbol.toStringTag);
      }
      Ce["$" + at] = W(ht.get);
    }
  }) : B(oe, function(at) {
    var lt = new ie[at](), pt = lt.slice || lt.set;
    pt && (Ce["$" + at] = W(pt));
  });
  var Oe = function(lt) {
    var pt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ce,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(ht, yt) {
        if (!pt)
          try {
            "$" + ht(lt) === yt && (pt = pe(yt, 1));
          } catch {
          }
      }
    ), pt;
  }, st = function(lt) {
    var pt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ce,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(ht, yt) {
        if (!pt)
          try {
            ht(lt), pt = pe(yt, 1);
          } catch {
          }
      }
    ), pt;
  };
  return whichTypedArray = function(lt) {
    if (!lt || typeof lt != "object")
      return !1;
    if (!re) {
      var pt = pe(V(lt), 8, -1);
      return ce(oe, pt) > -1 ? pt : pt !== "Object" ? !1 : st(lt);
    }
    return J ? Oe(lt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var B = requireWhichTypedArray();
  return isTypedArray = function(W) {
    return !!B(W);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(B) {
    var L = requireIsArguments(), W = requireIsGeneratorFunction(), K = requireWhichTypedArray(), J = requireIsTypedArray();
    function V(Jt) {
      return Jt.call.bind(Jt);
    }
    var re = typeof BigInt < "u", ie = typeof Symbol < "u", oe = V(Object.prototype.toString), pe = V(Number.prototype.valueOf), ne = V(String.prototype.valueOf), ce = V(Boolean.prototype.valueOf);
    if (re)
      var Ce = V(BigInt.prototype.valueOf);
    if (ie)
      var Oe = V(Symbol.prototype.valueOf);
    function st(Jt, Pr) {
      if (typeof Jt != "object")
        return !1;
      try {
        return Pr(Jt), !0;
      } catch {
        return !1;
      }
    }
    B.isArgumentsObject = L, B.isGeneratorFunction = W, B.isTypedArray = J;
    function at(Jt) {
      return typeof Promise < "u" && Jt instanceof Promise || Jt !== null && typeof Jt == "object" && typeof Jt.then == "function" && typeof Jt.catch == "function";
    }
    B.isPromise = at;
    function lt(Jt) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Jt) : J(Jt) || wt(Jt);
    }
    B.isArrayBufferView = lt;
    function pt(Jt) {
      return K(Jt) === "Uint8Array";
    }
    B.isUint8Array = pt;
    function ht(Jt) {
      return K(Jt) === "Uint8ClampedArray";
    }
    B.isUint8ClampedArray = ht;
    function yt(Jt) {
      return K(Jt) === "Uint16Array";
    }
    B.isUint16Array = yt;
    function vt(Jt) {
      return K(Jt) === "Uint32Array";
    }
    B.isUint32Array = vt;
    function $t(Jt) {
      return K(Jt) === "Int8Array";
    }
    B.isInt8Array = $t;
    function xt(Jt) {
      return K(Jt) === "Int16Array";
    }
    B.isInt16Array = xt;
    function Ct(Jt) {
      return K(Jt) === "Int32Array";
    }
    B.isInt32Array = Ct;
    function Et(Jt) {
      return K(Jt) === "Float32Array";
    }
    B.isFloat32Array = Et;
    function St(Jt) {
      return K(Jt) === "Float64Array";
    }
    B.isFloat64Array = St;
    function It(Jt) {
      return K(Jt) === "BigInt64Array";
    }
    B.isBigInt64Array = It;
    function Tt(Jt) {
      return K(Jt) === "BigUint64Array";
    }
    B.isBigUint64Array = Tt;
    function nt(Jt) {
      return oe(Jt) === "[object Map]";
    }
    nt.working = typeof Map < "u" && nt(/* @__PURE__ */ new Map());
    function it(Jt) {
      return typeof Map > "u" ? !1 : nt.working ? nt(Jt) : Jt instanceof Map;
    }
    B.isMap = it;
    function ke(Jt) {
      return oe(Jt) === "[object Set]";
    }
    ke.working = typeof Set < "u" && ke(/* @__PURE__ */ new Set());
    function rt(Jt) {
      return typeof Set > "u" ? !1 : ke.working ? ke(Jt) : Jt instanceof Set;
    }
    B.isSet = rt;
    function ot(Jt) {
      return oe(Jt) === "[object WeakMap]";
    }
    ot.working = typeof WeakMap < "u" && ot(/* @__PURE__ */ new WeakMap());
    function ft(Jt) {
      return typeof WeakMap > "u" ? !1 : ot.working ? ot(Jt) : Jt instanceof WeakMap;
    }
    B.isWeakMap = ft;
    function ct(Jt) {
      return oe(Jt) === "[object WeakSet]";
    }
    ct.working = typeof WeakSet < "u" && ct(/* @__PURE__ */ new WeakSet());
    function bt(Jt) {
      return ct(Jt);
    }
    B.isWeakSet = bt;
    function ut(Jt) {
      return oe(Jt) === "[object ArrayBuffer]";
    }
    ut.working = typeof ArrayBuffer < "u" && ut(new ArrayBuffer());
    function gt(Jt) {
      return typeof ArrayBuffer > "u" ? !1 : ut.working ? ut(Jt) : Jt instanceof ArrayBuffer;
    }
    B.isArrayBuffer = gt;
    function dt(Jt) {
      return oe(Jt) === "[object DataView]";
    }
    dt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && dt(new DataView(new ArrayBuffer(1), 0, 1));
    function wt(Jt) {
      return typeof DataView > "u" ? !1 : dt.working ? dt(Jt) : Jt instanceof DataView;
    }
    B.isDataView = wt;
    var Ft = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function jt(Jt) {
      return oe(Jt) === "[object SharedArrayBuffer]";
    }
    function Nt(Jt) {
      return typeof Ft > "u" ? !1 : (typeof jt.working > "u" && (jt.working = jt(new Ft())), jt.working ? jt(Jt) : Jt instanceof Ft);
    }
    B.isSharedArrayBuffer = Nt;
    function Bt(Jt) {
      return oe(Jt) === "[object AsyncFunction]";
    }
    B.isAsyncFunction = Bt;
    function Rt(Jt) {
      return oe(Jt) === "[object Map Iterator]";
    }
    B.isMapIterator = Rt;
    function Ut(Jt) {
      return oe(Jt) === "[object Set Iterator]";
    }
    B.isSetIterator = Ut;
    function zt(Jt) {
      return oe(Jt) === "[object Generator]";
    }
    B.isGeneratorObject = zt;
    function Mt(Jt) {
      return oe(Jt) === "[object WebAssembly.Module]";
    }
    B.isWebAssemblyCompiledModule = Mt;
    function kt(Jt) {
      return st(Jt, pe);
    }
    B.isNumberObject = kt;
    function Gt(Jt) {
      return st(Jt, ne);
    }
    B.isStringObject = Gt;
    function Qt(Jt) {
      return st(Jt, ce);
    }
    B.isBooleanObject = Qt;
    function nr(Jt) {
      return re && st(Jt, Ce);
    }
    B.isBigIntObject = nr;
    function ar(Jt) {
      return ie && st(Jt, Oe);
    }
    B.isSymbolObject = ar;
    function cr(Jt) {
      return kt(Jt) || Gt(Jt) || Qt(Jt) || nr(Jt) || ar(Jt);
    }
    B.isBoxedPrimitive = cr;
    function hr(Jt) {
      return typeof Uint8Array < "u" && (gt(Jt) || Nt(Jt));
    }
    B.isAnyArrayBuffer = hr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Jt) {
      Object.defineProperty(B, Jt, {
        enumerable: !1,
        value: function() {
          throw new Error(Jt + " is not supported in userland");
        }
      });
    });
  }(types$2)), types$2;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(L) {
    return L && typeof L == "object" && typeof L.copy == "function" && typeof L.fill == "function" && typeof L.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(B) {
    var L = Object.getOwnPropertyDescriptors || function(wt) {
      for (var Ft = Object.keys(wt), jt = {}, Nt = 0; Nt < Ft.length; Nt++)
        jt[Ft[Nt]] = Object.getOwnPropertyDescriptor(wt, Ft[Nt]);
      return jt;
    }, W = /%[sdj%]/g;
    B.format = function(dt) {
      if (!$t(dt)) {
        for (var wt = [], Ft = 0; Ft < arguments.length; Ft++)
          wt.push(re(arguments[Ft]));
        return wt.join(" ");
      }
      for (var Ft = 1, jt = arguments, Nt = jt.length, Bt = String(dt).replace(W, function(Ut) {
        if (Ut === "%%") return "%";
        if (Ft >= Nt) return Ut;
        switch (Ut) {
          case "%s":
            return String(jt[Ft++]);
          case "%d":
            return Number(jt[Ft++]);
          case "%j":
            try {
              return JSON.stringify(jt[Ft++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ut;
        }
      }), Rt = jt[Ft]; Ft < Nt; Rt = jt[++Ft])
        ht(Rt) || !St(Rt) ? Bt += " " + Rt : Bt += " " + re(Rt);
      return Bt;
    }, B.deprecate = function(dt, wt) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return dt;
      if (typeof process$1 > "u")
        return function() {
          return B.deprecate(dt, wt).apply(this, arguments);
        };
      var Ft = !1;
      function jt() {
        if (!Ft) {
          if (process$1.throwDeprecation)
            throw new Error(wt);
          process$1.traceDeprecation ? console.trace(wt) : console.error(wt), Ft = !0;
        }
        return dt.apply(this, arguments);
      }
      return jt;
    };
    var K = {}, J = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var V = process$1.env.NODE_DEBUG;
      V = V.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), J = new RegExp("^" + V + "$", "i");
    }
    B.debuglog = function(dt) {
      if (dt = dt.toUpperCase(), !K[dt])
        if (J.test(dt)) {
          var wt = process$1.pid;
          K[dt] = function() {
            var Ft = B.format.apply(B, arguments);
            console.error("%s %d: %s", dt, wt, Ft);
          };
        } else
          K[dt] = function() {
          };
      return K[dt];
    };
    function re(dt, wt) {
      var Ft = {
        seen: [],
        stylize: oe
      };
      return arguments.length >= 3 && (Ft.depth = arguments[2]), arguments.length >= 4 && (Ft.colors = arguments[3]), pt(wt) ? Ft.showHidden = wt : wt && B._extend(Ft, wt), Ct(Ft.showHidden) && (Ft.showHidden = !1), Ct(Ft.depth) && (Ft.depth = 2), Ct(Ft.colors) && (Ft.colors = !1), Ct(Ft.customInspect) && (Ft.customInspect = !0), Ft.colors && (Ft.stylize = ie), ne(Ft, dt, Ft.depth);
    }
    B.inspect = re, re.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, re.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function ie(dt, wt) {
      var Ft = re.styles[wt];
      return Ft ? "\x1B[" + re.colors[Ft][0] + "m" + dt + "\x1B[" + re.colors[Ft][1] + "m" : dt;
    }
    function oe(dt, wt) {
      return dt;
    }
    function pe(dt) {
      var wt = {};
      return dt.forEach(function(Ft, jt) {
        wt[Ft] = !0;
      }), wt;
    }
    function ne(dt, wt, Ft) {
      if (dt.customInspect && wt && nt(wt.inspect) && // Filter out the util module, it's inspect function is special
      wt.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
      !(wt.constructor && wt.constructor.prototype === wt)) {
        var jt = wt.inspect(Ft, dt);
        return $t(jt) || (jt = ne(dt, jt, Ft)), jt;
      }
      var Nt = ce(dt, wt);
      if (Nt)
        return Nt;
      var Bt = Object.keys(wt), Rt = pe(Bt);
      if (dt.showHidden && (Bt = Object.getOwnPropertyNames(wt)), Tt(wt) && (Bt.indexOf("message") >= 0 || Bt.indexOf("description") >= 0))
        return Ce(wt);
      if (Bt.length === 0) {
        if (nt(wt)) {
          var Ut = wt.name ? ": " + wt.name : "";
          return dt.stylize("[Function" + Ut + "]", "special");
        }
        if (Et(wt))
          return dt.stylize(RegExp.prototype.toString.call(wt), "regexp");
        if (It(wt))
          return dt.stylize(Date.prototype.toString.call(wt), "date");
        if (Tt(wt))
          return Ce(wt);
      }
      var zt = "", Mt = !1, kt = ["{", "}"];
      if (lt(wt) && (Mt = !0, kt = ["[", "]"]), nt(wt)) {
        var Gt = wt.name ? ": " + wt.name : "";
        zt = " [Function" + Gt + "]";
      }
      if (Et(wt) && (zt = " " + RegExp.prototype.toString.call(wt)), It(wt) && (zt = " " + Date.prototype.toUTCString.call(wt)), Tt(wt) && (zt = " " + Ce(wt)), Bt.length === 0 && (!Mt || wt.length == 0))
        return kt[0] + zt + kt[1];
      if (Ft < 0)
        return Et(wt) ? dt.stylize(RegExp.prototype.toString.call(wt), "regexp") : dt.stylize("[Object]", "special");
      dt.seen.push(wt);
      var Qt;
      return Mt ? Qt = Oe(dt, wt, Ft, Rt, Bt) : Qt = Bt.map(function(nr) {
        return st(dt, wt, Ft, Rt, nr, Mt);
      }), dt.seen.pop(), at(Qt, zt, kt);
    }
    function ce(dt, wt) {
      if (Ct(wt))
        return dt.stylize("undefined", "undefined");
      if ($t(wt)) {
        var Ft = "'" + JSON.stringify(wt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return dt.stylize(Ft, "string");
      }
      if (vt(wt))
        return dt.stylize("" + wt, "number");
      if (pt(wt))
        return dt.stylize("" + wt, "boolean");
      if (ht(wt))
        return dt.stylize("null", "null");
    }
    function Ce(dt) {
      return "[" + Error.prototype.toString.call(dt) + "]";
    }
    function Oe(dt, wt, Ft, jt, Nt) {
      for (var Bt = [], Rt = 0, Ut = wt.length; Rt < Ut; ++Rt)
        ct(wt, String(Rt)) ? Bt.push(st(
          dt,
          wt,
          Ft,
          jt,
          String(Rt),
          !0
        )) : Bt.push("");
      return Nt.forEach(function(zt) {
        zt.match(/^\d+$/) || Bt.push(st(
          dt,
          wt,
          Ft,
          jt,
          zt,
          !0
        ));
      }), Bt;
    }
    function st(dt, wt, Ft, jt, Nt, Bt) {
      var Rt, Ut, zt;
      if (zt = Object.getOwnPropertyDescriptor(wt, Nt) || { value: wt[Nt] }, zt.get ? zt.set ? Ut = dt.stylize("[Getter/Setter]", "special") : Ut = dt.stylize("[Getter]", "special") : zt.set && (Ut = dt.stylize("[Setter]", "special")), ct(jt, Nt) || (Rt = "[" + Nt + "]"), Ut || (dt.seen.indexOf(zt.value) < 0 ? (ht(Ft) ? Ut = ne(dt, zt.value, null) : Ut = ne(dt, zt.value, Ft - 1), Ut.indexOf(`
`) > -1 && (Bt ? Ut = Ut.split(`
`).map(function(Mt) {
        return "  " + Mt;
      }).join(`
`).slice(2) : Ut = `
` + Ut.split(`
`).map(function(Mt) {
        return "   " + Mt;
      }).join(`
`))) : Ut = dt.stylize("[Circular]", "special")), Ct(Rt)) {
        if (Bt && Nt.match(/^\d+$/))
          return Ut;
        Rt = JSON.stringify("" + Nt), Rt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Rt = Rt.slice(1, -1), Rt = dt.stylize(Rt, "name")) : (Rt = Rt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Rt = dt.stylize(Rt, "string"));
      }
      return Rt + ": " + Ut;
    }
    function at(dt, wt, Ft) {
      var jt = dt.reduce(function(Nt, Bt) {
        return Bt.indexOf(`
`) >= 0, Nt + Bt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return jt > 60 ? Ft[0] + (wt === "" ? "" : wt + `
 `) + " " + dt.join(`,
  `) + " " + Ft[1] : Ft[0] + wt + " " + dt.join(", ") + " " + Ft[1];
    }
    B.types = requireTypes();
    function lt(dt) {
      return Array.isArray(dt);
    }
    B.isArray = lt;
    function pt(dt) {
      return typeof dt == "boolean";
    }
    B.isBoolean = pt;
    function ht(dt) {
      return dt === null;
    }
    B.isNull = ht;
    function yt(dt) {
      return dt == null;
    }
    B.isNullOrUndefined = yt;
    function vt(dt) {
      return typeof dt == "number";
    }
    B.isNumber = vt;
    function $t(dt) {
      return typeof dt == "string";
    }
    B.isString = $t;
    function xt(dt) {
      return typeof dt == "symbol";
    }
    B.isSymbol = xt;
    function Ct(dt) {
      return dt === void 0;
    }
    B.isUndefined = Ct;
    function Et(dt) {
      return St(dt) && ke(dt) === "[object RegExp]";
    }
    B.isRegExp = Et, B.types.isRegExp = Et;
    function St(dt) {
      return typeof dt == "object" && dt !== null;
    }
    B.isObject = St;
    function It(dt) {
      return St(dt) && ke(dt) === "[object Date]";
    }
    B.isDate = It, B.types.isDate = It;
    function Tt(dt) {
      return St(dt) && (ke(dt) === "[object Error]" || dt instanceof Error);
    }
    B.isError = Tt, B.types.isNativeError = Tt;
    function nt(dt) {
      return typeof dt == "function";
    }
    B.isFunction = nt;
    function it(dt) {
      return dt === null || typeof dt == "boolean" || typeof dt == "number" || typeof dt == "string" || typeof dt == "symbol" || // ES6 symbol
      typeof dt > "u";
    }
    B.isPrimitive = it, B.isBuffer = requireIsBufferBrowser();
    function ke(dt) {
      return Object.prototype.toString.call(dt);
    }
    function rt(dt) {
      return dt < 10 ? "0" + dt.toString(10) : dt.toString(10);
    }
    var ot = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function ft() {
      var dt = /* @__PURE__ */ new Date(), wt = [
        rt(dt.getHours()),
        rt(dt.getMinutes()),
        rt(dt.getSeconds())
      ].join(":");
      return [dt.getDate(), ot[dt.getMonth()], wt].join(" ");
    }
    B.log = function() {
      console.log("%s - %s", ft(), B.format.apply(B, arguments));
    }, B.inherits = requireInherits_browser(), B._extend = function(dt, wt) {
      if (!wt || !St(wt)) return dt;
      for (var Ft = Object.keys(wt), jt = Ft.length; jt--; )
        dt[Ft[jt]] = wt[Ft[jt]];
      return dt;
    };
    function ct(dt, wt) {
      return Object.prototype.hasOwnProperty.call(dt, wt);
    }
    var bt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    B.promisify = function(wt) {
      if (typeof wt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (bt && wt[bt]) {
        var Ft = wt[bt];
        if (typeof Ft != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(Ft, bt, {
          value: Ft,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), Ft;
      }
      function Ft() {
        for (var jt, Nt, Bt = new Promise(function(zt, Mt) {
          jt = zt, Nt = Mt;
        }), Rt = [], Ut = 0; Ut < arguments.length; Ut++)
          Rt.push(arguments[Ut]);
        Rt.push(function(zt, Mt) {
          zt ? Nt(zt) : jt(Mt);
        });
        try {
          wt.apply(this, Rt);
        } catch (zt) {
          Nt(zt);
        }
        return Bt;
      }
      return Object.setPrototypeOf(Ft, Object.getPrototypeOf(wt)), bt && Object.defineProperty(Ft, bt, {
        value: Ft,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        Ft,
        L(wt)
      );
    }, B.promisify.custom = bt;
    function ut(dt, wt) {
      if (!dt) {
        var Ft = new Error("Promise was rejected with a falsy value");
        Ft.reason = dt, dt = Ft;
      }
      return wt(dt);
    }
    function gt(dt) {
      if (typeof dt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function wt() {
        for (var Ft = [], jt = 0; jt < arguments.length; jt++)
          Ft.push(arguments[jt]);
        var Nt = Ft.pop();
        if (typeof Nt != "function")
          throw new TypeError("The last argument must be of type Function");
        var Bt = this, Rt = function() {
          return Nt.apply(Bt, arguments);
        };
        dt.apply(this, Ft).then(
          function(Ut) {
            process$1.nextTick(Rt.bind(null, null, Ut));
          },
          function(Ut) {
            process$1.nextTick(ut.bind(null, Ut, Rt));
          }
        );
      }
      return Object.setPrototypeOf(wt, Object.getPrototypeOf(dt)), Object.defineProperties(
        wt,
        L(dt)
      ), wt;
    }
    B.callbackify = gt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B(st, at) {
    var lt = Object.keys(st);
    if (Object.getOwnPropertySymbols) {
      var pt = Object.getOwnPropertySymbols(st);
      at && (pt = pt.filter(function(ht) {
        return Object.getOwnPropertyDescriptor(st, ht).enumerable;
      })), lt.push.apply(lt, pt);
    }
    return lt;
  }
  function L(st) {
    for (var at = 1; at < arguments.length; at++) {
      var lt = arguments[at] != null ? arguments[at] : {};
      at % 2 ? B(Object(lt), !0).forEach(function(pt) {
        W(st, pt, lt[pt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(st, Object.getOwnPropertyDescriptors(lt)) : B(Object(lt)).forEach(function(pt) {
        Object.defineProperty(st, pt, Object.getOwnPropertyDescriptor(lt, pt));
      });
    }
    return st;
  }
  function W(st, at, lt) {
    return at = re(at), at in st ? Object.defineProperty(st, at, { value: lt, enumerable: !0, configurable: !0, writable: !0 }) : st[at] = lt, st;
  }
  function K(st, at) {
    if (!(st instanceof at))
      throw new TypeError("Cannot call a class as a function");
  }
  function J(st, at) {
    for (var lt = 0; lt < at.length; lt++) {
      var pt = at[lt];
      pt.enumerable = pt.enumerable || !1, pt.configurable = !0, "value" in pt && (pt.writable = !0), Object.defineProperty(st, re(pt.key), pt);
    }
  }
  function V(st, at, lt) {
    return at && J(st.prototype, at), Object.defineProperty(st, "prototype", { writable: !1 }), st;
  }
  function re(st) {
    var at = ie(st, "string");
    return typeof at == "symbol" ? at : String(at);
  }
  function ie(st, at) {
    if (typeof st != "object" || st === null) return st;
    var lt = st[Symbol.toPrimitive];
    if (lt !== void 0) {
      var pt = lt.call(st, at || "default");
      if (typeof pt != "object") return pt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (at === "string" ? String : Number)(st);
  }
  var oe = require$$1$2, pe = oe.Buffer, ne = requireUtil$1(), ce = ne.inspect, Ce = ce && ce.custom || "inspect";
  function Oe(st, at, lt) {
    pe.prototype.copy.call(st, at, lt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function st() {
      K(this, st), this.head = null, this.tail = null, this.length = 0;
    }
    return V(st, [{
      key: "push",
      value: function(lt) {
        var pt = {
          data: lt,
          next: null
        };
        this.length > 0 ? this.tail.next = pt : this.head = pt, this.tail = pt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(lt) {
        var pt = {
          data: lt,
          next: this.head
        };
        this.length === 0 && (this.tail = pt), this.head = pt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var lt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, lt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(lt) {
        if (this.length === 0) return "";
        for (var pt = this.head, ht = "" + pt.data; pt = pt.next; ) ht += lt + pt.data;
        return ht;
      }
    }, {
      key: "concat",
      value: function(lt) {
        if (this.length === 0) return pe.alloc(0);
        for (var pt = pe.allocUnsafe(lt >>> 0), ht = this.head, yt = 0; ht; )
          Oe(ht.data, pt, yt), yt += ht.data.length, ht = ht.next;
        return pt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(lt, pt) {
        var ht;
        return lt < this.head.data.length ? (ht = this.head.data.slice(0, lt), this.head.data = this.head.data.slice(lt)) : lt === this.head.data.length ? ht = this.shift() : ht = pt ? this._getString(lt) : this._getBuffer(lt), ht;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(lt) {
        var pt = this.head, ht = 1, yt = pt.data;
        for (lt -= yt.length; pt = pt.next; ) {
          var vt = pt.data, $t = lt > vt.length ? vt.length : lt;
          if ($t === vt.length ? yt += vt : yt += vt.slice(0, lt), lt -= $t, lt === 0) {
            $t === vt.length ? (++ht, pt.next ? this.head = pt.next : this.head = this.tail = null) : (this.head = pt, pt.data = vt.slice($t));
            break;
          }
          ++ht;
        }
        return this.length -= ht, yt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(lt) {
        var pt = pe.allocUnsafe(lt), ht = this.head, yt = 1;
        for (ht.data.copy(pt), lt -= ht.data.length; ht = ht.next; ) {
          var vt = ht.data, $t = lt > vt.length ? vt.length : lt;
          if (vt.copy(pt, pt.length - lt, 0, $t), lt -= $t, lt === 0) {
            $t === vt.length ? (++yt, ht.next ? this.head = ht.next : this.head = this.tail = null) : (this.head = ht, ht.data = vt.slice($t));
            break;
          }
          ++yt;
        }
        return this.length -= yt, pt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Ce,
      value: function(lt, pt) {
        return ce(this, L(L({}, pt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), st;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function B(re, ie) {
    var oe = this, pe = this._readableState && this._readableState.destroyed, ne = this._writableState && this._writableState.destroyed;
    return pe || ne ? (ie ? ie(re) : re && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(J, this, re)) : process$1.nextTick(J, this, re)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(re || null, function(ce) {
      !ie && ce ? oe._writableState ? oe._writableState.errorEmitted ? process$1.nextTick(W, oe) : (oe._writableState.errorEmitted = !0, process$1.nextTick(L, oe, ce)) : process$1.nextTick(L, oe, ce) : ie ? (process$1.nextTick(W, oe), ie(ce)) : process$1.nextTick(W, oe);
    }), this);
  }
  function L(re, ie) {
    J(re, ie), W(re);
  }
  function W(re) {
    re._writableState && !re._writableState.emitClose || re._readableState && !re._readableState.emitClose || re.emit("close");
  }
  function K() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function J(re, ie) {
    re.emit("error", ie);
  }
  function V(re, ie) {
    var oe = re._readableState, pe = re._writableState;
    oe && oe.autoDestroy || pe && pe.autoDestroy ? re.destroy(ie) : re.emit("error", ie);
  }
  return destroy_1$1 = {
    destroy: B,
    undestroy: K,
    errorOrDestroy: V
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function B(ie, oe) {
    ie.prototype = Object.create(oe.prototype), ie.prototype.constructor = ie, ie.__proto__ = oe;
  }
  var L = {};
  function W(ie, oe, pe) {
    pe || (pe = Error);
    function ne(Ce, Oe, st) {
      return typeof oe == "string" ? oe : oe(Ce, Oe, st);
    }
    var ce = /* @__PURE__ */ function(Ce) {
      B(Oe, Ce);
      function Oe(st, at, lt) {
        return Ce.call(this, ne(st, at, lt)) || this;
      }
      return Oe;
    }(pe);
    ce.prototype.name = pe.name, ce.prototype.code = ie, L[ie] = ce;
  }
  function K(ie, oe) {
    if (Array.isArray(ie)) {
      var pe = ie.length;
      return ie = ie.map(function(ne) {
        return String(ne);
      }), pe > 2 ? "one of ".concat(oe, " ").concat(ie.slice(0, pe - 1).join(", "), ", or ") + ie[pe - 1] : pe === 2 ? "one of ".concat(oe, " ").concat(ie[0], " or ").concat(ie[1]) : "of ".concat(oe, " ").concat(ie[0]);
    } else
      return "of ".concat(oe, " ").concat(String(ie));
  }
  function J(ie, oe, pe) {
    return ie.substr(0, oe.length) === oe;
  }
  function V(ie, oe, pe) {
    return (pe === void 0 || pe > ie.length) && (pe = ie.length), ie.substring(pe - oe.length, pe) === oe;
  }
  function re(ie, oe, pe) {
    return typeof pe != "number" && (pe = 0), pe + oe.length > ie.length ? !1 : ie.indexOf(oe, pe) !== -1;
  }
  return W("ERR_INVALID_OPT_VALUE", function(ie, oe) {
    return 'The value "' + oe + '" is invalid for option "' + ie + '"';
  }, TypeError), W("ERR_INVALID_ARG_TYPE", function(ie, oe, pe) {
    var ne;
    typeof oe == "string" && J(oe, "not ") ? (ne = "must not be", oe = oe.replace(/^not /, "")) : ne = "must be";
    var ce;
    if (V(ie, " argument"))
      ce = "The ".concat(ie, " ").concat(ne, " ").concat(K(oe, "type"));
    else {
      var Ce = re(ie, ".") ? "property" : "argument";
      ce = 'The "'.concat(ie, '" ').concat(Ce, " ").concat(ne, " ").concat(K(oe, "type"));
    }
    return ce += ". Received type ".concat(typeof pe), ce;
  }, TypeError), W("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), W("ERR_METHOD_NOT_IMPLEMENTED", function(ie) {
    return "The " + ie + " method is not implemented";
  }), W("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), W("ERR_STREAM_DESTROYED", function(ie) {
    return "Cannot call " + ie + " after a stream was destroyed";
  }), W("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), W("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), W("ERR_STREAM_WRITE_AFTER_END", "write after end"), W("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), W("ERR_UNKNOWN_ENCODING", function(ie) {
    return "Unknown encoding: " + ie;
  }, TypeError), W("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = L, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function L(K, J, V) {
    return K.highWaterMark != null ? K.highWaterMark : J ? K[V] : null;
  }
  function W(K, J, V, re) {
    var ie = L(J, re, V);
    if (ie != null) {
      if (!(isFinite(ie) && Math.floor(ie) === ie) || ie < 0) {
        var oe = re ? V : "highWaterMark";
        throw new B(oe, ie);
      }
      return Math.floor(ie);
    }
    return K.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: W
  }, state;
}
var browser$b, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b;
  hasRequiredBrowser$b = 1, browser$b = B;
  function B(W, K) {
    if (L("noDeprecation"))
      return W;
    var J = !1;
    function V() {
      if (!J) {
        if (L("throwDeprecation"))
          throw new Error(K);
        L("traceDeprecation") ? console.trace(K) : console.warn(K), J = !0;
      }
      return W.apply(this, arguments);
    }
    return V;
  }
  function L(W) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[W];
    return K == null ? !1 : String(K).toLowerCase() === "true";
  }
  return browser$b;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Et;
  function B(Nt) {
    var Bt = this;
    this.next = null, this.entry = null, this.finish = function() {
      jt(Bt, Nt);
    };
  }
  var L;
  Et.WritableState = xt;
  var W = {
    deprecate: requireBrowser$b()
  }, K = requireStreamBrowser$1(), J = require$$1$2.Buffer, V = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function re(Nt) {
    return J.from(Nt);
  }
  function ie(Nt) {
    return J.isBuffer(Nt) || Nt instanceof V;
  }
  var oe = requireDestroy$1(), pe = requireState(), ne = pe.getHighWaterMark, ce = requireErrorsBrowser().codes, Ce = ce.ERR_INVALID_ARG_TYPE, Oe = ce.ERR_METHOD_NOT_IMPLEMENTED, st = ce.ERR_MULTIPLE_CALLBACK, at = ce.ERR_STREAM_CANNOT_PIPE, lt = ce.ERR_STREAM_DESTROYED, pt = ce.ERR_STREAM_NULL_VALUES, ht = ce.ERR_STREAM_WRITE_AFTER_END, yt = ce.ERR_UNKNOWN_ENCODING, vt = oe.errorOrDestroy;
  requireInherits_browser()(Et, K);
  function $t() {
  }
  function xt(Nt, Bt, Rt) {
    L = L || require_stream_duplex$1(), Nt = Nt || {}, typeof Rt != "boolean" && (Rt = Bt instanceof L), this.objectMode = !!Nt.objectMode, Rt && (this.objectMode = this.objectMode || !!Nt.writableObjectMode), this.highWaterMark = ne(this, Nt, "writableHighWaterMark", Rt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ut = Nt.decodeStrings === !1;
    this.decodeStrings = !Ut, this.defaultEncoding = Nt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(zt) {
      ot(Bt, zt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Nt.emitClose !== !1, this.autoDestroy = !!Nt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  xt.prototype.getBuffer = function() {
    for (var Bt = this.bufferedRequest, Rt = []; Bt; )
      Rt.push(Bt), Bt = Bt.next;
    return Rt;
  }, function() {
    try {
      Object.defineProperty(xt.prototype, "buffer", {
        get: W.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Ct;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ct = Function.prototype[Symbol.hasInstance], Object.defineProperty(Et, Symbol.hasInstance, {
    value: function(Bt) {
      return Ct.call(this, Bt) ? !0 : this !== Et ? !1 : Bt && Bt._writableState instanceof xt;
    }
  })) : Ct = function(Bt) {
    return Bt instanceof this;
  };
  function Et(Nt) {
    L = L || require_stream_duplex$1();
    var Bt = this instanceof L;
    if (!Bt && !Ct.call(Et, this)) return new Et(Nt);
    this._writableState = new xt(Nt, this, Bt), this.writable = !0, Nt && (typeof Nt.write == "function" && (this._write = Nt.write), typeof Nt.writev == "function" && (this._writev = Nt.writev), typeof Nt.destroy == "function" && (this._destroy = Nt.destroy), typeof Nt.final == "function" && (this._final = Nt.final)), K.call(this);
  }
  Et.prototype.pipe = function() {
    vt(this, new at());
  };
  function St(Nt, Bt) {
    var Rt = new ht();
    vt(Nt, Rt), process$1.nextTick(Bt, Rt);
  }
  function It(Nt, Bt, Rt, Ut) {
    var zt;
    return Rt === null ? zt = new pt() : typeof Rt != "string" && !Bt.objectMode && (zt = new Ce("chunk", ["string", "Buffer"], Rt)), zt ? (vt(Nt, zt), process$1.nextTick(Ut, zt), !1) : !0;
  }
  Et.prototype.write = function(Nt, Bt, Rt) {
    var Ut = this._writableState, zt = !1, Mt = !Ut.objectMode && ie(Nt);
    return Mt && !J.isBuffer(Nt) && (Nt = re(Nt)), typeof Bt == "function" && (Rt = Bt, Bt = null), Mt ? Bt = "buffer" : Bt || (Bt = Ut.defaultEncoding), typeof Rt != "function" && (Rt = $t), Ut.ending ? St(this, Rt) : (Mt || It(this, Ut, Nt, Rt)) && (Ut.pendingcb++, zt = nt(this, Ut, Mt, Nt, Bt, Rt)), zt;
  }, Et.prototype.cork = function() {
    this._writableState.corked++;
  }, Et.prototype.uncork = function() {
    var Nt = this._writableState;
    Nt.corked && (Nt.corked--, !Nt.writing && !Nt.corked && !Nt.bufferProcessing && Nt.bufferedRequest && bt(this, Nt));
  }, Et.prototype.setDefaultEncoding = function(Bt) {
    if (typeof Bt == "string" && (Bt = Bt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Bt + "").toLowerCase()) > -1)) throw new yt(Bt);
    return this._writableState.defaultEncoding = Bt, this;
  }, Object.defineProperty(Et.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Tt(Nt, Bt, Rt) {
    return !Nt.objectMode && Nt.decodeStrings !== !1 && typeof Bt == "string" && (Bt = J.from(Bt, Rt)), Bt;
  }
  Object.defineProperty(Et.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function nt(Nt, Bt, Rt, Ut, zt, Mt) {
    if (!Rt) {
      var kt = Tt(Bt, Ut, zt);
      Ut !== kt && (Rt = !0, zt = "buffer", Ut = kt);
    }
    var Gt = Bt.objectMode ? 1 : Ut.length;
    Bt.length += Gt;
    var Qt = Bt.length < Bt.highWaterMark;
    if (Qt || (Bt.needDrain = !0), Bt.writing || Bt.corked) {
      var nr = Bt.lastBufferedRequest;
      Bt.lastBufferedRequest = {
        chunk: Ut,
        encoding: zt,
        isBuf: Rt,
        callback: Mt,
        next: null
      }, nr ? nr.next = Bt.lastBufferedRequest : Bt.bufferedRequest = Bt.lastBufferedRequest, Bt.bufferedRequestCount += 1;
    } else
      it(Nt, Bt, !1, Gt, Ut, zt, Mt);
    return Qt;
  }
  function it(Nt, Bt, Rt, Ut, zt, Mt, kt) {
    Bt.writelen = Ut, Bt.writecb = kt, Bt.writing = !0, Bt.sync = !0, Bt.destroyed ? Bt.onwrite(new lt("write")) : Rt ? Nt._writev(zt, Bt.onwrite) : Nt._write(zt, Mt, Bt.onwrite), Bt.sync = !1;
  }
  function ke(Nt, Bt, Rt, Ut, zt) {
    --Bt.pendingcb, Rt ? (process$1.nextTick(zt, Ut), process$1.nextTick(wt, Nt, Bt), Nt._writableState.errorEmitted = !0, vt(Nt, Ut)) : (zt(Ut), Nt._writableState.errorEmitted = !0, vt(Nt, Ut), wt(Nt, Bt));
  }
  function rt(Nt) {
    Nt.writing = !1, Nt.writecb = null, Nt.length -= Nt.writelen, Nt.writelen = 0;
  }
  function ot(Nt, Bt) {
    var Rt = Nt._writableState, Ut = Rt.sync, zt = Rt.writecb;
    if (typeof zt != "function") throw new st();
    if (rt(Rt), Bt) ke(Nt, Rt, Ut, Bt, zt);
    else {
      var Mt = ut(Rt) || Nt.destroyed;
      !Mt && !Rt.corked && !Rt.bufferProcessing && Rt.bufferedRequest && bt(Nt, Rt), Ut ? process$1.nextTick(ft, Nt, Rt, Mt, zt) : ft(Nt, Rt, Mt, zt);
    }
  }
  function ft(Nt, Bt, Rt, Ut) {
    Rt || ct(Nt, Bt), Bt.pendingcb--, Ut(), wt(Nt, Bt);
  }
  function ct(Nt, Bt) {
    Bt.length === 0 && Bt.needDrain && (Bt.needDrain = !1, Nt.emit("drain"));
  }
  function bt(Nt, Bt) {
    Bt.bufferProcessing = !0;
    var Rt = Bt.bufferedRequest;
    if (Nt._writev && Rt && Rt.next) {
      var Ut = Bt.bufferedRequestCount, zt = new Array(Ut), Mt = Bt.corkedRequestsFree;
      Mt.entry = Rt;
      for (var kt = 0, Gt = !0; Rt; )
        zt[kt] = Rt, Rt.isBuf || (Gt = !1), Rt = Rt.next, kt += 1;
      zt.allBuffers = Gt, it(Nt, Bt, !0, Bt.length, zt, "", Mt.finish), Bt.pendingcb++, Bt.lastBufferedRequest = null, Mt.next ? (Bt.corkedRequestsFree = Mt.next, Mt.next = null) : Bt.corkedRequestsFree = new B(Bt), Bt.bufferedRequestCount = 0;
    } else {
      for (; Rt; ) {
        var Qt = Rt.chunk, nr = Rt.encoding, ar = Rt.callback, cr = Bt.objectMode ? 1 : Qt.length;
        if (it(Nt, Bt, !1, cr, Qt, nr, ar), Rt = Rt.next, Bt.bufferedRequestCount--, Bt.writing)
          break;
      }
      Rt === null && (Bt.lastBufferedRequest = null);
    }
    Bt.bufferedRequest = Rt, Bt.bufferProcessing = !1;
  }
  Et.prototype._write = function(Nt, Bt, Rt) {
    Rt(new Oe("_write()"));
  }, Et.prototype._writev = null, Et.prototype.end = function(Nt, Bt, Rt) {
    var Ut = this._writableState;
    return typeof Nt == "function" ? (Rt = Nt, Nt = null, Bt = null) : typeof Bt == "function" && (Rt = Bt, Bt = null), Nt != null && this.write(Nt, Bt), Ut.corked && (Ut.corked = 1, this.uncork()), Ut.ending || Ft(this, Ut, Rt), this;
  }, Object.defineProperty(Et.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ut(Nt) {
    return Nt.ending && Nt.length === 0 && Nt.bufferedRequest === null && !Nt.finished && !Nt.writing;
  }
  function gt(Nt, Bt) {
    Nt._final(function(Rt) {
      Bt.pendingcb--, Rt && vt(Nt, Rt), Bt.prefinished = !0, Nt.emit("prefinish"), wt(Nt, Bt);
    });
  }
  function dt(Nt, Bt) {
    !Bt.prefinished && !Bt.finalCalled && (typeof Nt._final == "function" && !Bt.destroyed ? (Bt.pendingcb++, Bt.finalCalled = !0, process$1.nextTick(gt, Nt, Bt)) : (Bt.prefinished = !0, Nt.emit("prefinish")));
  }
  function wt(Nt, Bt) {
    var Rt = ut(Bt);
    if (Rt && (dt(Nt, Bt), Bt.pendingcb === 0 && (Bt.finished = !0, Nt.emit("finish"), Bt.autoDestroy))) {
      var Ut = Nt._readableState;
      (!Ut || Ut.autoDestroy && Ut.endEmitted) && Nt.destroy();
    }
    return Rt;
  }
  function Ft(Nt, Bt, Rt) {
    Bt.ending = !0, wt(Nt, Bt), Rt && (Bt.finished ? process$1.nextTick(Rt) : Nt.once("finish", Rt)), Bt.ended = !0, Nt.writable = !1;
  }
  function jt(Nt, Bt, Rt) {
    var Ut = Nt.entry;
    for (Nt.entry = null; Ut; ) {
      var zt = Ut.callback;
      Bt.pendingcb--, zt(Rt), Ut = Ut.next;
    }
    Bt.corkedRequestsFree.next = Nt;
  }
  return Object.defineProperty(Et.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Bt) {
      this._writableState && (this._writableState.destroyed = Bt);
    }
  }), Et.prototype.destroy = oe.destroy, Et.prototype._undestroy = oe.undestroy, Et.prototype._destroy = function(Nt, Bt) {
    Bt(Nt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(pe) {
    var ne = [];
    for (var ce in pe) ne.push(ce);
    return ne;
  };
  _stream_duplex$1 = re;
  var L = require_stream_readable$1(), W = require_stream_writable$1();
  requireInherits_browser()(re, L);
  for (var K = B(W.prototype), J = 0; J < K.length; J++) {
    var V = K[J];
    re.prototype[V] || (re.prototype[V] = W.prototype[V]);
  }
  function re(pe) {
    if (!(this instanceof re)) return new re(pe);
    L.call(this, pe), W.call(this, pe), this.allowHalfOpen = !0, pe && (pe.readable === !1 && (this.readable = !1), pe.writable === !1 && (this.writable = !1), pe.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ie)));
  }
  Object.defineProperty(re.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(re.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(re.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ie() {
    this._writableState.ended || process$1.nextTick(oe, this);
  }
  function oe(pe) {
    pe.end();
  }
  return Object.defineProperty(re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ne) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ne, this._writableState.destroyed = ne);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var B = safeBufferExports.Buffer, L = B.isEncoding || function(pt) {
    switch (pt = "" + pt, pt && pt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function W(pt) {
    if (!pt) return "utf8";
    for (var ht; ; )
      switch (pt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return pt;
        default:
          if (ht) return;
          pt = ("" + pt).toLowerCase(), ht = !0;
      }
  }
  function K(pt) {
    var ht = W(pt);
    if (typeof ht != "string" && (B.isEncoding === L || !L(pt))) throw new Error("Unknown encoding: " + pt);
    return ht || pt;
  }
  string_decoder.StringDecoder = J;
  function J(pt) {
    this.encoding = K(pt);
    var ht;
    switch (this.encoding) {
      case "utf16le":
        this.text = ce, this.end = Ce, ht = 4;
        break;
      case "utf8":
        this.fillLast = oe, ht = 4;
        break;
      case "base64":
        this.text = Oe, this.end = st, ht = 3;
        break;
      default:
        this.write = at, this.end = lt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = B.allocUnsafe(ht);
  }
  J.prototype.write = function(pt) {
    if (pt.length === 0) return "";
    var ht, yt;
    if (this.lastNeed) {
      if (ht = this.fillLast(pt), ht === void 0) return "";
      yt = this.lastNeed, this.lastNeed = 0;
    } else
      yt = 0;
    return yt < pt.length ? ht ? ht + this.text(pt, yt) : this.text(pt, yt) : ht || "";
  }, J.prototype.end = ne, J.prototype.text = pe, J.prototype.fillLast = function(pt) {
    if (this.lastNeed <= pt.length)
      return pt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    pt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, pt.length), this.lastNeed -= pt.length;
  };
  function V(pt) {
    return pt <= 127 ? 0 : pt >> 5 === 6 ? 2 : pt >> 4 === 14 ? 3 : pt >> 3 === 30 ? 4 : pt >> 6 === 2 ? -1 : -2;
  }
  function re(pt, ht, yt) {
    var vt = ht.length - 1;
    if (vt < yt) return 0;
    var $t = V(ht[vt]);
    return $t >= 0 ? ($t > 0 && (pt.lastNeed = $t - 1), $t) : --vt < yt || $t === -2 ? 0 : ($t = V(ht[vt]), $t >= 0 ? ($t > 0 && (pt.lastNeed = $t - 2), $t) : --vt < yt || $t === -2 ? 0 : ($t = V(ht[vt]), $t >= 0 ? ($t > 0 && ($t === 2 ? $t = 0 : pt.lastNeed = $t - 3), $t) : 0));
  }
  function ie(pt, ht, yt) {
    if ((ht[0] & 192) !== 128)
      return pt.lastNeed = 0, "�";
    if (pt.lastNeed > 1 && ht.length > 1) {
      if ((ht[1] & 192) !== 128)
        return pt.lastNeed = 1, "�";
      if (pt.lastNeed > 2 && ht.length > 2 && (ht[2] & 192) !== 128)
        return pt.lastNeed = 2, "�";
    }
  }
  function oe(pt) {
    var ht = this.lastTotal - this.lastNeed, yt = ie(this, pt);
    if (yt !== void 0) return yt;
    if (this.lastNeed <= pt.length)
      return pt.copy(this.lastChar, ht, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    pt.copy(this.lastChar, ht, 0, pt.length), this.lastNeed -= pt.length;
  }
  function pe(pt, ht) {
    var yt = re(this, pt, ht);
    if (!this.lastNeed) return pt.toString("utf8", ht);
    this.lastTotal = yt;
    var vt = pt.length - (yt - this.lastNeed);
    return pt.copy(this.lastChar, 0, vt), pt.toString("utf8", ht, vt);
  }
  function ne(pt) {
    var ht = pt && pt.length ? this.write(pt) : "";
    return this.lastNeed ? ht + "�" : ht;
  }
  function ce(pt, ht) {
    if ((pt.length - ht) % 2 === 0) {
      var yt = pt.toString("utf16le", ht);
      if (yt) {
        var vt = yt.charCodeAt(yt.length - 1);
        if (vt >= 55296 && vt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = pt[pt.length - 2], this.lastChar[1] = pt[pt.length - 1], yt.slice(0, -1);
      }
      return yt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = pt[pt.length - 1], pt.toString("utf16le", ht, pt.length - 1);
  }
  function Ce(pt) {
    var ht = pt && pt.length ? this.write(pt) : "";
    if (this.lastNeed) {
      var yt = this.lastTotal - this.lastNeed;
      return ht + this.lastChar.toString("utf16le", 0, yt);
    }
    return ht;
  }
  function Oe(pt, ht) {
    var yt = (pt.length - ht) % 3;
    return yt === 0 ? pt.toString("base64", ht) : (this.lastNeed = 3 - yt, this.lastTotal = 3, yt === 1 ? this.lastChar[0] = pt[pt.length - 1] : (this.lastChar[0] = pt[pt.length - 2], this.lastChar[1] = pt[pt.length - 1]), pt.toString("base64", ht, pt.length - yt));
  }
  function st(pt) {
    var ht = pt && pt.length ? this.write(pt) : "";
    return this.lastNeed ? ht + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ht;
  }
  function at(pt) {
    return pt.toString(this.encoding);
  }
  function lt(pt) {
    return pt && pt.length ? this.write(pt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function L(V) {
    var re = !1;
    return function() {
      if (!re) {
        re = !0;
        for (var ie = arguments.length, oe = new Array(ie), pe = 0; pe < ie; pe++)
          oe[pe] = arguments[pe];
        V.apply(this, oe);
      }
    };
  }
  function W() {
  }
  function K(V) {
    return V.setHeader && typeof V.abort == "function";
  }
  function J(V, re, ie) {
    if (typeof re == "function") return J(V, null, re);
    re || (re = {}), ie = L(ie || W);
    var oe = re.readable || re.readable !== !1 && V.readable, pe = re.writable || re.writable !== !1 && V.writable, ne = function() {
      V.writable || Ce();
    }, ce = V._writableState && V._writableState.finished, Ce = function() {
      pe = !1, ce = !0, oe || ie.call(V);
    }, Oe = V._readableState && V._readableState.endEmitted, st = function() {
      oe = !1, Oe = !0, pe || ie.call(V);
    }, at = function(yt) {
      ie.call(V, yt);
    }, lt = function() {
      var yt;
      if (oe && !Oe)
        return (!V._readableState || !V._readableState.ended) && (yt = new B()), ie.call(V, yt);
      if (pe && !ce)
        return (!V._writableState || !V._writableState.ended) && (yt = new B()), ie.call(V, yt);
    }, pt = function() {
      V.req.on("finish", Ce);
    };
    return K(V) ? (V.on("complete", Ce), V.on("abort", lt), V.req ? pt() : V.on("request", pt)) : pe && !V._writableState && (V.on("end", ne), V.on("close", ne)), V.on("end", st), V.on("finish", Ce), re.error !== !1 && V.on("error", at), V.on("close", lt), function() {
      V.removeListener("complete", Ce), V.removeListener("abort", lt), V.removeListener("request", pt), V.req && V.req.removeListener("finish", Ce), V.removeListener("end", ne), V.removeListener("close", ne), V.removeListener("finish", Ce), V.removeListener("end", st), V.removeListener("error", at), V.removeListener("close", lt);
    };
  }
  return endOfStream = J, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function L(yt, vt, $t) {
    return vt = W(vt), vt in yt ? Object.defineProperty(yt, vt, { value: $t, enumerable: !0, configurable: !0, writable: !0 }) : yt[vt] = $t, yt;
  }
  function W(yt) {
    var vt = K(yt, "string");
    return typeof vt == "symbol" ? vt : String(vt);
  }
  function K(yt, vt) {
    if (typeof yt != "object" || yt === null) return yt;
    var $t = yt[Symbol.toPrimitive];
    if ($t !== void 0) {
      var xt = $t.call(yt, vt || "default");
      if (typeof xt != "object") return xt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (vt === "string" ? String : Number)(yt);
  }
  var J = requireEndOfStream(), V = Symbol("lastResolve"), re = Symbol("lastReject"), ie = Symbol("error"), oe = Symbol("ended"), pe = Symbol("lastPromise"), ne = Symbol("handlePromise"), ce = Symbol("stream");
  function Ce(yt, vt) {
    return {
      value: yt,
      done: vt
    };
  }
  function Oe(yt) {
    var vt = yt[V];
    if (vt !== null) {
      var $t = yt[ce].read();
      $t !== null && (yt[pe] = null, yt[V] = null, yt[re] = null, vt(Ce($t, !1)));
    }
  }
  function st(yt) {
    process$1.nextTick(Oe, yt);
  }
  function at(yt, vt) {
    return function($t, xt) {
      yt.then(function() {
        if (vt[oe]) {
          $t(Ce(void 0, !0));
          return;
        }
        vt[ne]($t, xt);
      }, xt);
    };
  }
  var lt = Object.getPrototypeOf(function() {
  }), pt = Object.setPrototypeOf((B = {
    get stream() {
      return this[ce];
    },
    next: function() {
      var vt = this, $t = this[ie];
      if ($t !== null)
        return Promise.reject($t);
      if (this[oe])
        return Promise.resolve(Ce(void 0, !0));
      if (this[ce].destroyed)
        return new Promise(function(St, It) {
          process$1.nextTick(function() {
            vt[ie] ? It(vt[ie]) : St(Ce(void 0, !0));
          });
        });
      var xt = this[pe], Ct;
      if (xt)
        Ct = new Promise(at(xt, this));
      else {
        var Et = this[ce].read();
        if (Et !== null)
          return Promise.resolve(Ce(Et, !1));
        Ct = new Promise(this[ne]);
      }
      return this[pe] = Ct, Ct;
    }
  }, L(B, Symbol.asyncIterator, function() {
    return this;
  }), L(B, "return", function() {
    var vt = this;
    return new Promise(function($t, xt) {
      vt[ce].destroy(null, function(Ct) {
        if (Ct) {
          xt(Ct);
          return;
        }
        $t(Ce(void 0, !0));
      });
    });
  }), B), lt), ht = function(vt) {
    var $t, xt = Object.create(pt, ($t = {}, L($t, ce, {
      value: vt,
      writable: !0
    }), L($t, V, {
      value: null,
      writable: !0
    }), L($t, re, {
      value: null,
      writable: !0
    }), L($t, ie, {
      value: null,
      writable: !0
    }), L($t, oe, {
      value: vt._readableState.endEmitted,
      writable: !0
    }), L($t, ne, {
      value: function(Et, St) {
        var It = xt[ce].read();
        It ? (xt[pe] = null, xt[V] = null, xt[re] = null, Et(Ce(It, !1))) : (xt[V] = Et, xt[re] = St);
      },
      writable: !0
    }), $t));
    return xt[pe] = null, J(vt, function(Ct) {
      if (Ct && Ct.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Et = xt[re];
        Et !== null && (xt[pe] = null, xt[V] = null, xt[re] = null, Et(Ct)), xt[ie] = Ct;
        return;
      }
      var St = xt[V];
      St !== null && (xt[pe] = null, xt[V] = null, xt[re] = null, St(Ce(void 0, !0))), xt[oe] = !0;
    }), vt.on("readable", st.bind(null, xt)), xt;
  };
  return async_iterator = ht, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = St;
  var B;
  St.ReadableState = Et, requireEvents().EventEmitter;
  var L = function(kt, Gt) {
    return kt.listeners(Gt).length;
  }, W = requireStreamBrowser$1(), K = require$$1$2.Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function V(Mt) {
    return K.from(Mt);
  }
  function re(Mt) {
    return K.isBuffer(Mt) || Mt instanceof J;
  }
  var ie = requireUtil$1(), oe;
  ie && ie.debuglog ? oe = ie.debuglog("stream") : oe = function() {
  };
  var pe = requireBuffer_list(), ne = requireDestroy$1(), ce = requireState(), Ce = ce.getHighWaterMark, Oe = requireErrorsBrowser().codes, st = Oe.ERR_INVALID_ARG_TYPE, at = Oe.ERR_STREAM_PUSH_AFTER_EOF, lt = Oe.ERR_METHOD_NOT_IMPLEMENTED, pt = Oe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ht, yt, vt;
  requireInherits_browser()(St, W);
  var $t = ne.errorOrDestroy, xt = ["error", "close", "destroy", "pause", "resume"];
  function Ct(Mt, kt, Gt) {
    if (typeof Mt.prependListener == "function") return Mt.prependListener(kt, Gt);
    !Mt._events || !Mt._events[kt] ? Mt.on(kt, Gt) : Array.isArray(Mt._events[kt]) ? Mt._events[kt].unshift(Gt) : Mt._events[kt] = [Gt, Mt._events[kt]];
  }
  function Et(Mt, kt, Gt) {
    B = B || require_stream_duplex$1(), Mt = Mt || {}, typeof Gt != "boolean" && (Gt = kt instanceof B), this.objectMode = !!Mt.objectMode, Gt && (this.objectMode = this.objectMode || !!Mt.readableObjectMode), this.highWaterMark = Ce(this, Mt, "readableHighWaterMark", Gt), this.buffer = new pe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Mt.emitClose !== !1, this.autoDestroy = !!Mt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Mt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Mt.encoding && (ht || (ht = requireString_decoder().StringDecoder), this.decoder = new ht(Mt.encoding), this.encoding = Mt.encoding);
  }
  function St(Mt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof St)) return new St(Mt);
    var kt = this instanceof B;
    this._readableState = new Et(Mt, this, kt), this.readable = !0, Mt && (typeof Mt.read == "function" && (this._read = Mt.read), typeof Mt.destroy == "function" && (this._destroy = Mt.destroy)), W.call(this);
  }
  Object.defineProperty(St.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(kt) {
      this._readableState && (this._readableState.destroyed = kt);
    }
  }), St.prototype.destroy = ne.destroy, St.prototype._undestroy = ne.undestroy, St.prototype._destroy = function(Mt, kt) {
    kt(Mt);
  }, St.prototype.push = function(Mt, kt) {
    var Gt = this._readableState, Qt;
    return Gt.objectMode ? Qt = !0 : typeof Mt == "string" && (kt = kt || Gt.defaultEncoding, kt !== Gt.encoding && (Mt = K.from(Mt, kt), kt = ""), Qt = !0), It(this, Mt, kt, !1, Qt);
  }, St.prototype.unshift = function(Mt) {
    return It(this, Mt, null, !0, !1);
  };
  function It(Mt, kt, Gt, Qt, nr) {
    oe("readableAddChunk", kt);
    var ar = Mt._readableState;
    if (kt === null)
      ar.reading = !1, ot(Mt, ar);
    else {
      var cr;
      if (nr || (cr = nt(ar, kt)), cr)
        $t(Mt, cr);
      else if (ar.objectMode || kt && kt.length > 0)
        if (typeof kt != "string" && !ar.objectMode && Object.getPrototypeOf(kt) !== K.prototype && (kt = V(kt)), Qt)
          ar.endEmitted ? $t(Mt, new pt()) : Tt(Mt, ar, kt, !0);
        else if (ar.ended)
          $t(Mt, new at());
        else {
          if (ar.destroyed)
            return !1;
          ar.reading = !1, ar.decoder && !Gt ? (kt = ar.decoder.write(kt), ar.objectMode || kt.length !== 0 ? Tt(Mt, ar, kt, !1) : bt(Mt, ar)) : Tt(Mt, ar, kt, !1);
        }
      else Qt || (ar.reading = !1, bt(Mt, ar));
    }
    return !ar.ended && (ar.length < ar.highWaterMark || ar.length === 0);
  }
  function Tt(Mt, kt, Gt, Qt) {
    kt.flowing && kt.length === 0 && !kt.sync ? (kt.awaitDrain = 0, Mt.emit("data", Gt)) : (kt.length += kt.objectMode ? 1 : Gt.length, Qt ? kt.buffer.unshift(Gt) : kt.buffer.push(Gt), kt.needReadable && ft(Mt)), bt(Mt, kt);
  }
  function nt(Mt, kt) {
    var Gt;
    return !re(kt) && typeof kt != "string" && kt !== void 0 && !Mt.objectMode && (Gt = new st("chunk", ["string", "Buffer", "Uint8Array"], kt)), Gt;
  }
  St.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, St.prototype.setEncoding = function(Mt) {
    ht || (ht = requireString_decoder().StringDecoder);
    var kt = new ht(Mt);
    this._readableState.decoder = kt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Gt = this._readableState.buffer.head, Qt = ""; Gt !== null; )
      Qt += kt.write(Gt.data), Gt = Gt.next;
    return this._readableState.buffer.clear(), Qt !== "" && this._readableState.buffer.push(Qt), this._readableState.length = Qt.length, this;
  };
  var it = 1073741824;
  function ke(Mt) {
    return Mt >= it ? Mt = it : (Mt--, Mt |= Mt >>> 1, Mt |= Mt >>> 2, Mt |= Mt >>> 4, Mt |= Mt >>> 8, Mt |= Mt >>> 16, Mt++), Mt;
  }
  function rt(Mt, kt) {
    return Mt <= 0 || kt.length === 0 && kt.ended ? 0 : kt.objectMode ? 1 : Mt !== Mt ? kt.flowing && kt.length ? kt.buffer.head.data.length : kt.length : (Mt > kt.highWaterMark && (kt.highWaterMark = ke(Mt)), Mt <= kt.length ? Mt : kt.ended ? kt.length : (kt.needReadable = !0, 0));
  }
  St.prototype.read = function(Mt) {
    oe("read", Mt), Mt = parseInt(Mt, 10);
    var kt = this._readableState, Gt = Mt;
    if (Mt !== 0 && (kt.emittedReadable = !1), Mt === 0 && kt.needReadable && ((kt.highWaterMark !== 0 ? kt.length >= kt.highWaterMark : kt.length > 0) || kt.ended))
      return oe("read: emitReadable", kt.length, kt.ended), kt.length === 0 && kt.ended ? Rt(this) : ft(this), null;
    if (Mt = rt(Mt, kt), Mt === 0 && kt.ended)
      return kt.length === 0 && Rt(this), null;
    var Qt = kt.needReadable;
    oe("need readable", Qt), (kt.length === 0 || kt.length - Mt < kt.highWaterMark) && (Qt = !0, oe("length less than watermark", Qt)), kt.ended || kt.reading ? (Qt = !1, oe("reading or ended", Qt)) : Qt && (oe("do read"), kt.reading = !0, kt.sync = !0, kt.length === 0 && (kt.needReadable = !0), this._read(kt.highWaterMark), kt.sync = !1, kt.reading || (Mt = rt(Gt, kt)));
    var nr;
    return Mt > 0 ? nr = Bt(Mt, kt) : nr = null, nr === null ? (kt.needReadable = kt.length <= kt.highWaterMark, Mt = 0) : (kt.length -= Mt, kt.awaitDrain = 0), kt.length === 0 && (kt.ended || (kt.needReadable = !0), Gt !== Mt && kt.ended && Rt(this)), nr !== null && this.emit("data", nr), nr;
  };
  function ot(Mt, kt) {
    if (oe("onEofChunk"), !kt.ended) {
      if (kt.decoder) {
        var Gt = kt.decoder.end();
        Gt && Gt.length && (kt.buffer.push(Gt), kt.length += kt.objectMode ? 1 : Gt.length);
      }
      kt.ended = !0, kt.sync ? ft(Mt) : (kt.needReadable = !1, kt.emittedReadable || (kt.emittedReadable = !0, ct(Mt)));
    }
  }
  function ft(Mt) {
    var kt = Mt._readableState;
    oe("emitReadable", kt.needReadable, kt.emittedReadable), kt.needReadable = !1, kt.emittedReadable || (oe("emitReadable", kt.flowing), kt.emittedReadable = !0, process$1.nextTick(ct, Mt));
  }
  function ct(Mt) {
    var kt = Mt._readableState;
    oe("emitReadable_", kt.destroyed, kt.length, kt.ended), !kt.destroyed && (kt.length || kt.ended) && (Mt.emit("readable"), kt.emittedReadable = !1), kt.needReadable = !kt.flowing && !kt.ended && kt.length <= kt.highWaterMark, Nt(Mt);
  }
  function bt(Mt, kt) {
    kt.readingMore || (kt.readingMore = !0, process$1.nextTick(ut, Mt, kt));
  }
  function ut(Mt, kt) {
    for (; !kt.reading && !kt.ended && (kt.length < kt.highWaterMark || kt.flowing && kt.length === 0); ) {
      var Gt = kt.length;
      if (oe("maybeReadMore read 0"), Mt.read(0), Gt === kt.length)
        break;
    }
    kt.readingMore = !1;
  }
  St.prototype._read = function(Mt) {
    $t(this, new lt("_read()"));
  }, St.prototype.pipe = function(Mt, kt) {
    var Gt = this, Qt = this._readableState;
    switch (Qt.pipesCount) {
      case 0:
        Qt.pipes = Mt;
        break;
      case 1:
        Qt.pipes = [Qt.pipes, Mt];
        break;
      default:
        Qt.pipes.push(Mt);
        break;
    }
    Qt.pipesCount += 1, oe("pipe count=%d opts=%j", Qt.pipesCount, kt);
    var nr = (!kt || kt.end !== !1) && Mt !== process$1.stdout && Mt !== process$1.stderr, ar = nr ? hr : kr;
    Qt.endEmitted ? process$1.nextTick(ar) : Gt.once("end", ar), Mt.on("unpipe", cr);
    function cr(vr, Mr) {
      oe("onunpipe"), vr === Gt && Mr && Mr.hasUnpiped === !1 && (Mr.hasUnpiped = !0, dr());
    }
    function hr() {
      oe("onend"), Mt.end();
    }
    var Jt = gt(Gt);
    Mt.on("drain", Jt);
    var Pr = !1;
    function dr() {
      oe("cleanup"), Mt.removeListener("close", pr), Mt.removeListener("finish", $r), Mt.removeListener("drain", Jt), Mt.removeListener("error", Rr), Mt.removeListener("unpipe", cr), Gt.removeListener("end", hr), Gt.removeListener("end", kr), Gt.removeListener("data", Tr), Pr = !0, Qt.awaitDrain && (!Mt._writableState || Mt._writableState.needDrain) && Jt();
    }
    Gt.on("data", Tr);
    function Tr(vr) {
      oe("ondata");
      var Mr = Mt.write(vr);
      oe("dest.write", Mr), Mr === !1 && ((Qt.pipesCount === 1 && Qt.pipes === Mt || Qt.pipesCount > 1 && zt(Qt.pipes, Mt) !== -1) && !Pr && (oe("false write response, pause", Qt.awaitDrain), Qt.awaitDrain++), Gt.pause());
    }
    function Rr(vr) {
      oe("onerror", vr), kr(), Mt.removeListener("error", Rr), L(Mt, "error") === 0 && $t(Mt, vr);
    }
    Ct(Mt, "error", Rr);
    function pr() {
      Mt.removeListener("finish", $r), kr();
    }
    Mt.once("close", pr);
    function $r() {
      oe("onfinish"), Mt.removeListener("close", pr), kr();
    }
    Mt.once("finish", $r);
    function kr() {
      oe("unpipe"), Gt.unpipe(Mt);
    }
    return Mt.emit("pipe", Gt), Qt.flowing || (oe("pipe resume"), Gt.resume()), Mt;
  };
  function gt(Mt) {
    return function() {
      var Gt = Mt._readableState;
      oe("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && L(Mt, "data") && (Gt.flowing = !0, Nt(Mt));
    };
  }
  St.prototype.unpipe = function(Mt) {
    var kt = this._readableState, Gt = {
      hasUnpiped: !1
    };
    if (kt.pipesCount === 0) return this;
    if (kt.pipesCount === 1)
      return Mt && Mt !== kt.pipes ? this : (Mt || (Mt = kt.pipes), kt.pipes = null, kt.pipesCount = 0, kt.flowing = !1, Mt && Mt.emit("unpipe", this, Gt), this);
    if (!Mt) {
      var Qt = kt.pipes, nr = kt.pipesCount;
      kt.pipes = null, kt.pipesCount = 0, kt.flowing = !1;
      for (var ar = 0; ar < nr; ar++) Qt[ar].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var cr = zt(kt.pipes, Mt);
    return cr === -1 ? this : (kt.pipes.splice(cr, 1), kt.pipesCount -= 1, kt.pipesCount === 1 && (kt.pipes = kt.pipes[0]), Mt.emit("unpipe", this, Gt), this);
  }, St.prototype.on = function(Mt, kt) {
    var Gt = W.prototype.on.call(this, Mt, kt), Qt = this._readableState;
    return Mt === "data" ? (Qt.readableListening = this.listenerCount("readable") > 0, Qt.flowing !== !1 && this.resume()) : Mt === "readable" && !Qt.endEmitted && !Qt.readableListening && (Qt.readableListening = Qt.needReadable = !0, Qt.flowing = !1, Qt.emittedReadable = !1, oe("on readable", Qt.length, Qt.reading), Qt.length ? ft(this) : Qt.reading || process$1.nextTick(wt, this)), Gt;
  }, St.prototype.addListener = St.prototype.on, St.prototype.removeListener = function(Mt, kt) {
    var Gt = W.prototype.removeListener.call(this, Mt, kt);
    return Mt === "readable" && process$1.nextTick(dt, this), Gt;
  }, St.prototype.removeAllListeners = function(Mt) {
    var kt = W.prototype.removeAllListeners.apply(this, arguments);
    return (Mt === "readable" || Mt === void 0) && process$1.nextTick(dt, this), kt;
  };
  function dt(Mt) {
    var kt = Mt._readableState;
    kt.readableListening = Mt.listenerCount("readable") > 0, kt.resumeScheduled && !kt.paused ? kt.flowing = !0 : Mt.listenerCount("data") > 0 && Mt.resume();
  }
  function wt(Mt) {
    oe("readable nexttick read 0"), Mt.read(0);
  }
  St.prototype.resume = function() {
    var Mt = this._readableState;
    return Mt.flowing || (oe("resume"), Mt.flowing = !Mt.readableListening, Ft(this, Mt)), Mt.paused = !1, this;
  };
  function Ft(Mt, kt) {
    kt.resumeScheduled || (kt.resumeScheduled = !0, process$1.nextTick(jt, Mt, kt));
  }
  function jt(Mt, kt) {
    oe("resume", kt.reading), kt.reading || Mt.read(0), kt.resumeScheduled = !1, Mt.emit("resume"), Nt(Mt), kt.flowing && !kt.reading && Mt.read(0);
  }
  St.prototype.pause = function() {
    return oe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (oe("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Nt(Mt) {
    var kt = Mt._readableState;
    for (oe("flow", kt.flowing); kt.flowing && Mt.read() !== null; ) ;
  }
  St.prototype.wrap = function(Mt) {
    var kt = this, Gt = this._readableState, Qt = !1;
    Mt.on("end", function() {
      if (oe("wrapped end"), Gt.decoder && !Gt.ended) {
        var cr = Gt.decoder.end();
        cr && cr.length && kt.push(cr);
      }
      kt.push(null);
    }), Mt.on("data", function(cr) {
      if (oe("wrapped data"), Gt.decoder && (cr = Gt.decoder.write(cr)), !(Gt.objectMode && cr == null) && !(!Gt.objectMode && (!cr || !cr.length))) {
        var hr = kt.push(cr);
        hr || (Qt = !0, Mt.pause());
      }
    });
    for (var nr in Mt)
      this[nr] === void 0 && typeof Mt[nr] == "function" && (this[nr] = /* @__PURE__ */ function(hr) {
        return function() {
          return Mt[hr].apply(Mt, arguments);
        };
      }(nr));
    for (var ar = 0; ar < xt.length; ar++)
      Mt.on(xt[ar], this.emit.bind(this, xt[ar]));
    return this._read = function(cr) {
      oe("wrapped _read", cr), Qt && (Qt = !1, Mt.resume());
    }, this;
  }, typeof Symbol == "function" && (St.prototype[Symbol.asyncIterator] = function() {
    return yt === void 0 && (yt = requireAsync_iterator()), yt(this);
  }), Object.defineProperty(St.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(St.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(St.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(kt) {
      this._readableState && (this._readableState.flowing = kt);
    }
  }), St._fromList = Bt, Object.defineProperty(St.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Bt(Mt, kt) {
    if (kt.length === 0) return null;
    var Gt;
    return kt.objectMode ? Gt = kt.buffer.shift() : !Mt || Mt >= kt.length ? (kt.decoder ? Gt = kt.buffer.join("") : kt.buffer.length === 1 ? Gt = kt.buffer.first() : Gt = kt.buffer.concat(kt.length), kt.buffer.clear()) : Gt = kt.buffer.consume(Mt, kt.decoder), Gt;
  }
  function Rt(Mt) {
    var kt = Mt._readableState;
    oe("endReadable", kt.endEmitted), kt.endEmitted || (kt.ended = !0, process$1.nextTick(Ut, kt, Mt));
  }
  function Ut(Mt, kt) {
    if (oe("endReadableNT", Mt.endEmitted, Mt.length), !Mt.endEmitted && Mt.length === 0 && (Mt.endEmitted = !0, kt.readable = !1, kt.emit("end"), Mt.autoDestroy)) {
      var Gt = kt._writableState;
      (!Gt || Gt.autoDestroy && Gt.finished) && kt.destroy();
    }
  }
  typeof Symbol == "function" && (St.from = function(Mt, kt) {
    return vt === void 0 && (vt = requireFromBrowser()), vt(St, Mt, kt);
  });
  function zt(Mt, kt) {
    for (var Gt = 0, Qt = Mt.length; Gt < Qt; Gt++)
      if (Mt[Gt] === kt) return Gt;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ie;
  var B = requireErrorsBrowser().codes, L = B.ERR_METHOD_NOT_IMPLEMENTED, W = B.ERR_MULTIPLE_CALLBACK, K = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, J = B.ERR_TRANSFORM_WITH_LENGTH_0, V = require_stream_duplex$1();
  requireInherits_browser()(ie, V);
  function re(ne, ce) {
    var Ce = this._transformState;
    Ce.transforming = !1;
    var Oe = Ce.writecb;
    if (Oe === null)
      return this.emit("error", new W());
    Ce.writechunk = null, Ce.writecb = null, ce != null && this.push(ce), Oe(ne);
    var st = this._readableState;
    st.reading = !1, (st.needReadable || st.length < st.highWaterMark) && this._read(st.highWaterMark);
  }
  function ie(ne) {
    if (!(this instanceof ie)) return new ie(ne);
    V.call(this, ne), this._transformState = {
      afterTransform: re.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, ne && (typeof ne.transform == "function" && (this._transform = ne.transform), typeof ne.flush == "function" && (this._flush = ne.flush)), this.on("prefinish", oe);
  }
  function oe() {
    var ne = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(ce, Ce) {
      pe(ne, ce, Ce);
    }) : pe(this, null, null);
  }
  ie.prototype.push = function(ne, ce) {
    return this._transformState.needTransform = !1, V.prototype.push.call(this, ne, ce);
  }, ie.prototype._transform = function(ne, ce, Ce) {
    Ce(new L("_transform()"));
  }, ie.prototype._write = function(ne, ce, Ce) {
    var Oe = this._transformState;
    if (Oe.writecb = Ce, Oe.writechunk = ne, Oe.writeencoding = ce, !Oe.transforming) {
      var st = this._readableState;
      (Oe.needTransform || st.needReadable || st.length < st.highWaterMark) && this._read(st.highWaterMark);
    }
  }, ie.prototype._read = function(ne) {
    var ce = this._transformState;
    ce.writechunk !== null && !ce.transforming ? (ce.transforming = !0, this._transform(ce.writechunk, ce.writeencoding, ce.afterTransform)) : ce.needTransform = !0;
  }, ie.prototype._destroy = function(ne, ce) {
    V.prototype._destroy.call(this, ne, function(Ce) {
      ce(Ce);
    });
  };
  function pe(ne, ce, Ce) {
    if (ce) return ne.emit("error", ce);
    if (Ce != null && ne.push(Ce), ne._writableState.length) throw new J();
    if (ne._transformState.transforming) throw new K();
    return ne.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = L;
  var B = require_stream_transform$1();
  requireInherits_browser()(L, B);
  function L(W) {
    if (!(this instanceof L)) return new L(W);
    B.call(this, W);
  }
  return L.prototype._transform = function(W, K, J) {
    J(null, W);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var B;
  function L(Ce) {
    var Oe = !1;
    return function() {
      Oe || (Oe = !0, Ce.apply(void 0, arguments));
    };
  }
  var W = requireErrorsBrowser().codes, K = W.ERR_MISSING_ARGS, J = W.ERR_STREAM_DESTROYED;
  function V(Ce) {
    if (Ce) throw Ce;
  }
  function re(Ce) {
    return Ce.setHeader && typeof Ce.abort == "function";
  }
  function ie(Ce, Oe, st, at) {
    at = L(at);
    var lt = !1;
    Ce.on("close", function() {
      lt = !0;
    }), B === void 0 && (B = requireEndOfStream()), B(Ce, {
      readable: Oe,
      writable: st
    }, function(ht) {
      if (ht) return at(ht);
      lt = !0, at();
    });
    var pt = !1;
    return function(ht) {
      if (!lt && !pt) {
        if (pt = !0, re(Ce)) return Ce.abort();
        if (typeof Ce.destroy == "function") return Ce.destroy();
        at(ht || new J("pipe"));
      }
    };
  }
  function oe(Ce) {
    Ce();
  }
  function pe(Ce, Oe) {
    return Ce.pipe(Oe);
  }
  function ne(Ce) {
    return !Ce.length || typeof Ce[Ce.length - 1] != "function" ? V : Ce.pop();
  }
  function ce() {
    for (var Ce = arguments.length, Oe = new Array(Ce), st = 0; st < Ce; st++)
      Oe[st] = arguments[st];
    var at = ne(Oe);
    if (Array.isArray(Oe[0]) && (Oe = Oe[0]), Oe.length < 2)
      throw new K("streams");
    var lt, pt = Oe.map(function(ht, yt) {
      var vt = yt < Oe.length - 1, $t = yt > 0;
      return ie(ht, vt, $t, function(xt) {
        lt || (lt = xt), xt && pt.forEach(oe), !vt && (pt.forEach(oe), at(lt));
      });
    });
    return Oe.reduce(pe);
  }
  return pipeline_1 = ce, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(B, L) {
    L = B.exports = require_stream_readable$1(), L.Stream = L, L.Readable = L, L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var B = safeBufferExports.Buffer, L = requireReadableBrowser$1().Transform, W = requireInherits_browser();
  function K(V, re) {
    if (!B.isBuffer(V) && typeof V != "string")
      throw new TypeError(re + " must be a string or a buffer");
  }
  function J(V) {
    L.call(this), this._block = B.allocUnsafe(V), this._blockSize = V, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return W(J, L), J.prototype._transform = function(V, re, ie) {
    var oe = null;
    try {
      this.update(V, re);
    } catch (pe) {
      oe = pe;
    }
    ie(oe);
  }, J.prototype._flush = function(V) {
    var re = null;
    try {
      this.push(this.digest());
    } catch (ie) {
      re = ie;
    }
    V(re);
  }, J.prototype.update = function(V, re) {
    if (K(V, "Data"), this._finalized) throw new Error("Digest already called");
    B.isBuffer(V) || (V = B.from(V, re));
    for (var ie = this._block, oe = 0; this._blockOffset + V.length - oe >= this._blockSize; ) {
      for (var pe = this._blockOffset; pe < this._blockSize; ) ie[pe++] = V[oe++];
      this._update(), this._blockOffset = 0;
    }
    for (; oe < V.length; ) ie[this._blockOffset++] = V[oe++];
    for (var ne = 0, ce = V.length * 8; ce > 0; ++ne)
      this._length[ne] += ce, ce = this._length[ne] / 4294967296 | 0, ce > 0 && (this._length[ne] -= 4294967296 * ce);
    return this;
  }, J.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, J.prototype.digest = function(V) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var re = this._digest();
    V !== void 0 && (re = re.toString(V)), this._block.fill(0), this._blockOffset = 0;
    for (var ie = 0; ie < 4; ++ie) this._length[ie] = 0;
    return re;
  }, J.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = J, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var B = requireInherits_browser(), L = requireHashBase(), W = safeBufferExports.Buffer, K = new Array(16);
  function J() {
    L.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  B(J, L), J.prototype._update = function() {
    for (var ne = K, ce = 0; ce < 16; ++ce) ne[ce] = this._block.readInt32LE(ce * 4);
    var Ce = this._a, Oe = this._b, st = this._c, at = this._d;
    Ce = re(Ce, Oe, st, at, ne[0], 3614090360, 7), at = re(at, Ce, Oe, st, ne[1], 3905402710, 12), st = re(st, at, Ce, Oe, ne[2], 606105819, 17), Oe = re(Oe, st, at, Ce, ne[3], 3250441966, 22), Ce = re(Ce, Oe, st, at, ne[4], 4118548399, 7), at = re(at, Ce, Oe, st, ne[5], 1200080426, 12), st = re(st, at, Ce, Oe, ne[6], 2821735955, 17), Oe = re(Oe, st, at, Ce, ne[7], 4249261313, 22), Ce = re(Ce, Oe, st, at, ne[8], 1770035416, 7), at = re(at, Ce, Oe, st, ne[9], 2336552879, 12), st = re(st, at, Ce, Oe, ne[10], 4294925233, 17), Oe = re(Oe, st, at, Ce, ne[11], 2304563134, 22), Ce = re(Ce, Oe, st, at, ne[12], 1804603682, 7), at = re(at, Ce, Oe, st, ne[13], 4254626195, 12), st = re(st, at, Ce, Oe, ne[14], 2792965006, 17), Oe = re(Oe, st, at, Ce, ne[15], 1236535329, 22), Ce = ie(Ce, Oe, st, at, ne[1], 4129170786, 5), at = ie(at, Ce, Oe, st, ne[6], 3225465664, 9), st = ie(st, at, Ce, Oe, ne[11], 643717713, 14), Oe = ie(Oe, st, at, Ce, ne[0], 3921069994, 20), Ce = ie(Ce, Oe, st, at, ne[5], 3593408605, 5), at = ie(at, Ce, Oe, st, ne[10], 38016083, 9), st = ie(st, at, Ce, Oe, ne[15], 3634488961, 14), Oe = ie(Oe, st, at, Ce, ne[4], 3889429448, 20), Ce = ie(Ce, Oe, st, at, ne[9], 568446438, 5), at = ie(at, Ce, Oe, st, ne[14], 3275163606, 9), st = ie(st, at, Ce, Oe, ne[3], 4107603335, 14), Oe = ie(Oe, st, at, Ce, ne[8], 1163531501, 20), Ce = ie(Ce, Oe, st, at, ne[13], 2850285829, 5), at = ie(at, Ce, Oe, st, ne[2], 4243563512, 9), st = ie(st, at, Ce, Oe, ne[7], 1735328473, 14), Oe = ie(Oe, st, at, Ce, ne[12], 2368359562, 20), Ce = oe(Ce, Oe, st, at, ne[5], 4294588738, 4), at = oe(at, Ce, Oe, st, ne[8], 2272392833, 11), st = oe(st, at, Ce, Oe, ne[11], 1839030562, 16), Oe = oe(Oe, st, at, Ce, ne[14], 4259657740, 23), Ce = oe(Ce, Oe, st, at, ne[1], 2763975236, 4), at = oe(at, Ce, Oe, st, ne[4], 1272893353, 11), st = oe(st, at, Ce, Oe, ne[7], 4139469664, 16), Oe = oe(Oe, st, at, Ce, ne[10], 3200236656, 23), Ce = oe(Ce, Oe, st, at, ne[13], 681279174, 4), at = oe(at, Ce, Oe, st, ne[0], 3936430074, 11), st = oe(st, at, Ce, Oe, ne[3], 3572445317, 16), Oe = oe(Oe, st, at, Ce, ne[6], 76029189, 23), Ce = oe(Ce, Oe, st, at, ne[9], 3654602809, 4), at = oe(at, Ce, Oe, st, ne[12], 3873151461, 11), st = oe(st, at, Ce, Oe, ne[15], 530742520, 16), Oe = oe(Oe, st, at, Ce, ne[2], 3299628645, 23), Ce = pe(Ce, Oe, st, at, ne[0], 4096336452, 6), at = pe(at, Ce, Oe, st, ne[7], 1126891415, 10), st = pe(st, at, Ce, Oe, ne[14], 2878612391, 15), Oe = pe(Oe, st, at, Ce, ne[5], 4237533241, 21), Ce = pe(Ce, Oe, st, at, ne[12], 1700485571, 6), at = pe(at, Ce, Oe, st, ne[3], 2399980690, 10), st = pe(st, at, Ce, Oe, ne[10], 4293915773, 15), Oe = pe(Oe, st, at, Ce, ne[1], 2240044497, 21), Ce = pe(Ce, Oe, st, at, ne[8], 1873313359, 6), at = pe(at, Ce, Oe, st, ne[15], 4264355552, 10), st = pe(st, at, Ce, Oe, ne[6], 2734768916, 15), Oe = pe(Oe, st, at, Ce, ne[13], 1309151649, 21), Ce = pe(Ce, Oe, st, at, ne[4], 4149444226, 6), at = pe(at, Ce, Oe, st, ne[11], 3174756917, 10), st = pe(st, at, Ce, Oe, ne[2], 718787259, 15), Oe = pe(Oe, st, at, Ce, ne[9], 3951481745, 21), this._a = this._a + Ce | 0, this._b = this._b + Oe | 0, this._c = this._c + st | 0, this._d = this._d + at | 0;
  }, J.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var ne = W.allocUnsafe(16);
    return ne.writeInt32LE(this._a, 0), ne.writeInt32LE(this._b, 4), ne.writeInt32LE(this._c, 8), ne.writeInt32LE(this._d, 12), ne;
  };
  function V(ne, ce) {
    return ne << ce | ne >>> 32 - ce;
  }
  function re(ne, ce, Ce, Oe, st, at, lt) {
    return V(ne + (ce & Ce | ~ce & Oe) + st + at | 0, lt) + ce | 0;
  }
  function ie(ne, ce, Ce, Oe, st, at, lt) {
    return V(ne + (ce & Oe | Ce & ~Oe) + st + at | 0, lt) + ce | 0;
  }
  function oe(ne, ce, Ce, Oe, st, at, lt) {
    return V(ne + (ce ^ Ce ^ Oe) + st + at | 0, lt) + ce | 0;
  }
  function pe(ne, ce, Ce, Oe, st, at, lt) {
    return V(ne + (Ce ^ (ce | ~Oe)) + st + at | 0, lt) + ce | 0;
  }
  return md5_js = J, md5_js;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var B = require$$1$2.Buffer, L = requireInherits_browser(), W = requireHashBase(), K = new Array(16), J = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], V = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], re = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ie = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], oe = [0, 1518500249, 1859775393, 2400959708, 2840853838], pe = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function ne() {
    W.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  L(ne, W), ne.prototype._update = function() {
    for (var pt = K, ht = 0; ht < 16; ++ht) pt[ht] = this._block.readInt32LE(ht * 4);
    for (var yt = this._a | 0, vt = this._b | 0, $t = this._c | 0, xt = this._d | 0, Ct = this._e | 0, Et = this._a | 0, St = this._b | 0, It = this._c | 0, Tt = this._d | 0, nt = this._e | 0, it = 0; it < 80; it += 1) {
      var ke, rt;
      it < 16 ? (ke = Ce(yt, vt, $t, xt, Ct, pt[J[it]], oe[0], re[it]), rt = lt(Et, St, It, Tt, nt, pt[V[it]], pe[0], ie[it])) : it < 32 ? (ke = Oe(yt, vt, $t, xt, Ct, pt[J[it]], oe[1], re[it]), rt = at(Et, St, It, Tt, nt, pt[V[it]], pe[1], ie[it])) : it < 48 ? (ke = st(yt, vt, $t, xt, Ct, pt[J[it]], oe[2], re[it]), rt = st(Et, St, It, Tt, nt, pt[V[it]], pe[2], ie[it])) : it < 64 ? (ke = at(yt, vt, $t, xt, Ct, pt[J[it]], oe[3], re[it]), rt = Oe(Et, St, It, Tt, nt, pt[V[it]], pe[3], ie[it])) : (ke = lt(yt, vt, $t, xt, Ct, pt[J[it]], oe[4], re[it]), rt = Ce(Et, St, It, Tt, nt, pt[V[it]], pe[4], ie[it])), yt = Ct, Ct = xt, xt = ce($t, 10), $t = vt, vt = ke, Et = nt, nt = Tt, Tt = ce(It, 10), It = St, St = rt;
    }
    var ot = this._b + $t + Tt | 0;
    this._b = this._c + xt + nt | 0, this._c = this._d + Ct + Et | 0, this._d = this._e + yt + St | 0, this._e = this._a + vt + It | 0, this._a = ot;
  }, ne.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var pt = B.alloc ? B.alloc(20) : new B(20);
    return pt.writeInt32LE(this._a, 0), pt.writeInt32LE(this._b, 4), pt.writeInt32LE(this._c, 8), pt.writeInt32LE(this._d, 12), pt.writeInt32LE(this._e, 16), pt;
  };
  function ce(pt, ht) {
    return pt << ht | pt >>> 32 - ht;
  }
  function Ce(pt, ht, yt, vt, $t, xt, Ct, Et) {
    return ce(pt + (ht ^ yt ^ vt) + xt + Ct | 0, Et) + $t | 0;
  }
  function Oe(pt, ht, yt, vt, $t, xt, Ct, Et) {
    return ce(pt + (ht & yt | ~ht & vt) + xt + Ct | 0, Et) + $t | 0;
  }
  function st(pt, ht, yt, vt, $t, xt, Ct, Et) {
    return ce(pt + ((ht | ~yt) ^ vt) + xt + Ct | 0, Et) + $t | 0;
  }
  function at(pt, ht, yt, vt, $t, xt, Ct, Et) {
    return ce(pt + (ht & vt | yt & ~vt) + xt + Ct | 0, Et) + $t | 0;
  }
  function lt(pt, ht, yt, vt, $t, xt, Ct, Et) {
    return ce(pt + (ht ^ (yt | ~vt)) + xt + Ct | 0, Et) + $t | 0;
  }
  return ripemd160 = ne, ripemd160;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var B = safeBufferExports.Buffer;
  function L(W, K) {
    this._block = B.alloc(W), this._finalSize = K, this._blockSize = W, this._len = 0;
  }
  return L.prototype.update = function(W, K) {
    typeof W == "string" && (K = K || "utf8", W = B.from(W, K));
    for (var J = this._block, V = this._blockSize, re = W.length, ie = this._len, oe = 0; oe < re; ) {
      for (var pe = ie % V, ne = Math.min(re - oe, V - pe), ce = 0; ce < ne; ce++)
        J[pe + ce] = W[oe + ce];
      ie += ne, oe += ne, ie % V === 0 && this._update(J);
    }
    return this._len += re, this;
  }, L.prototype.digest = function(W) {
    var K = this._len % this._blockSize;
    this._block[K] = 128, this._block.fill(0, K + 1), K >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var J = this._len * 8;
    if (J <= 4294967295)
      this._block.writeUInt32BE(J, this._blockSize - 4);
    else {
      var V = (J & 4294967295) >>> 0, re = (J - V) / 4294967296;
      this._block.writeUInt32BE(re, this._blockSize - 8), this._block.writeUInt32BE(V, this._blockSize - 4);
    }
    this._update(this._block);
    var ie = this._hash();
    return W ? ie.toString(W) : ie;
  }, L.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = L, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], J = new Array(80);
  function V() {
    this.init(), this._w = J, L.call(this, 64, 56);
  }
  B(V, L), V.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function re(pe) {
    return pe << 5 | pe >>> 27;
  }
  function ie(pe) {
    return pe << 30 | pe >>> 2;
  }
  function oe(pe, ne, ce, Ce) {
    return pe === 0 ? ne & ce | ~ne & Ce : pe === 2 ? ne & ce | ne & Ce | ce & Ce : ne ^ ce ^ Ce;
  }
  return V.prototype._update = function(pe) {
    for (var ne = this._w, ce = this._a | 0, Ce = this._b | 0, Oe = this._c | 0, st = this._d | 0, at = this._e | 0, lt = 0; lt < 16; ++lt) ne[lt] = pe.readInt32BE(lt * 4);
    for (; lt < 80; ++lt) ne[lt] = ne[lt - 3] ^ ne[lt - 8] ^ ne[lt - 14] ^ ne[lt - 16];
    for (var pt = 0; pt < 80; ++pt) {
      var ht = ~~(pt / 20), yt = re(ce) + oe(ht, Ce, Oe, st) + at + ne[pt] + K[ht] | 0;
      at = st, st = Oe, Oe = ie(Ce), Ce = ce, ce = yt;
    }
    this._a = ce + this._a | 0, this._b = Ce + this._b | 0, this._c = Oe + this._c | 0, this._d = st + this._d | 0, this._e = at + this._e | 0;
  }, V.prototype._hash = function() {
    var pe = W.allocUnsafe(20);
    return pe.writeInt32BE(this._a | 0, 0), pe.writeInt32BE(this._b | 0, 4), pe.writeInt32BE(this._c | 0, 8), pe.writeInt32BE(this._d | 0, 12), pe.writeInt32BE(this._e | 0, 16), pe;
  }, sha$1 = V, sha$1;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], J = new Array(80);
  function V() {
    this.init(), this._w = J, L.call(this, 64, 56);
  }
  B(V, L), V.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function re(ne) {
    return ne << 1 | ne >>> 31;
  }
  function ie(ne) {
    return ne << 5 | ne >>> 27;
  }
  function oe(ne) {
    return ne << 30 | ne >>> 2;
  }
  function pe(ne, ce, Ce, Oe) {
    return ne === 0 ? ce & Ce | ~ce & Oe : ne === 2 ? ce & Ce | ce & Oe | Ce & Oe : ce ^ Ce ^ Oe;
  }
  return V.prototype._update = function(ne) {
    for (var ce = this._w, Ce = this._a | 0, Oe = this._b | 0, st = this._c | 0, at = this._d | 0, lt = this._e | 0, pt = 0; pt < 16; ++pt) ce[pt] = ne.readInt32BE(pt * 4);
    for (; pt < 80; ++pt) ce[pt] = re(ce[pt - 3] ^ ce[pt - 8] ^ ce[pt - 14] ^ ce[pt - 16]);
    for (var ht = 0; ht < 80; ++ht) {
      var yt = ~~(ht / 20), vt = ie(Ce) + pe(yt, Oe, st, at) + lt + ce[ht] + K[yt] | 0;
      lt = at, at = st, st = oe(Oe), Oe = Ce, Ce = vt;
    }
    this._a = Ce + this._a | 0, this._b = Oe + this._b | 0, this._c = st + this._c | 0, this._d = at + this._d | 0, this._e = lt + this._e | 0;
  }, V.prototype._hash = function() {
    var ne = W.allocUnsafe(20);
    return ne.writeInt32BE(this._a | 0, 0), ne.writeInt32BE(this._b | 0, 4), ne.writeInt32BE(this._c | 0, 8), ne.writeInt32BE(this._d | 0, 12), ne.writeInt32BE(this._e | 0, 16), ne;
  }, sha1 = V, sha1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], J = new Array(64);
  function V() {
    this.init(), this._w = J, L.call(this, 64, 56);
  }
  B(V, L), V.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function re(Ce, Oe, st) {
    return st ^ Ce & (Oe ^ st);
  }
  function ie(Ce, Oe, st) {
    return Ce & Oe | st & (Ce | Oe);
  }
  function oe(Ce) {
    return (Ce >>> 2 | Ce << 30) ^ (Ce >>> 13 | Ce << 19) ^ (Ce >>> 22 | Ce << 10);
  }
  function pe(Ce) {
    return (Ce >>> 6 | Ce << 26) ^ (Ce >>> 11 | Ce << 21) ^ (Ce >>> 25 | Ce << 7);
  }
  function ne(Ce) {
    return (Ce >>> 7 | Ce << 25) ^ (Ce >>> 18 | Ce << 14) ^ Ce >>> 3;
  }
  function ce(Ce) {
    return (Ce >>> 17 | Ce << 15) ^ (Ce >>> 19 | Ce << 13) ^ Ce >>> 10;
  }
  return V.prototype._update = function(Ce) {
    for (var Oe = this._w, st = this._a | 0, at = this._b | 0, lt = this._c | 0, pt = this._d | 0, ht = this._e | 0, yt = this._f | 0, vt = this._g | 0, $t = this._h | 0, xt = 0; xt < 16; ++xt) Oe[xt] = Ce.readInt32BE(xt * 4);
    for (; xt < 64; ++xt) Oe[xt] = ce(Oe[xt - 2]) + Oe[xt - 7] + ne(Oe[xt - 15]) + Oe[xt - 16] | 0;
    for (var Ct = 0; Ct < 64; ++Ct) {
      var Et = $t + pe(ht) + re(ht, yt, vt) + K[Ct] + Oe[Ct] | 0, St = oe(st) + ie(st, at, lt) | 0;
      $t = vt, vt = yt, yt = ht, ht = pt + Et | 0, pt = lt, lt = at, at = st, st = Et + St | 0;
    }
    this._a = st + this._a | 0, this._b = at + this._b | 0, this._c = lt + this._c | 0, this._d = pt + this._d | 0, this._e = ht + this._e | 0, this._f = yt + this._f | 0, this._g = vt + this._g | 0, this._h = $t + this._h | 0;
  }, V.prototype._hash = function() {
    var Ce = W.allocUnsafe(32);
    return Ce.writeInt32BE(this._a, 0), Ce.writeInt32BE(this._b, 4), Ce.writeInt32BE(this._c, 8), Ce.writeInt32BE(this._d, 12), Ce.writeInt32BE(this._e, 16), Ce.writeInt32BE(this._f, 20), Ce.writeInt32BE(this._g, 24), Ce.writeInt32BE(this._h, 28), Ce;
  }, sha256$3 = V, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var B = requireInherits_browser(), L = requireSha256(), W = requireHash$1(), K = safeBufferExports.Buffer, J = new Array(64);
  function V() {
    this.init(), this._w = J, W.call(this, 64, 56);
  }
  return B(V, L), V.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, V.prototype._hash = function() {
    var re = K.allocUnsafe(28);
    return re.writeInt32BE(this._a, 0), re.writeInt32BE(this._b, 4), re.writeInt32BE(this._c, 8), re.writeInt32BE(this._d, 12), re.writeInt32BE(this._e, 16), re.writeInt32BE(this._f, 20), re.writeInt32BE(this._g, 24), re;
  }, sha224$1 = V, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), W = safeBufferExports.Buffer, K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], J = new Array(160);
  function V() {
    this.init(), this._w = J, L.call(this, 128, 112);
  }
  B(V, L), V.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function re(at, lt, pt) {
    return pt ^ at & (lt ^ pt);
  }
  function ie(at, lt, pt) {
    return at & lt | pt & (at | lt);
  }
  function oe(at, lt) {
    return (at >>> 28 | lt << 4) ^ (lt >>> 2 | at << 30) ^ (lt >>> 7 | at << 25);
  }
  function pe(at, lt) {
    return (at >>> 14 | lt << 18) ^ (at >>> 18 | lt << 14) ^ (lt >>> 9 | at << 23);
  }
  function ne(at, lt) {
    return (at >>> 1 | lt << 31) ^ (at >>> 8 | lt << 24) ^ at >>> 7;
  }
  function ce(at, lt) {
    return (at >>> 1 | lt << 31) ^ (at >>> 8 | lt << 24) ^ (at >>> 7 | lt << 25);
  }
  function Ce(at, lt) {
    return (at >>> 19 | lt << 13) ^ (lt >>> 29 | at << 3) ^ at >>> 6;
  }
  function Oe(at, lt) {
    return (at >>> 19 | lt << 13) ^ (lt >>> 29 | at << 3) ^ (at >>> 6 | lt << 26);
  }
  function st(at, lt) {
    return at >>> 0 < lt >>> 0 ? 1 : 0;
  }
  return V.prototype._update = function(at) {
    for (var lt = this._w, pt = this._ah | 0, ht = this._bh | 0, yt = this._ch | 0, vt = this._dh | 0, $t = this._eh | 0, xt = this._fh | 0, Ct = this._gh | 0, Et = this._hh | 0, St = this._al | 0, It = this._bl | 0, Tt = this._cl | 0, nt = this._dl | 0, it = this._el | 0, ke = this._fl | 0, rt = this._gl | 0, ot = this._hl | 0, ft = 0; ft < 32; ft += 2)
      lt[ft] = at.readInt32BE(ft * 4), lt[ft + 1] = at.readInt32BE(ft * 4 + 4);
    for (; ft < 160; ft += 2) {
      var ct = lt[ft - 30], bt = lt[ft - 15 * 2 + 1], ut = ne(ct, bt), gt = ce(bt, ct);
      ct = lt[ft - 2 * 2], bt = lt[ft - 2 * 2 + 1];
      var dt = Ce(ct, bt), wt = Oe(bt, ct), Ft = lt[ft - 7 * 2], jt = lt[ft - 7 * 2 + 1], Nt = lt[ft - 16 * 2], Bt = lt[ft - 16 * 2 + 1], Rt = gt + jt | 0, Ut = ut + Ft + st(Rt, gt) | 0;
      Rt = Rt + wt | 0, Ut = Ut + dt + st(Rt, wt) | 0, Rt = Rt + Bt | 0, Ut = Ut + Nt + st(Rt, Bt) | 0, lt[ft] = Ut, lt[ft + 1] = Rt;
    }
    for (var zt = 0; zt < 160; zt += 2) {
      Ut = lt[zt], Rt = lt[zt + 1];
      var Mt = ie(pt, ht, yt), kt = ie(St, It, Tt), Gt = oe(pt, St), Qt = oe(St, pt), nr = pe($t, it), ar = pe(it, $t), cr = K[zt], hr = K[zt + 1], Jt = re($t, xt, Ct), Pr = re(it, ke, rt), dr = ot + ar | 0, Tr = Et + nr + st(dr, ot) | 0;
      dr = dr + Pr | 0, Tr = Tr + Jt + st(dr, Pr) | 0, dr = dr + hr | 0, Tr = Tr + cr + st(dr, hr) | 0, dr = dr + Rt | 0, Tr = Tr + Ut + st(dr, Rt) | 0;
      var Rr = Qt + kt | 0, pr = Gt + Mt + st(Rr, Qt) | 0;
      Et = Ct, ot = rt, Ct = xt, rt = ke, xt = $t, ke = it, it = nt + dr | 0, $t = vt + Tr + st(it, nt) | 0, vt = yt, nt = Tt, yt = ht, Tt = It, ht = pt, It = St, St = dr + Rr | 0, pt = Tr + pr + st(St, dr) | 0;
    }
    this._al = this._al + St | 0, this._bl = this._bl + It | 0, this._cl = this._cl + Tt | 0, this._dl = this._dl + nt | 0, this._el = this._el + it | 0, this._fl = this._fl + ke | 0, this._gl = this._gl + rt | 0, this._hl = this._hl + ot | 0, this._ah = this._ah + pt + st(this._al, St) | 0, this._bh = this._bh + ht + st(this._bl, It) | 0, this._ch = this._ch + yt + st(this._cl, Tt) | 0, this._dh = this._dh + vt + st(this._dl, nt) | 0, this._eh = this._eh + $t + st(this._el, it) | 0, this._fh = this._fh + xt + st(this._fl, ke) | 0, this._gh = this._gh + Ct + st(this._gl, rt) | 0, this._hh = this._hh + Et + st(this._hl, ot) | 0;
  }, V.prototype._hash = function() {
    var at = W.allocUnsafe(64);
    function lt(pt, ht, yt) {
      at.writeInt32BE(pt, yt), at.writeInt32BE(ht, yt + 4);
    }
    return lt(this._ah, this._al, 0), lt(this._bh, this._bl, 8), lt(this._ch, this._cl, 16), lt(this._dh, this._dl, 24), lt(this._eh, this._el, 32), lt(this._fh, this._fl, 40), lt(this._gh, this._gl, 48), lt(this._hh, this._hl, 56), at;
  }, sha512$1 = V, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var B = requireInherits_browser(), L = requireSha512(), W = requireHash$1(), K = safeBufferExports.Buffer, J = new Array(160);
  function V() {
    this.init(), this._w = J, W.call(this, 128, 112);
  }
  return B(V, L), V.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, V.prototype._hash = function() {
    var re = K.allocUnsafe(48);
    function ie(oe, pe, ne) {
      re.writeInt32BE(oe, ne), re.writeInt32BE(pe, ne + 4);
    }
    return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), re;
  }, sha384$1 = V, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var B = sha_js.exports = function(W) {
    W = W.toLowerCase();
    var K = B[W];
    if (!K) throw new Error(W + " is not supported (we accept pull requests)");
    return new K();
  };
  return B.sha = requireSha$1(), B.sha1 = requireSha1(), B.sha224 = requireSha224(), B.sha256 = requireSha256(), B.sha384 = requireSha384(), B.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = W;
  var B = requireEvents().EventEmitter, L = requireInherits_browser();
  L(W, B), W.Readable = require_stream_readable$1(), W.Writable = require_stream_writable$1(), W.Duplex = require_stream_duplex$1(), W.Transform = require_stream_transform$1(), W.PassThrough = require_stream_passthrough$1(), W.finished = requireEndOfStream(), W.pipeline = requirePipeline(), W.Stream = W;
  function W() {
    B.call(this);
  }
  return W.prototype.pipe = function(K, J) {
    var V = this;
    function re(Oe) {
      K.writable && K.write(Oe) === !1 && V.pause && V.pause();
    }
    V.on("data", re);
    function ie() {
      V.readable && V.resume && V.resume();
    }
    K.on("drain", ie), !K._isStdio && (!J || J.end !== !1) && (V.on("end", pe), V.on("close", ne));
    var oe = !1;
    function pe() {
      oe || (oe = !0, K.end());
    }
    function ne() {
      oe || (oe = !0, typeof K.destroy == "function" && K.destroy());
    }
    function ce(Oe) {
      if (Ce(), B.listenerCount(this, "error") === 0)
        throw Oe;
    }
    V.on("error", ce), K.on("error", ce);
    function Ce() {
      V.removeListener("data", re), K.removeListener("drain", ie), V.removeListener("end", pe), V.removeListener("close", ne), V.removeListener("error", ce), K.removeListener("error", ce), V.removeListener("end", Ce), V.removeListener("close", Ce), K.removeListener("close", Ce);
    }
    return V.on("end", Ce), V.on("close", Ce), K.on("close", Ce), K.emit("pipe", V), K;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var B = safeBufferExports.Buffer, L = requireStreamBrowserify().Transform, W = requireString_decoder().StringDecoder, K = requireInherits_browser();
  function J(V) {
    L.call(this), this.hashMode = typeof V == "string", this.hashMode ? this[V] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return K(J, L), J.prototype.update = function(V, re, ie) {
    typeof V == "string" && (V = B.from(V, re));
    var oe = this._update(V);
    return this.hashMode ? this : (ie && (oe = this._toString(oe, ie)), oe);
  }, J.prototype.setAutoPadding = function() {
  }, J.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, J.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, J.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, J.prototype._transform = function(V, re, ie) {
    var oe;
    try {
      this.hashMode ? this._update(V) : this.push(this._update(V));
    } catch (pe) {
      oe = pe;
    } finally {
      ie(oe);
    }
  }, J.prototype._flush = function(V) {
    var re;
    try {
      this.push(this.__final());
    } catch (ie) {
      re = ie;
    }
    V(re);
  }, J.prototype._finalOrDigest = function(V) {
    var re = this.__final() || B.alloc(0);
    return V && (re = this._toString(re, V, !0)), re;
  }, J.prototype._toString = function(V, re, ie) {
    if (this._decoder || (this._decoder = new W(re), this._encoding = re), this._encoding !== re) throw new Error("can't switch encodings");
    var oe = this._decoder.write(V);
    return ie && (oe += this._decoder.end()), oe;
  }, cipherBase = J, cipherBase;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1;
  var B = requireInherits_browser(), L = requireMd5_js(), W = requireRipemd160(), K = requireSha_js(), J = requireCipherBase();
  function V(re) {
    J.call(this, "digest"), this._hash = re;
  }
  return B(V, J), V.prototype._update = function(re) {
    this._hash.update(re);
  }, V.prototype._final = function() {
    return this._hash.digest();
  }, browser$a = function(ie) {
    return ie = ie.toLowerCase(), ie === "md5" ? new L() : ie === "rmd160" || ie === "ripemd160" ? new W() : new V(K(ie));
  }, browser$a;
}
var _Buffer = safeBufferExports.Buffer;
function base$3(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var L = new Uint8Array(256), W = 0; W < L.length; W++)
    L[W] = 255;
  for (var K = 0; K < B.length; K++) {
    var J = B.charAt(K), V = J.charCodeAt(0);
    if (L[V] !== 255)
      throw new TypeError(J + " is ambiguous");
    L[V] = K;
  }
  var re = B.length, ie = B.charAt(0), oe = Math.log(re) / Math.log(256), pe = Math.log(256) / Math.log(re);
  function ne(Oe) {
    if ((Array.isArray(Oe) || Oe instanceof Uint8Array) && (Oe = _Buffer.from(Oe)), !_Buffer.isBuffer(Oe))
      throw new TypeError("Expected Buffer");
    if (Oe.length === 0)
      return "";
    for (var st = 0, at = 0, lt = 0, pt = Oe.length; lt !== pt && Oe[lt] === 0; )
      lt++, st++;
    for (var ht = (pt - lt) * pe + 1 >>> 0, yt = new Uint8Array(ht); lt !== pt; ) {
      for (var vt = Oe[lt], $t = 0, xt = ht - 1; (vt !== 0 || $t < at) && xt !== -1; xt--, $t++)
        vt += 256 * yt[xt] >>> 0, yt[xt] = vt % re >>> 0, vt = vt / re >>> 0;
      if (vt !== 0)
        throw new Error("Non-zero carry");
      at = $t, lt++;
    }
    for (var Ct = ht - at; Ct !== ht && yt[Ct] === 0; )
      Ct++;
    for (var Et = ie.repeat(st); Ct < ht; ++Ct)
      Et += B.charAt(yt[Ct]);
    return Et;
  }
  function ce(Oe) {
    if (typeof Oe != "string")
      throw new TypeError("Expected String");
    if (Oe.length === 0)
      return _Buffer.alloc(0);
    for (var st = 0, at = 0, lt = 0; Oe[st] === ie; )
      at++, st++;
    for (var pt = (Oe.length - st) * oe + 1 >>> 0, ht = new Uint8Array(pt); st < Oe.length; ) {
      var yt = L[Oe.charCodeAt(st)];
      if (yt === 255)
        return;
      for (var vt = 0, $t = pt - 1; (yt !== 0 || vt < lt) && $t !== -1; $t--, vt++)
        yt += re * ht[$t] >>> 0, ht[$t] = yt % 256 >>> 0, yt = yt / 256 >>> 0;
      if (yt !== 0)
        throw new Error("Non-zero carry");
      lt = vt, st++;
    }
    for (var xt = pt - lt; xt !== pt && ht[xt] === 0; )
      xt++;
    var Ct = _Buffer.allocUnsafe(at + (pt - xt));
    Ct.fill(0, 0, at);
    for (var Et = at; xt !== pt; )
      Ct[Et++] = ht[xt++];
    return Ct;
  }
  function Ce(Oe) {
    var st = ce(Oe);
    if (st)
      return st;
    throw new Error("Non-base" + re + " character");
  }
  return {
    encode: ne,
    decodeUnsafe: ce,
    decode: Ce
  };
}
var src$1 = base$3, basex = src$1, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET), base58 = bs58, Buffer = safeBufferExports.Buffer, base$2 = function(B) {
  function L(V) {
    var re = B(V);
    return base58.encode(Buffer.concat([
      V,
      re
    ], V.length + 4));
  }
  function W(V) {
    var re = V.slice(0, -4), ie = V.slice(-4), oe = B(re);
    if (!(ie[0] ^ oe[0] | ie[1] ^ oe[1] | ie[2] ^ oe[2] | ie[3] ^ oe[3]))
      return re;
  }
  function K(V) {
    var re = base58.decodeUnsafe(V);
    if (re)
      return W(re);
  }
  function J(V) {
    var re = base58.decode(V), ie = W(re);
    if (!ie) throw new Error("Invalid checksum");
    return ie;
  }
  return {
    encode: L,
    decode: J,
    decodeUnsafe: K
  };
}, createHash = requireBrowser$a(), bs58checkBase = base$2;
function sha256x2(B) {
  var L = createHash("sha256").update(B).digest();
  return createHash("sha256").update(L).digest();
}
var bs58check$2 = bs58checkBase(sha256x2), bs58check$1 = bs58check$2;
function decodeRaw(B, L) {
  if (L !== void 0 && B[0] !== L) throw new Error("Invalid network version");
  if (B.length === 33)
    return {
      version: B[0],
      privateKey: B.slice(1, 33),
      compressed: !1
    };
  if (B.length !== 34) throw new Error("Invalid WIF length");
  if (B[33] !== 1) throw new Error("Invalid compression flag");
  return {
    version: B[0],
    privateKey: B.slice(1, 33),
    compressed: !0
  };
}
function encodeRaw(B, L, W) {
  var K = new Buffer$2(W ? 34 : 33);
  return K.writeUInt8(B, 0), L.copy(K, 1), W && (K[33] = 1), K;
}
function decode$2(B, L) {
  return decodeRaw(bs58check$1.decode(B), L);
}
function encode$1(B, L, W) {
  return typeof B == "number" ? bs58check$1.encode(encodeRaw(B, L, W)) : bs58check$1.encode(
    encodeRaw(
      B.version,
      B.privateKey,
      B.compressed
    )
  );
}
var wif$2 = {
  decode: decode$2,
  decodeRaw,
  encode: encode$1,
  encodeRaw
};
Object.defineProperty(bip32, "__esModule", { value: !0 });
bip32.BIP32Factory = void 0;
const crypto$1 = crypto$2, testecc_1$1 = testecc$1, base_1 = lib$2, sha256_1$4 = sha256$5, typeforce = typeforce_1, wif$1 = wif$2, _bs58check = (0, base_1.base58check)(sha256_1$4.sha256), bs58check = {
  encode: (B) => _bs58check.encode(Uint8Array.from(B)),
  decode: (B) => Buffer$2.from(_bs58check.decode(B))
};
function BIP32Factory(B) {
  (0, testecc_1$1.testEcc)(B);
  const L = typeforce.BufferN(32), W = typeforce.compile({
    wif: typeforce.UInt8,
    bip32: {
      public: typeforce.UInt32,
      private: typeforce.UInt32
    }
  }), K = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, J = 2147483648, V = Math.pow(2, 31) - 1;
  function re(pt) {
    return typeforce.String(pt) && pt.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
  }
  function ie(pt) {
    return typeforce.UInt32(pt) && pt <= V;
  }
  function oe(pt) {
    return pt.length === 32 ? pt : pt.slice(1, 33);
  }
  class pe {
    constructor(ht, yt) {
      this.__D = ht, this.__Q = yt, this.lowR = !1;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = Buffer$2.from(B.pointFromScalar(this.__D, !0))), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(ht, yt) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (yt === void 0 && (yt = this.lowR), yt === !1)
        return Buffer$2.from(B.sign(ht, this.privateKey));
      {
        let vt = Buffer$2.from(B.sign(ht, this.privateKey));
        const $t = Buffer$2.alloc(32, 0);
        let xt = 0;
        for (; vt[0] > 127; )
          xt++, $t.writeUIntLE(xt, 0, 6), vt = Buffer$2.from(B.sign(ht, this.privateKey, $t));
        return vt;
      }
    }
    signSchnorr(ht) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!B.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer$2.from(B.signSchnorr(ht, this.privateKey));
    }
    verify(ht, yt) {
      return B.verify(ht, this.publicKey, yt);
    }
    verifySchnorr(ht, yt) {
      if (!B.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return B.verifySchnorr(ht, this.publicKey.subarray(1, 33), yt);
    }
  }
  class ne extends pe {
    constructor(ht, yt, vt, $t, xt = 0, Ct = 0, Et = 0) {
      super(ht, yt), this.chainCode = vt, this.network = $t, this.__DEPTH = xt, this.__INDEX = Ct, this.__PARENT_FINGERPRINT = Et, typeforce(W, $t);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return crypto$1.hash160(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return at(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const ht = this.network, yt = this.isNeutered() ? ht.bip32.public : ht.bip32.private, vt = Buffer$2.allocUnsafe(78);
      return vt.writeUInt32BE(yt, 0), vt.writeUInt8(this.depth, 4), vt.writeUInt32BE(this.parentFingerprint, 5), vt.writeUInt32BE(this.index, 9), this.chainCode.copy(vt, 13), this.isNeutered() ? this.publicKey.copy(vt, 45) : (vt.writeUInt8(0, 45), this.privateKey.copy(vt, 46)), bs58check.encode(vt);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return wif$1.encode(this.network.wif, this.privateKey, !0);
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(ht) {
      typeforce(typeforce.UInt32, ht);
      const yt = ht >= J, vt = Buffer$2.allocUnsafe(37);
      if (yt) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        vt[0] = 0, this.privateKey.copy(vt, 1), vt.writeUInt32BE(ht, 33);
      } else
        this.publicKey.copy(vt, 0), vt.writeUInt32BE(ht, 33);
      const $t = crypto$1.hmacSHA512(this.chainCode, vt), xt = $t.slice(0, 32), Ct = $t.slice(32);
      if (!B.isPrivate(xt))
        return this.derive(ht + 1);
      let Et;
      if (this.isNeutered()) {
        const St = Buffer$2.from(B.pointAddScalar(this.publicKey, xt, !0));
        if (St === null)
          return this.derive(ht + 1);
        Et = at(St, Ct, this.network, this.depth + 1, ht, this.fingerprint.readUInt32BE(0));
      } else {
        const St = Buffer$2.from(B.privateAdd(this.privateKey, xt));
        if (St == null)
          return this.derive(ht + 1);
        Et = Oe(St, Ct, this.network, this.depth + 1, ht, this.fingerprint.readUInt32BE(0));
      }
      return Et;
    }
    deriveHardened(ht) {
      return typeforce(ie, ht), this.derive(ht + J);
    }
    derivePath(ht) {
      typeforce(re, ht);
      let yt = ht.split("/");
      if (yt[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        yt = yt.slice(1);
      }
      return yt.reduce((vt, $t) => {
        let xt;
        return $t.slice(-1) === "'" ? (xt = parseInt($t.slice(0, -1), 10), vt.deriveHardened(xt)) : (xt = parseInt($t, 10), vt.derive(xt));
      }, this);
    }
    tweak(ht) {
      return this.privateKey ? this.tweakFromPrivateKey(ht) : this.tweakFromPublicKey(ht);
    }
    tweakFromPublicKey(ht) {
      const yt = oe(this.publicKey);
      if (!B.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const vt = B.xOnlyPointAddTweak(yt, ht);
      if (!vt || vt.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const $t = Buffer$2.from([
        vt.parity === 0 ? 2 : 3
      ]), xt = Buffer$2.concat([
        $t,
        vt.xOnlyPubkey
      ]);
      return new pe(void 0, xt);
    }
    tweakFromPrivateKey(ht) {
      const yt = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, vt = (() => {
        if (yt) {
          if (B.privateNegate)
            return B.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), $t = B.privateAdd(vt, ht);
      if (!$t)
        throw new Error("Invalid tweaked private key!");
      return new pe(Buffer$2.from($t), void 0);
    }
  }
  function ce(pt, ht) {
    const yt = bs58check.decode(pt);
    if (yt.length !== 78)
      throw new TypeError("Invalid buffer length");
    ht = ht || K;
    const vt = yt.readUInt32BE(0);
    if (vt !== ht.bip32.private && vt !== ht.bip32.public)
      throw new TypeError("Invalid network version");
    const $t = yt[4], xt = yt.readUInt32BE(5);
    if ($t === 0 && xt !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const Ct = yt.readUInt32BE(9);
    if ($t === 0 && Ct !== 0)
      throw new TypeError("Invalid index");
    const Et = yt.slice(13, 45);
    let St;
    if (vt === ht.bip32.private) {
      if (yt.readUInt8(45) !== 0)
        throw new TypeError("Invalid private key");
      const It = yt.slice(46, 78);
      St = Oe(It, Et, ht, $t, Ct, xt);
    } else {
      const It = yt.slice(45, 78);
      St = at(It, Et, ht, $t, Ct, xt);
    }
    return St;
  }
  function Ce(pt, ht, yt) {
    return Oe(pt, ht, yt);
  }
  function Oe(pt, ht, yt, vt, $t, xt) {
    if (typeforce({
      privateKey: L,
      chainCode: L
    }, { privateKey: pt, chainCode: ht }), yt = yt || K, !B.isPrivate(pt))
      throw new TypeError("Private key not in range [1, n)");
    return new ne(pt, void 0, ht, yt, vt, $t, xt);
  }
  function st(pt, ht, yt) {
    return at(pt, ht, yt);
  }
  function at(pt, ht, yt, vt, $t, xt) {
    if (typeforce({
      publicKey: typeforce.BufferN(33),
      chainCode: L
    }, { publicKey: pt, chainCode: ht }), yt = yt || K, !B.isPoint(pt))
      throw new TypeError("Point is not on the curve");
    return new ne(void 0, pt, ht, yt, vt, $t, xt);
  }
  function lt(pt, ht) {
    if (typeforce(typeforce.Buffer, pt), pt.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (pt.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    ht = ht || K;
    const yt = crypto$1.hmacSHA512(Buffer$2.from("Bitcoin seed", "utf8"), pt), vt = yt.slice(0, 32), $t = yt.slice(32);
    return Ce(vt, $t, ht);
  }
  return {
    fromSeed: lt,
    fromBase58: ce,
    fromPublicKey: st,
    fromPrivateKey: Ce
  };
}
bip32.BIP32Factory = BIP32Factory;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.BIP32Factory = B.default = void 0;
  var L = bip32;
  Object.defineProperty(B, "default", { enumerable: !0, get: function() {
    return L.BIP32Factory;
  } }), Object.defineProperty(B, "BIP32Factory", { enumerable: !0, get: function() {
    return L.BIP32Factory;
  } });
})(src$2);
var dist = {}, lib$1 = {}, cryptoBrowserify = {}, browser$9 = { exports: {} }, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9.exports;
  hasRequiredBrowser$9 = 1;
  var B = 65536, L = 4294967295;
  function W() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var K = safeBufferExports.Buffer, J = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  J && J.getRandomValues ? browser$9.exports = V : browser$9.exports = W;
  function V(re, ie) {
    if (re > L) throw new RangeError("requested too many random bytes");
    var oe = K.allocUnsafe(re);
    if (re > 0)
      if (re > B)
        for (var pe = 0; pe < re; pe += B)
          J.getRandomValues(oe.slice(pe, pe + B));
      else
        J.getRandomValues(oe);
    return typeof ie == "function" ? process$1.nextTick(function() {
      ie(null, oe);
    }) : oe;
  }
  return browser$9.exports;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var B = requireInherits_browser(), L = safeBufferExports.Buffer, W = requireCipherBase(), K = L.alloc(128), J = 64;
  function V(re, ie) {
    W.call(this, "digest"), typeof ie == "string" && (ie = L.from(ie)), this._alg = re, this._key = ie, ie.length > J ? ie = re(ie) : ie.length < J && (ie = L.concat([ie, K], J));
    for (var oe = this._ipad = L.allocUnsafe(J), pe = this._opad = L.allocUnsafe(J), ne = 0; ne < J; ne++)
      oe[ne] = ie[ne] ^ 54, pe[ne] = ie[ne] ^ 92;
    this._hash = [oe];
  }
  return B(V, W), V.prototype._update = function(re) {
    this._hash.push(re);
  }, V.prototype._final = function() {
    var re = this._alg(L.concat(this._hash));
    return this._alg(L.concat([this._opad, re]));
  }, legacy = V, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var B = requireMd5_js();
  return md5 = function(L) {
    return new B().update(L).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var B = requireInherits_browser(), L = requireLegacy(), W = requireCipherBase(), K = safeBufferExports.Buffer, J = requireMd5(), V = requireRipemd160(), re = requireSha_js(), ie = K.alloc(128);
  function oe(pe, ne) {
    W.call(this, "digest"), typeof ne == "string" && (ne = K.from(ne));
    var ce = pe === "sha512" || pe === "sha384" ? 128 : 64;
    if (this._alg = pe, this._key = ne, ne.length > ce) {
      var Ce = pe === "rmd160" ? new V() : re(pe);
      ne = Ce.update(ne).digest();
    } else ne.length < ce && (ne = K.concat([ne, ie], ce));
    for (var Oe = this._ipad = K.allocUnsafe(ce), st = this._opad = K.allocUnsafe(ce), at = 0; at < ce; at++)
      Oe[at] = ne[at] ^ 54, st[at] = ne[at] ^ 92;
    this._hash = pe === "rmd160" ? new V() : re(pe), this._hash.update(Oe);
  }
  return B(oe, W), oe.prototype._update = function(pe) {
    this._hash.update(pe);
  }, oe.prototype._final = function() {
    var pe = this._hash.digest(), ne = this._alg === "rmd160" ? new V() : re(this._alg);
    return ne.update(this._opad).update(pe).digest();
  }, browser$8 = function(ne, ce) {
    return ne = ne.toLowerCase(), ne === "rmd160" || ne === "ripemd160" ? new oe("rmd160", ce) : ne === "md5" ? new L(J, ce) : new oe(ne, ce);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var B = Math.pow(2, 30) - 1;
  return precondition = function(L, W) {
    if (typeof L != "number")
      throw new TypeError("Iterations not a number");
    if (L < 0)
      throw new TypeError("Bad iterations");
    if (typeof W != "number")
      throw new TypeError("Key length not a number");
    if (W < 0 || W > B || W !== W)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var B;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    B = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var L = parseInt(process$1.version.split(".")[0].slice(1), 10);
    B = L >= 6 ? "utf-8" : "binary";
  } else
    B = "utf-8";
  return defaultEncoding_1 = B, defaultEncoding_1;
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer;
  hasRequiredToBuffer = 1;
  var B = safeBufferExports.Buffer;
  return toBuffer = function(L, W, K) {
    if (B.isBuffer(L))
      return L;
    if (typeof L == "string")
      return B.from(L, W);
    if (ArrayBuffer.isView(L))
      return B.from(L.buffer);
    throw new TypeError(K + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var B = requireMd5(), L = requireRipemd160(), W = requireSha_js(), K = safeBufferExports.Buffer, J = requirePrecondition(), V = requireDefaultEncoding(), re = requireToBuffer(), ie = K.alloc(128), oe = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function pe(Ce, Oe, st) {
    var at = ne(Ce), lt = Ce === "sha512" || Ce === "sha384" ? 128 : 64;
    Oe.length > lt ? Oe = at(Oe) : Oe.length < lt && (Oe = K.concat([Oe, ie], lt));
    for (var pt = K.allocUnsafe(lt + oe[Ce]), ht = K.allocUnsafe(lt + oe[Ce]), yt = 0; yt < lt; yt++)
      pt[yt] = Oe[yt] ^ 54, ht[yt] = Oe[yt] ^ 92;
    var vt = K.allocUnsafe(lt + st + 4);
    pt.copy(vt, 0, 0, lt), this.ipad1 = vt, this.ipad2 = pt, this.opad = ht, this.alg = Ce, this.blocksize = lt, this.hash = at, this.size = oe[Ce];
  }
  pe.prototype.run = function(Ce, Oe) {
    Ce.copy(Oe, this.blocksize);
    var st = this.hash(Oe);
    return st.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function ne(Ce) {
    function Oe(at) {
      return W(Ce).update(at).digest();
    }
    function st(at) {
      return new L().update(at).digest();
    }
    return Ce === "rmd160" || Ce === "ripemd160" ? st : Ce === "md5" ? B : Oe;
  }
  function ce(Ce, Oe, st, at, lt) {
    J(st, at), Ce = re(Ce, V, "Password"), Oe = re(Oe, V, "Salt"), lt = lt || "sha1";
    var pt = new pe(lt, Ce, Oe.length), ht = K.allocUnsafe(at), yt = K.allocUnsafe(Oe.length + 4);
    Oe.copy(yt, 0, 0, Oe.length);
    for (var vt = 0, $t = oe[lt], xt = Math.ceil(at / $t), Ct = 1; Ct <= xt; Ct++) {
      yt.writeUInt32BE(Ct, Oe.length);
      for (var Et = pt.run(yt, pt.ipad1), St = Et, It = 1; It < st; It++) {
        St = pt.run(St, pt.ipad2);
        for (var Tt = 0; Tt < $t; Tt++) Et[Tt] ^= St[Tt];
      }
      Et.copy(ht, vt), vt += $t;
    }
    return ht;
  }
  return syncBrowser = ce, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var B = safeBufferExports.Buffer, L = requirePrecondition(), W = requireDefaultEncoding(), K = requireSyncBrowser(), J = requireToBuffer(), V, re = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ie = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, oe = [];
  function pe(st) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !re || !re.importKey || !re.deriveBits)
      return Promise.resolve(!1);
    if (oe[st] !== void 0)
      return oe[st];
    V = V || B.alloc(8);
    var at = Ce(V, V, 10, 128, st).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return oe[st] = at, at;
  }
  var ne;
  function ce() {
    return ne || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? ne = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? ne = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? ne = commonjsGlobal.setImmediate : ne = commonjsGlobal.setTimeout, ne);
  }
  function Ce(st, at, lt, pt, ht) {
    return re.importKey(
      "raw",
      st,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(yt) {
      return re.deriveBits({
        name: "PBKDF2",
        salt: at,
        iterations: lt,
        hash: {
          name: ht
        }
      }, yt, pt << 3);
    }).then(function(yt) {
      return B.from(yt);
    });
  }
  function Oe(st, at) {
    st.then(function(lt) {
      ce()(function() {
        at(null, lt);
      });
    }, function(lt) {
      ce()(function() {
        at(lt);
      });
    });
  }
  return async = function(st, at, lt, pt, ht, yt) {
    typeof ht == "function" && (yt = ht, ht = void 0), ht = ht || "sha1";
    var vt = ie[ht.toLowerCase()];
    if (!vt || typeof commonjsGlobal.Promise != "function") {
      ce()(function() {
        var $t;
        try {
          $t = K(st, at, lt, pt, ht);
        } catch (xt) {
          return yt(xt);
        }
        yt(null, $t);
      });
      return;
    }
    if (L(lt, pt), st = J(st, W, "Password"), at = J(at, W, "Salt"), typeof yt != "function") throw new Error("No callback provided to pbkdf2");
    Oe(pe(vt).then(function($t) {
      return $t ? Ce(st, at, lt, pt, vt) : K(st, at, lt, pt, ht);
    }), yt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$3 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function(J, V) {
    var re = J[0 + V] << 24 | J[1 + V] << 16 | J[2 + V] << 8 | J[3 + V];
    return re >>> 0;
  }, utils$3.writeUInt32BE = function(J, V, re) {
    J[0 + re] = V >>> 24, J[1 + re] = V >>> 16 & 255, J[2 + re] = V >>> 8 & 255, J[3 + re] = V & 255;
  }, utils$3.ip = function(J, V, re, ie) {
    for (var oe = 0, pe = 0, ne = 6; ne >= 0; ne -= 2) {
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= V >>> ce + ne & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= J >>> ce + ne & 1;
    }
    for (var ne = 6; ne >= 0; ne -= 2) {
      for (var ce = 1; ce <= 25; ce += 8)
        pe <<= 1, pe |= V >>> ce + ne & 1;
      for (var ce = 1; ce <= 25; ce += 8)
        pe <<= 1, pe |= J >>> ce + ne & 1;
    }
    re[ie + 0] = oe >>> 0, re[ie + 1] = pe >>> 0;
  }, utils$3.rip = function(J, V, re, ie) {
    for (var oe = 0, pe = 0, ne = 0; ne < 4; ne++)
      for (var ce = 24; ce >= 0; ce -= 8)
        oe <<= 1, oe |= V >>> ce + ne & 1, oe <<= 1, oe |= J >>> ce + ne & 1;
    for (var ne = 4; ne < 8; ne++)
      for (var ce = 24; ce >= 0; ce -= 8)
        pe <<= 1, pe |= V >>> ce + ne & 1, pe <<= 1, pe |= J >>> ce + ne & 1;
    re[ie + 0] = oe >>> 0, re[ie + 1] = pe >>> 0;
  }, utils$3.pc1 = function(J, V, re, ie) {
    for (var oe = 0, pe = 0, ne = 7; ne >= 5; ne--) {
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= V >> ce + ne & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= J >> ce + ne & 1;
    }
    for (var ce = 0; ce <= 24; ce += 8)
      oe <<= 1, oe |= V >> ce + ne & 1;
    for (var ne = 1; ne <= 3; ne++) {
      for (var ce = 0; ce <= 24; ce += 8)
        pe <<= 1, pe |= V >> ce + ne & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        pe <<= 1, pe |= J >> ce + ne & 1;
    }
    for (var ce = 0; ce <= 24; ce += 8)
      pe <<= 1, pe |= J >> ce + ne & 1;
    re[ie + 0] = oe >>> 0, re[ie + 1] = pe >>> 0;
  }, utils$3.r28shl = function(J, V) {
    return J << V & 268435455 | J >>> 28 - V;
  };
  var B = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$3.pc2 = function(J, V, re, ie) {
    for (var oe = 0, pe = 0, ne = B.length >>> 1, ce = 0; ce < ne; ce++)
      oe <<= 1, oe |= J >>> B[ce] & 1;
    for (var ce = ne; ce < B.length; ce++)
      pe <<= 1, pe |= V >>> B[ce] & 1;
    re[ie + 0] = oe >>> 0, re[ie + 1] = pe >>> 0;
  }, utils$3.expand = function(J, V, re) {
    var ie = 0, oe = 0;
    ie = (J & 1) << 5 | J >>> 27;
    for (var pe = 23; pe >= 15; pe -= 4)
      ie <<= 6, ie |= J >>> pe & 63;
    for (var pe = 11; pe >= 3; pe -= 4)
      oe |= J >>> pe & 63, oe <<= 6;
    oe |= (J & 31) << 1 | J >>> 31, V[re + 0] = ie >>> 0, V[re + 1] = oe >>> 0;
  };
  var L = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$3.substitute = function(J, V) {
    for (var re = 0, ie = 0; ie < 4; ie++) {
      var oe = J >>> 18 - ie * 6 & 63, pe = L[ie * 64 + oe];
      re <<= 4, re |= pe;
    }
    for (var ie = 0; ie < 4; ie++) {
      var oe = V >>> 18 - ie * 6 & 63, pe = L[4 * 64 + ie * 64 + oe];
      re <<= 4, re |= pe;
    }
    return re >>> 0;
  };
  var W = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$3.permute = function(J) {
    for (var V = 0, re = 0; re < W.length; re++)
      V <<= 1, V |= J >>> W[re] & 1;
    return V >>> 0;
  }, utils$3.padSplit = function(J, V, re) {
    for (var ie = J.toString(2); ie.length < V; )
      ie = "0" + ie;
    for (var oe = [], pe = 0; pe < V; pe += re)
      oe.push(ie.slice(pe, pe + re));
    return oe.join(" ");
  }, utils$3;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = B;
  function B(L, W) {
    if (!L)
      throw new Error(W || "Assertion failed");
  }
  return B.equal = function(W, K, J) {
    if (W != K)
      throw new Error(J || "Assertion failed: " + W + " != " + K);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var B = requireMinimalisticAssert();
  function L(W) {
    this.options = W, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = W.padding !== !1;
  }
  return cipher = L, L.prototype._init = function() {
  }, L.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, L.prototype._buffer = function(K, J) {
    for (var V = Math.min(this.buffer.length - this.bufferOff, K.length - J), re = 0; re < V; re++)
      this.buffer[this.bufferOff + re] = K[J + re];
    return this.bufferOff += V, V;
  }, L.prototype._flushBuffer = function(K, J) {
    return this._update(this.buffer, 0, K, J), this.bufferOff = 0, this.blockSize;
  }, L.prototype._updateEncrypt = function(K) {
    var J = 0, V = 0, re = (this.bufferOff + K.length) / this.blockSize | 0, ie = new Array(re * this.blockSize);
    this.bufferOff !== 0 && (J += this._buffer(K, J), this.bufferOff === this.buffer.length && (V += this._flushBuffer(ie, V)));
    for (var oe = K.length - (K.length - J) % this.blockSize; J < oe; J += this.blockSize)
      this._update(K, J, ie, V), V += this.blockSize;
    for (; J < K.length; J++, this.bufferOff++)
      this.buffer[this.bufferOff] = K[J];
    return ie;
  }, L.prototype._updateDecrypt = function(K) {
    for (var J = 0, V = 0, re = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, ie = new Array(re * this.blockSize); re > 0; re--)
      J += this._buffer(K, J), V += this._flushBuffer(ie, V);
    return J += this._buffer(K, J), ie;
  }, L.prototype.final = function(K) {
    var J;
    K && (J = this.update(K));
    var V;
    return this.type === "encrypt" ? V = this._finalEncrypt() : V = this._finalDecrypt(), J ? J.concat(V) : V;
  }, L.prototype._pad = function(K, J) {
    if (J === 0)
      return !1;
    for (; J < K.length; )
      K[J++] = 0;
    return !0;
  }, L.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, L.prototype._unpad = function(K) {
    return K;
  }, L.prototype._finalDecrypt = function() {
    B.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser(), W = requireUtils$3(), K = requireCipher();
  function J() {
    this.tmp = new Array(2), this.keys = null;
  }
  function V(ie) {
    K.call(this, ie);
    var oe = new J();
    this._desState = oe, this.deriveKeys(oe, ie.key);
  }
  L(V, K), des = V, V.create = function(oe) {
    return new V(oe);
  };
  var re = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return V.prototype.deriveKeys = function(oe, pe) {
    oe.keys = new Array(16 * 2), B.equal(pe.length, this.blockSize, "Invalid key length");
    var ne = W.readUInt32BE(pe, 0), ce = W.readUInt32BE(pe, 4);
    W.pc1(ne, ce, oe.tmp, 0), ne = oe.tmp[0], ce = oe.tmp[1];
    for (var Ce = 0; Ce < oe.keys.length; Ce += 2) {
      var Oe = re[Ce >>> 1];
      ne = W.r28shl(ne, Oe), ce = W.r28shl(ce, Oe), W.pc2(ne, ce, oe.keys, Ce);
    }
  }, V.prototype._update = function(oe, pe, ne, ce) {
    var Ce = this._desState, Oe = W.readUInt32BE(oe, pe), st = W.readUInt32BE(oe, pe + 4);
    W.ip(Oe, st, Ce.tmp, 0), Oe = Ce.tmp[0], st = Ce.tmp[1], this.type === "encrypt" ? this._encrypt(Ce, Oe, st, Ce.tmp, 0) : this._decrypt(Ce, Oe, st, Ce.tmp, 0), Oe = Ce.tmp[0], st = Ce.tmp[1], W.writeUInt32BE(ne, Oe, ce), W.writeUInt32BE(ne, st, ce + 4);
  }, V.prototype._pad = function(oe, pe) {
    if (this.padding === !1)
      return !1;
    for (var ne = oe.length - pe, ce = pe; ce < oe.length; ce++)
      oe[ce] = ne;
    return !0;
  }, V.prototype._unpad = function(oe) {
    if (this.padding === !1)
      return oe;
    for (var pe = oe[oe.length - 1], ne = oe.length - pe; ne < oe.length; ne++)
      B.equal(oe[ne], pe);
    return oe.slice(0, oe.length - pe);
  }, V.prototype._encrypt = function(oe, pe, ne, ce, Ce) {
    for (var Oe = pe, st = ne, at = 0; at < oe.keys.length; at += 2) {
      var lt = oe.keys[at], pt = oe.keys[at + 1];
      W.expand(st, oe.tmp, 0), lt ^= oe.tmp[0], pt ^= oe.tmp[1];
      var ht = W.substitute(lt, pt), yt = W.permute(ht), vt = st;
      st = (Oe ^ yt) >>> 0, Oe = vt;
    }
    W.rip(st, Oe, ce, Ce);
  }, V.prototype._decrypt = function(oe, pe, ne, ce, Ce) {
    for (var Oe = ne, st = pe, at = oe.keys.length - 2; at >= 0; at -= 2) {
      var lt = oe.keys[at], pt = oe.keys[at + 1];
      W.expand(Oe, oe.tmp, 0), lt ^= oe.tmp[0], pt ^= oe.tmp[1];
      var ht = W.substitute(lt, pt), yt = W.permute(ht), vt = Oe;
      Oe = (st ^ yt) >>> 0, st = vt;
    }
    W.rip(Oe, st, ce, Ce);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser(), W = {};
  function K(V) {
    B.equal(V.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var re = 0; re < this.iv.length; re++)
      this.iv[re] = V[re];
  }
  function J(V) {
    function re(ne) {
      V.call(this, ne), this._cbcInit();
    }
    L(re, V);
    for (var ie = Object.keys(W), oe = 0; oe < ie.length; oe++) {
      var pe = ie[oe];
      re.prototype[pe] = W[pe];
    }
    return re.create = function(ce) {
      return new re(ce);
    }, re;
  }
  return cbc$1.instantiate = J, W._cbcInit = function() {
    var re = new K(this.options.iv);
    this._cbcState = re;
  }, W._update = function(re, ie, oe, pe) {
    var ne = this._cbcState, ce = this.constructor.super_.prototype, Ce = ne.iv;
    if (this.type === "encrypt") {
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        Ce[Oe] ^= re[ie + Oe];
      ce._update.call(this, Ce, 0, oe, pe);
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        Ce[Oe] = oe[pe + Oe];
    } else {
      ce._update.call(this, re, ie, oe, pe);
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        oe[pe + Oe] ^= Ce[Oe];
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        Ce[Oe] = re[ie + Oe];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser(), W = requireCipher(), K = requireDes$1();
  function J(re, ie) {
    B.equal(ie.length, 24, "Invalid key length");
    var oe = ie.slice(0, 8), pe = ie.slice(8, 16), ne = ie.slice(16, 24);
    re === "encrypt" ? this.ciphers = [
      K.create({ type: "encrypt", key: oe }),
      K.create({ type: "decrypt", key: pe }),
      K.create({ type: "encrypt", key: ne })
    ] : this.ciphers = [
      K.create({ type: "decrypt", key: ne }),
      K.create({ type: "encrypt", key: pe }),
      K.create({ type: "decrypt", key: oe })
    ];
  }
  function V(re) {
    W.call(this, re);
    var ie = new J(this.type, this.options.key);
    this._edeState = ie;
  }
  return L(V, W), ede = V, V.create = function(ie) {
    return new V(ie);
  }, V.prototype._update = function(ie, oe, pe, ne) {
    var ce = this._edeState;
    ce.ciphers[0]._update(ie, oe, pe, ne), ce.ciphers[1]._update(pe, ne, pe, ne), ce.ciphers[2]._update(pe, ne, pe, ne);
  }, V.prototype._pad = K.prototype._pad, V.prototype._unpad = K.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var B = requireCipherBase(), L = requireDes(), W = requireInherits_browser(), K = safeBufferExports.Buffer, J = {
    "des-ede3-cbc": L.CBC.instantiate(L.EDE),
    "des-ede3": L.EDE,
    "des-ede-cbc": L.CBC.instantiate(L.EDE),
    "des-ede": L.EDE,
    "des-cbc": L.CBC.instantiate(L.DES),
    "des-ecb": L.DES
  };
  J.des = J["des-cbc"], J.des3 = J["des-ede3-cbc"], browserifyDes = V, W(V, B);
  function V(re) {
    B.call(this);
    var ie = re.mode.toLowerCase(), oe = J[ie], pe;
    re.decrypt ? pe = "decrypt" : pe = "encrypt";
    var ne = re.key;
    K.isBuffer(ne) || (ne = K.from(ne)), (ie === "des-ede" || ie === "des-ede-cbc") && (ne = K.concat([ne, ne.slice(0, 8)]));
    var ce = re.iv;
    K.isBuffer(ce) || (ce = K.from(ce)), this._des = oe.create({
      key: ne,
      iv: ce,
      type: pe
    });
  }
  return V.prototype._update = function(re) {
    return K.from(this._des.update(re));
  }, V.prototype._final = function() {
    return K.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(B, L) {
    return B._cipher.encryptBlock(L);
  }, ecb.decrypt = function(B, L) {
    return B._cipher.decryptBlock(L);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(L, W) {
    for (var K = Math.min(L.length, W.length), J = new Buffer$2(K), V = 0; V < K; ++V)
      J[V] = L[V] ^ W[V];
    return J;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var B = requireBufferXor();
  return cbc.encrypt = function(L, W) {
    var K = B(W, L._prev);
    return L._prev = L._cipher.encryptBlock(K), L._prev;
  }, cbc.decrypt = function(L, W) {
    var K = L._prev;
    L._prev = W;
    var J = L._cipher.decryptBlock(W);
    return B(J, K);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var B = safeBufferExports.Buffer, L = requireBufferXor();
  function W(K, J, V) {
    var re = J.length, ie = L(J, K._cache);
    return K._cache = K._cache.slice(re), K._prev = B.concat([K._prev, V ? J : ie]), ie;
  }
  return cfb.encrypt = function(K, J, V) {
    for (var re = B.allocUnsafe(0), ie; J.length; )
      if (K._cache.length === 0 && (K._cache = K._cipher.encryptBlock(K._prev), K._prev = B.allocUnsafe(0)), K._cache.length <= J.length)
        ie = K._cache.length, re = B.concat([re, W(K, J.slice(0, ie), V)]), J = J.slice(ie);
      else {
        re = B.concat([re, W(K, J, V)]);
        break;
      }
    return re;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var B = safeBufferExports.Buffer;
  function L(W, K, J) {
    var V = W._cipher.encryptBlock(W._prev), re = V[0] ^ K;
    return W._prev = B.concat([
      W._prev.slice(1),
      B.from([J ? K : re])
    ]), re;
  }
  return cfb8.encrypt = function(W, K, J) {
    for (var V = K.length, re = B.allocUnsafe(V), ie = -1; ++ie < V; )
      re[ie] = L(W, K[ie], J);
    return re;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var B = safeBufferExports.Buffer;
  function L(K, J, V) {
    for (var re, ie = -1, oe = 8, pe = 0, ne, ce; ++ie < oe; )
      re = K._cipher.encryptBlock(K._prev), ne = J & 1 << 7 - ie ? 128 : 0, ce = re[0] ^ ne, pe += (ce & 128) >> ie % 8, K._prev = W(K._prev, V ? ne : ce);
    return pe;
  }
  function W(K, J) {
    var V = K.length, re = -1, ie = B.allocUnsafe(K.length);
    for (K = B.concat([K, B.from([J])]); ++re < V; )
      ie[re] = K[re] << 1 | K[re + 1] >> 7;
    return ie;
  }
  return cfb1.encrypt = function(K, J, V) {
    for (var re = J.length, ie = B.allocUnsafe(re), oe = -1; ++oe < re; )
      ie[oe] = L(K, J[oe], V);
    return ie;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var B = requireBufferXor();
  function L(W) {
    return W._prev = W._cipher.encryptBlock(W._prev), W._prev;
  }
  return ofb.encrypt = function(W, K) {
    for (; W._cache.length < K.length; )
      W._cache = Buffer$2.concat([W._cache, L(W)]);
    var J = W._cache.slice(0, K.length);
    return W._cache = W._cache.slice(K.length), B(K, J);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function B(L) {
    for (var W = L.length, K; W--; )
      if (K = L.readUInt8(W), K === 255)
        L.writeUInt8(0, W);
      else {
        K++, L.writeUInt8(K, W);
        break;
      }
  }
  return incr32_1 = B, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var B = requireBufferXor(), L = safeBufferExports.Buffer, W = requireIncr32();
  function K(V) {
    var re = V._cipher.encryptBlockRaw(V._prev);
    return W(V._prev), re;
  }
  var J = 16;
  return ctr.encrypt = function(V, re) {
    var ie = Math.ceil(re.length / J), oe = V._cache.length;
    V._cache = L.concat([
      V._cache,
      L.allocUnsafe(ie * J)
    ]);
    for (var pe = 0; pe < ie; pe++) {
      var ne = K(V), ce = oe + pe * J;
      V._cache.writeUInt32BE(ne[0], ce + 0), V._cache.writeUInt32BE(ne[1], ce + 4), V._cache.writeUInt32BE(ne[2], ce + 8), V._cache.writeUInt32BE(ne[3], ce + 12);
    }
    var Ce = V._cache.slice(0, re.length);
    return V._cache = V._cache.slice(re.length), B(re, Ce);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var B = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, L = require$$2;
  for (var W in L)
    L[W].module = B[L[W].mode];
  return modes_1 = L, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var B = safeBufferExports.Buffer;
  function L(ie) {
    B.isBuffer(ie) || (ie = B.from(ie));
    for (var oe = ie.length / 4 | 0, pe = new Array(oe), ne = 0; ne < oe; ne++)
      pe[ne] = ie.readUInt32BE(ne * 4);
    return pe;
  }
  function W(ie) {
    for (var oe = 0; oe < ie.length; ie++)
      ie[oe] = 0;
  }
  function K(ie, oe, pe, ne, ce) {
    for (var Ce = pe[0], Oe = pe[1], st = pe[2], at = pe[3], lt = ie[0] ^ oe[0], pt = ie[1] ^ oe[1], ht = ie[2] ^ oe[2], yt = ie[3] ^ oe[3], vt, $t, xt, Ct, Et = 4, St = 1; St < ce; St++)
      vt = Ce[lt >>> 24] ^ Oe[pt >>> 16 & 255] ^ st[ht >>> 8 & 255] ^ at[yt & 255] ^ oe[Et++], $t = Ce[pt >>> 24] ^ Oe[ht >>> 16 & 255] ^ st[yt >>> 8 & 255] ^ at[lt & 255] ^ oe[Et++], xt = Ce[ht >>> 24] ^ Oe[yt >>> 16 & 255] ^ st[lt >>> 8 & 255] ^ at[pt & 255] ^ oe[Et++], Ct = Ce[yt >>> 24] ^ Oe[lt >>> 16 & 255] ^ st[pt >>> 8 & 255] ^ at[ht & 255] ^ oe[Et++], lt = vt, pt = $t, ht = xt, yt = Ct;
    return vt = (ne[lt >>> 24] << 24 | ne[pt >>> 16 & 255] << 16 | ne[ht >>> 8 & 255] << 8 | ne[yt & 255]) ^ oe[Et++], $t = (ne[pt >>> 24] << 24 | ne[ht >>> 16 & 255] << 16 | ne[yt >>> 8 & 255] << 8 | ne[lt & 255]) ^ oe[Et++], xt = (ne[ht >>> 24] << 24 | ne[yt >>> 16 & 255] << 16 | ne[lt >>> 8 & 255] << 8 | ne[pt & 255]) ^ oe[Et++], Ct = (ne[yt >>> 24] << 24 | ne[lt >>> 16 & 255] << 16 | ne[pt >>> 8 & 255] << 8 | ne[ht & 255]) ^ oe[Et++], vt = vt >>> 0, $t = $t >>> 0, xt = xt >>> 0, Ct = Ct >>> 0, [vt, $t, xt, Ct];
  }
  var J = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], V = function() {
    for (var ie = new Array(256), oe = 0; oe < 256; oe++)
      oe < 128 ? ie[oe] = oe << 1 : ie[oe] = oe << 1 ^ 283;
    for (var pe = [], ne = [], ce = [[], [], [], []], Ce = [[], [], [], []], Oe = 0, st = 0, at = 0; at < 256; ++at) {
      var lt = st ^ st << 1 ^ st << 2 ^ st << 3 ^ st << 4;
      lt = lt >>> 8 ^ lt & 255 ^ 99, pe[Oe] = lt, ne[lt] = Oe;
      var pt = ie[Oe], ht = ie[pt], yt = ie[ht], vt = ie[lt] * 257 ^ lt * 16843008;
      ce[0][Oe] = vt << 24 | vt >>> 8, ce[1][Oe] = vt << 16 | vt >>> 16, ce[2][Oe] = vt << 8 | vt >>> 24, ce[3][Oe] = vt, vt = yt * 16843009 ^ ht * 65537 ^ pt * 257 ^ Oe * 16843008, Ce[0][lt] = vt << 24 | vt >>> 8, Ce[1][lt] = vt << 16 | vt >>> 16, Ce[2][lt] = vt << 8 | vt >>> 24, Ce[3][lt] = vt, Oe === 0 ? Oe = st = 1 : (Oe = pt ^ ie[ie[ie[yt ^ pt]]], st ^= ie[ie[st]]);
    }
    return {
      SBOX: pe,
      INV_SBOX: ne,
      SUB_MIX: ce,
      INV_SUB_MIX: Ce
    };
  }();
  function re(ie) {
    this._key = L(ie), this._reset();
  }
  return re.blockSize = 4 * 4, re.keySize = 256 / 8, re.prototype.blockSize = re.blockSize, re.prototype.keySize = re.keySize, re.prototype._reset = function() {
    for (var ie = this._key, oe = ie.length, pe = oe + 6, ne = (pe + 1) * 4, ce = [], Ce = 0; Ce < oe; Ce++)
      ce[Ce] = ie[Ce];
    for (Ce = oe; Ce < ne; Ce++) {
      var Oe = ce[Ce - 1];
      Ce % oe === 0 ? (Oe = Oe << 8 | Oe >>> 24, Oe = V.SBOX[Oe >>> 24] << 24 | V.SBOX[Oe >>> 16 & 255] << 16 | V.SBOX[Oe >>> 8 & 255] << 8 | V.SBOX[Oe & 255], Oe ^= J[Ce / oe | 0] << 24) : oe > 6 && Ce % oe === 4 && (Oe = V.SBOX[Oe >>> 24] << 24 | V.SBOX[Oe >>> 16 & 255] << 16 | V.SBOX[Oe >>> 8 & 255] << 8 | V.SBOX[Oe & 255]), ce[Ce] = ce[Ce - oe] ^ Oe;
    }
    for (var st = [], at = 0; at < ne; at++) {
      var lt = ne - at, pt = ce[lt - (at % 4 ? 0 : 4)];
      at < 4 || lt <= 4 ? st[at] = pt : st[at] = V.INV_SUB_MIX[0][V.SBOX[pt >>> 24]] ^ V.INV_SUB_MIX[1][V.SBOX[pt >>> 16 & 255]] ^ V.INV_SUB_MIX[2][V.SBOX[pt >>> 8 & 255]] ^ V.INV_SUB_MIX[3][V.SBOX[pt & 255]];
    }
    this._nRounds = pe, this._keySchedule = ce, this._invKeySchedule = st;
  }, re.prototype.encryptBlockRaw = function(ie) {
    return ie = L(ie), K(ie, this._keySchedule, V.SUB_MIX, V.SBOX, this._nRounds);
  }, re.prototype.encryptBlock = function(ie) {
    var oe = this.encryptBlockRaw(ie), pe = B.allocUnsafe(16);
    return pe.writeUInt32BE(oe[0], 0), pe.writeUInt32BE(oe[1], 4), pe.writeUInt32BE(oe[2], 8), pe.writeUInt32BE(oe[3], 12), pe;
  }, re.prototype.decryptBlock = function(ie) {
    ie = L(ie);
    var oe = ie[1];
    ie[1] = ie[3], ie[3] = oe;
    var pe = K(ie, this._invKeySchedule, V.INV_SUB_MIX, V.INV_SBOX, this._nRounds), ne = B.allocUnsafe(16);
    return ne.writeUInt32BE(pe[0], 0), ne.writeUInt32BE(pe[3], 4), ne.writeUInt32BE(pe[2], 8), ne.writeUInt32BE(pe[1], 12), ne;
  }, re.prototype.scrub = function() {
    W(this._keySchedule), W(this._invKeySchedule), W(this._key);
  }, aes.AES = re, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var B = safeBufferExports.Buffer, L = B.alloc(16, 0);
  function W(V) {
    return [
      V.readUInt32BE(0),
      V.readUInt32BE(4),
      V.readUInt32BE(8),
      V.readUInt32BE(12)
    ];
  }
  function K(V) {
    var re = B.allocUnsafe(16);
    return re.writeUInt32BE(V[0] >>> 0, 0), re.writeUInt32BE(V[1] >>> 0, 4), re.writeUInt32BE(V[2] >>> 0, 8), re.writeUInt32BE(V[3] >>> 0, 12), re;
  }
  function J(V) {
    this.h = V, this.state = B.alloc(16, 0), this.cache = B.allocUnsafe(0);
  }
  return J.prototype.ghash = function(V) {
    for (var re = -1; ++re < V.length; )
      this.state[re] ^= V[re];
    this._multiply();
  }, J.prototype._multiply = function() {
    for (var V = W(this.h), re = [0, 0, 0, 0], ie, oe, pe, ne = -1; ++ne < 128; ) {
      for (oe = (this.state[~~(ne / 8)] & 1 << 7 - ne % 8) !== 0, oe && (re[0] ^= V[0], re[1] ^= V[1], re[2] ^= V[2], re[3] ^= V[3]), pe = (V[3] & 1) !== 0, ie = 3; ie > 0; ie--)
        V[ie] = V[ie] >>> 1 | (V[ie - 1] & 1) << 31;
      V[0] = V[0] >>> 1, pe && (V[0] = V[0] ^ 225 << 24);
    }
    this.state = K(re);
  }, J.prototype.update = function(V) {
    this.cache = B.concat([this.cache, V]);
    for (var re; this.cache.length >= 16; )
      re = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(re);
  }, J.prototype.final = function(V, re) {
    return this.cache.length && this.ghash(B.concat([this.cache, L], 16)), this.ghash(K([0, V, 0, re])), this.state;
  }, ghash = J, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var B = requireAes(), L = safeBufferExports.Buffer, W = requireCipherBase(), K = requireInherits_browser(), J = requireGhash(), V = requireBufferXor(), re = requireIncr32();
  function ie(ne, ce) {
    var Ce = 0;
    ne.length !== ce.length && Ce++;
    for (var Oe = Math.min(ne.length, ce.length), st = 0; st < Oe; ++st)
      Ce += ne[st] ^ ce[st];
    return Ce;
  }
  function oe(ne, ce, Ce) {
    if (ce.length === 12)
      return ne._finID = L.concat([ce, L.from([0, 0, 0, 1])]), L.concat([ce, L.from([0, 0, 0, 2])]);
    var Oe = new J(Ce), st = ce.length, at = st % 16;
    Oe.update(ce), at && (at = 16 - at, Oe.update(L.alloc(at, 0))), Oe.update(L.alloc(8, 0));
    var lt = st * 8, pt = L.alloc(8);
    pt.writeUIntBE(lt, 0, 8), Oe.update(pt), ne._finID = Oe.state;
    var ht = L.from(ne._finID);
    return re(ht), ht;
  }
  function pe(ne, ce, Ce, Oe) {
    W.call(this);
    var st = L.alloc(4, 0);
    this._cipher = new B.AES(ce);
    var at = this._cipher.encryptBlock(st);
    this._ghash = new J(at), Ce = oe(this, Ce, at), this._prev = L.from(Ce), this._cache = L.allocUnsafe(0), this._secCache = L.allocUnsafe(0), this._decrypt = Oe, this._alen = 0, this._len = 0, this._mode = ne, this._authTag = null, this._called = !1;
  }
  return K(pe, W), pe.prototype._update = function(ne) {
    if (!this._called && this._alen) {
      var ce = 16 - this._alen % 16;
      ce < 16 && (ce = L.alloc(ce, 0), this._ghash.update(ce));
    }
    this._called = !0;
    var Ce = this._mode.encrypt(this, ne);
    return this._decrypt ? this._ghash.update(ne) : this._ghash.update(Ce), this._len += ne.length, Ce;
  }, pe.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var ne = V(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ie(ne, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = ne, this._cipher.scrub();
  }, pe.prototype.getAuthTag = function() {
    if (this._decrypt || !L.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, pe.prototype.setAuthTag = function(ce) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = ce;
  }, pe.prototype.setAAD = function(ce) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(ce), this._alen += ce.length;
  }, authCipher = pe, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var B = requireAes(), L = safeBufferExports.Buffer, W = requireCipherBase(), K = requireInherits_browser();
  function J(V, re, ie, oe) {
    W.call(this), this._cipher = new B.AES(re), this._prev = L.from(ie), this._cache = L.allocUnsafe(0), this._secCache = L.allocUnsafe(0), this._decrypt = oe, this._mode = V;
  }
  return K(J, W), J.prototype._update = function(V) {
    return this._mode.encrypt(this, V, this._decrypt);
  }, J.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = J, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var B = safeBufferExports.Buffer, L = requireMd5_js();
  function W(K, J, V, re) {
    if (B.isBuffer(K) || (K = B.from(K, "binary")), J && (B.isBuffer(J) || (J = B.from(J, "binary")), J.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var ie = V / 8, oe = B.alloc(ie), pe = B.alloc(re || 0), ne = B.alloc(0); ie > 0 || re > 0; ) {
      var ce = new L();
      ce.update(ne), ce.update(K), J && ce.update(J), ne = ce.digest();
      var Ce = 0;
      if (ie > 0) {
        var Oe = oe.length - ie;
        Ce = Math.min(ie, ne.length), ne.copy(oe, Oe, 0, Ce), ie -= Ce;
      }
      if (Ce < ne.length && re > 0) {
        var st = pe.length - re, at = Math.min(re, ne.length - Ce);
        ne.copy(pe, st, Ce, Ce + at), re -= at;
      }
    }
    return ne.fill(0), { key: oe, iv: pe };
  }
  return evp_bytestokey = W, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var B = requireModes$1(), L = requireAuthCipher(), W = safeBufferExports.Buffer, K = requireStreamCipher(), J = requireCipherBase(), V = requireAes(), re = requireEvp_bytestokey(), ie = requireInherits_browser();
  function oe(Oe, st, at) {
    J.call(this), this._cache = new ne(), this._cipher = new V.AES(st), this._prev = W.from(at), this._mode = Oe, this._autopadding = !0;
  }
  ie(oe, J), oe.prototype._update = function(Oe) {
    this._cache.add(Oe);
    for (var st, at, lt = []; st = this._cache.get(); )
      at = this._mode.encrypt(this, st), lt.push(at);
    return W.concat(lt);
  };
  var pe = W.alloc(16, 16);
  oe.prototype._final = function() {
    var Oe = this._cache.flush();
    if (this._autopadding)
      return Oe = this._mode.encrypt(this, Oe), this._cipher.scrub(), Oe;
    if (!Oe.equals(pe))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, oe.prototype.setAutoPadding = function(Oe) {
    return this._autopadding = !!Oe, this;
  };
  function ne() {
    this.cache = W.allocUnsafe(0);
  }
  ne.prototype.add = function(Oe) {
    this.cache = W.concat([this.cache, Oe]);
  }, ne.prototype.get = function() {
    if (this.cache.length > 15) {
      var Oe = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Oe;
    }
    return null;
  }, ne.prototype.flush = function() {
    for (var Oe = 16 - this.cache.length, st = W.allocUnsafe(Oe), at = -1; ++at < Oe; )
      st.writeUInt8(Oe, at);
    return W.concat([this.cache, st]);
  };
  function ce(Oe, st, at) {
    var lt = B[Oe.toLowerCase()];
    if (!lt) throw new TypeError("invalid suite type");
    if (typeof st == "string" && (st = W.from(st)), st.length !== lt.key / 8) throw new TypeError("invalid key length " + st.length);
    if (typeof at == "string" && (at = W.from(at)), lt.mode !== "GCM" && at.length !== lt.iv) throw new TypeError("invalid iv length " + at.length);
    return lt.type === "stream" ? new K(lt.module, st, at) : lt.type === "auth" ? new L(lt.module, st, at) : new oe(lt.module, st, at);
  }
  function Ce(Oe, st) {
    var at = B[Oe.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var lt = re(st, !1, at.key, at.iv);
    return ce(Oe, lt.key, lt.iv);
  }
  return encrypter.createCipheriv = ce, encrypter.createCipher = Ce, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var B = requireAuthCipher(), L = safeBufferExports.Buffer, W = requireModes$1(), K = requireStreamCipher(), J = requireCipherBase(), V = requireAes(), re = requireEvp_bytestokey(), ie = requireInherits_browser();
  function oe(Oe, st, at) {
    J.call(this), this._cache = new pe(), this._last = void 0, this._cipher = new V.AES(st), this._prev = L.from(at), this._mode = Oe, this._autopadding = !0;
  }
  ie(oe, J), oe.prototype._update = function(Oe) {
    this._cache.add(Oe);
    for (var st, at, lt = []; st = this._cache.get(this._autopadding); )
      at = this._mode.decrypt(this, st), lt.push(at);
    return L.concat(lt);
  }, oe.prototype._final = function() {
    var Oe = this._cache.flush();
    if (this._autopadding)
      return ne(this._mode.decrypt(this, Oe));
    if (Oe)
      throw new Error("data not multiple of block length");
  }, oe.prototype.setAutoPadding = function(Oe) {
    return this._autopadding = !!Oe, this;
  };
  function pe() {
    this.cache = L.allocUnsafe(0);
  }
  pe.prototype.add = function(Oe) {
    this.cache = L.concat([this.cache, Oe]);
  }, pe.prototype.get = function(Oe) {
    var st;
    if (Oe) {
      if (this.cache.length > 16)
        return st = this.cache.slice(0, 16), this.cache = this.cache.slice(16), st;
    } else if (this.cache.length >= 16)
      return st = this.cache.slice(0, 16), this.cache = this.cache.slice(16), st;
    return null;
  }, pe.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function ne(Oe) {
    var st = Oe[15];
    if (st < 1 || st > 16)
      throw new Error("unable to decrypt data");
    for (var at = -1; ++at < st; )
      if (Oe[at + (16 - st)] !== st)
        throw new Error("unable to decrypt data");
    if (st !== 16)
      return Oe.slice(0, 16 - st);
  }
  function ce(Oe, st, at) {
    var lt = W[Oe.toLowerCase()];
    if (!lt) throw new TypeError("invalid suite type");
    if (typeof at == "string" && (at = L.from(at)), lt.mode !== "GCM" && at.length !== lt.iv) throw new TypeError("invalid iv length " + at.length);
    if (typeof st == "string" && (st = L.from(st)), st.length !== lt.key / 8) throw new TypeError("invalid key length " + st.length);
    return lt.type === "stream" ? new K(lt.module, st, at, !0) : lt.type === "auth" ? new B(lt.module, st, at, !0) : new oe(lt.module, st, at);
  }
  function Ce(Oe, st) {
    var at = W[Oe.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var lt = re(st, !1, at.key, at.iv);
    return ce(Oe, lt.key, lt.iv);
  }
  return decrypter.createDecipher = Ce, decrypter.createDecipheriv = ce, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var B = requireEncrypter(), L = requireDecrypter(), W = require$$2;
  function K() {
    return Object.keys(W);
  }
  return browser$5.createCipher = browser$5.Cipher = B.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = B.createCipheriv, browser$5.createDecipher = browser$5.Decipher = L.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = L.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = K, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(B) {
    B["des-ecb"] = {
      key: 8,
      iv: 0
    }, B["des-cbc"] = B.des = {
      key: 8,
      iv: 8
    }, B["des-ede3-cbc"] = B.des3 = {
      key: 24,
      iv: 8
    }, B["des-ede3"] = {
      key: 24,
      iv: 0
    }, B["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, B["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var B = requireBrowserifyDes(), L = requireBrowser$6(), W = requireModes$1(), K = requireModes(), J = requireEvp_bytestokey();
  function V(ne, ce) {
    ne = ne.toLowerCase();
    var Ce, Oe;
    if (W[ne])
      Ce = W[ne].key, Oe = W[ne].iv;
    else if (K[ne])
      Ce = K[ne].key * 8, Oe = K[ne].iv;
    else
      throw new TypeError("invalid suite type");
    var st = J(ce, !1, Ce, Oe);
    return ie(ne, st.key, st.iv);
  }
  function re(ne, ce) {
    ne = ne.toLowerCase();
    var Ce, Oe;
    if (W[ne])
      Ce = W[ne].key, Oe = W[ne].iv;
    else if (K[ne])
      Ce = K[ne].key * 8, Oe = K[ne].iv;
    else
      throw new TypeError("invalid suite type");
    var st = J(ce, !1, Ce, Oe);
    return oe(ne, st.key, st.iv);
  }
  function ie(ne, ce, Ce) {
    if (ne = ne.toLowerCase(), W[ne]) return L.createCipheriv(ne, ce, Ce);
    if (K[ne]) return new B({ key: ce, iv: Ce, mode: ne });
    throw new TypeError("invalid suite type");
  }
  function oe(ne, ce, Ce) {
    if (ne = ne.toLowerCase(), W[ne]) return L.createDecipheriv(ne, ce, Ce);
    if (K[ne]) return new B({ key: ce, iv: Ce, mode: ne, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function pe() {
    return Object.keys(K).concat(L.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = V, browser$6.createCipheriv = browser$6.Cipheriv = ie, browser$6.createDecipher = browser$6.Decipher = re, browser$6.createDecipheriv = browser$6.Decipheriv = oe, browser$6.listCiphers = browser$6.getCiphers = pe, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(B) {
    (function(L, W) {
      function K(Tt, nt) {
        if (!Tt) throw new Error(nt || "Assertion failed");
      }
      function J(Tt, nt) {
        Tt.super_ = nt;
        var it = function() {
        };
        it.prototype = nt.prototype, Tt.prototype = new it(), Tt.prototype.constructor = Tt;
      }
      function V(Tt, nt, it) {
        if (V.isBN(Tt))
          return Tt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Tt !== null && ((nt === "le" || nt === "be") && (it = nt, nt = 10), this._init(Tt || 0, nt || 10, it || "be"));
      }
      typeof L == "object" ? L.exports = V : W.BN = V, V.BN = V, V.wordSize = 26;
      var re;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? re = window.Buffer : re = require$$1$2.Buffer;
      } catch {
      }
      V.isBN = function(nt) {
        return nt instanceof V ? !0 : nt !== null && typeof nt == "object" && nt.constructor.wordSize === V.wordSize && Array.isArray(nt.words);
      }, V.max = function(nt, it) {
        return nt.cmp(it) > 0 ? nt : it;
      }, V.min = function(nt, it) {
        return nt.cmp(it) < 0 ? nt : it;
      }, V.prototype._init = function(nt, it, ke) {
        if (typeof nt == "number")
          return this._initNumber(nt, it, ke);
        if (typeof nt == "object")
          return this._initArray(nt, it, ke);
        it === "hex" && (it = 16), K(it === (it | 0) && it >= 2 && it <= 36), nt = nt.toString().replace(/\s+/g, "");
        var rt = 0;
        nt[0] === "-" && (rt++, this.negative = 1), rt < nt.length && (it === 16 ? this._parseHex(nt, rt, ke) : (this._parseBase(nt, it, rt), ke === "le" && this._initArray(this.toArray(), it, ke)));
      }, V.prototype._initNumber = function(nt, it, ke) {
        nt < 0 && (this.negative = 1, nt = -nt), nt < 67108864 ? (this.words = [nt & 67108863], this.length = 1) : nt < 4503599627370496 ? (this.words = [
          nt & 67108863,
          nt / 67108864 & 67108863
        ], this.length = 2) : (K(nt < 9007199254740992), this.words = [
          nt & 67108863,
          nt / 67108864 & 67108863,
          1
        ], this.length = 3), ke === "le" && this._initArray(this.toArray(), it, ke);
      }, V.prototype._initArray = function(nt, it, ke) {
        if (K(typeof nt.length == "number"), nt.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(nt.length / 3), this.words = new Array(this.length);
        for (var rt = 0; rt < this.length; rt++)
          this.words[rt] = 0;
        var ot, ft, ct = 0;
        if (ke === "be")
          for (rt = nt.length - 1, ot = 0; rt >= 0; rt -= 3)
            ft = nt[rt] | nt[rt - 1] << 8 | nt[rt - 2] << 16, this.words[ot] |= ft << ct & 67108863, this.words[ot + 1] = ft >>> 26 - ct & 67108863, ct += 24, ct >= 26 && (ct -= 26, ot++);
        else if (ke === "le")
          for (rt = 0, ot = 0; rt < nt.length; rt += 3)
            ft = nt[rt] | nt[rt + 1] << 8 | nt[rt + 2] << 16, this.words[ot] |= ft << ct & 67108863, this.words[ot + 1] = ft >>> 26 - ct & 67108863, ct += 24, ct >= 26 && (ct -= 26, ot++);
        return this.strip();
      };
      function ie(Tt, nt) {
        var it = Tt.charCodeAt(nt);
        return it >= 65 && it <= 70 ? it - 55 : it >= 97 && it <= 102 ? it - 87 : it - 48 & 15;
      }
      function oe(Tt, nt, it) {
        var ke = ie(Tt, it);
        return it - 1 >= nt && (ke |= ie(Tt, it - 1) << 4), ke;
      }
      V.prototype._parseHex = function(nt, it, ke) {
        this.length = Math.ceil((nt.length - it) / 6), this.words = new Array(this.length);
        for (var rt = 0; rt < this.length; rt++)
          this.words[rt] = 0;
        var ot = 0, ft = 0, ct;
        if (ke === "be")
          for (rt = nt.length - 1; rt >= it; rt -= 2)
            ct = oe(nt, it, rt) << ot, this.words[ft] |= ct & 67108863, ot >= 18 ? (ot -= 18, ft += 1, this.words[ft] |= ct >>> 26) : ot += 8;
        else {
          var bt = nt.length - it;
          for (rt = bt % 2 === 0 ? it + 1 : it; rt < nt.length; rt += 2)
            ct = oe(nt, it, rt) << ot, this.words[ft] |= ct & 67108863, ot >= 18 ? (ot -= 18, ft += 1, this.words[ft] |= ct >>> 26) : ot += 8;
        }
        this.strip();
      };
      function pe(Tt, nt, it, ke) {
        for (var rt = 0, ot = Math.min(Tt.length, it), ft = nt; ft < ot; ft++) {
          var ct = Tt.charCodeAt(ft) - 48;
          rt *= ke, ct >= 49 ? rt += ct - 49 + 10 : ct >= 17 ? rt += ct - 17 + 10 : rt += ct;
        }
        return rt;
      }
      V.prototype._parseBase = function(nt, it, ke) {
        this.words = [0], this.length = 1;
        for (var rt = 0, ot = 1; ot <= 67108863; ot *= it)
          rt++;
        rt--, ot = ot / it | 0;
        for (var ft = nt.length - ke, ct = ft % rt, bt = Math.min(ft, ft - ct) + ke, ut = 0, gt = ke; gt < bt; gt += rt)
          ut = pe(nt, gt, gt + rt, it), this.imuln(ot), this.words[0] + ut < 67108864 ? this.words[0] += ut : this._iaddn(ut);
        if (ct !== 0) {
          var dt = 1;
          for (ut = pe(nt, gt, nt.length, it), gt = 0; gt < ct; gt++)
            dt *= it;
          this.imuln(dt), this.words[0] + ut < 67108864 ? this.words[0] += ut : this._iaddn(ut);
        }
        this.strip();
      }, V.prototype.copy = function(nt) {
        nt.words = new Array(this.length);
        for (var it = 0; it < this.length; it++)
          nt.words[it] = this.words[it];
        nt.length = this.length, nt.negative = this.negative, nt.red = this.red;
      }, V.prototype.clone = function() {
        var nt = new V(null);
        return this.copy(nt), nt;
      }, V.prototype._expand = function(nt) {
        for (; this.length < nt; )
          this.words[this.length++] = 0;
        return this;
      }, V.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, V.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, V.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var ne = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], ce = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Ce = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      V.prototype.toString = function(nt, it) {
        nt = nt || 10, it = it | 0 || 1;
        var ke;
        if (nt === 16 || nt === "hex") {
          ke = "";
          for (var rt = 0, ot = 0, ft = 0; ft < this.length; ft++) {
            var ct = this.words[ft], bt = ((ct << rt | ot) & 16777215).toString(16);
            ot = ct >>> 24 - rt & 16777215, ot !== 0 || ft !== this.length - 1 ? ke = ne[6 - bt.length] + bt + ke : ke = bt + ke, rt += 2, rt >= 26 && (rt -= 26, ft--);
          }
          for (ot !== 0 && (ke = ot.toString(16) + ke); ke.length % it !== 0; )
            ke = "0" + ke;
          return this.negative !== 0 && (ke = "-" + ke), ke;
        }
        if (nt === (nt | 0) && nt >= 2 && nt <= 36) {
          var ut = ce[nt], gt = Ce[nt];
          ke = "";
          var dt = this.clone();
          for (dt.negative = 0; !dt.isZero(); ) {
            var wt = dt.modn(gt).toString(nt);
            dt = dt.idivn(gt), dt.isZero() ? ke = wt + ke : ke = ne[ut - wt.length] + wt + ke;
          }
          for (this.isZero() && (ke = "0" + ke); ke.length % it !== 0; )
            ke = "0" + ke;
          return this.negative !== 0 && (ke = "-" + ke), ke;
        }
        K(!1, "Base should be between 2 and 36");
      }, V.prototype.toNumber = function() {
        var nt = this.words[0];
        return this.length === 2 ? nt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? nt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -nt : nt;
      }, V.prototype.toJSON = function() {
        return this.toString(16);
      }, V.prototype.toBuffer = function(nt, it) {
        return K(typeof re < "u"), this.toArrayLike(re, nt, it);
      }, V.prototype.toArray = function(nt, it) {
        return this.toArrayLike(Array, nt, it);
      }, V.prototype.toArrayLike = function(nt, it, ke) {
        var rt = this.byteLength(), ot = ke || Math.max(1, rt);
        K(rt <= ot, "byte array longer than desired length"), K(ot > 0, "Requested array length <= 0"), this.strip();
        var ft = it === "le", ct = new nt(ot), bt, ut, gt = this.clone();
        if (ft) {
          for (ut = 0; !gt.isZero(); ut++)
            bt = gt.andln(255), gt.iushrn(8), ct[ut] = bt;
          for (; ut < ot; ut++)
            ct[ut] = 0;
        } else {
          for (ut = 0; ut < ot - rt; ut++)
            ct[ut] = 0;
          for (ut = 0; !gt.isZero(); ut++)
            bt = gt.andln(255), gt.iushrn(8), ct[ot - ut - 1] = bt;
        }
        return ct;
      }, Math.clz32 ? V.prototype._countBits = function(nt) {
        return 32 - Math.clz32(nt);
      } : V.prototype._countBits = function(nt) {
        var it = nt, ke = 0;
        return it >= 4096 && (ke += 13, it >>>= 13), it >= 64 && (ke += 7, it >>>= 7), it >= 8 && (ke += 4, it >>>= 4), it >= 2 && (ke += 2, it >>>= 2), ke + it;
      }, V.prototype._zeroBits = function(nt) {
        if (nt === 0) return 26;
        var it = nt, ke = 0;
        return it & 8191 || (ke += 13, it >>>= 13), it & 127 || (ke += 7, it >>>= 7), it & 15 || (ke += 4, it >>>= 4), it & 3 || (ke += 2, it >>>= 2), it & 1 || ke++, ke;
      }, V.prototype.bitLength = function() {
        var nt = this.words[this.length - 1], it = this._countBits(nt);
        return (this.length - 1) * 26 + it;
      };
      function Oe(Tt) {
        for (var nt = new Array(Tt.bitLength()), it = 0; it < nt.length; it++) {
          var ke = it / 26 | 0, rt = it % 26;
          nt[it] = (Tt.words[ke] & 1 << rt) >>> rt;
        }
        return nt;
      }
      V.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var nt = 0, it = 0; it < this.length; it++) {
          var ke = this._zeroBits(this.words[it]);
          if (nt += ke, ke !== 26) break;
        }
        return nt;
      }, V.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, V.prototype.toTwos = function(nt) {
        return this.negative !== 0 ? this.abs().inotn(nt).iaddn(1) : this.clone();
      }, V.prototype.fromTwos = function(nt) {
        return this.testn(nt - 1) ? this.notn(nt).iaddn(1).ineg() : this.clone();
      }, V.prototype.isNeg = function() {
        return this.negative !== 0;
      }, V.prototype.neg = function() {
        return this.clone().ineg();
      }, V.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, V.prototype.iuor = function(nt) {
        for (; this.length < nt.length; )
          this.words[this.length++] = 0;
        for (var it = 0; it < nt.length; it++)
          this.words[it] = this.words[it] | nt.words[it];
        return this.strip();
      }, V.prototype.ior = function(nt) {
        return K((this.negative | nt.negative) === 0), this.iuor(nt);
      }, V.prototype.or = function(nt) {
        return this.length > nt.length ? this.clone().ior(nt) : nt.clone().ior(this);
      }, V.prototype.uor = function(nt) {
        return this.length > nt.length ? this.clone().iuor(nt) : nt.clone().iuor(this);
      }, V.prototype.iuand = function(nt) {
        var it;
        this.length > nt.length ? it = nt : it = this;
        for (var ke = 0; ke < it.length; ke++)
          this.words[ke] = this.words[ke] & nt.words[ke];
        return this.length = it.length, this.strip();
      }, V.prototype.iand = function(nt) {
        return K((this.negative | nt.negative) === 0), this.iuand(nt);
      }, V.prototype.and = function(nt) {
        return this.length > nt.length ? this.clone().iand(nt) : nt.clone().iand(this);
      }, V.prototype.uand = function(nt) {
        return this.length > nt.length ? this.clone().iuand(nt) : nt.clone().iuand(this);
      }, V.prototype.iuxor = function(nt) {
        var it, ke;
        this.length > nt.length ? (it = this, ke = nt) : (it = nt, ke = this);
        for (var rt = 0; rt < ke.length; rt++)
          this.words[rt] = it.words[rt] ^ ke.words[rt];
        if (this !== it)
          for (; rt < it.length; rt++)
            this.words[rt] = it.words[rt];
        return this.length = it.length, this.strip();
      }, V.prototype.ixor = function(nt) {
        return K((this.negative | nt.negative) === 0), this.iuxor(nt);
      }, V.prototype.xor = function(nt) {
        return this.length > nt.length ? this.clone().ixor(nt) : nt.clone().ixor(this);
      }, V.prototype.uxor = function(nt) {
        return this.length > nt.length ? this.clone().iuxor(nt) : nt.clone().iuxor(this);
      }, V.prototype.inotn = function(nt) {
        K(typeof nt == "number" && nt >= 0);
        var it = Math.ceil(nt / 26) | 0, ke = nt % 26;
        this._expand(it), ke > 0 && it--;
        for (var rt = 0; rt < it; rt++)
          this.words[rt] = ~this.words[rt] & 67108863;
        return ke > 0 && (this.words[rt] = ~this.words[rt] & 67108863 >> 26 - ke), this.strip();
      }, V.prototype.notn = function(nt) {
        return this.clone().inotn(nt);
      }, V.prototype.setn = function(nt, it) {
        K(typeof nt == "number" && nt >= 0);
        var ke = nt / 26 | 0, rt = nt % 26;
        return this._expand(ke + 1), it ? this.words[ke] = this.words[ke] | 1 << rt : this.words[ke] = this.words[ke] & ~(1 << rt), this.strip();
      }, V.prototype.iadd = function(nt) {
        var it;
        if (this.negative !== 0 && nt.negative === 0)
          return this.negative = 0, it = this.isub(nt), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && nt.negative !== 0)
          return nt.negative = 0, it = this.isub(nt), nt.negative = 1, it._normSign();
        var ke, rt;
        this.length > nt.length ? (ke = this, rt = nt) : (ke = nt, rt = this);
        for (var ot = 0, ft = 0; ft < rt.length; ft++)
          it = (ke.words[ft] | 0) + (rt.words[ft] | 0) + ot, this.words[ft] = it & 67108863, ot = it >>> 26;
        for (; ot !== 0 && ft < ke.length; ft++)
          it = (ke.words[ft] | 0) + ot, this.words[ft] = it & 67108863, ot = it >>> 26;
        if (this.length = ke.length, ot !== 0)
          this.words[this.length] = ot, this.length++;
        else if (ke !== this)
          for (; ft < ke.length; ft++)
            this.words[ft] = ke.words[ft];
        return this;
      }, V.prototype.add = function(nt) {
        var it;
        return nt.negative !== 0 && this.negative === 0 ? (nt.negative = 0, it = this.sub(nt), nt.negative ^= 1, it) : nt.negative === 0 && this.negative !== 0 ? (this.negative = 0, it = nt.sub(this), this.negative = 1, it) : this.length > nt.length ? this.clone().iadd(nt) : nt.clone().iadd(this);
      }, V.prototype.isub = function(nt) {
        if (nt.negative !== 0) {
          nt.negative = 0;
          var it = this.iadd(nt);
          return nt.negative = 1, it._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(nt), this.negative = 1, this._normSign();
        var ke = this.cmp(nt);
        if (ke === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var rt, ot;
        ke > 0 ? (rt = this, ot = nt) : (rt = nt, ot = this);
        for (var ft = 0, ct = 0; ct < ot.length; ct++)
          it = (rt.words[ct] | 0) - (ot.words[ct] | 0) + ft, ft = it >> 26, this.words[ct] = it & 67108863;
        for (; ft !== 0 && ct < rt.length; ct++)
          it = (rt.words[ct] | 0) + ft, ft = it >> 26, this.words[ct] = it & 67108863;
        if (ft === 0 && ct < rt.length && rt !== this)
          for (; ct < rt.length; ct++)
            this.words[ct] = rt.words[ct];
        return this.length = Math.max(this.length, ct), rt !== this && (this.negative = 1), this.strip();
      }, V.prototype.sub = function(nt) {
        return this.clone().isub(nt);
      };
      function st(Tt, nt, it) {
        it.negative = nt.negative ^ Tt.negative;
        var ke = Tt.length + nt.length | 0;
        it.length = ke, ke = ke - 1 | 0;
        var rt = Tt.words[0] | 0, ot = nt.words[0] | 0, ft = rt * ot, ct = ft & 67108863, bt = ft / 67108864 | 0;
        it.words[0] = ct;
        for (var ut = 1; ut < ke; ut++) {
          for (var gt = bt >>> 26, dt = bt & 67108863, wt = Math.min(ut, nt.length - 1), Ft = Math.max(0, ut - Tt.length + 1); Ft <= wt; Ft++) {
            var jt = ut - Ft | 0;
            rt = Tt.words[jt] | 0, ot = nt.words[Ft] | 0, ft = rt * ot + dt, gt += ft / 67108864 | 0, dt = ft & 67108863;
          }
          it.words[ut] = dt | 0, bt = gt | 0;
        }
        return bt !== 0 ? it.words[ut] = bt | 0 : it.length--, it.strip();
      }
      var at = function(nt, it, ke) {
        var rt = nt.words, ot = it.words, ft = ke.words, ct = 0, bt, ut, gt, dt = rt[0] | 0, wt = dt & 8191, Ft = dt >>> 13, jt = rt[1] | 0, Nt = jt & 8191, Bt = jt >>> 13, Rt = rt[2] | 0, Ut = Rt & 8191, zt = Rt >>> 13, Mt = rt[3] | 0, kt = Mt & 8191, Gt = Mt >>> 13, Qt = rt[4] | 0, nr = Qt & 8191, ar = Qt >>> 13, cr = rt[5] | 0, hr = cr & 8191, Jt = cr >>> 13, Pr = rt[6] | 0, dr = Pr & 8191, Tr = Pr >>> 13, Rr = rt[7] | 0, pr = Rr & 8191, $r = Rr >>> 13, kr = rt[8] | 0, vr = kr & 8191, Mr = kr >>> 13, Nr = rt[9] | 0, Pt = Nr & 8191, mt = Nr >>> 13, At = ot[0] | 0, qt = At & 8191, Kt = At >>> 13, Vt = ot[1] | 0, Xt = Vt & 8191, yr = Vt >>> 13, Ar = ot[2] | 0, lr = Ar & 8191, xr = Ar >>> 13, wr = ot[3] | 0, Sr = wr & 8191, Or = wr >>> 13, qr = ot[4] | 0, Dt = qr & 8191, Ot = qr >>> 13, Ht = ot[5] | 0, Wt = Ht & 8191, Yt = Ht >>> 13, er = ot[6] | 0, rr = er & 8191, ir = er >>> 13, ur = ot[7] | 0, sr = ur & 8191, br = ur >>> 13, _r = ot[8] | 0, or = _r & 8191, Lt = _r >>> 13, Zt = ot[9] | 0, tr = Zt & 8191, fr = Zt >>> 13;
        ke.negative = nt.negative ^ it.negative, ke.length = 19, bt = Math.imul(wt, qt), ut = Math.imul(wt, Kt), ut = ut + Math.imul(Ft, qt) | 0, gt = Math.imul(Ft, Kt);
        var gr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, bt = Math.imul(Nt, qt), ut = Math.imul(Nt, Kt), ut = ut + Math.imul(Bt, qt) | 0, gt = Math.imul(Bt, Kt), bt = bt + Math.imul(wt, Xt) | 0, ut = ut + Math.imul(wt, yr) | 0, ut = ut + Math.imul(Ft, Xt) | 0, gt = gt + Math.imul(Ft, yr) | 0;
        var Er = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, bt = Math.imul(Ut, qt), ut = Math.imul(Ut, Kt), ut = ut + Math.imul(zt, qt) | 0, gt = Math.imul(zt, Kt), bt = bt + Math.imul(Nt, Xt) | 0, ut = ut + Math.imul(Nt, yr) | 0, ut = ut + Math.imul(Bt, Xt) | 0, gt = gt + Math.imul(Bt, yr) | 0, bt = bt + Math.imul(wt, lr) | 0, ut = ut + Math.imul(wt, xr) | 0, ut = ut + Math.imul(Ft, lr) | 0, gt = gt + Math.imul(Ft, xr) | 0;
        var Ir = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, bt = Math.imul(kt, qt), ut = Math.imul(kt, Kt), ut = ut + Math.imul(Gt, qt) | 0, gt = Math.imul(Gt, Kt), bt = bt + Math.imul(Ut, Xt) | 0, ut = ut + Math.imul(Ut, yr) | 0, ut = ut + Math.imul(zt, Xt) | 0, gt = gt + Math.imul(zt, yr) | 0, bt = bt + Math.imul(Nt, lr) | 0, ut = ut + Math.imul(Nt, xr) | 0, ut = ut + Math.imul(Bt, lr) | 0, gt = gt + Math.imul(Bt, xr) | 0, bt = bt + Math.imul(wt, Sr) | 0, ut = ut + Math.imul(wt, Or) | 0, ut = ut + Math.imul(Ft, Sr) | 0, gt = gt + Math.imul(Ft, Or) | 0;
        var Br = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, bt = Math.imul(nr, qt), ut = Math.imul(nr, Kt), ut = ut + Math.imul(ar, qt) | 0, gt = Math.imul(ar, Kt), bt = bt + Math.imul(kt, Xt) | 0, ut = ut + Math.imul(kt, yr) | 0, ut = ut + Math.imul(Gt, Xt) | 0, gt = gt + Math.imul(Gt, yr) | 0, bt = bt + Math.imul(Ut, lr) | 0, ut = ut + Math.imul(Ut, xr) | 0, ut = ut + Math.imul(zt, lr) | 0, gt = gt + Math.imul(zt, xr) | 0, bt = bt + Math.imul(Nt, Sr) | 0, ut = ut + Math.imul(Nt, Or) | 0, ut = ut + Math.imul(Bt, Sr) | 0, gt = gt + Math.imul(Bt, Or) | 0, bt = bt + Math.imul(wt, Dt) | 0, ut = ut + Math.imul(wt, Ot) | 0, ut = ut + Math.imul(Ft, Dt) | 0, gt = gt + Math.imul(Ft, Ot) | 0;
        var Ur = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, bt = Math.imul(hr, qt), ut = Math.imul(hr, Kt), ut = ut + Math.imul(Jt, qt) | 0, gt = Math.imul(Jt, Kt), bt = bt + Math.imul(nr, Xt) | 0, ut = ut + Math.imul(nr, yr) | 0, ut = ut + Math.imul(ar, Xt) | 0, gt = gt + Math.imul(ar, yr) | 0, bt = bt + Math.imul(kt, lr) | 0, ut = ut + Math.imul(kt, xr) | 0, ut = ut + Math.imul(Gt, lr) | 0, gt = gt + Math.imul(Gt, xr) | 0, bt = bt + Math.imul(Ut, Sr) | 0, ut = ut + Math.imul(Ut, Or) | 0, ut = ut + Math.imul(zt, Sr) | 0, gt = gt + Math.imul(zt, Or) | 0, bt = bt + Math.imul(Nt, Dt) | 0, ut = ut + Math.imul(Nt, Ot) | 0, ut = ut + Math.imul(Bt, Dt) | 0, gt = gt + Math.imul(Bt, Ot) | 0, bt = bt + Math.imul(wt, Wt) | 0, ut = ut + Math.imul(wt, Yt) | 0, ut = ut + Math.imul(Ft, Wt) | 0, gt = gt + Math.imul(Ft, Yt) | 0;
        var Fr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, bt = Math.imul(dr, qt), ut = Math.imul(dr, Kt), ut = ut + Math.imul(Tr, qt) | 0, gt = Math.imul(Tr, Kt), bt = bt + Math.imul(hr, Xt) | 0, ut = ut + Math.imul(hr, yr) | 0, ut = ut + Math.imul(Jt, Xt) | 0, gt = gt + Math.imul(Jt, yr) | 0, bt = bt + Math.imul(nr, lr) | 0, ut = ut + Math.imul(nr, xr) | 0, ut = ut + Math.imul(ar, lr) | 0, gt = gt + Math.imul(ar, xr) | 0, bt = bt + Math.imul(kt, Sr) | 0, ut = ut + Math.imul(kt, Or) | 0, ut = ut + Math.imul(Gt, Sr) | 0, gt = gt + Math.imul(Gt, Or) | 0, bt = bt + Math.imul(Ut, Dt) | 0, ut = ut + Math.imul(Ut, Ot) | 0, ut = ut + Math.imul(zt, Dt) | 0, gt = gt + Math.imul(zt, Ot) | 0, bt = bt + Math.imul(Nt, Wt) | 0, ut = ut + Math.imul(Nt, Yt) | 0, ut = ut + Math.imul(Bt, Wt) | 0, gt = gt + Math.imul(Bt, Yt) | 0, bt = bt + Math.imul(wt, rr) | 0, ut = ut + Math.imul(wt, ir) | 0, ut = ut + Math.imul(Ft, rr) | 0, gt = gt + Math.imul(Ft, ir) | 0;
        var Dr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, bt = Math.imul(pr, qt), ut = Math.imul(pr, Kt), ut = ut + Math.imul($r, qt) | 0, gt = Math.imul($r, Kt), bt = bt + Math.imul(dr, Xt) | 0, ut = ut + Math.imul(dr, yr) | 0, ut = ut + Math.imul(Tr, Xt) | 0, gt = gt + Math.imul(Tr, yr) | 0, bt = bt + Math.imul(hr, lr) | 0, ut = ut + Math.imul(hr, xr) | 0, ut = ut + Math.imul(Jt, lr) | 0, gt = gt + Math.imul(Jt, xr) | 0, bt = bt + Math.imul(nr, Sr) | 0, ut = ut + Math.imul(nr, Or) | 0, ut = ut + Math.imul(ar, Sr) | 0, gt = gt + Math.imul(ar, Or) | 0, bt = bt + Math.imul(kt, Dt) | 0, ut = ut + Math.imul(kt, Ot) | 0, ut = ut + Math.imul(Gt, Dt) | 0, gt = gt + Math.imul(Gt, Ot) | 0, bt = bt + Math.imul(Ut, Wt) | 0, ut = ut + Math.imul(Ut, Yt) | 0, ut = ut + Math.imul(zt, Wt) | 0, gt = gt + Math.imul(zt, Yt) | 0, bt = bt + Math.imul(Nt, rr) | 0, ut = ut + Math.imul(Nt, ir) | 0, ut = ut + Math.imul(Bt, rr) | 0, gt = gt + Math.imul(Bt, ir) | 0, bt = bt + Math.imul(wt, sr) | 0, ut = ut + Math.imul(wt, br) | 0, ut = ut + Math.imul(Ft, sr) | 0, gt = gt + Math.imul(Ft, br) | 0;
        var Hr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, bt = Math.imul(vr, qt), ut = Math.imul(vr, Kt), ut = ut + Math.imul(Mr, qt) | 0, gt = Math.imul(Mr, Kt), bt = bt + Math.imul(pr, Xt) | 0, ut = ut + Math.imul(pr, yr) | 0, ut = ut + Math.imul($r, Xt) | 0, gt = gt + Math.imul($r, yr) | 0, bt = bt + Math.imul(dr, lr) | 0, ut = ut + Math.imul(dr, xr) | 0, ut = ut + Math.imul(Tr, lr) | 0, gt = gt + Math.imul(Tr, xr) | 0, bt = bt + Math.imul(hr, Sr) | 0, ut = ut + Math.imul(hr, Or) | 0, ut = ut + Math.imul(Jt, Sr) | 0, gt = gt + Math.imul(Jt, Or) | 0, bt = bt + Math.imul(nr, Dt) | 0, ut = ut + Math.imul(nr, Ot) | 0, ut = ut + Math.imul(ar, Dt) | 0, gt = gt + Math.imul(ar, Ot) | 0, bt = bt + Math.imul(kt, Wt) | 0, ut = ut + Math.imul(kt, Yt) | 0, ut = ut + Math.imul(Gt, Wt) | 0, gt = gt + Math.imul(Gt, Yt) | 0, bt = bt + Math.imul(Ut, rr) | 0, ut = ut + Math.imul(Ut, ir) | 0, ut = ut + Math.imul(zt, rr) | 0, gt = gt + Math.imul(zt, ir) | 0, bt = bt + Math.imul(Nt, sr) | 0, ut = ut + Math.imul(Nt, br) | 0, ut = ut + Math.imul(Bt, sr) | 0, gt = gt + Math.imul(Bt, br) | 0, bt = bt + Math.imul(wt, or) | 0, ut = ut + Math.imul(wt, Lt) | 0, ut = ut + Math.imul(Ft, or) | 0, gt = gt + Math.imul(Ft, Lt) | 0;
        var Wr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, bt = Math.imul(Pt, qt), ut = Math.imul(Pt, Kt), ut = ut + Math.imul(mt, qt) | 0, gt = Math.imul(mt, Kt), bt = bt + Math.imul(vr, Xt) | 0, ut = ut + Math.imul(vr, yr) | 0, ut = ut + Math.imul(Mr, Xt) | 0, gt = gt + Math.imul(Mr, yr) | 0, bt = bt + Math.imul(pr, lr) | 0, ut = ut + Math.imul(pr, xr) | 0, ut = ut + Math.imul($r, lr) | 0, gt = gt + Math.imul($r, xr) | 0, bt = bt + Math.imul(dr, Sr) | 0, ut = ut + Math.imul(dr, Or) | 0, ut = ut + Math.imul(Tr, Sr) | 0, gt = gt + Math.imul(Tr, Or) | 0, bt = bt + Math.imul(hr, Dt) | 0, ut = ut + Math.imul(hr, Ot) | 0, ut = ut + Math.imul(Jt, Dt) | 0, gt = gt + Math.imul(Jt, Ot) | 0, bt = bt + Math.imul(nr, Wt) | 0, ut = ut + Math.imul(nr, Yt) | 0, ut = ut + Math.imul(ar, Wt) | 0, gt = gt + Math.imul(ar, Yt) | 0, bt = bt + Math.imul(kt, rr) | 0, ut = ut + Math.imul(kt, ir) | 0, ut = ut + Math.imul(Gt, rr) | 0, gt = gt + Math.imul(Gt, ir) | 0, bt = bt + Math.imul(Ut, sr) | 0, ut = ut + Math.imul(Ut, br) | 0, ut = ut + Math.imul(zt, sr) | 0, gt = gt + Math.imul(zt, br) | 0, bt = bt + Math.imul(Nt, or) | 0, ut = ut + Math.imul(Nt, Lt) | 0, ut = ut + Math.imul(Bt, or) | 0, gt = gt + Math.imul(Bt, Lt) | 0, bt = bt + Math.imul(wt, tr) | 0, ut = ut + Math.imul(wt, fr) | 0, ut = ut + Math.imul(Ft, tr) | 0, gt = gt + Math.imul(Ft, fr) | 0;
        var jr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, bt = Math.imul(Pt, Xt), ut = Math.imul(Pt, yr), ut = ut + Math.imul(mt, Xt) | 0, gt = Math.imul(mt, yr), bt = bt + Math.imul(vr, lr) | 0, ut = ut + Math.imul(vr, xr) | 0, ut = ut + Math.imul(Mr, lr) | 0, gt = gt + Math.imul(Mr, xr) | 0, bt = bt + Math.imul(pr, Sr) | 0, ut = ut + Math.imul(pr, Or) | 0, ut = ut + Math.imul($r, Sr) | 0, gt = gt + Math.imul($r, Or) | 0, bt = bt + Math.imul(dr, Dt) | 0, ut = ut + Math.imul(dr, Ot) | 0, ut = ut + Math.imul(Tr, Dt) | 0, gt = gt + Math.imul(Tr, Ot) | 0, bt = bt + Math.imul(hr, Wt) | 0, ut = ut + Math.imul(hr, Yt) | 0, ut = ut + Math.imul(Jt, Wt) | 0, gt = gt + Math.imul(Jt, Yt) | 0, bt = bt + Math.imul(nr, rr) | 0, ut = ut + Math.imul(nr, ir) | 0, ut = ut + Math.imul(ar, rr) | 0, gt = gt + Math.imul(ar, ir) | 0, bt = bt + Math.imul(kt, sr) | 0, ut = ut + Math.imul(kt, br) | 0, ut = ut + Math.imul(Gt, sr) | 0, gt = gt + Math.imul(Gt, br) | 0, bt = bt + Math.imul(Ut, or) | 0, ut = ut + Math.imul(Ut, Lt) | 0, ut = ut + Math.imul(zt, or) | 0, gt = gt + Math.imul(zt, Lt) | 0, bt = bt + Math.imul(Nt, tr) | 0, ut = ut + Math.imul(Nt, fr) | 0, ut = ut + Math.imul(Bt, tr) | 0, gt = gt + Math.imul(Bt, fr) | 0;
        var Lr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, bt = Math.imul(Pt, lr), ut = Math.imul(Pt, xr), ut = ut + Math.imul(mt, lr) | 0, gt = Math.imul(mt, xr), bt = bt + Math.imul(vr, Sr) | 0, ut = ut + Math.imul(vr, Or) | 0, ut = ut + Math.imul(Mr, Sr) | 0, gt = gt + Math.imul(Mr, Or) | 0, bt = bt + Math.imul(pr, Dt) | 0, ut = ut + Math.imul(pr, Ot) | 0, ut = ut + Math.imul($r, Dt) | 0, gt = gt + Math.imul($r, Ot) | 0, bt = bt + Math.imul(dr, Wt) | 0, ut = ut + Math.imul(dr, Yt) | 0, ut = ut + Math.imul(Tr, Wt) | 0, gt = gt + Math.imul(Tr, Yt) | 0, bt = bt + Math.imul(hr, rr) | 0, ut = ut + Math.imul(hr, ir) | 0, ut = ut + Math.imul(Jt, rr) | 0, gt = gt + Math.imul(Jt, ir) | 0, bt = bt + Math.imul(nr, sr) | 0, ut = ut + Math.imul(nr, br) | 0, ut = ut + Math.imul(ar, sr) | 0, gt = gt + Math.imul(ar, br) | 0, bt = bt + Math.imul(kt, or) | 0, ut = ut + Math.imul(kt, Lt) | 0, ut = ut + Math.imul(Gt, or) | 0, gt = gt + Math.imul(Gt, Lt) | 0, bt = bt + Math.imul(Ut, tr) | 0, ut = ut + Math.imul(Ut, fr) | 0, ut = ut + Math.imul(zt, tr) | 0, gt = gt + Math.imul(zt, fr) | 0;
        var Gr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, bt = Math.imul(Pt, Sr), ut = Math.imul(Pt, Or), ut = ut + Math.imul(mt, Sr) | 0, gt = Math.imul(mt, Or), bt = bt + Math.imul(vr, Dt) | 0, ut = ut + Math.imul(vr, Ot) | 0, ut = ut + Math.imul(Mr, Dt) | 0, gt = gt + Math.imul(Mr, Ot) | 0, bt = bt + Math.imul(pr, Wt) | 0, ut = ut + Math.imul(pr, Yt) | 0, ut = ut + Math.imul($r, Wt) | 0, gt = gt + Math.imul($r, Yt) | 0, bt = bt + Math.imul(dr, rr) | 0, ut = ut + Math.imul(dr, ir) | 0, ut = ut + Math.imul(Tr, rr) | 0, gt = gt + Math.imul(Tr, ir) | 0, bt = bt + Math.imul(hr, sr) | 0, ut = ut + Math.imul(hr, br) | 0, ut = ut + Math.imul(Jt, sr) | 0, gt = gt + Math.imul(Jt, br) | 0, bt = bt + Math.imul(nr, or) | 0, ut = ut + Math.imul(nr, Lt) | 0, ut = ut + Math.imul(ar, or) | 0, gt = gt + Math.imul(ar, Lt) | 0, bt = bt + Math.imul(kt, tr) | 0, ut = ut + Math.imul(kt, fr) | 0, ut = ut + Math.imul(Gt, tr) | 0, gt = gt + Math.imul(Gt, fr) | 0;
        var zr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, bt = Math.imul(Pt, Dt), ut = Math.imul(Pt, Ot), ut = ut + Math.imul(mt, Dt) | 0, gt = Math.imul(mt, Ot), bt = bt + Math.imul(vr, Wt) | 0, ut = ut + Math.imul(vr, Yt) | 0, ut = ut + Math.imul(Mr, Wt) | 0, gt = gt + Math.imul(Mr, Yt) | 0, bt = bt + Math.imul(pr, rr) | 0, ut = ut + Math.imul(pr, ir) | 0, ut = ut + Math.imul($r, rr) | 0, gt = gt + Math.imul($r, ir) | 0, bt = bt + Math.imul(dr, sr) | 0, ut = ut + Math.imul(dr, br) | 0, ut = ut + Math.imul(Tr, sr) | 0, gt = gt + Math.imul(Tr, br) | 0, bt = bt + Math.imul(hr, or) | 0, ut = ut + Math.imul(hr, Lt) | 0, ut = ut + Math.imul(Jt, or) | 0, gt = gt + Math.imul(Jt, Lt) | 0, bt = bt + Math.imul(nr, tr) | 0, ut = ut + Math.imul(nr, fr) | 0, ut = ut + Math.imul(ar, tr) | 0, gt = gt + Math.imul(ar, fr) | 0;
        var Vr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, bt = Math.imul(Pt, Wt), ut = Math.imul(Pt, Yt), ut = ut + Math.imul(mt, Wt) | 0, gt = Math.imul(mt, Yt), bt = bt + Math.imul(vr, rr) | 0, ut = ut + Math.imul(vr, ir) | 0, ut = ut + Math.imul(Mr, rr) | 0, gt = gt + Math.imul(Mr, ir) | 0, bt = bt + Math.imul(pr, sr) | 0, ut = ut + Math.imul(pr, br) | 0, ut = ut + Math.imul($r, sr) | 0, gt = gt + Math.imul($r, br) | 0, bt = bt + Math.imul(dr, or) | 0, ut = ut + Math.imul(dr, Lt) | 0, ut = ut + Math.imul(Tr, or) | 0, gt = gt + Math.imul(Tr, Lt) | 0, bt = bt + Math.imul(hr, tr) | 0, ut = ut + Math.imul(hr, fr) | 0, ut = ut + Math.imul(Jt, tr) | 0, gt = gt + Math.imul(Jt, fr) | 0;
        var Xr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, bt = Math.imul(Pt, rr), ut = Math.imul(Pt, ir), ut = ut + Math.imul(mt, rr) | 0, gt = Math.imul(mt, ir), bt = bt + Math.imul(vr, sr) | 0, ut = ut + Math.imul(vr, br) | 0, ut = ut + Math.imul(Mr, sr) | 0, gt = gt + Math.imul(Mr, br) | 0, bt = bt + Math.imul(pr, or) | 0, ut = ut + Math.imul(pr, Lt) | 0, ut = ut + Math.imul($r, or) | 0, gt = gt + Math.imul($r, Lt) | 0, bt = bt + Math.imul(dr, tr) | 0, ut = ut + Math.imul(dr, fr) | 0, ut = ut + Math.imul(Tr, tr) | 0, gt = gt + Math.imul(Tr, fr) | 0;
        var Yr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, bt = Math.imul(Pt, sr), ut = Math.imul(Pt, br), ut = ut + Math.imul(mt, sr) | 0, gt = Math.imul(mt, br), bt = bt + Math.imul(vr, or) | 0, ut = ut + Math.imul(vr, Lt) | 0, ut = ut + Math.imul(Mr, or) | 0, gt = gt + Math.imul(Mr, Lt) | 0, bt = bt + Math.imul(pr, tr) | 0, ut = ut + Math.imul(pr, fr) | 0, ut = ut + Math.imul($r, tr) | 0, gt = gt + Math.imul($r, fr) | 0;
        var Jr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, bt = Math.imul(Pt, or), ut = Math.imul(Pt, Lt), ut = ut + Math.imul(mt, or) | 0, gt = Math.imul(mt, Lt), bt = bt + Math.imul(vr, tr) | 0, ut = ut + Math.imul(vr, fr) | 0, ut = ut + Math.imul(Mr, tr) | 0, gt = gt + Math.imul(Mr, fr) | 0;
        var Zr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        ct = (gt + (ut >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, bt = Math.imul(Pt, tr), ut = Math.imul(Pt, fr), ut = ut + Math.imul(mt, tr) | 0, gt = Math.imul(mt, fr);
        var Qr = (ct + bt | 0) + ((ut & 8191) << 13) | 0;
        return ct = (gt + (ut >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, ft[0] = gr, ft[1] = Er, ft[2] = Ir, ft[3] = Br, ft[4] = Ur, ft[5] = Fr, ft[6] = Dr, ft[7] = Hr, ft[8] = Wr, ft[9] = jr, ft[10] = Lr, ft[11] = Gr, ft[12] = zr, ft[13] = Vr, ft[14] = Xr, ft[15] = Yr, ft[16] = Jr, ft[17] = Zr, ft[18] = Qr, ct !== 0 && (ft[19] = ct, ke.length++), ke;
      };
      Math.imul || (at = st);
      function lt(Tt, nt, it) {
        it.negative = nt.negative ^ Tt.negative, it.length = Tt.length + nt.length;
        for (var ke = 0, rt = 0, ot = 0; ot < it.length - 1; ot++) {
          var ft = rt;
          rt = 0;
          for (var ct = ke & 67108863, bt = Math.min(ot, nt.length - 1), ut = Math.max(0, ot - Tt.length + 1); ut <= bt; ut++) {
            var gt = ot - ut, dt = Tt.words[gt] | 0, wt = nt.words[ut] | 0, Ft = dt * wt, jt = Ft & 67108863;
            ft = ft + (Ft / 67108864 | 0) | 0, jt = jt + ct | 0, ct = jt & 67108863, ft = ft + (jt >>> 26) | 0, rt += ft >>> 26, ft &= 67108863;
          }
          it.words[ot] = ct, ke = ft, ft = rt;
        }
        return ke !== 0 ? it.words[ot] = ke : it.length--, it.strip();
      }
      function pt(Tt, nt, it) {
        var ke = new ht();
        return ke.mulp(Tt, nt, it);
      }
      V.prototype.mulTo = function(nt, it) {
        var ke, rt = this.length + nt.length;
        return this.length === 10 && nt.length === 10 ? ke = at(this, nt, it) : rt < 63 ? ke = st(this, nt, it) : rt < 1024 ? ke = lt(this, nt, it) : ke = pt(this, nt, it), ke;
      };
      function ht(Tt, nt) {
        this.x = Tt, this.y = nt;
      }
      ht.prototype.makeRBT = function(nt) {
        for (var it = new Array(nt), ke = V.prototype._countBits(nt) - 1, rt = 0; rt < nt; rt++)
          it[rt] = this.revBin(rt, ke, nt);
        return it;
      }, ht.prototype.revBin = function(nt, it, ke) {
        if (nt === 0 || nt === ke - 1) return nt;
        for (var rt = 0, ot = 0; ot < it; ot++)
          rt |= (nt & 1) << it - ot - 1, nt >>= 1;
        return rt;
      }, ht.prototype.permute = function(nt, it, ke, rt, ot, ft) {
        for (var ct = 0; ct < ft; ct++)
          rt[ct] = it[nt[ct]], ot[ct] = ke[nt[ct]];
      }, ht.prototype.transform = function(nt, it, ke, rt, ot, ft) {
        this.permute(ft, nt, it, ke, rt, ot);
        for (var ct = 1; ct < ot; ct <<= 1)
          for (var bt = ct << 1, ut = Math.cos(2 * Math.PI / bt), gt = Math.sin(2 * Math.PI / bt), dt = 0; dt < ot; dt += bt)
            for (var wt = ut, Ft = gt, jt = 0; jt < ct; jt++) {
              var Nt = ke[dt + jt], Bt = rt[dt + jt], Rt = ke[dt + jt + ct], Ut = rt[dt + jt + ct], zt = wt * Rt - Ft * Ut;
              Ut = wt * Ut + Ft * Rt, Rt = zt, ke[dt + jt] = Nt + Rt, rt[dt + jt] = Bt + Ut, ke[dt + jt + ct] = Nt - Rt, rt[dt + jt + ct] = Bt - Ut, jt !== bt && (zt = ut * wt - gt * Ft, Ft = ut * Ft + gt * wt, wt = zt);
            }
      }, ht.prototype.guessLen13b = function(nt, it) {
        var ke = Math.max(it, nt) | 1, rt = ke & 1, ot = 0;
        for (ke = ke / 2 | 0; ke; ke = ke >>> 1)
          ot++;
        return 1 << ot + 1 + rt;
      }, ht.prototype.conjugate = function(nt, it, ke) {
        if (!(ke <= 1))
          for (var rt = 0; rt < ke / 2; rt++) {
            var ot = nt[rt];
            nt[rt] = nt[ke - rt - 1], nt[ke - rt - 1] = ot, ot = it[rt], it[rt] = -it[ke - rt - 1], it[ke - rt - 1] = -ot;
          }
      }, ht.prototype.normalize13b = function(nt, it) {
        for (var ke = 0, rt = 0; rt < it / 2; rt++) {
          var ot = Math.round(nt[2 * rt + 1] / it) * 8192 + Math.round(nt[2 * rt] / it) + ke;
          nt[rt] = ot & 67108863, ot < 67108864 ? ke = 0 : ke = ot / 67108864 | 0;
        }
        return nt;
      }, ht.prototype.convert13b = function(nt, it, ke, rt) {
        for (var ot = 0, ft = 0; ft < it; ft++)
          ot = ot + (nt[ft] | 0), ke[2 * ft] = ot & 8191, ot = ot >>> 13, ke[2 * ft + 1] = ot & 8191, ot = ot >>> 13;
        for (ft = 2 * it; ft < rt; ++ft)
          ke[ft] = 0;
        K(ot === 0), K((ot & -8192) === 0);
      }, ht.prototype.stub = function(nt) {
        for (var it = new Array(nt), ke = 0; ke < nt; ke++)
          it[ke] = 0;
        return it;
      }, ht.prototype.mulp = function(nt, it, ke) {
        var rt = 2 * this.guessLen13b(nt.length, it.length), ot = this.makeRBT(rt), ft = this.stub(rt), ct = new Array(rt), bt = new Array(rt), ut = new Array(rt), gt = new Array(rt), dt = new Array(rt), wt = new Array(rt), Ft = ke.words;
        Ft.length = rt, this.convert13b(nt.words, nt.length, ct, rt), this.convert13b(it.words, it.length, gt, rt), this.transform(ct, ft, bt, ut, rt, ot), this.transform(gt, ft, dt, wt, rt, ot);
        for (var jt = 0; jt < rt; jt++) {
          var Nt = bt[jt] * dt[jt] - ut[jt] * wt[jt];
          ut[jt] = bt[jt] * wt[jt] + ut[jt] * dt[jt], bt[jt] = Nt;
        }
        return this.conjugate(bt, ut, rt), this.transform(bt, ut, Ft, ft, rt, ot), this.conjugate(Ft, ft, rt), this.normalize13b(Ft, rt), ke.negative = nt.negative ^ it.negative, ke.length = nt.length + it.length, ke.strip();
      }, V.prototype.mul = function(nt) {
        var it = new V(null);
        return it.words = new Array(this.length + nt.length), this.mulTo(nt, it);
      }, V.prototype.mulf = function(nt) {
        var it = new V(null);
        return it.words = new Array(this.length + nt.length), pt(this, nt, it);
      }, V.prototype.imul = function(nt) {
        return this.clone().mulTo(nt, this);
      }, V.prototype.imuln = function(nt) {
        K(typeof nt == "number"), K(nt < 67108864);
        for (var it = 0, ke = 0; ke < this.length; ke++) {
          var rt = (this.words[ke] | 0) * nt, ot = (rt & 67108863) + (it & 67108863);
          it >>= 26, it += rt / 67108864 | 0, it += ot >>> 26, this.words[ke] = ot & 67108863;
        }
        return it !== 0 && (this.words[ke] = it, this.length++), this;
      }, V.prototype.muln = function(nt) {
        return this.clone().imuln(nt);
      }, V.prototype.sqr = function() {
        return this.mul(this);
      }, V.prototype.isqr = function() {
        return this.imul(this.clone());
      }, V.prototype.pow = function(nt) {
        var it = Oe(nt);
        if (it.length === 0) return new V(1);
        for (var ke = this, rt = 0; rt < it.length && it[rt] === 0; rt++, ke = ke.sqr())
          ;
        if (++rt < it.length)
          for (var ot = ke.sqr(); rt < it.length; rt++, ot = ot.sqr())
            it[rt] !== 0 && (ke = ke.mul(ot));
        return ke;
      }, V.prototype.iushln = function(nt) {
        K(typeof nt == "number" && nt >= 0);
        var it = nt % 26, ke = (nt - it) / 26, rt = 67108863 >>> 26 - it << 26 - it, ot;
        if (it !== 0) {
          var ft = 0;
          for (ot = 0; ot < this.length; ot++) {
            var ct = this.words[ot] & rt, bt = (this.words[ot] | 0) - ct << it;
            this.words[ot] = bt | ft, ft = ct >>> 26 - it;
          }
          ft && (this.words[ot] = ft, this.length++);
        }
        if (ke !== 0) {
          for (ot = this.length - 1; ot >= 0; ot--)
            this.words[ot + ke] = this.words[ot];
          for (ot = 0; ot < ke; ot++)
            this.words[ot] = 0;
          this.length += ke;
        }
        return this.strip();
      }, V.prototype.ishln = function(nt) {
        return K(this.negative === 0), this.iushln(nt);
      }, V.prototype.iushrn = function(nt, it, ke) {
        K(typeof nt == "number" && nt >= 0);
        var rt;
        it ? rt = (it - it % 26) / 26 : rt = 0;
        var ot = nt % 26, ft = Math.min((nt - ot) / 26, this.length), ct = 67108863 ^ 67108863 >>> ot << ot, bt = ke;
        if (rt -= ft, rt = Math.max(0, rt), bt) {
          for (var ut = 0; ut < ft; ut++)
            bt.words[ut] = this.words[ut];
          bt.length = ft;
        }
        if (ft !== 0) if (this.length > ft)
          for (this.length -= ft, ut = 0; ut < this.length; ut++)
            this.words[ut] = this.words[ut + ft];
        else
          this.words[0] = 0, this.length = 1;
        var gt = 0;
        for (ut = this.length - 1; ut >= 0 && (gt !== 0 || ut >= rt); ut--) {
          var dt = this.words[ut] | 0;
          this.words[ut] = gt << 26 - ot | dt >>> ot, gt = dt & ct;
        }
        return bt && gt !== 0 && (bt.words[bt.length++] = gt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, V.prototype.ishrn = function(nt, it, ke) {
        return K(this.negative === 0), this.iushrn(nt, it, ke);
      }, V.prototype.shln = function(nt) {
        return this.clone().ishln(nt);
      }, V.prototype.ushln = function(nt) {
        return this.clone().iushln(nt);
      }, V.prototype.shrn = function(nt) {
        return this.clone().ishrn(nt);
      }, V.prototype.ushrn = function(nt) {
        return this.clone().iushrn(nt);
      }, V.prototype.testn = function(nt) {
        K(typeof nt == "number" && nt >= 0);
        var it = nt % 26, ke = (nt - it) / 26, rt = 1 << it;
        if (this.length <= ke) return !1;
        var ot = this.words[ke];
        return !!(ot & rt);
      }, V.prototype.imaskn = function(nt) {
        K(typeof nt == "number" && nt >= 0);
        var it = nt % 26, ke = (nt - it) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ke)
          return this;
        if (it !== 0 && ke++, this.length = Math.min(ke, this.length), it !== 0) {
          var rt = 67108863 ^ 67108863 >>> it << it;
          this.words[this.length - 1] &= rt;
        }
        return this.strip();
      }, V.prototype.maskn = function(nt) {
        return this.clone().imaskn(nt);
      }, V.prototype.iaddn = function(nt) {
        return K(typeof nt == "number"), K(nt < 67108864), nt < 0 ? this.isubn(-nt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < nt ? (this.words[0] = nt - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(nt), this.negative = 1, this) : this._iaddn(nt);
      }, V.prototype._iaddn = function(nt) {
        this.words[0] += nt;
        for (var it = 0; it < this.length && this.words[it] >= 67108864; it++)
          this.words[it] -= 67108864, it === this.length - 1 ? this.words[it + 1] = 1 : this.words[it + 1]++;
        return this.length = Math.max(this.length, it + 1), this;
      }, V.prototype.isubn = function(nt) {
        if (K(typeof nt == "number"), K(nt < 67108864), nt < 0) return this.iaddn(-nt);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(nt), this.negative = 1, this;
        if (this.words[0] -= nt, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var it = 0; it < this.length && this.words[it] < 0; it++)
            this.words[it] += 67108864, this.words[it + 1] -= 1;
        return this.strip();
      }, V.prototype.addn = function(nt) {
        return this.clone().iaddn(nt);
      }, V.prototype.subn = function(nt) {
        return this.clone().isubn(nt);
      }, V.prototype.iabs = function() {
        return this.negative = 0, this;
      }, V.prototype.abs = function() {
        return this.clone().iabs();
      }, V.prototype._ishlnsubmul = function(nt, it, ke) {
        var rt = nt.length + ke, ot;
        this._expand(rt);
        var ft, ct = 0;
        for (ot = 0; ot < nt.length; ot++) {
          ft = (this.words[ot + ke] | 0) + ct;
          var bt = (nt.words[ot] | 0) * it;
          ft -= bt & 67108863, ct = (ft >> 26) - (bt / 67108864 | 0), this.words[ot + ke] = ft & 67108863;
        }
        for (; ot < this.length - ke; ot++)
          ft = (this.words[ot + ke] | 0) + ct, ct = ft >> 26, this.words[ot + ke] = ft & 67108863;
        if (ct === 0) return this.strip();
        for (K(ct === -1), ct = 0, ot = 0; ot < this.length; ot++)
          ft = -(this.words[ot] | 0) + ct, ct = ft >> 26, this.words[ot] = ft & 67108863;
        return this.negative = 1, this.strip();
      }, V.prototype._wordDiv = function(nt, it) {
        var ke = this.length - nt.length, rt = this.clone(), ot = nt, ft = ot.words[ot.length - 1] | 0, ct = this._countBits(ft);
        ke = 26 - ct, ke !== 0 && (ot = ot.ushln(ke), rt.iushln(ke), ft = ot.words[ot.length - 1] | 0);
        var bt = rt.length - ot.length, ut;
        if (it !== "mod") {
          ut = new V(null), ut.length = bt + 1, ut.words = new Array(ut.length);
          for (var gt = 0; gt < ut.length; gt++)
            ut.words[gt] = 0;
        }
        var dt = rt.clone()._ishlnsubmul(ot, 1, bt);
        dt.negative === 0 && (rt = dt, ut && (ut.words[bt] = 1));
        for (var wt = bt - 1; wt >= 0; wt--) {
          var Ft = (rt.words[ot.length + wt] | 0) * 67108864 + (rt.words[ot.length + wt - 1] | 0);
          for (Ft = Math.min(Ft / ft | 0, 67108863), rt._ishlnsubmul(ot, Ft, wt); rt.negative !== 0; )
            Ft--, rt.negative = 0, rt._ishlnsubmul(ot, 1, wt), rt.isZero() || (rt.negative ^= 1);
          ut && (ut.words[wt] = Ft);
        }
        return ut && ut.strip(), rt.strip(), it !== "div" && ke !== 0 && rt.iushrn(ke), {
          div: ut || null,
          mod: rt
        };
      }, V.prototype.divmod = function(nt, it, ke) {
        if (K(!nt.isZero()), this.isZero())
          return {
            div: new V(0),
            mod: new V(0)
          };
        var rt, ot, ft;
        return this.negative !== 0 && nt.negative === 0 ? (ft = this.neg().divmod(nt, it), it !== "mod" && (rt = ft.div.neg()), it !== "div" && (ot = ft.mod.neg(), ke && ot.negative !== 0 && ot.iadd(nt)), {
          div: rt,
          mod: ot
        }) : this.negative === 0 && nt.negative !== 0 ? (ft = this.divmod(nt.neg(), it), it !== "mod" && (rt = ft.div.neg()), {
          div: rt,
          mod: ft.mod
        }) : this.negative & nt.negative ? (ft = this.neg().divmod(nt.neg(), it), it !== "div" && (ot = ft.mod.neg(), ke && ot.negative !== 0 && ot.isub(nt)), {
          div: ft.div,
          mod: ot
        }) : nt.length > this.length || this.cmp(nt) < 0 ? {
          div: new V(0),
          mod: this
        } : nt.length === 1 ? it === "div" ? {
          div: this.divn(nt.words[0]),
          mod: null
        } : it === "mod" ? {
          div: null,
          mod: new V(this.modn(nt.words[0]))
        } : {
          div: this.divn(nt.words[0]),
          mod: new V(this.modn(nt.words[0]))
        } : this._wordDiv(nt, it);
      }, V.prototype.div = function(nt) {
        return this.divmod(nt, "div", !1).div;
      }, V.prototype.mod = function(nt) {
        return this.divmod(nt, "mod", !1).mod;
      }, V.prototype.umod = function(nt) {
        return this.divmod(nt, "mod", !0).mod;
      }, V.prototype.divRound = function(nt) {
        var it = this.divmod(nt);
        if (it.mod.isZero()) return it.div;
        var ke = it.div.negative !== 0 ? it.mod.isub(nt) : it.mod, rt = nt.ushrn(1), ot = nt.andln(1), ft = ke.cmp(rt);
        return ft < 0 || ot === 1 && ft === 0 ? it.div : it.div.negative !== 0 ? it.div.isubn(1) : it.div.iaddn(1);
      }, V.prototype.modn = function(nt) {
        K(nt <= 67108863);
        for (var it = (1 << 26) % nt, ke = 0, rt = this.length - 1; rt >= 0; rt--)
          ke = (it * ke + (this.words[rt] | 0)) % nt;
        return ke;
      }, V.prototype.idivn = function(nt) {
        K(nt <= 67108863);
        for (var it = 0, ke = this.length - 1; ke >= 0; ke--) {
          var rt = (this.words[ke] | 0) + it * 67108864;
          this.words[ke] = rt / nt | 0, it = rt % nt;
        }
        return this.strip();
      }, V.prototype.divn = function(nt) {
        return this.clone().idivn(nt);
      }, V.prototype.egcd = function(nt) {
        K(nt.negative === 0), K(!nt.isZero());
        var it = this, ke = nt.clone();
        it.negative !== 0 ? it = it.umod(nt) : it = it.clone();
        for (var rt = new V(1), ot = new V(0), ft = new V(0), ct = new V(1), bt = 0; it.isEven() && ke.isEven(); )
          it.iushrn(1), ke.iushrn(1), ++bt;
        for (var ut = ke.clone(), gt = it.clone(); !it.isZero(); ) {
          for (var dt = 0, wt = 1; !(it.words[0] & wt) && dt < 26; ++dt, wt <<= 1) ;
          if (dt > 0)
            for (it.iushrn(dt); dt-- > 0; )
              (rt.isOdd() || ot.isOdd()) && (rt.iadd(ut), ot.isub(gt)), rt.iushrn(1), ot.iushrn(1);
          for (var Ft = 0, jt = 1; !(ke.words[0] & jt) && Ft < 26; ++Ft, jt <<= 1) ;
          if (Ft > 0)
            for (ke.iushrn(Ft); Ft-- > 0; )
              (ft.isOdd() || ct.isOdd()) && (ft.iadd(ut), ct.isub(gt)), ft.iushrn(1), ct.iushrn(1);
          it.cmp(ke) >= 0 ? (it.isub(ke), rt.isub(ft), ot.isub(ct)) : (ke.isub(it), ft.isub(rt), ct.isub(ot));
        }
        return {
          a: ft,
          b: ct,
          gcd: ke.iushln(bt)
        };
      }, V.prototype._invmp = function(nt) {
        K(nt.negative === 0), K(!nt.isZero());
        var it = this, ke = nt.clone();
        it.negative !== 0 ? it = it.umod(nt) : it = it.clone();
        for (var rt = new V(1), ot = new V(0), ft = ke.clone(); it.cmpn(1) > 0 && ke.cmpn(1) > 0; ) {
          for (var ct = 0, bt = 1; !(it.words[0] & bt) && ct < 26; ++ct, bt <<= 1) ;
          if (ct > 0)
            for (it.iushrn(ct); ct-- > 0; )
              rt.isOdd() && rt.iadd(ft), rt.iushrn(1);
          for (var ut = 0, gt = 1; !(ke.words[0] & gt) && ut < 26; ++ut, gt <<= 1) ;
          if (ut > 0)
            for (ke.iushrn(ut); ut-- > 0; )
              ot.isOdd() && ot.iadd(ft), ot.iushrn(1);
          it.cmp(ke) >= 0 ? (it.isub(ke), rt.isub(ot)) : (ke.isub(it), ot.isub(rt));
        }
        var dt;
        return it.cmpn(1) === 0 ? dt = rt : dt = ot, dt.cmpn(0) < 0 && dt.iadd(nt), dt;
      }, V.prototype.gcd = function(nt) {
        if (this.isZero()) return nt.abs();
        if (nt.isZero()) return this.abs();
        var it = this.clone(), ke = nt.clone();
        it.negative = 0, ke.negative = 0;
        for (var rt = 0; it.isEven() && ke.isEven(); rt++)
          it.iushrn(1), ke.iushrn(1);
        do {
          for (; it.isEven(); )
            it.iushrn(1);
          for (; ke.isEven(); )
            ke.iushrn(1);
          var ot = it.cmp(ke);
          if (ot < 0) {
            var ft = it;
            it = ke, ke = ft;
          } else if (ot === 0 || ke.cmpn(1) === 0)
            break;
          it.isub(ke);
        } while (!0);
        return ke.iushln(rt);
      }, V.prototype.invm = function(nt) {
        return this.egcd(nt).a.umod(nt);
      }, V.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, V.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, V.prototype.andln = function(nt) {
        return this.words[0] & nt;
      }, V.prototype.bincn = function(nt) {
        K(typeof nt == "number");
        var it = nt % 26, ke = (nt - it) / 26, rt = 1 << it;
        if (this.length <= ke)
          return this._expand(ke + 1), this.words[ke] |= rt, this;
        for (var ot = rt, ft = ke; ot !== 0 && ft < this.length; ft++) {
          var ct = this.words[ft] | 0;
          ct += ot, ot = ct >>> 26, ct &= 67108863, this.words[ft] = ct;
        }
        return ot !== 0 && (this.words[ft] = ot, this.length++), this;
      }, V.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, V.prototype.cmpn = function(nt) {
        var it = nt < 0;
        if (this.negative !== 0 && !it) return -1;
        if (this.negative === 0 && it) return 1;
        this.strip();
        var ke;
        if (this.length > 1)
          ke = 1;
        else {
          it && (nt = -nt), K(nt <= 67108863, "Number is too big");
          var rt = this.words[0] | 0;
          ke = rt === nt ? 0 : rt < nt ? -1 : 1;
        }
        return this.negative !== 0 ? -ke | 0 : ke;
      }, V.prototype.cmp = function(nt) {
        if (this.negative !== 0 && nt.negative === 0) return -1;
        if (this.negative === 0 && nt.negative !== 0) return 1;
        var it = this.ucmp(nt);
        return this.negative !== 0 ? -it | 0 : it;
      }, V.prototype.ucmp = function(nt) {
        if (this.length > nt.length) return 1;
        if (this.length < nt.length) return -1;
        for (var it = 0, ke = this.length - 1; ke >= 0; ke--) {
          var rt = this.words[ke] | 0, ot = nt.words[ke] | 0;
          if (rt !== ot) {
            rt < ot ? it = -1 : rt > ot && (it = 1);
            break;
          }
        }
        return it;
      }, V.prototype.gtn = function(nt) {
        return this.cmpn(nt) === 1;
      }, V.prototype.gt = function(nt) {
        return this.cmp(nt) === 1;
      }, V.prototype.gten = function(nt) {
        return this.cmpn(nt) >= 0;
      }, V.prototype.gte = function(nt) {
        return this.cmp(nt) >= 0;
      }, V.prototype.ltn = function(nt) {
        return this.cmpn(nt) === -1;
      }, V.prototype.lt = function(nt) {
        return this.cmp(nt) === -1;
      }, V.prototype.lten = function(nt) {
        return this.cmpn(nt) <= 0;
      }, V.prototype.lte = function(nt) {
        return this.cmp(nt) <= 0;
      }, V.prototype.eqn = function(nt) {
        return this.cmpn(nt) === 0;
      }, V.prototype.eq = function(nt) {
        return this.cmp(nt) === 0;
      }, V.red = function(nt) {
        return new St(nt);
      }, V.prototype.toRed = function(nt) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), nt.convertTo(this)._forceRed(nt);
      }, V.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, V.prototype._forceRed = function(nt) {
        return this.red = nt, this;
      }, V.prototype.forceRed = function(nt) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(nt);
      }, V.prototype.redAdd = function(nt) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, nt);
      }, V.prototype.redIAdd = function(nt) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, nt);
      }, V.prototype.redSub = function(nt) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, nt);
      }, V.prototype.redISub = function(nt) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, nt);
      }, V.prototype.redShl = function(nt) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, nt);
      }, V.prototype.redMul = function(nt) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, nt), this.red.mul(this, nt);
      }, V.prototype.redIMul = function(nt) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, nt), this.red.imul(this, nt);
      }, V.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, V.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, V.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, V.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, V.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, V.prototype.redPow = function(nt) {
        return K(this.red && !nt.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, nt);
      };
      var yt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function vt(Tt, nt) {
        this.name = Tt, this.p = new V(nt, 16), this.n = this.p.bitLength(), this.k = new V(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      vt.prototype._tmp = function() {
        var nt = new V(null);
        return nt.words = new Array(Math.ceil(this.n / 13)), nt;
      }, vt.prototype.ireduce = function(nt) {
        var it = nt, ke;
        do
          this.split(it, this.tmp), it = this.imulK(it), it = it.iadd(this.tmp), ke = it.bitLength();
        while (ke > this.n);
        var rt = ke < this.n ? -1 : it.ucmp(this.p);
        return rt === 0 ? (it.words[0] = 0, it.length = 1) : rt > 0 ? it.isub(this.p) : it.strip !== void 0 ? it.strip() : it._strip(), it;
      }, vt.prototype.split = function(nt, it) {
        nt.iushrn(this.n, 0, it);
      }, vt.prototype.imulK = function(nt) {
        return nt.imul(this.k);
      };
      function $t() {
        vt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J($t, vt), $t.prototype.split = function(nt, it) {
        for (var ke = 4194303, rt = Math.min(nt.length, 9), ot = 0; ot < rt; ot++)
          it.words[ot] = nt.words[ot];
        if (it.length = rt, nt.length <= 9) {
          nt.words[0] = 0, nt.length = 1;
          return;
        }
        var ft = nt.words[9];
        for (it.words[it.length++] = ft & ke, ot = 10; ot < nt.length; ot++) {
          var ct = nt.words[ot] | 0;
          nt.words[ot - 10] = (ct & ke) << 4 | ft >>> 22, ft = ct;
        }
        ft >>>= 22, nt.words[ot - 10] = ft, ft === 0 && nt.length > 10 ? nt.length -= 10 : nt.length -= 9;
      }, $t.prototype.imulK = function(nt) {
        nt.words[nt.length] = 0, nt.words[nt.length + 1] = 0, nt.length += 2;
        for (var it = 0, ke = 0; ke < nt.length; ke++) {
          var rt = nt.words[ke] | 0;
          it += rt * 977, nt.words[ke] = it & 67108863, it = rt * 64 + (it / 67108864 | 0);
        }
        return nt.words[nt.length - 1] === 0 && (nt.length--, nt.words[nt.length - 1] === 0 && nt.length--), nt;
      };
      function xt() {
        vt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J(xt, vt);
      function Ct() {
        vt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(Ct, vt);
      function Et() {
        vt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(Et, vt), Et.prototype.imulK = function(nt) {
        for (var it = 0, ke = 0; ke < nt.length; ke++) {
          var rt = (nt.words[ke] | 0) * 19 + it, ot = rt & 67108863;
          rt >>>= 26, nt.words[ke] = ot, it = rt;
        }
        return it !== 0 && (nt.words[nt.length++] = it), nt;
      }, V._prime = function(nt) {
        if (yt[nt]) return yt[nt];
        var it;
        if (nt === "k256")
          it = new $t();
        else if (nt === "p224")
          it = new xt();
        else if (nt === "p192")
          it = new Ct();
        else if (nt === "p25519")
          it = new Et();
        else
          throw new Error("Unknown prime " + nt);
        return yt[nt] = it, it;
      };
      function St(Tt) {
        if (typeof Tt == "string") {
          var nt = V._prime(Tt);
          this.m = nt.p, this.prime = nt;
        } else
          K(Tt.gtn(1), "modulus must be greater than 1"), this.m = Tt, this.prime = null;
      }
      St.prototype._verify1 = function(nt) {
        K(nt.negative === 0, "red works only with positives"), K(nt.red, "red works only with red numbers");
      }, St.prototype._verify2 = function(nt, it) {
        K((nt.negative | it.negative) === 0, "red works only with positives"), K(
          nt.red && nt.red === it.red,
          "red works only with red numbers"
        );
      }, St.prototype.imod = function(nt) {
        return this.prime ? this.prime.ireduce(nt)._forceRed(this) : nt.umod(this.m)._forceRed(this);
      }, St.prototype.neg = function(nt) {
        return nt.isZero() ? nt.clone() : this.m.sub(nt)._forceRed(this);
      }, St.prototype.add = function(nt, it) {
        this._verify2(nt, it);
        var ke = nt.add(it);
        return ke.cmp(this.m) >= 0 && ke.isub(this.m), ke._forceRed(this);
      }, St.prototype.iadd = function(nt, it) {
        this._verify2(nt, it);
        var ke = nt.iadd(it);
        return ke.cmp(this.m) >= 0 && ke.isub(this.m), ke;
      }, St.prototype.sub = function(nt, it) {
        this._verify2(nt, it);
        var ke = nt.sub(it);
        return ke.cmpn(0) < 0 && ke.iadd(this.m), ke._forceRed(this);
      }, St.prototype.isub = function(nt, it) {
        this._verify2(nt, it);
        var ke = nt.isub(it);
        return ke.cmpn(0) < 0 && ke.iadd(this.m), ke;
      }, St.prototype.shl = function(nt, it) {
        return this._verify1(nt), this.imod(nt.ushln(it));
      }, St.prototype.imul = function(nt, it) {
        return this._verify2(nt, it), this.imod(nt.imul(it));
      }, St.prototype.mul = function(nt, it) {
        return this._verify2(nt, it), this.imod(nt.mul(it));
      }, St.prototype.isqr = function(nt) {
        return this.imul(nt, nt.clone());
      }, St.prototype.sqr = function(nt) {
        return this.mul(nt, nt);
      }, St.prototype.sqrt = function(nt) {
        if (nt.isZero()) return nt.clone();
        var it = this.m.andln(3);
        if (K(it % 2 === 1), it === 3) {
          var ke = this.m.add(new V(1)).iushrn(2);
          return this.pow(nt, ke);
        }
        for (var rt = this.m.subn(1), ot = 0; !rt.isZero() && rt.andln(1) === 0; )
          ot++, rt.iushrn(1);
        K(!rt.isZero());
        var ft = new V(1).toRed(this), ct = ft.redNeg(), bt = this.m.subn(1).iushrn(1), ut = this.m.bitLength();
        for (ut = new V(2 * ut * ut).toRed(this); this.pow(ut, bt).cmp(ct) !== 0; )
          ut.redIAdd(ct);
        for (var gt = this.pow(ut, rt), dt = this.pow(nt, rt.addn(1).iushrn(1)), wt = this.pow(nt, rt), Ft = ot; wt.cmp(ft) !== 0; ) {
          for (var jt = wt, Nt = 0; jt.cmp(ft) !== 0; Nt++)
            jt = jt.redSqr();
          K(Nt < Ft);
          var Bt = this.pow(gt, new V(1).iushln(Ft - Nt - 1));
          dt = dt.redMul(Bt), gt = Bt.redSqr(), wt = wt.redMul(gt), Ft = Nt;
        }
        return dt;
      }, St.prototype.invm = function(nt) {
        var it = nt._invmp(this.m);
        return it.negative !== 0 ? (it.negative = 0, this.imod(it).redNeg()) : this.imod(it);
      }, St.prototype.pow = function(nt, it) {
        if (it.isZero()) return new V(1).toRed(this);
        if (it.cmpn(1) === 0) return nt.clone();
        var ke = 4, rt = new Array(1 << ke);
        rt[0] = new V(1).toRed(this), rt[1] = nt;
        for (var ot = 2; ot < rt.length; ot++)
          rt[ot] = this.mul(rt[ot - 1], nt);
        var ft = rt[0], ct = 0, bt = 0, ut = it.bitLength() % 26;
        for (ut === 0 && (ut = 26), ot = it.length - 1; ot >= 0; ot--) {
          for (var gt = it.words[ot], dt = ut - 1; dt >= 0; dt--) {
            var wt = gt >> dt & 1;
            if (ft !== rt[0] && (ft = this.sqr(ft)), wt === 0 && ct === 0) {
              bt = 0;
              continue;
            }
            ct <<= 1, ct |= wt, bt++, !(bt !== ke && (ot !== 0 || dt !== 0)) && (ft = this.mul(ft, rt[ct]), bt = 0, ct = 0);
          }
          ut = 26;
        }
        return ft;
      }, St.prototype.convertTo = function(nt) {
        var it = nt.umod(this.m);
        return it === nt ? it.clone() : it;
      }, St.prototype.convertFrom = function(nt) {
        var it = nt.clone();
        return it.red = null, it;
      }, V.mont = function(nt) {
        return new It(nt);
      };
      function It(Tt) {
        St.call(this, Tt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new V(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(It, St), It.prototype.convertTo = function(nt) {
        return this.imod(nt.ushln(this.shift));
      }, It.prototype.convertFrom = function(nt) {
        var it = this.imod(nt.mul(this.rinv));
        return it.red = null, it;
      }, It.prototype.imul = function(nt, it) {
        if (nt.isZero() || it.isZero())
          return nt.words[0] = 0, nt.length = 1, nt;
        var ke = nt.imul(it), rt = ke.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = ke.isub(rt).iushrn(this.shift), ft = ot;
        return ot.cmp(this.m) >= 0 ? ft = ot.isub(this.m) : ot.cmpn(0) < 0 && (ft = ot.iadd(this.m)), ft._forceRed(this);
      }, It.prototype.mul = function(nt, it) {
        if (nt.isZero() || it.isZero()) return new V(0)._forceRed(this);
        var ke = nt.mul(it), rt = ke.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = ke.isub(rt).iushrn(this.shift), ft = ot;
        return ot.cmp(this.m) >= 0 ? ft = ot.isub(this.m) : ot.cmpn(0) < 0 && (ft = ot.iadd(this.m)), ft._forceRed(this);
      }, It.prototype.invm = function(nt) {
        var it = this.imod(nt._invmp(this.m).mul(this.r2));
        return it._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(J) {
    return B || (B = new L(null)), B.generate(J);
  };
  function L(K) {
    this.rand = K;
  }
  if (brorand.exports.Rand = L, L.prototype.generate = function(J) {
    return this._rand(J);
  }, L.prototype._rand = function(J) {
    if (this.rand.getBytes)
      return this.rand.getBytes(J);
    for (var V = new Uint8Array(J), re = 0; re < V.length; re++)
      V[re] = this.rand.getByte();
    return V;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? L.prototype._rand = function(J) {
      var V = new Uint8Array(J);
      return self.crypto.getRandomValues(V), V;
    } : self.msCrypto && self.msCrypto.getRandomValues ? L.prototype._rand = function(J) {
      var V = new Uint8Array(J);
      return self.msCrypto.getRandomValues(V), V;
    } : typeof window == "object" && (L.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var W = requireCryptoBrowserify();
      if (typeof W.randomBytes != "function")
        throw new Error("Not supported");
      L.prototype._rand = function(J) {
        return W.randomBytes(J);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = requireBn$1(), L = requireBrorand();
  function W(K) {
    this.rand = K || new L.Rand();
  }
  return mr = W, W.create = function(J) {
    return new W(J);
  }, W.prototype._randbelow = function(J) {
    var V = J.bitLength(), re = Math.ceil(V / 8);
    do
      var ie = new B(this.rand.generate(re));
    while (ie.cmp(J) >= 0);
    return ie;
  }, W.prototype._randrange = function(J, V) {
    var re = V.sub(J);
    return J.add(this._randbelow(re));
  }, W.prototype.test = function(J, V, re) {
    var ie = J.bitLength(), oe = B.mont(J), pe = new B(1).toRed(oe);
    V || (V = Math.max(1, ie / 48 | 0));
    for (var ne = J.subn(1), ce = 0; !ne.testn(ce); ce++)
      ;
    for (var Ce = J.shrn(ce), Oe = ne.toRed(oe), st = !0; V > 0; V--) {
      var at = this._randrange(new B(2), ne);
      re && re(at);
      var lt = at.toRed(oe).redPow(Ce);
      if (!(lt.cmp(pe) === 0 || lt.cmp(Oe) === 0)) {
        for (var pt = 1; pt < ce; pt++) {
          if (lt = lt.redSqr(), lt.cmp(pe) === 0)
            return !1;
          if (lt.cmp(Oe) === 0)
            break;
        }
        if (pt === ce)
          return !1;
      }
    }
    return st;
  }, W.prototype.getDivisor = function(J, V) {
    var re = J.bitLength(), ie = B.mont(J), oe = new B(1).toRed(ie);
    V || (V = Math.max(1, re / 48 | 0));
    for (var pe = J.subn(1), ne = 0; !pe.testn(ne); ne++)
      ;
    for (var ce = J.shrn(ne), Ce = pe.toRed(ie); V > 0; V--) {
      var Oe = this._randrange(new B(2), pe), st = J.gcd(Oe);
      if (st.cmpn(1) !== 0)
        return st;
      var at = Oe.toRed(ie).redPow(ce);
      if (!(at.cmp(oe) === 0 || at.cmp(Ce) === 0)) {
        for (var lt = 1; lt < ne; lt++) {
          if (at = at.redSqr(), at.cmp(oe) === 0)
            return at.fromRed().subn(1).gcd(J);
          if (at.cmp(Ce) === 0)
            break;
        }
        if (lt === ne)
          return at = at.redSqr(), at.fromRed().subn(1).gcd(J);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = requireBrowser$9();
  generatePrime = lt, lt.simpleSieve = st, lt.fermatTest = at;
  var L = requireBn$1(), W = new L(24), K = requireMr(), J = new K(), V = new L(1), re = new L(2), ie = new L(5);
  new L(16), new L(8);
  var oe = new L(10), pe = new L(3);
  new L(7);
  var ne = new L(11), ce = new L(4);
  new L(12);
  var Ce = null;
  function Oe() {
    if (Ce !== null)
      return Ce;
    var pt = 1048576, ht = [];
    ht[0] = 2;
    for (var yt = 1, vt = 3; vt < pt; vt += 2) {
      for (var $t = Math.ceil(Math.sqrt(vt)), xt = 0; xt < yt && ht[xt] <= $t && vt % ht[xt] !== 0; xt++)
        ;
      yt !== xt && ht[xt] <= $t || (ht[yt++] = vt);
    }
    return Ce = ht, ht;
  }
  function st(pt) {
    for (var ht = Oe(), yt = 0; yt < ht.length; yt++)
      if (pt.modn(ht[yt]) === 0)
        return pt.cmpn(ht[yt]) === 0;
    return !0;
  }
  function at(pt) {
    var ht = L.mont(pt);
    return re.toRed(ht).redPow(pt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function lt(pt, ht) {
    if (pt < 16)
      return ht === 2 || ht === 5 ? new L([140, 123]) : new L([140, 39]);
    ht = new L(ht);
    for (var yt, vt; ; ) {
      for (yt = new L(B(Math.ceil(pt / 8))); yt.bitLength() > pt; )
        yt.ishrn(1);
      if (yt.isEven() && yt.iadd(V), yt.testn(1) || yt.iadd(re), ht.cmp(re)) {
        if (!ht.cmp(ie))
          for (; yt.mod(oe).cmp(pe); )
            yt.iadd(ce);
      } else for (; yt.mod(W).cmp(ne); )
        yt.iadd(ce);
      if (vt = yt.shrn(1), st(vt) && st(yt) && at(vt) && at(yt) && J.test(vt) && J.test(yt))
        return yt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = requireBn$1(), L = requireMr(), W = new L(), K = new B(24), J = new B(11), V = new B(10), re = new B(3), ie = new B(7), oe = requireGeneratePrime(), pe = requireBrowser$9();
  dh = st;
  function ne(lt, pt) {
    return pt = pt || "utf8", Buffer$2.isBuffer(lt) || (lt = new Buffer$2(lt, pt)), this._pub = new B(lt), this;
  }
  function ce(lt, pt) {
    return pt = pt || "utf8", Buffer$2.isBuffer(lt) || (lt = new Buffer$2(lt, pt)), this._priv = new B(lt), this;
  }
  var Ce = {};
  function Oe(lt, pt) {
    var ht = pt.toString("hex"), yt = [ht, lt.toString(16)].join("_");
    if (yt in Ce)
      return Ce[yt];
    var vt = 0;
    if (lt.isEven() || !oe.simpleSieve || !oe.fermatTest(lt) || !W.test(lt))
      return vt += 1, ht === "02" || ht === "05" ? vt += 8 : vt += 4, Ce[yt] = vt, vt;
    W.test(lt.shrn(1)) || (vt += 2);
    var $t;
    switch (ht) {
      case "02":
        lt.mod(K).cmp(J) && (vt += 8);
        break;
      case "05":
        $t = lt.mod(V), $t.cmp(re) && $t.cmp(ie) && (vt += 8);
        break;
      default:
        vt += 4;
    }
    return Ce[yt] = vt, vt;
  }
  function st(lt, pt, ht) {
    this.setGenerator(pt), this.__prime = new B(lt), this._prime = B.mont(this.__prime), this._primeLen = lt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ht ? (this.setPublicKey = ne, this.setPrivateKey = ce) : this._primeCode = 8;
  }
  Object.defineProperty(st.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Oe(this.__prime, this.__gen)), this._primeCode;
    }
  }), st.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(pe(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, st.prototype.computeSecret = function(lt) {
    lt = new B(lt), lt = lt.toRed(this._prime);
    var pt = lt.redPow(this._priv).fromRed(), ht = new Buffer$2(pt.toArray()), yt = this.getPrime();
    if (ht.length < yt.length) {
      var vt = new Buffer$2(yt.length - ht.length);
      vt.fill(0), ht = Buffer$2.concat([vt, ht]);
    }
    return ht;
  }, st.prototype.getPublicKey = function(pt) {
    return at(this._pub, pt);
  }, st.prototype.getPrivateKey = function(pt) {
    return at(this._priv, pt);
  }, st.prototype.getPrime = function(lt) {
    return at(this.__prime, lt);
  }, st.prototype.getGenerator = function(lt) {
    return at(this._gen, lt);
  }, st.prototype.setGenerator = function(lt, pt) {
    return pt = pt || "utf8", Buffer$2.isBuffer(lt) || (lt = new Buffer$2(lt, pt)), this.__gen = lt, this._gen = new B(lt), this;
  };
  function at(lt, pt) {
    var ht = new Buffer$2(lt.toArray());
    return pt ? ht.toString(pt) : ht;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var B = requireGeneratePrime(), L = require$$1$1, W = requireDh();
  function K(re) {
    var ie = new Buffer$2(L[re].prime, "hex"), oe = new Buffer$2(L[re].gen, "hex");
    return new W(ie, oe);
  }
  var J = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function V(re, ie, oe, pe) {
    return Buffer$2.isBuffer(ie) || J[ie] === void 0 ? V(re, "binary", ie, oe) : (ie = ie || "binary", pe = pe || "binary", oe = oe || new Buffer$2([2]), Buffer$2.isBuffer(oe) || (oe = new Buffer$2(oe, pe)), typeof re == "number" ? new W(B(re, oe), oe, !0) : (Buffer$2.isBuffer(re) || (re = new Buffer$2(re, ie)), new W(re, oe, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = K, browser$4.createDiffieHellman = browser$4.DiffieHellman = V, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: B } : processNextickArgs.exports = process$1;
  function B(L, W, K, J) {
    if (typeof L != "function")
      throw new TypeError('"callback" argument must be a function');
    var V = arguments.length, re, ie;
    switch (V) {
      case 0:
      case 1:
        return process$1.nextTick(L);
      case 2:
        return process$1.nextTick(function() {
          L.call(null, W);
        });
      case 3:
        return process$1.nextTick(function() {
          L.call(null, W, K);
        });
      case 4:
        return process$1.nextTick(function() {
          L.call(null, W, K, J);
        });
      default:
        for (re = new Array(V - 1), ie = 0; ie < re.length; )
          re[ie++] = arguments[ie];
        return process$1.nextTick(function() {
          L.apply(null, re);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var B = {}.toString;
  return isarray = Array.isArray || function(L) {
    return B.call(L) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(B, L) {
    var W = require$$1$2, K = W.Buffer;
    function J(re, ie) {
      for (var oe in re)
        ie[oe] = re[oe];
    }
    K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? B.exports = W : (J(W, L), L.Buffer = V);
    function V(re, ie, oe) {
      return K(re, ie, oe);
    }
    J(K, V), V.from = function(re, ie, oe) {
      if (typeof re == "number")
        throw new TypeError("Argument must not be a number");
      return K(re, ie, oe);
    }, V.alloc = function(re, ie, oe) {
      if (typeof re != "number")
        throw new TypeError("Argument must be a number");
      var pe = K(re);
      return ie !== void 0 ? typeof oe == "string" ? pe.fill(ie, oe) : pe.fill(ie) : pe.fill(0), pe;
    }, V.allocUnsafe = function(re) {
      if (typeof re != "number")
        throw new TypeError("Argument must be a number");
      return K(re);
    }, V.allocUnsafeSlow = function(re) {
      if (typeof re != "number")
        throw new TypeError("Argument must be a number");
      return W.SlowBuffer(re);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function B(at) {
    return Array.isArray ? Array.isArray(at) : st(at) === "[object Array]";
  }
  util.isArray = B;
  function L(at) {
    return typeof at == "boolean";
  }
  util.isBoolean = L;
  function W(at) {
    return at === null;
  }
  util.isNull = W;
  function K(at) {
    return at == null;
  }
  util.isNullOrUndefined = K;
  function J(at) {
    return typeof at == "number";
  }
  util.isNumber = J;
  function V(at) {
    return typeof at == "string";
  }
  util.isString = V;
  function re(at) {
    return typeof at == "symbol";
  }
  util.isSymbol = re;
  function ie(at) {
    return at === void 0;
  }
  util.isUndefined = ie;
  function oe(at) {
    return st(at) === "[object RegExp]";
  }
  util.isRegExp = oe;
  function pe(at) {
    return typeof at == "object" && at !== null;
  }
  util.isObject = pe;
  function ne(at) {
    return st(at) === "[object Date]";
  }
  util.isDate = ne;
  function ce(at) {
    return st(at) === "[object Error]" || at instanceof Error;
  }
  util.isError = ce;
  function Ce(at) {
    return typeof at == "function";
  }
  util.isFunction = Ce;
  function Oe(at) {
    return at === null || typeof at == "boolean" || typeof at == "number" || typeof at == "string" || typeof at == "symbol" || // ES6 symbol
    typeof at > "u";
  }
  util.isPrimitive = Oe, util.isBuffer = require$$1$2.Buffer.isBuffer;
  function st(at) {
    return Object.prototype.toString.call(at);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function L(V, re) {
      if (!(V instanceof re))
        throw new TypeError("Cannot call a class as a function");
    }
    var W = requireSafeBuffer().Buffer, K = requireUtil$1();
    function J(V, re, ie) {
      V.copy(re, ie);
    }
    B.exports = function() {
      function V() {
        L(this, V), this.head = null, this.tail = null, this.length = 0;
      }
      return V.prototype.push = function(ie) {
        var oe = { data: ie, next: null };
        this.length > 0 ? this.tail.next = oe : this.head = oe, this.tail = oe, ++this.length;
      }, V.prototype.unshift = function(ie) {
        var oe = { data: ie, next: this.head };
        this.length === 0 && (this.tail = oe), this.head = oe, ++this.length;
      }, V.prototype.shift = function() {
        if (this.length !== 0) {
          var ie = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ie;
        }
      }, V.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, V.prototype.join = function(ie) {
        if (this.length === 0) return "";
        for (var oe = this.head, pe = "" + oe.data; oe = oe.next; )
          pe += ie + oe.data;
        return pe;
      }, V.prototype.concat = function(ie) {
        if (this.length === 0) return W.alloc(0);
        for (var oe = W.allocUnsafe(ie >>> 0), pe = this.head, ne = 0; pe; )
          J(pe.data, oe, ne), ne += pe.data.length, pe = pe.next;
        return oe;
      }, V;
    }(), K && K.inspect && K.inspect.custom && (B.exports.prototype[K.inspect.custom] = function() {
      var V = K.inspect({ length: this.length });
      return this.constructor.name + " " + V;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var B = requireProcessNextickArgs();
  function L(J, V) {
    var re = this, ie = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
    return ie || oe ? (V ? V(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, B.nextTick(K, this, J)) : B.nextTick(K, this, J)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(pe) {
      !V && pe ? re._writableState ? re._writableState.errorEmitted || (re._writableState.errorEmitted = !0, B.nextTick(K, re, pe)) : B.nextTick(K, re, pe) : V && V(pe);
    }), this);
  }
  function W() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function K(J, V) {
    J.emit("error", V);
  }
  return destroy_1 = {
    destroy: L,
    undestroy: W
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = requireProcessNextickArgs();
  _stream_writable = at;
  function L(ft) {
    var ct = this;
    this.next = null, this.entry = null, this.finish = function() {
      ot(ct, ft);
    };
  }
  var W = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, K;
  at.WritableState = Oe;
  var J = Object.create(requireUtil());
  J.inherits = requireInherits_browser();
  var V = {
    deprecate: requireBrowser$b()
  }, re = requireStreamBrowser(), ie = requireSafeBuffer().Buffer, oe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function pe(ft) {
    return ie.from(ft);
  }
  function ne(ft) {
    return ie.isBuffer(ft) || ft instanceof oe;
  }
  var ce = requireDestroy();
  J.inherits(at, re);
  function Ce() {
  }
  function Oe(ft, ct) {
    K = K || require_stream_duplex(), ft = ft || {};
    var bt = ct instanceof K;
    this.objectMode = !!ft.objectMode, bt && (this.objectMode = this.objectMode || !!ft.writableObjectMode);
    var ut = ft.highWaterMark, gt = ft.writableHighWaterMark, dt = this.objectMode ? 16 : 16 * 1024;
    ut || ut === 0 ? this.highWaterMark = ut : bt && (gt || gt === 0) ? this.highWaterMark = gt : this.highWaterMark = dt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var wt = ft.decodeStrings === !1;
    this.decodeStrings = !wt, this.defaultEncoding = ft.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ft) {
      Ct(ct, Ft);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new L(this);
  }
  Oe.prototype.getBuffer = function() {
    for (var ct = this.bufferedRequest, bt = []; ct; )
      bt.push(ct), ct = ct.next;
    return bt;
  }, function() {
    try {
      Object.defineProperty(Oe.prototype, "buffer", {
        get: V.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var st;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (st = Function.prototype[Symbol.hasInstance], Object.defineProperty(at, Symbol.hasInstance, {
    value: function(ft) {
      return st.call(this, ft) ? !0 : this !== at ? !1 : ft && ft._writableState instanceof Oe;
    }
  })) : st = function(ft) {
    return ft instanceof this;
  };
  function at(ft) {
    if (K = K || require_stream_duplex(), !st.call(at, this) && !(this instanceof K))
      return new at(ft);
    this._writableState = new Oe(ft, this), this.writable = !0, ft && (typeof ft.write == "function" && (this._write = ft.write), typeof ft.writev == "function" && (this._writev = ft.writev), typeof ft.destroy == "function" && (this._destroy = ft.destroy), typeof ft.final == "function" && (this._final = ft.final)), re.call(this);
  }
  at.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function lt(ft, ct) {
    var bt = new Error("write after end");
    ft.emit("error", bt), B.nextTick(ct, bt);
  }
  function pt(ft, ct, bt, ut) {
    var gt = !0, dt = !1;
    return bt === null ? dt = new TypeError("May not write null values to stream") : typeof bt != "string" && bt !== void 0 && !ct.objectMode && (dt = new TypeError("Invalid non-string/buffer chunk")), dt && (ft.emit("error", dt), B.nextTick(ut, dt), gt = !1), gt;
  }
  at.prototype.write = function(ft, ct, bt) {
    var ut = this._writableState, gt = !1, dt = !ut.objectMode && ne(ft);
    return dt && !ie.isBuffer(ft) && (ft = pe(ft)), typeof ct == "function" && (bt = ct, ct = null), dt ? ct = "buffer" : ct || (ct = ut.defaultEncoding), typeof bt != "function" && (bt = Ce), ut.ended ? lt(this, bt) : (dt || pt(this, ut, ft, bt)) && (ut.pendingcb++, gt = yt(this, ut, dt, ft, ct, bt)), gt;
  }, at.prototype.cork = function() {
    var ft = this._writableState;
    ft.corked++;
  }, at.prototype.uncork = function() {
    var ft = this._writableState;
    ft.corked && (ft.corked--, !ft.writing && !ft.corked && !ft.bufferProcessing && ft.bufferedRequest && It(this, ft));
  }, at.prototype.setDefaultEncoding = function(ct) {
    if (typeof ct == "string" && (ct = ct.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ct + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ct);
    return this._writableState.defaultEncoding = ct, this;
  };
  function ht(ft, ct, bt) {
    return !ft.objectMode && ft.decodeStrings !== !1 && typeof ct == "string" && (ct = ie.from(ct, bt)), ct;
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function yt(ft, ct, bt, ut, gt, dt) {
    if (!bt) {
      var wt = ht(ct, ut, gt);
      ut !== wt && (bt = !0, gt = "buffer", ut = wt);
    }
    var Ft = ct.objectMode ? 1 : ut.length;
    ct.length += Ft;
    var jt = ct.length < ct.highWaterMark;
    if (jt || (ct.needDrain = !0), ct.writing || ct.corked) {
      var Nt = ct.lastBufferedRequest;
      ct.lastBufferedRequest = {
        chunk: ut,
        encoding: gt,
        isBuf: bt,
        callback: dt,
        next: null
      }, Nt ? Nt.next = ct.lastBufferedRequest : ct.bufferedRequest = ct.lastBufferedRequest, ct.bufferedRequestCount += 1;
    } else
      vt(ft, ct, !1, Ft, ut, gt, dt);
    return jt;
  }
  function vt(ft, ct, bt, ut, gt, dt, wt) {
    ct.writelen = ut, ct.writecb = wt, ct.writing = !0, ct.sync = !0, bt ? ft._writev(gt, ct.onwrite) : ft._write(gt, dt, ct.onwrite), ct.sync = !1;
  }
  function $t(ft, ct, bt, ut, gt) {
    --ct.pendingcb, bt ? (B.nextTick(gt, ut), B.nextTick(ke, ft, ct), ft._writableState.errorEmitted = !0, ft.emit("error", ut)) : (gt(ut), ft._writableState.errorEmitted = !0, ft.emit("error", ut), ke(ft, ct));
  }
  function xt(ft) {
    ft.writing = !1, ft.writecb = null, ft.length -= ft.writelen, ft.writelen = 0;
  }
  function Ct(ft, ct) {
    var bt = ft._writableState, ut = bt.sync, gt = bt.writecb;
    if (xt(bt), ct) $t(ft, bt, ut, ct, gt);
    else {
      var dt = Tt(bt);
      !dt && !bt.corked && !bt.bufferProcessing && bt.bufferedRequest && It(ft, bt), ut ? W(Et, ft, bt, dt, gt) : Et(ft, bt, dt, gt);
    }
  }
  function Et(ft, ct, bt, ut) {
    bt || St(ft, ct), ct.pendingcb--, ut(), ke(ft, ct);
  }
  function St(ft, ct) {
    ct.length === 0 && ct.needDrain && (ct.needDrain = !1, ft.emit("drain"));
  }
  function It(ft, ct) {
    ct.bufferProcessing = !0;
    var bt = ct.bufferedRequest;
    if (ft._writev && bt && bt.next) {
      var ut = ct.bufferedRequestCount, gt = new Array(ut), dt = ct.corkedRequestsFree;
      dt.entry = bt;
      for (var wt = 0, Ft = !0; bt; )
        gt[wt] = bt, bt.isBuf || (Ft = !1), bt = bt.next, wt += 1;
      gt.allBuffers = Ft, vt(ft, ct, !0, ct.length, gt, "", dt.finish), ct.pendingcb++, ct.lastBufferedRequest = null, dt.next ? (ct.corkedRequestsFree = dt.next, dt.next = null) : ct.corkedRequestsFree = new L(ct), ct.bufferedRequestCount = 0;
    } else {
      for (; bt; ) {
        var jt = bt.chunk, Nt = bt.encoding, Bt = bt.callback, Rt = ct.objectMode ? 1 : jt.length;
        if (vt(ft, ct, !1, Rt, jt, Nt, Bt), bt = bt.next, ct.bufferedRequestCount--, ct.writing)
          break;
      }
      bt === null && (ct.lastBufferedRequest = null);
    }
    ct.bufferedRequest = bt, ct.bufferProcessing = !1;
  }
  at.prototype._write = function(ft, ct, bt) {
    bt(new Error("_write() is not implemented"));
  }, at.prototype._writev = null, at.prototype.end = function(ft, ct, bt) {
    var ut = this._writableState;
    typeof ft == "function" ? (bt = ft, ft = null, ct = null) : typeof ct == "function" && (bt = ct, ct = null), ft != null && this.write(ft, ct), ut.corked && (ut.corked = 1, this.uncork()), ut.ending || rt(this, ut, bt);
  };
  function Tt(ft) {
    return ft.ending && ft.length === 0 && ft.bufferedRequest === null && !ft.finished && !ft.writing;
  }
  function nt(ft, ct) {
    ft._final(function(bt) {
      ct.pendingcb--, bt && ft.emit("error", bt), ct.prefinished = !0, ft.emit("prefinish"), ke(ft, ct);
    });
  }
  function it(ft, ct) {
    !ct.prefinished && !ct.finalCalled && (typeof ft._final == "function" ? (ct.pendingcb++, ct.finalCalled = !0, B.nextTick(nt, ft, ct)) : (ct.prefinished = !0, ft.emit("prefinish")));
  }
  function ke(ft, ct) {
    var bt = Tt(ct);
    return bt && (it(ft, ct), ct.pendingcb === 0 && (ct.finished = !0, ft.emit("finish"))), bt;
  }
  function rt(ft, ct, bt) {
    ct.ending = !0, ke(ft, ct), bt && (ct.finished ? B.nextTick(bt) : ft.once("finish", bt)), ct.ended = !0, ft.writable = !1;
  }
  function ot(ft, ct, bt) {
    var ut = ft.entry;
    for (ft.entry = null; ut; ) {
      var gt = ut.callback;
      ct.pendingcb--, gt(bt), ut = ut.next;
    }
    ct.corkedRequestsFree.next = ft;
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ft) {
      this._writableState && (this._writableState.destroyed = ft);
    }
  }), at.prototype.destroy = ce.destroy, at.prototype._undestroy = ce.undestroy, at.prototype._destroy = function(ft, ct) {
    this.end(), ct(ft);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = requireProcessNextickArgs(), L = Object.keys || function(ce) {
    var Ce = [];
    for (var Oe in ce)
      Ce.push(Oe);
    return Ce;
  };
  _stream_duplex = oe;
  var W = Object.create(requireUtil());
  W.inherits = requireInherits_browser();
  var K = require_stream_readable(), J = require_stream_writable();
  W.inherits(oe, K);
  for (var V = L(J.prototype), re = 0; re < V.length; re++) {
    var ie = V[re];
    oe.prototype[ie] || (oe.prototype[ie] = J.prototype[ie]);
  }
  function oe(ce) {
    if (!(this instanceof oe)) return new oe(ce);
    K.call(this, ce), J.call(this, ce), ce && ce.readable === !1 && (this.readable = !1), ce && ce.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, ce && ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", pe);
  }
  Object.defineProperty(oe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function pe() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(ne, this);
  }
  function ne(ce) {
    ce.end();
  }
  return Object.defineProperty(oe.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ce) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ce, this._writableState.destroyed = ce);
    }
  }), oe.prototype._destroy = function(ce, Ce) {
    this.push(null), this.end(), B.nextTick(Ce, ce);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = requireProcessNextickArgs();
  _stream_readable = ht;
  var L = requireIsarray(), W;
  ht.ReadableState = pt, requireEvents().EventEmitter;
  var K = function(Bt, Rt) {
    return Bt.listeners(Rt).length;
  }, J = requireStreamBrowser(), V = requireSafeBuffer().Buffer, re = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ie(Bt) {
    return V.from(Bt);
  }
  function oe(Bt) {
    return V.isBuffer(Bt) || Bt instanceof re;
  }
  var pe = Object.create(requireUtil());
  pe.inherits = requireInherits_browser();
  var ne = requireUtil$1(), ce = void 0;
  ne && ne.debuglog ? ce = ne.debuglog("stream") : ce = function() {
  };
  var Ce = requireBufferList(), Oe = requireDestroy(), st;
  pe.inherits(ht, J);
  var at = ["error", "close", "destroy", "pause", "resume"];
  function lt(Bt, Rt, Ut) {
    if (typeof Bt.prependListener == "function") return Bt.prependListener(Rt, Ut);
    !Bt._events || !Bt._events[Rt] ? Bt.on(Rt, Ut) : L(Bt._events[Rt]) ? Bt._events[Rt].unshift(Ut) : Bt._events[Rt] = [Ut, Bt._events[Rt]];
  }
  function pt(Bt, Rt) {
    W = W || require_stream_duplex(), Bt = Bt || {};
    var Ut = Rt instanceof W;
    this.objectMode = !!Bt.objectMode, Ut && (this.objectMode = this.objectMode || !!Bt.readableObjectMode);
    var zt = Bt.highWaterMark, Mt = Bt.readableHighWaterMark, kt = this.objectMode ? 16 : 16 * 1024;
    zt || zt === 0 ? this.highWaterMark = zt : Ut && (Mt || Mt === 0) ? this.highWaterMark = Mt : this.highWaterMark = kt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Bt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Bt.encoding && (st || (st = requireString_decoder().StringDecoder), this.decoder = new st(Bt.encoding), this.encoding = Bt.encoding);
  }
  function ht(Bt) {
    if (W = W || require_stream_duplex(), !(this instanceof ht)) return new ht(Bt);
    this._readableState = new pt(Bt, this), this.readable = !0, Bt && (typeof Bt.read == "function" && (this._read = Bt.read), typeof Bt.destroy == "function" && (this._destroy = Bt.destroy)), J.call(this);
  }
  Object.defineProperty(ht.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Bt) {
      this._readableState && (this._readableState.destroyed = Bt);
    }
  }), ht.prototype.destroy = Oe.destroy, ht.prototype._undestroy = Oe.undestroy, ht.prototype._destroy = function(Bt, Rt) {
    this.push(null), Rt(Bt);
  }, ht.prototype.push = function(Bt, Rt) {
    var Ut = this._readableState, zt;
    return Ut.objectMode ? zt = !0 : typeof Bt == "string" && (Rt = Rt || Ut.defaultEncoding, Rt !== Ut.encoding && (Bt = V.from(Bt, Rt), Rt = ""), zt = !0), yt(this, Bt, Rt, !1, zt);
  }, ht.prototype.unshift = function(Bt) {
    return yt(this, Bt, null, !0, !1);
  };
  function yt(Bt, Rt, Ut, zt, Mt) {
    var kt = Bt._readableState;
    if (Rt === null)
      kt.reading = !1, It(Bt, kt);
    else {
      var Gt;
      Mt || (Gt = $t(kt, Rt)), Gt ? Bt.emit("error", Gt) : kt.objectMode || Rt && Rt.length > 0 ? (typeof Rt != "string" && !kt.objectMode && Object.getPrototypeOf(Rt) !== V.prototype && (Rt = ie(Rt)), zt ? kt.endEmitted ? Bt.emit("error", new Error("stream.unshift() after end event")) : vt(Bt, kt, Rt, !0) : kt.ended ? Bt.emit("error", new Error("stream.push() after EOF")) : (kt.reading = !1, kt.decoder && !Ut ? (Rt = kt.decoder.write(Rt), kt.objectMode || Rt.length !== 0 ? vt(Bt, kt, Rt, !1) : it(Bt, kt)) : vt(Bt, kt, Rt, !1))) : zt || (kt.reading = !1);
    }
    return xt(kt);
  }
  function vt(Bt, Rt, Ut, zt) {
    Rt.flowing && Rt.length === 0 && !Rt.sync ? (Bt.emit("data", Ut), Bt.read(0)) : (Rt.length += Rt.objectMode ? 1 : Ut.length, zt ? Rt.buffer.unshift(Ut) : Rt.buffer.push(Ut), Rt.needReadable && Tt(Bt)), it(Bt, Rt);
  }
  function $t(Bt, Rt) {
    var Ut;
    return !oe(Rt) && typeof Rt != "string" && Rt !== void 0 && !Bt.objectMode && (Ut = new TypeError("Invalid non-string/buffer chunk")), Ut;
  }
  function xt(Bt) {
    return !Bt.ended && (Bt.needReadable || Bt.length < Bt.highWaterMark || Bt.length === 0);
  }
  ht.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ht.prototype.setEncoding = function(Bt) {
    return st || (st = requireString_decoder().StringDecoder), this._readableState.decoder = new st(Bt), this._readableState.encoding = Bt, this;
  };
  var Ct = 8388608;
  function Et(Bt) {
    return Bt >= Ct ? Bt = Ct : (Bt--, Bt |= Bt >>> 1, Bt |= Bt >>> 2, Bt |= Bt >>> 4, Bt |= Bt >>> 8, Bt |= Bt >>> 16, Bt++), Bt;
  }
  function St(Bt, Rt) {
    return Bt <= 0 || Rt.length === 0 && Rt.ended ? 0 : Rt.objectMode ? 1 : Bt !== Bt ? Rt.flowing && Rt.length ? Rt.buffer.head.data.length : Rt.length : (Bt > Rt.highWaterMark && (Rt.highWaterMark = Et(Bt)), Bt <= Rt.length ? Bt : Rt.ended ? Rt.length : (Rt.needReadable = !0, 0));
  }
  ht.prototype.read = function(Bt) {
    ce("read", Bt), Bt = parseInt(Bt, 10);
    var Rt = this._readableState, Ut = Bt;
    if (Bt !== 0 && (Rt.emittedReadable = !1), Bt === 0 && Rt.needReadable && (Rt.length >= Rt.highWaterMark || Rt.ended))
      return ce("read: emitReadable", Rt.length, Rt.ended), Rt.length === 0 && Rt.ended ? Ft(this) : Tt(this), null;
    if (Bt = St(Bt, Rt), Bt === 0 && Rt.ended)
      return Rt.length === 0 && Ft(this), null;
    var zt = Rt.needReadable;
    ce("need readable", zt), (Rt.length === 0 || Rt.length - Bt < Rt.highWaterMark) && (zt = !0, ce("length less than watermark", zt)), Rt.ended || Rt.reading ? (zt = !1, ce("reading or ended", zt)) : zt && (ce("do read"), Rt.reading = !0, Rt.sync = !0, Rt.length === 0 && (Rt.needReadable = !0), this._read(Rt.highWaterMark), Rt.sync = !1, Rt.reading || (Bt = St(Ut, Rt)));
    var Mt;
    return Bt > 0 ? Mt = ut(Bt, Rt) : Mt = null, Mt === null ? (Rt.needReadable = !0, Bt = 0) : Rt.length -= Bt, Rt.length === 0 && (Rt.ended || (Rt.needReadable = !0), Ut !== Bt && Rt.ended && Ft(this)), Mt !== null && this.emit("data", Mt), Mt;
  };
  function It(Bt, Rt) {
    if (!Rt.ended) {
      if (Rt.decoder) {
        var Ut = Rt.decoder.end();
        Ut && Ut.length && (Rt.buffer.push(Ut), Rt.length += Rt.objectMode ? 1 : Ut.length);
      }
      Rt.ended = !0, Tt(Bt);
    }
  }
  function Tt(Bt) {
    var Rt = Bt._readableState;
    Rt.needReadable = !1, Rt.emittedReadable || (ce("emitReadable", Rt.flowing), Rt.emittedReadable = !0, Rt.sync ? B.nextTick(nt, Bt) : nt(Bt));
  }
  function nt(Bt) {
    ce("emit readable"), Bt.emit("readable"), bt(Bt);
  }
  function it(Bt, Rt) {
    Rt.readingMore || (Rt.readingMore = !0, B.nextTick(ke, Bt, Rt));
  }
  function ke(Bt, Rt) {
    for (var Ut = Rt.length; !Rt.reading && !Rt.flowing && !Rt.ended && Rt.length < Rt.highWaterMark && (ce("maybeReadMore read 0"), Bt.read(0), Ut !== Rt.length); )
      Ut = Rt.length;
    Rt.readingMore = !1;
  }
  ht.prototype._read = function(Bt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ht.prototype.pipe = function(Bt, Rt) {
    var Ut = this, zt = this._readableState;
    switch (zt.pipesCount) {
      case 0:
        zt.pipes = Bt;
        break;
      case 1:
        zt.pipes = [zt.pipes, Bt];
        break;
      default:
        zt.pipes.push(Bt);
        break;
    }
    zt.pipesCount += 1, ce("pipe count=%d opts=%j", zt.pipesCount, Rt);
    var Mt = (!Rt || Rt.end !== !1) && Bt !== process$1.stdout && Bt !== process$1.stderr, kt = Mt ? Qt : Rr;
    zt.endEmitted ? B.nextTick(kt) : Ut.once("end", kt), Bt.on("unpipe", Gt);
    function Gt(pr, $r) {
      ce("onunpipe"), pr === Ut && $r && $r.hasUnpiped === !1 && ($r.hasUnpiped = !0, cr());
    }
    function Qt() {
      ce("onend"), Bt.end();
    }
    var nr = rt(Ut);
    Bt.on("drain", nr);
    var ar = !1;
    function cr() {
      ce("cleanup"), Bt.removeListener("close", dr), Bt.removeListener("finish", Tr), Bt.removeListener("drain", nr), Bt.removeListener("error", Pr), Bt.removeListener("unpipe", Gt), Ut.removeListener("end", Qt), Ut.removeListener("end", Rr), Ut.removeListener("data", Jt), ar = !0, zt.awaitDrain && (!Bt._writableState || Bt._writableState.needDrain) && nr();
    }
    var hr = !1;
    Ut.on("data", Jt);
    function Jt(pr) {
      ce("ondata"), hr = !1;
      var $r = Bt.write(pr);
      $r === !1 && !hr && ((zt.pipesCount === 1 && zt.pipes === Bt || zt.pipesCount > 1 && Nt(zt.pipes, Bt) !== -1) && !ar && (ce("false write response, pause", zt.awaitDrain), zt.awaitDrain++, hr = !0), Ut.pause());
    }
    function Pr(pr) {
      ce("onerror", pr), Rr(), Bt.removeListener("error", Pr), K(Bt, "error") === 0 && Bt.emit("error", pr);
    }
    lt(Bt, "error", Pr);
    function dr() {
      Bt.removeListener("finish", Tr), Rr();
    }
    Bt.once("close", dr);
    function Tr() {
      ce("onfinish"), Bt.removeListener("close", dr), Rr();
    }
    Bt.once("finish", Tr);
    function Rr() {
      ce("unpipe"), Ut.unpipe(Bt);
    }
    return Bt.emit("pipe", Ut), zt.flowing || (ce("pipe resume"), Ut.resume()), Bt;
  };
  function rt(Bt) {
    return function() {
      var Rt = Bt._readableState;
      ce("pipeOnDrain", Rt.awaitDrain), Rt.awaitDrain && Rt.awaitDrain--, Rt.awaitDrain === 0 && K(Bt, "data") && (Rt.flowing = !0, bt(Bt));
    };
  }
  ht.prototype.unpipe = function(Bt) {
    var Rt = this._readableState, Ut = { hasUnpiped: !1 };
    if (Rt.pipesCount === 0) return this;
    if (Rt.pipesCount === 1)
      return Bt && Bt !== Rt.pipes ? this : (Bt || (Bt = Rt.pipes), Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1, Bt && Bt.emit("unpipe", this, Ut), this);
    if (!Bt) {
      var zt = Rt.pipes, Mt = Rt.pipesCount;
      Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1;
      for (var kt = 0; kt < Mt; kt++)
        zt[kt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Gt = Nt(Rt.pipes, Bt);
    return Gt === -1 ? this : (Rt.pipes.splice(Gt, 1), Rt.pipesCount -= 1, Rt.pipesCount === 1 && (Rt.pipes = Rt.pipes[0]), Bt.emit("unpipe", this, Ut), this);
  }, ht.prototype.on = function(Bt, Rt) {
    var Ut = J.prototype.on.call(this, Bt, Rt);
    if (Bt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Bt === "readable") {
      var zt = this._readableState;
      !zt.endEmitted && !zt.readableListening && (zt.readableListening = zt.needReadable = !0, zt.emittedReadable = !1, zt.reading ? zt.length && Tt(this) : B.nextTick(ot, this));
    }
    return Ut;
  }, ht.prototype.addListener = ht.prototype.on;
  function ot(Bt) {
    ce("readable nexttick read 0"), Bt.read(0);
  }
  ht.prototype.resume = function() {
    var Bt = this._readableState;
    return Bt.flowing || (ce("resume"), Bt.flowing = !0, ft(this, Bt)), this;
  };
  function ft(Bt, Rt) {
    Rt.resumeScheduled || (Rt.resumeScheduled = !0, B.nextTick(ct, Bt, Rt));
  }
  function ct(Bt, Rt) {
    Rt.reading || (ce("resume read 0"), Bt.read(0)), Rt.resumeScheduled = !1, Rt.awaitDrain = 0, Bt.emit("resume"), bt(Bt), Rt.flowing && !Rt.reading && Bt.read(0);
  }
  ht.prototype.pause = function() {
    return ce("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ce("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function bt(Bt) {
    var Rt = Bt._readableState;
    for (ce("flow", Rt.flowing); Rt.flowing && Bt.read() !== null; )
      ;
  }
  ht.prototype.wrap = function(Bt) {
    var Rt = this, Ut = this._readableState, zt = !1;
    Bt.on("end", function() {
      if (ce("wrapped end"), Ut.decoder && !Ut.ended) {
        var Gt = Ut.decoder.end();
        Gt && Gt.length && Rt.push(Gt);
      }
      Rt.push(null);
    }), Bt.on("data", function(Gt) {
      if (ce("wrapped data"), Ut.decoder && (Gt = Ut.decoder.write(Gt)), !(Ut.objectMode && Gt == null) && !(!Ut.objectMode && (!Gt || !Gt.length))) {
        var Qt = Rt.push(Gt);
        Qt || (zt = !0, Bt.pause());
      }
    });
    for (var Mt in Bt)
      this[Mt] === void 0 && typeof Bt[Mt] == "function" && (this[Mt] = /* @__PURE__ */ function(Gt) {
        return function() {
          return Bt[Gt].apply(Bt, arguments);
        };
      }(Mt));
    for (var kt = 0; kt < at.length; kt++)
      Bt.on(at[kt], this.emit.bind(this, at[kt]));
    return this._read = function(Gt) {
      ce("wrapped _read", Gt), zt && (zt = !1, Bt.resume());
    }, this;
  }, Object.defineProperty(ht.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ht._fromList = ut;
  function ut(Bt, Rt) {
    if (Rt.length === 0) return null;
    var Ut;
    return Rt.objectMode ? Ut = Rt.buffer.shift() : !Bt || Bt >= Rt.length ? (Rt.decoder ? Ut = Rt.buffer.join("") : Rt.buffer.length === 1 ? Ut = Rt.buffer.head.data : Ut = Rt.buffer.concat(Rt.length), Rt.buffer.clear()) : Ut = gt(Bt, Rt.buffer, Rt.decoder), Ut;
  }
  function gt(Bt, Rt, Ut) {
    var zt;
    return Bt < Rt.head.data.length ? (zt = Rt.head.data.slice(0, Bt), Rt.head.data = Rt.head.data.slice(Bt)) : Bt === Rt.head.data.length ? zt = Rt.shift() : zt = Ut ? dt(Bt, Rt) : wt(Bt, Rt), zt;
  }
  function dt(Bt, Rt) {
    var Ut = Rt.head, zt = 1, Mt = Ut.data;
    for (Bt -= Mt.length; Ut = Ut.next; ) {
      var kt = Ut.data, Gt = Bt > kt.length ? kt.length : Bt;
      if (Gt === kt.length ? Mt += kt : Mt += kt.slice(0, Bt), Bt -= Gt, Bt === 0) {
        Gt === kt.length ? (++zt, Ut.next ? Rt.head = Ut.next : Rt.head = Rt.tail = null) : (Rt.head = Ut, Ut.data = kt.slice(Gt));
        break;
      }
      ++zt;
    }
    return Rt.length -= zt, Mt;
  }
  function wt(Bt, Rt) {
    var Ut = V.allocUnsafe(Bt), zt = Rt.head, Mt = 1;
    for (zt.data.copy(Ut), Bt -= zt.data.length; zt = zt.next; ) {
      var kt = zt.data, Gt = Bt > kt.length ? kt.length : Bt;
      if (kt.copy(Ut, Ut.length - Bt, 0, Gt), Bt -= Gt, Bt === 0) {
        Gt === kt.length ? (++Mt, zt.next ? Rt.head = zt.next : Rt.head = Rt.tail = null) : (Rt.head = zt, zt.data = kt.slice(Gt));
        break;
      }
      ++Mt;
    }
    return Rt.length -= Mt, Ut;
  }
  function Ft(Bt) {
    var Rt = Bt._readableState;
    if (Rt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Rt.endEmitted || (Rt.ended = !0, B.nextTick(jt, Rt, Bt));
  }
  function jt(Bt, Rt) {
    !Bt.endEmitted && Bt.length === 0 && (Bt.endEmitted = !0, Rt.readable = !1, Rt.emit("end"));
  }
  function Nt(Bt, Rt) {
    for (var Ut = 0, zt = Bt.length; Ut < zt; Ut++)
      if (Bt[Ut] === Rt) return Ut;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = K;
  var B = require_stream_duplex(), L = Object.create(requireUtil());
  L.inherits = requireInherits_browser(), L.inherits(K, B);
  function W(re, ie) {
    var oe = this._transformState;
    oe.transforming = !1;
    var pe = oe.writecb;
    if (!pe)
      return this.emit("error", new Error("write callback called multiple times"));
    oe.writechunk = null, oe.writecb = null, ie != null && this.push(ie), pe(re);
    var ne = this._readableState;
    ne.reading = !1, (ne.needReadable || ne.length < ne.highWaterMark) && this._read(ne.highWaterMark);
  }
  function K(re) {
    if (!(this instanceof K)) return new K(re);
    B.call(this, re), this._transformState = {
      afterTransform: W.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, re && (typeof re.transform == "function" && (this._transform = re.transform), typeof re.flush == "function" && (this._flush = re.flush)), this.on("prefinish", J);
  }
  function J() {
    var re = this;
    typeof this._flush == "function" ? this._flush(function(ie, oe) {
      V(re, ie, oe);
    }) : V(this, null, null);
  }
  K.prototype.push = function(re, ie) {
    return this._transformState.needTransform = !1, B.prototype.push.call(this, re, ie);
  }, K.prototype._transform = function(re, ie, oe) {
    throw new Error("_transform() is not implemented");
  }, K.prototype._write = function(re, ie, oe) {
    var pe = this._transformState;
    if (pe.writecb = oe, pe.writechunk = re, pe.writeencoding = ie, !pe.transforming) {
      var ne = this._readableState;
      (pe.needTransform || ne.needReadable || ne.length < ne.highWaterMark) && this._read(ne.highWaterMark);
    }
  }, K.prototype._read = function(re) {
    var ie = this._transformState;
    ie.writechunk !== null && ie.writecb && !ie.transforming ? (ie.transforming = !0, this._transform(ie.writechunk, ie.writeencoding, ie.afterTransform)) : ie.needTransform = !0;
  }, K.prototype._destroy = function(re, ie) {
    var oe = this;
    B.prototype._destroy.call(this, re, function(pe) {
      ie(pe), oe.emit("close");
    });
  };
  function V(re, ie, oe) {
    if (ie) return re.emit("error", ie);
    if (oe != null && re.push(oe), re._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (re._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return re.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = W;
  var B = require_stream_transform(), L = Object.create(requireUtil());
  L.inherits = requireInherits_browser(), L.inherits(W, B);
  function W(K) {
    if (!(this instanceof W)) return new W(K);
    B.call(this, K);
  }
  return W.prototype._transform = function(K, J, V) {
    V(null, K);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(B, L) {
    L = B.exports = require_stream_readable(), L.Stream = L, L.Readable = L, L.Writable = require_stream_writable(), L.Duplex = require_stream_duplex(), L.Transform = require_stream_transform(), L.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign$1 = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(B) {
    (function(L, W) {
      function K(it, ke) {
        if (!it) throw new Error(ke || "Assertion failed");
      }
      function J(it, ke) {
        it.super_ = ke;
        var rt = function() {
        };
        rt.prototype = ke.prototype, it.prototype = new rt(), it.prototype.constructor = it;
      }
      function V(it, ke, rt) {
        if (V.isBN(it))
          return it;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, it !== null && ((ke === "le" || ke === "be") && (rt = ke, ke = 10), this._init(it || 0, ke || 10, rt || "be"));
      }
      typeof L == "object" ? L.exports = V : W.BN = V, V.BN = V, V.wordSize = 26;
      var re;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? re = window.Buffer : re = require$$1$2.Buffer;
      } catch {
      }
      V.isBN = function(ke) {
        return ke instanceof V ? !0 : ke !== null && typeof ke == "object" && ke.constructor.wordSize === V.wordSize && Array.isArray(ke.words);
      }, V.max = function(ke, rt) {
        return ke.cmp(rt) > 0 ? ke : rt;
      }, V.min = function(ke, rt) {
        return ke.cmp(rt) < 0 ? ke : rt;
      }, V.prototype._init = function(ke, rt, ot) {
        if (typeof ke == "number")
          return this._initNumber(ke, rt, ot);
        if (typeof ke == "object")
          return this._initArray(ke, rt, ot);
        rt === "hex" && (rt = 16), K(rt === (rt | 0) && rt >= 2 && rt <= 36), ke = ke.toString().replace(/\s+/g, "");
        var ft = 0;
        ke[0] === "-" && (ft++, this.negative = 1), ft < ke.length && (rt === 16 ? this._parseHex(ke, ft, ot) : (this._parseBase(ke, rt, ft), ot === "le" && this._initArray(this.toArray(), rt, ot)));
      }, V.prototype._initNumber = function(ke, rt, ot) {
        ke < 0 && (this.negative = 1, ke = -ke), ke < 67108864 ? (this.words = [ke & 67108863], this.length = 1) : ke < 4503599627370496 ? (this.words = [
          ke & 67108863,
          ke / 67108864 & 67108863
        ], this.length = 2) : (K(ke < 9007199254740992), this.words = [
          ke & 67108863,
          ke / 67108864 & 67108863,
          1
        ], this.length = 3), ot === "le" && this._initArray(this.toArray(), rt, ot);
      }, V.prototype._initArray = function(ke, rt, ot) {
        if (K(typeof ke.length == "number"), ke.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(ke.length / 3), this.words = new Array(this.length);
        for (var ft = 0; ft < this.length; ft++)
          this.words[ft] = 0;
        var ct, bt, ut = 0;
        if (ot === "be")
          for (ft = ke.length - 1, ct = 0; ft >= 0; ft -= 3)
            bt = ke[ft] | ke[ft - 1] << 8 | ke[ft - 2] << 16, this.words[ct] |= bt << ut & 67108863, this.words[ct + 1] = bt >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ct++);
        else if (ot === "le")
          for (ft = 0, ct = 0; ft < ke.length; ft += 3)
            bt = ke[ft] | ke[ft + 1] << 8 | ke[ft + 2] << 16, this.words[ct] |= bt << ut & 67108863, this.words[ct + 1] = bt >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ct++);
        return this._strip();
      };
      function ie(it, ke) {
        var rt = it.charCodeAt(ke);
        if (rt >= 48 && rt <= 57)
          return rt - 48;
        if (rt >= 65 && rt <= 70)
          return rt - 55;
        if (rt >= 97 && rt <= 102)
          return rt - 87;
        K(!1, "Invalid character in " + it);
      }
      function oe(it, ke, rt) {
        var ot = ie(it, rt);
        return rt - 1 >= ke && (ot |= ie(it, rt - 1) << 4), ot;
      }
      V.prototype._parseHex = function(ke, rt, ot) {
        this.length = Math.ceil((ke.length - rt) / 6), this.words = new Array(this.length);
        for (var ft = 0; ft < this.length; ft++)
          this.words[ft] = 0;
        var ct = 0, bt = 0, ut;
        if (ot === "be")
          for (ft = ke.length - 1; ft >= rt; ft -= 2)
            ut = oe(ke, rt, ft) << ct, this.words[bt] |= ut & 67108863, ct >= 18 ? (ct -= 18, bt += 1, this.words[bt] |= ut >>> 26) : ct += 8;
        else {
          var gt = ke.length - rt;
          for (ft = gt % 2 === 0 ? rt + 1 : rt; ft < ke.length; ft += 2)
            ut = oe(ke, rt, ft) << ct, this.words[bt] |= ut & 67108863, ct >= 18 ? (ct -= 18, bt += 1, this.words[bt] |= ut >>> 26) : ct += 8;
        }
        this._strip();
      };
      function pe(it, ke, rt, ot) {
        for (var ft = 0, ct = 0, bt = Math.min(it.length, rt), ut = ke; ut < bt; ut++) {
          var gt = it.charCodeAt(ut) - 48;
          ft *= ot, gt >= 49 ? ct = gt - 49 + 10 : gt >= 17 ? ct = gt - 17 + 10 : ct = gt, K(gt >= 0 && ct < ot, "Invalid character"), ft += ct;
        }
        return ft;
      }
      V.prototype._parseBase = function(ke, rt, ot) {
        this.words = [0], this.length = 1;
        for (var ft = 0, ct = 1; ct <= 67108863; ct *= rt)
          ft++;
        ft--, ct = ct / rt | 0;
        for (var bt = ke.length - ot, ut = bt % ft, gt = Math.min(bt, bt - ut) + ot, dt = 0, wt = ot; wt < gt; wt += ft)
          dt = pe(ke, wt, wt + ft, rt), this.imuln(ct), this.words[0] + dt < 67108864 ? this.words[0] += dt : this._iaddn(dt);
        if (ut !== 0) {
          var Ft = 1;
          for (dt = pe(ke, wt, ke.length, rt), wt = 0; wt < ut; wt++)
            Ft *= rt;
          this.imuln(Ft), this.words[0] + dt < 67108864 ? this.words[0] += dt : this._iaddn(dt);
        }
        this._strip();
      }, V.prototype.copy = function(ke) {
        ke.words = new Array(this.length);
        for (var rt = 0; rt < this.length; rt++)
          ke.words[rt] = this.words[rt];
        ke.length = this.length, ke.negative = this.negative, ke.red = this.red;
      };
      function ne(it, ke) {
        it.words = ke.words, it.length = ke.length, it.negative = ke.negative, it.red = ke.red;
      }
      if (V.prototype._move = function(ke) {
        ne(ke, this);
      }, V.prototype.clone = function() {
        var ke = new V(null);
        return this.copy(ke), ke;
      }, V.prototype._expand = function(ke) {
        for (; this.length < ke; )
          this.words[this.length++] = 0;
        return this;
      }, V.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, V.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          V.prototype[Symbol.for("nodejs.util.inspect.custom")] = ce;
        } catch {
          V.prototype.inspect = ce;
        }
      else
        V.prototype.inspect = ce;
      function ce() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Ce = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Oe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], st = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      V.prototype.toString = function(ke, rt) {
        ke = ke || 10, rt = rt | 0 || 1;
        var ot;
        if (ke === 16 || ke === "hex") {
          ot = "";
          for (var ft = 0, ct = 0, bt = 0; bt < this.length; bt++) {
            var ut = this.words[bt], gt = ((ut << ft | ct) & 16777215).toString(16);
            ct = ut >>> 24 - ft & 16777215, ft += 2, ft >= 26 && (ft -= 26, bt--), ct !== 0 || bt !== this.length - 1 ? ot = Ce[6 - gt.length] + gt + ot : ot = gt + ot;
          }
          for (ct !== 0 && (ot = ct.toString(16) + ot); ot.length % rt !== 0; )
            ot = "0" + ot;
          return this.negative !== 0 && (ot = "-" + ot), ot;
        }
        if (ke === (ke | 0) && ke >= 2 && ke <= 36) {
          var dt = Oe[ke], wt = st[ke];
          ot = "";
          var Ft = this.clone();
          for (Ft.negative = 0; !Ft.isZero(); ) {
            var jt = Ft.modrn(wt).toString(ke);
            Ft = Ft.idivn(wt), Ft.isZero() ? ot = jt + ot : ot = Ce[dt - jt.length] + jt + ot;
          }
          for (this.isZero() && (ot = "0" + ot); ot.length % rt !== 0; )
            ot = "0" + ot;
          return this.negative !== 0 && (ot = "-" + ot), ot;
        }
        K(!1, "Base should be between 2 and 36");
      }, V.prototype.toNumber = function() {
        var ke = this.words[0];
        return this.length === 2 ? ke += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ke += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ke : ke;
      }, V.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, re && (V.prototype.toBuffer = function(ke, rt) {
        return this.toArrayLike(re, ke, rt);
      }), V.prototype.toArray = function(ke, rt) {
        return this.toArrayLike(Array, ke, rt);
      };
      var at = function(ke, rt) {
        return ke.allocUnsafe ? ke.allocUnsafe(rt) : new ke(rt);
      };
      V.prototype.toArrayLike = function(ke, rt, ot) {
        this._strip();
        var ft = this.byteLength(), ct = ot || Math.max(1, ft);
        K(ft <= ct, "byte array longer than desired length"), K(ct > 0, "Requested array length <= 0");
        var bt = at(ke, ct), ut = rt === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ut](bt, ft), bt;
      }, V.prototype._toArrayLikeLE = function(ke, rt) {
        for (var ot = 0, ft = 0, ct = 0, bt = 0; ct < this.length; ct++) {
          var ut = this.words[ct] << bt | ft;
          ke[ot++] = ut & 255, ot < ke.length && (ke[ot++] = ut >> 8 & 255), ot < ke.length && (ke[ot++] = ut >> 16 & 255), bt === 6 ? (ot < ke.length && (ke[ot++] = ut >> 24 & 255), ft = 0, bt = 0) : (ft = ut >>> 24, bt += 2);
        }
        if (ot < ke.length)
          for (ke[ot++] = ft; ot < ke.length; )
            ke[ot++] = 0;
      }, V.prototype._toArrayLikeBE = function(ke, rt) {
        for (var ot = ke.length - 1, ft = 0, ct = 0, bt = 0; ct < this.length; ct++) {
          var ut = this.words[ct] << bt | ft;
          ke[ot--] = ut & 255, ot >= 0 && (ke[ot--] = ut >> 8 & 255), ot >= 0 && (ke[ot--] = ut >> 16 & 255), bt === 6 ? (ot >= 0 && (ke[ot--] = ut >> 24 & 255), ft = 0, bt = 0) : (ft = ut >>> 24, bt += 2);
        }
        if (ot >= 0)
          for (ke[ot--] = ft; ot >= 0; )
            ke[ot--] = 0;
      }, Math.clz32 ? V.prototype._countBits = function(ke) {
        return 32 - Math.clz32(ke);
      } : V.prototype._countBits = function(ke) {
        var rt = ke, ot = 0;
        return rt >= 4096 && (ot += 13, rt >>>= 13), rt >= 64 && (ot += 7, rt >>>= 7), rt >= 8 && (ot += 4, rt >>>= 4), rt >= 2 && (ot += 2, rt >>>= 2), ot + rt;
      }, V.prototype._zeroBits = function(ke) {
        if (ke === 0) return 26;
        var rt = ke, ot = 0;
        return rt & 8191 || (ot += 13, rt >>>= 13), rt & 127 || (ot += 7, rt >>>= 7), rt & 15 || (ot += 4, rt >>>= 4), rt & 3 || (ot += 2, rt >>>= 2), rt & 1 || ot++, ot;
      }, V.prototype.bitLength = function() {
        var ke = this.words[this.length - 1], rt = this._countBits(ke);
        return (this.length - 1) * 26 + rt;
      };
      function lt(it) {
        for (var ke = new Array(it.bitLength()), rt = 0; rt < ke.length; rt++) {
          var ot = rt / 26 | 0, ft = rt % 26;
          ke[rt] = it.words[ot] >>> ft & 1;
        }
        return ke;
      }
      V.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var ke = 0, rt = 0; rt < this.length; rt++) {
          var ot = this._zeroBits(this.words[rt]);
          if (ke += ot, ot !== 26) break;
        }
        return ke;
      }, V.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, V.prototype.toTwos = function(ke) {
        return this.negative !== 0 ? this.abs().inotn(ke).iaddn(1) : this.clone();
      }, V.prototype.fromTwos = function(ke) {
        return this.testn(ke - 1) ? this.notn(ke).iaddn(1).ineg() : this.clone();
      }, V.prototype.isNeg = function() {
        return this.negative !== 0;
      }, V.prototype.neg = function() {
        return this.clone().ineg();
      }, V.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, V.prototype.iuor = function(ke) {
        for (; this.length < ke.length; )
          this.words[this.length++] = 0;
        for (var rt = 0; rt < ke.length; rt++)
          this.words[rt] = this.words[rt] | ke.words[rt];
        return this._strip();
      }, V.prototype.ior = function(ke) {
        return K((this.negative | ke.negative) === 0), this.iuor(ke);
      }, V.prototype.or = function(ke) {
        return this.length > ke.length ? this.clone().ior(ke) : ke.clone().ior(this);
      }, V.prototype.uor = function(ke) {
        return this.length > ke.length ? this.clone().iuor(ke) : ke.clone().iuor(this);
      }, V.prototype.iuand = function(ke) {
        var rt;
        this.length > ke.length ? rt = ke : rt = this;
        for (var ot = 0; ot < rt.length; ot++)
          this.words[ot] = this.words[ot] & ke.words[ot];
        return this.length = rt.length, this._strip();
      }, V.prototype.iand = function(ke) {
        return K((this.negative | ke.negative) === 0), this.iuand(ke);
      }, V.prototype.and = function(ke) {
        return this.length > ke.length ? this.clone().iand(ke) : ke.clone().iand(this);
      }, V.prototype.uand = function(ke) {
        return this.length > ke.length ? this.clone().iuand(ke) : ke.clone().iuand(this);
      }, V.prototype.iuxor = function(ke) {
        var rt, ot;
        this.length > ke.length ? (rt = this, ot = ke) : (rt = ke, ot = this);
        for (var ft = 0; ft < ot.length; ft++)
          this.words[ft] = rt.words[ft] ^ ot.words[ft];
        if (this !== rt)
          for (; ft < rt.length; ft++)
            this.words[ft] = rt.words[ft];
        return this.length = rt.length, this._strip();
      }, V.prototype.ixor = function(ke) {
        return K((this.negative | ke.negative) === 0), this.iuxor(ke);
      }, V.prototype.xor = function(ke) {
        return this.length > ke.length ? this.clone().ixor(ke) : ke.clone().ixor(this);
      }, V.prototype.uxor = function(ke) {
        return this.length > ke.length ? this.clone().iuxor(ke) : ke.clone().iuxor(this);
      }, V.prototype.inotn = function(ke) {
        K(typeof ke == "number" && ke >= 0);
        var rt = Math.ceil(ke / 26) | 0, ot = ke % 26;
        this._expand(rt), ot > 0 && rt--;
        for (var ft = 0; ft < rt; ft++)
          this.words[ft] = ~this.words[ft] & 67108863;
        return ot > 0 && (this.words[ft] = ~this.words[ft] & 67108863 >> 26 - ot), this._strip();
      }, V.prototype.notn = function(ke) {
        return this.clone().inotn(ke);
      }, V.prototype.setn = function(ke, rt) {
        K(typeof ke == "number" && ke >= 0);
        var ot = ke / 26 | 0, ft = ke % 26;
        return this._expand(ot + 1), rt ? this.words[ot] = this.words[ot] | 1 << ft : this.words[ot] = this.words[ot] & ~(1 << ft), this._strip();
      }, V.prototype.iadd = function(ke) {
        var rt;
        if (this.negative !== 0 && ke.negative === 0)
          return this.negative = 0, rt = this.isub(ke), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && ke.negative !== 0)
          return ke.negative = 0, rt = this.isub(ke), ke.negative = 1, rt._normSign();
        var ot, ft;
        this.length > ke.length ? (ot = this, ft = ke) : (ot = ke, ft = this);
        for (var ct = 0, bt = 0; bt < ft.length; bt++)
          rt = (ot.words[bt] | 0) + (ft.words[bt] | 0) + ct, this.words[bt] = rt & 67108863, ct = rt >>> 26;
        for (; ct !== 0 && bt < ot.length; bt++)
          rt = (ot.words[bt] | 0) + ct, this.words[bt] = rt & 67108863, ct = rt >>> 26;
        if (this.length = ot.length, ct !== 0)
          this.words[this.length] = ct, this.length++;
        else if (ot !== this)
          for (; bt < ot.length; bt++)
            this.words[bt] = ot.words[bt];
        return this;
      }, V.prototype.add = function(ke) {
        var rt;
        return ke.negative !== 0 && this.negative === 0 ? (ke.negative = 0, rt = this.sub(ke), ke.negative ^= 1, rt) : ke.negative === 0 && this.negative !== 0 ? (this.negative = 0, rt = ke.sub(this), this.negative = 1, rt) : this.length > ke.length ? this.clone().iadd(ke) : ke.clone().iadd(this);
      }, V.prototype.isub = function(ke) {
        if (ke.negative !== 0) {
          ke.negative = 0;
          var rt = this.iadd(ke);
          return ke.negative = 1, rt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(ke), this.negative = 1, this._normSign();
        var ot = this.cmp(ke);
        if (ot === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var ft, ct;
        ot > 0 ? (ft = this, ct = ke) : (ft = ke, ct = this);
        for (var bt = 0, ut = 0; ut < ct.length; ut++)
          rt = (ft.words[ut] | 0) - (ct.words[ut] | 0) + bt, bt = rt >> 26, this.words[ut] = rt & 67108863;
        for (; bt !== 0 && ut < ft.length; ut++)
          rt = (ft.words[ut] | 0) + bt, bt = rt >> 26, this.words[ut] = rt & 67108863;
        if (bt === 0 && ut < ft.length && ft !== this)
          for (; ut < ft.length; ut++)
            this.words[ut] = ft.words[ut];
        return this.length = Math.max(this.length, ut), ft !== this && (this.negative = 1), this._strip();
      }, V.prototype.sub = function(ke) {
        return this.clone().isub(ke);
      };
      function pt(it, ke, rt) {
        rt.negative = ke.negative ^ it.negative;
        var ot = it.length + ke.length | 0;
        rt.length = ot, ot = ot - 1 | 0;
        var ft = it.words[0] | 0, ct = ke.words[0] | 0, bt = ft * ct, ut = bt & 67108863, gt = bt / 67108864 | 0;
        rt.words[0] = ut;
        for (var dt = 1; dt < ot; dt++) {
          for (var wt = gt >>> 26, Ft = gt & 67108863, jt = Math.min(dt, ke.length - 1), Nt = Math.max(0, dt - it.length + 1); Nt <= jt; Nt++) {
            var Bt = dt - Nt | 0;
            ft = it.words[Bt] | 0, ct = ke.words[Nt] | 0, bt = ft * ct + Ft, wt += bt / 67108864 | 0, Ft = bt & 67108863;
          }
          rt.words[dt] = Ft | 0, gt = wt | 0;
        }
        return gt !== 0 ? rt.words[dt] = gt | 0 : rt.length--, rt._strip();
      }
      var ht = function(ke, rt, ot) {
        var ft = ke.words, ct = rt.words, bt = ot.words, ut = 0, gt, dt, wt, Ft = ft[0] | 0, jt = Ft & 8191, Nt = Ft >>> 13, Bt = ft[1] | 0, Rt = Bt & 8191, Ut = Bt >>> 13, zt = ft[2] | 0, Mt = zt & 8191, kt = zt >>> 13, Gt = ft[3] | 0, Qt = Gt & 8191, nr = Gt >>> 13, ar = ft[4] | 0, cr = ar & 8191, hr = ar >>> 13, Jt = ft[5] | 0, Pr = Jt & 8191, dr = Jt >>> 13, Tr = ft[6] | 0, Rr = Tr & 8191, pr = Tr >>> 13, $r = ft[7] | 0, kr = $r & 8191, vr = $r >>> 13, Mr = ft[8] | 0, Nr = Mr & 8191, Pt = Mr >>> 13, mt = ft[9] | 0, At = mt & 8191, qt = mt >>> 13, Kt = ct[0] | 0, Vt = Kt & 8191, Xt = Kt >>> 13, yr = ct[1] | 0, Ar = yr & 8191, lr = yr >>> 13, xr = ct[2] | 0, wr = xr & 8191, Sr = xr >>> 13, Or = ct[3] | 0, qr = Or & 8191, Dt = Or >>> 13, Ot = ct[4] | 0, Ht = Ot & 8191, Wt = Ot >>> 13, Yt = ct[5] | 0, er = Yt & 8191, rr = Yt >>> 13, ir = ct[6] | 0, ur = ir & 8191, sr = ir >>> 13, br = ct[7] | 0, _r = br & 8191, or = br >>> 13, Lt = ct[8] | 0, Zt = Lt & 8191, tr = Lt >>> 13, fr = ct[9] | 0, gr = fr & 8191, Er = fr >>> 13;
        ot.negative = ke.negative ^ rt.negative, ot.length = 19, gt = Math.imul(jt, Vt), dt = Math.imul(jt, Xt), dt = dt + Math.imul(Nt, Vt) | 0, wt = Math.imul(Nt, Xt);
        var Ir = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, gt = Math.imul(Rt, Vt), dt = Math.imul(Rt, Xt), dt = dt + Math.imul(Ut, Vt) | 0, wt = Math.imul(Ut, Xt), gt = gt + Math.imul(jt, Ar) | 0, dt = dt + Math.imul(jt, lr) | 0, dt = dt + Math.imul(Nt, Ar) | 0, wt = wt + Math.imul(Nt, lr) | 0;
        var Br = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, gt = Math.imul(Mt, Vt), dt = Math.imul(Mt, Xt), dt = dt + Math.imul(kt, Vt) | 0, wt = Math.imul(kt, Xt), gt = gt + Math.imul(Rt, Ar) | 0, dt = dt + Math.imul(Rt, lr) | 0, dt = dt + Math.imul(Ut, Ar) | 0, wt = wt + Math.imul(Ut, lr) | 0, gt = gt + Math.imul(jt, wr) | 0, dt = dt + Math.imul(jt, Sr) | 0, dt = dt + Math.imul(Nt, wr) | 0, wt = wt + Math.imul(Nt, Sr) | 0;
        var Ur = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, gt = Math.imul(Qt, Vt), dt = Math.imul(Qt, Xt), dt = dt + Math.imul(nr, Vt) | 0, wt = Math.imul(nr, Xt), gt = gt + Math.imul(Mt, Ar) | 0, dt = dt + Math.imul(Mt, lr) | 0, dt = dt + Math.imul(kt, Ar) | 0, wt = wt + Math.imul(kt, lr) | 0, gt = gt + Math.imul(Rt, wr) | 0, dt = dt + Math.imul(Rt, Sr) | 0, dt = dt + Math.imul(Ut, wr) | 0, wt = wt + Math.imul(Ut, Sr) | 0, gt = gt + Math.imul(jt, qr) | 0, dt = dt + Math.imul(jt, Dt) | 0, dt = dt + Math.imul(Nt, qr) | 0, wt = wt + Math.imul(Nt, Dt) | 0;
        var Fr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, gt = Math.imul(cr, Vt), dt = Math.imul(cr, Xt), dt = dt + Math.imul(hr, Vt) | 0, wt = Math.imul(hr, Xt), gt = gt + Math.imul(Qt, Ar) | 0, dt = dt + Math.imul(Qt, lr) | 0, dt = dt + Math.imul(nr, Ar) | 0, wt = wt + Math.imul(nr, lr) | 0, gt = gt + Math.imul(Mt, wr) | 0, dt = dt + Math.imul(Mt, Sr) | 0, dt = dt + Math.imul(kt, wr) | 0, wt = wt + Math.imul(kt, Sr) | 0, gt = gt + Math.imul(Rt, qr) | 0, dt = dt + Math.imul(Rt, Dt) | 0, dt = dt + Math.imul(Ut, qr) | 0, wt = wt + Math.imul(Ut, Dt) | 0, gt = gt + Math.imul(jt, Ht) | 0, dt = dt + Math.imul(jt, Wt) | 0, dt = dt + Math.imul(Nt, Ht) | 0, wt = wt + Math.imul(Nt, Wt) | 0;
        var Dr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, gt = Math.imul(Pr, Vt), dt = Math.imul(Pr, Xt), dt = dt + Math.imul(dr, Vt) | 0, wt = Math.imul(dr, Xt), gt = gt + Math.imul(cr, Ar) | 0, dt = dt + Math.imul(cr, lr) | 0, dt = dt + Math.imul(hr, Ar) | 0, wt = wt + Math.imul(hr, lr) | 0, gt = gt + Math.imul(Qt, wr) | 0, dt = dt + Math.imul(Qt, Sr) | 0, dt = dt + Math.imul(nr, wr) | 0, wt = wt + Math.imul(nr, Sr) | 0, gt = gt + Math.imul(Mt, qr) | 0, dt = dt + Math.imul(Mt, Dt) | 0, dt = dt + Math.imul(kt, qr) | 0, wt = wt + Math.imul(kt, Dt) | 0, gt = gt + Math.imul(Rt, Ht) | 0, dt = dt + Math.imul(Rt, Wt) | 0, dt = dt + Math.imul(Ut, Ht) | 0, wt = wt + Math.imul(Ut, Wt) | 0, gt = gt + Math.imul(jt, er) | 0, dt = dt + Math.imul(jt, rr) | 0, dt = dt + Math.imul(Nt, er) | 0, wt = wt + Math.imul(Nt, rr) | 0;
        var Hr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, gt = Math.imul(Rr, Vt), dt = Math.imul(Rr, Xt), dt = dt + Math.imul(pr, Vt) | 0, wt = Math.imul(pr, Xt), gt = gt + Math.imul(Pr, Ar) | 0, dt = dt + Math.imul(Pr, lr) | 0, dt = dt + Math.imul(dr, Ar) | 0, wt = wt + Math.imul(dr, lr) | 0, gt = gt + Math.imul(cr, wr) | 0, dt = dt + Math.imul(cr, Sr) | 0, dt = dt + Math.imul(hr, wr) | 0, wt = wt + Math.imul(hr, Sr) | 0, gt = gt + Math.imul(Qt, qr) | 0, dt = dt + Math.imul(Qt, Dt) | 0, dt = dt + Math.imul(nr, qr) | 0, wt = wt + Math.imul(nr, Dt) | 0, gt = gt + Math.imul(Mt, Ht) | 0, dt = dt + Math.imul(Mt, Wt) | 0, dt = dt + Math.imul(kt, Ht) | 0, wt = wt + Math.imul(kt, Wt) | 0, gt = gt + Math.imul(Rt, er) | 0, dt = dt + Math.imul(Rt, rr) | 0, dt = dt + Math.imul(Ut, er) | 0, wt = wt + Math.imul(Ut, rr) | 0, gt = gt + Math.imul(jt, ur) | 0, dt = dt + Math.imul(jt, sr) | 0, dt = dt + Math.imul(Nt, ur) | 0, wt = wt + Math.imul(Nt, sr) | 0;
        var Wr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, gt = Math.imul(kr, Vt), dt = Math.imul(kr, Xt), dt = dt + Math.imul(vr, Vt) | 0, wt = Math.imul(vr, Xt), gt = gt + Math.imul(Rr, Ar) | 0, dt = dt + Math.imul(Rr, lr) | 0, dt = dt + Math.imul(pr, Ar) | 0, wt = wt + Math.imul(pr, lr) | 0, gt = gt + Math.imul(Pr, wr) | 0, dt = dt + Math.imul(Pr, Sr) | 0, dt = dt + Math.imul(dr, wr) | 0, wt = wt + Math.imul(dr, Sr) | 0, gt = gt + Math.imul(cr, qr) | 0, dt = dt + Math.imul(cr, Dt) | 0, dt = dt + Math.imul(hr, qr) | 0, wt = wt + Math.imul(hr, Dt) | 0, gt = gt + Math.imul(Qt, Ht) | 0, dt = dt + Math.imul(Qt, Wt) | 0, dt = dt + Math.imul(nr, Ht) | 0, wt = wt + Math.imul(nr, Wt) | 0, gt = gt + Math.imul(Mt, er) | 0, dt = dt + Math.imul(Mt, rr) | 0, dt = dt + Math.imul(kt, er) | 0, wt = wt + Math.imul(kt, rr) | 0, gt = gt + Math.imul(Rt, ur) | 0, dt = dt + Math.imul(Rt, sr) | 0, dt = dt + Math.imul(Ut, ur) | 0, wt = wt + Math.imul(Ut, sr) | 0, gt = gt + Math.imul(jt, _r) | 0, dt = dt + Math.imul(jt, or) | 0, dt = dt + Math.imul(Nt, _r) | 0, wt = wt + Math.imul(Nt, or) | 0;
        var jr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, gt = Math.imul(Nr, Vt), dt = Math.imul(Nr, Xt), dt = dt + Math.imul(Pt, Vt) | 0, wt = Math.imul(Pt, Xt), gt = gt + Math.imul(kr, Ar) | 0, dt = dt + Math.imul(kr, lr) | 0, dt = dt + Math.imul(vr, Ar) | 0, wt = wt + Math.imul(vr, lr) | 0, gt = gt + Math.imul(Rr, wr) | 0, dt = dt + Math.imul(Rr, Sr) | 0, dt = dt + Math.imul(pr, wr) | 0, wt = wt + Math.imul(pr, Sr) | 0, gt = gt + Math.imul(Pr, qr) | 0, dt = dt + Math.imul(Pr, Dt) | 0, dt = dt + Math.imul(dr, qr) | 0, wt = wt + Math.imul(dr, Dt) | 0, gt = gt + Math.imul(cr, Ht) | 0, dt = dt + Math.imul(cr, Wt) | 0, dt = dt + Math.imul(hr, Ht) | 0, wt = wt + Math.imul(hr, Wt) | 0, gt = gt + Math.imul(Qt, er) | 0, dt = dt + Math.imul(Qt, rr) | 0, dt = dt + Math.imul(nr, er) | 0, wt = wt + Math.imul(nr, rr) | 0, gt = gt + Math.imul(Mt, ur) | 0, dt = dt + Math.imul(Mt, sr) | 0, dt = dt + Math.imul(kt, ur) | 0, wt = wt + Math.imul(kt, sr) | 0, gt = gt + Math.imul(Rt, _r) | 0, dt = dt + Math.imul(Rt, or) | 0, dt = dt + Math.imul(Ut, _r) | 0, wt = wt + Math.imul(Ut, or) | 0, gt = gt + Math.imul(jt, Zt) | 0, dt = dt + Math.imul(jt, tr) | 0, dt = dt + Math.imul(Nt, Zt) | 0, wt = wt + Math.imul(Nt, tr) | 0;
        var Lr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, gt = Math.imul(At, Vt), dt = Math.imul(At, Xt), dt = dt + Math.imul(qt, Vt) | 0, wt = Math.imul(qt, Xt), gt = gt + Math.imul(Nr, Ar) | 0, dt = dt + Math.imul(Nr, lr) | 0, dt = dt + Math.imul(Pt, Ar) | 0, wt = wt + Math.imul(Pt, lr) | 0, gt = gt + Math.imul(kr, wr) | 0, dt = dt + Math.imul(kr, Sr) | 0, dt = dt + Math.imul(vr, wr) | 0, wt = wt + Math.imul(vr, Sr) | 0, gt = gt + Math.imul(Rr, qr) | 0, dt = dt + Math.imul(Rr, Dt) | 0, dt = dt + Math.imul(pr, qr) | 0, wt = wt + Math.imul(pr, Dt) | 0, gt = gt + Math.imul(Pr, Ht) | 0, dt = dt + Math.imul(Pr, Wt) | 0, dt = dt + Math.imul(dr, Ht) | 0, wt = wt + Math.imul(dr, Wt) | 0, gt = gt + Math.imul(cr, er) | 0, dt = dt + Math.imul(cr, rr) | 0, dt = dt + Math.imul(hr, er) | 0, wt = wt + Math.imul(hr, rr) | 0, gt = gt + Math.imul(Qt, ur) | 0, dt = dt + Math.imul(Qt, sr) | 0, dt = dt + Math.imul(nr, ur) | 0, wt = wt + Math.imul(nr, sr) | 0, gt = gt + Math.imul(Mt, _r) | 0, dt = dt + Math.imul(Mt, or) | 0, dt = dt + Math.imul(kt, _r) | 0, wt = wt + Math.imul(kt, or) | 0, gt = gt + Math.imul(Rt, Zt) | 0, dt = dt + Math.imul(Rt, tr) | 0, dt = dt + Math.imul(Ut, Zt) | 0, wt = wt + Math.imul(Ut, tr) | 0, gt = gt + Math.imul(jt, gr) | 0, dt = dt + Math.imul(jt, Er) | 0, dt = dt + Math.imul(Nt, gr) | 0, wt = wt + Math.imul(Nt, Er) | 0;
        var Gr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, gt = Math.imul(At, Ar), dt = Math.imul(At, lr), dt = dt + Math.imul(qt, Ar) | 0, wt = Math.imul(qt, lr), gt = gt + Math.imul(Nr, wr) | 0, dt = dt + Math.imul(Nr, Sr) | 0, dt = dt + Math.imul(Pt, wr) | 0, wt = wt + Math.imul(Pt, Sr) | 0, gt = gt + Math.imul(kr, qr) | 0, dt = dt + Math.imul(kr, Dt) | 0, dt = dt + Math.imul(vr, qr) | 0, wt = wt + Math.imul(vr, Dt) | 0, gt = gt + Math.imul(Rr, Ht) | 0, dt = dt + Math.imul(Rr, Wt) | 0, dt = dt + Math.imul(pr, Ht) | 0, wt = wt + Math.imul(pr, Wt) | 0, gt = gt + Math.imul(Pr, er) | 0, dt = dt + Math.imul(Pr, rr) | 0, dt = dt + Math.imul(dr, er) | 0, wt = wt + Math.imul(dr, rr) | 0, gt = gt + Math.imul(cr, ur) | 0, dt = dt + Math.imul(cr, sr) | 0, dt = dt + Math.imul(hr, ur) | 0, wt = wt + Math.imul(hr, sr) | 0, gt = gt + Math.imul(Qt, _r) | 0, dt = dt + Math.imul(Qt, or) | 0, dt = dt + Math.imul(nr, _r) | 0, wt = wt + Math.imul(nr, or) | 0, gt = gt + Math.imul(Mt, Zt) | 0, dt = dt + Math.imul(Mt, tr) | 0, dt = dt + Math.imul(kt, Zt) | 0, wt = wt + Math.imul(kt, tr) | 0, gt = gt + Math.imul(Rt, gr) | 0, dt = dt + Math.imul(Rt, Er) | 0, dt = dt + Math.imul(Ut, gr) | 0, wt = wt + Math.imul(Ut, Er) | 0;
        var zr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, gt = Math.imul(At, wr), dt = Math.imul(At, Sr), dt = dt + Math.imul(qt, wr) | 0, wt = Math.imul(qt, Sr), gt = gt + Math.imul(Nr, qr) | 0, dt = dt + Math.imul(Nr, Dt) | 0, dt = dt + Math.imul(Pt, qr) | 0, wt = wt + Math.imul(Pt, Dt) | 0, gt = gt + Math.imul(kr, Ht) | 0, dt = dt + Math.imul(kr, Wt) | 0, dt = dt + Math.imul(vr, Ht) | 0, wt = wt + Math.imul(vr, Wt) | 0, gt = gt + Math.imul(Rr, er) | 0, dt = dt + Math.imul(Rr, rr) | 0, dt = dt + Math.imul(pr, er) | 0, wt = wt + Math.imul(pr, rr) | 0, gt = gt + Math.imul(Pr, ur) | 0, dt = dt + Math.imul(Pr, sr) | 0, dt = dt + Math.imul(dr, ur) | 0, wt = wt + Math.imul(dr, sr) | 0, gt = gt + Math.imul(cr, _r) | 0, dt = dt + Math.imul(cr, or) | 0, dt = dt + Math.imul(hr, _r) | 0, wt = wt + Math.imul(hr, or) | 0, gt = gt + Math.imul(Qt, Zt) | 0, dt = dt + Math.imul(Qt, tr) | 0, dt = dt + Math.imul(nr, Zt) | 0, wt = wt + Math.imul(nr, tr) | 0, gt = gt + Math.imul(Mt, gr) | 0, dt = dt + Math.imul(Mt, Er) | 0, dt = dt + Math.imul(kt, gr) | 0, wt = wt + Math.imul(kt, Er) | 0;
        var Vr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, gt = Math.imul(At, qr), dt = Math.imul(At, Dt), dt = dt + Math.imul(qt, qr) | 0, wt = Math.imul(qt, Dt), gt = gt + Math.imul(Nr, Ht) | 0, dt = dt + Math.imul(Nr, Wt) | 0, dt = dt + Math.imul(Pt, Ht) | 0, wt = wt + Math.imul(Pt, Wt) | 0, gt = gt + Math.imul(kr, er) | 0, dt = dt + Math.imul(kr, rr) | 0, dt = dt + Math.imul(vr, er) | 0, wt = wt + Math.imul(vr, rr) | 0, gt = gt + Math.imul(Rr, ur) | 0, dt = dt + Math.imul(Rr, sr) | 0, dt = dt + Math.imul(pr, ur) | 0, wt = wt + Math.imul(pr, sr) | 0, gt = gt + Math.imul(Pr, _r) | 0, dt = dt + Math.imul(Pr, or) | 0, dt = dt + Math.imul(dr, _r) | 0, wt = wt + Math.imul(dr, or) | 0, gt = gt + Math.imul(cr, Zt) | 0, dt = dt + Math.imul(cr, tr) | 0, dt = dt + Math.imul(hr, Zt) | 0, wt = wt + Math.imul(hr, tr) | 0, gt = gt + Math.imul(Qt, gr) | 0, dt = dt + Math.imul(Qt, Er) | 0, dt = dt + Math.imul(nr, gr) | 0, wt = wt + Math.imul(nr, Er) | 0;
        var Xr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, gt = Math.imul(At, Ht), dt = Math.imul(At, Wt), dt = dt + Math.imul(qt, Ht) | 0, wt = Math.imul(qt, Wt), gt = gt + Math.imul(Nr, er) | 0, dt = dt + Math.imul(Nr, rr) | 0, dt = dt + Math.imul(Pt, er) | 0, wt = wt + Math.imul(Pt, rr) | 0, gt = gt + Math.imul(kr, ur) | 0, dt = dt + Math.imul(kr, sr) | 0, dt = dt + Math.imul(vr, ur) | 0, wt = wt + Math.imul(vr, sr) | 0, gt = gt + Math.imul(Rr, _r) | 0, dt = dt + Math.imul(Rr, or) | 0, dt = dt + Math.imul(pr, _r) | 0, wt = wt + Math.imul(pr, or) | 0, gt = gt + Math.imul(Pr, Zt) | 0, dt = dt + Math.imul(Pr, tr) | 0, dt = dt + Math.imul(dr, Zt) | 0, wt = wt + Math.imul(dr, tr) | 0, gt = gt + Math.imul(cr, gr) | 0, dt = dt + Math.imul(cr, Er) | 0, dt = dt + Math.imul(hr, gr) | 0, wt = wt + Math.imul(hr, Er) | 0;
        var Yr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, gt = Math.imul(At, er), dt = Math.imul(At, rr), dt = dt + Math.imul(qt, er) | 0, wt = Math.imul(qt, rr), gt = gt + Math.imul(Nr, ur) | 0, dt = dt + Math.imul(Nr, sr) | 0, dt = dt + Math.imul(Pt, ur) | 0, wt = wt + Math.imul(Pt, sr) | 0, gt = gt + Math.imul(kr, _r) | 0, dt = dt + Math.imul(kr, or) | 0, dt = dt + Math.imul(vr, _r) | 0, wt = wt + Math.imul(vr, or) | 0, gt = gt + Math.imul(Rr, Zt) | 0, dt = dt + Math.imul(Rr, tr) | 0, dt = dt + Math.imul(pr, Zt) | 0, wt = wt + Math.imul(pr, tr) | 0, gt = gt + Math.imul(Pr, gr) | 0, dt = dt + Math.imul(Pr, Er) | 0, dt = dt + Math.imul(dr, gr) | 0, wt = wt + Math.imul(dr, Er) | 0;
        var Jr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, gt = Math.imul(At, ur), dt = Math.imul(At, sr), dt = dt + Math.imul(qt, ur) | 0, wt = Math.imul(qt, sr), gt = gt + Math.imul(Nr, _r) | 0, dt = dt + Math.imul(Nr, or) | 0, dt = dt + Math.imul(Pt, _r) | 0, wt = wt + Math.imul(Pt, or) | 0, gt = gt + Math.imul(kr, Zt) | 0, dt = dt + Math.imul(kr, tr) | 0, dt = dt + Math.imul(vr, Zt) | 0, wt = wt + Math.imul(vr, tr) | 0, gt = gt + Math.imul(Rr, gr) | 0, dt = dt + Math.imul(Rr, Er) | 0, dt = dt + Math.imul(pr, gr) | 0, wt = wt + Math.imul(pr, Er) | 0;
        var Zr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, gt = Math.imul(At, _r), dt = Math.imul(At, or), dt = dt + Math.imul(qt, _r) | 0, wt = Math.imul(qt, or), gt = gt + Math.imul(Nr, Zt) | 0, dt = dt + Math.imul(Nr, tr) | 0, dt = dt + Math.imul(Pt, Zt) | 0, wt = wt + Math.imul(Pt, tr) | 0, gt = gt + Math.imul(kr, gr) | 0, dt = dt + Math.imul(kr, Er) | 0, dt = dt + Math.imul(vr, gr) | 0, wt = wt + Math.imul(vr, Er) | 0;
        var Qr = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, gt = Math.imul(At, Zt), dt = Math.imul(At, tr), dt = dt + Math.imul(qt, Zt) | 0, wt = Math.imul(qt, tr), gt = gt + Math.imul(Nr, gr) | 0, dt = dt + Math.imul(Nr, Er) | 0, dt = dt + Math.imul(Pt, gr) | 0, wt = wt + Math.imul(Pt, Er) | 0;
        var en = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        ut = (wt + (dt >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, gt = Math.imul(At, gr), dt = Math.imul(At, Er), dt = dt + Math.imul(qt, gr) | 0, wt = Math.imul(qt, Er);
        var tn = (ut + gt | 0) + ((dt & 8191) << 13) | 0;
        return ut = (wt + (dt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, bt[0] = Ir, bt[1] = Br, bt[2] = Ur, bt[3] = Fr, bt[4] = Dr, bt[5] = Hr, bt[6] = Wr, bt[7] = jr, bt[8] = Lr, bt[9] = Gr, bt[10] = zr, bt[11] = Vr, bt[12] = Xr, bt[13] = Yr, bt[14] = Jr, bt[15] = Zr, bt[16] = Qr, bt[17] = en, bt[18] = tn, ut !== 0 && (bt[19] = ut, ot.length++), ot;
      };
      Math.imul || (ht = pt);
      function yt(it, ke, rt) {
        rt.negative = ke.negative ^ it.negative, rt.length = it.length + ke.length;
        for (var ot = 0, ft = 0, ct = 0; ct < rt.length - 1; ct++) {
          var bt = ft;
          ft = 0;
          for (var ut = ot & 67108863, gt = Math.min(ct, ke.length - 1), dt = Math.max(0, ct - it.length + 1); dt <= gt; dt++) {
            var wt = ct - dt, Ft = it.words[wt] | 0, jt = ke.words[dt] | 0, Nt = Ft * jt, Bt = Nt & 67108863;
            bt = bt + (Nt / 67108864 | 0) | 0, Bt = Bt + ut | 0, ut = Bt & 67108863, bt = bt + (Bt >>> 26) | 0, ft += bt >>> 26, bt &= 67108863;
          }
          rt.words[ct] = ut, ot = bt, bt = ft;
        }
        return ot !== 0 ? rt.words[ct] = ot : rt.length--, rt._strip();
      }
      function vt(it, ke, rt) {
        return yt(it, ke, rt);
      }
      V.prototype.mulTo = function(ke, rt) {
        var ot, ft = this.length + ke.length;
        return this.length === 10 && ke.length === 10 ? ot = ht(this, ke, rt) : ft < 63 ? ot = pt(this, ke, rt) : ft < 1024 ? ot = yt(this, ke, rt) : ot = vt(this, ke, rt), ot;
      }, V.prototype.mul = function(ke) {
        var rt = new V(null);
        return rt.words = new Array(this.length + ke.length), this.mulTo(ke, rt);
      }, V.prototype.mulf = function(ke) {
        var rt = new V(null);
        return rt.words = new Array(this.length + ke.length), vt(this, ke, rt);
      }, V.prototype.imul = function(ke) {
        return this.clone().mulTo(ke, this);
      }, V.prototype.imuln = function(ke) {
        var rt = ke < 0;
        rt && (ke = -ke), K(typeof ke == "number"), K(ke < 67108864);
        for (var ot = 0, ft = 0; ft < this.length; ft++) {
          var ct = (this.words[ft] | 0) * ke, bt = (ct & 67108863) + (ot & 67108863);
          ot >>= 26, ot += ct / 67108864 | 0, ot += bt >>> 26, this.words[ft] = bt & 67108863;
        }
        return ot !== 0 && (this.words[ft] = ot, this.length++), rt ? this.ineg() : this;
      }, V.prototype.muln = function(ke) {
        return this.clone().imuln(ke);
      }, V.prototype.sqr = function() {
        return this.mul(this);
      }, V.prototype.isqr = function() {
        return this.imul(this.clone());
      }, V.prototype.pow = function(ke) {
        var rt = lt(ke);
        if (rt.length === 0) return new V(1);
        for (var ot = this, ft = 0; ft < rt.length && rt[ft] === 0; ft++, ot = ot.sqr())
          ;
        if (++ft < rt.length)
          for (var ct = ot.sqr(); ft < rt.length; ft++, ct = ct.sqr())
            rt[ft] !== 0 && (ot = ot.mul(ct));
        return ot;
      }, V.prototype.iushln = function(ke) {
        K(typeof ke == "number" && ke >= 0);
        var rt = ke % 26, ot = (ke - rt) / 26, ft = 67108863 >>> 26 - rt << 26 - rt, ct;
        if (rt !== 0) {
          var bt = 0;
          for (ct = 0; ct < this.length; ct++) {
            var ut = this.words[ct] & ft, gt = (this.words[ct] | 0) - ut << rt;
            this.words[ct] = gt | bt, bt = ut >>> 26 - rt;
          }
          bt && (this.words[ct] = bt, this.length++);
        }
        if (ot !== 0) {
          for (ct = this.length - 1; ct >= 0; ct--)
            this.words[ct + ot] = this.words[ct];
          for (ct = 0; ct < ot; ct++)
            this.words[ct] = 0;
          this.length += ot;
        }
        return this._strip();
      }, V.prototype.ishln = function(ke) {
        return K(this.negative === 0), this.iushln(ke);
      }, V.prototype.iushrn = function(ke, rt, ot) {
        K(typeof ke == "number" && ke >= 0);
        var ft;
        rt ? ft = (rt - rt % 26) / 26 : ft = 0;
        var ct = ke % 26, bt = Math.min((ke - ct) / 26, this.length), ut = 67108863 ^ 67108863 >>> ct << ct, gt = ot;
        if (ft -= bt, ft = Math.max(0, ft), gt) {
          for (var dt = 0; dt < bt; dt++)
            gt.words[dt] = this.words[dt];
          gt.length = bt;
        }
        if (bt !== 0) if (this.length > bt)
          for (this.length -= bt, dt = 0; dt < this.length; dt++)
            this.words[dt] = this.words[dt + bt];
        else
          this.words[0] = 0, this.length = 1;
        var wt = 0;
        for (dt = this.length - 1; dt >= 0 && (wt !== 0 || dt >= ft); dt--) {
          var Ft = this.words[dt] | 0;
          this.words[dt] = wt << 26 - ct | Ft >>> ct, wt = Ft & ut;
        }
        return gt && wt !== 0 && (gt.words[gt.length++] = wt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, V.prototype.ishrn = function(ke, rt, ot) {
        return K(this.negative === 0), this.iushrn(ke, rt, ot);
      }, V.prototype.shln = function(ke) {
        return this.clone().ishln(ke);
      }, V.prototype.ushln = function(ke) {
        return this.clone().iushln(ke);
      }, V.prototype.shrn = function(ke) {
        return this.clone().ishrn(ke);
      }, V.prototype.ushrn = function(ke) {
        return this.clone().iushrn(ke);
      }, V.prototype.testn = function(ke) {
        K(typeof ke == "number" && ke >= 0);
        var rt = ke % 26, ot = (ke - rt) / 26, ft = 1 << rt;
        if (this.length <= ot) return !1;
        var ct = this.words[ot];
        return !!(ct & ft);
      }, V.prototype.imaskn = function(ke) {
        K(typeof ke == "number" && ke >= 0);
        var rt = ke % 26, ot = (ke - rt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ot)
          return this;
        if (rt !== 0 && ot++, this.length = Math.min(ot, this.length), rt !== 0) {
          var ft = 67108863 ^ 67108863 >>> rt << rt;
          this.words[this.length - 1] &= ft;
        }
        return this._strip();
      }, V.prototype.maskn = function(ke) {
        return this.clone().imaskn(ke);
      }, V.prototype.iaddn = function(ke) {
        return K(typeof ke == "number"), K(ke < 67108864), ke < 0 ? this.isubn(-ke) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ke ? (this.words[0] = ke - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ke), this.negative = 1, this) : this._iaddn(ke);
      }, V.prototype._iaddn = function(ke) {
        this.words[0] += ke;
        for (var rt = 0; rt < this.length && this.words[rt] >= 67108864; rt++)
          this.words[rt] -= 67108864, rt === this.length - 1 ? this.words[rt + 1] = 1 : this.words[rt + 1]++;
        return this.length = Math.max(this.length, rt + 1), this;
      }, V.prototype.isubn = function(ke) {
        if (K(typeof ke == "number"), K(ke < 67108864), ke < 0) return this.iaddn(-ke);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(ke), this.negative = 1, this;
        if (this.words[0] -= ke, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var rt = 0; rt < this.length && this.words[rt] < 0; rt++)
            this.words[rt] += 67108864, this.words[rt + 1] -= 1;
        return this._strip();
      }, V.prototype.addn = function(ke) {
        return this.clone().iaddn(ke);
      }, V.prototype.subn = function(ke) {
        return this.clone().isubn(ke);
      }, V.prototype.iabs = function() {
        return this.negative = 0, this;
      }, V.prototype.abs = function() {
        return this.clone().iabs();
      }, V.prototype._ishlnsubmul = function(ke, rt, ot) {
        var ft = ke.length + ot, ct;
        this._expand(ft);
        var bt, ut = 0;
        for (ct = 0; ct < ke.length; ct++) {
          bt = (this.words[ct + ot] | 0) + ut;
          var gt = (ke.words[ct] | 0) * rt;
          bt -= gt & 67108863, ut = (bt >> 26) - (gt / 67108864 | 0), this.words[ct + ot] = bt & 67108863;
        }
        for (; ct < this.length - ot; ct++)
          bt = (this.words[ct + ot] | 0) + ut, ut = bt >> 26, this.words[ct + ot] = bt & 67108863;
        if (ut === 0) return this._strip();
        for (K(ut === -1), ut = 0, ct = 0; ct < this.length; ct++)
          bt = -(this.words[ct] | 0) + ut, ut = bt >> 26, this.words[ct] = bt & 67108863;
        return this.negative = 1, this._strip();
      }, V.prototype._wordDiv = function(ke, rt) {
        var ot = this.length - ke.length, ft = this.clone(), ct = ke, bt = ct.words[ct.length - 1] | 0, ut = this._countBits(bt);
        ot = 26 - ut, ot !== 0 && (ct = ct.ushln(ot), ft.iushln(ot), bt = ct.words[ct.length - 1] | 0);
        var gt = ft.length - ct.length, dt;
        if (rt !== "mod") {
          dt = new V(null), dt.length = gt + 1, dt.words = new Array(dt.length);
          for (var wt = 0; wt < dt.length; wt++)
            dt.words[wt] = 0;
        }
        var Ft = ft.clone()._ishlnsubmul(ct, 1, gt);
        Ft.negative === 0 && (ft = Ft, dt && (dt.words[gt] = 1));
        for (var jt = gt - 1; jt >= 0; jt--) {
          var Nt = (ft.words[ct.length + jt] | 0) * 67108864 + (ft.words[ct.length + jt - 1] | 0);
          for (Nt = Math.min(Nt / bt | 0, 67108863), ft._ishlnsubmul(ct, Nt, jt); ft.negative !== 0; )
            Nt--, ft.negative = 0, ft._ishlnsubmul(ct, 1, jt), ft.isZero() || (ft.negative ^= 1);
          dt && (dt.words[jt] = Nt);
        }
        return dt && dt._strip(), ft._strip(), rt !== "div" && ot !== 0 && ft.iushrn(ot), {
          div: dt || null,
          mod: ft
        };
      }, V.prototype.divmod = function(ke, rt, ot) {
        if (K(!ke.isZero()), this.isZero())
          return {
            div: new V(0),
            mod: new V(0)
          };
        var ft, ct, bt;
        return this.negative !== 0 && ke.negative === 0 ? (bt = this.neg().divmod(ke, rt), rt !== "mod" && (ft = bt.div.neg()), rt !== "div" && (ct = bt.mod.neg(), ot && ct.negative !== 0 && ct.iadd(ke)), {
          div: ft,
          mod: ct
        }) : this.negative === 0 && ke.negative !== 0 ? (bt = this.divmod(ke.neg(), rt), rt !== "mod" && (ft = bt.div.neg()), {
          div: ft,
          mod: bt.mod
        }) : this.negative & ke.negative ? (bt = this.neg().divmod(ke.neg(), rt), rt !== "div" && (ct = bt.mod.neg(), ot && ct.negative !== 0 && ct.isub(ke)), {
          div: bt.div,
          mod: ct
        }) : ke.length > this.length || this.cmp(ke) < 0 ? {
          div: new V(0),
          mod: this
        } : ke.length === 1 ? rt === "div" ? {
          div: this.divn(ke.words[0]),
          mod: null
        } : rt === "mod" ? {
          div: null,
          mod: new V(this.modrn(ke.words[0]))
        } : {
          div: this.divn(ke.words[0]),
          mod: new V(this.modrn(ke.words[0]))
        } : this._wordDiv(ke, rt);
      }, V.prototype.div = function(ke) {
        return this.divmod(ke, "div", !1).div;
      }, V.prototype.mod = function(ke) {
        return this.divmod(ke, "mod", !1).mod;
      }, V.prototype.umod = function(ke) {
        return this.divmod(ke, "mod", !0).mod;
      }, V.prototype.divRound = function(ke) {
        var rt = this.divmod(ke);
        if (rt.mod.isZero()) return rt.div;
        var ot = rt.div.negative !== 0 ? rt.mod.isub(ke) : rt.mod, ft = ke.ushrn(1), ct = ke.andln(1), bt = ot.cmp(ft);
        return bt < 0 || ct === 1 && bt === 0 ? rt.div : rt.div.negative !== 0 ? rt.div.isubn(1) : rt.div.iaddn(1);
      }, V.prototype.modrn = function(ke) {
        var rt = ke < 0;
        rt && (ke = -ke), K(ke <= 67108863);
        for (var ot = (1 << 26) % ke, ft = 0, ct = this.length - 1; ct >= 0; ct--)
          ft = (ot * ft + (this.words[ct] | 0)) % ke;
        return rt ? -ft : ft;
      }, V.prototype.modn = function(ke) {
        return this.modrn(ke);
      }, V.prototype.idivn = function(ke) {
        var rt = ke < 0;
        rt && (ke = -ke), K(ke <= 67108863);
        for (var ot = 0, ft = this.length - 1; ft >= 0; ft--) {
          var ct = (this.words[ft] | 0) + ot * 67108864;
          this.words[ft] = ct / ke | 0, ot = ct % ke;
        }
        return this._strip(), rt ? this.ineg() : this;
      }, V.prototype.divn = function(ke) {
        return this.clone().idivn(ke);
      }, V.prototype.egcd = function(ke) {
        K(ke.negative === 0), K(!ke.isZero());
        var rt = this, ot = ke.clone();
        rt.negative !== 0 ? rt = rt.umod(ke) : rt = rt.clone();
        for (var ft = new V(1), ct = new V(0), bt = new V(0), ut = new V(1), gt = 0; rt.isEven() && ot.isEven(); )
          rt.iushrn(1), ot.iushrn(1), ++gt;
        for (var dt = ot.clone(), wt = rt.clone(); !rt.isZero(); ) {
          for (var Ft = 0, jt = 1; !(rt.words[0] & jt) && Ft < 26; ++Ft, jt <<= 1) ;
          if (Ft > 0)
            for (rt.iushrn(Ft); Ft-- > 0; )
              (ft.isOdd() || ct.isOdd()) && (ft.iadd(dt), ct.isub(wt)), ft.iushrn(1), ct.iushrn(1);
          for (var Nt = 0, Bt = 1; !(ot.words[0] & Bt) && Nt < 26; ++Nt, Bt <<= 1) ;
          if (Nt > 0)
            for (ot.iushrn(Nt); Nt-- > 0; )
              (bt.isOdd() || ut.isOdd()) && (bt.iadd(dt), ut.isub(wt)), bt.iushrn(1), ut.iushrn(1);
          rt.cmp(ot) >= 0 ? (rt.isub(ot), ft.isub(bt), ct.isub(ut)) : (ot.isub(rt), bt.isub(ft), ut.isub(ct));
        }
        return {
          a: bt,
          b: ut,
          gcd: ot.iushln(gt)
        };
      }, V.prototype._invmp = function(ke) {
        K(ke.negative === 0), K(!ke.isZero());
        var rt = this, ot = ke.clone();
        rt.negative !== 0 ? rt = rt.umod(ke) : rt = rt.clone();
        for (var ft = new V(1), ct = new V(0), bt = ot.clone(); rt.cmpn(1) > 0 && ot.cmpn(1) > 0; ) {
          for (var ut = 0, gt = 1; !(rt.words[0] & gt) && ut < 26; ++ut, gt <<= 1) ;
          if (ut > 0)
            for (rt.iushrn(ut); ut-- > 0; )
              ft.isOdd() && ft.iadd(bt), ft.iushrn(1);
          for (var dt = 0, wt = 1; !(ot.words[0] & wt) && dt < 26; ++dt, wt <<= 1) ;
          if (dt > 0)
            for (ot.iushrn(dt); dt-- > 0; )
              ct.isOdd() && ct.iadd(bt), ct.iushrn(1);
          rt.cmp(ot) >= 0 ? (rt.isub(ot), ft.isub(ct)) : (ot.isub(rt), ct.isub(ft));
        }
        var Ft;
        return rt.cmpn(1) === 0 ? Ft = ft : Ft = ct, Ft.cmpn(0) < 0 && Ft.iadd(ke), Ft;
      }, V.prototype.gcd = function(ke) {
        if (this.isZero()) return ke.abs();
        if (ke.isZero()) return this.abs();
        var rt = this.clone(), ot = ke.clone();
        rt.negative = 0, ot.negative = 0;
        for (var ft = 0; rt.isEven() && ot.isEven(); ft++)
          rt.iushrn(1), ot.iushrn(1);
        do {
          for (; rt.isEven(); )
            rt.iushrn(1);
          for (; ot.isEven(); )
            ot.iushrn(1);
          var ct = rt.cmp(ot);
          if (ct < 0) {
            var bt = rt;
            rt = ot, ot = bt;
          } else if (ct === 0 || ot.cmpn(1) === 0)
            break;
          rt.isub(ot);
        } while (!0);
        return ot.iushln(ft);
      }, V.prototype.invm = function(ke) {
        return this.egcd(ke).a.umod(ke);
      }, V.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, V.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, V.prototype.andln = function(ke) {
        return this.words[0] & ke;
      }, V.prototype.bincn = function(ke) {
        K(typeof ke == "number");
        var rt = ke % 26, ot = (ke - rt) / 26, ft = 1 << rt;
        if (this.length <= ot)
          return this._expand(ot + 1), this.words[ot] |= ft, this;
        for (var ct = ft, bt = ot; ct !== 0 && bt < this.length; bt++) {
          var ut = this.words[bt] | 0;
          ut += ct, ct = ut >>> 26, ut &= 67108863, this.words[bt] = ut;
        }
        return ct !== 0 && (this.words[bt] = ct, this.length++), this;
      }, V.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, V.prototype.cmpn = function(ke) {
        var rt = ke < 0;
        if (this.negative !== 0 && !rt) return -1;
        if (this.negative === 0 && rt) return 1;
        this._strip();
        var ot;
        if (this.length > 1)
          ot = 1;
        else {
          rt && (ke = -ke), K(ke <= 67108863, "Number is too big");
          var ft = this.words[0] | 0;
          ot = ft === ke ? 0 : ft < ke ? -1 : 1;
        }
        return this.negative !== 0 ? -ot | 0 : ot;
      }, V.prototype.cmp = function(ke) {
        if (this.negative !== 0 && ke.negative === 0) return -1;
        if (this.negative === 0 && ke.negative !== 0) return 1;
        var rt = this.ucmp(ke);
        return this.negative !== 0 ? -rt | 0 : rt;
      }, V.prototype.ucmp = function(ke) {
        if (this.length > ke.length) return 1;
        if (this.length < ke.length) return -1;
        for (var rt = 0, ot = this.length - 1; ot >= 0; ot--) {
          var ft = this.words[ot] | 0, ct = ke.words[ot] | 0;
          if (ft !== ct) {
            ft < ct ? rt = -1 : ft > ct && (rt = 1);
            break;
          }
        }
        return rt;
      }, V.prototype.gtn = function(ke) {
        return this.cmpn(ke) === 1;
      }, V.prototype.gt = function(ke) {
        return this.cmp(ke) === 1;
      }, V.prototype.gten = function(ke) {
        return this.cmpn(ke) >= 0;
      }, V.prototype.gte = function(ke) {
        return this.cmp(ke) >= 0;
      }, V.prototype.ltn = function(ke) {
        return this.cmpn(ke) === -1;
      }, V.prototype.lt = function(ke) {
        return this.cmp(ke) === -1;
      }, V.prototype.lten = function(ke) {
        return this.cmpn(ke) <= 0;
      }, V.prototype.lte = function(ke) {
        return this.cmp(ke) <= 0;
      }, V.prototype.eqn = function(ke) {
        return this.cmpn(ke) === 0;
      }, V.prototype.eq = function(ke) {
        return this.cmp(ke) === 0;
      }, V.red = function(ke) {
        return new Tt(ke);
      }, V.prototype.toRed = function(ke) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), ke.convertTo(this)._forceRed(ke);
      }, V.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, V.prototype._forceRed = function(ke) {
        return this.red = ke, this;
      }, V.prototype.forceRed = function(ke) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(ke);
      }, V.prototype.redAdd = function(ke) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, ke);
      }, V.prototype.redIAdd = function(ke) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ke);
      }, V.prototype.redSub = function(ke) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, ke);
      }, V.prototype.redISub = function(ke) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, ke);
      }, V.prototype.redShl = function(ke) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, ke);
      }, V.prototype.redMul = function(ke) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, ke), this.red.mul(this, ke);
      }, V.prototype.redIMul = function(ke) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, ke), this.red.imul(this, ke);
      }, V.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, V.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, V.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, V.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, V.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, V.prototype.redPow = function(ke) {
        return K(this.red && !ke.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ke);
      };
      var $t = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function xt(it, ke) {
        this.name = it, this.p = new V(ke, 16), this.n = this.p.bitLength(), this.k = new V(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      xt.prototype._tmp = function() {
        var ke = new V(null);
        return ke.words = new Array(Math.ceil(this.n / 13)), ke;
      }, xt.prototype.ireduce = function(ke) {
        var rt = ke, ot;
        do
          this.split(rt, this.tmp), rt = this.imulK(rt), rt = rt.iadd(this.tmp), ot = rt.bitLength();
        while (ot > this.n);
        var ft = ot < this.n ? -1 : rt.ucmp(this.p);
        return ft === 0 ? (rt.words[0] = 0, rt.length = 1) : ft > 0 ? rt.isub(this.p) : rt.strip !== void 0 ? rt.strip() : rt._strip(), rt;
      }, xt.prototype.split = function(ke, rt) {
        ke.iushrn(this.n, 0, rt);
      }, xt.prototype.imulK = function(ke) {
        return ke.imul(this.k);
      };
      function Ct() {
        xt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J(Ct, xt), Ct.prototype.split = function(ke, rt) {
        for (var ot = 4194303, ft = Math.min(ke.length, 9), ct = 0; ct < ft; ct++)
          rt.words[ct] = ke.words[ct];
        if (rt.length = ft, ke.length <= 9) {
          ke.words[0] = 0, ke.length = 1;
          return;
        }
        var bt = ke.words[9];
        for (rt.words[rt.length++] = bt & ot, ct = 10; ct < ke.length; ct++) {
          var ut = ke.words[ct] | 0;
          ke.words[ct - 10] = (ut & ot) << 4 | bt >>> 22, bt = ut;
        }
        bt >>>= 22, ke.words[ct - 10] = bt, bt === 0 && ke.length > 10 ? ke.length -= 10 : ke.length -= 9;
      }, Ct.prototype.imulK = function(ke) {
        ke.words[ke.length] = 0, ke.words[ke.length + 1] = 0, ke.length += 2;
        for (var rt = 0, ot = 0; ot < ke.length; ot++) {
          var ft = ke.words[ot] | 0;
          rt += ft * 977, ke.words[ot] = rt & 67108863, rt = ft * 64 + (rt / 67108864 | 0);
        }
        return ke.words[ke.length - 1] === 0 && (ke.length--, ke.words[ke.length - 1] === 0 && ke.length--), ke;
      };
      function Et() {
        xt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J(Et, xt);
      function St() {
        xt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(St, xt);
      function It() {
        xt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(It, xt), It.prototype.imulK = function(ke) {
        for (var rt = 0, ot = 0; ot < ke.length; ot++) {
          var ft = (ke.words[ot] | 0) * 19 + rt, ct = ft & 67108863;
          ft >>>= 26, ke.words[ot] = ct, rt = ft;
        }
        return rt !== 0 && (ke.words[ke.length++] = rt), ke;
      }, V._prime = function(ke) {
        if ($t[ke]) return $t[ke];
        var rt;
        if (ke === "k256")
          rt = new Ct();
        else if (ke === "p224")
          rt = new Et();
        else if (ke === "p192")
          rt = new St();
        else if (ke === "p25519")
          rt = new It();
        else
          throw new Error("Unknown prime " + ke);
        return $t[ke] = rt, rt;
      };
      function Tt(it) {
        if (typeof it == "string") {
          var ke = V._prime(it);
          this.m = ke.p, this.prime = ke;
        } else
          K(it.gtn(1), "modulus must be greater than 1"), this.m = it, this.prime = null;
      }
      Tt.prototype._verify1 = function(ke) {
        K(ke.negative === 0, "red works only with positives"), K(ke.red, "red works only with red numbers");
      }, Tt.prototype._verify2 = function(ke, rt) {
        K((ke.negative | rt.negative) === 0, "red works only with positives"), K(
          ke.red && ke.red === rt.red,
          "red works only with red numbers"
        );
      }, Tt.prototype.imod = function(ke) {
        return this.prime ? this.prime.ireduce(ke)._forceRed(this) : (ne(ke, ke.umod(this.m)._forceRed(this)), ke);
      }, Tt.prototype.neg = function(ke) {
        return ke.isZero() ? ke.clone() : this.m.sub(ke)._forceRed(this);
      }, Tt.prototype.add = function(ke, rt) {
        this._verify2(ke, rt);
        var ot = ke.add(rt);
        return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot._forceRed(this);
      }, Tt.prototype.iadd = function(ke, rt) {
        this._verify2(ke, rt);
        var ot = ke.iadd(rt);
        return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot;
      }, Tt.prototype.sub = function(ke, rt) {
        this._verify2(ke, rt);
        var ot = ke.sub(rt);
        return ot.cmpn(0) < 0 && ot.iadd(this.m), ot._forceRed(this);
      }, Tt.prototype.isub = function(ke, rt) {
        this._verify2(ke, rt);
        var ot = ke.isub(rt);
        return ot.cmpn(0) < 0 && ot.iadd(this.m), ot;
      }, Tt.prototype.shl = function(ke, rt) {
        return this._verify1(ke), this.imod(ke.ushln(rt));
      }, Tt.prototype.imul = function(ke, rt) {
        return this._verify2(ke, rt), this.imod(ke.imul(rt));
      }, Tt.prototype.mul = function(ke, rt) {
        return this._verify2(ke, rt), this.imod(ke.mul(rt));
      }, Tt.prototype.isqr = function(ke) {
        return this.imul(ke, ke.clone());
      }, Tt.prototype.sqr = function(ke) {
        return this.mul(ke, ke);
      }, Tt.prototype.sqrt = function(ke) {
        if (ke.isZero()) return ke.clone();
        var rt = this.m.andln(3);
        if (K(rt % 2 === 1), rt === 3) {
          var ot = this.m.add(new V(1)).iushrn(2);
          return this.pow(ke, ot);
        }
        for (var ft = this.m.subn(1), ct = 0; !ft.isZero() && ft.andln(1) === 0; )
          ct++, ft.iushrn(1);
        K(!ft.isZero());
        var bt = new V(1).toRed(this), ut = bt.redNeg(), gt = this.m.subn(1).iushrn(1), dt = this.m.bitLength();
        for (dt = new V(2 * dt * dt).toRed(this); this.pow(dt, gt).cmp(ut) !== 0; )
          dt.redIAdd(ut);
        for (var wt = this.pow(dt, ft), Ft = this.pow(ke, ft.addn(1).iushrn(1)), jt = this.pow(ke, ft), Nt = ct; jt.cmp(bt) !== 0; ) {
          for (var Bt = jt, Rt = 0; Bt.cmp(bt) !== 0; Rt++)
            Bt = Bt.redSqr();
          K(Rt < Nt);
          var Ut = this.pow(wt, new V(1).iushln(Nt - Rt - 1));
          Ft = Ft.redMul(Ut), wt = Ut.redSqr(), jt = jt.redMul(wt), Nt = Rt;
        }
        return Ft;
      }, Tt.prototype.invm = function(ke) {
        var rt = ke._invmp(this.m);
        return rt.negative !== 0 ? (rt.negative = 0, this.imod(rt).redNeg()) : this.imod(rt);
      }, Tt.prototype.pow = function(ke, rt) {
        if (rt.isZero()) return new V(1).toRed(this);
        if (rt.cmpn(1) === 0) return ke.clone();
        var ot = 4, ft = new Array(1 << ot);
        ft[0] = new V(1).toRed(this), ft[1] = ke;
        for (var ct = 2; ct < ft.length; ct++)
          ft[ct] = this.mul(ft[ct - 1], ke);
        var bt = ft[0], ut = 0, gt = 0, dt = rt.bitLength() % 26;
        for (dt === 0 && (dt = 26), ct = rt.length - 1; ct >= 0; ct--) {
          for (var wt = rt.words[ct], Ft = dt - 1; Ft >= 0; Ft--) {
            var jt = wt >> Ft & 1;
            if (bt !== ft[0] && (bt = this.sqr(bt)), jt === 0 && ut === 0) {
              gt = 0;
              continue;
            }
            ut <<= 1, ut |= jt, gt++, !(gt !== ot && (ct !== 0 || Ft !== 0)) && (bt = this.mul(bt, ft[ut]), gt = 0, ut = 0);
          }
          dt = 26;
        }
        return bt;
      }, Tt.prototype.convertTo = function(ke) {
        var rt = ke.umod(this.m);
        return rt === ke ? rt.clone() : rt;
      }, Tt.prototype.convertFrom = function(ke) {
        var rt = ke.clone();
        return rt.red = null, rt;
      }, V.mont = function(ke) {
        return new nt(ke);
      };
      function nt(it) {
        Tt.call(this, it), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new V(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(nt, Tt), nt.prototype.convertTo = function(ke) {
        return this.imod(ke.ushln(this.shift));
      }, nt.prototype.convertFrom = function(ke) {
        var rt = this.imod(ke.mul(this.rinv));
        return rt.red = null, rt;
      }, nt.prototype.imul = function(ke, rt) {
        if (ke.isZero() || rt.isZero())
          return ke.words[0] = 0, ke.length = 1, ke;
        var ot = ke.imul(rt), ft = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ct = ot.isub(ft).iushrn(this.shift), bt = ct;
        return ct.cmp(this.m) >= 0 ? bt = ct.isub(this.m) : ct.cmpn(0) < 0 && (bt = ct.iadd(this.m)), bt._forceRed(this);
      }, nt.prototype.mul = function(ke, rt) {
        if (ke.isZero() || rt.isZero()) return new V(0)._forceRed(this);
        var ot = ke.mul(rt), ft = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ct = ot.isub(ft).iushrn(this.shift), bt = ct;
        return ct.cmp(this.m) >= 0 ? bt = ct.isub(this.m) : ct.cmpn(0) < 0 && (bt = ct.iadd(this.m)), bt._forceRed(this);
      }, nt.prototype.invm = function(ke) {
        var rt = this.imod(ke._invmp(this.m).mul(this.r2));
        return rt._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var B = requireBn(), L = requireBrowser$9();
  function W(V) {
    var re = K(V), ie = re.toRed(B.mont(V.modulus)).redPow(new B(V.publicExponent)).fromRed();
    return { blinder: ie, unblinder: re.invm(V.modulus) };
  }
  function K(V) {
    var re = V.modulus.byteLength(), ie;
    do
      ie = new B(L(re));
    while (ie.cmp(V.modulus) >= 0 || !ie.umod(V.prime1) || !ie.umod(V.prime2));
    return ie;
  }
  function J(V, re) {
    var ie = W(re), oe = re.modulus.byteLength(), pe = new B(V).mul(ie.blinder).umod(re.modulus), ne = pe.toRed(B.mont(re.prime1)), ce = pe.toRed(B.mont(re.prime2)), Ce = re.coefficient, Oe = re.prime1, st = re.prime2, at = ne.redPow(re.exponent1).fromRed(), lt = ce.redPow(re.exponent2).fromRed(), pt = at.isub(lt).imul(Ce).umod(Oe).imul(st);
    return lt.iadd(pt).imul(ie.unblinder).umod(re.modulus).toArrayLike(Buffer$2, "be", oe);
  }
  return J.getr = K, browserifyRsa = J, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$2 = {}, utils$1 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(B) {
    var L = B;
    function W(V, re) {
      if (Array.isArray(V))
        return V.slice();
      if (!V)
        return [];
      var ie = [];
      if (typeof V != "string") {
        for (var oe = 0; oe < V.length; oe++)
          ie[oe] = V[oe] | 0;
        return ie;
      }
      if (re === "hex") {
        V = V.replace(/[^a-z0-9]+/ig, ""), V.length % 2 !== 0 && (V = "0" + V);
        for (var oe = 0; oe < V.length; oe += 2)
          ie.push(parseInt(V[oe] + V[oe + 1], 16));
      } else
        for (var oe = 0; oe < V.length; oe++) {
          var pe = V.charCodeAt(oe), ne = pe >> 8, ce = pe & 255;
          ne ? ie.push(ne, ce) : ie.push(ce);
        }
      return ie;
    }
    L.toArray = W;
    function K(V) {
      return V.length === 1 ? "0" + V : V;
    }
    L.zero2 = K;
    function J(V) {
      for (var re = "", ie = 0; ie < V.length; ie++)
        re += K(V[ie].toString(16));
      return re;
    }
    L.toHex = J, L.encode = function(re, ie) {
      return ie === "hex" ? J(re) : re;
    };
  }(utils$1)), utils$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(B) {
    var L = B, W = requireBn$1(), K = requireMinimalisticAssert(), J = requireUtils$2();
    L.assert = K, L.toArray = J.toArray, L.zero2 = J.zero2, L.toHex = J.toHex, L.encode = J.encode;
    function V(ne, ce, Ce) {
      var Oe = new Array(Math.max(ne.bitLength(), Ce) + 1), st;
      for (st = 0; st < Oe.length; st += 1)
        Oe[st] = 0;
      var at = 1 << ce + 1, lt = ne.clone();
      for (st = 0; st < Oe.length; st++) {
        var pt, ht = lt.andln(at - 1);
        lt.isOdd() ? (ht > (at >> 1) - 1 ? pt = (at >> 1) - ht : pt = ht, lt.isubn(pt)) : pt = 0, Oe[st] = pt, lt.iushrn(1);
      }
      return Oe;
    }
    L.getNAF = V;
    function re(ne, ce) {
      var Ce = [
        [],
        []
      ];
      ne = ne.clone(), ce = ce.clone();
      for (var Oe = 0, st = 0, at; ne.cmpn(-Oe) > 0 || ce.cmpn(-st) > 0; ) {
        var lt = ne.andln(3) + Oe & 3, pt = ce.andln(3) + st & 3;
        lt === 3 && (lt = -1), pt === 3 && (pt = -1);
        var ht;
        lt & 1 ? (at = ne.andln(7) + Oe & 7, (at === 3 || at === 5) && pt === 2 ? ht = -lt : ht = lt) : ht = 0, Ce[0].push(ht);
        var yt;
        pt & 1 ? (at = ce.andln(7) + st & 7, (at === 3 || at === 5) && lt === 2 ? yt = -pt : yt = pt) : yt = 0, Ce[1].push(yt), 2 * Oe === ht + 1 && (Oe = 1 - Oe), 2 * st === yt + 1 && (st = 1 - st), ne.iushrn(1), ce.iushrn(1);
      }
      return Ce;
    }
    L.getJSF = re;
    function ie(ne, ce, Ce) {
      var Oe = "_" + ce;
      ne.prototype[ce] = function() {
        return this[Oe] !== void 0 ? this[Oe] : this[Oe] = Ce.call(this);
      };
    }
    L.cachedProperty = ie;
    function oe(ne) {
      return typeof ne == "string" ? L.toArray(ne, "hex") : ne;
    }
    L.parseBytes = oe;
    function pe(ne) {
      return new W(ne, "hex", "le");
    }
    L.intFromLE = pe;
  }(utils$2)), utils$2;
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$1;
  hasRequiredBase$1 = 1;
  var B = requireBn$1(), L = requireUtils$1(), W = L.getNAF, K = L.getJSF, J = L.assert;
  function V(ie, oe) {
    this.type = ie, this.p = new B(oe.p, 16), this.red = oe.prime ? B.red(oe.prime) : B.mont(this.p), this.zero = new B(0).toRed(this.red), this.one = new B(1).toRed(this.red), this.two = new B(2).toRed(this.red), this.n = oe.n && new B(oe.n, 16), this.g = oe.g && this.pointFromJSON(oe.g, oe.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var pe = this.n && this.p.div(this.n);
    !pe || pe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$1 = V, V.prototype.point = function() {
    throw new Error("Not implemented");
  }, V.prototype.validate = function() {
    throw new Error("Not implemented");
  }, V.prototype._fixedNafMul = function(oe, pe) {
    J(oe.precomputed);
    var ne = oe._getDoubles(), ce = W(pe, 1, this._bitLength), Ce = (1 << ne.step + 1) - (ne.step % 2 === 0 ? 2 : 1);
    Ce /= 3;
    var Oe = [], st, at;
    for (st = 0; st < ce.length; st += ne.step) {
      at = 0;
      for (var lt = st + ne.step - 1; lt >= st; lt--)
        at = (at << 1) + ce[lt];
      Oe.push(at);
    }
    for (var pt = this.jpoint(null, null, null), ht = this.jpoint(null, null, null), yt = Ce; yt > 0; yt--) {
      for (st = 0; st < Oe.length; st++)
        at = Oe[st], at === yt ? ht = ht.mixedAdd(ne.points[st]) : at === -yt && (ht = ht.mixedAdd(ne.points[st].neg()));
      pt = pt.add(ht);
    }
    return pt.toP();
  }, V.prototype._wnafMul = function(oe, pe) {
    var ne = 4, ce = oe._getNAFPoints(ne);
    ne = ce.wnd;
    for (var Ce = ce.points, Oe = W(pe, ne, this._bitLength), st = this.jpoint(null, null, null), at = Oe.length - 1; at >= 0; at--) {
      for (var lt = 0; at >= 0 && Oe[at] === 0; at--)
        lt++;
      if (at >= 0 && lt++, st = st.dblp(lt), at < 0)
        break;
      var pt = Oe[at];
      J(pt !== 0), oe.type === "affine" ? pt > 0 ? st = st.mixedAdd(Ce[pt - 1 >> 1]) : st = st.mixedAdd(Ce[-pt - 1 >> 1].neg()) : pt > 0 ? st = st.add(Ce[pt - 1 >> 1]) : st = st.add(Ce[-pt - 1 >> 1].neg());
    }
    return oe.type === "affine" ? st.toP() : st;
  }, V.prototype._wnafMulAdd = function(oe, pe, ne, ce, Ce) {
    var Oe = this._wnafT1, st = this._wnafT2, at = this._wnafT3, lt = 0, pt, ht, yt;
    for (pt = 0; pt < ce; pt++) {
      yt = pe[pt];
      var vt = yt._getNAFPoints(oe);
      Oe[pt] = vt.wnd, st[pt] = vt.points;
    }
    for (pt = ce - 1; pt >= 1; pt -= 2) {
      var $t = pt - 1, xt = pt;
      if (Oe[$t] !== 1 || Oe[xt] !== 1) {
        at[$t] = W(ne[$t], Oe[$t], this._bitLength), at[xt] = W(ne[xt], Oe[xt], this._bitLength), lt = Math.max(at[$t].length, lt), lt = Math.max(at[xt].length, lt);
        continue;
      }
      var Ct = [
        pe[$t],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        pe[xt]
        /* 7 */
      ];
      pe[$t].y.cmp(pe[xt].y) === 0 ? (Ct[1] = pe[$t].add(pe[xt]), Ct[2] = pe[$t].toJ().mixedAdd(pe[xt].neg())) : pe[$t].y.cmp(pe[xt].y.redNeg()) === 0 ? (Ct[1] = pe[$t].toJ().mixedAdd(pe[xt]), Ct[2] = pe[$t].add(pe[xt].neg())) : (Ct[1] = pe[$t].toJ().mixedAdd(pe[xt]), Ct[2] = pe[$t].toJ().mixedAdd(pe[xt].neg()));
      var Et = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], St = K(ne[$t], ne[xt]);
      for (lt = Math.max(St[0].length, lt), at[$t] = new Array(lt), at[xt] = new Array(lt), ht = 0; ht < lt; ht++) {
        var It = St[0][ht] | 0, Tt = St[1][ht] | 0;
        at[$t][ht] = Et[(It + 1) * 3 + (Tt + 1)], at[xt][ht] = 0, st[$t] = Ct;
      }
    }
    var nt = this.jpoint(null, null, null), it = this._wnafT4;
    for (pt = lt; pt >= 0; pt--) {
      for (var ke = 0; pt >= 0; ) {
        var rt = !0;
        for (ht = 0; ht < ce; ht++)
          it[ht] = at[ht][pt] | 0, it[ht] !== 0 && (rt = !1);
        if (!rt)
          break;
        ke++, pt--;
      }
      if (pt >= 0 && ke++, nt = nt.dblp(ke), pt < 0)
        break;
      for (ht = 0; ht < ce; ht++) {
        var ot = it[ht];
        ot !== 0 && (ot > 0 ? yt = st[ht][ot - 1 >> 1] : ot < 0 && (yt = st[ht][-ot - 1 >> 1].neg()), yt.type === "affine" ? nt = nt.mixedAdd(yt) : nt = nt.add(yt));
      }
    }
    for (pt = 0; pt < ce; pt++)
      st[pt] = null;
    return Ce ? nt : nt.toP();
  };
  function re(ie, oe) {
    this.curve = ie, this.type = oe, this.precomputed = null;
  }
  return V.BasePoint = re, re.prototype.eq = function() {
    throw new Error("Not implemented");
  }, re.prototype.validate = function() {
    return this.curve.validate(this);
  }, V.prototype.decodePoint = function(oe, pe) {
    oe = L.toArray(oe, pe);
    var ne = this.p.byteLength();
    if ((oe[0] === 4 || oe[0] === 6 || oe[0] === 7) && oe.length - 1 === 2 * ne) {
      oe[0] === 6 ? J(oe[oe.length - 1] % 2 === 0) : oe[0] === 7 && J(oe[oe.length - 1] % 2 === 1);
      var ce = this.point(
        oe.slice(1, 1 + ne),
        oe.slice(1 + ne, 1 + 2 * ne)
      );
      return ce;
    } else if ((oe[0] === 2 || oe[0] === 3) && oe.length - 1 === ne)
      return this.pointFromX(oe.slice(1, 1 + ne), oe[0] === 3);
    throw new Error("Unknown point format");
  }, re.prototype.encodeCompressed = function(oe) {
    return this.encode(oe, !0);
  }, re.prototype._encode = function(oe) {
    var pe = this.curve.p.byteLength(), ne = this.getX().toArray("be", pe);
    return oe ? [this.getY().isEven() ? 2 : 3].concat(ne) : [4].concat(ne, this.getY().toArray("be", pe));
  }, re.prototype.encode = function(oe, pe) {
    return L.encode(this._encode(pe), oe);
  }, re.prototype.precompute = function(oe) {
    if (this.precomputed)
      return this;
    var pe = {
      doubles: null,
      naf: null,
      beta: null
    };
    return pe.naf = this._getNAFPoints(8), pe.doubles = this._getDoubles(4, oe), pe.beta = this._getBeta(), this.precomputed = pe, this;
  }, re.prototype._hasDoubles = function(oe) {
    if (!this.precomputed)
      return !1;
    var pe = this.precomputed.doubles;
    return pe ? pe.points.length >= Math.ceil((oe.bitLength() + 1) / pe.step) : !1;
  }, re.prototype._getDoubles = function(oe, pe) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var ne = [this], ce = this, Ce = 0; Ce < pe; Ce += oe) {
      for (var Oe = 0; Oe < oe; Oe++)
        ce = ce.dbl();
      ne.push(ce);
    }
    return {
      step: oe,
      points: ne
    };
  }, re.prototype._getNAFPoints = function(oe) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var pe = [this], ne = (1 << oe) - 1, ce = ne === 1 ? null : this.dbl(), Ce = 1; Ce < ne; Ce++)
      pe[Ce] = pe[Ce - 1].add(ce);
    return {
      wnd: oe,
      points: pe
    };
  }, re.prototype._getBeta = function() {
    return null;
  }, re.prototype.dblp = function(oe) {
    for (var pe = this, ne = 0; ne < oe; ne++)
      pe = pe.dbl();
    return pe;
  }, base$1;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var B = requireUtils$1(), L = requireBn$1(), W = requireInherits_browser(), K = requireBase$1(), J = B.assert;
  function V(oe) {
    K.call(this, "short", oe), this.a = new L(oe.a, 16).toRed(this.red), this.b = new L(oe.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(oe), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  W(V, K), short = V, V.prototype._getEndomorphism = function(pe) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var ne, ce;
      if (pe.beta)
        ne = new L(pe.beta, 16).toRed(this.red);
      else {
        var Ce = this._getEndoRoots(this.p);
        ne = Ce[0].cmp(Ce[1]) < 0 ? Ce[0] : Ce[1], ne = ne.toRed(this.red);
      }
      if (pe.lambda)
        ce = new L(pe.lambda, 16);
      else {
        var Oe = this._getEndoRoots(this.n);
        this.g.mul(Oe[0]).x.cmp(this.g.x.redMul(ne)) === 0 ? ce = Oe[0] : (ce = Oe[1], J(this.g.mul(ce).x.cmp(this.g.x.redMul(ne)) === 0));
      }
      var st;
      return pe.basis ? st = pe.basis.map(function(at) {
        return {
          a: new L(at.a, 16),
          b: new L(at.b, 16)
        };
      }) : st = this._getEndoBasis(ce), {
        beta: ne,
        lambda: ce,
        basis: st
      };
    }
  }, V.prototype._getEndoRoots = function(pe) {
    var ne = pe === this.p ? this.red : L.mont(pe), ce = new L(2).toRed(ne).redInvm(), Ce = ce.redNeg(), Oe = new L(3).toRed(ne).redNeg().redSqrt().redMul(ce), st = Ce.redAdd(Oe).fromRed(), at = Ce.redSub(Oe).fromRed();
    return [st, at];
  }, V.prototype._getEndoBasis = function(pe) {
    for (var ne = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ce = pe, Ce = this.n.clone(), Oe = new L(1), st = new L(0), at = new L(0), lt = new L(1), pt, ht, yt, vt, $t, xt, Ct, Et = 0, St, It; ce.cmpn(0) !== 0; ) {
      var Tt = Ce.div(ce);
      St = Ce.sub(Tt.mul(ce)), It = at.sub(Tt.mul(Oe));
      var nt = lt.sub(Tt.mul(st));
      if (!yt && St.cmp(ne) < 0)
        pt = Ct.neg(), ht = Oe, yt = St.neg(), vt = It;
      else if (yt && ++Et === 2)
        break;
      Ct = St, Ce = ce, ce = St, at = Oe, Oe = It, lt = st, st = nt;
    }
    $t = St.neg(), xt = It;
    var it = yt.sqr().add(vt.sqr()), ke = $t.sqr().add(xt.sqr());
    return ke.cmp(it) >= 0 && ($t = pt, xt = ht), yt.negative && (yt = yt.neg(), vt = vt.neg()), $t.negative && ($t = $t.neg(), xt = xt.neg()), [
      { a: yt, b: vt },
      { a: $t, b: xt }
    ];
  }, V.prototype._endoSplit = function(pe) {
    var ne = this.endo.basis, ce = ne[0], Ce = ne[1], Oe = Ce.b.mul(pe).divRound(this.n), st = ce.b.neg().mul(pe).divRound(this.n), at = Oe.mul(ce.a), lt = st.mul(Ce.a), pt = Oe.mul(ce.b), ht = st.mul(Ce.b), yt = pe.sub(at).sub(lt), vt = pt.add(ht).neg();
    return { k1: yt, k2: vt };
  }, V.prototype.pointFromX = function(pe, ne) {
    pe = new L(pe, 16), pe.red || (pe = pe.toRed(this.red));
    var ce = pe.redSqr().redMul(pe).redIAdd(pe.redMul(this.a)).redIAdd(this.b), Ce = ce.redSqrt();
    if (Ce.redSqr().redSub(ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Oe = Ce.fromRed().isOdd();
    return (ne && !Oe || !ne && Oe) && (Ce = Ce.redNeg()), this.point(pe, Ce);
  }, V.prototype.validate = function(pe) {
    if (pe.inf)
      return !0;
    var ne = pe.x, ce = pe.y, Ce = this.a.redMul(ne), Oe = ne.redSqr().redMul(ne).redIAdd(Ce).redIAdd(this.b);
    return ce.redSqr().redISub(Oe).cmpn(0) === 0;
  }, V.prototype._endoWnafMulAdd = function(pe, ne, ce) {
    for (var Ce = this._endoWnafT1, Oe = this._endoWnafT2, st = 0; st < pe.length; st++) {
      var at = this._endoSplit(ne[st]), lt = pe[st], pt = lt._getBeta();
      at.k1.negative && (at.k1.ineg(), lt = lt.neg(!0)), at.k2.negative && (at.k2.ineg(), pt = pt.neg(!0)), Ce[st * 2] = lt, Ce[st * 2 + 1] = pt, Oe[st * 2] = at.k1, Oe[st * 2 + 1] = at.k2;
    }
    for (var ht = this._wnafMulAdd(1, Ce, Oe, st * 2, ce), yt = 0; yt < st * 2; yt++)
      Ce[yt] = null, Oe[yt] = null;
    return ht;
  };
  function re(oe, pe, ne, ce) {
    K.BasePoint.call(this, oe, "affine"), pe === null && ne === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new L(pe, 16), this.y = new L(ne, 16), ce && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  W(re, K.BasePoint), V.prototype.point = function(pe, ne, ce) {
    return new re(this, pe, ne, ce);
  }, V.prototype.pointFromJSON = function(pe, ne) {
    return re.fromJSON(this, pe, ne);
  }, re.prototype._getBeta = function() {
    if (this.curve.endo) {
      var pe = this.precomputed;
      if (pe && pe.beta)
        return pe.beta;
      var ne = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pe) {
        var ce = this.curve, Ce = function(Oe) {
          return ce.point(Oe.x.redMul(ce.endo.beta), Oe.y);
        };
        pe.beta = ne, ne.precomputed = {
          beta: null,
          naf: pe.naf && {
            wnd: pe.naf.wnd,
            points: pe.naf.points.map(Ce)
          },
          doubles: pe.doubles && {
            step: pe.doubles.step,
            points: pe.doubles.points.map(Ce)
          }
        };
      }
      return ne;
    }
  }, re.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, re.fromJSON = function(pe, ne, ce) {
    typeof ne == "string" && (ne = JSON.parse(ne));
    var Ce = pe.point(ne[0], ne[1], ce);
    if (!ne[2])
      return Ce;
    function Oe(at) {
      return pe.point(at[0], at[1], ce);
    }
    var st = ne[2];
    return Ce.precomputed = {
      beta: null,
      doubles: st.doubles && {
        step: st.doubles.step,
        points: [Ce].concat(st.doubles.points.map(Oe))
      },
      naf: st.naf && {
        wnd: st.naf.wnd,
        points: [Ce].concat(st.naf.points.map(Oe))
      }
    }, Ce;
  }, re.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, re.prototype.isInfinity = function() {
    return this.inf;
  }, re.prototype.add = function(pe) {
    if (this.inf)
      return pe;
    if (pe.inf)
      return this;
    if (this.eq(pe))
      return this.dbl();
    if (this.neg().eq(pe))
      return this.curve.point(null, null);
    if (this.x.cmp(pe.x) === 0)
      return this.curve.point(null, null);
    var ne = this.y.redSub(pe.y);
    ne.cmpn(0) !== 0 && (ne = ne.redMul(this.x.redSub(pe.x).redInvm()));
    var ce = ne.redSqr().redISub(this.x).redISub(pe.x), Ce = ne.redMul(this.x.redSub(ce)).redISub(this.y);
    return this.curve.point(ce, Ce);
  }, re.prototype.dbl = function() {
    if (this.inf)
      return this;
    var pe = this.y.redAdd(this.y);
    if (pe.cmpn(0) === 0)
      return this.curve.point(null, null);
    var ne = this.curve.a, ce = this.x.redSqr(), Ce = pe.redInvm(), Oe = ce.redAdd(ce).redIAdd(ce).redIAdd(ne).redMul(Ce), st = Oe.redSqr().redISub(this.x.redAdd(this.x)), at = Oe.redMul(this.x.redSub(st)).redISub(this.y);
    return this.curve.point(st, at);
  }, re.prototype.getX = function() {
    return this.x.fromRed();
  }, re.prototype.getY = function() {
    return this.y.fromRed();
  }, re.prototype.mul = function(pe) {
    return pe = new L(pe, 16), this.isInfinity() ? this : this._hasDoubles(pe) ? this.curve._fixedNafMul(this, pe) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [pe]) : this.curve._wnafMul(this, pe);
  }, re.prototype.mulAdd = function(pe, ne, ce) {
    var Ce = [this, ne], Oe = [pe, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ce, Oe) : this.curve._wnafMulAdd(1, Ce, Oe, 2);
  }, re.prototype.jmulAdd = function(pe, ne, ce) {
    var Ce = [this, ne], Oe = [pe, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ce, Oe, !0) : this.curve._wnafMulAdd(1, Ce, Oe, 2, !0);
  }, re.prototype.eq = function(pe) {
    return this === pe || this.inf === pe.inf && (this.inf || this.x.cmp(pe.x) === 0 && this.y.cmp(pe.y) === 0);
  }, re.prototype.neg = function(pe) {
    if (this.inf)
      return this;
    var ne = this.curve.point(this.x, this.y.redNeg());
    if (pe && this.precomputed) {
      var ce = this.precomputed, Ce = function(Oe) {
        return Oe.neg();
      };
      ne.precomputed = {
        naf: ce.naf && {
          wnd: ce.naf.wnd,
          points: ce.naf.points.map(Ce)
        },
        doubles: ce.doubles && {
          step: ce.doubles.step,
          points: ce.doubles.points.map(Ce)
        }
      };
    }
    return ne;
  }, re.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var pe = this.curve.jpoint(this.x, this.y, this.curve.one);
    return pe;
  };
  function ie(oe, pe, ne, ce) {
    K.BasePoint.call(this, oe, "jacobian"), pe === null && ne === null && ce === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new L(0)) : (this.x = new L(pe, 16), this.y = new L(ne, 16), this.z = new L(ce, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return W(ie, K.BasePoint), V.prototype.jpoint = function(pe, ne, ce) {
    return new ie(this, pe, ne, ce);
  }, ie.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var pe = this.z.redInvm(), ne = pe.redSqr(), ce = this.x.redMul(ne), Ce = this.y.redMul(ne).redMul(pe);
    return this.curve.point(ce, Ce);
  }, ie.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ie.prototype.add = function(pe) {
    if (this.isInfinity())
      return pe;
    if (pe.isInfinity())
      return this;
    var ne = pe.z.redSqr(), ce = this.z.redSqr(), Ce = this.x.redMul(ne), Oe = pe.x.redMul(ce), st = this.y.redMul(ne.redMul(pe.z)), at = pe.y.redMul(ce.redMul(this.z)), lt = Ce.redSub(Oe), pt = st.redSub(at);
    if (lt.cmpn(0) === 0)
      return pt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var ht = lt.redSqr(), yt = ht.redMul(lt), vt = Ce.redMul(ht), $t = pt.redSqr().redIAdd(yt).redISub(vt).redISub(vt), xt = pt.redMul(vt.redISub($t)).redISub(st.redMul(yt)), Ct = this.z.redMul(pe.z).redMul(lt);
    return this.curve.jpoint($t, xt, Ct);
  }, ie.prototype.mixedAdd = function(pe) {
    if (this.isInfinity())
      return pe.toJ();
    if (pe.isInfinity())
      return this;
    var ne = this.z.redSqr(), ce = this.x, Ce = pe.x.redMul(ne), Oe = this.y, st = pe.y.redMul(ne).redMul(this.z), at = ce.redSub(Ce), lt = Oe.redSub(st);
    if (at.cmpn(0) === 0)
      return lt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var pt = at.redSqr(), ht = pt.redMul(at), yt = ce.redMul(pt), vt = lt.redSqr().redIAdd(ht).redISub(yt).redISub(yt), $t = lt.redMul(yt.redISub(vt)).redISub(Oe.redMul(ht)), xt = this.z.redMul(at);
    return this.curve.jpoint(vt, $t, xt);
  }, ie.prototype.dblp = function(pe) {
    if (pe === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pe)
      return this.dbl();
    var ne;
    if (this.curve.zeroA || this.curve.threeA) {
      var ce = this;
      for (ne = 0; ne < pe; ne++)
        ce = ce.dbl();
      return ce;
    }
    var Ce = this.curve.a, Oe = this.curve.tinv, st = this.x, at = this.y, lt = this.z, pt = lt.redSqr().redSqr(), ht = at.redAdd(at);
    for (ne = 0; ne < pe; ne++) {
      var yt = st.redSqr(), vt = ht.redSqr(), $t = vt.redSqr(), xt = yt.redAdd(yt).redIAdd(yt).redIAdd(Ce.redMul(pt)), Ct = st.redMul(vt), Et = xt.redSqr().redISub(Ct.redAdd(Ct)), St = Ct.redISub(Et), It = xt.redMul(St);
      It = It.redIAdd(It).redISub($t);
      var Tt = ht.redMul(lt);
      ne + 1 < pe && (pt = pt.redMul($t)), st = Et, lt = Tt, ht = It;
    }
    return this.curve.jpoint(st, ht.redMul(Oe), lt);
  }, ie.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ie.prototype._zeroDbl = function() {
    var pe, ne, ce;
    if (this.zOne) {
      var Ce = this.x.redSqr(), Oe = this.y.redSqr(), st = Oe.redSqr(), at = this.x.redAdd(Oe).redSqr().redISub(Ce).redISub(st);
      at = at.redIAdd(at);
      var lt = Ce.redAdd(Ce).redIAdd(Ce), pt = lt.redSqr().redISub(at).redISub(at), ht = st.redIAdd(st);
      ht = ht.redIAdd(ht), ht = ht.redIAdd(ht), pe = pt, ne = lt.redMul(at.redISub(pt)).redISub(ht), ce = this.y.redAdd(this.y);
    } else {
      var yt = this.x.redSqr(), vt = this.y.redSqr(), $t = vt.redSqr(), xt = this.x.redAdd(vt).redSqr().redISub(yt).redISub($t);
      xt = xt.redIAdd(xt);
      var Ct = yt.redAdd(yt).redIAdd(yt), Et = Ct.redSqr(), St = $t.redIAdd($t);
      St = St.redIAdd(St), St = St.redIAdd(St), pe = Et.redISub(xt).redISub(xt), ne = Ct.redMul(xt.redISub(pe)).redISub(St), ce = this.y.redMul(this.z), ce = ce.redIAdd(ce);
    }
    return this.curve.jpoint(pe, ne, ce);
  }, ie.prototype._threeDbl = function() {
    var pe, ne, ce;
    if (this.zOne) {
      var Ce = this.x.redSqr(), Oe = this.y.redSqr(), st = Oe.redSqr(), at = this.x.redAdd(Oe).redSqr().redISub(Ce).redISub(st);
      at = at.redIAdd(at);
      var lt = Ce.redAdd(Ce).redIAdd(Ce).redIAdd(this.curve.a), pt = lt.redSqr().redISub(at).redISub(at);
      pe = pt;
      var ht = st.redIAdd(st);
      ht = ht.redIAdd(ht), ht = ht.redIAdd(ht), ne = lt.redMul(at.redISub(pt)).redISub(ht), ce = this.y.redAdd(this.y);
    } else {
      var yt = this.z.redSqr(), vt = this.y.redSqr(), $t = this.x.redMul(vt), xt = this.x.redSub(yt).redMul(this.x.redAdd(yt));
      xt = xt.redAdd(xt).redIAdd(xt);
      var Ct = $t.redIAdd($t);
      Ct = Ct.redIAdd(Ct);
      var Et = Ct.redAdd(Ct);
      pe = xt.redSqr().redISub(Et), ce = this.y.redAdd(this.z).redSqr().redISub(vt).redISub(yt);
      var St = vt.redSqr();
      St = St.redIAdd(St), St = St.redIAdd(St), St = St.redIAdd(St), ne = xt.redMul(Ct.redISub(pe)).redISub(St);
    }
    return this.curve.jpoint(pe, ne, ce);
  }, ie.prototype._dbl = function() {
    var pe = this.curve.a, ne = this.x, ce = this.y, Ce = this.z, Oe = Ce.redSqr().redSqr(), st = ne.redSqr(), at = ce.redSqr(), lt = st.redAdd(st).redIAdd(st).redIAdd(pe.redMul(Oe)), pt = ne.redAdd(ne);
    pt = pt.redIAdd(pt);
    var ht = pt.redMul(at), yt = lt.redSqr().redISub(ht.redAdd(ht)), vt = ht.redISub(yt), $t = at.redSqr();
    $t = $t.redIAdd($t), $t = $t.redIAdd($t), $t = $t.redIAdd($t);
    var xt = lt.redMul(vt).redISub($t), Ct = ce.redAdd(ce).redMul(Ce);
    return this.curve.jpoint(yt, xt, Ct);
  }, ie.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var pe = this.x.redSqr(), ne = this.y.redSqr(), ce = this.z.redSqr(), Ce = ne.redSqr(), Oe = pe.redAdd(pe).redIAdd(pe), st = Oe.redSqr(), at = this.x.redAdd(ne).redSqr().redISub(pe).redISub(Ce);
    at = at.redIAdd(at), at = at.redAdd(at).redIAdd(at), at = at.redISub(st);
    var lt = at.redSqr(), pt = Ce.redIAdd(Ce);
    pt = pt.redIAdd(pt), pt = pt.redIAdd(pt), pt = pt.redIAdd(pt);
    var ht = Oe.redIAdd(at).redSqr().redISub(st).redISub(lt).redISub(pt), yt = ne.redMul(ht);
    yt = yt.redIAdd(yt), yt = yt.redIAdd(yt);
    var vt = this.x.redMul(lt).redISub(yt);
    vt = vt.redIAdd(vt), vt = vt.redIAdd(vt);
    var $t = this.y.redMul(ht.redMul(pt.redISub(ht)).redISub(at.redMul(lt)));
    $t = $t.redIAdd($t), $t = $t.redIAdd($t), $t = $t.redIAdd($t);
    var xt = this.z.redAdd(at).redSqr().redISub(ce).redISub(lt);
    return this.curve.jpoint(vt, $t, xt);
  }, ie.prototype.mul = function(pe, ne) {
    return pe = new L(pe, ne), this.curve._wnafMul(this, pe);
  }, ie.prototype.eq = function(pe) {
    if (pe.type === "affine")
      return this.eq(pe.toJ());
    if (this === pe)
      return !0;
    var ne = this.z.redSqr(), ce = pe.z.redSqr();
    if (this.x.redMul(ce).redISub(pe.x.redMul(ne)).cmpn(0) !== 0)
      return !1;
    var Ce = ne.redMul(this.z), Oe = ce.redMul(pe.z);
    return this.y.redMul(Oe).redISub(pe.y.redMul(Ce)).cmpn(0) === 0;
  }, ie.prototype.eqXToP = function(pe) {
    var ne = this.z.redSqr(), ce = pe.toRed(this.curve.red).redMul(ne);
    if (this.x.cmp(ce) === 0)
      return !0;
    for (var Ce = pe.clone(), Oe = this.curve.redN.redMul(ne); ; ) {
      if (Ce.iadd(this.curve.n), Ce.cmp(this.curve.p) >= 0)
        return !1;
      if (ce.redIAdd(Oe), this.x.cmp(ce) === 0)
        return !0;
    }
  }, ie.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ie.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var B = requireBn$1(), L = requireInherits_browser(), W = requireBase$1(), K = requireUtils$1();
  function J(re) {
    W.call(this, "mont", re), this.a = new B(re.a, 16).toRed(this.red), this.b = new B(re.b, 16).toRed(this.red), this.i4 = new B(4).toRed(this.red).redInvm(), this.two = new B(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  L(J, W), mont = J, J.prototype.validate = function(ie) {
    var oe = ie.normalize().x, pe = oe.redSqr(), ne = pe.redMul(oe).redAdd(pe.redMul(this.a)).redAdd(oe), ce = ne.redSqrt();
    return ce.redSqr().cmp(ne) === 0;
  };
  function V(re, ie, oe) {
    W.BasePoint.call(this, re, "projective"), ie === null && oe === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new B(ie, 16), this.z = new B(oe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return L(V, W.BasePoint), J.prototype.decodePoint = function(ie, oe) {
    return this.point(K.toArray(ie, oe), 1);
  }, J.prototype.point = function(ie, oe) {
    return new V(this, ie, oe);
  }, J.prototype.pointFromJSON = function(ie) {
    return V.fromJSON(this, ie);
  }, V.prototype.precompute = function() {
  }, V.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, V.fromJSON = function(ie, oe) {
    return new V(ie, oe[0], oe[1] || ie.one);
  }, V.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, V.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, V.prototype.dbl = function() {
    var ie = this.x.redAdd(this.z), oe = ie.redSqr(), pe = this.x.redSub(this.z), ne = pe.redSqr(), ce = oe.redSub(ne), Ce = oe.redMul(ne), Oe = ce.redMul(ne.redAdd(this.curve.a24.redMul(ce)));
    return this.curve.point(Ce, Oe);
  }, V.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, V.prototype.diffAdd = function(ie, oe) {
    var pe = this.x.redAdd(this.z), ne = this.x.redSub(this.z), ce = ie.x.redAdd(ie.z), Ce = ie.x.redSub(ie.z), Oe = Ce.redMul(pe), st = ce.redMul(ne), at = oe.z.redMul(Oe.redAdd(st).redSqr()), lt = oe.x.redMul(Oe.redISub(st).redSqr());
    return this.curve.point(at, lt);
  }, V.prototype.mul = function(ie) {
    for (var oe = ie.clone(), pe = this, ne = this.curve.point(null, null), ce = this, Ce = []; oe.cmpn(0) !== 0; oe.iushrn(1))
      Ce.push(oe.andln(1));
    for (var Oe = Ce.length - 1; Oe >= 0; Oe--)
      Ce[Oe] === 0 ? (pe = pe.diffAdd(ne, ce), ne = ne.dbl()) : (ne = pe.diffAdd(ne, ce), pe = pe.dbl());
    return ne;
  }, V.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, V.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, V.prototype.eq = function(ie) {
    return this.getX().cmp(ie.getX()) === 0;
  }, V.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, V.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var B = requireUtils$1(), L = requireBn$1(), W = requireInherits_browser(), K = requireBase$1(), J = B.assert;
  function V(ie) {
    this.twisted = (ie.a | 0) !== 1, this.mOneA = this.twisted && (ie.a | 0) === -1, this.extended = this.mOneA, K.call(this, "edwards", ie), this.a = new L(ie.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new L(ie.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new L(ie.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), J(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ie.c | 0) === 1;
  }
  W(V, K), edwards = V, V.prototype._mulA = function(oe) {
    return this.mOneA ? oe.redNeg() : this.a.redMul(oe);
  }, V.prototype._mulC = function(oe) {
    return this.oneC ? oe : this.c.redMul(oe);
  }, V.prototype.jpoint = function(oe, pe, ne, ce) {
    return this.point(oe, pe, ne, ce);
  }, V.prototype.pointFromX = function(oe, pe) {
    oe = new L(oe, 16), oe.red || (oe = oe.toRed(this.red));
    var ne = oe.redSqr(), ce = this.c2.redSub(this.a.redMul(ne)), Ce = this.one.redSub(this.c2.redMul(this.d).redMul(ne)), Oe = ce.redMul(Ce.redInvm()), st = Oe.redSqrt();
    if (st.redSqr().redSub(Oe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var at = st.fromRed().isOdd();
    return (pe && !at || !pe && at) && (st = st.redNeg()), this.point(oe, st);
  }, V.prototype.pointFromY = function(oe, pe) {
    oe = new L(oe, 16), oe.red || (oe = oe.toRed(this.red));
    var ne = oe.redSqr(), ce = ne.redSub(this.c2), Ce = ne.redMul(this.d).redMul(this.c2).redSub(this.a), Oe = ce.redMul(Ce.redInvm());
    if (Oe.cmp(this.zero) === 0) {
      if (pe)
        throw new Error("invalid point");
      return this.point(this.zero, oe);
    }
    var st = Oe.redSqrt();
    if (st.redSqr().redSub(Oe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return st.fromRed().isOdd() !== pe && (st = st.redNeg()), this.point(st, oe);
  }, V.prototype.validate = function(oe) {
    if (oe.isInfinity())
      return !0;
    oe.normalize();
    var pe = oe.x.redSqr(), ne = oe.y.redSqr(), ce = pe.redMul(this.a).redAdd(ne), Ce = this.c2.redMul(this.one.redAdd(this.d.redMul(pe).redMul(ne)));
    return ce.cmp(Ce) === 0;
  };
  function re(ie, oe, pe, ne, ce) {
    K.BasePoint.call(this, ie, "projective"), oe === null && pe === null && ne === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new L(oe, 16), this.y = new L(pe, 16), this.z = ne ? new L(ne, 16) : this.curve.one, this.t = ce && new L(ce, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return W(re, K.BasePoint), V.prototype.pointFromJSON = function(oe) {
    return re.fromJSON(this, oe);
  }, V.prototype.point = function(oe, pe, ne, ce) {
    return new re(this, oe, pe, ne, ce);
  }, re.fromJSON = function(oe, pe) {
    return new re(oe, pe[0], pe[1], pe[2]);
  }, re.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, re.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, re.prototype._extDbl = function() {
    var oe = this.x.redSqr(), pe = this.y.redSqr(), ne = this.z.redSqr();
    ne = ne.redIAdd(ne);
    var ce = this.curve._mulA(oe), Ce = this.x.redAdd(this.y).redSqr().redISub(oe).redISub(pe), Oe = ce.redAdd(pe), st = Oe.redSub(ne), at = ce.redSub(pe), lt = Ce.redMul(st), pt = Oe.redMul(at), ht = Ce.redMul(at), yt = st.redMul(Oe);
    return this.curve.point(lt, pt, yt, ht);
  }, re.prototype._projDbl = function() {
    var oe = this.x.redAdd(this.y).redSqr(), pe = this.x.redSqr(), ne = this.y.redSqr(), ce, Ce, Oe, st, at, lt;
    if (this.curve.twisted) {
      st = this.curve._mulA(pe);
      var pt = st.redAdd(ne);
      this.zOne ? (ce = oe.redSub(pe).redSub(ne).redMul(pt.redSub(this.curve.two)), Ce = pt.redMul(st.redSub(ne)), Oe = pt.redSqr().redSub(pt).redSub(pt)) : (at = this.z.redSqr(), lt = pt.redSub(at).redISub(at), ce = oe.redSub(pe).redISub(ne).redMul(lt), Ce = pt.redMul(st.redSub(ne)), Oe = pt.redMul(lt));
    } else
      st = pe.redAdd(ne), at = this.curve._mulC(this.z).redSqr(), lt = st.redSub(at).redSub(at), ce = this.curve._mulC(oe.redISub(st)).redMul(lt), Ce = this.curve._mulC(st).redMul(pe.redISub(ne)), Oe = st.redMul(lt);
    return this.curve.point(ce, Ce, Oe);
  }, re.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, re.prototype._extAdd = function(oe) {
    var pe = this.y.redSub(this.x).redMul(oe.y.redSub(oe.x)), ne = this.y.redAdd(this.x).redMul(oe.y.redAdd(oe.x)), ce = this.t.redMul(this.curve.dd).redMul(oe.t), Ce = this.z.redMul(oe.z.redAdd(oe.z)), Oe = ne.redSub(pe), st = Ce.redSub(ce), at = Ce.redAdd(ce), lt = ne.redAdd(pe), pt = Oe.redMul(st), ht = at.redMul(lt), yt = Oe.redMul(lt), vt = st.redMul(at);
    return this.curve.point(pt, ht, vt, yt);
  }, re.prototype._projAdd = function(oe) {
    var pe = this.z.redMul(oe.z), ne = pe.redSqr(), ce = this.x.redMul(oe.x), Ce = this.y.redMul(oe.y), Oe = this.curve.d.redMul(ce).redMul(Ce), st = ne.redSub(Oe), at = ne.redAdd(Oe), lt = this.x.redAdd(this.y).redMul(oe.x.redAdd(oe.y)).redISub(ce).redISub(Ce), pt = pe.redMul(st).redMul(lt), ht, yt;
    return this.curve.twisted ? (ht = pe.redMul(at).redMul(Ce.redSub(this.curve._mulA(ce))), yt = st.redMul(at)) : (ht = pe.redMul(at).redMul(Ce.redSub(ce)), yt = this.curve._mulC(st).redMul(at)), this.curve.point(pt, ht, yt);
  }, re.prototype.add = function(oe) {
    return this.isInfinity() ? oe : oe.isInfinity() ? this : this.curve.extended ? this._extAdd(oe) : this._projAdd(oe);
  }, re.prototype.mul = function(oe) {
    return this._hasDoubles(oe) ? this.curve._fixedNafMul(this, oe) : this.curve._wnafMul(this, oe);
  }, re.prototype.mulAdd = function(oe, pe, ne) {
    return this.curve._wnafMulAdd(1, [this, pe], [oe, ne], 2, !1);
  }, re.prototype.jmulAdd = function(oe, pe, ne) {
    return this.curve._wnafMulAdd(1, [this, pe], [oe, ne], 2, !0);
  }, re.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var oe = this.z.redInvm();
    return this.x = this.x.redMul(oe), this.y = this.y.redMul(oe), this.t && (this.t = this.t.redMul(oe)), this.z = this.curve.one, this.zOne = !0, this;
  }, re.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, re.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, re.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, re.prototype.eq = function(oe) {
    return this === oe || this.getX().cmp(oe.getX()) === 0 && this.getY().cmp(oe.getY()) === 0;
  }, re.prototype.eqXToP = function(oe) {
    var pe = oe.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(pe) === 0)
      return !0;
    for (var ne = oe.clone(), ce = this.curve.redN.redMul(this.z); ; ) {
      if (ne.iadd(this.curve.n), ne.cmp(this.curve.p) >= 0)
        return !1;
      if (pe.redIAdd(ce), this.x.cmp(pe) === 0)
        return !0;
    }
  }, re.prototype.toP = re.prototype.normalize, re.prototype.mixedAdd = re.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(B) {
    var L = B;
    L.base = requireBase$1(), L.short = requireShort(), L.mont = requireMont(), L.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser();
  utils.inherits = L;
  function W(nt, it) {
    return (nt.charCodeAt(it) & 64512) !== 55296 || it < 0 || it + 1 >= nt.length ? !1 : (nt.charCodeAt(it + 1) & 64512) === 56320;
  }
  function K(nt, it) {
    if (Array.isArray(nt))
      return nt.slice();
    if (!nt)
      return [];
    var ke = [];
    if (typeof nt == "string")
      if (it) {
        if (it === "hex")
          for (nt = nt.replace(/[^a-z0-9]+/ig, ""), nt.length % 2 !== 0 && (nt = "0" + nt), ot = 0; ot < nt.length; ot += 2)
            ke.push(parseInt(nt[ot] + nt[ot + 1], 16));
      } else for (var rt = 0, ot = 0; ot < nt.length; ot++) {
        var ft = nt.charCodeAt(ot);
        ft < 128 ? ke[rt++] = ft : ft < 2048 ? (ke[rt++] = ft >> 6 | 192, ke[rt++] = ft & 63 | 128) : W(nt, ot) ? (ft = 65536 + ((ft & 1023) << 10) + (nt.charCodeAt(++ot) & 1023), ke[rt++] = ft >> 18 | 240, ke[rt++] = ft >> 12 & 63 | 128, ke[rt++] = ft >> 6 & 63 | 128, ke[rt++] = ft & 63 | 128) : (ke[rt++] = ft >> 12 | 224, ke[rt++] = ft >> 6 & 63 | 128, ke[rt++] = ft & 63 | 128);
      }
    else
      for (ot = 0; ot < nt.length; ot++)
        ke[ot] = nt[ot] | 0;
    return ke;
  }
  utils.toArray = K;
  function J(nt) {
    for (var it = "", ke = 0; ke < nt.length; ke++)
      it += ie(nt[ke].toString(16));
    return it;
  }
  utils.toHex = J;
  function V(nt) {
    var it = nt >>> 24 | nt >>> 8 & 65280 | nt << 8 & 16711680 | (nt & 255) << 24;
    return it >>> 0;
  }
  utils.htonl = V;
  function re(nt, it) {
    for (var ke = "", rt = 0; rt < nt.length; rt++) {
      var ot = nt[rt];
      it === "little" && (ot = V(ot)), ke += oe(ot.toString(16));
    }
    return ke;
  }
  utils.toHex32 = re;
  function ie(nt) {
    return nt.length === 1 ? "0" + nt : nt;
  }
  utils.zero2 = ie;
  function oe(nt) {
    return nt.length === 7 ? "0" + nt : nt.length === 6 ? "00" + nt : nt.length === 5 ? "000" + nt : nt.length === 4 ? "0000" + nt : nt.length === 3 ? "00000" + nt : nt.length === 2 ? "000000" + nt : nt.length === 1 ? "0000000" + nt : nt;
  }
  utils.zero8 = oe;
  function pe(nt, it, ke, rt) {
    var ot = ke - it;
    B(ot % 4 === 0);
    for (var ft = new Array(ot / 4), ct = 0, bt = it; ct < ft.length; ct++, bt += 4) {
      var ut;
      rt === "big" ? ut = nt[bt] << 24 | nt[bt + 1] << 16 | nt[bt + 2] << 8 | nt[bt + 3] : ut = nt[bt + 3] << 24 | nt[bt + 2] << 16 | nt[bt + 1] << 8 | nt[bt], ft[ct] = ut >>> 0;
    }
    return ft;
  }
  utils.join32 = pe;
  function ne(nt, it) {
    for (var ke = new Array(nt.length * 4), rt = 0, ot = 0; rt < nt.length; rt++, ot += 4) {
      var ft = nt[rt];
      it === "big" ? (ke[ot] = ft >>> 24, ke[ot + 1] = ft >>> 16 & 255, ke[ot + 2] = ft >>> 8 & 255, ke[ot + 3] = ft & 255) : (ke[ot + 3] = ft >>> 24, ke[ot + 2] = ft >>> 16 & 255, ke[ot + 1] = ft >>> 8 & 255, ke[ot] = ft & 255);
    }
    return ke;
  }
  utils.split32 = ne;
  function ce(nt, it) {
    return nt >>> it | nt << 32 - it;
  }
  utils.rotr32 = ce;
  function Ce(nt, it) {
    return nt << it | nt >>> 32 - it;
  }
  utils.rotl32 = Ce;
  function Oe(nt, it) {
    return nt + it >>> 0;
  }
  utils.sum32 = Oe;
  function st(nt, it, ke) {
    return nt + it + ke >>> 0;
  }
  utils.sum32_3 = st;
  function at(nt, it, ke, rt) {
    return nt + it + ke + rt >>> 0;
  }
  utils.sum32_4 = at;
  function lt(nt, it, ke, rt, ot) {
    return nt + it + ke + rt + ot >>> 0;
  }
  utils.sum32_5 = lt;
  function pt(nt, it, ke, rt) {
    var ot = nt[it], ft = nt[it + 1], ct = rt + ft >>> 0, bt = (ct < rt ? 1 : 0) + ke + ot;
    nt[it] = bt >>> 0, nt[it + 1] = ct;
  }
  utils.sum64 = pt;
  function ht(nt, it, ke, rt) {
    var ot = it + rt >>> 0, ft = (ot < it ? 1 : 0) + nt + ke;
    return ft >>> 0;
  }
  utils.sum64_hi = ht;
  function yt(nt, it, ke, rt) {
    var ot = it + rt;
    return ot >>> 0;
  }
  utils.sum64_lo = yt;
  function vt(nt, it, ke, rt, ot, ft, ct, bt) {
    var ut = 0, gt = it;
    gt = gt + rt >>> 0, ut += gt < it ? 1 : 0, gt = gt + ft >>> 0, ut += gt < ft ? 1 : 0, gt = gt + bt >>> 0, ut += gt < bt ? 1 : 0;
    var dt = nt + ke + ot + ct + ut;
    return dt >>> 0;
  }
  utils.sum64_4_hi = vt;
  function $t(nt, it, ke, rt, ot, ft, ct, bt) {
    var ut = it + rt + ft + bt;
    return ut >>> 0;
  }
  utils.sum64_4_lo = $t;
  function xt(nt, it, ke, rt, ot, ft, ct, bt, ut, gt) {
    var dt = 0, wt = it;
    wt = wt + rt >>> 0, dt += wt < it ? 1 : 0, wt = wt + ft >>> 0, dt += wt < ft ? 1 : 0, wt = wt + bt >>> 0, dt += wt < bt ? 1 : 0, wt = wt + gt >>> 0, dt += wt < gt ? 1 : 0;
    var Ft = nt + ke + ot + ct + ut + dt;
    return Ft >>> 0;
  }
  utils.sum64_5_hi = xt;
  function Ct(nt, it, ke, rt, ot, ft, ct, bt, ut, gt) {
    var dt = it + rt + ft + bt + gt;
    return dt >>> 0;
  }
  utils.sum64_5_lo = Ct;
  function Et(nt, it, ke) {
    var rt = it << 32 - ke | nt >>> ke;
    return rt >>> 0;
  }
  utils.rotr64_hi = Et;
  function St(nt, it, ke) {
    var rt = nt << 32 - ke | it >>> ke;
    return rt >>> 0;
  }
  utils.rotr64_lo = St;
  function It(nt, it, ke) {
    return nt >>> ke;
  }
  utils.shr64_hi = It;
  function Tt(nt, it, ke) {
    var rt = nt << 32 - ke | it >>> ke;
    return rt >>> 0;
  }
  return utils.shr64_lo = Tt, utils;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var B = requireUtils(), L = requireMinimalisticAssert();
  function W() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = W, W.prototype.update = function(J, V) {
    if (J = B.toArray(J, V), this.pending ? this.pending = this.pending.concat(J) : this.pending = J, this.pendingTotal += J.length, this.pending.length >= this._delta8) {
      J = this.pending;
      var re = J.length % this._delta8;
      this.pending = J.slice(J.length - re, J.length), this.pending.length === 0 && (this.pending = null), J = B.join32(J, 0, J.length - re, this.endian);
      for (var ie = 0; ie < J.length; ie += this._delta32)
        this._update(J, ie, ie + this._delta32);
    }
    return this;
  }, W.prototype.digest = function(J) {
    return this.update(this._pad()), L(this.pending === null), this._digest(J);
  }, W.prototype._pad = function() {
    var J = this.pendingTotal, V = this._delta8, re = V - (J + this.padLength) % V, ie = new Array(re + this.padLength);
    ie[0] = 128;
    for (var oe = 1; oe < re; oe++)
      ie[oe] = 0;
    if (J <<= 3, this.endian === "big") {
      for (var pe = 8; pe < this.padLength; pe++)
        ie[oe++] = 0;
      ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = J >>> 24 & 255, ie[oe++] = J >>> 16 & 255, ie[oe++] = J >>> 8 & 255, ie[oe++] = J & 255;
    } else
      for (ie[oe++] = J & 255, ie[oe++] = J >>> 8 & 255, ie[oe++] = J >>> 16 & 255, ie[oe++] = J >>> 24 & 255, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, pe = 8; pe < this.padLength; pe++)
        ie[oe++] = 0;
    return ie;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var B = requireUtils(), L = B.rotr32;
  function W(ne, ce, Ce, Oe) {
    if (ne === 0)
      return K(ce, Ce, Oe);
    if (ne === 1 || ne === 3)
      return V(ce, Ce, Oe);
    if (ne === 2)
      return J(ce, Ce, Oe);
  }
  common.ft_1 = W;
  function K(ne, ce, Ce) {
    return ne & ce ^ ~ne & Ce;
  }
  common.ch32 = K;
  function J(ne, ce, Ce) {
    return ne & ce ^ ne & Ce ^ ce & Ce;
  }
  common.maj32 = J;
  function V(ne, ce, Ce) {
    return ne ^ ce ^ Ce;
  }
  common.p32 = V;
  function re(ne) {
    return L(ne, 2) ^ L(ne, 13) ^ L(ne, 22);
  }
  common.s0_256 = re;
  function ie(ne) {
    return L(ne, 6) ^ L(ne, 11) ^ L(ne, 25);
  }
  common.s1_256 = ie;
  function oe(ne) {
    return L(ne, 7) ^ L(ne, 18) ^ ne >>> 3;
  }
  common.g0_256 = oe;
  function pe(ne) {
    return L(ne, 17) ^ L(ne, 19) ^ ne >>> 10;
  }
  return common.g1_256 = pe, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var B = requireUtils(), L = requireCommon$1(), W = requireCommon(), K = B.rotl32, J = B.sum32, V = B.sum32_5, re = W.ft_1, ie = L.BlockHash, oe = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function pe() {
    if (!(this instanceof pe))
      return new pe();
    ie.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return B.inherits(pe, ie), _1 = pe, pe.blockSize = 512, pe.outSize = 160, pe.hmacStrength = 80, pe.padLength = 64, pe.prototype._update = function(ce, Ce) {
    for (var Oe = this.W, st = 0; st < 16; st++)
      Oe[st] = ce[Ce + st];
    for (; st < Oe.length; st++)
      Oe[st] = K(Oe[st - 3] ^ Oe[st - 8] ^ Oe[st - 14] ^ Oe[st - 16], 1);
    var at = this.h[0], lt = this.h[1], pt = this.h[2], ht = this.h[3], yt = this.h[4];
    for (st = 0; st < Oe.length; st++) {
      var vt = ~~(st / 20), $t = V(K(at, 5), re(vt, lt, pt, ht), yt, Oe[st], oe[vt]);
      yt = ht, ht = pt, pt = K(lt, 30), lt = at, at = $t;
    }
    this.h[0] = J(this.h[0], at), this.h[1] = J(this.h[1], lt), this.h[2] = J(this.h[2], pt), this.h[3] = J(this.h[3], ht), this.h[4] = J(this.h[4], yt);
  }, pe.prototype._digest = function(ce) {
    return ce === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var B = requireUtils(), L = requireCommon$1(), W = requireCommon(), K = requireMinimalisticAssert(), J = B.sum32, V = B.sum32_4, re = B.sum32_5, ie = W.ch32, oe = W.maj32, pe = W.s0_256, ne = W.s1_256, ce = W.g0_256, Ce = W.g1_256, Oe = L.BlockHash, st = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function at() {
    if (!(this instanceof at))
      return new at();
    Oe.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = st, this.W = new Array(64);
  }
  return B.inherits(at, Oe), _256 = at, at.blockSize = 512, at.outSize = 256, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(pt, ht) {
    for (var yt = this.W, vt = 0; vt < 16; vt++)
      yt[vt] = pt[ht + vt];
    for (; vt < yt.length; vt++)
      yt[vt] = V(Ce(yt[vt - 2]), yt[vt - 7], ce(yt[vt - 15]), yt[vt - 16]);
    var $t = this.h[0], xt = this.h[1], Ct = this.h[2], Et = this.h[3], St = this.h[4], It = this.h[5], Tt = this.h[6], nt = this.h[7];
    for (K(this.k.length === yt.length), vt = 0; vt < yt.length; vt++) {
      var it = re(nt, ne(St), ie(St, It, Tt), this.k[vt], yt[vt]), ke = J(pe($t), oe($t, xt, Ct));
      nt = Tt, Tt = It, It = St, St = J(Et, it), Et = Ct, Ct = xt, xt = $t, $t = J(it, ke);
    }
    this.h[0] = J(this.h[0], $t), this.h[1] = J(this.h[1], xt), this.h[2] = J(this.h[2], Ct), this.h[3] = J(this.h[3], Et), this.h[4] = J(this.h[4], St), this.h[5] = J(this.h[5], It), this.h[6] = J(this.h[6], Tt), this.h[7] = J(this.h[7], nt);
  }, at.prototype._digest = function(pt) {
    return pt === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var B = requireUtils(), L = require_256();
  function W() {
    if (!(this instanceof W))
      return new W();
    L.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return B.inherits(W, L), _224 = W, W.blockSize = 512, W.outSize = 224, W.hmacStrength = 192, W.padLength = 64, W.prototype._digest = function(J) {
    return J === "hex" ? B.toHex32(this.h.slice(0, 7), "big") : B.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var B = requireUtils(), L = requireCommon$1(), W = requireMinimalisticAssert(), K = B.rotr64_hi, J = B.rotr64_lo, V = B.shr64_hi, re = B.shr64_lo, ie = B.sum64, oe = B.sum64_hi, pe = B.sum64_lo, ne = B.sum64_4_hi, ce = B.sum64_4_lo, Ce = B.sum64_5_hi, Oe = B.sum64_5_lo, st = L.BlockHash, at = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function lt() {
    if (!(this instanceof lt))
      return new lt();
    st.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = at, this.W = new Array(160);
  }
  B.inherits(lt, st), _512 = lt, lt.blockSize = 1024, lt.outSize = 512, lt.hmacStrength = 192, lt.padLength = 128, lt.prototype._prepareBlock = function(ke, rt) {
    for (var ot = this.W, ft = 0; ft < 32; ft++)
      ot[ft] = ke[rt + ft];
    for (; ft < ot.length; ft += 2) {
      var ct = Tt(ot[ft - 4], ot[ft - 3]), bt = nt(ot[ft - 4], ot[ft - 3]), ut = ot[ft - 14], gt = ot[ft - 13], dt = St(ot[ft - 30], ot[ft - 29]), wt = It(ot[ft - 30], ot[ft - 29]), Ft = ot[ft - 32], jt = ot[ft - 31];
      ot[ft] = ne(
        ct,
        bt,
        ut,
        gt,
        dt,
        wt,
        Ft,
        jt
      ), ot[ft + 1] = ce(
        ct,
        bt,
        ut,
        gt,
        dt,
        wt,
        Ft,
        jt
      );
    }
  }, lt.prototype._update = function(ke, rt) {
    this._prepareBlock(ke, rt);
    var ot = this.W, ft = this.h[0], ct = this.h[1], bt = this.h[2], ut = this.h[3], gt = this.h[4], dt = this.h[5], wt = this.h[6], Ft = this.h[7], jt = this.h[8], Nt = this.h[9], Bt = this.h[10], Rt = this.h[11], Ut = this.h[12], zt = this.h[13], Mt = this.h[14], kt = this.h[15];
    W(this.k.length === ot.length);
    for (var Gt = 0; Gt < ot.length; Gt += 2) {
      var Qt = Mt, nr = kt, ar = Ct(jt, Nt), cr = Et(jt, Nt), hr = pt(jt, Nt, Bt, Rt, Ut), Jt = ht(jt, Nt, Bt, Rt, Ut, zt), Pr = this.k[Gt], dr = this.k[Gt + 1], Tr = ot[Gt], Rr = ot[Gt + 1], pr = Ce(
        Qt,
        nr,
        ar,
        cr,
        hr,
        Jt,
        Pr,
        dr,
        Tr,
        Rr
      ), $r = Oe(
        Qt,
        nr,
        ar,
        cr,
        hr,
        Jt,
        Pr,
        dr,
        Tr,
        Rr
      );
      Qt = $t(ft, ct), nr = xt(ft, ct), ar = yt(ft, ct, bt, ut, gt), cr = vt(ft, ct, bt, ut, gt, dt);
      var kr = oe(Qt, nr, ar, cr), vr = pe(Qt, nr, ar, cr);
      Mt = Ut, kt = zt, Ut = Bt, zt = Rt, Bt = jt, Rt = Nt, jt = oe(wt, Ft, pr, $r), Nt = pe(Ft, Ft, pr, $r), wt = gt, Ft = dt, gt = bt, dt = ut, bt = ft, ut = ct, ft = oe(pr, $r, kr, vr), ct = pe(pr, $r, kr, vr);
    }
    ie(this.h, 0, ft, ct), ie(this.h, 2, bt, ut), ie(this.h, 4, gt, dt), ie(this.h, 6, wt, Ft), ie(this.h, 8, jt, Nt), ie(this.h, 10, Bt, Rt), ie(this.h, 12, Ut, zt), ie(this.h, 14, Mt, kt);
  }, lt.prototype._digest = function(ke) {
    return ke === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  };
  function pt(it, ke, rt, ot, ft) {
    var ct = it & rt ^ ~it & ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function ht(it, ke, rt, ot, ft, ct) {
    var bt = ke & ot ^ ~ke & ct;
    return bt < 0 && (bt += 4294967296), bt;
  }
  function yt(it, ke, rt, ot, ft) {
    var ct = it & rt ^ it & ft ^ rt & ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function vt(it, ke, rt, ot, ft, ct) {
    var bt = ke & ot ^ ke & ct ^ ot & ct;
    return bt < 0 && (bt += 4294967296), bt;
  }
  function $t(it, ke) {
    var rt = K(it, ke, 28), ot = K(ke, it, 2), ft = K(ke, it, 7), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function xt(it, ke) {
    var rt = J(it, ke, 28), ot = J(ke, it, 2), ft = J(ke, it, 7), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function Ct(it, ke) {
    var rt = K(it, ke, 14), ot = K(it, ke, 18), ft = K(ke, it, 9), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function Et(it, ke) {
    var rt = J(it, ke, 14), ot = J(it, ke, 18), ft = J(ke, it, 9), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function St(it, ke) {
    var rt = K(it, ke, 1), ot = K(it, ke, 8), ft = V(it, ke, 7), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function It(it, ke) {
    var rt = J(it, ke, 1), ot = J(it, ke, 8), ft = re(it, ke, 7), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function Tt(it, ke) {
    var rt = K(it, ke, 19), ot = K(ke, it, 29), ft = V(it, ke, 6), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  function nt(it, ke) {
    var rt = J(it, ke, 19), ot = J(ke, it, 29), ft = re(it, ke, 6), ct = rt ^ ot ^ ft;
    return ct < 0 && (ct += 4294967296), ct;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var B = requireUtils(), L = require_512();
  function W() {
    if (!(this instanceof W))
      return new W();
    L.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return B.inherits(W, L), _384 = W, W.blockSize = 1024, W.outSize = 384, W.hmacStrength = 192, W.padLength = 128, W.prototype._digest = function(J) {
    return J === "hex" ? B.toHex32(this.h.slice(0, 12), "big") : B.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var B = requireUtils(), L = requireCommon$1(), W = B.rotl32, K = B.sum32, J = B.sum32_3, V = B.sum32_4, re = L.BlockHash;
  function ie() {
    if (!(this instanceof ie))
      return new ie();
    re.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  B.inherits(ie, re), ripemd.ripemd160 = ie, ie.blockSize = 512, ie.outSize = 160, ie.hmacStrength = 192, ie.padLength = 64, ie.prototype._update = function(lt, pt) {
    for (var ht = this.h[0], yt = this.h[1], vt = this.h[2], $t = this.h[3], xt = this.h[4], Ct = ht, Et = yt, St = vt, It = $t, Tt = xt, nt = 0; nt < 80; nt++) {
      var it = K(
        W(
          V(ht, oe(nt, yt, vt, $t), lt[ce[nt] + pt], pe(nt)),
          Oe[nt]
        ),
        xt
      );
      ht = xt, xt = $t, $t = W(vt, 10), vt = yt, yt = it, it = K(
        W(
          V(Ct, oe(79 - nt, Et, St, It), lt[Ce[nt] + pt], ne(nt)),
          st[nt]
        ),
        Tt
      ), Ct = Tt, Tt = It, It = W(St, 10), St = Et, Et = it;
    }
    it = J(this.h[1], vt, It), this.h[1] = J(this.h[2], $t, Tt), this.h[2] = J(this.h[3], xt, Ct), this.h[3] = J(this.h[4], ht, Et), this.h[4] = J(this.h[0], yt, St), this.h[0] = it;
  }, ie.prototype._digest = function(lt) {
    return lt === "hex" ? B.toHex32(this.h, "little") : B.split32(this.h, "little");
  };
  function oe(at, lt, pt, ht) {
    return at <= 15 ? lt ^ pt ^ ht : at <= 31 ? lt & pt | ~lt & ht : at <= 47 ? (lt | ~pt) ^ ht : at <= 63 ? lt & ht | pt & ~ht : lt ^ (pt | ~ht);
  }
  function pe(at) {
    return at <= 15 ? 0 : at <= 31 ? 1518500249 : at <= 47 ? 1859775393 : at <= 63 ? 2400959708 : 2840853838;
  }
  function ne(at) {
    return at <= 15 ? 1352829926 : at <= 31 ? 1548603684 : at <= 47 ? 1836072691 : at <= 63 ? 2053994217 : 0;
  }
  var ce = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Ce = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Oe = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], st = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac$1, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac$1;
  hasRequiredHmac = 1;
  var B = requireUtils(), L = requireMinimalisticAssert();
  function W(K, J, V) {
    if (!(this instanceof W))
      return new W(K, J, V);
    this.Hash = K, this.blockSize = K.blockSize / 8, this.outSize = K.outSize / 8, this.inner = null, this.outer = null, this._init(B.toArray(J, V));
  }
  return hmac$1 = W, W.prototype._init = function(J) {
    J.length > this.blockSize && (J = new this.Hash().update(J).digest()), L(J.length <= this.blockSize);
    for (var V = J.length; V < this.blockSize; V++)
      J.push(0);
    for (V = 0; V < J.length; V++)
      J[V] ^= 54;
    for (this.inner = new this.Hash().update(J), V = 0; V < J.length; V++)
      J[V] ^= 106;
    this.outer = new this.Hash().update(J);
  }, W.prototype.update = function(J, V) {
    return this.inner.update(J, V), this;
  }, W.prototype.digest = function(J) {
    return this.outer.update(this.inner.digest()), this.outer.digest(J);
  }, hmac$1;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(B) {
    var L = B;
    L.utils = requireUtils(), L.common = requireCommon$1(), L.sha = requireSha(), L.ripemd = requireRipemd(), L.hmac = requireHmac(), L.sha1 = L.sha.sha1, L.sha256 = L.sha.sha256, L.sha224 = L.sha.sha224, L.sha384 = L.sha.sha384, L.sha512 = L.sha.sha512, L.ripemd160 = L.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1$1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1$1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1$1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(B) {
    var L = B, W = requireHash(), K = requireCurve(), J = requireUtils$1(), V = J.assert;
    function re(pe) {
      pe.type === "short" ? this.curve = new K.short(pe) : pe.type === "edwards" ? this.curve = new K.edwards(pe) : this.curve = new K.mont(pe), this.g = this.curve.g, this.n = this.curve.n, this.hash = pe.hash, V(this.g.validate(), "Invalid curve"), V(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    L.PresetCurve = re;
    function ie(pe, ne) {
      Object.defineProperty(L, pe, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var ce = new re(ne);
          return Object.defineProperty(L, pe, {
            configurable: !0,
            enumerable: !0,
            value: ce
          }), ce;
        }
      });
    }
    ie("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: W.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), ie("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: W.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), ie("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: W.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), ie("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: W.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), ie("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: W.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), ie("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: W.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), ie("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: W.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var oe;
    try {
      oe = requireSecp256k1();
    } catch {
      oe = void 0;
    }
    ie("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: W.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        oe
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var B = requireHash(), L = requireUtils$2(), W = requireMinimalisticAssert();
  function K(J) {
    if (!(this instanceof K))
      return new K(J);
    this.hash = J.hash, this.predResist = !!J.predResist, this.outLen = this.hash.outSize, this.minEntropy = J.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var V = L.toArray(J.entropy, J.entropyEnc || "hex"), re = L.toArray(J.nonce, J.nonceEnc || "hex"), ie = L.toArray(J.pers, J.persEnc || "hex");
    W(
      V.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(V, re, ie);
  }
  return hmacDrbg = K, K.prototype._init = function(V, re, ie) {
    var oe = V.concat(re).concat(ie);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var pe = 0; pe < this.V.length; pe++)
      this.K[pe] = 0, this.V[pe] = 1;
    this._update(oe), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, K.prototype._hmac = function() {
    return new B.hmac(this.hash, this.K);
  }, K.prototype._update = function(V) {
    var re = this._hmac().update(this.V).update([0]);
    V && (re = re.update(V)), this.K = re.digest(), this.V = this._hmac().update(this.V).digest(), V && (this.K = this._hmac().update(this.V).update([1]).update(V).digest(), this.V = this._hmac().update(this.V).digest());
  }, K.prototype.reseed = function(V, re, ie, oe) {
    typeof re != "string" && (oe = ie, ie = re, re = null), V = L.toArray(V, re), ie = L.toArray(ie, oe), W(
      V.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(V.concat(ie || [])), this._reseed = 1;
  }, K.prototype.generate = function(V, re, ie, oe) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof re != "string" && (oe = ie, ie = re, re = null), ie && (ie = L.toArray(ie, oe || "hex"), this._update(ie));
    for (var pe = []; pe.length < V; )
      this.V = this._hmac().update(this.V).digest(), pe = pe.concat(this.V);
    var ne = pe.slice(0, V);
    return this._update(ie), this._reseed++, L.encode(ne, re);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var B = requireBn$1(), L = requireUtils$1(), W = L.assert;
  function K(J, V) {
    this.ec = J, this.priv = null, this.pub = null, V.priv && this._importPrivate(V.priv, V.privEnc), V.pub && this._importPublic(V.pub, V.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(V, re, ie) {
    return re instanceof K ? re : new K(V, {
      pub: re,
      pubEnc: ie
    });
  }, K.fromPrivate = function(V, re, ie) {
    return re instanceof K ? re : new K(V, {
      priv: re,
      privEnc: ie
    });
  }, K.prototype.validate = function() {
    var V = this.getPublic();
    return V.isInfinity() ? { result: !1, reason: "Invalid public key" } : V.validate() ? V.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(V, re) {
    return typeof V == "string" && (re = V, V = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), re ? this.pub.encode(re, V) : this.pub;
  }, K.prototype.getPrivate = function(V) {
    return V === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(V, re) {
    this.priv = new B(V, re || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(V, re) {
    if (V.x || V.y) {
      this.ec.curve.type === "mont" ? W(V.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && W(V.x && V.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(V.x, V.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(V, re);
  }, K.prototype.derive = function(V) {
    return V.validate() || W(V.validate(), "public point not validated"), V.mul(this.priv).getX();
  }, K.prototype.sign = function(V, re, ie) {
    return this.ec.sign(V, this, re, ie);
  }, K.prototype.verify = function(V, re) {
    return this.ec.verify(V, re, this);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var B = requireBn$1(), L = requireUtils$1(), W = L.assert;
  function K(oe, pe) {
    if (oe instanceof K)
      return oe;
    this._importDER(oe, pe) || (W(oe.r && oe.s, "Signature without r or s"), this.r = new B(oe.r, 16), this.s = new B(oe.s, 16), oe.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = oe.recoveryParam);
  }
  signature$1 = K;
  function J() {
    this.place = 0;
  }
  function V(oe, pe) {
    var ne = oe[pe.place++];
    if (!(ne & 128))
      return ne;
    var ce = ne & 15;
    if (ce === 0 || ce > 4 || oe[pe.place] === 0)
      return !1;
    for (var Ce = 0, Oe = 0, st = pe.place; Oe < ce; Oe++, st++)
      Ce <<= 8, Ce |= oe[st], Ce >>>= 0;
    return Ce <= 127 ? !1 : (pe.place = st, Ce);
  }
  function re(oe) {
    for (var pe = 0, ne = oe.length - 1; !oe[pe] && !(oe[pe + 1] & 128) && pe < ne; )
      pe++;
    return pe === 0 ? oe : oe.slice(pe);
  }
  K.prototype._importDER = function(pe, ne) {
    pe = L.toArray(pe, ne);
    var ce = new J();
    if (pe[ce.place++] !== 48)
      return !1;
    var Ce = V(pe, ce);
    if (Ce === !1 || Ce + ce.place !== pe.length || pe[ce.place++] !== 2)
      return !1;
    var Oe = V(pe, ce);
    if (Oe === !1 || pe[ce.place] & 128)
      return !1;
    var st = pe.slice(ce.place, Oe + ce.place);
    if (ce.place += Oe, pe[ce.place++] !== 2)
      return !1;
    var at = V(pe, ce);
    if (at === !1 || pe.length !== at + ce.place || pe[ce.place] & 128)
      return !1;
    var lt = pe.slice(ce.place, at + ce.place);
    if (st[0] === 0)
      if (st[1] & 128)
        st = st.slice(1);
      else
        return !1;
    if (lt[0] === 0)
      if (lt[1] & 128)
        lt = lt.slice(1);
      else
        return !1;
    return this.r = new B(st), this.s = new B(lt), this.recoveryParam = null, !0;
  };
  function ie(oe, pe) {
    if (pe < 128) {
      oe.push(pe);
      return;
    }
    var ne = 1 + (Math.log(pe) / Math.LN2 >>> 3);
    for (oe.push(ne | 128); --ne; )
      oe.push(pe >>> (ne << 3) & 255);
    oe.push(pe);
  }
  return K.prototype.toDER = function(pe) {
    var ne = this.r.toArray(), ce = this.s.toArray();
    for (ne[0] & 128 && (ne = [0].concat(ne)), ce[0] & 128 && (ce = [0].concat(ce)), ne = re(ne), ce = re(ce); !ce[0] && !(ce[1] & 128); )
      ce = ce.slice(1);
    var Ce = [2];
    ie(Ce, ne.length), Ce = Ce.concat(ne), Ce.push(2), ie(Ce, ce.length);
    var Oe = Ce.concat(ce), st = [48];
    return ie(st, Oe.length), st = st.concat(Oe), L.encode(st, pe);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = requireBn$1(), L = requireHmacDrbg(), W = requireUtils$1(), K = requireCurves(), J = requireBrorand(), V = W.assert, re = requireKey$1(), ie = requireSignature$1();
  function oe(pe) {
    if (!(this instanceof oe))
      return new oe(pe);
    typeof pe == "string" && (V(
      Object.prototype.hasOwnProperty.call(K, pe),
      "Unknown curve " + pe
    ), pe = K[pe]), pe instanceof K.PresetCurve && (pe = { curve: pe }), this.curve = pe.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = pe.curve.g, this.g.precompute(pe.curve.n.bitLength() + 1), this.hash = pe.hash || pe.curve.hash;
  }
  return ec = oe, oe.prototype.keyPair = function(ne) {
    return new re(this, ne);
  }, oe.prototype.keyFromPrivate = function(ne, ce) {
    return re.fromPrivate(this, ne, ce);
  }, oe.prototype.keyFromPublic = function(ne, ce) {
    return re.fromPublic(this, ne, ce);
  }, oe.prototype.genKeyPair = function(ne) {
    ne || (ne = {});
    for (var ce = new L({
      hash: this.hash,
      pers: ne.pers,
      persEnc: ne.persEnc || "utf8",
      entropy: ne.entropy || J(this.hash.hmacStrength),
      entropyEnc: ne.entropy && ne.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Ce = this.n.byteLength(), Oe = this.n.sub(new B(2)); ; ) {
      var st = new B(ce.generate(Ce));
      if (!(st.cmp(Oe) > 0))
        return st.iaddn(1), this.keyFromPrivate(st);
    }
  }, oe.prototype._truncateToN = function(ne, ce) {
    var Ce = ne.byteLength() * 8 - this.n.bitLength();
    return Ce > 0 && (ne = ne.ushrn(Ce)), !ce && ne.cmp(this.n) >= 0 ? ne.sub(this.n) : ne;
  }, oe.prototype.sign = function(ne, ce, Ce, Oe) {
    typeof Ce == "object" && (Oe = Ce, Ce = null), Oe || (Oe = {}), ce = this.keyFromPrivate(ce, Ce), ne = this._truncateToN(new B(ne, 16));
    for (var st = this.n.byteLength(), at = ce.getPrivate().toArray("be", st), lt = ne.toArray("be", st), pt = new L({
      hash: this.hash,
      entropy: at,
      nonce: lt,
      pers: Oe.pers,
      persEnc: Oe.persEnc || "utf8"
    }), ht = this.n.sub(new B(1)), yt = 0; ; yt++) {
      var vt = Oe.k ? Oe.k(yt) : new B(pt.generate(this.n.byteLength()));
      if (vt = this._truncateToN(vt, !0), !(vt.cmpn(1) <= 0 || vt.cmp(ht) >= 0)) {
        var $t = this.g.mul(vt);
        if (!$t.isInfinity()) {
          var xt = $t.getX(), Ct = xt.umod(this.n);
          if (Ct.cmpn(0) !== 0) {
            var Et = vt.invm(this.n).mul(Ct.mul(ce.getPrivate()).iadd(ne));
            if (Et = Et.umod(this.n), Et.cmpn(0) !== 0) {
              var St = ($t.getY().isOdd() ? 1 : 0) | (xt.cmp(Ct) !== 0 ? 2 : 0);
              return Oe.canonical && Et.cmp(this.nh) > 0 && (Et = this.n.sub(Et), St ^= 1), new ie({ r: Ct, s: Et, recoveryParam: St });
            }
          }
        }
      }
    }
  }, oe.prototype.verify = function(ne, ce, Ce, Oe) {
    ne = this._truncateToN(new B(ne, 16)), Ce = this.keyFromPublic(Ce, Oe), ce = new ie(ce, "hex");
    var st = ce.r, at = ce.s;
    if (st.cmpn(1) < 0 || st.cmp(this.n) >= 0 || at.cmpn(1) < 0 || at.cmp(this.n) >= 0)
      return !1;
    var lt = at.invm(this.n), pt = lt.mul(ne).umod(this.n), ht = lt.mul(st).umod(this.n), yt;
    return this.curve._maxwellTrick ? (yt = this.g.jmulAdd(pt, Ce.getPublic(), ht), yt.isInfinity() ? !1 : yt.eqXToP(st)) : (yt = this.g.mulAdd(pt, Ce.getPublic(), ht), yt.isInfinity() ? !1 : yt.getX().umod(this.n).cmp(st) === 0);
  }, oe.prototype.recoverPubKey = function(pe, ne, ce, Ce) {
    V((3 & ce) === ce, "The recovery param is more than two bits"), ne = new ie(ne, Ce);
    var Oe = this.n, st = new B(pe), at = ne.r, lt = ne.s, pt = ce & 1, ht = ce >> 1;
    if (at.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ht)
      throw new Error("Unable to find sencond key candinate");
    ht ? at = this.curve.pointFromX(at.add(this.curve.n), pt) : at = this.curve.pointFromX(at, pt);
    var yt = ne.r.invm(Oe), vt = Oe.sub(st).mul(yt).umod(Oe), $t = lt.mul(yt).umod(Oe);
    return this.g.mulAdd(vt, at, $t);
  }, oe.prototype.getKeyRecoveryParam = function(pe, ne, ce, Ce) {
    if (ne = new ie(ne, Ce), ne.recoveryParam !== null)
      return ne.recoveryParam;
    for (var Oe = 0; Oe < 4; Oe++) {
      var st;
      try {
        st = this.recoverPubKey(pe, ne, Oe);
      } catch {
        continue;
      }
      if (st.eq(ce))
        return Oe;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var B = requireUtils$1(), L = B.assert, W = B.parseBytes, K = B.cachedProperty;
  function J(V, re) {
    this.eddsa = V, this._secret = W(re.secret), V.isPoint(re.pub) ? this._pub = re.pub : this._pubBytes = W(re.pub);
  }
  return J.fromPublic = function(re, ie) {
    return ie instanceof J ? ie : new J(re, { pub: ie });
  }, J.fromSecret = function(re, ie) {
    return ie instanceof J ? ie : new J(re, { secret: ie });
  }, J.prototype.secret = function() {
    return this._secret;
  }, K(J, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), K(J, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), K(J, "privBytes", function() {
    var re = this.eddsa, ie = this.hash(), oe = re.encodingLength - 1, pe = ie.slice(0, re.encodingLength);
    return pe[0] &= 248, pe[oe] &= 127, pe[oe] |= 64, pe;
  }), K(J, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), K(J, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), K(J, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), J.prototype.sign = function(re) {
    return L(this._secret, "KeyPair can only verify"), this.eddsa.sign(re, this);
  }, J.prototype.verify = function(re, ie) {
    return this.eddsa.verify(re, ie, this);
  }, J.prototype.getSecret = function(re) {
    return L(this._secret, "KeyPair is public only"), B.encode(this.secret(), re);
  }, J.prototype.getPublic = function(re) {
    return B.encode(this.pubBytes(), re);
  }, key = J, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var B = requireBn$1(), L = requireUtils$1(), W = L.assert, K = L.cachedProperty, J = L.parseBytes;
  function V(re, ie) {
    this.eddsa = re, typeof ie != "object" && (ie = J(ie)), Array.isArray(ie) && (W(ie.length === re.encodingLength * 2, "Signature has invalid size"), ie = {
      R: ie.slice(0, re.encodingLength),
      S: ie.slice(re.encodingLength)
    }), W(ie.R && ie.S, "Signature without R or S"), re.isPoint(ie.R) && (this._R = ie.R), ie.S instanceof B && (this._S = ie.S), this._Rencoded = Array.isArray(ie.R) ? ie.R : ie.Rencoded, this._Sencoded = Array.isArray(ie.S) ? ie.S : ie.Sencoded;
  }
  return K(V, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), K(V, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), K(V, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), K(V, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), V.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, V.prototype.toHex = function() {
    return L.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = V, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var B = requireHash(), L = requireCurves(), W = requireUtils$1(), K = W.assert, J = W.parseBytes, V = requireKey(), re = requireSignature();
  function ie(oe) {
    if (K(oe === "ed25519", "only tested with ed25519 so far"), !(this instanceof ie))
      return new ie(oe);
    oe = L[oe].curve, this.curve = oe, this.g = oe.g, this.g.precompute(oe.n.bitLength() + 1), this.pointClass = oe.point().constructor, this.encodingLength = Math.ceil(oe.n.bitLength() / 8), this.hash = B.sha512;
  }
  return eddsa = ie, ie.prototype.sign = function(pe, ne) {
    pe = J(pe);
    var ce = this.keyFromSecret(ne), Ce = this.hashInt(ce.messagePrefix(), pe), Oe = this.g.mul(Ce), st = this.encodePoint(Oe), at = this.hashInt(st, ce.pubBytes(), pe).mul(ce.priv()), lt = Ce.add(at).umod(this.curve.n);
    return this.makeSignature({ R: Oe, S: lt, Rencoded: st });
  }, ie.prototype.verify = function(pe, ne, ce) {
    if (pe = J(pe), ne = this.makeSignature(ne), ne.S().gte(ne.eddsa.curve.n) || ne.S().isNeg())
      return !1;
    var Ce = this.keyFromPublic(ce), Oe = this.hashInt(ne.Rencoded(), Ce.pubBytes(), pe), st = this.g.mul(ne.S()), at = ne.R().add(Ce.pub().mul(Oe));
    return at.eq(st);
  }, ie.prototype.hashInt = function() {
    for (var pe = this.hash(), ne = 0; ne < arguments.length; ne++)
      pe.update(arguments[ne]);
    return W.intFromLE(pe.digest()).umod(this.curve.n);
  }, ie.prototype.keyFromPublic = function(pe) {
    return V.fromPublic(this, pe);
  }, ie.prototype.keyFromSecret = function(pe) {
    return V.fromSecret(this, pe);
  }, ie.prototype.makeSignature = function(pe) {
    return pe instanceof re ? pe : new re(this, pe);
  }, ie.prototype.encodePoint = function(pe) {
    var ne = pe.getY().toArray("le", this.encodingLength);
    return ne[this.encodingLength - 1] |= pe.getX().isOdd() ? 128 : 0, ne;
  }, ie.prototype.decodePoint = function(pe) {
    pe = W.parseBytes(pe);
    var ne = pe.length - 1, ce = pe.slice(0, ne).concat(pe[ne] & -129), Ce = (pe[ne] & 128) !== 0, Oe = W.intFromLE(ce);
    return this.curve.pointFromY(Oe, Ce);
  }, ie.prototype.encodeInt = function(pe) {
    return pe.toArray("le", this.encodingLength);
  }, ie.prototype.decodeInt = function(pe) {
    return W.intFromLE(pe);
  }, ie.prototype.isPoint = function(pe) {
    return pe instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var L = B;
    L.version = require$$0.version, L.utils = requireUtils$1(), L.rand = requireBrorand(), L.curve = requireCurve(), L.curves = requireCurves(), L.ec = requireEc(), L.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, L) {
      if (B.indexOf) return B.indexOf(L);
      for (var W = 0; W < B.length; W++)
        if (B[W] === L) return W;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var L = [];
      for (var W in B) L.push(W);
      return L;
    }, forEach = function(B, L) {
      if (B.forEach) return B.forEach(L);
      for (var W = 0; W < B.length; W++)
        L(B[W], W, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, L, W) {
          Object.defineProperty(B, L, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: W
          });
        };
      } catch {
        return function(L, W, K) {
          L[W] = K;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(L) {
      if (!(this instanceof Script)) return new Script(L);
      this.code = L;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var L = document.createElement("iframe");
      L.style || (L.style = {}), L.style.display = "none", document.body.appendChild(L);
      var W = L.contentWindow, K = W.eval, J = W.execScript;
      !K && J && (J.call(W, "null"), K = W.eval), forEach(Object_keys(B), function(ie) {
        W[ie] = B[ie];
      }), forEach(globals, function(ie) {
        B[ie] && (W[ie] = B[ie]);
      });
      var V = Object_keys(W), re = K.call(W, this.code);
      return forEach(Object_keys(W), function(ie) {
        (ie in B || indexOf(V, ie) === -1) && (B[ie] = W[ie]);
      }), forEach(globals, function(ie) {
        ie in B || defineProp(B, ie, W[ie]);
      }), document.body.removeChild(L), re;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var L = Script.createContext(B), W = this.runInContext(L);
      return B && forEach(Object_keys(L), function(K) {
        B[K] = L[K];
      }), W;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(L) {
        var W = Script(L);
        return W[B].apply(W, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var L = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(W) {
        L[W] = B[W];
      }), L;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var L = requireAsn1$1(), W = requireInherits_browser(), K = B;
    K.define = function(re, ie) {
      return new J(re, ie);
    };
    function J(V, re) {
      this.name = V, this.body = re, this.decoders = {}, this.encoders = {};
    }
    J.prototype._createNamed = function(re) {
      var ie;
      try {
        ie = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ie = function(pe) {
          this._initNamed(pe);
        };
      }
      return W(ie, re), ie.prototype._initNamed = function(pe) {
        re.call(this, pe);
      }, new ie(this);
    }, J.prototype._getDecoder = function(re) {
      return re = re || "der", this.decoders.hasOwnProperty(re) || (this.decoders[re] = this._createNamed(L.decoders[re])), this.decoders[re];
    }, J.prototype.decode = function(re, ie, oe) {
      return this._getDecoder(ie).decode(re, oe);
    }, J.prototype._getEncoder = function(re) {
      return re = re || "der", this.encoders.hasOwnProperty(re) || (this.encoders[re] = this._createNamed(L.encoders[re])), this.encoders[re];
    }, J.prototype.encode = function(re, ie, oe) {
      return this._getEncoder(ie).encode(re, oe);
    };
  }(api)), api;
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var B = requireInherits_browser();
  function L(K) {
    this._reporterState = {
      obj: null,
      path: [],
      options: K || {},
      errors: []
    };
  }
  reporter.Reporter = L, L.prototype.isError = function(J) {
    return J instanceof W;
  }, L.prototype.save = function() {
    var J = this._reporterState;
    return { obj: J.obj, pathLen: J.path.length };
  }, L.prototype.restore = function(J) {
    var V = this._reporterState;
    V.obj = J.obj, V.path = V.path.slice(0, J.pathLen);
  }, L.prototype.enterKey = function(J) {
    return this._reporterState.path.push(J);
  }, L.prototype.exitKey = function(J) {
    var V = this._reporterState;
    V.path = V.path.slice(0, J - 1);
  }, L.prototype.leaveKey = function(J, V, re) {
    var ie = this._reporterState;
    this.exitKey(J), ie.obj !== null && (ie.obj[V] = re);
  }, L.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, L.prototype.enterObject = function() {
    var J = this._reporterState, V = J.obj;
    return J.obj = {}, V;
  }, L.prototype.leaveObject = function(J) {
    var V = this._reporterState, re = V.obj;
    return V.obj = J, re;
  }, L.prototype.error = function(J) {
    var V, re = this._reporterState, ie = J instanceof W;
    if (ie ? V = J : V = new W(re.path.map(function(oe) {
      return "[" + JSON.stringify(oe) + "]";
    }).join(""), J.message || J, J.stack), !re.options.partial)
      throw V;
    return ie || re.errors.push(V), V;
  }, L.prototype.wrapResult = function(J) {
    var V = this._reporterState;
    return V.options.partial ? {
      result: this.isError(J) ? null : J,
      errors: V.errors
    } : J;
  };
  function W(K, J) {
    this.path = K, this.rethrow(J);
  }
  return B(W, Error), W.prototype.rethrow = function(J) {
    if (this.message = J + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, W), !this.stack)
      try {
        throw new Error(this.message);
      } catch (V) {
        this.stack = V.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = requireInherits_browser(), L = requireBase().Reporter, W = require$$1$2.Buffer;
  function K(V, re) {
    if (L.call(this, re), !W.isBuffer(V)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = V, this.offset = 0, this.length = V.length;
  }
  B(K, L), buffer.DecoderBuffer = K, K.prototype.save = function() {
    return { offset: this.offset, reporter: L.prototype.save.call(this) };
  }, K.prototype.restore = function(re) {
    var ie = new K(this.base);
    return ie.offset = re.offset, ie.length = this.offset, this.offset = re.offset, L.prototype.restore.call(this, re.reporter), ie;
  }, K.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, K.prototype.readUInt8 = function(re) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(re || "DecoderBuffer overrun");
  }, K.prototype.skip = function(re, ie) {
    if (!(this.offset + re <= this.length))
      return this.error(ie || "DecoderBuffer overrun");
    var oe = new K(this.base);
    return oe._reporterState = this._reporterState, oe.offset = this.offset, oe.length = this.offset + re, this.offset += re, oe;
  }, K.prototype.raw = function(re) {
    return this.base.slice(re ? re.offset : this.offset, this.length);
  };
  function J(V, re) {
    if (Array.isArray(V))
      this.length = 0, this.value = V.map(function(ie) {
        return ie instanceof J || (ie = new J(ie, re)), this.length += ie.length, ie;
      }, this);
    else if (typeof V == "number") {
      if (!(0 <= V && V <= 255))
        return re.error("non-byte EncoderBuffer value");
      this.value = V, this.length = 1;
    } else if (typeof V == "string")
      this.value = V, this.length = W.byteLength(V);
    else if (W.isBuffer(V))
      this.value = V, this.length = V.length;
    else
      return re.error("Unsupported type: " + typeof V);
  }
  return buffer.EncoderBuffer = J, J.prototype.join = function(re, ie) {
    return re || (re = new W(this.length)), ie || (ie = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(oe) {
      oe.join(re, ie), ie += oe.length;
    }) : (typeof this.value == "number" ? re[ie] = this.value : typeof this.value == "string" ? re.write(this.value, ie) : W.isBuffer(this.value) && this.value.copy(re, ie), ie += this.length)), re;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, L = requireBase().EncoderBuffer, W = requireBase().DecoderBuffer, K = requireMinimalisticAssert(), J = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], V = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(J), re = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ie(pe, ne) {
    var ce = {};
    this._baseState = ce, ce.enc = pe, ce.parent = ne || null, ce.children = null, ce.tag = null, ce.args = null, ce.reverseArgs = null, ce.choice = null, ce.optional = !1, ce.any = !1, ce.obj = !1, ce.use = null, ce.useDecoder = null, ce.key = null, ce.default = null, ce.explicit = null, ce.implicit = null, ce.contains = null, ce.parent || (ce.children = [], this._wrap());
  }
  node = ie;
  var oe = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ie.prototype.clone = function() {
    var ne = this._baseState, ce = {};
    oe.forEach(function(Oe) {
      ce[Oe] = ne[Oe];
    });
    var Ce = new this.constructor(ce.parent);
    return Ce._baseState = ce, Ce;
  }, ie.prototype._wrap = function() {
    var ne = this._baseState;
    V.forEach(function(ce) {
      this[ce] = function() {
        var Oe = new this.constructor(this);
        return ne.children.push(Oe), Oe[ce].apply(Oe, arguments);
      };
    }, this);
  }, ie.prototype._init = function(ne) {
    var ce = this._baseState;
    K(ce.parent === null), ne.call(this), ce.children = ce.children.filter(function(Ce) {
      return Ce._baseState.parent === this;
    }, this), K.equal(ce.children.length, 1, "Root node can have only one child");
  }, ie.prototype._useArgs = function(ne) {
    var ce = this._baseState, Ce = ne.filter(function(Oe) {
      return Oe instanceof this.constructor;
    }, this);
    ne = ne.filter(function(Oe) {
      return !(Oe instanceof this.constructor);
    }, this), Ce.length !== 0 && (K(ce.children === null), ce.children = Ce, Ce.forEach(function(Oe) {
      Oe._baseState.parent = this;
    }, this)), ne.length !== 0 && (K(ce.args === null), ce.args = ne, ce.reverseArgs = ne.map(function(Oe) {
      if (typeof Oe != "object" || Oe.constructor !== Object)
        return Oe;
      var st = {};
      return Object.keys(Oe).forEach(function(at) {
        at == (at | 0) && (at |= 0);
        var lt = Oe[at];
        st[lt] = at;
      }), st;
    }));
  }, re.forEach(function(pe) {
    ie.prototype[pe] = function() {
      var ce = this._baseState;
      throw new Error(pe + " not implemented for encoding: " + ce.enc);
    };
  }), J.forEach(function(pe) {
    ie.prototype[pe] = function() {
      var ce = this._baseState, Ce = Array.prototype.slice.call(arguments);
      return K(ce.tag === null), ce.tag = pe, this._useArgs(Ce), this;
    };
  }), ie.prototype.use = function(ne) {
    K(ne);
    var ce = this._baseState;
    return K(ce.use === null), ce.use = ne, this;
  }, ie.prototype.optional = function() {
    var ne = this._baseState;
    return ne.optional = !0, this;
  }, ie.prototype.def = function(ne) {
    var ce = this._baseState;
    return K(ce.default === null), ce.default = ne, ce.optional = !0, this;
  }, ie.prototype.explicit = function(ne) {
    var ce = this._baseState;
    return K(ce.explicit === null && ce.implicit === null), ce.explicit = ne, this;
  }, ie.prototype.implicit = function(ne) {
    var ce = this._baseState;
    return K(ce.explicit === null && ce.implicit === null), ce.implicit = ne, this;
  }, ie.prototype.obj = function() {
    var ne = this._baseState, ce = Array.prototype.slice.call(arguments);
    return ne.obj = !0, ce.length !== 0 && this._useArgs(ce), this;
  }, ie.prototype.key = function(ne) {
    var ce = this._baseState;
    return K(ce.key === null), ce.key = ne, this;
  }, ie.prototype.any = function() {
    var ne = this._baseState;
    return ne.any = !0, this;
  }, ie.prototype.choice = function(ne) {
    var ce = this._baseState;
    return K(ce.choice === null), ce.choice = ne, this._useArgs(Object.keys(ne).map(function(Ce) {
      return ne[Ce];
    })), this;
  }, ie.prototype.contains = function(ne) {
    var ce = this._baseState;
    return K(ce.use === null), ce.contains = ne, this;
  }, ie.prototype._decode = function(ne, ce) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return ne.wrapResult(Ce.children[0]._decode(ne, ce));
    var Oe = Ce.default, st = !0, at = null;
    if (Ce.key !== null && (at = ne.enterKey(Ce.key)), Ce.optional) {
      var lt = null;
      if (Ce.explicit !== null ? lt = Ce.explicit : Ce.implicit !== null ? lt = Ce.implicit : Ce.tag !== null && (lt = Ce.tag), lt === null && !Ce.any) {
        var pt = ne.save();
        try {
          Ce.choice === null ? this._decodeGeneric(Ce.tag, ne, ce) : this._decodeChoice(ne, ce), st = !0;
        } catch {
          st = !1;
        }
        ne.restore(pt);
      } else if (st = this._peekTag(ne, lt, Ce.any), ne.isError(st))
        return st;
    }
    var ht;
    if (Ce.obj && st && (ht = ne.enterObject()), st) {
      if (Ce.explicit !== null) {
        var yt = this._decodeTag(ne, Ce.explicit);
        if (ne.isError(yt))
          return yt;
        ne = yt;
      }
      var vt = ne.offset;
      if (Ce.use === null && Ce.choice === null) {
        if (Ce.any)
          var pt = ne.save();
        var $t = this._decodeTag(
          ne,
          Ce.implicit !== null ? Ce.implicit : Ce.tag,
          Ce.any
        );
        if (ne.isError($t))
          return $t;
        Ce.any ? Oe = ne.raw(pt) : ne = $t;
      }
      if (ce && ce.track && Ce.tag !== null && ce.track(ne.path(), vt, ne.length, "tagged"), ce && ce.track && Ce.tag !== null && ce.track(ne.path(), ne.offset, ne.length, "content"), Ce.any ? Oe = Oe : Ce.choice === null ? Oe = this._decodeGeneric(Ce.tag, ne, ce) : Oe = this._decodeChoice(ne, ce), ne.isError(Oe))
        return Oe;
      if (!Ce.any && Ce.choice === null && Ce.children !== null && Ce.children.forEach(function(Et) {
        Et._decode(ne, ce);
      }), Ce.contains && (Ce.tag === "octstr" || Ce.tag === "bitstr")) {
        var xt = new W(Oe);
        Oe = this._getUse(Ce.contains, ne._reporterState.obj)._decode(xt, ce);
      }
    }
    return Ce.obj && st && (Oe = ne.leaveObject(ht)), Ce.key !== null && (Oe !== null || st === !0) ? ne.leaveKey(at, Ce.key, Oe) : at !== null && ne.exitKey(at), Oe;
  }, ie.prototype._decodeGeneric = function(ne, ce, Ce) {
    var Oe = this._baseState;
    return ne === "seq" || ne === "set" ? null : ne === "seqof" || ne === "setof" ? this._decodeList(ce, ne, Oe.args[0], Ce) : /str$/.test(ne) ? this._decodeStr(ce, ne, Ce) : ne === "objid" && Oe.args ? this._decodeObjid(ce, Oe.args[0], Oe.args[1], Ce) : ne === "objid" ? this._decodeObjid(ce, null, null, Ce) : ne === "gentime" || ne === "utctime" ? this._decodeTime(ce, ne, Ce) : ne === "null_" ? this._decodeNull(ce, Ce) : ne === "bool" ? this._decodeBool(ce, Ce) : ne === "objDesc" ? this._decodeStr(ce, ne, Ce) : ne === "int" || ne === "enum" ? this._decodeInt(ce, Oe.args && Oe.args[0], Ce) : Oe.use !== null ? this._getUse(Oe.use, ce._reporterState.obj)._decode(ce, Ce) : ce.error("unknown tag: " + ne);
  }, ie.prototype._getUse = function(ne, ce) {
    var Ce = this._baseState;
    return Ce.useDecoder = this._use(ne, ce), K(Ce.useDecoder._baseState.parent === null), Ce.useDecoder = Ce.useDecoder._baseState.children[0], Ce.implicit !== Ce.useDecoder._baseState.implicit && (Ce.useDecoder = Ce.useDecoder.clone(), Ce.useDecoder._baseState.implicit = Ce.implicit), Ce.useDecoder;
  }, ie.prototype._decodeChoice = function(ne, ce) {
    var Ce = this._baseState, Oe = null, st = !1;
    return Object.keys(Ce.choice).some(function(at) {
      var lt = ne.save(), pt = Ce.choice[at];
      try {
        var ht = pt._decode(ne, ce);
        if (ne.isError(ht))
          return !1;
        Oe = { type: at, value: ht }, st = !0;
      } catch {
        return ne.restore(lt), !1;
      }
      return !0;
    }, this), st ? Oe : ne.error("Choice not matched");
  }, ie.prototype._createEncoderBuffer = function(ne) {
    return new L(ne, this.reporter);
  }, ie.prototype._encode = function(ne, ce, Ce) {
    var Oe = this._baseState;
    if (!(Oe.default !== null && Oe.default === ne)) {
      var st = this._encodeValue(ne, ce, Ce);
      if (st !== void 0 && !this._skipDefault(st, ce, Ce))
        return st;
    }
  }, ie.prototype._encodeValue = function(ne, ce, Ce) {
    var Oe = this._baseState;
    if (Oe.parent === null)
      return Oe.children[0]._encode(ne, ce || new B());
    var pt = null;
    if (this.reporter = ce, Oe.optional && ne === void 0)
      if (Oe.default !== null)
        ne = Oe.default;
      else
        return;
    var st = null, at = !1;
    if (Oe.any)
      pt = this._createEncoderBuffer(ne);
    else if (Oe.choice)
      pt = this._encodeChoice(ne, ce);
    else if (Oe.contains)
      st = this._getUse(Oe.contains, Ce)._encode(ne, ce), at = !0;
    else if (Oe.children)
      st = Oe.children.map(function(vt) {
        if (vt._baseState.tag === "null_")
          return vt._encode(null, ce, ne);
        if (vt._baseState.key === null)
          return ce.error("Child should have a key");
        var $t = ce.enterKey(vt._baseState.key);
        if (typeof ne != "object")
          return ce.error("Child expected, but input is not object");
        var xt = vt._encode(ne[vt._baseState.key], ce, ne);
        return ce.leaveKey($t), xt;
      }, this).filter(function(vt) {
        return vt;
      }), st = this._createEncoderBuffer(st);
    else if (Oe.tag === "seqof" || Oe.tag === "setof") {
      if (!(Oe.args && Oe.args.length === 1))
        return ce.error("Too many args for : " + Oe.tag);
      if (!Array.isArray(ne))
        return ce.error("seqof/setof, but data is not Array");
      var lt = this.clone();
      lt._baseState.implicit = null, st = this._createEncoderBuffer(ne.map(function(vt) {
        var $t = this._baseState;
        return this._getUse($t.args[0], ne)._encode(vt, ce);
      }, lt));
    } else Oe.use !== null ? pt = this._getUse(Oe.use, Ce)._encode(ne, ce) : (st = this._encodePrimitive(Oe.tag, ne), at = !0);
    var pt;
    if (!Oe.any && Oe.choice === null) {
      var ht = Oe.implicit !== null ? Oe.implicit : Oe.tag, yt = Oe.implicit === null ? "universal" : "context";
      ht === null ? Oe.use === null && ce.error("Tag could be omitted only for .use()") : Oe.use === null && (pt = this._encodeComposite(ht, at, yt, st));
    }
    return Oe.explicit !== null && (pt = this._encodeComposite(Oe.explicit, !1, "context", pt)), pt;
  }, ie.prototype._encodeChoice = function(ne, ce) {
    var Ce = this._baseState, Oe = Ce.choice[ne.type];
    return Oe || K(
      !1,
      ne.type + " not found in " + JSON.stringify(Object.keys(Ce.choice))
    ), Oe._encode(ne.value, ce);
  }, ie.prototype._encodePrimitive = function(ne, ce) {
    var Ce = this._baseState;
    if (/str$/.test(ne))
      return this._encodeStr(ce, ne);
    if (ne === "objid" && Ce.args)
      return this._encodeObjid(ce, Ce.reverseArgs[0], Ce.args[1]);
    if (ne === "objid")
      return this._encodeObjid(ce, null, null);
    if (ne === "gentime" || ne === "utctime")
      return this._encodeTime(ce, ne);
    if (ne === "null_")
      return this._encodeNull();
    if (ne === "int" || ne === "enum")
      return this._encodeInt(ce, Ce.args && Ce.reverseArgs[0]);
    if (ne === "bool")
      return this._encodeBool(ce);
    if (ne === "objDesc")
      return this._encodeStr(ce, ne);
    throw new Error("Unsupported tag: " + ne);
  }, ie.prototype._isNumstr = function(ne) {
    return /^[0-9 ]*$/.test(ne);
  }, ie.prototype._isPrintstr = function(ne) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(ne);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var L = B;
    L.Reporter = requireReporter().Reporter, L.DecoderBuffer = requireBuffer().DecoderBuffer, L.EncoderBuffer = requireBuffer().EncoderBuffer, L.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var L = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = L._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = L._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var L = B;
    L._reverse = function(K) {
      var J = {};
      return Object.keys(K).forEach(function(V) {
        (V | 0) == V && (V = V | 0);
        var re = K[V];
        J[re] = V;
      }), J;
    }, L.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = requireInherits_browser(), L = requireAsn1$1(), W = L.base, K = L.bignum, J = L.constants.der;
  function V(pe) {
    this.enc = "der", this.name = pe.name, this.entity = pe, this.tree = new re(), this.tree._init(pe.body);
  }
  der_1$1 = V, V.prototype.decode = function(ne, ce) {
    return ne instanceof W.DecoderBuffer || (ne = new W.DecoderBuffer(ne, ce)), this.tree._decode(ne, ce);
  };
  function re(pe) {
    W.Node.call(this, "der", pe);
  }
  B(re, W.Node), re.prototype._peekTag = function(ne, ce, Ce) {
    if (ne.isEmpty())
      return !1;
    var Oe = ne.save(), st = ie(ne, 'Failed to peek tag: "' + ce + '"');
    return ne.isError(st) ? st : (ne.restore(Oe), st.tag === ce || st.tagStr === ce || st.tagStr + "of" === ce || Ce);
  }, re.prototype._decodeTag = function(ne, ce, Ce) {
    var Oe = ie(
      ne,
      'Failed to decode tag of "' + ce + '"'
    );
    if (ne.isError(Oe))
      return Oe;
    var st = oe(
      ne,
      Oe.primitive,
      'Failed to get length of "' + ce + '"'
    );
    if (ne.isError(st))
      return st;
    if (!Ce && Oe.tag !== ce && Oe.tagStr !== ce && Oe.tagStr + "of" !== ce)
      return ne.error('Failed to match tag: "' + ce + '"');
    if (Oe.primitive || st !== null)
      return ne.skip(st, 'Failed to match body of: "' + ce + '"');
    var at = ne.save(), lt = this._skipUntilEnd(
      ne,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return ne.isError(lt) ? lt : (st = ne.offset - at.offset, ne.restore(at), ne.skip(st, 'Failed to match body of: "' + ce + '"'));
  }, re.prototype._skipUntilEnd = function(ne, ce) {
    for (; ; ) {
      var Ce = ie(ne, ce);
      if (ne.isError(Ce))
        return Ce;
      var Oe = oe(ne, Ce.primitive, ce);
      if (ne.isError(Oe))
        return Oe;
      var st;
      if (Ce.primitive || Oe !== null ? st = ne.skip(Oe) : st = this._skipUntilEnd(ne, ce), ne.isError(st))
        return st;
      if (Ce.tagStr === "end")
        break;
    }
  }, re.prototype._decodeList = function(ne, ce, Ce, Oe) {
    for (var st = []; !ne.isEmpty(); ) {
      var at = this._peekTag(ne, "end");
      if (ne.isError(at))
        return at;
      var lt = Ce.decode(ne, "der", Oe);
      if (ne.isError(lt) && at)
        break;
      st.push(lt);
    }
    return st;
  }, re.prototype._decodeStr = function(ne, ce) {
    if (ce === "bitstr") {
      var Ce = ne.readUInt8();
      return ne.isError(Ce) ? Ce : { unused: Ce, data: ne.raw() };
    } else if (ce === "bmpstr") {
      var Oe = ne.raw();
      if (Oe.length % 2 === 1)
        return ne.error("Decoding of string type: bmpstr length mismatch");
      for (var st = "", at = 0; at < Oe.length / 2; at++)
        st += String.fromCharCode(Oe.readUInt16BE(at * 2));
      return st;
    } else if (ce === "numstr") {
      var lt = ne.raw().toString("ascii");
      return this._isNumstr(lt) ? lt : ne.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (ce === "octstr")
        return ne.raw();
      if (ce === "objDesc")
        return ne.raw();
      if (ce === "printstr") {
        var pt = ne.raw().toString("ascii");
        return this._isPrintstr(pt) ? pt : ne.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(ce) ? ne.raw().toString() : ne.error("Decoding of string type: " + ce + " unsupported");
    }
  }, re.prototype._decodeObjid = function(ne, ce, Ce) {
    for (var Oe, st = [], at = 0; !ne.isEmpty(); ) {
      var lt = ne.readUInt8();
      at <<= 7, at |= lt & 127, lt & 128 || (st.push(at), at = 0);
    }
    lt & 128 && st.push(at);
    var pt = st[0] / 40 | 0, ht = st[0] % 40;
    if (Ce ? Oe = st : Oe = [pt, ht].concat(st.slice(1)), ce) {
      var yt = ce[Oe.join(" ")];
      yt === void 0 && (yt = ce[Oe.join(".")]), yt !== void 0 && (Oe = yt);
    }
    return Oe;
  }, re.prototype._decodeTime = function(ne, ce) {
    var Ce = ne.raw().toString();
    if (ce === "gentime")
      var Oe = Ce.slice(0, 4) | 0, st = Ce.slice(4, 6) | 0, at = Ce.slice(6, 8) | 0, lt = Ce.slice(8, 10) | 0, pt = Ce.slice(10, 12) | 0, ht = Ce.slice(12, 14) | 0;
    else if (ce === "utctime") {
      var Oe = Ce.slice(0, 2) | 0, st = Ce.slice(2, 4) | 0, at = Ce.slice(4, 6) | 0, lt = Ce.slice(6, 8) | 0, pt = Ce.slice(8, 10) | 0, ht = Ce.slice(10, 12) | 0;
      Oe < 70 ? Oe = 2e3 + Oe : Oe = 1900 + Oe;
    } else
      return ne.error("Decoding " + ce + " time is not supported yet");
    return Date.UTC(Oe, st - 1, at, lt, pt, ht, 0);
  }, re.prototype._decodeNull = function(ne) {
    return null;
  }, re.prototype._decodeBool = function(ne) {
    var ce = ne.readUInt8();
    return ne.isError(ce) ? ce : ce !== 0;
  }, re.prototype._decodeInt = function(ne, ce) {
    var Ce = ne.raw(), Oe = new K(Ce);
    return ce && (Oe = ce[Oe.toString(10)] || Oe), Oe;
  }, re.prototype._use = function(ne, ce) {
    return typeof ne == "function" && (ne = ne(ce)), ne._getDecoder("der").tree;
  };
  function ie(pe, ne) {
    var ce = pe.readUInt8(ne);
    if (pe.isError(ce))
      return ce;
    var Ce = J.tagClass[ce >> 6], Oe = (ce & 32) === 0;
    if ((ce & 31) === 31) {
      var st = ce;
      for (ce = 0; (st & 128) === 128; ) {
        if (st = pe.readUInt8(ne), pe.isError(st))
          return st;
        ce <<= 7, ce |= st & 127;
      }
    } else
      ce &= 31;
    var at = J.tag[ce];
    return {
      cls: Ce,
      primitive: Oe,
      tag: ce,
      tagStr: at
    };
  }
  function oe(pe, ne, ce) {
    var Ce = pe.readUInt8(ce);
    if (pe.isError(Ce))
      return Ce;
    if (!ne && Ce === 128)
      return null;
    if (!(Ce & 128))
      return Ce;
    var Oe = Ce & 127;
    if (Oe > 4)
      return pe.error("length octect is too long");
    Ce = 0;
    for (var st = 0; st < Oe; st++) {
      Ce <<= 8;
      var at = pe.readUInt8(ce);
      if (pe.isError(at))
        return at;
      Ce |= at;
    }
    return Ce;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = requireInherits_browser(), L = require$$1$2.Buffer, W = requireDer$1();
  function K(J) {
    W.call(this, J), this.enc = "pem";
  }
  return B(K, W), pem$1 = K, K.prototype.decode = function(V, re) {
    for (var ie = V.toString().split(/[\r\n]+/g), oe = re.label.toUpperCase(), pe = /^-----(BEGIN|END) ([^-]+)-----$/, ne = -1, ce = -1, Ce = 0; Ce < ie.length; Ce++) {
      var Oe = ie[Ce].match(pe);
      if (Oe !== null && Oe[2] === oe)
        if (ne === -1) {
          if (Oe[1] !== "BEGIN")
            break;
          ne = Ce;
        } else {
          if (Oe[1] !== "END")
            break;
          ce = Ce;
          break;
        }
    }
    if (ne === -1 || ce === -1)
      throw new Error("PEM section not found for: " + oe);
    var st = ie.slice(ne + 1, ce).join("");
    st.replace(/[^a-z0-9\+\/=]+/gi, "");
    var at = new L(st, "base64");
    return W.prototype.decode.call(this, at, re);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var L = B;
    L.der = requireDer$1(), L.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = requireInherits_browser(), L = require$$1$2.Buffer, W = requireAsn1$1(), K = W.base, J = W.constants.der;
  function V(pe) {
    this.enc = "der", this.name = pe.name, this.entity = pe, this.tree = new re(), this.tree._init(pe.body);
  }
  der_1 = V, V.prototype.encode = function(ne, ce) {
    return this.tree._encode(ne, ce).join();
  };
  function re(pe) {
    K.Node.call(this, "der", pe);
  }
  B(re, K.Node), re.prototype._encodeComposite = function(ne, ce, Ce, Oe) {
    var st = oe(ne, ce, Ce, this.reporter);
    if (Oe.length < 128) {
      var pt = new L(2);
      return pt[0] = st, pt[1] = Oe.length, this._createEncoderBuffer([pt, Oe]);
    }
    for (var at = 1, lt = Oe.length; lt >= 256; lt >>= 8)
      at++;
    var pt = new L(2 + at);
    pt[0] = st, pt[1] = 128 | at;
    for (var lt = 1 + at, ht = Oe.length; ht > 0; lt--, ht >>= 8)
      pt[lt] = ht & 255;
    return this._createEncoderBuffer([pt, Oe]);
  }, re.prototype._encodeStr = function(ne, ce) {
    if (ce === "bitstr")
      return this._createEncoderBuffer([ne.unused | 0, ne.data]);
    if (ce === "bmpstr") {
      for (var Ce = new L(ne.length * 2), Oe = 0; Oe < ne.length; Oe++)
        Ce.writeUInt16BE(ne.charCodeAt(Oe), Oe * 2);
      return this._createEncoderBuffer(Ce);
    } else return ce === "numstr" ? this._isNumstr(ne) ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : ce === "printstr" ? this._isPrintstr(ne) ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(ce) ? this._createEncoderBuffer(ne) : ce === "objDesc" ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: " + ce + " unsupported");
  }, re.prototype._encodeObjid = function(ne, ce, Ce) {
    if (typeof ne == "string") {
      if (!ce)
        return this.reporter.error("string objid given, but no values map found");
      if (!ce.hasOwnProperty(ne))
        return this.reporter.error("objid not found in values map");
      ne = ce[ne].split(/[\s\.]+/g);
      for (var Oe = 0; Oe < ne.length; Oe++)
        ne[Oe] |= 0;
    } else if (Array.isArray(ne)) {
      ne = ne.slice();
      for (var Oe = 0; Oe < ne.length; Oe++)
        ne[Oe] |= 0;
    }
    if (!Array.isArray(ne))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(ne));
    if (!Ce) {
      if (ne[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      ne.splice(0, 2, ne[0] * 40 + ne[1]);
    }
    for (var st = 0, Oe = 0; Oe < ne.length; Oe++) {
      var at = ne[Oe];
      for (st++; at >= 128; at >>= 7)
        st++;
    }
    for (var lt = new L(st), pt = lt.length - 1, Oe = ne.length - 1; Oe >= 0; Oe--) {
      var at = ne[Oe];
      for (lt[pt--] = at & 127; (at >>= 7) > 0; )
        lt[pt--] = 128 | at & 127;
    }
    return this._createEncoderBuffer(lt);
  };
  function ie(pe) {
    return pe < 10 ? "0" + pe : pe;
  }
  re.prototype._encodeTime = function(ne, ce) {
    var Ce, Oe = new Date(ne);
    return ce === "gentime" ? Ce = [
      ie(Oe.getFullYear()),
      ie(Oe.getUTCMonth() + 1),
      ie(Oe.getUTCDate()),
      ie(Oe.getUTCHours()),
      ie(Oe.getUTCMinutes()),
      ie(Oe.getUTCSeconds()),
      "Z"
    ].join("") : ce === "utctime" ? Ce = [
      ie(Oe.getFullYear() % 100),
      ie(Oe.getUTCMonth() + 1),
      ie(Oe.getUTCDate()),
      ie(Oe.getUTCHours()),
      ie(Oe.getUTCMinutes()),
      ie(Oe.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + ce + " time is not supported yet"), this._encodeStr(Ce, "octstr");
  }, re.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, re.prototype._encodeInt = function(ne, ce) {
    if (typeof ne == "string") {
      if (!ce)
        return this.reporter.error("String int or enum given, but no values map");
      if (!ce.hasOwnProperty(ne))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(ne));
      ne = ce[ne];
    }
    if (typeof ne != "number" && !L.isBuffer(ne)) {
      var Ce = ne.toArray();
      !ne.sign && Ce[0] & 128 && Ce.unshift(0), ne = new L(Ce);
    }
    if (L.isBuffer(ne)) {
      var Oe = ne.length;
      ne.length === 0 && Oe++;
      var at = new L(Oe);
      return ne.copy(at), ne.length === 0 && (at[0] = 0), this._createEncoderBuffer(at);
    }
    if (ne < 128)
      return this._createEncoderBuffer(ne);
    if (ne < 256)
      return this._createEncoderBuffer([0, ne]);
    for (var Oe = 1, st = ne; st >= 256; st >>= 8)
      Oe++;
    for (var at = new Array(Oe), st = at.length - 1; st >= 0; st--)
      at[st] = ne & 255, ne >>= 8;
    return at[0] & 128 && at.unshift(0), this._createEncoderBuffer(new L(at));
  }, re.prototype._encodeBool = function(ne) {
    return this._createEncoderBuffer(ne ? 255 : 0);
  }, re.prototype._use = function(ne, ce) {
    return typeof ne == "function" && (ne = ne(ce)), ne._getEncoder("der").tree;
  }, re.prototype._skipDefault = function(ne, ce, Ce) {
    var Oe = this._baseState, st;
    if (Oe.default === null)
      return !1;
    var at = ne.join();
    if (Oe.defaultBuffer === void 0 && (Oe.defaultBuffer = this._encodeValue(Oe.default, ce, Ce).join()), at.length !== Oe.defaultBuffer.length)
      return !1;
    for (st = 0; st < at.length; st++)
      if (at[st] !== Oe.defaultBuffer[st])
        return !1;
    return !0;
  };
  function oe(pe, ne, ce, Ce) {
    var Oe;
    if (pe === "seqof" ? pe = "seq" : pe === "setof" && (pe = "set"), J.tagByName.hasOwnProperty(pe))
      Oe = J.tagByName[pe];
    else if (typeof pe == "number" && (pe | 0) === pe)
      Oe = pe;
    else
      return Ce.error("Unknown tag: " + pe);
    return Oe >= 31 ? Ce.error("Multi-octet tag encoding unsupported") : (ne || (Oe |= 32), Oe |= J.tagClassByName[ce || "universal"] << 6, Oe);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = requireInherits_browser(), L = requireDer();
  function W(K) {
    L.call(this, K), this.enc = "pem";
  }
  return B(W, L), pem = W, W.prototype.encode = function(J, V) {
    for (var re = L.prototype.encode.call(this, J), ie = re.toString("base64"), oe = ["-----BEGIN " + V.label + "-----"], pe = 0; pe < ie.length; pe += 64)
      oe.push(ie.slice(pe, pe + 64));
    return oe.push("-----END " + V.label + "-----"), oe.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var L = B;
    L.der = requireDer(), L.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(B) {
    var L = B;
    L.bignum = requireBn$1(), L.define = requireApi().define, L.base = requireBase(), L.constants = requireConstants(), L.decoders = requireDecoders(), L.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var B = requireAsn1$1(), L = B.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), W = B.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), K = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), J = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  }), V = B.define("RelativeDistinguishedName", function() {
    this.setof(W);
  }), re = B.define("RDNSequence", function() {
    this.seqof(V);
  }), ie = B.define("Name", function() {
    this.choice({
      rdnSequence: this.use(re)
    });
  }), oe = B.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(L),
      this.key("notAfter").use(L)
    );
  }), pe = B.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), ne = B.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(K),
      this.key("issuer").use(ie),
      this.key("validity").use(oe),
      this.key("subject").use(ie),
      this.key("subjectPublicKeyInfo").use(J),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(pe).optional()
    );
  }), ce = B.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(ne),
      this.key("signatureAlgorithm").use(K),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = ce, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var B = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var L = B.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = L;
  var W = B.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = W;
  var K = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), J = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = J;
  var V = B.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(K),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = V;
  var re = B.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = re;
  var ie = B.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = ie, asn1$1.DSAparam = B.define("DSAparam", function() {
    this.int();
  });
  var oe = B.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), pe = B.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(oe),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = pe, asn1$1.signature = B.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var B = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, L = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, W = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K = requireEvp_bytestokey(), J = requireBrowser$6(), V = safeBufferExports.Buffer;
  return fixProc = function(re, ie) {
    var oe = re.toString(), pe = oe.match(B), ne;
    if (pe) {
      var Ce = "aes" + pe[1], Oe = V.from(pe[2], "hex"), st = V.from(pe[3].replace(/[\r\n]/g, ""), "base64"), at = K(ie, Oe.slice(0, 8), parseInt(pe[1], 10)).key, lt = [], pt = J.createDecipheriv(Ce, at, Oe);
      lt.push(pt.update(st)), lt.push(pt.final()), ne = V.concat(lt);
    } else {
      var ce = oe.match(W);
      ne = V.from(ce[2].replace(/[\r\n]/g, ""), "base64");
    }
    var ht = oe.match(L)[1];
    return {
      tag: ht,
      data: ne
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var B = requireAsn1(), L = require$$1, W = requireFixProc(), K = requireBrowser$6(), J = requireBrowser$7(), V = safeBufferExports.Buffer;
  function re(oe, pe) {
    var ne = oe.algorithm.decrypt.kde.kdeparams.salt, ce = parseInt(oe.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), Ce = L[oe.algorithm.decrypt.cipher.algo.join(".")], Oe = oe.algorithm.decrypt.cipher.iv, st = oe.subjectPrivateKey, at = parseInt(Ce.split("-")[1], 10) / 8, lt = J.pbkdf2Sync(pe, ne, ce, at, "sha1"), pt = K.createDecipheriv(Ce, lt, Oe), ht = [];
    return ht.push(pt.update(st)), ht.push(pt.final()), V.concat(ht);
  }
  function ie(oe) {
    var pe;
    typeof oe == "object" && !V.isBuffer(oe) && (pe = oe.passphrase, oe = oe.key), typeof oe == "string" && (oe = V.from(oe));
    var ne = W(oe, pe), ce = ne.tag, Ce = ne.data, Oe, st;
    switch (ce) {
      case "CERTIFICATE":
        st = B.certificate.decode(Ce, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (st || (st = B.PublicKey.decode(Ce, "der")), Oe = st.algorithm.algorithm.join("."), Oe) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPublicKey.decode(st.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return st.subjectPrivateKey = st.subjectPublicKey, {
              type: "ec",
              data: st
            };
          case "1.2.840.10040.4.1":
            return st.algorithm.params.pub_key = B.DSAparam.decode(st.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: st.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Oe);
        }
      case "ENCRYPTED PRIVATE KEY":
        Ce = B.EncryptedPrivateKey.decode(Ce, "der"), Ce = re(Ce, pe);
      case "PRIVATE KEY":
        switch (st = B.PrivateKey.decode(Ce, "der"), Oe = st.algorithm.algorithm.join("."), Oe) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPrivateKey.decode(st.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: st.algorithm.curve,
              privateKey: B.ECPrivateKey.decode(st.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return st.algorithm.params.priv_key = B.DSAparam.decode(st.subjectPrivateKey, "der"), {
              type: "dsa",
              params: st.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Oe);
        }
      case "RSA PUBLIC KEY":
        return B.RSAPublicKey.decode(Ce, "der");
      case "RSA PRIVATE KEY":
        return B.RSAPrivateKey.decode(Ce, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: B.DSAPrivateKey.decode(Ce, "der")
        };
      case "EC PRIVATE KEY":
        return Ce = B.ECPrivateKey.decode(Ce, "der"), {
          curve: Ce.parameters.value,
          privateKey: Ce.privateKey
        };
      default:
        throw new Error("unknown key type " + ce);
    }
  }
  return ie.signature = B.signature, parseAsn1 = ie, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign$1.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports.Buffer, L = requireBrowser$8(), W = requireBrowserifyRsa(), K = requireElliptic().ec, J = requireBn(), V = requireParseAsn1(), re = require$$4, ie = 1;
  function oe(pt, ht, yt, vt, $t) {
    var xt = V(ht);
    if (xt.curve) {
      if (vt !== "ecdsa" && vt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return pe(pt, xt);
    } else if (xt.type === "dsa") {
      if (vt !== "dsa")
        throw new Error("wrong private key type");
      return ne(pt, xt, yt);
    }
    if (vt !== "rsa" && vt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ht.padding !== void 0 && ht.padding !== ie)
      throw new Error("illegal or unsupported padding mode");
    pt = B.concat([$t, pt]);
    for (var Ct = xt.modulus.byteLength(), Et = [0, 1]; pt.length + Et.length + 1 < Ct; )
      Et.push(255);
    Et.push(0);
    for (var St = -1; ++St < pt.length; )
      Et.push(pt[St]);
    var It = W(Et, xt);
    return It;
  }
  function pe(pt, ht) {
    var yt = re[ht.curve.join(".")];
    if (!yt)
      throw new Error("unknown curve " + ht.curve.join("."));
    var vt = new K(yt), $t = vt.keyFromPrivate(ht.privateKey), xt = $t.sign(pt);
    return B.from(xt.toDER());
  }
  function ne(pt, ht, yt) {
    for (var vt = ht.params.priv_key, $t = ht.params.p, xt = ht.params.q, Ct = ht.params.g, Et = new J(0), St, It = Oe(pt, xt).mod(xt), Tt = !1, nt = Ce(vt, xt, pt, yt); Tt === !1; )
      St = at(xt, nt, yt), Et = lt(Ct, St, $t, xt), Tt = St.invm(xt).imul(It.add(vt.mul(Et))).mod(xt), Tt.cmpn(0) === 0 && (Tt = !1, Et = new J(0));
    return ce(Et, Tt);
  }
  function ce(pt, ht) {
    pt = pt.toArray(), ht = ht.toArray(), pt[0] & 128 && (pt = [0].concat(pt)), ht[0] & 128 && (ht = [0].concat(ht));
    var yt = pt.length + ht.length + 4, vt = [
      48,
      yt,
      2,
      pt.length
    ];
    return vt = vt.concat(pt, [2, ht.length], ht), B.from(vt);
  }
  function Ce(pt, ht, yt, vt) {
    if (pt = B.from(pt.toArray()), pt.length < ht.byteLength()) {
      var $t = B.alloc(ht.byteLength() - pt.length);
      pt = B.concat([$t, pt]);
    }
    var xt = yt.length, Ct = st(yt, ht), Et = B.alloc(xt);
    Et.fill(1);
    var St = B.alloc(xt);
    return St = L(vt, St).update(Et).update(B.from([0])).update(pt).update(Ct).digest(), Et = L(vt, St).update(Et).digest(), St = L(vt, St).update(Et).update(B.from([1])).update(pt).update(Ct).digest(), Et = L(vt, St).update(Et).digest(), { k: St, v: Et };
  }
  function Oe(pt, ht) {
    var yt = new J(pt), vt = (pt.length << 3) - ht.bitLength();
    return vt > 0 && yt.ishrn(vt), yt;
  }
  function st(pt, ht) {
    pt = Oe(pt, ht), pt = pt.mod(ht);
    var yt = B.from(pt.toArray());
    if (yt.length < ht.byteLength()) {
      var vt = B.alloc(ht.byteLength() - yt.length);
      yt = B.concat([vt, yt]);
    }
    return yt;
  }
  function at(pt, ht, yt) {
    var vt, $t;
    do {
      for (vt = B.alloc(0); vt.length * 8 < pt.bitLength(); )
        ht.v = L(yt, ht.k).update(ht.v).digest(), vt = B.concat([vt, ht.v]);
      $t = Oe(vt, pt), ht.k = L(yt, ht.k).update(ht.v).update(B.from([0])).digest(), ht.v = L(yt, ht.k).update(ht.v).digest();
    } while ($t.cmp(pt) !== -1);
    return $t;
  }
  function lt(pt, ht, yt, vt) {
    return pt.toRed(J.mont(yt)).redPow(ht).fromRed().mod(vt);
  }
  return sign$1.exports = oe, sign$1.exports.getKey = Ce, sign$1.exports.makeKey = at, sign$1.exports;
}
var verify_1$1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1$1;
  hasRequiredVerify = 1;
  var B = safeBufferExports.Buffer, L = requireBn(), W = requireElliptic().ec, K = requireParseAsn1(), J = require$$4;
  function V(pe, ne, ce, Ce, Oe) {
    var st = K(ce);
    if (st.type === "ec") {
      if (Ce !== "ecdsa" && Ce !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return re(pe, ne, st);
    } else if (st.type === "dsa") {
      if (Ce !== "dsa")
        throw new Error("wrong public key type");
      return ie(pe, ne, st);
    }
    if (Ce !== "rsa" && Ce !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    ne = B.concat([Oe, ne]);
    for (var at = st.modulus.byteLength(), lt = [1], pt = 0; ne.length + lt.length + 2 < at; )
      lt.push(255), pt += 1;
    lt.push(0);
    for (var ht = -1; ++ht < ne.length; )
      lt.push(ne[ht]);
    lt = B.from(lt);
    var yt = L.mont(st.modulus);
    pe = new L(pe).toRed(yt), pe = pe.redPow(new L(st.publicExponent)), pe = B.from(pe.fromRed().toArray());
    var vt = pt < 8 ? 1 : 0;
    for (at = Math.min(pe.length, lt.length), pe.length !== lt.length && (vt = 1), ht = -1; ++ht < at; )
      vt |= pe[ht] ^ lt[ht];
    return vt === 0;
  }
  function re(pe, ne, ce) {
    var Ce = J[ce.data.algorithm.curve.join(".")];
    if (!Ce)
      throw new Error("unknown curve " + ce.data.algorithm.curve.join("."));
    var Oe = new W(Ce), st = ce.data.subjectPrivateKey.data;
    return Oe.verify(ne, pe, st);
  }
  function ie(pe, ne, ce) {
    var Ce = ce.data.p, Oe = ce.data.q, st = ce.data.g, at = ce.data.pub_key, lt = K.signature.decode(pe, "der"), pt = lt.s, ht = lt.r;
    oe(pt, Oe), oe(ht, Oe);
    var yt = L.mont(Ce), vt = pt.invm(Oe), $t = st.toRed(yt).redPow(new L(ne).mul(vt).mod(Oe)).fromRed().mul(at.toRed(yt).redPow(ht.mul(vt).mod(Oe)).fromRed()).mod(Ce).mod(Oe);
    return $t.cmp(ht) === 0;
  }
  function oe(pe, ne) {
    if (pe.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (pe.cmp(ne) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1$1 = V, verify_1$1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var B = safeBufferExports.Buffer, L = requireBrowser$a(), W = requireReadableBrowser(), K = requireInherits_browser(), J = requireSign(), V = requireVerify(), re = require$$6;
  Object.keys(re).forEach(function(ce) {
    re[ce].id = B.from(re[ce].id, "hex"), re[ce.toLowerCase()] = re[ce];
  });
  function ie(ce) {
    W.Writable.call(this);
    var Ce = re[ce];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hashType = Ce.hash, this._hash = L(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  K(ie, W.Writable), ie.prototype._write = function(Ce, Oe, st) {
    this._hash.update(Ce), st();
  }, ie.prototype.update = function(Ce, Oe) {
    return this._hash.update(typeof Ce == "string" ? B.from(Ce, Oe) : Ce), this;
  }, ie.prototype.sign = function(Ce, Oe) {
    this.end();
    var st = this._hash.digest(), at = J(st, Ce, this._hashType, this._signType, this._tag);
    return Oe ? at.toString(Oe) : at;
  };
  function oe(ce) {
    W.Writable.call(this);
    var Ce = re[ce];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hash = L(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  K(oe, W.Writable), oe.prototype._write = function(Ce, Oe, st) {
    this._hash.update(Ce), st();
  }, oe.prototype.update = function(Ce, Oe) {
    return this._hash.update(typeof Ce == "string" ? B.from(Ce, Oe) : Ce), this;
  }, oe.prototype.verify = function(Ce, Oe, st) {
    var at = typeof Oe == "string" ? B.from(Oe, st) : Oe;
    this.end();
    var lt = this._hash.digest();
    return V(at, lt, Ce, this._signType, this._tag);
  };
  function pe(ce) {
    return new ie(ce);
  }
  function ne(ce) {
    return new oe(ce);
  }
  return browser$3 = {
    Sign: pe,
    Verify: ne,
    createSign: pe,
    createVerify: ne
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var B = requireElliptic(), L = requireBn$1();
  browser$2 = function(re) {
    return new K(re);
  };
  var W = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  W.p224 = W.secp224r1, W.p256 = W.secp256r1 = W.prime256v1, W.p192 = W.secp192r1 = W.prime192v1, W.p384 = W.secp384r1, W.p521 = W.secp521r1;
  function K(V) {
    this.curveType = W[V], this.curveType || (this.curveType = {
      name: V
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  K.prototype.generateKeys = function(V, re) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(V, re);
  }, K.prototype.computeSecret = function(V, re, ie) {
    re = re || "utf8", Buffer$2.isBuffer(V) || (V = new Buffer$2(V, re));
    var oe = this.curve.keyFromPublic(V).getPublic(), pe = oe.mul(this.keys.getPrivate()).getX();
    return J(pe, ie, this.curveType.byteLength);
  }, K.prototype.getPublicKey = function(V, re) {
    var ie = this.keys.getPublic(re === "compressed", !0);
    return re === "hybrid" && (ie[ie.length - 1] % 2 ? ie[0] = 7 : ie[0] = 6), J(ie, V);
  }, K.prototype.getPrivateKey = function(V) {
    return J(this.keys.getPrivate(), V);
  }, K.prototype.setPublicKey = function(V, re) {
    return re = re || "utf8", Buffer$2.isBuffer(V) || (V = new Buffer$2(V, re)), this.keys._importPublic(V), this;
  }, K.prototype.setPrivateKey = function(V, re) {
    re = re || "utf8", Buffer$2.isBuffer(V) || (V = new Buffer$2(V, re));
    var ie = new L(V);
    return ie = ie.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ie), this;
  };
  function J(V, re, ie) {
    Array.isArray(V) || (V = V.toArray());
    var oe = new Buffer$2(V);
    if (ie && oe.length < ie) {
      var pe = new Buffer$2(ie - oe.length);
      pe.fill(0), oe = Buffer$2.concat([pe, oe]);
    }
    return re ? oe.toString(re) : oe;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var B = requireBrowser$a(), L = safeBufferExports.Buffer;
  mgf = function(K, J) {
    for (var V = L.alloc(0), re = 0, ie; V.length < J; )
      ie = W(re++), V = L.concat([V, B("sha1").update(K).update(ie).digest()]);
    return V.slice(0, J);
  };
  function W(K) {
    var J = L.allocUnsafe(4);
    return J.writeUInt32BE(K, 0), J;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(L, W) {
    for (var K = L.length, J = -1; ++J < K; )
      L[J] ^= W[J];
    return L;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var B = requireBn$1(), L = safeBufferExports.Buffer;
  function W(K, J) {
    return L.from(K.toRed(B.mont(J.modulus)).redPow(new B(J.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = W, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var B = requireParseAsn1(), L = requireBrowser$9(), W = requireBrowser$a(), K = requireMgf(), J = requireXor(), V = requireBn$1(), re = requireWithPublic(), ie = requireBrowserifyRsa(), oe = safeBufferExports.Buffer;
  publicEncrypt = function(Oe, st, at) {
    var lt;
    Oe.padding ? lt = Oe.padding : at ? lt = 1 : lt = 4;
    var pt = B(Oe), ht;
    if (lt === 4)
      ht = pe(pt, st);
    else if (lt === 1)
      ht = ne(pt, st, at);
    else if (lt === 3) {
      if (ht = new V(st), ht.cmp(pt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return at ? ie(ht, pt) : re(ht, pt);
  };
  function pe(Ce, Oe) {
    var st = Ce.modulus.byteLength(), at = Oe.length, lt = W("sha1").update(oe.alloc(0)).digest(), pt = lt.length, ht = 2 * pt;
    if (at > st - ht - 2)
      throw new Error("message too long");
    var yt = oe.alloc(st - at - ht - 2), vt = st - pt - 1, $t = L(pt), xt = J(oe.concat([lt, yt, oe.alloc(1, 1), Oe], vt), K($t, vt)), Ct = J($t, K(xt, pt));
    return new V(oe.concat([oe.alloc(1), Ct, xt], st));
  }
  function ne(Ce, Oe, st) {
    var at = Oe.length, lt = Ce.modulus.byteLength();
    if (at > lt - 11)
      throw new Error("message too long");
    var pt;
    return st ? pt = oe.alloc(lt - at - 3, 255) : pt = ce(lt - at - 3), new V(oe.concat([oe.from([0, st ? 1 : 2]), pt, oe.alloc(1), Oe], lt));
  }
  function ce(Ce) {
    for (var Oe = oe.allocUnsafe(Ce), st = 0, at = L(Ce * 2), lt = 0, pt; st < Ce; )
      lt === at.length && (at = L(Ce * 2), lt = 0), pt = at[lt++], pt && (Oe[st++] = pt);
    return Oe;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var B = requireParseAsn1(), L = requireMgf(), W = requireXor(), K = requireBn$1(), J = requireBrowserifyRsa(), V = requireBrowser$a(), re = requireWithPublic(), ie = safeBufferExports.Buffer;
  privateDecrypt = function(Ce, Oe, st) {
    var at;
    Ce.padding ? at = Ce.padding : st ? at = 1 : at = 4;
    var lt = B(Ce), pt = lt.modulus.byteLength();
    if (Oe.length > pt || new K(Oe).cmp(lt.modulus) >= 0)
      throw new Error("decryption error");
    var ht;
    st ? ht = re(new K(Oe), lt) : ht = J(Oe, lt);
    var yt = ie.alloc(pt - ht.length);
    if (ht = ie.concat([yt, ht], pt), at === 4)
      return oe(lt, ht);
    if (at === 1)
      return pe(lt, ht, st);
    if (at === 3)
      return ht;
    throw new Error("unknown padding");
  };
  function oe(ce, Ce) {
    var Oe = ce.modulus.byteLength(), st = V("sha1").update(ie.alloc(0)).digest(), at = st.length;
    if (Ce[0] !== 0)
      throw new Error("decryption error");
    var lt = Ce.slice(1, at + 1), pt = Ce.slice(at + 1), ht = W(lt, L(pt, at)), yt = W(pt, L(ht, Oe - at - 1));
    if (ne(st, yt.slice(0, at)))
      throw new Error("decryption error");
    for (var vt = at; yt[vt] === 0; )
      vt++;
    if (yt[vt++] !== 1)
      throw new Error("decryption error");
    return yt.slice(vt);
  }
  function pe(ce, Ce, Oe) {
    for (var st = Ce.slice(0, 2), at = 2, lt = 0; Ce[at++] !== 0; )
      if (at >= Ce.length) {
        lt++;
        break;
      }
    var pt = Ce.slice(2, at - 1);
    if ((st.toString("hex") !== "0002" && !Oe || st.toString("hex") !== "0001" && Oe) && lt++, pt.length < 8 && lt++, lt)
      throw new Error("decryption error");
    return Ce.slice(at);
  }
  function ne(ce, Ce) {
    ce = ie.from(ce), Ce = ie.from(Ce);
    var Oe = 0, st = ce.length;
    ce.length !== Ce.length && (Oe++, st = Math.min(ce.length, Ce.length));
    for (var at = -1; ++at < st; )
      Oe += ce[at] ^ Ce[at];
    return Oe;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(B) {
    B.publicEncrypt = requirePublicEncrypt(), B.privateDecrypt = requirePrivateDecrypt(), B.privateEncrypt = function(W, K) {
      return B.publicEncrypt(W, K, !0);
    }, B.publicDecrypt = function(W, K) {
      return B.privateDecrypt(W, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function B() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var L = safeBufferExports, W = requireBrowser$9(), K = L.Buffer, J = L.kMaxLength, V = commonjsGlobal.crypto || commonjsGlobal.msCrypto, re = Math.pow(2, 32) - 1;
  function ie(Ce, Oe) {
    if (typeof Ce != "number" || Ce !== Ce)
      throw new TypeError("offset must be a number");
    if (Ce > re || Ce < 0)
      throw new TypeError("offset must be a uint32");
    if (Ce > J || Ce > Oe)
      throw new RangeError("offset out of range");
  }
  function oe(Ce, Oe, st) {
    if (typeof Ce != "number" || Ce !== Ce)
      throw new TypeError("size must be a number");
    if (Ce > re || Ce < 0)
      throw new TypeError("size must be a uint32");
    if (Ce + Oe > st || Ce > J)
      throw new RangeError("buffer too small");
  }
  V && V.getRandomValues || !process$1.browser ? (browser.randomFill = pe, browser.randomFillSync = ce) : (browser.randomFill = B, browser.randomFillSync = B);
  function pe(Ce, Oe, st, at) {
    if (!K.isBuffer(Ce) && !(Ce instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Oe == "function")
      at = Oe, Oe = 0, st = Ce.length;
    else if (typeof st == "function")
      at = st, st = Ce.length - Oe;
    else if (typeof at != "function")
      throw new TypeError('"cb" argument must be a function');
    return ie(Oe, Ce.length), oe(st, Oe, Ce.length), ne(Ce, Oe, st, at);
  }
  function ne(Ce, Oe, st, at) {
    if (process$1.browser) {
      var lt = Ce.buffer, pt = new Uint8Array(lt, Oe, st);
      if (V.getRandomValues(pt), at) {
        process$1.nextTick(function() {
          at(null, Ce);
        });
        return;
      }
      return Ce;
    }
    if (at) {
      W(st, function(yt, vt) {
        if (yt)
          return at(yt);
        vt.copy(Ce, Oe), at(null, Ce);
      });
      return;
    }
    var ht = W(st);
    return ht.copy(Ce, Oe), Ce;
  }
  function ce(Ce, Oe, st) {
    if (typeof Oe > "u" && (Oe = 0), !K.isBuffer(Ce) && !(Ce instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ie(Oe, Ce.length), st === void 0 && (st = Ce.length - Oe), oe(st, Oe, Ce.length), ne(Ce, Oe, st);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$9(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$a(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var B = requireAlgos(), L = Object.keys(B), W = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(L);
  cryptoBrowserify.getHashes = function() {
    return W;
  };
  var K = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = K.pbkdf2, cryptoBrowserify.pbkdf2Sync = K.pbkdf2Sync;
  var J = requireBrowser$5();
  cryptoBrowserify.Cipher = J.Cipher, cryptoBrowserify.createCipher = J.createCipher, cryptoBrowserify.Cipheriv = J.Cipheriv, cryptoBrowserify.createCipheriv = J.createCipheriv, cryptoBrowserify.Decipher = J.Decipher, cryptoBrowserify.createDecipher = J.createDecipher, cryptoBrowserify.Decipheriv = J.Decipheriv, cryptoBrowserify.createDecipheriv = J.createDecipheriv, cryptoBrowserify.getCiphers = J.getCiphers, cryptoBrowserify.listCiphers = J.listCiphers;
  var V = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = V.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = V.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = V.getDiffieHellman, cryptoBrowserify.createDiffieHellman = V.createDiffieHellman, cryptoBrowserify.DiffieHellman = V.DiffieHellman;
  var re = requireBrowser$3();
  cryptoBrowserify.createSign = re.createSign, cryptoBrowserify.Sign = re.Sign, cryptoBrowserify.createVerify = re.createVerify, cryptoBrowserify.Verify = re.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ie = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ie.publicEncrypt, cryptoBrowserify.privateEncrypt = ie.privateEncrypt, cryptoBrowserify.publicDecrypt = ie.publicDecrypt, cryptoBrowserify.privateDecrypt = ie.privateDecrypt;
  var oe = requireBrowser();
  return cryptoBrowserify.randomFill = oe.randomFill, cryptoBrowserify.randomFillSync = oe.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const L = requireCryptoBrowserify(), W = BigInt(0), K = BigInt(1), J = BigInt(2), V = BigInt(3), re = BigInt(8), ie = Object.freeze({
    a: W,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: K,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = ie;
  const oe = (Dt, Ot) => (Dt + Ot / J) / Ot, pe = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Dt) {
      const { n: Ot } = ie, Ht = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Wt = -K * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Yt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), er = Ht, rr = BigInt("0x100000000000000000000000000000000"), ir = oe(er * Dt, Ot), ur = oe(-Wt * Dt, Ot);
      let sr = wt(Dt - ir * Ht - ur * Yt, Ot), br = wt(-ir * Wt - ur * er, Ot);
      const _r = sr > rr, or = br > rr;
      if (_r && (sr = Ot - sr), or && (br = Ot - br), sr > rr || br > rr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Dt);
      return { k1neg: _r, k1: sr, k2neg: or, k2: br };
    }
  }, ne = 32, ce = 32, Ce = 32, Oe = ne + 1, st = 2 * ne + 1;
  function at(Dt) {
    const { a: Ot, b: Ht } = ie, Wt = wt(Dt * Dt), Yt = wt(Wt * Dt);
    return wt(Yt + Ot * Dt + Ht);
  }
  const lt = ie.a === W;
  class pt extends Error {
    constructor(Ot) {
      super(Ot);
    }
  }
  function ht(Dt) {
    if (!(Dt instanceof yt))
      throw new TypeError("JacobianPoint expected");
  }
  class yt {
    constructor(Ot, Ht, Wt) {
      this.x = Ot, this.y = Ht, this.z = Wt;
    }
    static fromAffine(Ot) {
      if (!(Ot instanceof xt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Ot.equals(xt.ZERO) ? yt.ZERO : new yt(Ot.x, Ot.y, K);
    }
    static toAffineBatch(Ot) {
      const Ht = Bt(Ot.map((Wt) => Wt.z));
      return Ot.map((Wt, Yt) => Wt.toAffine(Ht[Yt]));
    }
    static normalizeZ(Ot) {
      return yt.toAffineBatch(Ot).map(yt.fromAffine);
    }
    equals(Ot) {
      ht(Ot);
      const { x: Ht, y: Wt, z: Yt } = this, { x: er, y: rr, z: ir } = Ot, ur = wt(Yt * Yt), sr = wt(ir * ir), br = wt(Ht * sr), _r = wt(er * ur), or = wt(wt(Wt * ir) * sr), Lt = wt(wt(rr * Yt) * ur);
      return br === _r && or === Lt;
    }
    negate() {
      return new yt(this.x, wt(-this.y), this.z);
    }
    double() {
      const { x: Ot, y: Ht, z: Wt } = this, Yt = wt(Ot * Ot), er = wt(Ht * Ht), rr = wt(er * er), ir = Ot + er, ur = wt(J * (wt(ir * ir) - Yt - rr)), sr = wt(V * Yt), br = wt(sr * sr), _r = wt(br - J * ur), or = wt(sr * (ur - _r) - re * rr), Lt = wt(J * Ht * Wt);
      return new yt(_r, or, Lt);
    }
    add(Ot) {
      ht(Ot);
      const { x: Ht, y: Wt, z: Yt } = this, { x: er, y: rr, z: ir } = Ot;
      if (er === W || rr === W)
        return this;
      if (Ht === W || Wt === W)
        return Ot;
      const ur = wt(Yt * Yt), sr = wt(ir * ir), br = wt(Ht * sr), _r = wt(er * ur), or = wt(wt(Wt * ir) * sr), Lt = wt(wt(rr * Yt) * ur), Zt = wt(_r - br), tr = wt(Lt - or);
      if (Zt === W)
        return tr === W ? this.double() : yt.ZERO;
      const fr = wt(Zt * Zt), gr = wt(Zt * fr), Er = wt(br * fr), Ir = wt(tr * tr - gr - J * Er), Br = wt(tr * (Er - Ir) - or * gr), Ur = wt(Yt * ir * Zt);
      return new yt(Ir, Br, Ur);
    }
    subtract(Ot) {
      return this.add(Ot.negate());
    }
    multiplyUnsafe(Ot) {
      const Ht = yt.ZERO;
      if (typeof Ot == "bigint" && Ot === W)
        return Ht;
      let Wt = dt(Ot);
      if (Wt === K)
        return this;
      if (!lt) {
        let _r = Ht, or = this;
        for (; Wt > W; )
          Wt & K && (_r = _r.add(or)), or = or.double(), Wt >>= K;
        return _r;
      }
      let { k1neg: Yt, k1: er, k2neg: rr, k2: ir } = pe.splitScalar(Wt), ur = Ht, sr = Ht, br = this;
      for (; er > W || ir > W; )
        er & K && (ur = ur.add(br)), ir & K && (sr = sr.add(br)), br = br.double(), er >>= K, ir >>= K;
      return Yt && (ur = ur.negate()), rr && (sr = sr.negate()), sr = new yt(wt(sr.x * pe.beta), sr.y, sr.z), ur.add(sr);
    }
    precomputeWindow(Ot) {
      const Ht = lt ? 128 / Ot + 1 : 256 / Ot + 1, Wt = [];
      let Yt = this, er = Yt;
      for (let rr = 0; rr < Ht; rr++) {
        er = Yt, Wt.push(er);
        for (let ir = 1; ir < 2 ** (Ot - 1); ir++)
          er = er.add(Yt), Wt.push(er);
        Yt = er.double();
      }
      return Wt;
    }
    wNAF(Ot, Ht) {
      !Ht && this.equals(yt.BASE) && (Ht = xt.BASE);
      const Wt = Ht && Ht._WINDOW_SIZE || 1;
      if (256 % Wt)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Yt = Ht && $t.get(Ht);
      Yt || (Yt = this.precomputeWindow(Wt), Ht && Wt !== 1 && (Yt = yt.normalizeZ(Yt), $t.set(Ht, Yt)));
      let er = yt.ZERO, rr = yt.BASE;
      const ir = 1 + (lt ? 128 / Wt : 256 / Wt), ur = 2 ** (Wt - 1), sr = BigInt(2 ** Wt - 1), br = 2 ** Wt, _r = BigInt(Wt);
      for (let or = 0; or < ir; or++) {
        const Lt = or * ur;
        let Zt = Number(Ot & sr);
        Ot >>= _r, Zt > ur && (Zt -= br, Ot += K);
        const tr = Lt, fr = Lt + Math.abs(Zt) - 1, gr = or % 2 !== 0, Er = Zt < 0;
        Zt === 0 ? rr = rr.add(vt(gr, Yt[tr])) : er = er.add(vt(Er, Yt[fr]));
      }
      return { p: er, f: rr };
    }
    multiply(Ot, Ht) {
      let Wt = dt(Ot), Yt, er;
      if (lt) {
        const { k1neg: rr, k1: ir, k2neg: ur, k2: sr } = pe.splitScalar(Wt);
        let { p: br, f: _r } = this.wNAF(ir, Ht), { p: or, f: Lt } = this.wNAF(sr, Ht);
        br = vt(rr, br), or = vt(ur, or), or = new yt(wt(or.x * pe.beta), or.y, or.z), Yt = br.add(or), er = _r.add(Lt);
      } else {
        const { p: rr, f: ir } = this.wNAF(Wt, Ht);
        Yt = rr, er = ir;
      }
      return yt.normalizeZ([Yt, er])[0];
    }
    toAffine(Ot) {
      const { x: Ht, y: Wt, z: Yt } = this, er = this.equals(yt.ZERO);
      Ot == null && (Ot = er ? re : Nt(Yt));
      const rr = Ot, ir = wt(rr * rr), ur = wt(ir * rr), sr = wt(Ht * ir), br = wt(Wt * ur), _r = wt(Yt * rr);
      if (er)
        return xt.ZERO;
      if (_r !== K)
        throw new Error("invZ was invalid");
      return new xt(sr, br);
    }
  }
  yt.BASE = new yt(ie.Gx, ie.Gy, K), yt.ZERO = new yt(W, K, W);
  function vt(Dt, Ot) {
    const Ht = Ot.negate();
    return Dt ? Ht : Ot;
  }
  const $t = /* @__PURE__ */ new WeakMap();
  class xt {
    constructor(Ot, Ht) {
      this.x = Ot, this.y = Ht;
    }
    _setWindowSize(Ot) {
      this._WINDOW_SIZE = Ot, $t.delete(this);
    }
    hasEvenY() {
      return this.y % J === W;
    }
    static fromCompressedHex(Ot) {
      const Ht = Ot.length === 32, Wt = ut(Ht ? Ot : Ot.subarray(1));
      if (!Qt(Wt))
        throw new Error("Point is not on curve");
      const Yt = at(Wt);
      let er = jt(Yt);
      const rr = (er & K) === K;
      Ht ? rr && (er = wt(-er)) : (Ot[0] & 1) === 1 !== rr && (er = wt(-er));
      const ir = new xt(Wt, er);
      return ir.assertValidity(), ir;
    }
    static fromUncompressedHex(Ot) {
      const Ht = ut(Ot.subarray(1, ne + 1)), Wt = ut(Ot.subarray(ne + 1, ne * 2 + 1)), Yt = new xt(Ht, Wt);
      return Yt.assertValidity(), Yt;
    }
    static fromHex(Ot) {
      const Ht = gt(Ot), Wt = Ht.length, Yt = Ht[0];
      if (Wt === ne)
        return this.fromCompressedHex(Ht);
      if (Wt === Oe && (Yt === 2 || Yt === 3))
        return this.fromCompressedHex(Ht);
      if (Wt === st && Yt === 4)
        return this.fromUncompressedHex(Ht);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Oe} compressed bytes or ${st} uncompressed bytes, not ${Wt}`);
    }
    static fromPrivateKey(Ot) {
      return xt.BASE.multiply(ar(Ot));
    }
    static fromSignature(Ot, Ht, Wt) {
      const { r: Yt, s: er } = hr(Ht);
      if (![0, 1, 2, 3].includes(Wt))
        throw new Error("Cannot recover: invalid recovery bit");
      const rr = Ut(gt(Ot)), { n: ir } = ie, ur = Wt === 2 || Wt === 3 ? Yt + ir : Yt, sr = Nt(ur, ir), br = wt(-rr * sr, ir), _r = wt(er * sr, ir), or = Wt & 1 ? "03" : "02", Lt = xt.fromHex(or + rt(ur)), Zt = xt.BASE.multiplyAndAddUnsafe(Lt, br, _r);
      if (!Zt)
        throw new Error("Cannot recover signature: point at infinify");
      return Zt.assertValidity(), Zt;
    }
    toRawBytes(Ot = !1) {
      return bt(this.toHex(Ot));
    }
    toHex(Ot = !1) {
      const Ht = rt(this.x);
      return Ot ? `${this.hasEvenY() ? "02" : "03"}${Ht}` : `04${Ht}${rt(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Ot = "Point is not on elliptic curve", { x: Ht, y: Wt } = this;
      if (!Qt(Ht) || !Qt(Wt))
        throw new Error(Ot);
      const Yt = wt(Wt * Wt), er = at(Ht);
      if (wt(Yt - er) !== W)
        throw new Error(Ot);
    }
    equals(Ot) {
      return this.x === Ot.x && this.y === Ot.y;
    }
    negate() {
      return new xt(this.x, wt(-this.y));
    }
    double() {
      return yt.fromAffine(this).double().toAffine();
    }
    add(Ot) {
      return yt.fromAffine(this).add(yt.fromAffine(Ot)).toAffine();
    }
    subtract(Ot) {
      return this.add(Ot.negate());
    }
    multiply(Ot) {
      return yt.fromAffine(this).multiply(Ot, this).toAffine();
    }
    multiplyAndAddUnsafe(Ot, Ht, Wt) {
      const Yt = yt.fromAffine(this), er = Ht === W || Ht === K || this !== xt.BASE ? Yt.multiplyUnsafe(Ht) : Yt.multiply(Ht), rr = yt.fromAffine(Ot).multiplyUnsafe(Wt), ir = er.add(rr);
      return ir.equals(yt.ZERO) ? void 0 : ir.toAffine();
    }
  }
  B.Point = xt, xt.BASE = new xt(ie.Gx, ie.Gy), xt.ZERO = new xt(W, W);
  function Ct(Dt) {
    return Number.parseInt(Dt[0], 16) >= 8 ? "00" + Dt : Dt;
  }
  function Et(Dt) {
    if (Dt.length < 2 || Dt[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${it(Dt)}`);
    const Ot = Dt[1], Ht = Dt.subarray(2, Ot + 2);
    if (!Ot || Ht.length !== Ot)
      throw new Error("Invalid signature integer: wrong length");
    if (Ht[0] === 0 && Ht[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ut(Ht), left: Dt.subarray(Ot + 2) };
  }
  function St(Dt) {
    if (Dt.length < 2 || Dt[0] != 48)
      throw new Error(`Invalid signature tag: ${it(Dt)}`);
    if (Dt[1] !== Dt.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Ot, left: Ht } = Et(Dt.subarray(2)), { data: Wt, left: Yt } = Et(Ht);
    if (Yt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${it(Yt)}`);
    return { r: Ot, s: Wt };
  }
  class It {
    constructor(Ot, Ht) {
      this.r = Ot, this.s = Ht, this.assertValidity();
    }
    static fromCompact(Ot) {
      const Ht = Ot instanceof Uint8Array, Wt = "Signature.fromCompact";
      if (typeof Ot != "string" && !Ht)
        throw new TypeError(`${Wt}: Expected string or Uint8Array`);
      const Yt = Ht ? it(Ot) : Ot;
      if (Yt.length !== 128)
        throw new Error(`${Wt}: Expected 64-byte hex`);
      return new It(ct(Yt.slice(0, 64)), ct(Yt.slice(64, 128)));
    }
    static fromDER(Ot) {
      const Ht = Ot instanceof Uint8Array;
      if (typeof Ot != "string" && !Ht)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Wt, s: Yt } = St(Ht ? Ot : bt(Ot));
      return new It(Wt, Yt);
    }
    static fromHex(Ot) {
      return this.fromDER(Ot);
    }
    assertValidity() {
      const { r: Ot, s: Ht } = this;
      if (!Gt(Ot))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Gt(Ht))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Ot = ie.n >> K;
      return this.s > Ot;
    }
    normalizeS() {
      return this.hasHighS() ? new It(this.r, wt(-this.s, ie.n)) : this;
    }
    toDERRawBytes() {
      return bt(this.toDERHex());
    }
    toDERHex() {
      const Ot = Ct(ft(this.s)), Ht = Ct(ft(this.r)), Wt = Ot.length / 2, Yt = Ht.length / 2, er = ft(Wt), rr = ft(Yt);
      return `30${ft(Yt + Wt + 4)}02${rr}${Ht}02${er}${Ot}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return bt(this.toCompactHex());
    }
    toCompactHex() {
      return rt(this.r) + rt(this.s);
    }
  }
  B.Signature = It;
  function Tt(...Dt) {
    if (!Dt.every((Wt) => Wt instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Dt.length === 1)
      return Dt[0];
    const Ot = Dt.reduce((Wt, Yt) => Wt + Yt.length, 0), Ht = new Uint8Array(Ot);
    for (let Wt = 0, Yt = 0; Wt < Dt.length; Wt++) {
      const er = Dt[Wt];
      Ht.set(er, Yt), Yt += er.length;
    }
    return Ht;
  }
  const nt = Array.from({ length: 256 }, (Dt, Ot) => Ot.toString(16).padStart(2, "0"));
  function it(Dt) {
    if (!(Dt instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Ot = "";
    for (let Ht = 0; Ht < Dt.length; Ht++)
      Ot += nt[Dt[Ht]];
    return Ot;
  }
  const ke = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function rt(Dt) {
    if (typeof Dt != "bigint")
      throw new Error("Expected bigint");
    if (!(W <= Dt && Dt < ke))
      throw new Error("Expected number 0 <= n < 2^256");
    return Dt.toString(16).padStart(64, "0");
  }
  function ot(Dt) {
    const Ot = bt(rt(Dt));
    if (Ot.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Ot;
  }
  function ft(Dt) {
    const Ot = Dt.toString(16);
    return Ot.length & 1 ? `0${Ot}` : Ot;
  }
  function ct(Dt) {
    if (typeof Dt != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Dt);
    return BigInt(`0x${Dt}`);
  }
  function bt(Dt) {
    if (typeof Dt != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Dt);
    if (Dt.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Dt.length);
    const Ot = new Uint8Array(Dt.length / 2);
    for (let Ht = 0; Ht < Ot.length; Ht++) {
      const Wt = Ht * 2, Yt = Dt.slice(Wt, Wt + 2), er = Number.parseInt(Yt, 16);
      if (Number.isNaN(er) || er < 0)
        throw new Error("Invalid byte sequence");
      Ot[Ht] = er;
    }
    return Ot;
  }
  function ut(Dt) {
    return ct(it(Dt));
  }
  function gt(Dt) {
    return Dt instanceof Uint8Array ? Uint8Array.from(Dt) : bt(Dt);
  }
  function dt(Dt) {
    if (typeof Dt == "number" && Number.isSafeInteger(Dt) && Dt > 0)
      return BigInt(Dt);
    if (typeof Dt == "bigint" && Gt(Dt))
      return Dt;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function wt(Dt, Ot = ie.P) {
    const Ht = Dt % Ot;
    return Ht >= W ? Ht : Ot + Ht;
  }
  function Ft(Dt, Ot) {
    const { P: Ht } = ie;
    let Wt = Dt;
    for (; Ot-- > W; )
      Wt *= Wt, Wt %= Ht;
    return Wt;
  }
  function jt(Dt) {
    const { P: Ot } = ie, Ht = BigInt(6), Wt = BigInt(11), Yt = BigInt(22), er = BigInt(23), rr = BigInt(44), ir = BigInt(88), ur = Dt * Dt * Dt % Ot, sr = ur * ur * Dt % Ot, br = Ft(sr, V) * sr % Ot, _r = Ft(br, V) * sr % Ot, or = Ft(_r, J) * ur % Ot, Lt = Ft(or, Wt) * or % Ot, Zt = Ft(Lt, Yt) * Lt % Ot, tr = Ft(Zt, rr) * Zt % Ot, fr = Ft(tr, ir) * tr % Ot, gr = Ft(fr, rr) * Zt % Ot, Er = Ft(gr, V) * sr % Ot, Ir = Ft(Er, er) * Lt % Ot, Br = Ft(Ir, Ht) * ur % Ot, Ur = Ft(Br, J);
    if (Ur * Ur % Ot !== Dt)
      throw new Error("Cannot find square root");
    return Ur;
  }
  function Nt(Dt, Ot = ie.P) {
    if (Dt === W || Ot <= W)
      throw new Error(`invert: expected positive integers, got n=${Dt} mod=${Ot}`);
    let Ht = wt(Dt, Ot), Wt = Ot, Yt = W, er = K;
    for (; Ht !== W; ) {
      const ir = Wt / Ht, ur = Wt % Ht, sr = Yt - er * ir;
      Wt = Ht, Ht = ur, Yt = er, er = sr;
    }
    if (Wt !== K)
      throw new Error("invert: does not exist");
    return wt(Yt, Ot);
  }
  function Bt(Dt, Ot = ie.P) {
    const Ht = new Array(Dt.length), Wt = Dt.reduce((er, rr, ir) => rr === W ? er : (Ht[ir] = er, wt(er * rr, Ot)), K), Yt = Nt(Wt, Ot);
    return Dt.reduceRight((er, rr, ir) => rr === W ? er : (Ht[ir] = wt(er * Ht[ir], Ot), wt(er * rr, Ot)), Yt), Ht;
  }
  function Rt(Dt) {
    const Ot = Dt.length * 8 - ce * 8, Ht = ut(Dt);
    return Ot > 0 ? Ht >> BigInt(Ot) : Ht;
  }
  function Ut(Dt, Ot = !1) {
    const Ht = Rt(Dt);
    if (Ot)
      return Ht;
    const { n: Wt } = ie;
    return Ht >= Wt ? Ht - Wt : Ht;
  }
  let zt, Mt;
  class kt {
    constructor(Ot, Ht) {
      if (this.hashLen = Ot, this.qByteLen = Ht, typeof Ot != "number" || Ot < 2)
        throw new Error("hashLen must be a number");
      if (typeof Ht != "number" || Ht < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Ot).fill(1), this.k = new Uint8Array(Ot).fill(0), this.counter = 0;
    }
    hmac(...Ot) {
      return B.utils.hmacSha256(this.k, ...Ot);
    }
    hmacSync(...Ot) {
      return Mt(this.k, ...Ot);
    }
    checkSync() {
      if (typeof Mt != "function")
        throw new pt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Ot = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Ot), this.v = await this.hmac(this.v), Ot.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Ot), this.v = await this.hmac(this.v));
    }
    reseedSync(Ot = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Ot), this.v = this.hmacSync(this.v), Ot.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Ot), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Ot = 0;
      const Ht = [];
      for (; Ot < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Wt = this.v.slice();
        Ht.push(Wt), Ot += this.v.length;
      }
      return Tt(...Ht);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Ot = 0;
      const Ht = [];
      for (; Ot < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Wt = this.v.slice();
        Ht.push(Wt), Ot += this.v.length;
      }
      return Tt(...Ht);
    }
  }
  function Gt(Dt) {
    return W < Dt && Dt < ie.n;
  }
  function Qt(Dt) {
    return W < Dt && Dt < ie.P;
  }
  function nr(Dt, Ot, Ht, Wt = !0) {
    const { n: Yt } = ie, er = Ut(Dt, !0);
    if (!Gt(er))
      return;
    const rr = Nt(er, Yt), ir = xt.BASE.multiply(er), ur = wt(ir.x, Yt);
    if (ur === W)
      return;
    const sr = wt(rr * wt(Ot + Ht * ur, Yt), Yt);
    if (sr === W)
      return;
    let br = new It(ur, sr), _r = (ir.x === br.r ? 0 : 2) | Number(ir.y & K);
    return Wt && br.hasHighS() && (br = br.normalizeS(), _r ^= 1), { sig: br, recovery: _r };
  }
  function ar(Dt) {
    let Ot;
    if (typeof Dt == "bigint")
      Ot = Dt;
    else if (typeof Dt == "number" && Number.isSafeInteger(Dt) && Dt > 0)
      Ot = BigInt(Dt);
    else if (typeof Dt == "string") {
      if (Dt.length !== 2 * ce)
        throw new Error("Expected 32 bytes of private key");
      Ot = ct(Dt);
    } else if (Dt instanceof Uint8Array) {
      if (Dt.length !== ce)
        throw new Error("Expected 32 bytes of private key");
      Ot = ut(Dt);
    } else
      throw new TypeError("Expected valid private key");
    if (!Gt(Ot))
      throw new Error("Expected private key: 0 < key < n");
    return Ot;
  }
  function cr(Dt) {
    return Dt instanceof xt ? (Dt.assertValidity(), Dt) : xt.fromHex(Dt);
  }
  function hr(Dt) {
    if (Dt instanceof It)
      return Dt.assertValidity(), Dt;
    try {
      return It.fromDER(Dt);
    } catch {
      return It.fromCompact(Dt);
    }
  }
  function Jt(Dt, Ot = !1) {
    return xt.fromPrivateKey(Dt).toRawBytes(Ot);
  }
  B.getPublicKey = Jt;
  function Pr(Dt, Ot, Ht, Wt = !1) {
    return xt.fromSignature(Dt, Ot, Ht).toRawBytes(Wt);
  }
  B.recoverPublicKey = Pr;
  function dr(Dt) {
    const Ot = Dt instanceof Uint8Array, Ht = typeof Dt == "string", Wt = (Ot || Ht) && Dt.length;
    return Ot ? Wt === Oe || Wt === st : Ht ? Wt === Oe * 2 || Wt === st * 2 : Dt instanceof xt;
  }
  function Tr(Dt, Ot, Ht = !1) {
    if (dr(Dt))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!dr(Ot))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Wt = cr(Ot);
    return Wt.assertValidity(), Wt.multiply(ar(Dt)).toRawBytes(Ht);
  }
  B.getSharedSecret = Tr;
  function Rr(Dt) {
    const Ot = Dt.length > ne ? Dt.slice(0, ne) : Dt;
    return ut(Ot);
  }
  function pr(Dt) {
    const Ot = Rr(Dt), Ht = wt(Ot, ie.n);
    return $r(Ht < W ? Ot : Ht);
  }
  function $r(Dt) {
    return ot(Dt);
  }
  function kr(Dt, Ot, Ht) {
    if (Dt == null)
      throw new Error(`sign: expected valid message hash, not "${Dt}"`);
    const Wt = gt(Dt), Yt = ar(Ot), er = [$r(Yt), pr(Wt)];
    if (Ht != null) {
      Ht === !0 && (Ht = B.utils.randomBytes(ne));
      const ur = gt(Ht);
      if (ur.length !== ne)
        throw new Error(`sign: Expected ${ne} bytes of extra data`);
      er.push(ur);
    }
    const rr = Tt(...er), ir = Rr(Wt);
    return { seed: rr, m: ir, d: Yt };
  }
  function vr(Dt, Ot) {
    const { sig: Ht, recovery: Wt } = Dt, { der: Yt, recovered: er } = Object.assign({ canonical: !0, der: !0 }, Ot), rr = Yt ? Ht.toDERRawBytes() : Ht.toCompactRawBytes();
    return er ? [rr, Wt] : rr;
  }
  async function Mr(Dt, Ot, Ht = {}) {
    const { seed: Wt, m: Yt, d: er } = kr(Dt, Ot, Ht.extraEntropy), rr = new kt(Ce, ce);
    await rr.reseed(Wt);
    let ir;
    for (; !(ir = nr(await rr.generate(), Yt, er, Ht.canonical)); )
      await rr.reseed();
    return vr(ir, Ht);
  }
  B.sign = Mr;
  function Nr(Dt, Ot, Ht = {}) {
    const { seed: Wt, m: Yt, d: er } = kr(Dt, Ot, Ht.extraEntropy), rr = new kt(Ce, ce);
    rr.reseedSync(Wt);
    let ir;
    for (; !(ir = nr(rr.generateSync(), Yt, er, Ht.canonical)); )
      rr.reseedSync();
    return vr(ir, Ht);
  }
  B.signSync = Nr;
  const Pt = { strict: !0 };
  function mt(Dt, Ot, Ht, Wt = Pt) {
    let Yt;
    try {
      Yt = hr(Dt), Ot = gt(Ot);
    } catch {
      return !1;
    }
    const { r: er, s: rr } = Yt;
    if (Wt.strict && Yt.hasHighS())
      return !1;
    const ir = Ut(Ot);
    let ur;
    try {
      ur = cr(Ht);
    } catch {
      return !1;
    }
    const { n: sr } = ie, br = Nt(rr, sr), _r = wt(ir * br, sr), or = wt(er * br, sr), Lt = xt.BASE.multiplyAndAddUnsafe(ur, _r, or);
    return Lt ? wt(Lt.x, sr) === er : !1;
  }
  B.verify = mt;
  function At(Dt) {
    return wt(ut(Dt), ie.n);
  }
  class qt {
    constructor(Ot, Ht) {
      this.r = Ot, this.s = Ht, this.assertValidity();
    }
    static fromHex(Ot) {
      const Ht = gt(Ot);
      if (Ht.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Ht.length}`);
      const Wt = ut(Ht.subarray(0, 32)), Yt = ut(Ht.subarray(32, 64));
      return new qt(Wt, Yt);
    }
    assertValidity() {
      const { r: Ot, s: Ht } = this;
      if (!Qt(Ot) || !Gt(Ht))
        throw new Error("Invalid signature");
    }
    toHex() {
      return rt(this.r) + rt(this.s);
    }
    toRawBytes() {
      return bt(this.toHex());
    }
  }
  function Kt(Dt) {
    return xt.fromPrivateKey(Dt).toRawX();
  }
  class Vt {
    constructor(Ot, Ht, Wt = B.utils.randomBytes()) {
      if (Ot == null)
        throw new TypeError(`sign: Expected valid message, not "${Ot}"`);
      this.m = gt(Ot);
      const { x: Yt, scalar: er } = this.getScalar(ar(Ht));
      if (this.px = Yt, this.d = er, this.rand = gt(Wt), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Ot) {
      const Ht = xt.fromPrivateKey(Ot), Wt = Ht.hasEvenY() ? Ot : ie.n - Ot;
      return { point: Ht, scalar: Wt, x: Ht.toRawX() };
    }
    initNonce(Ot, Ht) {
      return ot(Ot ^ ut(Ht));
    }
    finalizeNonce(Ot) {
      const Ht = wt(ut(Ot), ie.n);
      if (Ht === W)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Wt, x: Yt, scalar: er } = this.getScalar(Ht);
      return { R: Wt, rx: Yt, k: er };
    }
    finalizeSig(Ot, Ht, Wt, Yt) {
      return new qt(Ot.x, wt(Ht + Wt * Yt, ie.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Ot, d: Ht, px: Wt, rand: Yt } = this, er = B.utils.taggedHash, rr = this.initNonce(Ht, await er(Or.aux, Yt)), { R: ir, rx: ur, k: sr } = this.finalizeNonce(await er(Or.nonce, rr, Wt, Ot)), br = At(await er(Or.challenge, ur, Wt, Ot)), _r = this.finalizeSig(ir, sr, br, Ht);
      return await xr(_r, Ot, Wt) || this.error(), _r;
    }
    calcSync() {
      const { m: Ot, d: Ht, px: Wt, rand: Yt } = this, er = B.utils.taggedHashSync, rr = this.initNonce(Ht, er(Or.aux, Yt)), { R: ir, rx: ur, k: sr } = this.finalizeNonce(er(Or.nonce, rr, Wt, Ot)), br = At(er(Or.challenge, ur, Wt, Ot)), _r = this.finalizeSig(ir, sr, br, Ht);
      return wr(_r, Ot, Wt) || this.error(), _r;
    }
  }
  async function Xt(Dt, Ot, Ht) {
    return new Vt(Dt, Ot, Ht).calc();
  }
  function yr(Dt, Ot, Ht) {
    return new Vt(Dt, Ot, Ht).calcSync();
  }
  function Ar(Dt, Ot, Ht) {
    const Wt = Dt instanceof qt, Yt = Wt ? Dt : qt.fromHex(Dt);
    return Wt && Yt.assertValidity(), {
      ...Yt,
      m: gt(Ot),
      P: cr(Ht)
    };
  }
  function lr(Dt, Ot, Ht, Wt) {
    const Yt = xt.BASE.multiplyAndAddUnsafe(Ot, ar(Ht), wt(-Wt, ie.n));
    return !(!Yt || !Yt.hasEvenY() || Yt.x !== Dt);
  }
  async function xr(Dt, Ot, Ht) {
    try {
      const { r: Wt, s: Yt, m: er, P: rr } = Ar(Dt, Ot, Ht), ir = At(await B.utils.taggedHash(Or.challenge, ot(Wt), rr.toRawX(), er));
      return lr(Wt, rr, Yt, ir);
    } catch {
      return !1;
    }
  }
  function wr(Dt, Ot, Ht) {
    try {
      const { r: Wt, s: Yt, m: er, P: rr } = Ar(Dt, Ot, Ht), ir = At(B.utils.taggedHashSync(Or.challenge, ot(Wt), rr.toRawX(), er));
      return lr(Wt, rr, Yt, ir);
    } catch (Wt) {
      if (Wt instanceof pt)
        throw Wt;
      return !1;
    }
  }
  B.schnorr = {
    Signature: qt,
    getPublicKey: Kt,
    sign: Xt,
    verify: xr,
    signSync: yr,
    verifySync: wr
  }, xt.BASE._setWindowSize(8);
  const Sr = {
    node: L,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Or = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, qr = {};
  B.utils = {
    bytesToHex: it,
    hexToBytes: bt,
    concatBytes: Tt,
    mod: wt,
    invert: Nt,
    isValidPrivateKey(Dt) {
      try {
        return ar(Dt), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: ot,
    _normalizePrivateKey: ar,
    hashToPrivateKey: (Dt) => {
      Dt = gt(Dt);
      const Ot = ce + 8;
      if (Dt.length < Ot || Dt.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Ht = wt(ut(Dt), ie.n - K) + K;
      return ot(Ht);
    },
    randomBytes: (Dt = 32) => {
      if (Sr.web)
        return Sr.web.getRandomValues(new Uint8Array(Dt));
      if (Sr.node) {
        const { randomBytes: Ot } = Sr.node;
        return Uint8Array.from(Ot(Dt));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(ce + 8)),
    precompute(Dt = 8, Ot = xt.BASE) {
      const Ht = Ot === xt.BASE ? Ot : new xt(Ot.x, Ot.y);
      return Ht._setWindowSize(Dt), Ht.multiply(V), Ht;
    },
    sha256: async (...Dt) => {
      if (Sr.web) {
        const Ot = await Sr.web.subtle.digest("SHA-256", Tt(...Dt));
        return new Uint8Array(Ot);
      } else if (Sr.node) {
        const { createHash: Ot } = Sr.node, Ht = Ot("sha256");
        return Dt.forEach((Wt) => Ht.update(Wt)), Uint8Array.from(Ht.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Dt, ...Ot) => {
      if (Sr.web) {
        const Ht = await Sr.web.subtle.importKey("raw", Dt, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Wt = Tt(...Ot), Yt = await Sr.web.subtle.sign("HMAC", Ht, Wt);
        return new Uint8Array(Yt);
      } else if (Sr.node) {
        const { createHmac: Ht } = Sr.node, Wt = Ht("sha256", Dt);
        return Ot.forEach((Yt) => Wt.update(Yt)), Uint8Array.from(Wt.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Dt, ...Ot) => {
      let Ht = qr[Dt];
      if (Ht === void 0) {
        const Wt = await B.utils.sha256(Uint8Array.from(Dt, (Yt) => Yt.charCodeAt(0)));
        Ht = Tt(Wt, Wt), qr[Dt] = Ht;
      }
      return B.utils.sha256(Ht, ...Ot);
    },
    taggedHashSync: (Dt, ...Ot) => {
      if (typeof zt != "function")
        throw new pt("sha256Sync is undefined, you need to set it");
      let Ht = qr[Dt];
      if (Ht === void 0) {
        const Wt = zt(Uint8Array.from(Dt, (Yt) => Yt.charCodeAt(0)));
        Ht = Tt(Wt, Wt), qr[Dt] = Ht;
      }
      return zt(Ht, ...Ot);
    },
    _JacobianPoint: yt
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return zt;
      },
      set(Dt) {
        zt || (zt = Dt);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Mt;
      },
      set(Dt) {
        Mt || (Mt = Dt);
      }
    }
  });
})(lib$1);
var necc = lib$1, hmac = hmac$2, sha256$1 = sha256$5;
function _interopNamespaceDefault(B) {
  var L = /* @__PURE__ */ Object.create(null);
  return B && Object.keys(B).forEach(function(W) {
    if (W !== "default") {
      var K = Object.getOwnPropertyDescriptor(B, W);
      Object.defineProperty(L, W, K.get ? K : {
        enumerable: !0,
        get: function() {
          return B[W];
        }
      });
    }
  }), L.default = B, Object.freeze(L);
}
var necc__namespace = /* @__PURE__ */ _interopNamespaceDefault(necc);
const THROW_BAD_PRIVATE = "Expected Private", THROW_BAD_POINT = "Expected Point", THROW_BAD_TWEAK = "Expected Tweak", THROW_BAD_HASH = "Expected Hash", THROW_BAD_SIGNATURE = "Expected Signature", THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)", THROW_BAD_SCALAR = "Expected Scalar", THROW_BAD_RECOVERY_ID = "Bad Recovery Id";
necc__namespace.utils.hmacSha256Sync = (B, ...L) => hmac.hmac(sha256$1.sha256, B, necc__namespace.utils.concatBytes(...L));
necc__namespace.utils.sha256Sync = (...B) => sha256$1.sha256(necc__namespace.utils.concatBytes(...B));
const normalizePrivateKey = necc__namespace.utils._normalizePrivateKey, HASH_SIZE = 32, TWEAK_SIZE = 32, BN32_N = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]), EXTRA_DATA_SIZE = 32, BN32_ZERO = new Uint8Array(32), BN32_P_MINUS_N = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function isUint8Array(B) {
  return B instanceof Uint8Array;
}
function cmpBN32(B, L) {
  for (let W = 0; W < 32; ++W)
    if (B[W] !== L[W])
      return B[W] < L[W] ? -1 : 1;
  return 0;
}
function isZero(B) {
  return cmpBN32(B, BN32_ZERO) === 0;
}
function isTweak(B) {
  return !(!(B instanceof Uint8Array) || B.length !== TWEAK_SIZE || cmpBN32(B, BN32_N) >= 0);
}
function isSignature(B) {
  return B instanceof Uint8Array && B.length === 64 && cmpBN32(B.subarray(0, 32), BN32_N) < 0 && cmpBN32(B.subarray(32, 64), BN32_N) < 0;
}
function isSigrLessThanPMinusN(B) {
  return isUint8Array(B) && B.length === 64 && cmpBN32(B.subarray(0, 32), BN32_P_MINUS_N) < 0;
}
function isSignatureNonzeroRS(B) {
  return !(isZero(B.subarray(0, 32)) || isZero(B.subarray(32, 64)));
}
function isHash(B) {
  return B instanceof Uint8Array && B.length === HASH_SIZE;
}
function isExtraData(B) {
  return B === void 0 || B instanceof Uint8Array && B.length === EXTRA_DATA_SIZE;
}
function hexToNumber(B) {
  if (typeof B != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof B);
  return BigInt(`0x${B}`);
}
function bytesToNumber(B) {
  return hexToNumber(necc__namespace.utils.bytesToHex(B));
}
function normalizeScalar(B) {
  let L;
  if (typeof B == "bigint")
    L = B;
  else if (typeof B == "number" && Number.isSafeInteger(B) && B >= 0)
    L = BigInt(B);
  else if (typeof B == "string") {
    if (B.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    L = hexToNumber(B);
  } else if (B instanceof Uint8Array) {
    if (B.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    L = bytesToNumber(B);
  } else
    throw new TypeError("Expected valid private scalar");
  if (L < 0) throw new Error("Expected private scalar >= 0");
  return L;
}
const _privateAdd = (B, L) => {
  const W = normalizePrivateKey(B), K = normalizeScalar(L), J = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(W + K, necc__namespace.CURVE.n));
  return necc__namespace.utils.isValidPrivateKey(J) ? J : null;
}, _privateSub = (B, L) => {
  const W = normalizePrivateKey(B), K = normalizeScalar(L), J = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(W - K, necc__namespace.CURVE.n));
  return necc__namespace.utils.isValidPrivateKey(J) ? J : null;
}, _privateNegate = (B) => {
  const L = normalizePrivateKey(B), W = necc__namespace.utils._bigintTo32Bytes(necc__namespace.CURVE.n - L);
  return necc__namespace.utils.isValidPrivateKey(W) ? W : null;
}, _pointAddScalar = (B, L, W) => {
  const K = necc__namespace.Point.fromHex(B), J = normalizeScalar(L), V = necc__namespace.Point.BASE.multiplyAndAddUnsafe(K, J, BigInt(1));
  if (!V) throw new Error("Tweaked point at infinity");
  return V.toRawBytes(W);
}, _pointMultiply = (B, L, W) => {
  const K = necc__namespace.Point.fromHex(B), J = typeof L == "string" ? L : necc__namespace.utils.bytesToHex(L), V = BigInt(`0x${J}`);
  return K.multiply(V).toRawBytes(W);
};
function assumeCompression(B, L) {
  return B === void 0 ? L !== void 0 ? isPointCompressed(L) : !0 : !!B;
}
function throwToNull(B) {
  try {
    return B();
  } catch {
    return null;
  }
}
function _isPoint(B, L) {
  if (B.length === 32 !== L) return !1;
  try {
    return !!necc__namespace.Point.fromHex(B);
  } catch {
    return !1;
  }
}
function isPoint(B) {
  return _isPoint(B, !1);
}
function isPointCompressed(B) {
  return _isPoint(B, !1) && B.length === 33;
}
function isPrivate(B) {
  return necc__namespace.utils.isValidPrivateKey(B);
}
function isXOnlyPoint(B) {
  return _isPoint(B, !0);
}
function xOnlyPointAddTweak(B, L) {
  if (!isXOnlyPoint(B))
    throw new Error(THROW_BAD_POINT);
  if (!isTweak(L))
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => {
    const W = _pointAddScalar(B, L, !0);
    return { parity: W[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: W.slice(1) };
  });
}
function xOnlyPointFromPoint(B) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  return B.slice(1, 33);
}
function pointFromScalar(B, L) {
  if (!isPrivate(B))
    throw new Error(THROW_BAD_PRIVATE);
  return throwToNull(
    () => necc__namespace.getPublicKey(B, assumeCompression(L))
  );
}
function xOnlyPointFromScalar(B) {
  if (!isPrivate(B))
    throw new Error(THROW_BAD_PRIVATE);
  return xOnlyPointFromPoint(pointFromScalar(B));
}
function pointCompress(B, L) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  return necc__namespace.Point.fromHex(B).toRawBytes(assumeCompression(L, B));
}
function pointMultiply(B, L, W) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  if (!isTweak(L))
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(
    () => _pointMultiply(B, L, assumeCompression(W, B))
  );
}
function pointAdd(B, L, W) {
  if (!isPoint(B) || !isPoint(L))
    throw new Error(THROW_BAD_POINT);
  return throwToNull(() => {
    const K = necc__namespace.Point.fromHex(B), J = necc__namespace.Point.fromHex(L);
    return K.equals(J.negate()) ? null : K.add(J).toRawBytes(assumeCompression(W, B));
  });
}
function pointAddScalar(B, L, W) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  if (!isTweak(L))
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(
    () => _pointAddScalar(B, L, assumeCompression(W, B))
  );
}
function privateAdd(B, L) {
  if (isPrivate(B) === !1)
    throw new Error(THROW_BAD_PRIVATE);
  if (isTweak(L) === !1)
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _privateAdd(B, L));
}
function privateSub(B, L) {
  if (isPrivate(B) === !1)
    throw new Error(THROW_BAD_PRIVATE);
  if (isTweak(L) === !1)
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _privateSub(B, L));
}
function privateNegate(B) {
  if (isPrivate(B) === !1)
    throw new Error(THROW_BAD_PRIVATE);
  return _privateNegate(B);
}
function sign(B, L, W) {
  if (!isPrivate(L))
    throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(W))
    throw new Error(THROW_BAD_EXTRA_DATA);
  return necc__namespace.signSync(B, L, { der: !1, extraEntropy: W });
}
function signRecoverable(B, L, W) {
  if (!isPrivate(L))
    throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(W))
    throw new Error(THROW_BAD_EXTRA_DATA);
  const [K, J] = necc__namespace.signSync(B, L, { der: !1, extraEntropy: W, recovered: !0 });
  return { signature: K, recoveryId: J };
}
function signSchnorr(B, L, W = Buffer$2.alloc(32, 0)) {
  if (!isPrivate(L))
    throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(W))
    throw new Error(THROW_BAD_EXTRA_DATA);
  return necc__namespace.schnorr.signSync(B, L, W);
}
function recover(B, L, W, K) {
  if (!isHash(B))
    throw new Error(THROW_BAD_HASH);
  if (!isSignature(L) || !isSignatureNonzeroRS(L))
    throw new Error(THROW_BAD_SIGNATURE);
  if (W & 2 && !isSigrLessThanPMinusN(L))
    throw new Error(THROW_BAD_RECOVERY_ID);
  if (!isXOnlyPoint(L.subarray(0, 32)))
    throw new Error(THROW_BAD_SIGNATURE);
  return necc__namespace.recoverPublicKey(B, L, W, assumeCompression(K));
}
function verify(B, L, W, K) {
  if (!isPoint(L))
    throw new Error(THROW_BAD_POINT);
  if (!isSignature(W))
    throw new Error(THROW_BAD_SIGNATURE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  return necc__namespace.verify(W, B, L, { strict: K });
}
function verifySchnorr(B, L, W) {
  if (!isXOnlyPoint(L))
    throw new Error(THROW_BAD_POINT);
  if (!isSignature(W))
    throw new Error(THROW_BAD_SIGNATURE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  return necc__namespace.schnorr.verifySync(W, B, L);
}
var isPoint_1 = dist.isPoint = isPoint, isPointCompressed_1 = dist.isPointCompressed = isPointCompressed, isPrivate_1 = dist.isPrivate = isPrivate, isXOnlyPoint_1 = dist.isXOnlyPoint = isXOnlyPoint, pointAdd_1 = dist.pointAdd = pointAdd, pointAddScalar_1 = dist.pointAddScalar = pointAddScalar, pointCompress_1 = dist.pointCompress = pointCompress, pointFromScalar_1 = dist.pointFromScalar = pointFromScalar, pointMultiply_1 = dist.pointMultiply = pointMultiply, privateAdd_1 = dist.privateAdd = privateAdd, privateNegate_1 = dist.privateNegate = privateNegate, privateSub_1 = dist.privateSub = privateSub, recover_1 = dist.recover = recover, sign_1 = dist.sign = sign, signRecoverable_1 = dist.signRecoverable = signRecoverable, signSchnorr_1 = dist.signSchnorr = signSchnorr, verify_1 = dist.verify = verify, verifySchnorr_1 = dist.verifySchnorr = verifySchnorr, xOnlyPointAddTweak_1 = dist.xOnlyPointAddTweak = xOnlyPointAddTweak, xOnlyPointFromPoint_1 = dist.xOnlyPointFromPoint = xOnlyPointFromPoint, xOnlyPointFromScalar_1 = dist.xOnlyPointFromScalar = xOnlyPointFromScalar;
const ecc = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: dist,
  isPoint: isPoint_1,
  isPointCompressed: isPointCompressed_1,
  isPrivate: isPrivate_1,
  isXOnlyPoint: isXOnlyPoint_1,
  pointAdd: pointAdd_1,
  pointAddScalar: pointAddScalar_1,
  pointCompress: pointCompress_1,
  pointFromScalar: pointFromScalar_1,
  pointMultiply: pointMultiply_1,
  privateAdd: privateAdd_1,
  privateNegate: privateNegate_1,
  privateSub: privateSub_1,
  recover: recover_1,
  sign: sign_1,
  signRecoverable: signRecoverable_1,
  signSchnorr: signSchnorr_1,
  verify: verify_1,
  verifySchnorr: verifySchnorr_1,
  xOnlyPointAddTweak: xOnlyPointAddTweak_1,
  xOnlyPointFromPoint: xOnlyPointFromPoint_1,
  xOnlyPointFromScalar: xOnlyPointFromScalar_1
}, [dist]), MINIMUM_AMOUNT_IN_SATS = 600, MAXIMUM_FEE = 5e6, INSTANT_BUY_SELLER_INPUT_INDEX = 2, BIP32 = src$2.BIP32Factory(ecc), CHAIN_CODE = Buffer$2.alloc(32, 1);
class BrowserWalletExtractTxFromNonFinalizedPsbtError extends Error {
  constructor(L = "Cannot extract transaction from non-finalized psbt.") {
    super(L), this.name = "BrowserWalletExtractTxFromNonFinalizedPsbtError";
  }
}
class BrowserWalletNetworkMismatchError extends Error {
  constructor(L) {
    super(L), this.name = "BrowserWalletNetworkMismatchError";
  }
}
class BrowserWalletNotInstalledError extends Error {
  constructor(L) {
    super(L), this.name = "BrowserWalletNotInstalledError";
  }
}
class BrowserWalletRequestCancelledByUserError extends Error {
  constructor(L = "Request canceled by user.") {
    super(L), this.name = "BrowserWalletRequestCancelledByUserError";
  }
}
class BrowserWalletSigningError extends Error {
  constructor(L) {
    super(L), this.name = "BrowserWalletSigningError";
  }
}
class OrditSDKError extends Error {
  constructor(L) {
    super(L), this.name = "OrditSDKError";
  }
}
var src = {}, ecpair = {}, networks$1 = {};
Object.defineProperty(networks$1, "__esModule", { value: !0 });
networks$1.testnet = networks$1.bitcoin = void 0;
networks$1.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
networks$1.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var types$1 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.maybe = B.Boolean = B.Array = B.Buffer256bit = B.Network = B.typeforce = void 0, B.typeforce = typeforce_1, B.Network = B.typeforce.compile({
    messagePrefix: B.typeforce.oneOf(
      B.typeforce.Buffer,
      B.typeforce.String
    ),
    bip32: {
      public: B.typeforce.UInt32,
      private: B.typeforce.UInt32
    },
    pubKeyHash: B.typeforce.UInt8,
    scriptHash: B.typeforce.UInt8,
    wif: B.typeforce.UInt8
  }), B.Buffer256bit = B.typeforce.BufferN(32), B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.maybe = B.typeforce.maybe;
})(types$1);
var testecc = {};
Object.defineProperty(testecc, "__esModule", { value: !0 });
testecc.testEcc = void 0;
const h = (B) => Buffer$2.from(B, "hex");
function testEcc(B) {
  assert(
    B.isPoint(
      h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    !B.isPoint(
      h("030000000000000000000000000000000000000000000000000000000000000005")
    )
  ), assert(
    B.isPrivate(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isPrivate(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), assert(
    !B.isPrivate(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isPrivate(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
    )
  ), assert(
    !B.isPrivate(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
    )
  ), assert(
    Buffer$2.from(
      B.privateAdd(
        h("0000000000000000000000000000000000000000000000000000000000000001"),
        h("0000000000000000000000000000000000000000000000000000000000000000")
      )
    ).equals(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    B.privateAdd(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      h("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null
  ), assert(
    Buffer$2.from(
      B.privateAdd(
        h("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
        h("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
      )
    ).equals(
      h("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    )
  ), assert(
    Buffer$2.from(
      B.privateNegate(
        h("0000000000000000000000000000000000000000000000000000000000000001")
      )
    ).equals(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), assert(
    Buffer$2.from(
      B.privateNegate(
        h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      )
    ).equals(
      h("0000000000000000000000000000000000000000000000000000000000000003")
    )
  ), assert(
    Buffer$2.from(
      B.privateNegate(
        h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    )
  ), assert(
    Buffer$2.from(
      B.pointCompress(
        h(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      )
    ).equals(
      h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    Buffer$2.from(
      B.pointCompress(
        h(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      )
    ).equals(
      h(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), assert(
    Buffer$2.from(
      B.pointCompress(
        h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !0
      )
    ).equals(
      h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    Buffer$2.from(
      B.pointCompress(
        h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !1
      )
    ).equals(
      h(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), assert(
    Buffer$2.from(
      B.pointFromScalar(
        h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    )
  ), assert(
    B.xOnlyPointAddTweak(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null
  );
  let L = B.xOnlyPointAddTweak(
    h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  assert(
    Buffer$2.from(L.xOnlyPubkey).equals(
      h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && L.parity === 1
  ), L = B.xOnlyPointAddTweak(
    h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), assert(
    Buffer$2.from(L.xOnlyPubkey).equals(
      h("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && L.parity === 0
  ), assert(
    Buffer$2.from(
      B.sign(
        h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
        h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ).equals(
      h(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), assert(
    B.verify(
      h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      h(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), B.signSchnorr && assert(
    Buffer$2.from(
      B.signSchnorr(
        h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
        h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
        h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
      )
    ).equals(
      h(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  ), B.verifySchnorr && assert(
    B.verifySchnorr(
      h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
      h(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  );
}
testecc.testEcc = testEcc;
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
Object.defineProperty(ecpair, "__esModule", { value: !0 });
ecpair.ECPairFactory = ecpair.networks = void 0;
const networks = networks$1;
ecpair.networks = networks;
const types = types$1, randomBytes = requireBrowser$9(), wif = wif$2, testecc_1 = testecc, isOptions = types.typeforce.maybe(
  types.typeforce.compile({
    compressed: types.maybe(types.Boolean),
    network: types.maybe(types.Network)
  })
), toXOnly$1 = (B) => B.length === 32 ? B : B.slice(1, 33);
function ECPairFactory(B) {
  (0, testecc_1.testEcc)(B);
  function L(ie) {
    return B.isPoint(ie);
  }
  function W(ie, oe) {
    if (types.typeforce(types.Buffer256bit, ie), !B.isPrivate(ie))
      throw new TypeError("Private key not in range [1, n)");
    return types.typeforce(isOptions, oe), new re(ie, void 0, oe);
  }
  function K(ie, oe) {
    return types.typeforce(B.isPoint, ie), types.typeforce(isOptions, oe), new re(void 0, ie, oe);
  }
  function J(ie, oe) {
    const pe = wif.decode(ie), ne = pe.version;
    if (types.Array(oe)) {
      if (oe = oe.filter((ce) => ne === ce.wif).pop(), !oe) throw new Error("Unknown network version");
    } else if (oe = oe || networks.bitcoin, ne !== oe.wif) throw new Error("Invalid network version");
    return W(pe.privateKey, {
      compressed: pe.compressed,
      network: oe
    });
  }
  function V(ie) {
    types.typeforce(isOptions, ie), ie === void 0 && (ie = {});
    const oe = ie.rng || randomBytes;
    let pe;
    do
      pe = oe(32), types.typeforce(types.Buffer256bit, pe);
    while (!B.isPrivate(pe));
    return W(pe, ie);
  }
  class re {
    constructor(oe, pe, ne) {
      Cr(this, "__D");
      Cr(this, "__Q");
      Cr(this, "compressed");
      Cr(this, "network");
      Cr(this, "lowR");
      this.__D = oe, this.__Q = pe, this.lowR = !1, ne === void 0 && (ne = {}), this.compressed = ne.compressed === void 0 ? !0 : ne.compressed, this.network = ne.network || networks.bitcoin, pe !== void 0 && (this.__Q = Buffer$2.from(B.pointCompress(pe, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const oe = B.pointFromScalar(this.__D, this.compressed);
        this.__Q = Buffer$2.from(oe);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error("Missing private key");
      return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(oe) {
      return this.privateKey ? this.tweakFromPrivateKey(oe) : this.tweakFromPublicKey(oe);
    }
    sign(oe, pe) {
      if (!this.__D) throw new Error("Missing private key");
      if (pe === void 0 && (pe = this.lowR), pe === !1)
        return Buffer$2.from(B.sign(oe, this.__D));
      {
        let ne = B.sign(oe, this.__D);
        const ce = Buffer$2.alloc(32, 0);
        let Ce = 0;
        for (; ne[0] > 127; )
          Ce++, ce.writeUIntLE(Ce, 0, 6), ne = B.sign(oe, this.__D, ce);
        return Buffer$2.from(ne);
      }
    }
    signSchnorr(oe) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (!B.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer$2.from(B.signSchnorr(oe, this.privateKey));
    }
    verify(oe, pe) {
      return B.verify(oe, this.publicKey, pe);
    }
    verifySchnorr(oe, pe) {
      if (!B.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return B.verifySchnorr(oe, this.publicKey.subarray(1, 33), pe);
    }
    tweakFromPublicKey(oe) {
      const pe = toXOnly$1(this.publicKey), ne = B.xOnlyPointAddTweak(pe, oe);
      if (!ne || ne.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const ce = Buffer$2.from([
        ne.parity === 0 ? 2 : 3
      ]);
      return K(
        Buffer$2.concat([ce, ne.xOnlyPubkey]),
        { network: this.network, compressed: this.compressed }
      );
    }
    tweakFromPrivateKey(oe) {
      const ne = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1 ? B.privateNegate(this.privateKey) : this.privateKey, ce = B.privateAdd(ne, oe);
      if (!ce) throw new Error("Invalid tweaked private key!");
      return W(Buffer$2.from(ce), {
        network: this.network,
        compressed: this.compressed
      });
    }
  }
  return {
    isPoint: L,
    fromPrivateKey: W,
    fromPublicKey: K,
    fromWIF: J,
    makeRandom: V
  };
}
ecpair.ECPairFactory = ECPairFactory;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.networks = B.ECPairFactory = B.default = void 0;
  var L = ecpair;
  Object.defineProperty(B, "default", {
    enumerable: !0,
    get: function() {
      return L.ECPairFactory;
    }
  }), Object.defineProperty(B, "ECPairFactory", {
    enumerable: !0,
    get: function() {
      return L.ECPairFactory;
    }
  }), Object.defineProperty(B, "networks", {
    enumerable: !0,
    get: function() {
      return L.networks;
    }
  });
})(src);
function invert(B) {
  return Object.fromEntries(
    Object.entries(B).map(([L, W]) => [W, L])
  );
}
const ADDRESS_TYPE_TO_FORMAT = {
  p2pkh: "legacy",
  p2sh: "p2sh-p2wpkh",
  p2wsh: "p2wsh",
  p2wpkh: "segwit",
  p2tr: "taproot"
}, ADDRESS_FORMAT_TO_TYPE = invert(ADDRESS_TYPE_TO_FORMAT);
function getNetwork(B) {
  return B === "mainnet" ? src$4.networks.bitcoin : B === "signet" ? src$4.networks.testnet : src$4.networks[B];
}
function createPayment(B, L, W, K) {
  src$4.initEccLib(ecc);
  const J = typeof W == "string" ? getNetwork(W) : W;
  return L === "p2tr" ? src$4.payments.p2tr({
    internalPubkey: B,
    network: J,
    ...K
  }) : L === "p2sh" ? src$4.payments.p2sh({
    redeem: src$4.payments.p2wpkh({ pubkey: B, network: J }),
    network: J
  }) : src$4.payments[L]({ pubkey: B, network: J });
}
function toXOnly(B) {
  return B.subarray(1, 33);
}
const isObject$1 = (B) => (B == null ? void 0 : B.constructor) === Object, isString$1 = (B) => B instanceof String || typeof B == "string";
function encodeDecodeObject(B, { encode: L, depth: W = 0 }) {
  if (W > 5)
    throw new OrditSDKError("Object too deep");
  for (const J in B) {
    if (!B.hasOwnProperty(J))
      continue;
    const V = B[J];
    isObject$1(V) ? B[J] = encodeDecodeObject(V, {
      encode: L,
      depth: W + 1
    }) : isString$1(V) && (B[J] = L ? encodeURIComponent(V) : decodeURIComponent(V));
  }
  return B;
}
function UNSTABLE_decodeObject(B) {
  return encodeDecodeObject(B, { encode: !1 });
}
function convertSatoshisToBTC(B) {
  return B / 10 ** 8;
}
function generateTxUniqueIdentifier(B, L) {
  return `${B}:${L}`;
}
function outpointToIdFormat(B) {
  return B.includes(":") ? B.replace(":", "i") : B.includes("i") ? B : `${B}i0`;
}
function isPaymentFactory(B, L) {
  return (W) => {
    try {
      return B({ output: W, network: getNetwork(L) });
    } catch {
      return !1;
    }
  };
}
const isP2PKH = (B, L) => ({
  type: "p2pkh",
  payload: isPaymentFactory(src$4.payments.p2pkh, L)(B)
}), isP2WPKH = (B, L) => ({
  type: "p2wpkh",
  payload: isPaymentFactory(src$4.payments.p2wpkh, L)(B)
}), isP2SHScript = (B, L) => ({
  type: "p2sh",
  payload: isPaymentFactory(src$4.payments.p2sh, L)(B)
}), isP2TR = (B, L) => ({
  type: "p2tr",
  payload: isPaymentFactory(src$4.payments.p2tr, L)(B)
});
function getScriptType(B, L) {
  const W = isP2PKH(B, L);
  if (W.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2pkh,
      ...W
    };
  const K = isP2WPKH(B, L);
  if (K.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2wpkh,
      ...K
    };
  const J = isP2SHScript(B, L);
  if (J.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2sh,
      ...J
    };
  const V = isP2TR(B, L);
  if (V.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2tr,
      ...V
    };
  throw new OrditSDKError("Unsupported input");
}
function getAddressFormatForRegTest(B) {
  try {
    const { type: L, network: W, bech32: K } = z(B);
    if (!K && W !== "testnet" || K && W !== "regtest")
      throw new Error("Invalid address");
    return ADDRESS_TYPE_TO_FORMAT[L];
  } catch {
    throw new OrditSDKError("Invalid address");
  }
}
function getAddressFormat(B, L) {
  if (L === "regtest")
    return getAddressFormatForRegTest(B);
  if (!O(
    B,
    L === "signet" ? "testnet" : L
  ))
    throw new OrditSDKError("Invalid address");
  const { type: W } = z(B);
  return ADDRESS_TYPE_TO_FORMAT[W];
}
function getTaprootAddressFromBip32PublicKey(B, L) {
  const W = B.subarray(1, 33), { address: K } = createPayment(W, "p2tr", L);
  return {
    address: K,
    // address will never be undefined
    format: ADDRESS_TYPE_TO_FORMAT.p2tr,
    publicKey: B.toString("hex"),
    xKey: W.toString("hex")
  };
}
function getAddressFromBip32PublicKey(B, L, W) {
  if (W === "p2tr")
    return getTaprootAddressFromBip32PublicKey(B, L);
  const { address: K } = createPayment(B, W, L);
  return {
    address: K,
    // address will never be undefined
    format: ADDRESS_TYPE_TO_FORMAT[W],
    publicKey: B.toString("hex")
  };
}
function getAddressesFromPublicKey(B, L = "mainnet", W = "all") {
  const K = Buffer$2.isBuffer(B) ? B : Buffer$2.from(B, "hex"), { publicKey: J } = BIP32.fromPublicKey(
    K,
    CHAIN_CODE,
    getNetwork(L)
  );
  return W === "all" ? Object.keys(ADDRESS_TYPE_TO_FORMAT).filter((re) => re !== "p2wsh").map(
    (re) => getAddressFromBip32PublicKey(J, L, re)
  ) : [getAddressFromBip32PublicKey(J, L, W)];
}
function getNetworkByAddress(B) {
  try {
    const { network: L } = z(B);
    return L;
  } catch {
    throw new OrditSDKError("Invalid address");
  }
}
var LeatherAddressType = /* @__PURE__ */ ((B) => (B.P2WPKH = "p2wpkh", B.P2TR = "p2tr", B))(LeatherAddressType || {});
async function leatherRequest$1(B, L) {
  try {
    return (await window.LeatherProvider.request(
      B,
      L
    )).result;
  } catch (W) {
    const K = W, { message: J } = K.error;
    throw K.error.code === 4001 ? new BrowserWalletRequestCancelledByUserError(J) : new OrditSDKError(`Leather error: ${J}`);
  }
}
function isInstalled$4() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof window.LeatherProvider < "u";
}
async function getAddresses$3(B = "mainnet") {
  if (!isInstalled$4())
    throw new BrowserWalletNotInstalledError("Leather not installed");
  const W = (await leatherRequest$1("getAddresses", {
    network: B
  })).addresses.filter(
    (J) => J.type === LeatherAddressType.P2TR || J.type === LeatherAddressType.P2WPKH
  ), K = getNetworkByAddress(W[0].address);
  if (B !== "signet" && K !== B || B === "signet" && K !== "testnet")
    throw new BrowserWalletNetworkMismatchError(
      "Leather network mismatch, please switch it manually"
    );
  return W.map((J) => ({
    publicKey: J.publicKey,
    address: J.address,
    format: ADDRESS_TYPE_TO_FORMAT[J.type]
  }));
}
async function signMessage$6(B, { network: L = "mainnet", paymentType: W }) {
  if (!isInstalled$4())
    throw new BrowserWalletNotInstalledError("Leather not installed");
  const { signature: K } = await leatherRequest$1(
    "signMessage",
    {
      message: B,
      paymentType: W,
      network: L
    }
  );
  return {
    base64: K,
    hex: Buffer$2.from(K, "base64").toString("hex")
  };
}
async function signPsbt$5(B, {
  finalize: L = !0,
  extractTx: W = !0,
  allowedSighash: K,
  accountNumber: J,
  network: V = "mainnet",
  signAtIndexes: re = []
} = {}) {
  if (!isInstalled$4())
    throw new BrowserWalletNotInstalledError("Leather not installed");
  if (W && !L)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  const ie = B.toHex(), oe = await leatherRequest$1("signPsbt", {
    hex: ie,
    allowedSighash: K,
    account: J,
    network: V,
    signAtIndex: re,
    broadcast: !1
  }), pe = src$4.Psbt.fromHex(oe.hex);
  if (L && re.forEach((ne) => {
    try {
      pe.finalizeInput(ne);
    } catch (ce) {
      throw console.error("Sign psbt error", ce), new OrditSDKError("Failed to finalize input");
    }
  }), W)
    try {
      return {
        base64: null,
        hex: pe.extractTransaction().toHex()
      };
    } catch (ne) {
      throw ne instanceof Error && ne.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
    }
  return {
    base64: pe.toBase64(),
    hex: pe.toHex()
  };
}
var __classPrivateFieldGet = function(B, L, W, K) {
  if (W === "a" && !K) throw new TypeError("Private accessor was defined without a getter");
  if (typeof L == "function" ? B !== L || !K : !L.has(B)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return W === "m" ? K : W === "a" ? K.call(B) : K ? K.value : L.get(B);
}, __classPrivateFieldSet = function(B, L, W, K, J) {
  if (K === "m") throw new TypeError("Private method is not writable");
  if (K === "a" && !J) throw new TypeError("Private accessor was defined without a setter");
  if (typeof L == "function" ? B !== L || !J : !L.has(B)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return K === "a" ? J.call(B, W) : J ? J.value = W : L.set(B, W), W;
}, _AppReadyEvent_detail;
let wallets;
const registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(B) {
  cachedWalletsArray = void 0, registeredWalletsSet.add(B);
}
function removeRegisteredWallet(B) {
  cachedWalletsArray = void 0, registeredWalletsSet.delete(B);
}
const listeners = {};
function getWallets() {
  if (wallets || (wallets = Object.freeze({ register, get, on }), typeof window > "u"))
    return wallets;
  const B = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: L }) => L(B));
  } catch (L) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, L);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(B));
  } catch (L) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, L);
  }
  return wallets;
}
function register(...B) {
  var L;
  return B = B.filter((W) => !registeredWalletsSet.has(W)), B.length ? (B.forEach((W) => addRegisteredWallet(W)), (L = listeners.register) == null || L.forEach((W) => guard(() => W(...B))), function() {
    var K;
    B.forEach((J) => removeRegisteredWallet(J)), (K = listeners.unregister) == null || K.forEach((J) => guard(() => J(...B)));
  }) : () => {
  };
}
let cachedWalletsArray;
function get() {
  return cachedWalletsArray || (cachedWalletsArray = [...registeredWalletsSet]), cachedWalletsArray;
}
function on(B, L) {
  var W;
  return (W = listeners[B]) != null && W.push(L) || (listeners[B] = [L]), function() {
    var J;
    listeners[B] = (J = listeners[B]) == null ? void 0 : J.filter((V) => L !== V);
  };
}
function guard(B) {
  try {
    B();
  } catch (L) {
    console.error(L);
  }
}
class AppReadyEvent extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(L) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), _AppReadyEvent_detail.set(this, void 0), __classPrivateFieldSet(this, _AppReadyEvent_detail, L, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
function getValue(B, L) {
  return B == null ? void 0 : B[L];
}
function isHostObject(B) {
  var L = !1;
  if (B != null && typeof B.toString != "function")
    try {
      L = !!(B + "");
    } catch {
    }
  return L;
}
var funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var B = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return B ? "Symbol(src)_1." + B : "";
}(), funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), Symbol$1 = root.Symbol;
Symbol$1 && Symbol$1.isConcatSpreadable;
getNative(root, "Map");
getNative(Object, "create");
function baseIsNative(B) {
  if (!isObject(B) || isMasked(B))
    return !1;
  var L = isFunction(B) || isHostObject(B) ? reIsNative : reIsHostCtor;
  return L.test(toSource(B));
}
function getNative(B, L) {
  var W = getValue(B, L);
  return baseIsNative(W) ? W : void 0;
}
function isMasked(B) {
  return !!maskSrcKey && maskSrcKey in B;
}
function toSource(B) {
  if (B != null) {
    try {
      return funcToString.call(B);
    } catch {
    }
    try {
      return B + "";
    } catch {
    }
  }
  return "";
}
function isFunction(B) {
  var L = isObject(B) ? objectToString.call(B) : "";
  return L == funcTag || L == genTag;
}
function isObject(B) {
  var L = typeof B;
  return !!B && (L == "object" || L == "function");
}
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, L) {
  var W;
  return (W = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : W.get(L);
}
function _stringify(B) {
  var W, K;
  let L = typeof B;
  return L === "object" && (L = (B && ((K = (W = Object.getPrototypeOf(B)) == null ? void 0 : W.constructor) == null ? void 0 : K.name)) ?? "null"), L === "string" ? `"${B}"` : L === "number" || L === "bigint" || L === "boolean" ? `${B}` : L;
}
function _addIssue(B, L, W, K, J) {
  const V = J && "input" in J ? J.input : W.value, re = (J == null ? void 0 : J.expected) ?? B.expects ?? null, ie = (J == null ? void 0 : J.received) ?? _stringify(V), oe = {
    kind: B.kind,
    type: B.type,
    input: V,
    expected: re,
    received: ie,
    message: `Invalid ${L}: ${re ? `Expected ${re} but r` : "R"}eceived ${ie}`,
    // @ts-expect-error
    requirement: B.requirement,
    path: J == null ? void 0 : J.path,
    issues: J == null ? void 0 : J.issues,
    lang: K.lang,
    abortEarly: K.abortEarly,
    abortPipeEarly: K.abortPipeEarly
  }, pe = B.kind === "schema", ne = (J == null ? void 0 : J.message) ?? // @ts-expect-error
  B.message ?? getSpecificMessage(B.reference, oe.lang) ?? (pe ? getSchemaMessage(oe.lang) : null) ?? K.message ?? getGlobalMessage(oe.lang);
  ne && (oe.message = typeof ne == "function" ? ne(oe) : ne), pe && (W.typed = !1), W.issues ? W.issues.push(oe) : W.issues = [oe];
}
function _isValidObjectKey(B, L) {
  return Object.hasOwn(B, L) && L !== "__proto__" && L !== "prototype" && L !== "constructor";
}
function getDefault(B, L, W) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(L, W)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function array(B, L) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: L,
    _run(W, K) {
      var V;
      const J = W.value;
      if (Array.isArray(J)) {
        W.typed = !0, W.value = [];
        for (let re = 0; re < J.length; re++) {
          const ie = J[re], oe = this.item._run({ typed: !1, value: ie }, K);
          if (oe.issues) {
            const pe = {
              type: "array",
              origin: "value",
              input: J,
              key: re,
              value: ie
            };
            for (const ne of oe.issues)
              ne.path ? ne.path.unshift(pe) : ne.path = [pe], (V = W.issues) == null || V.push(ne);
            if (W.issues || (W.issues = oe.issues), K.abortEarly) {
              W.typed = !1;
              break;
            }
          }
          oe.typed || (W.typed = !1), W.value.push(oe.value);
        }
      } else
        _addIssue(this, "type", W, K);
      return W;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(L, W) {
      return typeof L.value == "boolean" ? L.typed = !0 : _addIssue(this, "type", L, W), L;
    }
  };
}
function enum_(B, L) {
  const W = Object.entries(B).filter(([K]) => isNaN(+K)).map(([, K]) => K);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: W.map(_stringify).join(" | ") || "never",
    async: !1,
    enum: B,
    options: W,
    message: L,
    _run(K, J) {
      return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, J), K;
    }
  };
}
function literal(B, L) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: L,
    _run(W, K) {
      return W.value === this.literal ? W.typed = !0 : _addIssue(this, "type", W, K), W;
    }
  };
}
function looseObject(B, L) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: L,
    _run(W, K) {
      var V;
      const J = W.value;
      if (J && typeof J == "object") {
        W.typed = !0, W.value = {};
        for (const re in this.entries) {
          const ie = J[re], oe = this.entries[re]._run(
            { typed: !1, value: ie },
            K
          );
          if (oe.issues) {
            const pe = {
              type: "object",
              origin: "value",
              input: J,
              key: re,
              value: ie
            };
            for (const ne of oe.issues)
              ne.path ? ne.path.unshift(pe) : ne.path = [pe], (V = W.issues) == null || V.push(ne);
            if (W.issues || (W.issues = oe.issues), K.abortEarly) {
              W.typed = !1;
              break;
            }
          }
          oe.typed || (W.typed = !1), (oe.value !== void 0 || re in J) && (W.value[re] = oe.value);
        }
        if (!W.issues || !K.abortEarly)
          for (const re in J)
            _isValidObjectKey(J, re) && !(re in this.entries) && (W.value[re] = J[re]);
      } else
        _addIssue(this, "type", W, K);
      return W;
    }
  };
}
function nonOptional(B, L) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: L,
    _run(W, K) {
      return W.value === void 0 ? (_addIssue(this, "type", W, K), W) : this.wrapped._run(W, K);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(L, W) {
      return L.value === null ? L.typed = !0 : _addIssue(this, "type", L, W), L;
    }
  };
}
function nullish(B, ...L) {
  const W = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${B.expects} | null | undefined`,
    async: !1,
    wrapped: B,
    _run(K, J) {
      return (K.value === null || K.value === void 0) && ("default" in this && (K.value = getDefault(
        this,
        K,
        J
      )), K.value === null || K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, J);
    }
  };
  return 0 in L && (W.default = L[0]), W;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(L, W) {
      return typeof L.value == "number" && !isNaN(L.value) ? L.typed = !0 : _addIssue(this, "type", L, W), L;
    }
  };
}
function object(B, L) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: L,
    _run(W, K) {
      var V;
      const J = W.value;
      if (J && typeof J == "object") {
        W.typed = !0, W.value = {};
        for (const re in this.entries) {
          const ie = J[re], oe = this.entries[re]._run(
            { typed: !1, value: ie },
            K
          );
          if (oe.issues) {
            const pe = {
              type: "object",
              origin: "value",
              input: J,
              key: re,
              value: ie
            };
            for (const ne of oe.issues)
              ne.path ? ne.path.unshift(pe) : ne.path = [pe], (V = W.issues) == null || V.push(ne);
            if (W.issues || (W.issues = oe.issues), K.abortEarly) {
              W.typed = !1;
              break;
            }
          }
          oe.typed || (W.typed = !1), (oe.value !== void 0 || re in J) && (W.value[re] = oe.value);
        }
      } else
        _addIssue(this, "type", W, K);
      return W;
    }
  };
}
function optional(B, ...L) {
  const W = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${B.expects} | undefined`,
    async: !1,
    wrapped: B,
    _run(K, J) {
      return K.value === void 0 && ("default" in this && (K.value = getDefault(
        this,
        K,
        J
      )), K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, J);
    }
  };
  return 0 in L && (W.default = L[0]), W;
}
function picklist(B, L) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: B.map(_stringify).join(" | ") || "never",
    async: !1,
    options: B,
    message: L,
    _run(W, K) {
      return this.options.includes(W.value) ? W.typed = !0 : _addIssue(this, "type", W, K), W;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(L, W) {
      return typeof L.value == "string" ? L.typed = !0 : _addIssue(this, "type", L, W), L;
    }
  };
}
function undefined_(B) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: !1,
    message: B,
    _run(L, W) {
      return L.value === void 0 ? L.typed = !0 : _addIssue(this, "type", L, W), L;
    }
  };
}
function _subIssues(B) {
  let L;
  if (B)
    for (const W of B)
      L ? L.push(...W.issues) : L = W.issues;
  return L;
}
function union(B, L) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(B.map((W) => W.expects))].join(" | ") || "never",
    async: !1,
    options: B,
    message: L,
    _run(W, K) {
      let J, V, re;
      for (const ie of this.options) {
        const oe = ie._run(
          { typed: !1, value: W.value },
          K
        );
        if (oe.typed)
          if (oe.issues)
            V ? V.push(oe) : V = [oe];
          else {
            J = oe;
            break;
          }
        else
          re ? re.push(oe) : re = [oe];
      }
      if (J)
        return J;
      if (V) {
        if (V.length === 1)
          return V[0];
        _addIssue(this, "type", W, K, {
          issues: _subIssues(V)
        }), W.typed = !0;
      } else {
        if ((re == null ? void 0 : re.length) === 1)
          return re[0];
        _addIssue(this, "type", W, K, {
          issues: _subIssues(re)
        });
      }
      return W;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
var lib = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var L = B.length;
  if (L % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var W = B.indexOf("=");
  W === -1 && (W = L);
  var K = W === L ? 0 : 4 - W % 4;
  return [W, K];
}
function byteLength(B) {
  var L = getLens(B), W = L[0], K = L[1];
  return (W + K) * 3 / 4 - K;
}
function _byteLength(B, L, W) {
  return (L + W) * 3 / 4 - W;
}
function toByteArray(B) {
  var L, W = getLens(B), K = W[0], J = W[1], V = new Arr(_byteLength(B, K, J)), re = 0, ie = J > 0 ? K - 4 : K, oe;
  for (oe = 0; oe < ie; oe += 4)
    L = revLookup[B.charCodeAt(oe)] << 18 | revLookup[B.charCodeAt(oe + 1)] << 12 | revLookup[B.charCodeAt(oe + 2)] << 6 | revLookup[B.charCodeAt(oe + 3)], V[re++] = L >> 16 & 255, V[re++] = L >> 8 & 255, V[re++] = L & 255;
  return J === 2 && (L = revLookup[B.charCodeAt(oe)] << 2 | revLookup[B.charCodeAt(oe + 1)] >> 4, V[re++] = L & 255), J === 1 && (L = revLookup[B.charCodeAt(oe)] << 10 | revLookup[B.charCodeAt(oe + 1)] << 4 | revLookup[B.charCodeAt(oe + 2)] >> 2, V[re++] = L >> 8 & 255, V[re++] = L & 255), V;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, L, W) {
  for (var K, J = [], V = L; V < W; V += 3)
    K = (B[V] << 16 & 16711680) + (B[V + 1] << 8 & 65280) + (B[V + 2] & 255), J.push(tripletToBase64(K));
  return J.join("");
}
function fromByteArray(B) {
  for (var L, W = B.length, K = W % 3, J = [], V = 16383, re = 0, ie = W - K; re < ie; re += V)
    J.push(encodeChunk(B, re, re + V > ie ? ie : re + V));
  return K === 1 ? (L = B[W - 1], J.push(
    lookup[L >> 2] + lookup[L << 4 & 63] + "=="
  )) : K === 2 && (L = (B[W - 2] << 8) + B[W - 1], J.push(
    lookup[L >> 10] + lookup[L >> 4 & 63] + lookup[L << 2 & 63] + "="
  )), J.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode;
function decode$1(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$1;
var cryptoClients = {}, secp256k1 = {}, ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const L = paramBytesForAlg[B];
  if (L)
    return L;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, L) {
  const W = signatureAsBytes(B), K = getParamBytesForAlg(L), J = K + 1, V = W.length;
  let re = 0;
  if (W[re++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ie = W[re++];
  if (ie === (MAX_OCTET | 1) && (ie = W[re++]), V - re < ie)
    throw new Error(`"seq" specified length of "${ie}", only "${V - re}" remaining`);
  if (W[re++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const oe = W[re++];
  if (V - re - 2 < oe)
    throw new Error(`"r" specified length of "${oe}", only "${V - re - 2}" available`);
  if (J < oe)
    throw new Error(`"r" specified length of "${oe}", max of "${J}" is acceptable`);
  const pe = re;
  if (re += oe, W[re++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const ne = W[re++];
  if (V - re !== ne)
    throw new Error(`"s" specified length of "${ne}", expected "${V - re}"`);
  if (J < ne)
    throw new Error(`"s" specified length of "${ne}", max of "${J}" is acceptable`);
  const ce = re;
  if (re += ne, re !== V)
    throw new Error(`Expected to consume entire array, but "${V - re}" bytes remain`);
  const Ce = K - oe, Oe = K - ne, st = new Uint8Array(Ce + oe + Oe + ne);
  for (re = 0; re < Ce; ++re)
    st[re] = 0;
  st.set(W.subarray(pe + Math.max(-Ce, 0), pe + oe), re), re = K;
  for (const at = re; re < at + Oe; ++re)
    st[re] = 0;
  return st.set(W.subarray(ce + Math.max(-Oe, 0), ce + ne), re), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(st));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, L, W) {
  let K = 0;
  for (; L + K < W && B[L + K] === 0; )
    ++K;
  return B[L + K] >= MAX_OCTET && --K, K;
}
function joseToDer(B, L) {
  B = signatureAsBytes(B);
  const W = getParamBytesForAlg(L), K = B.length;
  if (K !== W * 2)
    throw new TypeError(`"${L}" signatures must be "${W * 2}" bytes, saw "${K}"`);
  const J = countPadding(B, 0, W), V = countPadding(B, W, B.length), re = W - J, ie = W - V, oe = 2 + re + 1 + 1 + ie, pe = oe < MAX_OCTET, ne = new Uint8Array((pe ? 2 : 3) + oe);
  let ce = 0;
  return ne[ce++] = ENCODED_TAG_SEQ, pe ? ne[ce++] = oe : (ne[ce++] = MAX_OCTET | 1, ne[ce++] = oe & 255), ne[ce++] = ENCODED_TAG_INT, ne[ce++] = re, J < 0 ? (ne[ce++] = 0, ne.set(B.subarray(0, W), ce), ce += W) : (ne.set(B.subarray(J, W), ce), ce += W - J), ne[ce++] = ENCODED_TAG_INT, ne[ce++] = ie, V < 0 ? (ne[ce++] = 0, ne.set(B.subarray(W), ce)) : ne.set(B.subarray(W + V), ce), ne;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors = {};
Object.defineProperty(errors, "__esModule", { value: !0 });
errors.InvalidTokenError = errors.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(L) {
    super(), this.name = "MissingParametersError", this.message = L || "";
  }
}
errors.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(L) {
    super(), this.name = "InvalidTokenError", this.message = L || "";
  }
}
errors.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1, "__esModule", { value: !0 });
secp256k1.SECP256K1Client = void 0;
const hmac_1 = hmac$2, sha256_1$3 = sha256$5, secp = lib$1, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors, utils_1 = utils$5;
secp.utils.hmacSha256Sync = (B, ...L) => {
  const W = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return L.forEach((K) => W.update(K)), W.digest();
};
class SECP256K1Client {
  static derivePublicKey(L, W = !0) {
    return L.length === 66 && (L = L.slice(0, 64)), L.length < 64 && (L = L.padStart(64, "0")), (0, utils_1.bytesToHex)(secp.getPublicKey(L, W));
  }
  static signHash(L, W, K = "jose") {
    if (!L || !W)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const J = secp.signSync(L, W.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (K === "der")
      return (0, utils_1.bytesToHex)(J);
    if (K === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(J, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(L) {
    return (0, ecdsaSigFormatter_1.joseToDer)(L, "ES256");
  }
  static verifyHash(L, W, K) {
    if (!L || !W || !K)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(W, L, K, { strict: !1 });
  }
}
secp256k1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const L = secp256k1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return L.SECP256K1Client;
  } });
  const W = {
    ES256K: L.SECP256K1Client
  };
  B.cryptoClients = W;
})(cryptoClients);
var sha256 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, L, W, K) {
  function J(V) {
    return V instanceof W ? V : new W(function(re) {
      re(V);
    });
  }
  return new (W || (W = Promise))(function(V, re) {
    function ie(ne) {
      try {
        pe(K.next(ne));
      } catch (ce) {
        re(ce);
      }
    }
    function oe(ne) {
      try {
        pe(K.throw(ne));
      } catch (ce) {
        re(ce);
      }
    }
    function pe(ne) {
      ne.done ? V(ne.value) : J(ne.value).then(ie, oe);
    }
    pe((K = K.apply(B, L || [])).next());
  });
};
Object.defineProperty(sha256, "__esModule", { value: !0 });
sha256.hashSha256Async = sha256.hashSha256 = void 0;
const sha256_1$2 = sha256$5;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
sha256.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const W = typeof B == "string" ? new TextEncoder().encode(B) : B, K = yield crypto.subtle.digest("SHA-256", W);
        return new Uint8Array(K);
      } else {
        const W = requireCryptoBrowserify();
        if (!W.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(W.createHash("sha256").update(B).digest());
      }
    } catch (L) {
      return console.log(L), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, L, W, K) {
  function J(V) {
    return V instanceof W ? V : new W(function(re) {
      re(V);
    });
  }
  return new (W || (W = Promise))(function(V, re) {
    function ie(ne) {
      try {
        pe(K.next(ne));
      } catch (ce) {
        re(ce);
      }
    }
    function oe(ne) {
      try {
        pe(K.throw(ne));
      } catch (ce) {
        re(ce);
      }
    }
    function pe(ne) {
      ne.done ? V(ne.value) : J(ne.value).then(ie, oe);
    }
    pe((K = K.apply(B, L || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors, sha256_1$1 = sha256;
function createSigningInput(B, L) {
  const W = [], K = base64url$2.encode(JSON.stringify(L));
  W.push(K);
  const J = base64url$2.encode(JSON.stringify(B));
  return W.push(J), W.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(L, W) {
    if (!(L && W))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof L != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (L = L.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(L))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[L], this.rawPrivateKey = W;
  }
  header(L = {}) {
    const W = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, W, L);
  }
  sign(L, W = !1, K = {}) {
    const J = this.header(K), V = createSigningInput(L, J), re = (0, sha256_1$1.hashSha256)(V);
    return this.createWithSignedHash(L, W, J, V, re);
  }
  signAsync(L, W = !1, K = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const J = this.header(K), V = createSigningInput(L, J), re = yield (0, sha256_1$1.hashSha256Async)(V);
      return this.createWithSignedHash(L, W, J, V, re);
    });
  }
  createWithSignedHash(L, W, K, J, V) {
    const re = this.cryptoClient.signHash(V, this.rawPrivateKey);
    return W ? {
      header: [base64url$2.encode(JSON.stringify(K))],
      payload: JSON.stringify(L),
      signature: [re]
    } : [J, re].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors, sha256_1 = sha256;
class TokenVerifier {
  constructor(L, W) {
    if (!(L && W))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof L != "string")
      throw "signing algorithm parameter must be a string";
    if (L = L.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(L))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[L], this.rawPublicKey = W;
  }
  verify(L) {
    return typeof L == "string" ? this.verifyCompact(L, !1) : typeof L == "object" ? this.verifyExpanded(L, !1) : !1;
  }
  verifyAsync(L) {
    return typeof L == "string" ? this.verifyCompact(L, !0) : typeof L == "object" ? this.verifyExpanded(L, !0) : Promise.resolve(!1);
  }
  verifyCompact(L, W) {
    const K = L.split("."), J = K[0] + "." + K[1], V = (re) => {
      const ie = this.cryptoClient.loadSignature(K[2]);
      return this.cryptoClient.verifyHash(re, ie, this.rawPublicKey);
    };
    if (W)
      return (0, sha256_1.hashSha256Async)(J).then((re) => V(re));
    {
      const re = (0, sha256_1.hashSha256)(J);
      return V(re);
    }
  }
  verifyExpanded(L, W) {
    const K = [L.header.join("."), base64url$1.encode(L.payload)].join(".");
    let J = !0;
    const V = (re) => (L.signature.map((ie) => {
      const oe = this.cryptoClient.loadSignature(ie);
      this.cryptoClient.verifyHash(re, oe, this.rawPublicKey) || (J = !1);
    }), J);
    if (W)
      return (0, sha256_1.hashSha256Async)(K).then((re) => V(re));
    {
      const re = (0, sha256_1.hashSha256)(K);
      return V(re);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode = {};
Object.defineProperty(decode, "__esModule", { value: !0 });
decode.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const L = B.split("."), W = JSON.parse(base64url.decode(L[0])), K = JSON.parse(base64url.decode(L[1])), J = L[2];
    return {
      header: W,
      payload: K,
      signature: J
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let L = B.payload;
    B.payload[0] !== "{" && (L = base64url.decode(L));
    const W = [];
    return B.header.map((K) => {
      const J = JSON.parse(base64url.decode(K));
      W.push(J);
    }), {
      header: W,
      payload: JSON.parse(L),
      signature: B.signature
    };
  }
}
decode.decodeToken = decodeToken;
(function(B) {
  var L = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(K, J, V, re) {
    re === void 0 && (re = V);
    var ie = Object.getOwnPropertyDescriptor(J, V);
    (!ie || ("get" in ie ? !J.__esModule : ie.writable || ie.configurable)) && (ie = { enumerable: !0, get: function() {
      return J[V];
    } }), Object.defineProperty(K, re, ie);
  } : function(K, J, V, re) {
    re === void 0 && (re = V), K[re] = J[V];
  }), W = commonjsGlobal && commonjsGlobal.__exportStar || function(K, J) {
    for (var V in K) V !== "default" && !Object.prototype.hasOwnProperty.call(J, V) && L(J, K, V);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), W(signer, B), W(verifier, B), W(decode, B), W(errors, B), W(cryptoClients, B);
})(lib);
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange";
object({
  type: literal(networkChangeEventName)
});
async function getProviderOrThrow(B) {
  var W;
  const L = await (B == null ? void 0 : B()) || ((W = window.XverseProviders) == null ? void 0 : W.BitcoinProvider) || window.BitcoinProvider;
  if (!L)
    throw new Error("No Bitcoin wallet installed");
  return L;
}
var BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Signet = "Signet", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: RpcIdSchema
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType)
}), getAddress = async (B) => {
  var K, J;
  const L = await getProviderOrThrow(B.getProvider), { purposes: W } = B.payload;
  if (!W)
    throw new Error("Address purposes are required");
  try {
    const V = lib.createUnsecuredToken(B.payload), re = await L.connect(V);
    (K = B.onFinish) == null || K.call(B, re);
  } catch (V) {
    console.error("[Connect] Error during address request", V), (J = B.onCancel) == null || J.call(B);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    id: string()
  }).entries
});
var getRunesBalanceMethodName = "runes_getBalance", getRunesBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getRunesBalanceMethodName),
    params: getRunesBalanceParamsSchema,
    id: string()
  }).entries
});
var transferRunesMethodName = "runes_transfer", transferRunesParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(transferRunesMethodName),
    params: transferRunesParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var signMessage$5 = async (B) => {
  var J, V;
  const L = await getProviderOrThrow(B.getProvider), { address: W, message: K } = B.payload;
  if (!W)
    throw new Error("An address is required to sign a message");
  if (!K)
    throw new Error("A message to be signed is required");
  try {
    const re = lib.createUnsecuredToken(B.payload), ie = await L.signMessage(re);
    (J = B.onFinish) == null || J.call(B, ie);
  } catch (re) {
    console.error("[Connect] Error during sign message request", re), (V = B.onCancel) == null || V.call(B);
  }
}, serializer = (B) => B.map((L) => {
  const { address: W, amountSats: K } = L;
  return {
    address: W,
    amountSats: K.toString()
  };
}), sendBtcTransaction = async (B) => {
  var re, ie;
  const L = await getProviderOrThrow(B.getProvider), { recipients: W, senderAddress: K, network: J, message: V } = B.payload;
  if (!W || W.length === 0)
    throw new Error("At least one recipient is required");
  if (W.some(
    (oe) => typeof oe.address != "string" || typeof oe.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!K)
    throw new Error("The sender address is required");
  try {
    const oe = serializer(W), pe = {
      network: J,
      senderAddress: K,
      message: V,
      recipients: oe
    }, ne = lib.createUnsecuredToken(pe), ce = await L.sendBtcTransaction(ne);
    (re = B.onFinish) == null || re.call(B, ce);
  } catch (oe) {
    console.error("[Connect] Error during send BTC transaction request", oe), (ie = B.onCancel) == null || ie.call(B);
  }
}, signTransaction = async (B) => {
  var J, V;
  const L = await getProviderOrThrow(B.getProvider), { psbtBase64: W, inputsToSign: K } = B.payload;
  if (!W)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!K)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const re = lib.createUnsecuredToken(B.payload), ie = await L.signTransaction(re);
    (J = B.onFinish) == null || J.call(B, ie);
  } catch (re) {
    console.error("[Connect] Error during sign transaction request", re), (V = B.onCancel) == null || V.call(B);
  }
};
const NETWORK_TO_BITCOIN_NETWORK_TYPE = {
  mainnet: BitcoinNetworkType.Mainnet,
  testnet: BitcoinNetworkType.Testnet
};
function fromXOnlyToFullPubkey(B) {
  return Buffer$2.from(B, "hex").length === 33 ? B : `02${B}`;
}
src$4.initEccLib(ecc);
async function satsConnectWalletGetAddresses(B, L = "mainnet") {
  if (L === "signet")
    throw new OrditSDKError("signet network is not supported");
  const W = [], K = (re) => {
    if (!re || !re.addresses || re.addresses.length !== 2)
      throw new BrowserWalletSigningError(
        "Failed to retrieve addresses using selected wallet"
      );
    re.addresses.forEach((ie) => {
      const oe = getAddressFormat(ie.address, L);
      let pe = ie.publicKey;
      oe === "taproot" && (pe = fromXOnlyToFullPubkey(ie.publicKey)), W.push({
        publicKey: pe,
        address: ie.address,
        format: oe
      });
    });
  }, J = () => {
    throw new BrowserWalletRequestCancelledByUserError();
  }, V = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: NETWORK_TO_BITCOIN_NETWORK_TYPE[L]
      }
    },
    getProvider: B,
    onFinish: (re) => K(re),
    onCancel: J
  };
  return await getAddress(V), W;
}
async function satsConnectWalletSignPsbt(B, L, {
  finalize: W = !0,
  extractTx: K = !0,
  network: J,
  inputsToSign: V
} = { network: "mainnet", inputsToSign: [] }) {
  if (J === "signet")
    throw new OrditSDKError("signet network is not supported");
  if (!W && K)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  if (!L || !J || !V.length)
    throw new OrditSDKError("Invalid options provided");
  let re, ie = null;
  const oe = (ce) => {
    const { psbtBase64: Ce } = ce;
    if (!Ce)
      throw new BrowserWalletSigningError(
        "Failed to sign psbt using selected wallet"
      );
    const Oe = src$4.Psbt.fromBase64(Ce);
    if (W && V.forEach((st) => {
      st.signingIndexes.forEach((at) => {
        try {
          Oe.finalizeInput(at);
        } catch (lt) {
          throw console.error("Sign psbt error", lt), new OrditSDKError("Failed to finalize input");
        }
      });
    }), K) {
      try {
        re = Oe.extractTransaction().toHex();
      } catch (st) {
        throw st instanceof Error && st.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
      }
      ie = null;
    } else
      re = Oe.toHex(), ie = Oe.toBase64();
  }, pe = () => {
    throw new BrowserWalletRequestCancelledByUserError();
  }, ne = {
    payload: {
      network: {
        type: NETWORK_TO_BITCOIN_NETWORK_TYPE[J]
      },
      message: "Sign PSBT",
      psbtBase64: L.toBase64(),
      broadcast: !1,
      inputsToSign: V
    },
    onFinish: oe,
    onCancel: pe,
    getProvider: B
  };
  return await signTransaction(ne), { hex: re, base64: ie };
}
async function satsConnectWalletSignMessage(B, L, W, K = "mainnet") {
  if (K === "signet")
    throw new OrditSDKError("signet network is not supported");
  if (!L || !K || !W)
    throw new OrditSDKError("Invalid options provided");
  let J, V = null;
  const re = (pe) => {
    if (!pe)
      throw new BrowserWalletSigningError(
        "Failed to sign message using selected wallet"
      );
    J = Buffer$2.from(pe, "base64").toString("hex"), V = pe;
  }, ie = () => {
    throw new BrowserWalletRequestCancelledByUserError();
  }, oe = {
    payload: {
      network: {
        type: NETWORK_TO_BITCOIN_NETWORK_TYPE[K]
      },
      message: L,
      address: W
    },
    getProvider: B,
    onFinish: re,
    onCancel: ie
  };
  return await signMessage$5(oe), { hex: J, base64: V };
}
async function getMagicEdenWalletProvider() {
  const { get: B } = getWallets(), W = B().find(
    (K) => {
      var J, V;
      return K.name === "Magic Eden" && ((V = (J = K.features["sats-connect:"]) == null ? void 0 : J.provider) == null ? void 0 : V.isMagicEden) === !0;
    }
  );
  if (!W)
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  return W.features["sats-connect:"].provider;
}
async function isInstalled$3() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  try {
    const B = await getMagicEdenWalletProvider();
    return B.isMagicEden !== void 0 && B.isMagicEden === !0;
  } catch (B) {
    if (B instanceof BrowserWalletNotInstalledError)
      return !1;
    throw B;
  }
}
async function getAddresses$2(B = "mainnet") {
  if (!isInstalled$3())
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  if (B !== "mainnet")
    throw new BrowserWalletNetworkMismatchError(
      "Magic Eden Wallet only supports mainnet"
    );
  return satsConnectWalletGetAddresses(getMagicEdenWalletProvider, B);
}
async function signPsbt$4(B, {
  finalize: L = !0,
  extractTx: W = !0,
  network: K,
  inputsToSign: J
} = { network: "mainnet", inputsToSign: [] }) {
  if (!isInstalled$3())
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  if (K !== "mainnet")
    throw new BrowserWalletNetworkMismatchError(
      "Magic Eden Wallet only supports mainnet"
    );
  return satsConnectWalletSignPsbt(getMagicEdenWalletProvider, B, {
    finalize: L,
    extractTx: W,
    network: K,
    inputsToSign: J
  });
}
async function signMessage$4(B, L, W = "mainnet") {
  if (!isInstalled$3())
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  if (W !== "mainnet")
    throw new BrowserWalletNetworkMismatchError(
      "Magic Eden Wallet only supports mainnet"
    );
  return satsConnectWalletSignMessage(
    getMagicEdenWalletProvider,
    B,
    L,
    W
  );
}
const NETWORK_TO_UNISAT_NETWORK = {
  mainnet: "livenet",
  testnet: "testnet"
};
function isInstalled$2() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof window.unisat < "u";
}
async function getAddresses$1(B = "mainnet", L) {
  if (B === "signet")
    throw new OrditSDKError("signet network is not supported");
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Unisat not installed");
  try {
    const W = await window.unisat.getNetwork(), K = NETWORK_TO_UNISAT_NETWORK[B];
    W !== K && await window.unisat.switchNetwork(K);
    const J = L ? await window.unisat.getAccounts() : await window.unisat.requestAccounts(), V = await window.unisat.getPublicKey(), re = J[0];
    if (!re)
      return [];
    const ie = getAddressFormat(re, B);
    return [
      {
        publicKey: V,
        address: re,
        format: ie
      }
    ];
  } catch (W) {
    if (W instanceof OrditSDKError)
      throw W;
    const K = W;
    throw (K == null ? void 0 : K.code) === 4001 ? new BrowserWalletRequestCancelledByUserError() : new OrditSDKError(K.message);
  }
}
async function signPsbt$3(B, { finalize: L = !0, extractTx: W = !0 } = {}) {
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Unisat not installed");
  if (W && !L)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  const K = B.toHex();
  let J = "";
  try {
    J = await window.unisat.signPsbt(K, {
      autoFinalized: L
    });
  } catch (re) {
    const ie = re;
    if ((ie == null ? void 0 : ie.code) === 4001)
      throw new BrowserWalletRequestCancelledByUserError();
  }
  if (!J)
    throw new BrowserWalletSigningError("Failed to sign psbt hex using Unisat");
  const V = src$4.Psbt.fromHex(J);
  if (W)
    try {
      return {
        base64: null,
        hex: V.extractTransaction().toHex()
      };
    } catch (re) {
      throw re instanceof Error && re.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
    }
  else
    return {
      base64: V.toBase64(),
      hex: V.toHex()
    };
}
async function signMessage$3(B, L = "ecdsa") {
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Unisat not installed");
  let W = "";
  try {
    W = await window.unisat.signMessage(B, L);
  } catch (K) {
    const J = K;
    if ((J == null ? void 0 : J.code) === 4001)
      throw new BrowserWalletRequestCancelledByUserError();
  }
  if (!W)
    throw new BrowserWalletSigningError("Failed to sign message using Unisat");
  return {
    base64: W,
    hex: Buffer$2.from(W, "base64").toString("hex")
  };
}
function isInstalled$1() {
  var B;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof ((B = window.XverseProviders) == null ? void 0 : B.BitcoinProvider) < "u";
}
async function getXverseWalletProvider() {
  if (!isInstalled$1())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return window.XverseProviders.BitcoinProvider;
}
async function getAddresses(B = "mainnet") {
  if (!isInstalled$1())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return satsConnectWalletGetAddresses(getXverseWalletProvider, B);
}
async function signPsbt$2(B, {
  finalize: L = !0,
  extractTx: W = !0,
  network: K,
  inputsToSign: J
} = { network: "mainnet", inputsToSign: [] }) {
  if (!isInstalled$1())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return satsConnectWalletSignPsbt(getXverseWalletProvider, B, {
    finalize: L,
    extractTx: W,
    network: K,
    inputsToSign: J
  });
}
async function signMessage$2(B, L, W = "mainnet") {
  if (!isInstalled$1())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return satsConnectWalletSignMessage(
    getXverseWalletProvider,
    B,
    L,
    W
  );
}
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
async function waitForUnisatExtensionReady() {
  let B = 0;
  const L = 20;
  for (; B < L; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const W = await window.unisat.getAccounts();
        if (W && W.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((W) => {
      setTimeout(W, 100);
    });
  }
  return !1;
}
const LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20200%20200'%3e%3cradialGradient%20id='a12'%20cx='.66'%20fx='.66'%20cy='.3125'%20fy='.3125'%20gradientTransform='scale(1.5)'%3e%3cstop%20offset='0'%20stop-color='%23D9D5D2'%3e%3c/stop%3e%3cstop%20offset='.3'%20stop-color='%23D9D5D2'%20stop-opacity='.9'%3e%3c/stop%3e%3cstop%20offset='.6'%20stop-color='%23D9D5D2'%20stop-opacity='.6'%3e%3c/stop%3e%3cstop%20offset='.8'%20stop-color='%23D9D5D2'%20stop-opacity='.3'%3e%3c/stop%3e%3cstop%20offset='1'%20stop-color='%23D9D5D2'%20stop-opacity='0'%3e%3c/stop%3e%3c/radialGradient%3e%3ccircle%20transform-origin='center'%20fill='none'%20stroke='url(%23a12)'%20stroke-width='15'%20stroke-linecap='round'%20stroke-dasharray='200%201000'%20stroke-dashoffset='0'%20cx='100'%20cy='100'%20r='70'%3e%3canimateTransform%20type='rotate'%20attributeName='transform'%20calcMode='spline'%20dur='2'%20values='360;0'%20keyTimes='0;1'%20keySplines='0%200%201%201'%20repeatCount='indefinite'%3e%3c/animateTransform%3e%3c/circle%3e%3ccircle%20transform-origin='center'%20fill='none'%20opacity='.2'%20stroke='%23D9D5D2'%20stroke-width='15'%20stroke-linecap='round'%20cx='100'%20cy='100'%20r='70'%3e%3c/circle%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  subtitle: L,
  onConnect: W,
  icon: K,
  setErrorMessage: J,
  isDisabled: V,
  isMobileDevice: re
}) {
  const { wallet: ie, address: oe } = useWallie(), [{ connectedWallet: pe, connectedAddress: ne }] = useState({
    connectedWallet: ie,
    connectedAddress: oe
  }), [ce, Ce] = useState(!1), Oe = WALLET_TO_NAME[B], st = useCallback(async () => {
    Ce(!0), await Promise.race([
      W().then(() => Ce(!1)).catch(() => Ce(!1)),
      new Promise((lt) => {
        setTimeout(() => lt("timeout"), 5e3);
      })
    ]) === "timeout" ? J(
      "No wallet pop-up? The extension is not responding. Try reloading your browser."
    ) : Ce(!1);
  }, [W, J]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      className: "wallie-w-full wallie-flex wallie-flex-row wallie-justify-between wallie-items-center wallie-text-ord-light-gray wallie-bg-ord-light-blue wallie-hover:bg-ord-light-blue-250 wallie-p-2 wallie-rounded-lg md:wallie-text-xl wallie-space-x-4 md:space-x-6 wallie-ease-in wallie-transition-all wallie-duration-100 wallie-ease-in-outscale-120",
      onClick: st,
      disabled: V,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallie-flex wallie-flex-row wallie-space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallie-w-5 md:wallie-w-8", src: K, alt: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-text-lg wallie-block wallie-font-medium", children: Oe }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "wallie-text-sm wallie-font-medium",
              style: { display: re ? "block" : "none" },
              children: L
            }
          )
        ] }),
        pe === B && ne.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-flex wallie-flex-row wallie-ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-text-sm wallie-font-medium wallie-pr-3", children: truncateMiddle(ne.ordinals) }) }) : null,
        ce && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: 24,
            alt: `${Oe} extension is loading`
          }
        )
      ]
    }
  );
}
const WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download"
  // their www subdomain doesn't work
};
function SelectWalletModal({
  isOpen: B,
  closeModal: L
}) {
  const {
    updateAddress: W,
    network: K,
    updateWallet: J,
    updatePublicKey: V,
    updateFormat: re,
    wallet: ie,
    format: oe,
    address: pe,
    publicKey: ne,
    disconnectWallet: ce
  } = useWallie(), [Ce, Oe] = useState(""), st = isMobileUserAgent(), at = useCallback(
    (vt, $t) => {
      $t instanceof BrowserWalletNotInstalledError && window.open(
        WALLET_CHROME_EXTENSION_URL[vt],
        "_blank",
        "noopener,noreferrer"
      ), Oe($t.message ?? $t.toString()), ce();
    },
    [ce]
  ), lt = useCallback(async () => {
    if (K === "testnet") {
      const vt = new Error(
        "Magic Eden wallet is not supported on testnet"
      );
      return at(Wallet.MAGICEDEN, vt), !1;
    }
    try {
      Oe("");
      const vt = await getAddresses$2(K);
      if (!vt || vt.length < 1)
        throw ce(), new Error("Magic Eden via Ordit returned no addresses.");
      const $t = vt.find(
        (Ct) => Ct.format === "segwit" || Ct.format === "p2sh-p2wpkh"
      );
      if (!$t)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address."
        );
      const xt = vt.find(
        (Ct) => Ct.format === "taproot"
      );
      if (!xt)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address."
        );
      return W({
        ordinals: xt.address,
        payments: $t.address
      }), V({
        ordinals: xt.publicKey,
        payments: $t.publicKey
      }), J(Wallet.MAGICEDEN), re({
        ordinals: xt.format,
        payments: $t.format
      }), L(), !0;
    } catch (vt) {
      return at(Wallet.MAGICEDEN, vt), !1;
    }
  }, [
    L,
    ce,
    K,
    at,
    W,
    re,
    V,
    J
  ]), pt = useCallback(
    async ({ readOnly: vt } = {}) => {
      try {
        Oe("");
        const $t = await getAddresses$1(K, vt);
        if (!$t || $t.length < 1)
          throw ce(), new Error("Unisat via Ordit returned no addresses.");
        const xt = $t[0];
        return W({
          ordinals: xt.address,
          payments: xt.address
        }), V({
          ordinals: xt.publicKey,
          payments: xt.publicKey
        }), J(Wallet.UNISAT), re({
          ordinals: xt.format,
          payments: xt.format
        }), L(), !0;
      } catch ($t) {
        return at(Wallet.UNISAT, $t), !1;
      }
    },
    [
      L,
      ce,
      K,
      at,
      W,
      re,
      V,
      J
    ]
  ), ht = useCallback(async () => {
    try {
      Oe("");
      const vt = await getAddresses(K);
      if (!vt || vt.length < 1)
        throw ce(), new Error("Xverse via Ordit returned no addresses.");
      const $t = vt.find(
        (Ct) => Ct.format === "p2sh-p2wpkh" || Ct.format === "segwit"
      );
      if (!$t)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address."
        );
      const xt = vt.find(
        (Ct) => Ct.format === "taproot"
      );
      if (!xt)
        throw new Error("Xverse via Ordit did not return a Taproot address.");
      return W({
        ordinals: xt.address,
        payments: $t.address
      }), V({
        ordinals: xt.publicKey,
        payments: $t.publicKey
      }), J(Wallet.XVERSE), re({
        ordinals: xt.format,
        payments: $t.format
      }), L(), !0;
    } catch (vt) {
      return at(Wallet.XVERSE, vt), !1;
    }
  }, [
    L,
    ce,
    K,
    at,
    W,
    re,
    V,
    J
  ]), yt = useCallback(async () => {
    try {
      Oe("");
      const vt = await getAddresses$3(K);
      if (!vt || vt.length < 1)
        throw ce(), new Error("Leather via Ordit returned no addresses.");
      const $t = vt.find(
        (Ct) => Ct.format === "segwit"
      );
      if (!$t)
        throw new Error("Leather via Ordit did not return a Segwit address.");
      const xt = vt.find(
        (Ct) => Ct.format === "taproot"
      );
      if (!xt)
        throw new Error("Leather via Ordit did not return a Taproot address.");
      return W({
        ordinals: xt.address,
        payments: $t.address
      }), V({
        ordinals: xt.publicKey,
        payments: $t.publicKey
      }), J(Wallet.LEATHER), re({
        ordinals: xt.format,
        payments: $t.format
      }), L(), !0;
    } catch (vt) {
      return at(Wallet.LEATHER, vt), !1;
    }
  }, [
    L,
    ce,
    K,
    at,
    W,
    re,
    V,
    J
  ]);
  return useEffect(() => {
    if (ie !== Wallet.UNISAT)
      return;
    let vt = !0, $t = !1;
    const xt = () => pt();
    return pe && ne && oe && (async () => {
      const Et = await waitForUnisatExtensionReady();
      if (vt) {
        if (!Et) {
          ce();
          return;
        }
        $t = await pt({ readOnly: !0 }), vt && $t && window.unisat.addListener("accountsChanged", xt);
      }
    })(), () => {
      vt = !1, $t && window.unisat.removeListener("accountsChanged", xt);
    };
  }, [
    ie,
    pt,
    ce,
    pe,
    ne,
    oe
  ]), /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: B, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "wallie-z-50 wallie-fixed wallie-inset-0 wallie-overflow-y-auto",
      onClose: L,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "wallie-ease-out wallie-duration-300",
            enterFrom: "wallie-opacity-0",
            enterTo: "wallie-opacity-100",
            leave: "wallie-ease-in wallie-duration-200",
            leaveFrom: "wallie-opacity-100",
            leaveTo: "wallie-opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-fixed wallie-inset-0 wallie-bg-black wallie-bg-opacity-90 md:wallie-bg-opacity-75 wallie-transition-opacity" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "wallie-fixed wallie-inset-0 wallie-z-10 wallie-overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-flex wallie-min-h-full wallie-w-full md:wallie-w-96 wallie-mx-auto wallie-items-end wallie-justify-center wallie-p-4 wallie-text-left sm:wallie-items-center sm:wallie-p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "wallie-ease-out wallie-duration-300",
            enterFrom: "wallie-opacity-0 wallie-scale-95",
            enterTo: "wallie-opacity-100 wallie-scale-100",
            leave: "wallie-ease-in wallie-duration-200",
            leaveFrom: "wallie-opacity-100 wallie-scale-100",
            leaveTo: "wallie-opacity-0 wallie-scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "wallie-relative wallie-bg-ord-blue-600 wallie-transform wallie-overflow-hidden wallie-rounded-lg wallie-p-8 wallie-transition-all wallie-w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "wallie-flex wallie-flex-row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  _t.Title,
                  {
                    as: "h3",
                    className: "wallie-text-[21px] wallie-font-medium wallie-leading-8 wallie--mt-1  wallie-text-ord-gray",
                    children: "Connect a wallet to continue"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: L,
                    className: "wallie-ml-auto",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: CloseModalIcon,
                        alt: "close modal",
                        className: "wallie-w-[19px] wallie-h-[19px]"
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallie-text-ord-light-blue-400 wallie-font-medium wallie-py-3", children: "Choose a wallet below to connect and continue" }),
              Ce && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallie-text-ord-alert wallie-pb-4", children: Ce }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "wallie-w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "wallie-w-full wallie-space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.LEATHER,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: yt,
                    icon: LeatherWalletIcon,
                    setErrorMessage: Oe,
                    isDisabled: st,
                    isMobileDevice: st
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.XVERSE,
                    subtitle: "",
                    onConnect: ht,
                    icon: XverseWalletIcon,
                    setErrorMessage: Oe,
                    isMobileDevice: st
                  }
                ),
                !st && // TODO: remove this once unisat supported on mobile devices
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.UNISAT,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: pt,
                    icon: UnisatWalletIcon,
                    setErrorMessage: Oe,
                    isDisabled: st,
                    isMobileDevice: st
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.MAGICEDEN,
                    subtitle: "",
                    onConnect: lt,
                    icon: MagicEdenWalletIcon,
                    setErrorMessage: Oe,
                    isMobileDevice: st
                  }
                )
              ] }) })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  connectButton: B,
  connectButtonComponent: L,
  hideConnectButton: W,
  onViewProfile: K,
  onChangeWalletClick: J,
  onDisconnectWalletClick: V
}) {
  const {
    address: re,
    disconnectWallet: ie,
    network: oe,
    isModalOpen: pe,
    openModal: ne,
    closeModal: ce
  } = useWallie(), Ce = useHasMounted(), Oe = () => W ? null : re != null && re.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: re.ordinals,
      network: oe,
      onViewProfile: K,
      onChangeWallet: () => {
        ne(), J == null || J();
      },
      onDisconnectWallet: () => {
        ie(), V == null || V();
      }
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    PreConnectButton,
    {
      disabled: !Ce,
      connectButton: B,
      connectButtonComponent: L,
      openModal: ne
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    Oe(),
    Ce ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectWalletModal, { isOpen: pe, closeModal: ce }) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var L, W, K, J = ht.prototype = { constructor: ht, toString: null, valueOf: null }, V = new ht(1), re = 20, ie = 4, oe = -7, pe = 21, ne = -1e7, ce = 1e7, Ce = !1, Oe = 1, st = 0, at = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, lt = "0123456789abcdefghijklmnopqrstuvwxyz", pt = !0;
  function ht(Et, St) {
    var It, Tt, nt, it, ke, rt, ot, ft, ct = this;
    if (!(ct instanceof ht)) return new ht(Et, St);
    if (St == null) {
      if (Et && Et._isBigNumber === !0) {
        ct.s = Et.s, !Et.c || Et.e > ce ? ct.c = ct.e = null : Et.e < ne ? ct.c = [ct.e = 0] : (ct.e = Et.e, ct.c = Et.c.slice());
        return;
      }
      if ((rt = typeof Et == "number") && Et * 0 == 0) {
        if (ct.s = 1 / Et < 0 ? (Et = -Et, -1) : 1, Et === ~~Et) {
          for (it = 0, ke = Et; ke >= 10; ke /= 10, it++) ;
          it > ce ? ct.c = ct.e = null : (ct.e = it, ct.c = [Et]);
          return;
        }
        ft = String(Et);
      } else {
        if (!isNumeric.test(ft = String(Et))) return K(ct, ft, rt);
        ct.s = ft.charCodeAt(0) == 45 ? (ft = ft.slice(1), -1) : 1;
      }
      (it = ft.indexOf(".")) > -1 && (ft = ft.replace(".", "")), (ke = ft.search(/e/i)) > 0 ? (it < 0 && (it = ke), it += +ft.slice(ke + 1), ft = ft.substring(0, ke)) : it < 0 && (it = ft.length);
    } else {
      if (intCheck(St, 2, lt.length, "Base"), St == 10 && pt)
        return ct = new ht(Et), xt(ct, re + ct.e + 1, ie);
      if (ft = String(Et), rt = typeof Et == "number") {
        if (Et * 0 != 0) return K(ct, ft, rt, St);
        if (ct.s = 1 / Et < 0 ? (ft = ft.slice(1), -1) : 1, ht.DEBUG && ft.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Et);
      } else
        ct.s = ft.charCodeAt(0) === 45 ? (ft = ft.slice(1), -1) : 1;
      for (It = lt.slice(0, St), it = ke = 0, ot = ft.length; ke < ot; ke++)
        if (It.indexOf(Tt = ft.charAt(ke)) < 0) {
          if (Tt == ".") {
            if (ke > it) {
              it = ot;
              continue;
            }
          } else if (!nt && (ft == ft.toUpperCase() && (ft = ft.toLowerCase()) || ft == ft.toLowerCase() && (ft = ft.toUpperCase()))) {
            nt = !0, ke = -1, it = 0;
            continue;
          }
          return K(ct, String(Et), rt, St);
        }
      rt = !1, ft = W(ft, St, 10, ct.s), (it = ft.indexOf(".")) > -1 ? ft = ft.replace(".", "") : it = ft.length;
    }
    for (ke = 0; ft.charCodeAt(ke) === 48; ke++) ;
    for (ot = ft.length; ft.charCodeAt(--ot) === 48; ) ;
    if (ft = ft.slice(ke, ++ot)) {
      if (ot -= ke, rt && ht.DEBUG && ot > 15 && (Et > MAX_SAFE_INTEGER || Et !== mathfloor(Et)))
        throw Error(tooManyDigits + ct.s * Et);
      if ((it = it - ke - 1) > ce)
        ct.c = ct.e = null;
      else if (it < ne)
        ct.c = [ct.e = 0];
      else {
        if (ct.e = it, ct.c = [], ke = (it + 1) % LOG_BASE, it < 0 && (ke += LOG_BASE), ke < ot) {
          for (ke && ct.c.push(+ft.slice(0, ke)), ot -= LOG_BASE; ke < ot; )
            ct.c.push(+ft.slice(ke, ke += LOG_BASE));
          ke = LOG_BASE - (ft = ft.slice(ke)).length;
        } else
          ke -= ot;
        for (; ke--; ft += "0") ;
        ct.c.push(+ft);
      }
    } else
      ct.c = [ct.e = 0];
  }
  ht.clone = clone, ht.ROUND_UP = 0, ht.ROUND_DOWN = 1, ht.ROUND_CEIL = 2, ht.ROUND_FLOOR = 3, ht.ROUND_HALF_UP = 4, ht.ROUND_HALF_DOWN = 5, ht.ROUND_HALF_EVEN = 6, ht.ROUND_HALF_CEIL = 7, ht.ROUND_HALF_FLOOR = 8, ht.EUCLID = 9, ht.config = ht.set = function(Et) {
    var St, It;
    if (Et != null)
      if (typeof Et == "object") {
        if (Et.hasOwnProperty(St = "DECIMAL_PLACES") && (It = Et[St], intCheck(It, 0, MAX, St), re = It), Et.hasOwnProperty(St = "ROUNDING_MODE") && (It = Et[St], intCheck(It, 0, 8, St), ie = It), Et.hasOwnProperty(St = "EXPONENTIAL_AT") && (It = Et[St], It && It.pop ? (intCheck(It[0], -MAX, 0, St), intCheck(It[1], 0, MAX, St), oe = It[0], pe = It[1]) : (intCheck(It, -MAX, MAX, St), oe = -(pe = It < 0 ? -It : It))), Et.hasOwnProperty(St = "RANGE"))
          if (It = Et[St], It && It.pop)
            intCheck(It[0], -MAX, -1, St), intCheck(It[1], 1, MAX, St), ne = It[0], ce = It[1];
          else if (intCheck(It, -MAX, MAX, St), It)
            ne = -(ce = It < 0 ? -It : It);
          else
            throw Error(bignumberError + St + " cannot be zero: " + It);
        if (Et.hasOwnProperty(St = "CRYPTO"))
          if (It = Et[St], It === !!It)
            if (It)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Ce = It;
              else
                throw Ce = !It, Error(bignumberError + "crypto unavailable");
            else
              Ce = It;
          else
            throw Error(bignumberError + St + " not true or false: " + It);
        if (Et.hasOwnProperty(St = "MODULO_MODE") && (It = Et[St], intCheck(It, 0, 9, St), Oe = It), Et.hasOwnProperty(St = "POW_PRECISION") && (It = Et[St], intCheck(It, 0, MAX, St), st = It), Et.hasOwnProperty(St = "FORMAT"))
          if (It = Et[St], typeof It == "object") at = It;
          else throw Error(bignumberError + St + " not an object: " + It);
        if (Et.hasOwnProperty(St = "ALPHABET"))
          if (It = Et[St], typeof It == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(It))
            pt = It.slice(0, 10) == "0123456789", lt = It;
          else
            throw Error(bignumberError + St + " invalid: " + It);
      } else
        throw Error(bignumberError + "Object expected: " + Et);
    return {
      DECIMAL_PLACES: re,
      ROUNDING_MODE: ie,
      EXPONENTIAL_AT: [oe, pe],
      RANGE: [ne, ce],
      CRYPTO: Ce,
      MODULO_MODE: Oe,
      POW_PRECISION: st,
      FORMAT: at,
      ALPHABET: lt
    };
  }, ht.isBigNumber = function(Et) {
    if (!Et || Et._isBigNumber !== !0) return !1;
    if (!ht.DEBUG) return !0;
    var St, It, Tt = Et.c, nt = Et.e, it = Et.s;
    e: if ({}.toString.call(Tt) == "[object Array]") {
      if ((it === 1 || it === -1) && nt >= -MAX && nt <= MAX && nt === mathfloor(nt)) {
        if (Tt[0] === 0) {
          if (nt === 0 && Tt.length === 1) return !0;
          break e;
        }
        if (St = (nt + 1) % LOG_BASE, St < 1 && (St += LOG_BASE), String(Tt[0]).length == St) {
          for (St = 0; St < Tt.length; St++)
            if (It = Tt[St], It < 0 || It >= BASE || It !== mathfloor(It)) break e;
          if (It !== 0) return !0;
        }
      }
    } else if (Tt === null && nt === null && (it === null || it === 1 || it === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Et);
  }, ht.maximum = ht.max = function() {
    return vt(arguments, -1);
  }, ht.minimum = ht.min = function() {
    return vt(arguments, 1);
  }, ht.random = function() {
    var Et = 9007199254740992, St = Math.random() * Et & 2097151 ? function() {
      return mathfloor(Math.random() * Et);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(It) {
      var Tt, nt, it, ke, rt, ot = 0, ft = [], ct = new ht(V);
      if (It == null ? It = re : intCheck(It, 0, MAX), ke = mathceil(It / LOG_BASE), Ce)
        if (crypto.getRandomValues) {
          for (Tt = crypto.getRandomValues(new Uint32Array(ke *= 2)); ot < ke; )
            rt = Tt[ot] * 131072 + (Tt[ot + 1] >>> 11), rt >= 9e15 ? (nt = crypto.getRandomValues(new Uint32Array(2)), Tt[ot] = nt[0], Tt[ot + 1] = nt[1]) : (ft.push(rt % 1e14), ot += 2);
          ot = ke / 2;
        } else if (crypto.randomBytes) {
          for (Tt = crypto.randomBytes(ke *= 7); ot < ke; )
            rt = (Tt[ot] & 31) * 281474976710656 + Tt[ot + 1] * 1099511627776 + Tt[ot + 2] * 4294967296 + Tt[ot + 3] * 16777216 + (Tt[ot + 4] << 16) + (Tt[ot + 5] << 8) + Tt[ot + 6], rt >= 9e15 ? crypto.randomBytes(7).copy(Tt, ot) : (ft.push(rt % 1e14), ot += 7);
          ot = ke / 7;
        } else
          throw Ce = !1, Error(bignumberError + "crypto unavailable");
      if (!Ce)
        for (; ot < ke; )
          rt = St(), rt < 9e15 && (ft[ot++] = rt % 1e14);
      for (ke = ft[--ot], It %= LOG_BASE, ke && It && (rt = POWS_TEN[LOG_BASE - It], ft[ot] = mathfloor(ke / rt) * rt); ft[ot] === 0; ft.pop(), ot--) ;
      if (ot < 0)
        ft = [it = 0];
      else {
        for (it = -1; ft[0] === 0; ft.splice(0, 1), it -= LOG_BASE) ;
        for (ot = 1, rt = ft[0]; rt >= 10; rt /= 10, ot++) ;
        ot < LOG_BASE && (it -= LOG_BASE - ot);
      }
      return ct.e = it, ct.c = ft, ct;
    };
  }(), ht.sum = function() {
    for (var Et = 1, St = arguments, It = new ht(St[0]); Et < St.length; ) It = It.plus(St[Et++]);
    return It;
  }, W = /* @__PURE__ */ function() {
    var Et = "0123456789";
    function St(It, Tt, nt, it) {
      for (var ke, rt = [0], ot, ft = 0, ct = It.length; ft < ct; ) {
        for (ot = rt.length; ot--; rt[ot] *= Tt) ;
        for (rt[0] += it.indexOf(It.charAt(ft++)), ke = 0; ke < rt.length; ke++)
          rt[ke] > nt - 1 && (rt[ke + 1] == null && (rt[ke + 1] = 0), rt[ke + 1] += rt[ke] / nt | 0, rt[ke] %= nt);
      }
      return rt.reverse();
    }
    return function(It, Tt, nt, it, ke) {
      var rt, ot, ft, ct, bt, ut, gt, dt, wt = It.indexOf("."), Ft = re, jt = ie;
      for (wt >= 0 && (ct = st, st = 0, It = It.replace(".", ""), dt = new ht(Tt), ut = dt.pow(It.length - wt), st = ct, dt.c = St(
        toFixedPoint(coeffToString(ut.c), ut.e, "0"),
        10,
        nt,
        Et
      ), dt.e = dt.c.length), gt = St(It, Tt, nt, ke ? (rt = lt, Et) : (rt = Et, lt)), ft = ct = gt.length; gt[--ct] == 0; gt.pop()) ;
      if (!gt[0]) return rt.charAt(0);
      if (wt < 0 ? --ft : (ut.c = gt, ut.e = ft, ut.s = it, ut = L(ut, dt, Ft, jt, nt), gt = ut.c, bt = ut.r, ft = ut.e), ot = ft + Ft + 1, wt = gt[ot], ct = nt / 2, bt = bt || ot < 0 || gt[ot + 1] != null, bt = jt < 4 ? (wt != null || bt) && (jt == 0 || jt == (ut.s < 0 ? 3 : 2)) : wt > ct || wt == ct && (jt == 4 || bt || jt == 6 && gt[ot - 1] & 1 || jt == (ut.s < 0 ? 8 : 7)), ot < 1 || !gt[0])
        It = bt ? toFixedPoint(rt.charAt(1), -Ft, rt.charAt(0)) : rt.charAt(0);
      else {
        if (gt.length = ot, bt)
          for (--nt; ++gt[--ot] > nt; )
            gt[ot] = 0, ot || (++ft, gt = [1].concat(gt));
        for (ct = gt.length; !gt[--ct]; ) ;
        for (wt = 0, It = ""; wt <= ct; It += rt.charAt(gt[wt++])) ;
        It = toFixedPoint(It, ft, rt.charAt(0));
      }
      return It;
    };
  }(), L = /* @__PURE__ */ function() {
    function Et(Tt, nt, it) {
      var ke, rt, ot, ft, ct = 0, bt = Tt.length, ut = nt % SQRT_BASE, gt = nt / SQRT_BASE | 0;
      for (Tt = Tt.slice(); bt--; )
        ot = Tt[bt] % SQRT_BASE, ft = Tt[bt] / SQRT_BASE | 0, ke = gt * ot + ft * ut, rt = ut * ot + ke % SQRT_BASE * SQRT_BASE + ct, ct = (rt / it | 0) + (ke / SQRT_BASE | 0) + gt * ft, Tt[bt] = rt % it;
      return ct && (Tt = [ct].concat(Tt)), Tt;
    }
    function St(Tt, nt, it, ke) {
      var rt, ot;
      if (it != ke)
        ot = it > ke ? 1 : -1;
      else
        for (rt = ot = 0; rt < it; rt++)
          if (Tt[rt] != nt[rt]) {
            ot = Tt[rt] > nt[rt] ? 1 : -1;
            break;
          }
      return ot;
    }
    function It(Tt, nt, it, ke) {
      for (var rt = 0; it--; )
        Tt[it] -= rt, rt = Tt[it] < nt[it] ? 1 : 0, Tt[it] = rt * ke + Tt[it] - nt[it];
      for (; !Tt[0] && Tt.length > 1; Tt.splice(0, 1)) ;
    }
    return function(Tt, nt, it, ke, rt) {
      var ot, ft, ct, bt, ut, gt, dt, wt, Ft, jt, Nt, Bt, Rt, Ut, zt, Mt, kt, Gt = Tt.s == nt.s ? 1 : -1, Qt = Tt.c, nr = nt.c;
      if (!Qt || !Qt[0] || !nr || !nr[0])
        return new ht(
          // Return NaN if either NaN, or both Infinity or 0.
          !Tt.s || !nt.s || (Qt ? nr && Qt[0] == nr[0] : !nr) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            Qt && Qt[0] == 0 || !nr ? Gt * 0 : Gt / 0
          )
        );
      for (wt = new ht(Gt), Ft = wt.c = [], ft = Tt.e - nt.e, Gt = it + ft + 1, rt || (rt = BASE, ft = bitFloor(Tt.e / LOG_BASE) - bitFloor(nt.e / LOG_BASE), Gt = Gt / LOG_BASE | 0), ct = 0; nr[ct] == (Qt[ct] || 0); ct++) ;
      if (nr[ct] > (Qt[ct] || 0) && ft--, Gt < 0)
        Ft.push(1), bt = !0;
      else {
        for (Ut = Qt.length, Mt = nr.length, ct = 0, Gt += 2, ut = mathfloor(rt / (nr[0] + 1)), ut > 1 && (nr = Et(nr, ut, rt), Qt = Et(Qt, ut, rt), Mt = nr.length, Ut = Qt.length), Rt = Mt, jt = Qt.slice(0, Mt), Nt = jt.length; Nt < Mt; jt[Nt++] = 0) ;
        kt = nr.slice(), kt = [0].concat(kt), zt = nr[0], nr[1] >= rt / 2 && zt++;
        do {
          if (ut = 0, ot = St(nr, jt, Mt, Nt), ot < 0) {
            if (Bt = jt[0], Mt != Nt && (Bt = Bt * rt + (jt[1] || 0)), ut = mathfloor(Bt / zt), ut > 1)
              for (ut >= rt && (ut = rt - 1), gt = Et(nr, ut, rt), dt = gt.length, Nt = jt.length; St(gt, jt, dt, Nt) == 1; )
                ut--, It(gt, Mt < dt ? kt : nr, dt, rt), dt = gt.length, ot = 1;
            else
              ut == 0 && (ot = ut = 1), gt = nr.slice(), dt = gt.length;
            if (dt < Nt && (gt = [0].concat(gt)), It(jt, gt, Nt, rt), Nt = jt.length, ot == -1)
              for (; St(nr, jt, Mt, Nt) < 1; )
                ut++, It(jt, Mt < Nt ? kt : nr, Nt, rt), Nt = jt.length;
          } else ot === 0 && (ut++, jt = [0]);
          Ft[ct++] = ut, jt[0] ? jt[Nt++] = Qt[Rt] || 0 : (jt = [Qt[Rt]], Nt = 1);
        } while ((Rt++ < Ut || jt[0] != null) && Gt--);
        bt = jt[0] != null, Ft[0] || Ft.splice(0, 1);
      }
      if (rt == BASE) {
        for (ct = 1, Gt = Ft[0]; Gt >= 10; Gt /= 10, ct++) ;
        xt(wt, it + (wt.e = ct + ft * LOG_BASE - 1) + 1, ke, bt);
      } else
        wt.e = ft, wt.r = +bt;
      return wt;
    };
  }();
  function yt(Et, St, It, Tt) {
    var nt, it, ke, rt, ot;
    if (It == null ? It = ie : intCheck(It, 0, 8), !Et.c) return Et.toString();
    if (nt = Et.c[0], ke = Et.e, St == null)
      ot = coeffToString(Et.c), ot = Tt == 1 || Tt == 2 && (ke <= oe || ke >= pe) ? toExponential(ot, ke) : toFixedPoint(ot, ke, "0");
    else if (Et = xt(new ht(Et), St, It), it = Et.e, ot = coeffToString(Et.c), rt = ot.length, Tt == 1 || Tt == 2 && (St <= it || it <= oe)) {
      for (; rt < St; ot += "0", rt++) ;
      ot = toExponential(ot, it);
    } else if (St -= ke, ot = toFixedPoint(ot, it, "0"), it + 1 > rt) {
      if (--St > 0) for (ot += "."; St--; ot += "0") ;
    } else if (St += it - rt, St > 0)
      for (it + 1 == rt && (ot += "."); St--; ot += "0") ;
    return Et.s < 0 && nt ? "-" + ot : ot;
  }
  function vt(Et, St) {
    for (var It, Tt, nt = 1, it = new ht(Et[0]); nt < Et.length; nt++)
      Tt = new ht(Et[nt]), (!Tt.s || (It = compare(it, Tt)) === St || It === 0 && it.s === St) && (it = Tt);
    return it;
  }
  function $t(Et, St, It) {
    for (var Tt = 1, nt = St.length; !St[--nt]; St.pop()) ;
    for (nt = St[0]; nt >= 10; nt /= 10, Tt++) ;
    return (It = Tt + It * LOG_BASE - 1) > ce ? Et.c = Et.e = null : It < ne ? Et.c = [Et.e = 0] : (Et.e = It, Et.c = St), Et;
  }
  K = /* @__PURE__ */ function() {
    var Et = /^(-?)0([xbo])(?=\w[\w.]*$)/i, St = /^([^.]+)\.$/, It = /^\.([^.]+)$/, Tt = /^-?(Infinity|NaN)$/, nt = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(it, ke, rt, ot) {
      var ft, ct = rt ? ke : ke.replace(nt, "");
      if (Tt.test(ct))
        it.s = isNaN(ct) ? null : ct < 0 ? -1 : 1;
      else {
        if (!rt && (ct = ct.replace(Et, function(bt, ut, gt) {
          return ft = (gt = gt.toLowerCase()) == "x" ? 16 : gt == "b" ? 2 : 8, !ot || ot == ft ? ut : bt;
        }), ot && (ft = ot, ct = ct.replace(St, "$1").replace(It, "0.$1")), ke != ct))
          return new ht(ct, ft);
        if (ht.DEBUG)
          throw Error(bignumberError + "Not a" + (ot ? " base " + ot : "") + " number: " + ke);
        it.s = null;
      }
      it.c = it.e = null;
    };
  }();
  function xt(Et, St, It, Tt) {
    var nt, it, ke, rt, ot, ft, ct, bt = Et.c, ut = POWS_TEN;
    if (bt) {
      e: {
        for (nt = 1, rt = bt[0]; rt >= 10; rt /= 10, nt++) ;
        if (it = St - nt, it < 0)
          it += LOG_BASE, ke = St, ot = bt[ft = 0], ct = mathfloor(ot / ut[nt - ke - 1] % 10);
        else if (ft = mathceil((it + 1) / LOG_BASE), ft >= bt.length)
          if (Tt) {
            for (; bt.length <= ft; bt.push(0)) ;
            ot = ct = 0, nt = 1, it %= LOG_BASE, ke = it - LOG_BASE + 1;
          } else
            break e;
        else {
          for (ot = rt = bt[ft], nt = 1; rt >= 10; rt /= 10, nt++) ;
          it %= LOG_BASE, ke = it - LOG_BASE + nt, ct = ke < 0 ? 0 : mathfloor(ot / ut[nt - ke - 1] % 10);
        }
        if (Tt = Tt || St < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        bt[ft + 1] != null || (ke < 0 ? ot : ot % ut[nt - ke - 1]), Tt = It < 4 ? (ct || Tt) && (It == 0 || It == (Et.s < 0 ? 3 : 2)) : ct > 5 || ct == 5 && (It == 4 || Tt || It == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (it > 0 ? ke > 0 ? ot / ut[nt - ke] : 0 : bt[ft - 1]) % 10 & 1 || It == (Et.s < 0 ? 8 : 7)), St < 1 || !bt[0])
          return bt.length = 0, Tt ? (St -= Et.e + 1, bt[0] = ut[(LOG_BASE - St % LOG_BASE) % LOG_BASE], Et.e = -St || 0) : bt[0] = Et.e = 0, Et;
        if (it == 0 ? (bt.length = ft, rt = 1, ft--) : (bt.length = ft + 1, rt = ut[LOG_BASE - it], bt[ft] = ke > 0 ? mathfloor(ot / ut[nt - ke] % ut[ke]) * rt : 0), Tt)
          for (; ; )
            if (ft == 0) {
              for (it = 1, ke = bt[0]; ke >= 10; ke /= 10, it++) ;
              for (ke = bt[0] += rt, rt = 1; ke >= 10; ke /= 10, rt++) ;
              it != rt && (Et.e++, bt[0] == BASE && (bt[0] = 1));
              break;
            } else {
              if (bt[ft] += rt, bt[ft] != BASE) break;
              bt[ft--] = 0, rt = 1;
            }
        for (it = bt.length; bt[--it] === 0; bt.pop()) ;
      }
      Et.e > ce ? Et.c = Et.e = null : Et.e < ne && (Et.c = [Et.e = 0]);
    }
    return Et;
  }
  function Ct(Et) {
    var St, It = Et.e;
    return It === null ? Et.toString() : (St = coeffToString(Et.c), St = It <= oe || It >= pe ? toExponential(St, It) : toFixedPoint(St, It, "0"), Et.s < 0 ? "-" + St : St);
  }
  return J.absoluteValue = J.abs = function() {
    var Et = new ht(this);
    return Et.s < 0 && (Et.s = 1), Et;
  }, J.comparedTo = function(Et, St) {
    return compare(this, new ht(Et, St));
  }, J.decimalPlaces = J.dp = function(Et, St) {
    var It, Tt, nt, it = this;
    if (Et != null)
      return intCheck(Et, 0, MAX), St == null ? St = ie : intCheck(St, 0, 8), xt(new ht(it), Et + it.e + 1, St);
    if (!(It = it.c)) return null;
    if (Tt = ((nt = It.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, nt = It[nt]) for (; nt % 10 == 0; nt /= 10, Tt--) ;
    return Tt < 0 && (Tt = 0), Tt;
  }, J.dividedBy = J.div = function(Et, St) {
    return L(this, new ht(Et, St), re, ie);
  }, J.dividedToIntegerBy = J.idiv = function(Et, St) {
    return L(this, new ht(Et, St), 0, 1);
  }, J.exponentiatedBy = J.pow = function(Et, St) {
    var It, Tt, nt, it, ke, rt, ot, ft, ct, bt = this;
    if (Et = new ht(Et), Et.c && !Et.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Ct(Et));
    if (St != null && (St = new ht(St)), rt = Et.e > 14, !bt.c || !bt.c[0] || bt.c[0] == 1 && !bt.e && bt.c.length == 1 || !Et.c || !Et.c[0])
      return ct = new ht(Math.pow(+Ct(bt), rt ? Et.s * (2 - isOdd(Et)) : +Ct(Et))), St ? ct.mod(St) : ct;
    if (ot = Et.s < 0, St) {
      if (St.c ? !St.c[0] : !St.s) return new ht(NaN);
      Tt = !ot && bt.isInteger() && St.isInteger(), Tt && (bt = bt.mod(St));
    } else {
      if (Et.e > 9 && (bt.e > 0 || bt.e < -1 || (bt.e == 0 ? bt.c[0] > 1 || rt && bt.c[1] >= 24e7 : bt.c[0] < 8e13 || rt && bt.c[0] <= 9999975e7)))
        return it = bt.s < 0 && isOdd(Et) ? -0 : 0, bt.e > -1 && (it = 1 / it), new ht(ot ? 1 / it : it);
      st && (it = mathceil(st / LOG_BASE + 2));
    }
    for (rt ? (It = new ht(0.5), ot && (Et.s = 1), ft = isOdd(Et)) : (nt = Math.abs(+Ct(Et)), ft = nt % 2), ct = new ht(V); ; ) {
      if (ft) {
        if (ct = ct.times(bt), !ct.c) break;
        it ? ct.c.length > it && (ct.c.length = it) : Tt && (ct = ct.mod(St));
      }
      if (nt) {
        if (nt = mathfloor(nt / 2), nt === 0) break;
        ft = nt % 2;
      } else if (Et = Et.times(It), xt(Et, Et.e + 1, 1), Et.e > 14)
        ft = isOdd(Et);
      else {
        if (nt = +Ct(Et), nt === 0) break;
        ft = nt % 2;
      }
      bt = bt.times(bt), it ? bt.c && bt.c.length > it && (bt.c.length = it) : Tt && (bt = bt.mod(St));
    }
    return Tt ? ct : (ot && (ct = V.div(ct)), St ? ct.mod(St) : it ? xt(ct, st, ie, ke) : ct);
  }, J.integerValue = function(Et) {
    var St = new ht(this);
    return Et == null ? Et = ie : intCheck(Et, 0, 8), xt(St, St.e + 1, Et);
  }, J.isEqualTo = J.eq = function(Et, St) {
    return compare(this, new ht(Et, St)) === 0;
  }, J.isFinite = function() {
    return !!this.c;
  }, J.isGreaterThan = J.gt = function(Et, St) {
    return compare(this, new ht(Et, St)) > 0;
  }, J.isGreaterThanOrEqualTo = J.gte = function(Et, St) {
    return (St = compare(this, new ht(Et, St))) === 1 || St === 0;
  }, J.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, J.isLessThan = J.lt = function(Et, St) {
    return compare(this, new ht(Et, St)) < 0;
  }, J.isLessThanOrEqualTo = J.lte = function(Et, St) {
    return (St = compare(this, new ht(Et, St))) === -1 || St === 0;
  }, J.isNaN = function() {
    return !this.s;
  }, J.isNegative = function() {
    return this.s < 0;
  }, J.isPositive = function() {
    return this.s > 0;
  }, J.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, J.minus = function(Et, St) {
    var It, Tt, nt, it, ke = this, rt = ke.s;
    if (Et = new ht(Et, St), St = Et.s, !rt || !St) return new ht(NaN);
    if (rt != St)
      return Et.s = -St, ke.plus(Et);
    var ot = ke.e / LOG_BASE, ft = Et.e / LOG_BASE, ct = ke.c, bt = Et.c;
    if (!ot || !ft) {
      if (!ct || !bt) return ct ? (Et.s = -St, Et) : new ht(bt ? ke : NaN);
      if (!ct[0] || !bt[0])
        return bt[0] ? (Et.s = -St, Et) : new ht(ct[0] ? ke : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ie == 3 ? -0 : 0
        ));
    }
    if (ot = bitFloor(ot), ft = bitFloor(ft), ct = ct.slice(), rt = ot - ft) {
      for ((it = rt < 0) ? (rt = -rt, nt = ct) : (ft = ot, nt = bt), nt.reverse(), St = rt; St--; nt.push(0)) ;
      nt.reverse();
    } else
      for (Tt = (it = (rt = ct.length) < (St = bt.length)) ? rt : St, rt = St = 0; St < Tt; St++)
        if (ct[St] != bt[St]) {
          it = ct[St] < bt[St];
          break;
        }
    if (it && (nt = ct, ct = bt, bt = nt, Et.s = -Et.s), St = (Tt = bt.length) - (It = ct.length), St > 0) for (; St--; ct[It++] = 0) ;
    for (St = BASE - 1; Tt > rt; ) {
      if (ct[--Tt] < bt[Tt]) {
        for (It = Tt; It && !ct[--It]; ct[It] = St) ;
        --ct[It], ct[Tt] += BASE;
      }
      ct[Tt] -= bt[Tt];
    }
    for (; ct[0] == 0; ct.splice(0, 1), --ft) ;
    return ct[0] ? $t(Et, ct, ft) : (Et.s = ie == 3 ? -1 : 1, Et.c = [Et.e = 0], Et);
  }, J.modulo = J.mod = function(Et, St) {
    var It, Tt, nt = this;
    return Et = new ht(Et, St), !nt.c || !Et.s || Et.c && !Et.c[0] ? new ht(NaN) : !Et.c || nt.c && !nt.c[0] ? new ht(nt) : (Oe == 9 ? (Tt = Et.s, Et.s = 1, It = L(nt, Et, 0, 3), Et.s = Tt, It.s *= Tt) : It = L(nt, Et, 0, Oe), Et = nt.minus(It.times(Et)), !Et.c[0] && Oe == 1 && (Et.s = nt.s), Et);
  }, J.multipliedBy = J.times = function(Et, St) {
    var It, Tt, nt, it, ke, rt, ot, ft, ct, bt, ut, gt, dt, wt, Ft, jt = this, Nt = jt.c, Bt = (Et = new ht(Et, St)).c;
    if (!Nt || !Bt || !Nt[0] || !Bt[0])
      return !jt.s || !Et.s || Nt && !Nt[0] && !Bt || Bt && !Bt[0] && !Nt ? Et.c = Et.e = Et.s = null : (Et.s *= jt.s, !Nt || !Bt ? Et.c = Et.e = null : (Et.c = [0], Et.e = 0)), Et;
    for (Tt = bitFloor(jt.e / LOG_BASE) + bitFloor(Et.e / LOG_BASE), Et.s *= jt.s, ot = Nt.length, bt = Bt.length, ot < bt && (dt = Nt, Nt = Bt, Bt = dt, nt = ot, ot = bt, bt = nt), nt = ot + bt, dt = []; nt--; dt.push(0)) ;
    for (wt = BASE, Ft = SQRT_BASE, nt = bt; --nt >= 0; ) {
      for (It = 0, ut = Bt[nt] % Ft, gt = Bt[nt] / Ft | 0, ke = ot, it = nt + ke; it > nt; )
        ft = Nt[--ke] % Ft, ct = Nt[ke] / Ft | 0, rt = gt * ft + ct * ut, ft = ut * ft + rt % Ft * Ft + dt[it] + It, It = (ft / wt | 0) + (rt / Ft | 0) + gt * ct, dt[it--] = ft % wt;
      dt[it] = It;
    }
    return It ? ++Tt : dt.splice(0, 1), $t(Et, dt, Tt);
  }, J.negated = function() {
    var Et = new ht(this);
    return Et.s = -Et.s || null, Et;
  }, J.plus = function(Et, St) {
    var It, Tt = this, nt = Tt.s;
    if (Et = new ht(Et, St), St = Et.s, !nt || !St) return new ht(NaN);
    if (nt != St)
      return Et.s = -St, Tt.minus(Et);
    var it = Tt.e / LOG_BASE, ke = Et.e / LOG_BASE, rt = Tt.c, ot = Et.c;
    if (!it || !ke) {
      if (!rt || !ot) return new ht(nt / 0);
      if (!rt[0] || !ot[0]) return ot[0] ? Et : new ht(rt[0] ? Tt : nt * 0);
    }
    if (it = bitFloor(it), ke = bitFloor(ke), rt = rt.slice(), nt = it - ke) {
      for (nt > 0 ? (ke = it, It = ot) : (nt = -nt, It = rt), It.reverse(); nt--; It.push(0)) ;
      It.reverse();
    }
    for (nt = rt.length, St = ot.length, nt - St < 0 && (It = ot, ot = rt, rt = It, St = nt), nt = 0; St; )
      nt = (rt[--St] = rt[St] + ot[St] + nt) / BASE | 0, rt[St] = BASE === rt[St] ? 0 : rt[St] % BASE;
    return nt && (rt = [nt].concat(rt), ++ke), $t(Et, rt, ke);
  }, J.precision = J.sd = function(Et, St) {
    var It, Tt, nt, it = this;
    if (Et != null && Et !== !!Et)
      return intCheck(Et, 1, MAX), St == null ? St = ie : intCheck(St, 0, 8), xt(new ht(it), Et, St);
    if (!(It = it.c)) return null;
    if (nt = It.length - 1, Tt = nt * LOG_BASE + 1, nt = It[nt]) {
      for (; nt % 10 == 0; nt /= 10, Tt--) ;
      for (nt = It[0]; nt >= 10; nt /= 10, Tt++) ;
    }
    return Et && it.e + 1 > Tt && (Tt = it.e + 1), Tt;
  }, J.shiftedBy = function(Et) {
    return intCheck(Et, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER), this.times("1e" + Et);
  }, J.squareRoot = J.sqrt = function() {
    var Et, St, It, Tt, nt, it = this, ke = it.c, rt = it.s, ot = it.e, ft = re + 4, ct = new ht("0.5");
    if (rt !== 1 || !ke || !ke[0])
      return new ht(!rt || rt < 0 && (!ke || ke[0]) ? NaN : ke ? it : 1 / 0);
    if (rt = Math.sqrt(+Ct(it)), rt == 0 || rt == 1 / 0 ? (St = coeffToString(ke), (St.length + ot) % 2 == 0 && (St += "0"), rt = Math.sqrt(+St), ot = bitFloor((ot + 1) / 2) - (ot < 0 || ot % 2), rt == 1 / 0 ? St = "5e" + ot : (St = rt.toExponential(), St = St.slice(0, St.indexOf("e") + 1) + ot), It = new ht(St)) : It = new ht(rt + ""), It.c[0]) {
      for (ot = It.e, rt = ot + ft, rt < 3 && (rt = 0); ; )
        if (nt = It, It = ct.times(nt.plus(L(it, nt, ft, 1))), coeffToString(nt.c).slice(0, rt) === (St = coeffToString(It.c)).slice(0, rt))
          if (It.e < ot && --rt, St = St.slice(rt - 3, rt + 1), St == "9999" || !Tt && St == "4999") {
            if (!Tt && (xt(nt, nt.e + re + 2, 0), nt.times(nt).eq(it))) {
              It = nt;
              break;
            }
            ft += 4, rt += 4, Tt = 1;
          } else {
            (!+St || !+St.slice(1) && St.charAt(0) == "5") && (xt(It, It.e + re + 2, 1), Et = !It.times(It).eq(it));
            break;
          }
    }
    return xt(It, It.e + re + 1, ie, Et);
  }, J.toExponential = function(Et, St) {
    return Et != null && (intCheck(Et, 0, MAX), Et++), yt(this, Et, St, 1);
  }, J.toFixed = function(Et, St) {
    return Et != null && (intCheck(Et, 0, MAX), Et = Et + this.e + 1), yt(this, Et, St);
  }, J.toFormat = function(Et, St, It) {
    var Tt, nt = this;
    if (It == null)
      Et != null && St && typeof St == "object" ? (It = St, St = null) : Et && typeof Et == "object" ? (It = Et, Et = St = null) : It = at;
    else if (typeof It != "object")
      throw Error(bignumberError + "Argument not an object: " + It);
    if (Tt = nt.toFixed(Et, St), nt.c) {
      var it, ke = Tt.split("."), rt = +It.groupSize, ot = +It.secondaryGroupSize, ft = It.groupSeparator || "", ct = ke[0], bt = ke[1], ut = nt.s < 0, gt = ut ? ct.slice(1) : ct, dt = gt.length;
      if (ot && (it = rt, rt = ot, ot = it, dt -= it), rt > 0 && dt > 0) {
        for (it = dt % rt || rt, ct = gt.substr(0, it); it < dt; it += rt) ct += ft + gt.substr(it, rt);
        ot > 0 && (ct += ft + gt.slice(it)), ut && (ct = "-" + ct);
      }
      Tt = bt ? ct + (It.decimalSeparator || "") + ((ot = +It.fractionGroupSize) ? bt.replace(
        new RegExp("\\d{" + ot + "}\\B", "g"),
        "$&" + (It.fractionGroupSeparator || "")
      ) : bt) : ct;
    }
    return (It.prefix || "") + Tt + (It.suffix || "");
  }, J.toFraction = function(Et) {
    var St, It, Tt, nt, it, ke, rt, ot, ft, ct, bt, ut, gt = this, dt = gt.c;
    if (Et != null && (rt = new ht(Et), !rt.isInteger() && (rt.c || rt.s !== 1) || rt.lt(V)))
      throw Error(bignumberError + "Argument " + (rt.isInteger() ? "out of range: " : "not an integer: ") + Ct(rt));
    if (!dt) return new ht(gt);
    for (St = new ht(V), ft = It = new ht(V), Tt = ot = new ht(V), ut = coeffToString(dt), it = St.e = ut.length - gt.e - 1, St.c[0] = POWS_TEN[(ke = it % LOG_BASE) < 0 ? LOG_BASE + ke : ke], Et = !Et || rt.comparedTo(St) > 0 ? it > 0 ? St : ft : rt, ke = ce, ce = 1 / 0, rt = new ht(ut), ot.c[0] = 0; ct = L(rt, St, 0, 1), nt = It.plus(ct.times(Tt)), nt.comparedTo(Et) != 1; )
      It = Tt, Tt = nt, ft = ot.plus(ct.times(nt = ft)), ot = nt, St = rt.minus(ct.times(nt = St)), rt = nt;
    return nt = L(Et.minus(It), Tt, 0, 1), ot = ot.plus(nt.times(ft)), It = It.plus(nt.times(Tt)), ot.s = ft.s = gt.s, it = it * 2, bt = L(ft, Tt, it, ie).minus(gt).abs().comparedTo(
      L(ot, It, it, ie).minus(gt).abs()
    ) < 1 ? [ft, Tt] : [ot, It], ce = ke, bt;
  }, J.toNumber = function() {
    return +Ct(this);
  }, J.toPrecision = function(Et, St) {
    return Et != null && intCheck(Et, 1, MAX), yt(this, Et, St, 2);
  }, J.toString = function(Et) {
    var St, It = this, Tt = It.s, nt = It.e;
    return nt === null ? Tt ? (St = "Infinity", Tt < 0 && (St = "-" + St)) : St = "NaN" : (Et == null ? St = nt <= oe || nt >= pe ? toExponential(coeffToString(It.c), nt) : toFixedPoint(coeffToString(It.c), nt, "0") : Et === 10 && pt ? (It = xt(new ht(It), re + nt + 1, ie), St = toFixedPoint(coeffToString(It.c), It.e, "0")) : (intCheck(Et, 2, lt.length, "Base"), St = W(toFixedPoint(coeffToString(It.c), nt, "0"), 10, Et, Tt, !0)), Tt < 0 && It.c[0] && (St = "-" + St)), St;
  }, J.valueOf = J.toJSON = function() {
    return Ct(this);
  }, J._isBigNumber = !0, J[Symbol.toStringTag] = "BigNumber", J[Symbol.for("nodejs.util.inspect.custom")] = J.valueOf, B != null && ht.set(B), ht;
}
function bitFloor(B) {
  var L = B | 0;
  return B > 0 || B === L ? L : L - 1;
}
function coeffToString(B) {
  for (var L, W, K = 1, J = B.length, V = B[0] + ""; K < J; ) {
    for (L = B[K++] + "", W = LOG_BASE - L.length; W--; L = "0" + L) ;
    V += L;
  }
  for (J = V.length; V.charCodeAt(--J) === 48; ) ;
  return V.slice(0, J + 1 || 1);
}
function compare(B, L) {
  var W, K, J = B.c, V = L.c, re = B.s, ie = L.s, oe = B.e, pe = L.e;
  if (!re || !ie) return null;
  if (W = J && !J[0], K = V && !V[0], W || K) return W ? K ? 0 : -ie : re;
  if (re != ie) return re;
  if (W = re < 0, K = oe == pe, !J || !V) return K ? 0 : !J ^ W ? 1 : -1;
  if (!K) return oe > pe ^ W ? 1 : -1;
  for (ie = (oe = J.length) < (pe = V.length) ? oe : pe, re = 0; re < ie; re++) if (J[re] != V[re]) return J[re] > V[re] ^ W ? 1 : -1;
  return oe == pe ? 0 : oe > pe ^ W ? 1 : -1;
}
function intCheck(B, L, W, K) {
  if (B < L || B > W || B !== mathfloor(B))
    throw Error(bignumberError + (K || "Argument") + (typeof B == "number" ? B < L || B > W ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var L = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == L && B.c[L] % 2 != 0;
}
function toExponential(B, L) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (L < 0 ? "e" : "e+") + L;
}
function toFixedPoint(B, L, W) {
  var K, J;
  if (L < 0) {
    for (J = W + "."; ++L; J += W) ;
    B = J + B;
  } else if (K = B.length, ++L > K) {
    for (J = W, L -= K; --L; J += W) ;
    B += J;
  } else L < K && (B = B.slice(0, L) + "." + B.slice(L));
  return B;
}
var BigNumber = clone();
class BaseDatasource {
  constructor({ network: L }) {
    Cr(this, "network");
    this.network = L;
  }
}
class DatasourceUtility {
  /**
   * Parses an inscription.
   *
   * @param inscription Inscription
   * @param options Options
   * - `decodeMetadata` decodes the metadata object into [valid URI components](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent).
   * @returns Parsed inscription
   */
  static parseInscription(L, { decodeMetadata: W }) {
    return {
      ...L,
      meta: W && L.meta ? UNSTABLE_decodeObject(L.meta) : L.meta
    };
  }
  /**
   * Parses inscriptions.
   *
   * @param inscriptions Inscriptions
   * @param options Options
   * - `decodeMetadata` decodes the metadata object into [valid URI components](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent).
   * @returns Parsed inscriptions
   */
  static parseInscriptions(L, { decodeMetadata: W }) {
    return L.map(
      (K) => this.parseInscription(K, { decodeMetadata: W })
    );
  }
  static segregateUTXOsBySpendStatus({
    utxos: L
  }) {
    const { spendableUTXOs: W, unspendableUTXOs: K } = L.reduce(
      (J, V) => (V.safeToSpend ? J.spendableUTXOs.push(V) : J.unspendableUTXOs.push(V), J),
      {
        spendableUTXOs: [],
        unspendableUTXOs: []
      }
    );
    return {
      totalUTXOs: L.length,
      spendableUTXOs: W,
      unspendableUTXOs: K
    };
  }
}
var browserPonyfill = { exports: {} };
(function(B, L) {
  var W = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof commonjsGlobal < "u" && commonjsGlobal, K = function() {
    function V() {
      this.fetch = !1, this.DOMException = W.DOMException;
    }
    return V.prototype = W, new V();
  }();
  (function(V) {
    (function(re) {
      var ie = typeof V < "u" && V || typeof self < "u" && self || typeof ie < "u" && ie, oe = {
        searchParams: "URLSearchParams" in ie,
        iterable: "Symbol" in ie && "iterator" in Symbol,
        blob: "FileReader" in ie && "Blob" in ie && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in ie,
        arrayBuffer: "ArrayBuffer" in ie
      };
      function pe(rt) {
        return rt && DataView.prototype.isPrototypeOf(rt);
      }
      if (oe.arrayBuffer)
        var ne = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], ce = ArrayBuffer.isView || function(rt) {
          return rt && ne.indexOf(Object.prototype.toString.call(rt)) > -1;
        };
      function Ce(rt) {
        if (typeof rt != "string" && (rt = String(rt)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(rt) || rt === "")
          throw new TypeError('Invalid character in header field name: "' + rt + '"');
        return rt.toLowerCase();
      }
      function Oe(rt) {
        return typeof rt != "string" && (rt = String(rt)), rt;
      }
      function st(rt) {
        var ot = {
          next: function() {
            var ft = rt.shift();
            return { done: ft === void 0, value: ft };
          }
        };
        return oe.iterable && (ot[Symbol.iterator] = function() {
          return ot;
        }), ot;
      }
      function at(rt) {
        this.map = {}, rt instanceof at ? rt.forEach(function(ot, ft) {
          this.append(ft, ot);
        }, this) : Array.isArray(rt) ? rt.forEach(function(ot) {
          this.append(ot[0], ot[1]);
        }, this) : rt && Object.getOwnPropertyNames(rt).forEach(function(ot) {
          this.append(ot, rt[ot]);
        }, this);
      }
      at.prototype.append = function(rt, ot) {
        rt = Ce(rt), ot = Oe(ot);
        var ft = this.map[rt];
        this.map[rt] = ft ? ft + ", " + ot : ot;
      }, at.prototype.delete = function(rt) {
        delete this.map[Ce(rt)];
      }, at.prototype.get = function(rt) {
        return rt = Ce(rt), this.has(rt) ? this.map[rt] : null;
      }, at.prototype.has = function(rt) {
        return this.map.hasOwnProperty(Ce(rt));
      }, at.prototype.set = function(rt, ot) {
        this.map[Ce(rt)] = Oe(ot);
      }, at.prototype.forEach = function(rt, ot) {
        for (var ft in this.map)
          this.map.hasOwnProperty(ft) && rt.call(ot, this.map[ft], ft, this);
      }, at.prototype.keys = function() {
        var rt = [];
        return this.forEach(function(ot, ft) {
          rt.push(ft);
        }), st(rt);
      }, at.prototype.values = function() {
        var rt = [];
        return this.forEach(function(ot) {
          rt.push(ot);
        }), st(rt);
      }, at.prototype.entries = function() {
        var rt = [];
        return this.forEach(function(ot, ft) {
          rt.push([ft, ot]);
        }), st(rt);
      }, oe.iterable && (at.prototype[Symbol.iterator] = at.prototype.entries);
      function lt(rt) {
        if (rt.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        rt.bodyUsed = !0;
      }
      function pt(rt) {
        return new Promise(function(ot, ft) {
          rt.onload = function() {
            ot(rt.result);
          }, rt.onerror = function() {
            ft(rt.error);
          };
        });
      }
      function ht(rt) {
        var ot = new FileReader(), ft = pt(ot);
        return ot.readAsArrayBuffer(rt), ft;
      }
      function yt(rt) {
        var ot = new FileReader(), ft = pt(ot);
        return ot.readAsText(rt), ft;
      }
      function vt(rt) {
        for (var ot = new Uint8Array(rt), ft = new Array(ot.length), ct = 0; ct < ot.length; ct++)
          ft[ct] = String.fromCharCode(ot[ct]);
        return ft.join("");
      }
      function $t(rt) {
        if (rt.slice)
          return rt.slice(0);
        var ot = new Uint8Array(rt.byteLength);
        return ot.set(new Uint8Array(rt)), ot.buffer;
      }
      function xt() {
        return this.bodyUsed = !1, this._initBody = function(rt) {
          this.bodyUsed = this.bodyUsed, this._bodyInit = rt, rt ? typeof rt == "string" ? this._bodyText = rt : oe.blob && Blob.prototype.isPrototypeOf(rt) ? this._bodyBlob = rt : oe.formData && FormData.prototype.isPrototypeOf(rt) ? this._bodyFormData = rt : oe.searchParams && URLSearchParams.prototype.isPrototypeOf(rt) ? this._bodyText = rt.toString() : oe.arrayBuffer && oe.blob && pe(rt) ? (this._bodyArrayBuffer = $t(rt.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : oe.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(rt) || ce(rt)) ? this._bodyArrayBuffer = $t(rt) : this._bodyText = rt = Object.prototype.toString.call(rt) : this._bodyText = "", this.headers.get("content-type") || (typeof rt == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : oe.searchParams && URLSearchParams.prototype.isPrototypeOf(rt) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, oe.blob && (this.blob = function() {
          var rt = lt(this);
          if (rt)
            return rt;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var rt = lt(this);
            return rt || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            ) : Promise.resolve(this._bodyArrayBuffer));
          } else
            return this.blob().then(ht);
        }), this.text = function() {
          var rt = lt(this);
          if (rt)
            return rt;
          if (this._bodyBlob)
            return yt(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(vt(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, oe.formData && (this.formData = function() {
          return this.text().then(It);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var Ct = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function Et(rt) {
        var ot = rt.toUpperCase();
        return Ct.indexOf(ot) > -1 ? ot : rt;
      }
      function St(rt, ot) {
        if (!(this instanceof St))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        ot = ot || {};
        var ft = ot.body;
        if (rt instanceof St) {
          if (rt.bodyUsed)
            throw new TypeError("Already read");
          this.url = rt.url, this.credentials = rt.credentials, ot.headers || (this.headers = new at(rt.headers)), this.method = rt.method, this.mode = rt.mode, this.signal = rt.signal, !ft && rt._bodyInit != null && (ft = rt._bodyInit, rt.bodyUsed = !0);
        } else
          this.url = String(rt);
        if (this.credentials = ot.credentials || this.credentials || "same-origin", (ot.headers || !this.headers) && (this.headers = new at(ot.headers)), this.method = Et(ot.method || this.method || "GET"), this.mode = ot.mode || this.mode || null, this.signal = ot.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ft)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(ft), (this.method === "GET" || this.method === "HEAD") && (ot.cache === "no-store" || ot.cache === "no-cache")) {
          var ct = /([?&])_=[^&]*/;
          if (ct.test(this.url))
            this.url = this.url.replace(ct, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
          else {
            var bt = /\?/;
            this.url += (bt.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
          }
        }
      }
      St.prototype.clone = function() {
        return new St(this, { body: this._bodyInit });
      };
      function It(rt) {
        var ot = new FormData();
        return rt.trim().split("&").forEach(function(ft) {
          if (ft) {
            var ct = ft.split("="), bt = ct.shift().replace(/\+/g, " "), ut = ct.join("=").replace(/\+/g, " ");
            ot.append(decodeURIComponent(bt), decodeURIComponent(ut));
          }
        }), ot;
      }
      function Tt(rt) {
        var ot = new at(), ft = rt.replace(/\r?\n[\t ]+/g, " ");
        return ft.split("\r").map(function(ct) {
          return ct.indexOf(`
`) === 0 ? ct.substr(1, ct.length) : ct;
        }).forEach(function(ct) {
          var bt = ct.split(":"), ut = bt.shift().trim();
          if (ut) {
            var gt = bt.join(":").trim();
            ot.append(ut, gt);
          }
        }), ot;
      }
      xt.call(St.prototype);
      function nt(rt, ot) {
        if (!(this instanceof nt))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        ot || (ot = {}), this.type = "default", this.status = ot.status === void 0 ? 200 : ot.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = ot.statusText === void 0 ? "" : "" + ot.statusText, this.headers = new at(ot.headers), this.url = ot.url || "", this._initBody(rt);
      }
      xt.call(nt.prototype), nt.prototype.clone = function() {
        return new nt(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new at(this.headers),
          url: this.url
        });
      }, nt.error = function() {
        var rt = new nt(null, { status: 0, statusText: "" });
        return rt.type = "error", rt;
      };
      var it = [301, 302, 303, 307, 308];
      nt.redirect = function(rt, ot) {
        if (it.indexOf(ot) === -1)
          throw new RangeError("Invalid status code");
        return new nt(null, { status: ot, headers: { location: rt } });
      }, re.DOMException = ie.DOMException;
      try {
        new re.DOMException();
      } catch {
        re.DOMException = function(ot, ft) {
          this.message = ot, this.name = ft;
          var ct = Error(ot);
          this.stack = ct.stack;
        }, re.DOMException.prototype = Object.create(Error.prototype), re.DOMException.prototype.constructor = re.DOMException;
      }
      function ke(rt, ot) {
        return new Promise(function(ft, ct) {
          var bt = new St(rt, ot);
          if (bt.signal && bt.signal.aborted)
            return ct(new re.DOMException("Aborted", "AbortError"));
          var ut = new XMLHttpRequest();
          function gt() {
            ut.abort();
          }
          ut.onload = function() {
            var wt = {
              status: ut.status,
              statusText: ut.statusText,
              headers: Tt(ut.getAllResponseHeaders() || "")
            };
            wt.url = "responseURL" in ut ? ut.responseURL : wt.headers.get("X-Request-URL");
            var Ft = "response" in ut ? ut.response : ut.responseText;
            setTimeout(function() {
              ft(new nt(Ft, wt));
            }, 0);
          }, ut.onerror = function() {
            setTimeout(function() {
              ct(new TypeError("Network request failed"));
            }, 0);
          }, ut.ontimeout = function() {
            setTimeout(function() {
              ct(new TypeError("Network request failed"));
            }, 0);
          }, ut.onabort = function() {
            setTimeout(function() {
              ct(new re.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function dt(wt) {
            try {
              return wt === "" && ie.location.href ? ie.location.href : wt;
            } catch {
              return wt;
            }
          }
          ut.open(bt.method, dt(bt.url), !0), bt.credentials === "include" ? ut.withCredentials = !0 : bt.credentials === "omit" && (ut.withCredentials = !1), "responseType" in ut && (oe.blob ? ut.responseType = "blob" : oe.arrayBuffer && bt.headers.get("Content-Type") && bt.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (ut.responseType = "arraybuffer")), ot && typeof ot.headers == "object" && !(ot.headers instanceof at) ? Object.getOwnPropertyNames(ot.headers).forEach(function(wt) {
            ut.setRequestHeader(wt, Oe(ot.headers[wt]));
          }) : bt.headers.forEach(function(wt, Ft) {
            ut.setRequestHeader(Ft, wt);
          }), bt.signal && (bt.signal.addEventListener("abort", gt), ut.onreadystatechange = function() {
            ut.readyState === 4 && bt.signal.removeEventListener("abort", gt);
          }), ut.send(typeof bt._bodyInit > "u" ? null : bt._bodyInit);
        });
      }
      return ke.polyfill = !0, ie.fetch || (ie.fetch = ke, ie.Headers = at, ie.Request = St, ie.Response = nt), re.Headers = at, re.Request = St, re.Response = nt, re.fetch = ke, re;
    })({});
  })(K), K.fetch.ponyfill = !0, delete K.fetch.polyfill;
  var J = W.fetch ? W : K;
  L = J.fetch, L.default = J.fetch, L.fetch = J.fetch, L.Headers = J.Headers, L.Request = J.Request, L.Response = J.Response, B.exports = L;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const fetch = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports), API_CONFIG = {
  version: "0.0.0.10",
  apis: {
    mainnet: {
      batter: "https://mainnet.ordit.io/"
    },
    regtest: {
      batter: "https://regtest.ordit.io/"
    },
    testnet: {
      batter: "https://testnet.ordit.io/"
    },
    signet: {
      batter: "https://signet.ordit.io/"
    }
  }
};
function isNumber(B) {
  return typeof B == "number" && B > Number.NEGATIVE_INFINITY && B < Number.POSITIVE_INFINITY;
}
function isInteger(B) {
  return isNumber(B) && B % 1 === 0;
}
function isString(B) {
  return typeof B == "string";
}
function isJsonRpcId(B) {
  return isString(B) || isInteger(B) || B === null;
}
function getRpcUrl(B) {
  return B[B.length - 1] === "/" ? B.substring(0, B.length - 1) : B;
}
class JsonRpc {
  constructor(L) {
    this.url = L;
  }
  /**
   * Send a JSON-RPC 2.0 notification to the connected Sado compliant server.
   *
   * @param method - Method to call.
   * @param params - JSON-RPC 2.0 parameters.
   */
  async notify(L, W) {
    await fetch(`${this.url}/rpc`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: L,
        params: W
      })
    });
  }
  async call(L, W, K) {
    let J = {}, V = K;
    isJsonRpcId(W) ? V = W : J = W;
    const re = await fetch(`${this.url}/rpc`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: L,
        params: J,
        id: V
      })
    });
    if (re.status === 200) {
      const ie = await re.json();
      if (ie.error) {
        const oe = typeof ie.error.data == "string" ? ie.error.data : ie.error.message;
        throw new OrditSDKError(oe);
      }
      return ie.result;
    }
    throw new OrditSDKError("Internal Server Error");
  }
}
const rpc = {
  get id() {
    return Math.floor(Math.random() * 1e5);
  },
  mainnet: new JsonRpc(getRpcUrl(API_CONFIG.apis.mainnet.batter)),
  testnet: new JsonRpc(getRpcUrl(API_CONFIG.apis.testnet.batter)),
  signet: new JsonRpc(getRpcUrl(API_CONFIG.apis.signet.batter)),
  regtest: new JsonRpc(getRpcUrl(API_CONFIG.apis.regtest.batter))
};
class JsonRpcDatasource extends BaseDatasource {
  constructor({ network: L }) {
    super({ network: L });
  }
  async getBalance({ address: L }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    return rpc[this.network].call(
      "Address.GetBalance",
      { address: L },
      rpc.id
    );
  }
  async getInscription({
    id: L,
    decodeMetadata: W = !1
  }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    const K = outpointToIdFormat(L), J = await rpc[this.network].call(
      "Ordinals.GetInscription",
      { id: K },
      rpc.id
    );
    return DatasourceUtility.parseInscription(J, { decodeMetadata: W });
  }
  async getInscriptionUTXO({ id: L }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    const W = outpointToIdFormat(L);
    return rpc[this.network].call(
      "Ordinals.GetInscriptionUtxo",
      { id: W },
      rpc.id
    );
  }
  async getInscriptions({
    creator: L,
    owner: W,
    mimeType: K,
    mimeSubType: J,
    outpoint: V,
    decodeMetadata: re = !1,
    sort: ie = "asc",
    limit: oe = 25,
    next: pe = null
  }) {
    let ne = [], ce = pe;
    do {
      const { inscriptions: Ce, pagination: Oe } = await rpc[this.network].call(
        "Ordinals.GetInscriptions",
        {
          filter: { creator: L, owner: W, mimeType: K, mimeSubType: J, outpoint: V },
          sort: { number: ie },
          pagination: { limit: oe, next: ce }
        },
        rpc.id
      );
      ne = ne.concat(Ce), ce = Oe.next;
    } while (ce !== null);
    return DatasourceUtility.parseInscriptions(ne, {
      decodeMetadata: re
    });
  }
  async getSpendables({
    address: L,
    value: W,
    rarity: K = ["common"],
    filter: J = [],
    limit: V = 200,
    type: re = "spendable"
  }) {
    if (!L || Number.isNaN(W) || !W)
      throw new OrditSDKError("Invalid request");
    return rpc[this.network].call(
      "Address.GetSpendables",
      {
        address: L,
        value: W,
        safetospend: re === "spendable",
        allowedrarity: K,
        filter: J,
        limit: V
      },
      rpc.id
    );
  }
  async getTransaction({
    txId: L,
    ordinals: W = !0,
    hex: K = !1,
    witness: J = !0,
    decodeMetadata: V = !0
  }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    const re = await rpc[this.network].call(
      "Transactions.GetTransaction",
      {
        txid: L,
        options: {
          ord: W,
          hex: K,
          witness: J
        }
      },
      rpc.id
    );
    return re.vout = re.vout.map((ie) => ({
      ...ie,
      inscriptions: DatasourceUtility.parseInscriptions(ie.inscriptions, {
        decodeMetadata: V
      })
    })), {
      tx: re,
      rawTx: K && re.hex ? src$4.Transaction.fromHex(re.hex) : void 0
    };
  }
  async getUnspents({
    address: L,
    type: W = "spendable",
    rarity: K = ["common"],
    sort: J = "desc",
    limit: V = 50,
    next: re = null
  }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    let ie = [], oe = re;
    do {
      const { unspents: pe, pagination: ne } = await rpc[this.network].call(
        "Address.GetUnspents",
        {
          address: L,
          options: {
            allowedrarity: K,
            safetospend: W === "spendable"
          },
          pagination: {
            limit: V,
            next: oe
          },
          sort: { value: J }
        },
        rpc.id
      );
      ie = ie.concat(pe), oe = ne.next;
    } while (oe !== null);
    return DatasourceUtility.segregateUTXOsBySpendStatus({ utxos: ie });
  }
  async relay({ hex: L, maxFeeRate: W, validate: K = !0 }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    if (W && (W < 0 || Number.isNaN(W)))
      throw new OrditSDKError("Invalid max fee rate");
    return rpc[this.network].call(
      "Transactions.Relay",
      { hex: L, maxFeeRate: W, validate: K },
      rpc.id
    );
  }
}
function useBalance() {
  const { network: B, publicKey: L, format: W } = useWallie(), [K, J] = useState(null), [V, re] = useState(!1);
  return { getBalance: useCallback(async () => {
    re(!0);
    try {
      if (J(null), !W || !W.payments || !L || !L.payments)
        throw new Error("No wallet is connected");
      const { address: oe } = getAddressesFromPublicKey(
        L.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[W.payments]
      )[0], ne = await new JsonRpcDatasource({ network: B }).getBalance({ address: oe }), ce = Number(
        new BigNumber(ne).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return re(!1), ce;
    } catch (oe) {
      throw J(oe.message), re(!1), oe;
    }
  }, [W, B, L]), error: K, loading: V };
}
function isInstalled() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof window.okxwallet < "u";
}
function getOKXWalletProvider(B = "mainnet") {
  if (!isInstalled())
    throw new BrowserWalletNotInstalledError("OKX Wallet not installed");
  let L;
  switch (B) {
    case "mainnet":
      L = window.okxwallet.bitcoin;
      break;
    case "testnet":
      L = window.okxwallet.bitcoinTestnet;
      break;
    case "signet":
      L = window.okxwallet.bitcoinSignet;
      break;
    default:
      throw new OrditSDKError("Invalid network");
  }
  if (!L)
    throw new OrditSDKError("Failed to get OKX Wallet provider");
  return L;
}
async function signPsbt$1(B, {
  finalize: L = !0,
  extractTx: W = !0,
  network: K,
  inputsToSign: J
} = { network: "mainnet", inputsToSign: [] }) {
  if (!isInstalled())
    throw new BrowserWalletNotInstalledError("OKX Wallet not installed");
  if (W && !L)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  const V = getOKXWalletProvider(K), re = B.toHex();
  let ie = "";
  const oe = [];
  J.forEach((ne) => {
    const { address: ce, signingIndexes: Ce, sigHash: Oe } = ne;
    Ce.forEach((st) => {
      oe.push({
        index: st,
        address: ce,
        sighashTypes: Oe ? [Oe] : void 0
      });
    });
  });
  try {
    ie = await V.signPsbt(re, {
      autoFinalized: L,
      toSignInputs: oe
    });
  } catch (ne) {
    const ce = ne;
    throw ce.code === 4001 ? new BrowserWalletRequestCancelledByUserError() : new OrditSDKError(ce.message);
  }
  if (!ie)
    throw new BrowserWalletSigningError(
      "Failed to sign psbt hex using OKX Wallet"
    );
  const pe = src$4.Psbt.fromHex(ie);
  if (W)
    try {
      return {
        base64: null,
        hex: pe.extractTransaction().toHex()
      };
    } catch (ne) {
      throw ne instanceof Error && ne.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
    }
  else
    return {
      base64: pe.toBase64(),
      hex: pe.toHex()
    };
}
async function signMessage$1(B, L = "ecdsa", W = "mainnet") {
  if (!isInstalled())
    throw new BrowserWalletNotInstalledError("OKX Wallet not installed");
  const K = getOKXWalletProvider(W);
  let J = "";
  try {
    J = await K.signMessage(B, L);
  } catch (V) {
    const re = V;
    throw re.code === 4001 ? new BrowserWalletRequestCancelledByUserError() : new OrditSDKError(re.message);
  }
  if (!J)
    throw new BrowserWalletSigningError(
      "Failed to sign message using OKX Wallet"
    );
  return {
    base64: J,
    hex: Buffer$2.from(J, "base64").toString("hex")
  };
}
async function signPsbt({
  address: B,
  wallet: L,
  network: W,
  psbt: K,
  options: J
}) {
  var oe, pe;
  if ((oe = J == null ? void 0 : J.signingIndexes) != null && oe.length && ((pe = J == null ? void 0 : J.inputsToSign) != null && pe.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const V = (J == null ? void 0 : J.finalize) ?? !0, re = (J == null ? void 0 : J.extractTx) ?? !0, ie = () => K.data.inputs.map((ne, ce) => ce);
  if (L === Wallet.MAGICEDEN)
    return await signPsbt$4(K, {
      network: W,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: V,
      extractTx: re
    });
  if (L === Wallet.UNISAT)
    return await signPsbt$3(K, {
      finalize: V,
      extractTx: re
    });
  if (L === Wallet.XVERSE)
    return await signPsbt$2(K, {
      network: W,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: V,
      extractTx: re
    });
  if (L === Wallet.LEATHER)
    return await signPsbt$5(K, {
      network: W,
      finalize: V,
      extractTx: re,
      allowedSighash: J != null && J.sigHash ? [J == null ? void 0 : J.sigHash] : [],
      signAtIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie()
      // If signingIndexes is not provided, just sign everything
    });
  if (L === Wallet.OKX)
    return await signPsbt$1(K, {
      finalize: V,
      extractTx: re,
      network: W,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
var bufferReverse = function B(L) {
  for (var W = new Buffer$2(L.length), K = 0, J = L.length - 1; K <= J; ++K, --J)
    W[K] = L[J], W[J] = L[K];
  return W;
};
const reverseBuffer = /* @__PURE__ */ getDefaultExportFromCjs(bufferReverse), TRANSACTION_HEADER_SIZE = 10.5;
function getBaseSizeByType(B) {
  switch (B) {
    case "taproot":
      return { input: 42, output: 43, witness: 66 };
    case "segwit":
      return { input: 41, output: 31, witness: 105 };
    case "p2sh-p2wpkh":
      return { input: 64, output: 32, witness: 105 };
    case "legacy":
      return { input: 148, output: 34, witness: 0 };
    default:
      throw new OrditSDKError("Invalid type");
  }
}
class FeeEstimator {
  constructor({ feeRate: L, network: W, psbt: K, witness: J }) {
    /**
     * Fee in satoshis
     */
    Cr(this, "fee", 0);
    /**
     * Fee rate in satoshis
     */
    Cr(this, "feeRate");
    Cr(this, "network");
    Cr(this, "psbt");
    Cr(this, "witness", []);
    Cr(this, "virtualSize", 0);
    Cr(this, "weight", 0);
    if (L < 0 || !Number.isSafeInteger(L))
      throw new OrditSDKError("Invalid feeRate");
    this.feeRate = L, this.network = W, this.witness = J || [], this.psbt = K || new src$4.Psbt({ network: getNetwork(this.network) });
  }
  get data() {
    return {
      fee: this.fee,
      virtualSize: this.virtualSize,
      weight: this.weight
    };
  }
  /**
   * Calculates network fee based on virtual size of transaction and fee rate.
   *
   * @returns Estimated network fee
   * @throws {OrditSDKError} Fee is above MAXIMUM_FEE (5,000,000 satoshis)
   */
  calculateNetworkFee() {
    if (this.fee = this.calculateVirtualSize() * this.feeRate, this.fee > MAXIMUM_FEE)
      throw new OrditSDKError("Error while calculating fees");
    return this.fee;
  }
  getInputAndOutputScriptTypes() {
    const { inputs: L } = this.psbt.data, W = this.psbt.txOutputs;
    if (L.length === 0)
      throw new OrditSDKError("PSBT must have at least one input");
    if (W.length === 0)
      throw new OrditSDKError("PSBT must have at least one output");
    return {
      inputTypes: L.map((K) => {
        const J = K.witnessUtxo && K.witnessUtxo.script ? K.witnessUtxo.script : null;
        if (!J)
          throw new OrditSDKError("Invalid script");
        return getScriptType(J, this.network).format;
      }),
      outputTypes: W.map(
        (K) => getScriptType(K.script, this.network).format
      )
    };
  }
  calculateScriptWitnessSize() {
    var W;
    const { inputTypes: L } = this.getInputAndOutputScriptTypes();
    return L.includes("taproot") && ((W = this.witness) != null && W.length) ? this.witness.reduce((K, J) => K + J.byteLength, 0) : 0;
  }
  getBaseSize() {
    var oe, pe;
    const { inputTypes: L, outputTypes: W } = this.getInputAndOutputScriptTypes(), K = 2, J = L.reduce(
      (ne, ce) => {
        const { input: Ce, witness: Oe } = getBaseSizeByType(ce);
        return ne.input += Ce, ne.witness += Oe, ne;
      },
      {
        input: 0,
        witness: 0
      }
    ), V = W.reduce((ne, ce) => {
      const { output: Ce } = getBaseSizeByType(ce);
      return ne + Ce;
    }, 0), re = J.witness + ((oe = this.witness) != null && oe.length ? this.calculateScriptWitnessSize() : 0);
    let ie = 0;
    return (pe = this.witness) != null && pe.length ? ie = re : re > 0 && (ie = K + re), {
      baseSize: J.input + TRANSACTION_HEADER_SIZE + V,
      witnessSize: ie
    };
  }
  calculateVirtualSize() {
    const { baseSize: L, witnessSize: W } = this.getBaseSize();
    return this.weight = L * 3 + (L + W), this.virtualSize = Math.ceil(this.weight / 4), this.virtualSize;
  }
}
function generateTaprootInput({
  utxo: B,
  pubKey: L,
  network: W,
  sighashType: K,
  witness: J
}) {
  const V = BIP32.fromPublicKey(
    Buffer$2.from(L, "hex"),
    CHAIN_CODE,
    getNetwork(W)
  ), re = toXOnly(V.publicKey);
  if (!B.scriptPubKey.hex)
    throw new Error("Unable to process p2tr input");
  return {
    type: "taproot",
    hash: B.txid,
    index: B.n,
    tapInternalKey: re,
    witnessUtxo: {
      script: Buffer$2.from(B.scriptPubKey.hex, "hex"),
      value: B.sats
    },
    witness: J,
    ...K ? { sighashType: K } : void 0
  };
}
function generateSegwitInput({
  utxo: B,
  sighashType: L
}) {
  if (!B.scriptPubKey.hex)
    throw new Error("Unable to process Segwit input");
  return {
    type: "segwit",
    hash: B.txid,
    index: B.n,
    witnessUtxo: {
      script: Buffer$2.from(B.scriptPubKey.hex, "hex"),
      value: B.sats
    },
    ...L ? { sighashType: L } : void 0
  };
}
function generateP2SHP2WPKHInput({
  utxo: B,
  pubKey: L,
  network: W,
  sighashType: K
}) {
  const J = createPayment(Buffer$2.from(L, "hex"), "p2sh", W);
  if (!J || !J.output || !J.redeem)
    throw new Error("Unable to process P2SH input");
  return {
    type: "p2sh-p2wpkh",
    hash: B.txid,
    index: B.n,
    redeemScript: J.redeem.output,
    witnessUtxo: {
      script: Buffer$2.from(B.scriptPubKey.hex, "hex"),
      value: B.sats
    },
    ...K ? { sighashType: K } : void 0
  };
}
async function generateLegacyInput({
  utxo: B,
  sighashType: L,
  network: W,
  pubKey: K,
  datasource: J
}) {
  const { rawTx: V } = await J.getTransaction({
    txId: B.txid,
    hex: !0
  });
  if (!V)
    throw new Error("Unable to process legacy input");
  const re = createPayment(Buffer$2.from(K, "hex"), "p2pkh", W);
  return {
    type: "legacy",
    hash: B.txid,
    index: B.n,
    nonWitnessUtxo: V == null ? void 0 : V.toBuffer(),
    witnessUtxo: {
      script: re.output,
      value: B.sats
    },
    ...L ? { sighashType: L } : void 0
  };
}
async function processInput({
  utxo: B,
  pubKey: L,
  network: W,
  sighashType: K,
  witness: J,
  datasource: V
}) {
  const re = V || new JsonRpcDatasource({ network: W });
  switch (B.scriptPubKey.type) {
    case "witness_v1_taproot":
      return generateTaprootInput({
        utxo: B,
        pubKey: L,
        network: W,
        sighashType: K,
        witness: J
      });
    case "witness_v0_scripthash":
    case "witness_v0_keyhash":
      return generateSegwitInput({ utxo: B, sighashType: K });
    case "scripthash":
      return generateP2SHP2WPKHInput({ utxo: B, pubKey: L, network: W, sighashType: K });
    case "pubkeyhash":
      return generateLegacyInput({
        utxo: B,
        sighashType: K,
        network: W,
        pubKey: L,
        datasource: re
      });
    default:
      throw new Error("invalid script pub type");
  }
}
class PSBTBuilder extends FeeEstimator {
  constructor({
    address: W,
    changeAddress: K,
    datasource: J,
    feeRate: V,
    network: re = "mainnet",
    publicKey: ie,
    outputs: oe,
    autoAdjustment: pe = !0,
    instantTradeMode: ne = !1
  }) {
    super({
      feeRate: V,
      network: re
    });
    Cr(this, "address");
    Cr(this, "changeAddress");
    /**
     * Change amount in satoshis
     */
    Cr(this, "changeAmount", 0);
    Cr(this, "datasource");
    Cr(this, "injectableInputs", []);
    Cr(this, "injectableOutputs", []);
    /**
     * Input amount in satoshis
     */
    Cr(this, "inputAmount", 0);
    Cr(this, "inputs", []);
    /**
     * Output amount in satoshis
     */
    Cr(this, "outputAmount", 0);
    Cr(this, "outputs", []);
    Cr(this, "psbt");
    Cr(this, "publicKey");
    /**
     * Replace-by-fee (RBF) is a feature that allows users to replace one version of an unconfirmed transaction
     * with a different version of the transaction that pays a higher transaction fee.
     * This can be done multiple times while the transaction is unconfirmed.
     *
     * Reference: [BIP-125](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki)
     */
    Cr(this, "rbf", !0);
    Cr(this, "utxos", []);
    Cr(this, "usedUTXOs", []);
    /**
     * Enable auto adjustment.
     *
     * When `true`, change is calculated and UTXOs will be added as required to account for network fees.
     *
     * Otherwise, change is not calculated and no UTXOs will be added.
     */
    Cr(this, "autoAdjustment");
    Cr(this, "instantTradeMode");
    Cr(this, "noMoreUTXOS", !1);
    this.address = W, this.changeAddress = K, this.datasource = J || new JsonRpcDatasource({ network: this.network }), this.outputs = oe, this.publicKey = ie, this.autoAdjustment = pe, this.instantTradeMode = ne, this.psbt = new src$4.Psbt({ network: getNetwork(re) });
  }
  get data() {
    return {
      fee: this.fee,
      virtualSize: this.virtualSize,
      weight: this.weight,
      changeAmount: this.changeAmount,
      inputAmount: this.inputAmount,
      outputAmount: this.outputAmount
    };
  }
  toPSBT() {
    return this.psbt;
  }
  toHex() {
    return this.psbt.toHex();
  }
  toBase64() {
    return this.psbt.toBase64();
  }
  /**
   * Set Replace-by-fee (RBF) value
   *
   * Replace-by-fee (RBF) is a feature that allows users to replace one version of an unconfirmed transaction
   * with a different version of the transaction that pays a higher transaction fee.
   * This can be done multiple times while the transaction is unconfirmed.
   *
   * Reference: [BIP-125](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki)
   */
  setRBF(W) {
    this.rbf = W, this.addInputs();
  }
  /**
   * Gets the x-coordinate of the public key.
   */
  get xKey() {
    return toXOnly(Buffer$2.from(this.publicKey, "hex")).toString("hex");
  }
  get inputsToSign() {
    const W = this.instantTradeMode && !this.autoAdjustment;
    return this.psbt.txInputs.reduce(
      (K, J, V) => ((!this.instantTradeMode || this.instantTradeMode && V !== INSTANT_BUY_SELLER_INPUT_INDEX) && (K.signingIndexes = K.signingIndexes.concat(V)), W && (K.sigHash = // eslint-disable-next-line no-bitwise
      src$4.Transaction.SIGHASH_SINGLE | src$4.Transaction.SIGHASH_ANYONECANPAY), K),
      {
        address: this.address,
        signingIndexes: []
      }
    );
  }
  initPSBT() {
    this.psbt = new src$4.Psbt({ network: getNetwork(this.network) }), this.psbt.setMaximumFeeRate(this.feeRate);
  }
  getInputSequence() {
    return this.rbf ? 4294967293 : 4294967295;
  }
  injectInput(W) {
    this.psbt.data.globalMap.unsignedTx.tx.ins[W.injectionIndex] = W.txInput, this.psbt.data.inputs[W.injectionIndex] = W.standardInput;
  }
  injectOutput(W) {
    let K = W.injectionIndex;
    do {
      if (!!!this.psbt.data.globalMap.unsignedTx.tx.outs[K]) {
        this.psbt.data.globalMap.unsignedTx.tx.outs[K] = W.txOutput, this.psbt.data.outputs[K] = // TODO: remove hack
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        W.standardOutput;
        break;
      }
      K += 1;
    } while (K);
  }
  addInputs() {
    const W = this.injectableInputs.map(
      (J) => J.injectionIndex
    ), K = [];
    this.inputs.forEach((J, V) => {
      const re = W.includes(V);
      if (re) {
        const oe = this.injectableInputs.find(
          (pe) => pe.injectionIndex === V
        );
        this.injectInput(oe), K.push(oe.injectionIndex);
      }
      this.psbt.txInputs.map((oe) => {
        const pe = reverseBuffer(oe.hash);
        return generateTxUniqueIdentifier(pe.toString("hex"), oe.index);
      }).includes(
        generateTxUniqueIdentifier(J.hash, J.index)
      ) || (this.psbt.addInput(J), this.psbt.setInputSequence(
        re ? V + 1 : V,
        this.getInputSequence()
      ));
    }), this.injectableInputs.forEach((J) => {
      K.includes(J.injectionIndex) || (this.injectInput(J), K.push(J.injectionIndex));
    });
  }
  addOutputs() {
    const W = this.injectableOutputs.map((J) => J.injectionIndex), K = [];
    this.outputs.forEach((J, V) => {
      if (W.includes(V)) {
        const re = this.injectableOutputs.find(
          (ie) => ie.injectionIndex === V
        );
        this.injectOutput(re), K.push(re.injectionIndex);
      }
      this.psbt.addOutput({
        address: J.address,
        value: J.value
      });
    }), this.injectableOutputs.forEach((J) => {
      K.includes(J.injectionIndex) || (this.injectOutput(J), K.push(J.injectionIndex));
    }), this.changeAmount >= MINIMUM_AMOUNT_IN_SATS && this.psbt.addOutput({
      address: this.changeAddress || this.address,
      value: this.changeAmount
    });
  }
  calculateOutputAmount() {
    if (this.outputAmount = Math.floor(
      this.outputs.reduce((W, K) => W + K.value, 0) + this.injectableOutputs.reduce((W, K) => W + K.sats, 0)
    ), this.outputAmount < MINIMUM_AMOUNT_IN_SATS)
      throw new Error(
        `Output amount too low. Minimum output amount needs to be ${MINIMUM_AMOUNT_IN_SATS} sats`
      );
  }
  /**
   * Calculates change amount from transaction and fetches additional UTXOs as required to cover output and network fees, if change is negative.
   */
  async recursivelyCalculateChangeAmount() {
    if (this.autoAdjustment && (this.changeAmount = Math.floor(
      this.inputAmount - this.outputAmount - this.fee
    ), this.changeAmount < 0 && (await this.prepare(), this.noMoreUTXOS)))
      throw new Error(
        `Insufficient balance. Decrease the output amount by ${this.changeAmount * -1} sats`
      );
  }
  getRetrievedUTXOsValue() {
    return this.utxos.reduce((W, K) => W + K.sats, 0);
  }
  getReservedUTXOs() {
    return this.utxos.map(
      (W) => generateTxUniqueIdentifier(W.txid, W.n)
    );
  }
  getUTXOAmountToRequestFromChangeAmount() {
    return this.changeAmount < 0 ? Math.abs(this.changeAmount) : this.outputAmount - this.getRetrievedUTXOsValue();
  }
  /**
   * Retrieves UTXOs using `getSpendables` RPC.
   *
   * @param address Address
   * @param amount Amount in satoshis
   */
  async retrieveUTXOs(W, K) {
    if (!this.autoAdjustment && !W)
      return;
    const J = K && K > 0 ? K : this.getUTXOAmountToRequestFromChangeAmount();
    if (K && this.getRetrievedUTXOsValue() >= K || J <= 0)
      return;
    const V = await this.datasource.getSpendables({
      address: W || this.address,
      value: convertSatoshisToBTC(J),
      filter: this.getReservedUTXOs()
    });
    this.noMoreUTXOS = V.length === 0, this.utxos.push(...V);
  }
  async retrieveSelectedUTXOs(W, K) {
    await this.retrieveUTXOs(W, K);
    const J = this.utxos.find((V) => V.sats >= K);
    return this.utxos = J ? [J] : [], this.utxos;
  }
  /**
   * Prepares inputs from UTXOs.
   */
  async prepareInputs() {
    if (!this.autoAdjustment)
      return;
    const W = [];
    this.utxos.forEach((J) => {
      if (this.usedUTXOs.includes(generateTxUniqueIdentifier(J.txid, J.n)))
        return;
      this.inputAmount += J.sats;
      const V = processInput({
        utxo: J,
        pubKey: this.publicKey,
        network: this.network,
        datasource: this.datasource
      });
      W.push(V);
    });
    const K = await Promise.all(W);
    this.inputAmount += this.injectableInputs.reduce(
      (J, V) => J + V.sats,
      0
    ), K.forEach((J) => {
      const V = generateTxUniqueIdentifier(
        J.hash,
        J.index
      );
      this.usedUTXOs.includes(V) || this.usedUTXOs.push(V);
    }), this.inputs = this.inputs.concat(K);
  }
  /**
   * Prepares PSBT to be set to a network, calculating and validating both inputs and outputs.
   */
  async prepare() {
    this.calculateOutputAmount(), await this.retrieveUTXOs(), await this.prepareInputs(), await this.recursivelyCalculateChangeAmount(), this.process(), await this.recursivelyCalculateChangeAmount(), this.calculateOutputAmount(), this.process();
  }
  /**
   * Initializes PSBT instance, adding all inputs and outputs and calculates network fees.
   *
   * @returns PSBTBuilder instance
   */
  process() {
    return this.initPSBT(), this.addInputs(), this.addOutputs(), this.calculateNetworkFee(), this;
  }
}
function useSend() {
  const { wallet: B, network: L, address: W, publicKey: K } = useWallie(), [J, V] = useState(null), [re, ie] = useState(!1);
  return { send: useCallback(
    async (pe, ne, ce, Ce = !0) => {
      ie(!0);
      try {
        if (V(null), !W || !W.payments || !K || !K.payments || !B)
          throw new Error("No wallet is connected");
        const Oe = new PSBTBuilder({
          address: W.payments,
          feeRate: ce,
          network: L,
          publicKey: K.payments,
          outputs: [
            {
              address: pe,
              value: ne
            }
          ]
        });
        await Oe.prepare();
        const st = await signPsbt({
          address: W.payments,
          wallet: B,
          network: L,
          psbt: Oe.toPSBT()
        });
        if (Ce) {
          const lt = await new JsonRpcDatasource({ network: L }).relay({ hex: st.hex });
          return ie(!1), lt;
        }
        return ie(!1), st.hex;
      } catch (Oe) {
        return V(Oe.message), ie(!1), null;
      }
    },
    [W, L, K, B]
  ), error: J, loading: re };
}
async function leatherRequest(B, L) {
  if (typeof window < "u" && window.LeatherProvider)
    try {
      return (await window.LeatherProvider.request(
        B,
        L
      )).result;
    } catch (W) {
      const K = W, { message: J } = K.error;
      throw K.error.code === 4001 ? new Error(J) : new Error(`Leather error: ${J}`);
    }
  else
    throw new Error("LeatherProvider not found");
}
async function walletProvider() {
  const { get: B } = getWallets(), W = B().find(
    (K) => {
      var J, V;
      return K.name === "Magic Eden" && ((V = (J = K.features["sats-connect:"]) == null ? void 0 : J.provider) == null ? void 0 : V.isMagicEden) === !0;
    }
  );
  if (!W)
    throw new Error("Magic Eden wallet not found");
  return W.features["sats-connect:"].provider;
}
function useSendBtc() {
  const { wallet: B, network: L, address: W, publicKey: K } = useWallie(), [J, V] = useState(null), [re, ie] = useState(!1);
  return { send: useCallback(
    async (pe, ne) => {
      ie(!0);
      try {
        if (V(null), !W || !W.payments || !K || !K.payments || !B)
          throw new Error("No wallet is connected");
        if (B === "magiceden" || B === "xverse") {
          const ce = B === "magiceden" ? await walletProvider() : void 0;
          let Ce = null;
          return Ce = await new Promise((Oe, st) => {
            sendBtcTransaction({
              payload: {
                network: {
                  type: L === "mainnet" ? BitcoinNetworkType.Mainnet : BitcoinNetworkType.Testnet
                },
                message: "Sign Transaction",
                recipients: [
                  {
                    address: pe,
                    amountSats: BigInt(ne)
                  }
                ],
                senderAddress: W.payments
              },
              getProvider: async () => ce,
              onFinish: (at) => {
                Oe(at);
              },
              onCancel: () => {
                st(new Error("Transaction canceled"));
              }
            });
          }), ie(!1), Ce;
        }
        if (B === "unisat") {
          let ce = "";
          return ce = await window.unisat.sendBitcoin(pe, ne, {}), ie(!1), ce;
        }
        if (B === "leather") {
          let ce = "";
          return ce = (await leatherRequest(
            "sendTransfer",
            {
              recipients: [
                {
                  address: pe,
                  amount: ne
                }
              ],
              network: L
            }
          )).txid, ie(!1), ce;
        }
        if (B === "okx") {
          let ce = "";
          if (L === "mainnet")
            return ce = await window.okxwallet.bitcoin.sendBitcoin(
              pe,
              ne,
              {}
            ), ie(!1), ce;
          if (L === "testnet")
            return ce = await window.okxwallet.bitcoinTestnet.sendBitcoin(
              pe,
              ne,
              {}
            ), ie(!1), ce;
        }
        return ie(!1), null;
      } catch (ce) {
        return V(ce.message), ie(!1), null;
      }
    },
    [W, L, K, B]
  ), error: J, loading: re };
}
function useSendV2() {
  const { wallet: B, network: L, address: W, publicKey: K } = useWallie(), [J, V] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ie,
      satoshis: oe,
      feeRate: pe,
      relay: ne = !0,
      rbf: ce = !1
    }) => {
      V(!0);
      try {
        if (!W || !W.payments || !K || !K.payments || !B)
          throw new Error("No wallet is connected");
        const Ce = new PSBTBuilder({
          address: W.payments,
          feeRate: pe,
          network: L,
          publicKey: K.payments,
          outputs: [
            {
              address: ie,
              value: oe
            }
          ]
        });
        Ce.setRBF(ce), await Ce.prepare();
        const Oe = await signPsbt({
          address: W.payments,
          wallet: B,
          network: L,
          psbt: Ce.toPSBT()
        });
        if (ne) {
          const at = await new JsonRpcDatasource({ network: L }).relay({ hex: Oe.hex });
          return V(!1), {
            txId: at
          };
        }
        return V(!1), {
          signedPsbtHex: Oe.hex
        };
      } catch (Ce) {
        return V(!1), {
          error: Ce.message
        };
      }
    },
    [W, L, K, B]
  ), isLoading: J };
}
function useSign() {
  const { network: B, publicKey: L, format: W, wallet: K } = useWallie(), [J, V] = useState(null), [re, ie] = useState(!1);
  return { sign: useCallback(
    async (pe, ne, ce) => {
      ie(!0);
      try {
        if (V(null), !W || !L || !K)
          throw new Error("No wallet is connected");
        const Ce = src$4.Psbt.fromBase64(ne), Oe = await signPsbt({
          address: pe,
          wallet: K,
          network: B,
          psbt: Ce,
          options: ce
        });
        return ie(!1), Oe;
      } catch (Ce) {
        throw V(Ce.message), ie(!1), Ce;
      }
    },
    [W, B, L, K]
  ), error: J, loading: re };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: B,
  wallet: L,
  address: W,
  network: K,
  format: J
}) {
  if (L === Wallet.MAGICEDEN) {
    const { base64: V } = await signMessage$4(B, W, K);
    return V;
  }
  if (L === Wallet.UNISAT) {
    const { base64: V } = await signMessage$3(B, "bip322-simple");
    return V;
  }
  if (L === Wallet.XVERSE) {
    const { base64: V } = await signMessage$2(B, W, K);
    return V;
  }
  if (L === Wallet.LEATHER) {
    const V = leatherPaymentTypeFromFormat(J), { base64: re } = await signMessage$6(B, {
      paymentType: V,
      network: K
    });
    return re;
  }
  if (L === Wallet.OKX) {
    const { base64: V } = await signMessage$1(B, "bip322-simple", K);
    return V;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: L,
    publicKey: W,
    format: K,
    address: J
  } = useWallie(), [V, re] = useState(null), [ie, oe] = useState(!1);
  return { signMsg: useCallback(
    async (ne, ce) => {
      oe(!0);
      try {
        if (re(null), !K || !W || !L)
          throw new Error("No wallet is connected");
        if (J.ordinals !== ne && J.payments !== ne)
          throw new Error("Address supplied is not connected address");
        const Ce = await signMessage({
          address: ne,
          wallet: L,
          message: ce,
          network: B,
          format: J.ordinals === ne ? K.ordinals : K.payments
        });
        return oe(!1), Ce;
      } catch (Ce) {
        throw re(Ce.message), oe(!1), Ce;
      }
    },
    [K, B, W, L, J]
  ), error: V, isLoading: ie };
}
export {
  Network,
  OrdConnectKit,
  SelectWalletModal,
  Wallet,
  WallieProvider,
  useBalance,
  useSend,
  useSendBtc,
  useSendV2,
  useSign,
  useSignMessage,
  useWallie
};
