var D8 = Object.defineProperty;
var N8 = (B, L, J) => L in B ? D8(B, L, { enumerable: !0, configurable: !0, writable: !0, value: J }) : B[L] = J;
var Li = (B, L, J) => N8(B, typeof L != "symbol" ? L + "" : L, J);
function _mergeNamespaces(B, L) {
  for (var J = 0; J < L.length; J++) {
    const ne = L[J];
    if (typeof ne != "string" && !Array.isArray(ne)) {
      for (const oe in ne)
        if (oe !== "default" && !(oe in B)) {
          const ce = Object.getOwnPropertyDescriptor(ne, oe);
          ce && Object.defineProperty(B, oe, ce.get ? ce : {
            enumerable: !0,
            get: () => ne[oe]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(B, Symbol.toStringTag, { value: "Module" }));
}
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var L = queue.length; L; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < L; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, L = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var L = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var J = 1; J < arguments.length; J++)
      L[J - 1] = arguments[J];
  queue.push(new Item(B, L)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, L) {
  this.fun = B, this.array = L;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$2() {
}
process.on = noop$2;
process.addListener = noop$2;
process.once = noop$2;
process.off = noop$2;
process.removeListener = noop$2;
process.removeAllListeners = noop$2;
process.emit = noop$2;
process.prependListener = noop$2;
process.prependOnceListener = noop$2;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
function getAugmentedNamespace(B) {
  if (B.__esModule) return B;
  var L = B.default;
  if (typeof L == "function") {
    var J = function ne() {
      return this instanceof ne ? Reflect.construct(L, arguments, this.constructor) : L.apply(this, arguments);
    };
    J.prototype = L.prototype;
  } else J = {};
  return Object.defineProperty(J, "__esModule", { value: !0 }), Object.keys(B).forEach(function(ne) {
    var oe = Object.getOwnPropertyDescriptor(B, ne);
    Object.defineProperty(J, ne, oe.get ? oe : {
      enumerable: !0,
      get: function() {
        return B[ne];
      }
    });
  }), J;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {}, react = { exports: {} }, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var B = Symbol.for("react.element"), L = Symbol.for("react.portal"), J = Symbol.for("react.fragment"), ne = Symbol.for("react.strict_mode"), oe = Symbol.for("react.profiler"), ce = Symbol.for("react.provider"), Ce = Symbol.for("react.context"), rt = Symbol.for("react.forward_ref"), at = Symbol.for("react.suspense"), ht = Symbol.for("react.memo"), it = Symbol.for("react.lazy"), lt = Symbol.iterator;
  function Et($t) {
    return $t === null || typeof $t != "object" ? null : ($t = lt && $t[lt] || $t["@@iterator"], typeof $t == "function" ? $t : null);
  }
  var wt = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, Rt = Object.assign, Mt = {};
  function Lt($t, yt, Bt) {
    this.props = $t, this.context = yt, this.refs = Mt, this.updater = Bt || wt;
  }
  Lt.prototype.isReactComponent = {}, Lt.prototype.setState = function($t, yt) {
    if (typeof $t != "object" && typeof $t != "function" && $t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, $t, yt, "setState");
  }, Lt.prototype.forceUpdate = function($t) {
    this.updater.enqueueForceUpdate(this, $t, "forceUpdate");
  };
  function zt() {
  }
  zt.prototype = Lt.prototype;
  function Ot($t, yt, Bt) {
    this.props = $t, this.context = yt, this.refs = Mt, this.updater = Bt || wt;
  }
  var It = Ot.prototype = new zt();
  It.constructor = Ot, Rt(It, Lt.prototype), It.isPureReactComponent = !0;
  var Ft = Array.isArray, Jt = Object.prototype.hasOwnProperty, Vt = { current: null }, yr = { key: !0, ref: !0, __self: !0, __source: !0 };
  function jt($t, yt, Bt) {
    var rr, dr = {}, tr = null, Dt = null;
    if (yt != null) for (rr in yt.ref !== void 0 && (Dt = yt.ref), yt.key !== void 0 && (tr = "" + yt.key), yt) Jt.call(yt, rr) && !yr.hasOwnProperty(rr) && (dr[rr] = yt[rr]);
    var Wt = arguments.length - 2;
    if (Wt === 1) dr.children = Bt;
    else if (1 < Wt) {
      for (var or = Array(Wt), _r = 0; _r < Wt; _r++) or[_r] = arguments[_r + 2];
      dr.children = or;
    }
    if ($t && $t.defaultProps) for (rr in Wt = $t.defaultProps, Wt) dr[rr] === void 0 && (dr[rr] = Wt[rr]);
    return { $$typeof: B, type: $t, key: tr, ref: Dt, props: dr, _owner: Vt.current };
  }
  function Ut($t, yt) {
    return { $$typeof: B, type: $t.type, key: yt, ref: $t.ref, props: $t.props, _owner: $t._owner };
  }
  function er($t) {
    return typeof $t == "object" && $t !== null && $t.$$typeof === B;
  }
  function Ht($t) {
    var yt = { "=": "=0", ":": "=2" };
    return "$" + $t.replace(/[=:]/g, function(Bt) {
      return yt[Bt];
    });
  }
  var ct = /\/+/g;
  function dt($t, yt) {
    return typeof $t == "object" && $t !== null && $t.key != null ? Ht("" + $t.key) : yt.toString(36);
  }
  function ot($t, yt, Bt, rr, dr) {
    var tr = typeof $t;
    (tr === "undefined" || tr === "boolean") && ($t = null);
    var Dt = !1;
    if ($t === null) Dt = !0;
    else switch (tr) {
      case "string":
      case "number":
        Dt = !0;
        break;
      case "object":
        switch ($t.$$typeof) {
          case B:
          case L:
            Dt = !0;
        }
    }
    if (Dt) return Dt = $t, dr = dr(Dt), $t = rr === "" ? "." + dt(Dt, 0) : rr, Ft(dr) ? (Bt = "", $t != null && (Bt = $t.replace(ct, "$&/") + "/"), ot(dr, yt, Bt, "", function(_r) {
      return _r;
    })) : dr != null && (er(dr) && (dr = Ut(dr, Bt + (!dr.key || Dt && Dt.key === dr.key ? "" : ("" + dr.key).replace(ct, "$&/") + "/") + $t)), yt.push(dr)), 1;
    if (Dt = 0, rr = rr === "" ? "." : rr + ":", Ft($t)) for (var Wt = 0; Wt < $t.length; Wt++) {
      tr = $t[Wt];
      var or = rr + dt(tr, Wt);
      Dt += ot(tr, yt, Bt, or, dr);
    }
    else if (or = Et($t), typeof or == "function") for ($t = or.call($t), Wt = 0; !(tr = $t.next()).done; ) tr = tr.value, or = rr + dt(tr, Wt++), Dt += ot(tr, yt, Bt, or, dr);
    else if (tr === "object") throw yt = String($t), Error("Objects are not valid as a React child (found: " + (yt === "[object Object]" ? "object with keys {" + Object.keys($t).join(", ") + "}" : yt) + "). If you meant to render a collection of children, use an array instead.");
    return Dt;
  }
  function ut($t, yt, Bt) {
    if ($t == null) return $t;
    var rr = [], dr = 0;
    return ot($t, rr, "", "", function(tr) {
      return yt.call(Bt, tr, dr++);
    }), rr;
  }
  function mt($t) {
    if ($t._status === -1) {
      var yt = $t._result;
      yt = yt(), yt.then(function(Bt) {
        ($t._status === 0 || $t._status === -1) && ($t._status = 1, $t._result = Bt);
      }, function(Bt) {
        ($t._status === 0 || $t._status === -1) && ($t._status = 2, $t._result = Bt);
      }), $t._status === -1 && ($t._status = 0, $t._result = yt);
    }
    if ($t._status === 1) return $t._result.default;
    throw $t._result;
  }
  var gt = { current: null }, St = { transition: null }, xt = { ReactCurrentDispatcher: gt, ReactCurrentBatchConfig: St, ReactCurrentOwner: Vt };
  function vt() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return react_production_min.Children = { map: ut, forEach: function($t, yt, Bt) {
    ut($t, function() {
      yt.apply(this, arguments);
    }, Bt);
  }, count: function($t) {
    var yt = 0;
    return ut($t, function() {
      yt++;
    }), yt;
  }, toArray: function($t) {
    return ut($t, function(yt) {
      return yt;
    }) || [];
  }, only: function($t) {
    if (!er($t)) throw Error("React.Children.only expected to receive a single React element child.");
    return $t;
  } }, react_production_min.Component = Lt, react_production_min.Fragment = J, react_production_min.Profiler = oe, react_production_min.PureComponent = Ot, react_production_min.StrictMode = ne, react_production_min.Suspense = at, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = xt, react_production_min.act = vt, react_production_min.cloneElement = function($t, yt, Bt) {
    if ($t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + $t + ".");
    var rr = Rt({}, $t.props), dr = $t.key, tr = $t.ref, Dt = $t._owner;
    if (yt != null) {
      if (yt.ref !== void 0 && (tr = yt.ref, Dt = Vt.current), yt.key !== void 0 && (dr = "" + yt.key), $t.type && $t.type.defaultProps) var Wt = $t.type.defaultProps;
      for (or in yt) Jt.call(yt, or) && !yr.hasOwnProperty(or) && (rr[or] = yt[or] === void 0 && Wt !== void 0 ? Wt[or] : yt[or]);
    }
    var or = arguments.length - 2;
    if (or === 1) rr.children = Bt;
    else if (1 < or) {
      Wt = Array(or);
      for (var _r = 0; _r < or; _r++) Wt[_r] = arguments[_r + 2];
      rr.children = Wt;
    }
    return { $$typeof: B, type: $t.type, key: dr, ref: tr, props: rr, _owner: Dt };
  }, react_production_min.createContext = function($t) {
    return $t = { $$typeof: Ce, _currentValue: $t, _currentValue2: $t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, $t.Provider = { $$typeof: ce, _context: $t }, $t.Consumer = $t;
  }, react_production_min.createElement = jt, react_production_min.createFactory = function($t) {
    var yt = jt.bind(null, $t);
    return yt.type = $t, yt;
  }, react_production_min.createRef = function() {
    return { current: null };
  }, react_production_min.forwardRef = function($t) {
    return { $$typeof: rt, render: $t };
  }, react_production_min.isValidElement = er, react_production_min.lazy = function($t) {
    return { $$typeof: it, _payload: { _status: -1, _result: $t }, _init: mt };
  }, react_production_min.memo = function($t, yt) {
    return { $$typeof: ht, type: $t, compare: yt === void 0 ? null : yt };
  }, react_production_min.startTransition = function($t) {
    var yt = St.transition;
    St.transition = {};
    try {
      $t();
    } finally {
      St.transition = yt;
    }
  }, react_production_min.unstable_act = vt, react_production_min.useCallback = function($t, yt) {
    return gt.current.useCallback($t, yt);
  }, react_production_min.useContext = function($t) {
    return gt.current.useContext($t);
  }, react_production_min.useDebugValue = function() {
  }, react_production_min.useDeferredValue = function($t) {
    return gt.current.useDeferredValue($t);
  }, react_production_min.useEffect = function($t, yt) {
    return gt.current.useEffect($t, yt);
  }, react_production_min.useId = function() {
    return gt.current.useId();
  }, react_production_min.useImperativeHandle = function($t, yt, Bt) {
    return gt.current.useImperativeHandle($t, yt, Bt);
  }, react_production_min.useInsertionEffect = function($t, yt) {
    return gt.current.useInsertionEffect($t, yt);
  }, react_production_min.useLayoutEffect = function($t, yt) {
    return gt.current.useLayoutEffect($t, yt);
  }, react_production_min.useMemo = function($t, yt) {
    return gt.current.useMemo($t, yt);
  }, react_production_min.useReducer = function($t, yt, Bt) {
    return gt.current.useReducer($t, yt, Bt);
  }, react_production_min.useRef = function($t) {
    return gt.current.useRef($t);
  }, react_production_min.useState = function($t) {
    return gt.current.useState($t);
  }, react_production_min.useSyncExternalStore = function($t, yt, Bt) {
    return gt.current.useSyncExternalStore($t, yt, Bt);
  }, react_production_min.useTransition = function() {
    return gt.current.useTransition();
  }, react_production_min.version = "18.3.1", react_production_min;
}
var react_development = { exports: {} };
react_development.exports;
var hasRequiredReact_development;
function requireReact_development() {
  return hasRequiredReact_development || (hasRequiredReact_development = 1, function(B, L) {
    process$1.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var J = "18.3.1", ne = Symbol.for("react.element"), oe = Symbol.for("react.portal"), ce = Symbol.for("react.fragment"), Ce = Symbol.for("react.strict_mode"), rt = Symbol.for("react.profiler"), at = Symbol.for("react.provider"), ht = Symbol.for("react.context"), it = Symbol.for("react.forward_ref"), lt = Symbol.for("react.suspense"), Et = Symbol.for("react.suspense_list"), wt = Symbol.for("react.memo"), Rt = Symbol.for("react.lazy"), Mt = Symbol.for("react.offscreen"), Lt = Symbol.iterator, zt = "@@iterator";
      function Ot(Kt) {
        if (Kt === null || typeof Kt != "object")
          return null;
        var vr = Lt && Kt[Lt] || Kt[zt];
        return typeof vr == "function" ? vr : null;
      }
      var It = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, Ft = {
        transition: null
      }, Jt = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, Vt = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, yr = {}, jt = null;
      function Ut(Kt) {
        jt = Kt;
      }
      yr.setExtraStackFrame = function(Kt) {
        jt = Kt;
      }, yr.getCurrentStack = null, yr.getStackAddendum = function() {
        var Kt = "";
        jt && (Kt += jt);
        var vr = yr.getCurrentStack;
        return vr && (Kt += vr() || ""), Kt;
      };
      var er = !1, Ht = !1, ct = !1, dt = !1, ot = !1, ut = {
        ReactCurrentDispatcher: It,
        ReactCurrentBatchConfig: Ft,
        ReactCurrentOwner: Vt
      };
      ut.ReactDebugCurrentFrame = yr, ut.ReactCurrentActQueue = Jt;
      function mt(Kt) {
        {
          for (var vr = arguments.length, Pr = new Array(vr > 1 ? vr - 1 : 0), Hr = 1; Hr < vr; Hr++)
            Pr[Hr - 1] = arguments[Hr];
          St("warn", Kt, Pr);
        }
      }
      function gt(Kt) {
        {
          for (var vr = arguments.length, Pr = new Array(vr > 1 ? vr - 1 : 0), Hr = 1; Hr < vr; Hr++)
            Pr[Hr - 1] = arguments[Hr];
          St("error", Kt, Pr);
        }
      }
      function St(Kt, vr, Pr) {
        {
          var Hr = ut.ReactDebugCurrentFrame, an = Hr.getStackAddendum();
          an !== "" && (vr += "%s", Pr = Pr.concat([an]));
          var Zn = Pr.map(function(wn) {
            return String(wn);
          });
          Zn.unshift("Warning: " + vr), Function.prototype.apply.call(console[Kt], console, Zn);
        }
      }
      var xt = {};
      function vt(Kt, vr) {
        {
          var Pr = Kt.constructor, Hr = Pr && (Pr.displayName || Pr.name) || "ReactClass", an = Hr + "." + vr;
          if (xt[an])
            return;
          gt("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", vr, Hr), xt[an] = !0;
        }
      }
      var $t = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(Kt) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(Kt, vr, Pr) {
          vt(Kt, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(Kt, vr, Pr, Hr) {
          vt(Kt, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(Kt, vr, Pr, Hr) {
          vt(Kt, "setState");
        }
      }, yt = Object.assign, Bt = {};
      Object.freeze(Bt);
      function rr(Kt, vr, Pr) {
        this.props = Kt, this.context = vr, this.refs = Bt, this.updater = Pr || $t;
      }
      rr.prototype.isReactComponent = {}, rr.prototype.setState = function(Kt, vr) {
        if (typeof Kt != "object" && typeof Kt != "function" && Kt != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, Kt, vr, "setState");
      }, rr.prototype.forceUpdate = function(Kt) {
        this.updater.enqueueForceUpdate(this, Kt, "forceUpdate");
      };
      {
        var dr = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, tr = function(Kt, vr) {
          Object.defineProperty(rr.prototype, Kt, {
            get: function() {
              mt("%s(...) is deprecated in plain JavaScript React classes. %s", vr[0], vr[1]);
            }
          });
        };
        for (var Dt in dr)
          dr.hasOwnProperty(Dt) && tr(Dt, dr[Dt]);
      }
      function Wt() {
      }
      Wt.prototype = rr.prototype;
      function or(Kt, vr, Pr) {
        this.props = Kt, this.context = vr, this.refs = Bt, this.updater = Pr || $t;
      }
      var _r = or.prototype = new Wt();
      _r.constructor = or, yt(_r, rr.prototype), _r.isPureReactComponent = !0;
      function Xt() {
        var Kt = {
          current: null
        };
        return Object.seal(Kt), Kt;
      }
      var Qt = Array.isArray;
      function br(Kt) {
        return Qt(Kt);
      }
      function Dr(Kt) {
        {
          var vr = typeof Symbol == "function" && Symbol.toStringTag, Pr = vr && Kt[Symbol.toStringTag] || Kt.constructor.name || "Object";
          return Pr;
        }
      }
      function Vr(Kt) {
        try {
          return Zr(Kt), !1;
        } catch {
          return !0;
        }
      }
      function Zr(Kt) {
        return "" + Kt;
      }
      function ln(Kt) {
        if (Vr(Kt))
          return gt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Dr(Kt)), Zr(Kt);
      }
      function _n(Kt, vr, Pr) {
        var Hr = Kt.displayName;
        if (Hr)
          return Hr;
        var an = vr.displayName || vr.name || "";
        return an !== "" ? Pr + "(" + an + ")" : Pr;
      }
      function Mr(Kt) {
        return Kt.displayName || "Context";
      }
      function Wn(Kt) {
        if (Kt == null)
          return null;
        if (typeof Kt.tag == "number" && gt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Kt == "function")
          return Kt.displayName || Kt.name || null;
        if (typeof Kt == "string")
          return Kt;
        switch (Kt) {
          case ce:
            return "Fragment";
          case oe:
            return "Portal";
          case rt:
            return "Profiler";
          case Ce:
            return "StrictMode";
          case lt:
            return "Suspense";
          case Et:
            return "SuspenseList";
        }
        if (typeof Kt == "object")
          switch (Kt.$$typeof) {
            case ht:
              var vr = Kt;
              return Mr(vr) + ".Consumer";
            case at:
              var Pr = Kt;
              return Mr(Pr._context) + ".Provider";
            case it:
              return _n(Kt, Kt.render, "ForwardRef");
            case wt:
              var Hr = Kt.displayName || null;
              return Hr !== null ? Hr : Wn(Kt.type) || "Memo";
            case Rt: {
              var an = Kt, Zn = an._payload, wn = an._init;
              try {
                return Wn(wn(Zn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var xn = Object.prototype.hasOwnProperty, ni = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Gn, En, Pn;
      Pn = {};
      function ti(Kt) {
        if (xn.call(Kt, "ref")) {
          var vr = Object.getOwnPropertyDescriptor(Kt, "ref").get;
          if (vr && vr.isReactWarning)
            return !1;
        }
        return Kt.ref !== void 0;
      }
      function gn(Kt) {
        if (xn.call(Kt, "key")) {
          var vr = Object.getOwnPropertyDescriptor(Kt, "key").get;
          if (vr && vr.isReactWarning)
            return !1;
        }
        return Kt.key !== void 0;
      }
      function Kn(Kt, vr) {
        var Pr = function() {
          Gn || (Gn = !0, gt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", vr));
        };
        Pr.isReactWarning = !0, Object.defineProperty(Kt, "key", {
          get: Pr,
          configurable: !0
        });
      }
      function gi(Kt, vr) {
        var Pr = function() {
          En || (En = !0, gt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", vr));
        };
        Pr.isReactWarning = !0, Object.defineProperty(Kt, "ref", {
          get: Pr,
          configurable: !0
        });
      }
      function Gt(Kt) {
        if (typeof Kt.ref == "string" && Vt.current && Kt.__self && Vt.current.stateNode !== Kt.__self) {
          var vr = Wn(Vt.current.type);
          Pn[vr] || (gt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', vr, Kt.ref), Pn[vr] = !0);
        }
      }
      var At = function(Kt, vr, Pr, Hr, an, Zn, wn) {
        var Qn = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: ne,
          // Built-in properties that belong on the element
          type: Kt,
          key: vr,
          ref: Pr,
          props: wn,
          // Record the component responsible for creating this element.
          _owner: Zn
        };
        return Qn._store = {}, Object.defineProperty(Qn._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Qn, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Hr
        }), Object.defineProperty(Qn, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: an
        }), Object.freeze && (Object.freeze(Qn.props), Object.freeze(Qn)), Qn;
      };
      function kt(Kt, vr, Pr) {
        var Hr, an = {}, Zn = null, wn = null, Qn = null, yi = null;
        if (vr != null) {
          ti(vr) && (wn = vr.ref, Gt(vr)), gn(vr) && (ln(vr.key), Zn = "" + vr.key), Qn = vr.__self === void 0 ? null : vr.__self, yi = vr.__source === void 0 ? null : vr.__source;
          for (Hr in vr)
            xn.call(vr, Hr) && !ni.hasOwnProperty(Hr) && (an[Hr] = vr[Hr]);
        }
        var Ai = arguments.length - 2;
        if (Ai === 1)
          an.children = Pr;
        else if (Ai > 1) {
          for (var ji = Array(Ai), Ui = 0; Ui < Ai; Ui++)
            ji[Ui] = arguments[Ui + 2];
          Object.freeze && Object.freeze(ji), an.children = ji;
        }
        if (Kt && Kt.defaultProps) {
          var zi = Kt.defaultProps;
          for (Hr in zi)
            an[Hr] === void 0 && (an[Hr] = zi[Hr]);
        }
        if (Zn || wn) {
          var Ki = typeof Kt == "function" ? Kt.displayName || Kt.name || "Unknown" : Kt;
          Zn && Kn(an, Ki), wn && gi(an, Ki);
        }
        return At(Kt, Zn, wn, Qn, yi, Vt.current, an);
      }
      function Zt(Kt, vr) {
        var Pr = At(Kt.type, vr, Kt.ref, Kt._self, Kt._source, Kt._owner, Kt.props);
        return Pr;
      }
      function pr(Kt, vr, Pr) {
        if (Kt == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + Kt + ".");
        var Hr, an = yt({}, Kt.props), Zn = Kt.key, wn = Kt.ref, Qn = Kt._self, yi = Kt._source, Ai = Kt._owner;
        if (vr != null) {
          ti(vr) && (wn = vr.ref, Ai = Vt.current), gn(vr) && (ln(vr.key), Zn = "" + vr.key);
          var ji;
          Kt.type && Kt.type.defaultProps && (ji = Kt.type.defaultProps);
          for (Hr in vr)
            xn.call(vr, Hr) && !ni.hasOwnProperty(Hr) && (vr[Hr] === void 0 && ji !== void 0 ? an[Hr] = ji[Hr] : an[Hr] = vr[Hr]);
        }
        var Ui = arguments.length - 2;
        if (Ui === 1)
          an.children = Pr;
        else if (Ui > 1) {
          for (var zi = Array(Ui), Ki = 0; Ki < Ui; Ki++)
            zi[Ki] = arguments[Ki + 2];
          an.children = zi;
        }
        return At(Kt.type, Zn, wn, Qn, yi, Ai, an);
      }
      function Sr(Kt) {
        return typeof Kt == "object" && Kt !== null && Kt.$$typeof === ne;
      }
      var Tr = ".", fn = ":";
      function On(Kt) {
        var vr = /[=:]/g, Pr = {
          "=": "=0",
          ":": "=2"
        }, Hr = Kt.replace(vr, function(an) {
          return Pr[an];
        });
        return "$" + Hr;
      }
      var tn = !1, In = /\/+/g;
      function hn(Kt) {
        return Kt.replace(In, "$&/");
      }
      function cn(Kt, vr) {
        return typeof Kt == "object" && Kt !== null && Kt.key != null ? (ln(Kt.key), On("" + Kt.key)) : vr.toString(36);
      }
      function ci(Kt, vr, Pr, Hr, an) {
        var Zn = typeof Kt;
        (Zn === "undefined" || Zn === "boolean") && (Kt = null);
        var wn = !1;
        if (Kt === null)
          wn = !0;
        else
          switch (Zn) {
            case "string":
            case "number":
              wn = !0;
              break;
            case "object":
              switch (Kt.$$typeof) {
                case ne:
                case oe:
                  wn = !0;
              }
          }
        if (wn) {
          var Qn = Kt, yi = an(Qn), Ai = Hr === "" ? Tr + cn(Qn, 0) : Hr;
          if (br(yi)) {
            var ji = "";
            Ai != null && (ji = hn(Ai) + "/"), ci(yi, vr, ji, "", function(Qh) {
              return Qh;
            });
          } else yi != null && (Sr(yi) && (yi.key && (!Qn || Qn.key !== yi.key) && ln(yi.key), yi = Zt(
            yi,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            Pr + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (yi.key && (!Qn || Qn.key !== yi.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              hn("" + yi.key) + "/"
            ) : "") + Ai
          )), vr.push(yi));
          return 1;
        }
        var Ui, zi, Ki = 0, Ei = Hr === "" ? Tr : Hr + fn;
        if (br(Kt))
          for (var js = 0; js < Kt.length; js++)
            Ui = Kt[js], zi = Ei + cn(Ui, js), Ki += ci(Ui, vr, Pr, zi, an);
        else {
          var zf = Ot(Kt);
          if (typeof zf == "function") {
            var Yl = Kt;
            zf === Yl.entries && (tn || mt("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), tn = !0);
            for (var Jh = zf.call(Yl), ps, Jl = 0; !(ps = Jh.next()).done; )
              Ui = ps.value, zi = Ei + cn(Ui, Jl++), Ki += ci(Ui, vr, Pr, zi, an);
          } else if (Zn === "object") {
            var Ql = String(Kt);
            throw new Error("Objects are not valid as a React child (found: " + (Ql === "[object Object]" ? "object with keys {" + Object.keys(Kt).join(", ") + "}" : Ql) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Ki;
      }
      function pi(Kt, vr, Pr) {
        if (Kt == null)
          return Kt;
        var Hr = [], an = 0;
        return ci(Kt, Hr, "", "", function(Zn) {
          return vr.call(Pr, Zn, an++);
        }), Hr;
      }
      function ur(Kt) {
        var vr = 0;
        return pi(Kt, function() {
          vr++;
        }), vr;
      }
      function ir(Kt, vr, Pr) {
        pi(Kt, function() {
          vr.apply(this, arguments);
        }, Pr);
      }
      function lr(Kt) {
        return pi(Kt, function(vr) {
          return vr;
        }) || [];
      }
      function gr(Kt) {
        if (!Sr(Kt))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return Kt;
      }
      function Ar(Kt) {
        var vr = {
          $$typeof: ht,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: Kt,
          _currentValue2: Kt,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        vr.Provider = {
          $$typeof: at,
          _context: vr
        };
        var Pr = !1, Hr = !1, an = !1;
        {
          var Zn = {
            $$typeof: ht,
            _context: vr
          };
          Object.defineProperties(Zn, {
            Provider: {
              get: function() {
                return Hr || (Hr = !0, gt("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), vr.Provider;
              },
              set: function(wn) {
                vr.Provider = wn;
              }
            },
            _currentValue: {
              get: function() {
                return vr._currentValue;
              },
              set: function(wn) {
                vr._currentValue = wn;
              }
            },
            _currentValue2: {
              get: function() {
                return vr._currentValue2;
              },
              set: function(wn) {
                vr._currentValue2 = wn;
              }
            },
            _threadCount: {
              get: function() {
                return vr._threadCount;
              },
              set: function(wn) {
                vr._threadCount = wn;
              }
            },
            Consumer: {
              get: function() {
                return Pr || (Pr = !0, gt("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), vr.Consumer;
              }
            },
            displayName: {
              get: function() {
                return vr.displayName;
              },
              set: function(wn) {
                an || (mt("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", wn), an = !0);
              }
            }
          }), vr.Consumer = Zn;
        }
        return vr._currentRenderer = null, vr._currentRenderer2 = null, vr;
      }
      var Fr = -1, jr = 0, Xr = 1, pn = 2;
      function Yr(Kt) {
        if (Kt._status === Fr) {
          var vr = Kt._result, Pr = vr();
          if (Pr.then(function(Zn) {
            if (Kt._status === jr || Kt._status === Fr) {
              var wn = Kt;
              wn._status = Xr, wn._result = Zn;
            }
          }, function(Zn) {
            if (Kt._status === jr || Kt._status === Fr) {
              var wn = Kt;
              wn._status = pn, wn._result = Zn;
            }
          }), Kt._status === Fr) {
            var Hr = Kt;
            Hr._status = jr, Hr._result = Pr;
          }
        }
        if (Kt._status === Xr) {
          var an = Kt._result;
          return an === void 0 && gt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, an), "default" in an || gt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, an), an.default;
        } else
          throw Kt._result;
      }
      function vn(Kt) {
        var vr = {
          // We use these fields to store the result.
          _status: Fr,
          _result: Kt
        }, Pr = {
          $$typeof: Rt,
          _payload: vr,
          _init: Yr
        };
        {
          var Hr, an;
          Object.defineProperties(Pr, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Hr;
              },
              set: function(Zn) {
                gt("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Hr = Zn, Object.defineProperty(Pr, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return an;
              },
              set: function(Zn) {
                gt("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), an = Zn, Object.defineProperty(Pr, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return Pr;
      }
      function Cn(Kt) {
        Kt != null && Kt.$$typeof === wt ? gt("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof Kt != "function" ? gt("forwardRef requires a render function but was given %s.", Kt === null ? "null" : typeof Kt) : Kt.length !== 0 && Kt.length !== 2 && gt("forwardRef render functions accept exactly two parameters: props and ref. %s", Kt.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), Kt != null && (Kt.defaultProps != null || Kt.propTypes != null) && gt("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var vr = {
          $$typeof: it,
          render: Kt
        };
        {
          var Pr;
          Object.defineProperty(vr, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Pr;
            },
            set: function(Hr) {
              Pr = Hr, !Kt.name && !Kt.displayName && (Kt.displayName = Hr);
            }
          });
        }
        return vr;
      }
      var dn;
      dn = Symbol.for("react.module.reference");
      function fr(Kt) {
        return !!(typeof Kt == "string" || typeof Kt == "function" || Kt === ce || Kt === rt || ot || Kt === Ce || Kt === lt || Kt === Et || dt || Kt === Mt || er || Ht || ct || typeof Kt == "object" && Kt !== null && (Kt.$$typeof === Rt || Kt.$$typeof === wt || Kt.$$typeof === at || Kt.$$typeof === ht || Kt.$$typeof === it || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        Kt.$$typeof === dn || Kt.getModuleId !== void 0));
      }
      function Nr(Kt, vr) {
        fr(Kt) || gt("memo: The first argument must be a component. Instead received: %s", Kt === null ? "null" : typeof Kt);
        var Pr = {
          $$typeof: wt,
          type: Kt,
          compare: vr === void 0 ? null : vr
        };
        {
          var Hr;
          Object.defineProperty(Pr, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Hr;
            },
            set: function(an) {
              Hr = an, !Kt.name && !Kt.displayName && (Kt.displayName = an);
            }
          });
        }
        return Pr;
      }
      function Ir() {
        var Kt = It.current;
        return Kt === null && gt(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), Kt;
      }
      function sn(Kt) {
        var vr = Ir();
        if (Kt._context !== void 0) {
          var Pr = Kt._context;
          Pr.Consumer === Kt ? gt("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Pr.Provider === Kt && gt("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return vr.useContext(Kt);
      }
      function Tn(Kt) {
        var vr = Ir();
        return vr.useState(Kt);
      }
      function kn(Kt, vr, Pr) {
        var Hr = Ir();
        return Hr.useReducer(Kt, vr, Pr);
      }
      function Dn(Kt) {
        var vr = Ir();
        return vr.useRef(Kt);
      }
      function Jn(Kt, vr) {
        var Pr = Ir();
        return Pr.useEffect(Kt, vr);
      }
      function Ti(Kt, vr) {
        var Pr = Ir();
        return Pr.useInsertionEffect(Kt, vr);
      }
      function _i(Kt, vr) {
        var Pr = Ir();
        return Pr.useLayoutEffect(Kt, vr);
      }
      function Ri(Kt, vr) {
        var Pr = Ir();
        return Pr.useCallback(Kt, vr);
      }
      function Qi(Kt, vr) {
        var Pr = Ir();
        return Pr.useMemo(Kt, vr);
      }
      function Ca(Kt, vr, Pr) {
        var Hr = Ir();
        return Hr.useImperativeHandle(Kt, vr, Pr);
      }
      function vi(Kt, vr) {
        {
          var Pr = Ir();
          return Pr.useDebugValue(Kt, vr);
        }
      }
      function Wi() {
        var Kt = Ir();
        return Kt.useTransition();
      }
      function ra(Kt) {
        var vr = Ir();
        return vr.useDeferredValue(Kt);
      }
      function ii() {
        var Kt = Ir();
        return Kt.useId();
      }
      function ma(Kt, vr, Pr) {
        var Hr = Ir();
        return Hr.useSyncExternalStore(Kt, vr, Pr);
      }
      var Ga = 0, po, Xa, sa, Oo, Sa, Ls, Gl;
      function Zc() {
      }
      Zc.__reactDisabledLog = !0;
      function Pf() {
        {
          if (Ga === 0) {
            po = console.log, Xa = console.info, sa = console.warn, Oo = console.error, Sa = console.group, Ls = console.groupCollapsed, Gl = console.groupEnd;
            var Kt = {
              configurable: !0,
              enumerable: !0,
              value: Zc,
              writable: !0
            };
            Object.defineProperties(console, {
              info: Kt,
              log: Kt,
              warn: Kt,
              error: Kt,
              group: Kt,
              groupCollapsed: Kt,
              groupEnd: Kt
            });
          }
          Ga++;
        }
      }
      function pu() {
        {
          if (Ga--, Ga === 0) {
            var Kt = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: yt({}, Kt, {
                value: po
              }),
              info: yt({}, Kt, {
                value: Xa
              }),
              warn: yt({}, Kt, {
                value: sa
              }),
              error: yt({}, Kt, {
                value: Oo
              }),
              group: yt({}, Kt, {
                value: Sa
              }),
              groupCollapsed: yt({}, Kt, {
                value: Ls
              }),
              groupEnd: yt({}, Kt, {
                value: Gl
              })
            });
          }
          Ga < 0 && gt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ds = ut.ReactCurrentDispatcher, to;
      function vu(Kt, vr, Pr) {
        {
          if (to === void 0)
            try {
              throw Error();
            } catch (an) {
              var Hr = an.stack.trim().match(/\n( *(at )?)/);
              to = Hr && Hr[1] || "";
            }
          return `
` + to + Kt;
        }
      }
      var yu = !1, mu;
      {
        var If = typeof WeakMap == "function" ? WeakMap : Map;
        mu = new If();
      }
      function Df(Kt, vr) {
        if (!Kt || yu)
          return "";
        {
          var Pr = mu.get(Kt);
          if (Pr !== void 0)
            return Pr;
        }
        var Hr;
        yu = !0;
        var an = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Zn;
        Zn = ds.current, ds.current = null, Pf();
        try {
          if (vr) {
            var wn = function() {
              throw Error();
            };
            if (Object.defineProperty(wn.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(wn, []);
              } catch (Ei) {
                Hr = Ei;
              }
              Reflect.construct(Kt, [], wn);
            } else {
              try {
                wn.call();
              } catch (Ei) {
                Hr = Ei;
              }
              Kt.call(wn.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Ei) {
              Hr = Ei;
            }
            Kt();
          }
        } catch (Ei) {
          if (Ei && Hr && typeof Ei.stack == "string") {
            for (var Qn = Ei.stack.split(`
`), yi = Hr.stack.split(`
`), Ai = Qn.length - 1, ji = yi.length - 1; Ai >= 1 && ji >= 0 && Qn[Ai] !== yi[ji]; )
              ji--;
            for (; Ai >= 1 && ji >= 0; Ai--, ji--)
              if (Qn[Ai] !== yi[ji]) {
                if (Ai !== 1 || ji !== 1)
                  do
                    if (Ai--, ji--, ji < 0 || Qn[Ai] !== yi[ji]) {
                      var Ui = `
` + Qn[Ai].replace(" at new ", " at ");
                      return Kt.displayName && Ui.includes("<anonymous>") && (Ui = Ui.replace("<anonymous>", Kt.displayName)), typeof Kt == "function" && mu.set(Kt, Ui), Ui;
                    }
                  while (Ai >= 1 && ji >= 0);
                break;
              }
          }
        } finally {
          yu = !1, ds.current = Zn, pu(), Error.prepareStackTrace = an;
        }
        var zi = Kt ? Kt.displayName || Kt.name : "", Ki = zi ? vu(zi) : "";
        return typeof Kt == "function" && mu.set(Kt, Ki), Ki;
      }
      function Us(Kt, vr, Pr) {
        return Df(Kt, !1);
      }
      function Yh(Kt) {
        var vr = Kt.prototype;
        return !!(vr && vr.isReactComponent);
      }
      function Ss(Kt, vr, Pr) {
        if (Kt == null)
          return "";
        if (typeof Kt == "function")
          return Df(Kt, Yh(Kt));
        if (typeof Kt == "string")
          return vu(Kt);
        switch (Kt) {
          case lt:
            return vu("Suspense");
          case Et:
            return vu("SuspenseList");
        }
        if (typeof Kt == "object")
          switch (Kt.$$typeof) {
            case it:
              return Us(Kt.render);
            case wt:
              return Ss(Kt.type, vr, Pr);
            case Rt: {
              var Hr = Kt, an = Hr._payload, Zn = Hr._init;
              try {
                return Ss(Zn(an), vr, Pr);
              } catch {
              }
            }
          }
        return "";
      }
      var Ci = {}, Nf = ut.ReactDebugCurrentFrame;
      function Gu(Kt) {
        if (Kt) {
          var vr = Kt._owner, Pr = Ss(Kt.type, Kt._source, vr ? vr.type : null);
          Nf.setExtraStackFrame(Pr);
        } else
          Nf.setExtraStackFrame(null);
      }
      function Lf(Kt, vr, Pr, Hr, an) {
        {
          var Zn = Function.call.bind(xn);
          for (var wn in Kt)
            if (Zn(Kt, wn)) {
              var Qn = void 0;
              try {
                if (typeof Kt[wn] != "function") {
                  var yi = Error((Hr || "React class") + ": " + Pr + " type `" + wn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Kt[wn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw yi.name = "Invariant Violation", yi;
                }
                Qn = Kt[wn](vr, wn, Hr, Pr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Ai) {
                Qn = Ai;
              }
              Qn && !(Qn instanceof Error) && (Gu(an), gt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Hr || "React class", Pr, wn, typeof Qn), Gu(null)), Qn instanceof Error && !(Qn.message in Ci) && (Ci[Qn.message] = !0, Gu(an), gt("Failed %s type: %s", Pr, Qn.message), Gu(null));
            }
        }
      }
      function Si(Kt) {
        if (Kt) {
          var vr = Kt._owner, Pr = Ss(Kt.type, Kt._source, vr ? vr.type : null);
          Ut(Pr);
        } else
          Ut(null);
      }
      var Uf;
      Uf = !1;
      function Ff() {
        if (Vt.current) {
          var Kt = Wn(Vt.current.type);
          if (Kt)
            return `

Check the render method of \`` + Kt + "`.";
        }
        return "";
      }
      function ui(Kt) {
        if (Kt !== void 0) {
          var vr = Kt.fileName.replace(/^.*[\\\/]/, ""), Pr = Kt.lineNumber;
          return `

Check your code at ` + vr + ":" + Pr + ".";
        }
        return "";
      }
      function Xu(Kt) {
        return Kt != null ? ui(Kt.__source) : "";
      }
      var na = {};
      function vo(Kt) {
        var vr = Ff();
        if (!vr) {
          var Pr = typeof Kt == "string" ? Kt : Kt.displayName || Kt.name;
          Pr && (vr = `

Check the top-level render call using <` + Pr + ">.");
        }
        return vr;
      }
      function ro(Kt, vr) {
        if (!(!Kt._store || Kt._store.validated || Kt.key != null)) {
          Kt._store.validated = !0;
          var Pr = vo(vr);
          if (!na[Pr]) {
            na[Pr] = !0;
            var Hr = "";
            Kt && Kt._owner && Kt._owner !== Vt.current && (Hr = " It was passed a child from " + Wn(Kt._owner.type) + "."), Si(Kt), gt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Pr, Hr), Si(null);
          }
        }
      }
      function gu(Kt, vr) {
        if (typeof Kt == "object") {
          if (br(Kt))
            for (var Pr = 0; Pr < Kt.length; Pr++) {
              var Hr = Kt[Pr];
              Sr(Hr) && ro(Hr, vr);
            }
          else if (Sr(Kt))
            Kt._store && (Kt._store.validated = !0);
          else if (Kt) {
            var an = Ot(Kt);
            if (typeof an == "function" && an !== Kt.entries)
              for (var Zn = an.call(Kt), wn; !(wn = Zn.next()).done; )
                Sr(wn.value) && ro(wn.value, vr);
          }
        }
      }
      function ua(Kt) {
        {
          var vr = Kt.type;
          if (vr == null || typeof vr == "string")
            return;
          var Pr;
          if (typeof vr == "function")
            Pr = vr.propTypes;
          else if (typeof vr == "object" && (vr.$$typeof === it || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          vr.$$typeof === wt))
            Pr = vr.propTypes;
          else
            return;
          if (Pr) {
            var Hr = Wn(vr);
            Lf(Pr, Kt.props, "prop", Hr, Kt);
          } else if (vr.PropTypes !== void 0 && !Uf) {
            Uf = !0;
            var an = Wn(vr);
            gt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", an || "Unknown");
          }
          typeof vr.getDefaultProps == "function" && !vr.getDefaultProps.isReactClassApproved && gt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Ii(Kt) {
        {
          for (var vr = Object.keys(Kt.props), Pr = 0; Pr < vr.length; Pr++) {
            var Hr = vr[Pr];
            if (Hr !== "children" && Hr !== "key") {
              Si(Kt), gt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Hr), Si(null);
              break;
            }
          }
          Kt.ref !== null && (Si(Kt), gt("Invalid attribute `ref` supplied to `React.Fragment`."), Si(null));
        }
      }
      function ed(Kt, vr, Pr) {
        var Hr = fr(Kt);
        if (!Hr) {
          var an = "";
          (Kt === void 0 || typeof Kt == "object" && Kt !== null && Object.keys(Kt).length === 0) && (an += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Zn = Xu(vr);
          Zn ? an += Zn : an += Ff();
          var wn;
          Kt === null ? wn = "null" : br(Kt) ? wn = "array" : Kt !== void 0 && Kt.$$typeof === ne ? (wn = "<" + (Wn(Kt.type) || "Unknown") + " />", an = " Did you accidentally export a JSX literal instead of a component?") : wn = typeof Kt, gt("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", wn, an);
        }
        var Qn = kt.apply(this, arguments);
        if (Qn == null)
          return Qn;
        if (Hr)
          for (var yi = 2; yi < arguments.length; yi++)
            gu(arguments[yi], Kt);
        return Kt === ce ? Ii(Qn) : ua(Qn), Qn;
      }
      var yo = !1;
      function Ba(Kt) {
        var vr = ed.bind(null, Kt);
        return vr.type = Kt, yo || (yo = !0, mt("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(vr, "type", {
          enumerable: !1,
          get: function() {
            return mt("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: Kt
            }), Kt;
          }
        }), vr;
      }
      function Es(Kt, vr, Pr) {
        for (var Hr = pr.apply(this, arguments), an = 2; an < arguments.length; an++)
          gu(arguments[an], Hr.type);
        return ua(Hr), Hr;
      }
      function td(Kt, vr) {
        var Pr = Ft.transition;
        Ft.transition = {};
        var Hr = Ft.transition;
        Ft.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          Kt();
        } finally {
          if (Ft.transition = Pr, Pr === null && Hr._updatedFibers) {
            var an = Hr._updatedFibers.size;
            an > 10 && mt("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Hr._updatedFibers.clear();
          }
        }
      }
      var Fs = !1, bu = null;
      function rd(Kt) {
        if (bu === null)
          try {
            var vr = ("require" + Math.random()).slice(0, 7), Pr = B && B[vr];
            bu = Pr.call(B, "timers").setImmediate;
          } catch {
            bu = function(an) {
              Fs === !1 && (Fs = !0, typeof MessageChannel > "u" && gt("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Zn = new MessageChannel();
              Zn.port1.onmessage = an, Zn.port2.postMessage(void 0);
            };
          }
        return bu(Kt);
      }
      var Wo = 0, wu = !1;
      function Hs(Kt) {
        {
          var vr = Wo;
          Wo++, Jt.current === null && (Jt.current = []);
          var Pr = Jt.isBatchingLegacy, Hr;
          try {
            if (Jt.isBatchingLegacy = !0, Hr = Kt(), !Pr && Jt.didScheduleLegacyUpdate) {
              var an = Jt.current;
              an !== null && (Jt.didScheduleLegacyUpdate = !1, Su(an));
            }
          } catch (zi) {
            throw Ko(vr), zi;
          } finally {
            Jt.isBatchingLegacy = Pr;
          }
          if (Hr !== null && typeof Hr == "object" && typeof Hr.then == "function") {
            var Zn = Hr, wn = !1, Qn = {
              then: function(zi, Ki) {
                wn = !0, Zn.then(function(Ei) {
                  Ko(vr), Wo === 0 ? Hf(Ei, zi, Ki) : zi(Ei);
                }, function(Ei) {
                  Ko(vr), Ki(Ei);
                });
              }
            };
            return !wu && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              wn || (wu = !0, gt("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Qn;
          } else {
            var yi = Hr;
            if (Ko(vr), Wo === 0) {
              var Ai = Jt.current;
              Ai !== null && (Su(Ai), Jt.current = null);
              var ji = {
                then: function(zi, Ki) {
                  Jt.current === null ? (Jt.current = [], Hf(yi, zi, Ki)) : zi(yi);
                }
              };
              return ji;
            } else {
              var Ui = {
                then: function(zi, Ki) {
                  zi(yi);
                }
              };
              return Ui;
            }
          }
        }
      }
      function Ko(Kt) {
        Kt !== Wo - 1 && gt("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Wo = Kt;
      }
      function Hf(Kt, vr, Pr) {
        {
          var Hr = Jt.current;
          if (Hr !== null)
            try {
              Su(Hr), rd(function() {
                Hr.length === 0 ? (Jt.current = null, vr(Kt)) : Hf(Kt, vr, Pr);
              });
            } catch (an) {
              Pr(an);
            }
          else
            vr(Kt);
        }
      }
      var _u = !1;
      function Su(Kt) {
        if (!_u) {
          _u = !0;
          var vr = 0;
          try {
            for (; vr < Kt.length; vr++) {
              var Pr = Kt[vr];
              do
                Pr = Pr(!0);
              while (Pr !== null);
            }
            Kt.length = 0;
          } catch (Hr) {
            throw Kt = Kt.slice(vr + 1), Hr;
          } finally {
            _u = !1;
          }
        }
      }
      var Yu = ed, jf = Es, Xl = Ba, hs = {
        map: pi,
        forEach: ir,
        count: ur,
        toArray: lr,
        only: gr
      };
      L.Children = hs, L.Component = rr, L.Fragment = ce, L.Profiler = rt, L.PureComponent = or, L.StrictMode = Ce, L.Suspense = lt, L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ut, L.act = Hs, L.cloneElement = jf, L.createContext = Ar, L.createElement = Yu, L.createFactory = Xl, L.createRef = Xt, L.forwardRef = Cn, L.isValidElement = Sr, L.lazy = vn, L.memo = Nr, L.startTransition = td, L.unstable_act = Hs, L.useCallback = Ri, L.useContext = sn, L.useDebugValue = vi, L.useDeferredValue = ra, L.useEffect = Jn, L.useId = ii, L.useImperativeHandle = Ca, L.useInsertionEffect = Ti, L.useLayoutEffect = _i, L.useMemo = Qi, L.useReducer = kn, L.useRef = Dn, L.useState = Tn, L.useSyncExternalStore = ma, L.useTransition = Wi, L.version = J, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(react_development, react_development.exports)), react_development.exports;
}
process$1.env.NODE_ENV === "production" ? react.exports = requireReact_production_min() : react.exports = requireReact_development();
var reactExports = react.exports;
const m$4 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports), e$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: m$4
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = reactExports, L = Symbol.for("react.element"), J = Symbol.for("react.fragment"), ne = Object.prototype.hasOwnProperty, oe = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ce = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Ce(rt, at, ht) {
    var it, lt = {}, Et = null, wt = null;
    ht !== void 0 && (Et = "" + ht), at.key !== void 0 && (Et = "" + at.key), at.ref !== void 0 && (wt = at.ref);
    for (it in at) ne.call(at, it) && !ce.hasOwnProperty(it) && (lt[it] = at[it]);
    if (rt && rt.defaultProps) for (it in at = rt.defaultProps, at) lt[it] === void 0 && (lt[it] = at[it]);
    return { $$typeof: L, type: rt, key: Et, ref: wt, props: lt, _owner: oe.current };
  }
  return reactJsxRuntime_production_min.Fragment = J, reactJsxRuntime_production_min.jsx = Ce, reactJsxRuntime_production_min.jsxs = Ce, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = reactExports, L = Symbol.for("react.element"), J = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), oe = Symbol.for("react.strict_mode"), ce = Symbol.for("react.profiler"), Ce = Symbol.for("react.provider"), rt = Symbol.for("react.context"), at = Symbol.for("react.forward_ref"), ht = Symbol.for("react.suspense"), it = Symbol.for("react.suspense_list"), lt = Symbol.for("react.memo"), Et = Symbol.for("react.lazy"), wt = Symbol.for("react.offscreen"), Rt = Symbol.iterator, Mt = "@@iterator";
    function Lt(fr) {
      if (fr === null || typeof fr != "object")
        return null;
      var Nr = Rt && fr[Rt] || fr[Mt];
      return typeof Nr == "function" ? Nr : null;
    }
    var zt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Ot(fr) {
      {
        for (var Nr = arguments.length, Ir = new Array(Nr > 1 ? Nr - 1 : 0), sn = 1; sn < Nr; sn++)
          Ir[sn - 1] = arguments[sn];
        It("error", fr, Ir);
      }
    }
    function It(fr, Nr, Ir) {
      {
        var sn = zt.ReactDebugCurrentFrame, Tn = sn.getStackAddendum();
        Tn !== "" && (Nr += "%s", Ir = Ir.concat([Tn]));
        var kn = Ir.map(function(Dn) {
          return String(Dn);
        });
        kn.unshift("Warning: " + Nr), Function.prototype.apply.call(console[fr], console, kn);
      }
    }
    var Ft = !1, Jt = !1, Vt = !1, yr = !1, jt = !1, Ut;
    Ut = Symbol.for("react.module.reference");
    function er(fr) {
      return !!(typeof fr == "string" || typeof fr == "function" || fr === ne || fr === ce || jt || fr === oe || fr === ht || fr === it || yr || fr === wt || Ft || Jt || Vt || typeof fr == "object" && fr !== null && (fr.$$typeof === Et || fr.$$typeof === lt || fr.$$typeof === Ce || fr.$$typeof === rt || fr.$$typeof === at || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      fr.$$typeof === Ut || fr.getModuleId !== void 0));
    }
    function Ht(fr, Nr, Ir) {
      var sn = fr.displayName;
      if (sn)
        return sn;
      var Tn = Nr.displayName || Nr.name || "";
      return Tn !== "" ? Ir + "(" + Tn + ")" : Ir;
    }
    function ct(fr) {
      return fr.displayName || "Context";
    }
    function dt(fr) {
      if (fr == null)
        return null;
      if (typeof fr.tag == "number" && Ot("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof fr == "function")
        return fr.displayName || fr.name || null;
      if (typeof fr == "string")
        return fr;
      switch (fr) {
        case ne:
          return "Fragment";
        case J:
          return "Portal";
        case ce:
          return "Profiler";
        case oe:
          return "StrictMode";
        case ht:
          return "Suspense";
        case it:
          return "SuspenseList";
      }
      if (typeof fr == "object")
        switch (fr.$$typeof) {
          case rt:
            var Nr = fr;
            return ct(Nr) + ".Consumer";
          case Ce:
            var Ir = fr;
            return ct(Ir._context) + ".Provider";
          case at:
            return Ht(fr, fr.render, "ForwardRef");
          case lt:
            var sn = fr.displayName || null;
            return sn !== null ? sn : dt(fr.type) || "Memo";
          case Et: {
            var Tn = fr, kn = Tn._payload, Dn = Tn._init;
            try {
              return dt(Dn(kn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ot = Object.assign, ut = 0, mt, gt, St, xt, vt, $t, yt;
    function Bt() {
    }
    Bt.__reactDisabledLog = !0;
    function rr() {
      {
        if (ut === 0) {
          mt = console.log, gt = console.info, St = console.warn, xt = console.error, vt = console.group, $t = console.groupCollapsed, yt = console.groupEnd;
          var fr = {
            configurable: !0,
            enumerable: !0,
            value: Bt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: fr,
            log: fr,
            warn: fr,
            error: fr,
            group: fr,
            groupCollapsed: fr,
            groupEnd: fr
          });
        }
        ut++;
      }
    }
    function dr() {
      {
        if (ut--, ut === 0) {
          var fr = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ot({}, fr, {
              value: mt
            }),
            info: ot({}, fr, {
              value: gt
            }),
            warn: ot({}, fr, {
              value: St
            }),
            error: ot({}, fr, {
              value: xt
            }),
            group: ot({}, fr, {
              value: vt
            }),
            groupCollapsed: ot({}, fr, {
              value: $t
            }),
            groupEnd: ot({}, fr, {
              value: yt
            })
          });
        }
        ut < 0 && Ot("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var tr = zt.ReactCurrentDispatcher, Dt;
    function Wt(fr, Nr, Ir) {
      {
        if (Dt === void 0)
          try {
            throw Error();
          } catch (Tn) {
            var sn = Tn.stack.trim().match(/\n( *(at )?)/);
            Dt = sn && sn[1] || "";
          }
        return `
` + Dt + fr;
      }
    }
    var or = !1, _r;
    {
      var Xt = typeof WeakMap == "function" ? WeakMap : Map;
      _r = new Xt();
    }
    function Qt(fr, Nr) {
      if (!fr || or)
        return "";
      {
        var Ir = _r.get(fr);
        if (Ir !== void 0)
          return Ir;
      }
      var sn;
      or = !0;
      var Tn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var kn;
      kn = tr.current, tr.current = null, rr();
      try {
        if (Nr) {
          var Dn = function() {
            throw Error();
          };
          if (Object.defineProperty(Dn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Dn, []);
            } catch (Wi) {
              sn = Wi;
            }
            Reflect.construct(fr, [], Dn);
          } else {
            try {
              Dn.call();
            } catch (Wi) {
              sn = Wi;
            }
            fr.call(Dn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Wi) {
            sn = Wi;
          }
          fr();
        }
      } catch (Wi) {
        if (Wi && sn && typeof Wi.stack == "string") {
          for (var Jn = Wi.stack.split(`
`), Ti = sn.stack.split(`
`), _i = Jn.length - 1, Ri = Ti.length - 1; _i >= 1 && Ri >= 0 && Jn[_i] !== Ti[Ri]; )
            Ri--;
          for (; _i >= 1 && Ri >= 0; _i--, Ri--)
            if (Jn[_i] !== Ti[Ri]) {
              if (_i !== 1 || Ri !== 1)
                do
                  if (_i--, Ri--, Ri < 0 || Jn[_i] !== Ti[Ri]) {
                    var Qi = `
` + Jn[_i].replace(" at new ", " at ");
                    return fr.displayName && Qi.includes("<anonymous>") && (Qi = Qi.replace("<anonymous>", fr.displayName)), typeof fr == "function" && _r.set(fr, Qi), Qi;
                  }
                while (_i >= 1 && Ri >= 0);
              break;
            }
        }
      } finally {
        or = !1, tr.current = kn, dr(), Error.prepareStackTrace = Tn;
      }
      var Ca = fr ? fr.displayName || fr.name : "", vi = Ca ? Wt(Ca) : "";
      return typeof fr == "function" && _r.set(fr, vi), vi;
    }
    function br(fr, Nr, Ir) {
      return Qt(fr, !1);
    }
    function Dr(fr) {
      var Nr = fr.prototype;
      return !!(Nr && Nr.isReactComponent);
    }
    function Vr(fr, Nr, Ir) {
      if (fr == null)
        return "";
      if (typeof fr == "function")
        return Qt(fr, Dr(fr));
      if (typeof fr == "string")
        return Wt(fr);
      switch (fr) {
        case ht:
          return Wt("Suspense");
        case it:
          return Wt("SuspenseList");
      }
      if (typeof fr == "object")
        switch (fr.$$typeof) {
          case at:
            return br(fr.render);
          case lt:
            return Vr(fr.type, Nr, Ir);
          case Et: {
            var sn = fr, Tn = sn._payload, kn = sn._init;
            try {
              return Vr(kn(Tn), Nr, Ir);
            } catch {
            }
          }
        }
      return "";
    }
    var Zr = Object.prototype.hasOwnProperty, ln = {}, _n = zt.ReactDebugCurrentFrame;
    function Mr(fr) {
      if (fr) {
        var Nr = fr._owner, Ir = Vr(fr.type, fr._source, Nr ? Nr.type : null);
        _n.setExtraStackFrame(Ir);
      } else
        _n.setExtraStackFrame(null);
    }
    function Wn(fr, Nr, Ir, sn, Tn) {
      {
        var kn = Function.call.bind(Zr);
        for (var Dn in fr)
          if (kn(fr, Dn)) {
            var Jn = void 0;
            try {
              if (typeof fr[Dn] != "function") {
                var Ti = Error((sn || "React class") + ": " + Ir + " type `" + Dn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof fr[Dn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ti.name = "Invariant Violation", Ti;
              }
              Jn = fr[Dn](Nr, Dn, sn, Ir, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (_i) {
              Jn = _i;
            }
            Jn && !(Jn instanceof Error) && (Mr(Tn), Ot("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", sn || "React class", Ir, Dn, typeof Jn), Mr(null)), Jn instanceof Error && !(Jn.message in ln) && (ln[Jn.message] = !0, Mr(Tn), Ot("Failed %s type: %s", Ir, Jn.message), Mr(null));
          }
      }
    }
    var xn = Array.isArray;
    function ni(fr) {
      return xn(fr);
    }
    function Gn(fr) {
      {
        var Nr = typeof Symbol == "function" && Symbol.toStringTag, Ir = Nr && fr[Symbol.toStringTag] || fr.constructor.name || "Object";
        return Ir;
      }
    }
    function En(fr) {
      try {
        return Pn(fr), !1;
      } catch {
        return !0;
      }
    }
    function Pn(fr) {
      return "" + fr;
    }
    function ti(fr) {
      if (En(fr))
        return Ot("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Gn(fr)), Pn(fr);
    }
    var gn = zt.ReactCurrentOwner, Kn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, gi, Gt, At;
    At = {};
    function kt(fr) {
      if (Zr.call(fr, "ref")) {
        var Nr = Object.getOwnPropertyDescriptor(fr, "ref").get;
        if (Nr && Nr.isReactWarning)
          return !1;
      }
      return fr.ref !== void 0;
    }
    function Zt(fr) {
      if (Zr.call(fr, "key")) {
        var Nr = Object.getOwnPropertyDescriptor(fr, "key").get;
        if (Nr && Nr.isReactWarning)
          return !1;
      }
      return fr.key !== void 0;
    }
    function pr(fr, Nr) {
      if (typeof fr.ref == "string" && gn.current && Nr && gn.current.stateNode !== Nr) {
        var Ir = dt(gn.current.type);
        At[Ir] || (Ot('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', dt(gn.current.type), fr.ref), At[Ir] = !0);
      }
    }
    function Sr(fr, Nr) {
      {
        var Ir = function() {
          gi || (gi = !0, Ot("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Nr));
        };
        Ir.isReactWarning = !0, Object.defineProperty(fr, "key", {
          get: Ir,
          configurable: !0
        });
      }
    }
    function Tr(fr, Nr) {
      {
        var Ir = function() {
          Gt || (Gt = !0, Ot("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Nr));
        };
        Ir.isReactWarning = !0, Object.defineProperty(fr, "ref", {
          get: Ir,
          configurable: !0
        });
      }
    }
    var fn = function(fr, Nr, Ir, sn, Tn, kn, Dn) {
      var Jn = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: L,
        // Built-in properties that belong on the element
        type: fr,
        key: Nr,
        ref: Ir,
        props: Dn,
        // Record the component responsible for creating this element.
        _owner: kn
      };
      return Jn._store = {}, Object.defineProperty(Jn._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Jn, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: sn
      }), Object.defineProperty(Jn, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Tn
      }), Object.freeze && (Object.freeze(Jn.props), Object.freeze(Jn)), Jn;
    };
    function On(fr, Nr, Ir, sn, Tn) {
      {
        var kn, Dn = {}, Jn = null, Ti = null;
        Ir !== void 0 && (ti(Ir), Jn = "" + Ir), Zt(Nr) && (ti(Nr.key), Jn = "" + Nr.key), kt(Nr) && (Ti = Nr.ref, pr(Nr, Tn));
        for (kn in Nr)
          Zr.call(Nr, kn) && !Kn.hasOwnProperty(kn) && (Dn[kn] = Nr[kn]);
        if (fr && fr.defaultProps) {
          var _i = fr.defaultProps;
          for (kn in _i)
            Dn[kn] === void 0 && (Dn[kn] = _i[kn]);
        }
        if (Jn || Ti) {
          var Ri = typeof fr == "function" ? fr.displayName || fr.name || "Unknown" : fr;
          Jn && Sr(Dn, Ri), Ti && Tr(Dn, Ri);
        }
        return fn(fr, Jn, Ti, Tn, sn, gn.current, Dn);
      }
    }
    var tn = zt.ReactCurrentOwner, In = zt.ReactDebugCurrentFrame;
    function hn(fr) {
      if (fr) {
        var Nr = fr._owner, Ir = Vr(fr.type, fr._source, Nr ? Nr.type : null);
        In.setExtraStackFrame(Ir);
      } else
        In.setExtraStackFrame(null);
    }
    var cn;
    cn = !1;
    function ci(fr) {
      return typeof fr == "object" && fr !== null && fr.$$typeof === L;
    }
    function pi() {
      {
        if (tn.current) {
          var fr = dt(tn.current.type);
          if (fr)
            return `

Check the render method of \`` + fr + "`.";
        }
        return "";
      }
    }
    function ur(fr) {
      return "";
    }
    var ir = {};
    function lr(fr) {
      {
        var Nr = pi();
        if (!Nr) {
          var Ir = typeof fr == "string" ? fr : fr.displayName || fr.name;
          Ir && (Nr = `

Check the top-level render call using <` + Ir + ">.");
        }
        return Nr;
      }
    }
    function gr(fr, Nr) {
      {
        if (!fr._store || fr._store.validated || fr.key != null)
          return;
        fr._store.validated = !0;
        var Ir = lr(Nr);
        if (ir[Ir])
          return;
        ir[Ir] = !0;
        var sn = "";
        fr && fr._owner && fr._owner !== tn.current && (sn = " It was passed a child from " + dt(fr._owner.type) + "."), hn(fr), Ot('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ir, sn), hn(null);
      }
    }
    function Ar(fr, Nr) {
      {
        if (typeof fr != "object")
          return;
        if (ni(fr))
          for (var Ir = 0; Ir < fr.length; Ir++) {
            var sn = fr[Ir];
            ci(sn) && gr(sn, Nr);
          }
        else if (ci(fr))
          fr._store && (fr._store.validated = !0);
        else if (fr) {
          var Tn = Lt(fr);
          if (typeof Tn == "function" && Tn !== fr.entries)
            for (var kn = Tn.call(fr), Dn; !(Dn = kn.next()).done; )
              ci(Dn.value) && gr(Dn.value, Nr);
        }
      }
    }
    function Fr(fr) {
      {
        var Nr = fr.type;
        if (Nr == null || typeof Nr == "string")
          return;
        var Ir;
        if (typeof Nr == "function")
          Ir = Nr.propTypes;
        else if (typeof Nr == "object" && (Nr.$$typeof === at || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Nr.$$typeof === lt))
          Ir = Nr.propTypes;
        else
          return;
        if (Ir) {
          var sn = dt(Nr);
          Wn(Ir, fr.props, "prop", sn, fr);
        } else if (Nr.PropTypes !== void 0 && !cn) {
          cn = !0;
          var Tn = dt(Nr);
          Ot("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Tn || "Unknown");
        }
        typeof Nr.getDefaultProps == "function" && !Nr.getDefaultProps.isReactClassApproved && Ot("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function jr(fr) {
      {
        for (var Nr = Object.keys(fr.props), Ir = 0; Ir < Nr.length; Ir++) {
          var sn = Nr[Ir];
          if (sn !== "children" && sn !== "key") {
            hn(fr), Ot("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", sn), hn(null);
            break;
          }
        }
        fr.ref !== null && (hn(fr), Ot("Invalid attribute `ref` supplied to `React.Fragment`."), hn(null));
      }
    }
    var Xr = {};
    function pn(fr, Nr, Ir, sn, Tn, kn) {
      {
        var Dn = er(fr);
        if (!Dn) {
          var Jn = "";
          (fr === void 0 || typeof fr == "object" && fr !== null && Object.keys(fr).length === 0) && (Jn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ti = ur();
          Ti ? Jn += Ti : Jn += pi();
          var _i;
          fr === null ? _i = "null" : ni(fr) ? _i = "array" : fr !== void 0 && fr.$$typeof === L ? (_i = "<" + (dt(fr.type) || "Unknown") + " />", Jn = " Did you accidentally export a JSX literal instead of a component?") : _i = typeof fr, Ot("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", _i, Jn);
        }
        var Ri = On(fr, Nr, Ir, Tn, kn);
        if (Ri == null)
          return Ri;
        if (Dn) {
          var Qi = Nr.children;
          if (Qi !== void 0)
            if (sn)
              if (ni(Qi)) {
                for (var Ca = 0; Ca < Qi.length; Ca++)
                  Ar(Qi[Ca], fr);
                Object.freeze && Object.freeze(Qi);
              } else
                Ot("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ar(Qi, fr);
        }
        if (Zr.call(Nr, "key")) {
          var vi = dt(fr), Wi = Object.keys(Nr).filter(function(ma) {
            return ma !== "key";
          }), ra = Wi.length > 0 ? "{key: someKey, " + Wi.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Xr[vi + ra]) {
            var ii = Wi.length > 0 ? "{" + Wi.join(": ..., ") + ": ...}" : "{}";
            Ot(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ra, vi, ii, vi), Xr[vi + ra] = !0;
          }
        }
        return fr === ne ? jr(Ri) : Fr(Ri), Ri;
      }
    }
    function Yr(fr, Nr, Ir) {
      return pn(fr, Nr, Ir, !0);
    }
    function vn(fr, Nr, Ir) {
      return pn(fr, Nr, Ir, !1);
    }
    var Cn = vn, dn = Yr;
    reactJsxRuntime_development.Fragment = ne, reactJsxRuntime_development.jsx = Cn, reactJsxRuntime_development.jsxs = dn;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, L] = reactExports.useState(!1);
  return reactExports.useEffect(() => {
    L(!0);
  }, []), B;
}
const KEY_PREFIX = "wallie";
function isBrowser() {
  return typeof window < "u";
}
function getItemFromLocalStorage(B) {
  if (!isBrowser())
    return null;
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${B}`;
  try {
    const J = window.localStorage.getItem(L);
    return J != null ? JSON.parse(J) : null;
  } catch (J) {
    return console.error(`Error retrieving ${L} from localStorage`, J), null;
  }
}
function setItemToLocalStorage(B, L) {
  if (!isBrowser())
    return;
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const J = `${KEY_PREFIX}_${B}`;
  try {
    L ? window.localStorage.setItem(J, JSON.stringify(L)) : window.localStorage.removeItem(J);
  } catch (ne) {
    console.error(`Error saving ${J} to localStorage`, ne);
  }
}
function useLocalStorage(B, L, J = {}) {
  const { initializeWithValue: ne = !0 } = J, oe = reactExports.useCallback(() => {
    const at = getItemFromLocalStorage(B);
    return at || (setItemToLocalStorage(B, L), L);
  }, [L, B]), [ce, Ce] = reactExports.useState(() => ne ? oe() : L), rt = reactExports.useCallback(
    (at) => {
      setItemToLocalStorage(B, at), Ce(at);
    },
    [B]
  );
  return reactExports.useEffect(() => {
    Ce(oe());
  }, [B]), [ce, rt];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, WallieContext = reactExports.createContext(void 0), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function WallieProvider({
  children: B,
  initialNetwork: L,
  ssr: J = !1
}) {
  if (!L)
    throw new Error("Initial network cannot be empty");
  const [ne, oe] = reactExports.useState(L), [ce, Ce] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [rt, at] = useLocalStorage(WALLET, null, {
    initializeWithValue: !J
  }), [ht, it] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [lt, Et] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [wt, Rt] = reactExports.useState(!1), Mt = reactExports.useCallback(() => Rt(!0), []), Lt = reactExports.useCallback(() => Rt(!1), []), zt = reactExports.useCallback(() => {
    Ce(EMPTY_BIADDRESS_OBJECT), it(EMPTY_BIADDRESS_OBJECT), Et(EMPTY_BIADDRESS_OBJECT), at(null);
  }, [Ce, Et, it, at]), Ot = reactExports.useMemo(
    () => ({
      address: ce,
      updateAddress: Ce,
      publicKey: ht,
      updatePublicKey: it,
      network: ne,
      updateNetwork: oe,
      wallet: rt,
      updateWallet: at,
      isModalOpen: wt,
      openModal: Mt,
      closeModal: Lt,
      format: lt,
      updateFormat: Et,
      disconnectWallet: zt
    }),
    [
      ce,
      Ce,
      ht,
      it,
      ne,
      oe,
      rt,
      at,
      wt,
      Mt,
      Lt,
      lt,
      Et,
      zt
    ]
  );
  return reactExports.useEffect(() => {
    oe(L);
  }, [L]), /* @__PURE__ */ jsxRuntimeExports.jsx(WallieContext.Provider, { value: Ot, children: B });
}
function useWallie() {
  const B = reactExports.useContext(WallieContext);
  if (!B)
    throw new Error("useWallie must be used within WallieProvider");
  return B;
}
var reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  return hasRequiredScheduler_production_min || (hasRequiredScheduler_production_min = 1, function(B) {
    function L(St, xt) {
      var vt = St.length;
      St.push(xt);
      e: for (; 0 < vt; ) {
        var $t = vt - 1 >>> 1, yt = St[$t];
        if (0 < oe(yt, xt)) St[$t] = xt, St[vt] = yt, vt = $t;
        else break e;
      }
    }
    function J(St) {
      return St.length === 0 ? null : St[0];
    }
    function ne(St) {
      if (St.length === 0) return null;
      var xt = St[0], vt = St.pop();
      if (vt !== xt) {
        St[0] = vt;
        e: for (var $t = 0, yt = St.length, Bt = yt >>> 1; $t < Bt; ) {
          var rr = 2 * ($t + 1) - 1, dr = St[rr], tr = rr + 1, Dt = St[tr];
          if (0 > oe(dr, vt)) tr < yt && 0 > oe(Dt, dr) ? (St[$t] = Dt, St[tr] = vt, $t = tr) : (St[$t] = dr, St[rr] = vt, $t = rr);
          else if (tr < yt && 0 > oe(Dt, vt)) St[$t] = Dt, St[tr] = vt, $t = tr;
          else break e;
        }
      }
      return xt;
    }
    function oe(St, xt) {
      var vt = St.sortIndex - xt.sortIndex;
      return vt !== 0 ? vt : St.id - xt.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var ce = performance;
      B.unstable_now = function() {
        return ce.now();
      };
    } else {
      var Ce = Date, rt = Ce.now();
      B.unstable_now = function() {
        return Ce.now() - rt;
      };
    }
    var at = [], ht = [], it = 1, lt = null, Et = 3, wt = !1, Rt = !1, Mt = !1, Lt = typeof setTimeout == "function" ? setTimeout : null, zt = typeof clearTimeout == "function" ? clearTimeout : null, Ot = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function It(St) {
      for (var xt = J(ht); xt !== null; ) {
        if (xt.callback === null) ne(ht);
        else if (xt.startTime <= St) ne(ht), xt.sortIndex = xt.expirationTime, L(at, xt);
        else break;
        xt = J(ht);
      }
    }
    function Ft(St) {
      if (Mt = !1, It(St), !Rt) if (J(at) !== null) Rt = !0, mt(Jt);
      else {
        var xt = J(ht);
        xt !== null && gt(Ft, xt.startTime - St);
      }
    }
    function Jt(St, xt) {
      Rt = !1, Mt && (Mt = !1, zt(jt), jt = -1), wt = !0;
      var vt = Et;
      try {
        for (It(xt), lt = J(at); lt !== null && (!(lt.expirationTime > xt) || St && !Ht()); ) {
          var $t = lt.callback;
          if (typeof $t == "function") {
            lt.callback = null, Et = lt.priorityLevel;
            var yt = $t(lt.expirationTime <= xt);
            xt = B.unstable_now(), typeof yt == "function" ? lt.callback = yt : lt === J(at) && ne(at), It(xt);
          } else ne(at);
          lt = J(at);
        }
        if (lt !== null) var Bt = !0;
        else {
          var rr = J(ht);
          rr !== null && gt(Ft, rr.startTime - xt), Bt = !1;
        }
        return Bt;
      } finally {
        lt = null, Et = vt, wt = !1;
      }
    }
    var Vt = !1, yr = null, jt = -1, Ut = 5, er = -1;
    function Ht() {
      return !(B.unstable_now() - er < Ut);
    }
    function ct() {
      if (yr !== null) {
        var St = B.unstable_now();
        er = St;
        var xt = !0;
        try {
          xt = yr(!0, St);
        } finally {
          xt ? dt() : (Vt = !1, yr = null);
        }
      } else Vt = !1;
    }
    var dt;
    if (typeof Ot == "function") dt = function() {
      Ot(ct);
    };
    else if (typeof MessageChannel < "u") {
      var ot = new MessageChannel(), ut = ot.port2;
      ot.port1.onmessage = ct, dt = function() {
        ut.postMessage(null);
      };
    } else dt = function() {
      Lt(ct, 0);
    };
    function mt(St) {
      yr = St, Vt || (Vt = !0, dt());
    }
    function gt(St, xt) {
      jt = Lt(function() {
        St(B.unstable_now());
      }, xt);
    }
    B.unstable_IdlePriority = 5, B.unstable_ImmediatePriority = 1, B.unstable_LowPriority = 4, B.unstable_NormalPriority = 3, B.unstable_Profiling = null, B.unstable_UserBlockingPriority = 2, B.unstable_cancelCallback = function(St) {
      St.callback = null;
    }, B.unstable_continueExecution = function() {
      Rt || wt || (Rt = !0, mt(Jt));
    }, B.unstable_forceFrameRate = function(St) {
      0 > St || 125 < St ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ut = 0 < St ? Math.floor(1e3 / St) : 5;
    }, B.unstable_getCurrentPriorityLevel = function() {
      return Et;
    }, B.unstable_getFirstCallbackNode = function() {
      return J(at);
    }, B.unstable_next = function(St) {
      switch (Et) {
        case 1:
        case 2:
        case 3:
          var xt = 3;
          break;
        default:
          xt = Et;
      }
      var vt = Et;
      Et = xt;
      try {
        return St();
      } finally {
        Et = vt;
      }
    }, B.unstable_pauseExecution = function() {
    }, B.unstable_requestPaint = function() {
    }, B.unstable_runWithPriority = function(St, xt) {
      switch (St) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          St = 3;
      }
      var vt = Et;
      Et = St;
      try {
        return xt();
      } finally {
        Et = vt;
      }
    }, B.unstable_scheduleCallback = function(St, xt, vt) {
      var $t = B.unstable_now();
      switch (typeof vt == "object" && vt !== null ? (vt = vt.delay, vt = typeof vt == "number" && 0 < vt ? $t + vt : $t) : vt = $t, St) {
        case 1:
          var yt = -1;
          break;
        case 2:
          yt = 250;
          break;
        case 5:
          yt = 1073741823;
          break;
        case 4:
          yt = 1e4;
          break;
        default:
          yt = 5e3;
      }
      return yt = vt + yt, St = { id: it++, callback: xt, priorityLevel: St, startTime: vt, expirationTime: yt, sortIndex: -1 }, vt > $t ? (St.sortIndex = vt, L(ht, St), J(at) === null && St === J(ht) && (Mt ? (zt(jt), jt = -1) : Mt = !0, gt(Ft, vt - $t))) : (St.sortIndex = yt, L(at, St), Rt || wt || (Rt = !0, mt(Jt))), St;
    }, B.unstable_shouldYield = Ht, B.unstable_wrapCallback = function(St) {
      var xt = Et;
      return function() {
        var vt = Et;
        Et = xt;
        try {
          return St.apply(this, arguments);
        } finally {
          Et = vt;
        }
      };
    };
  }(scheduler_production_min)), scheduler_production_min;
}
var scheduler_development = {}, hasRequiredScheduler_development;
function requireScheduler_development() {
  return hasRequiredScheduler_development || (hasRequiredScheduler_development = 1, function(B) {
    process$1.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var L = !1, J = !1, ne = 5;
      function oe(At, kt) {
        var Zt = At.length;
        At.push(kt), rt(At, kt, Zt);
      }
      function ce(At) {
        return At.length === 0 ? null : At[0];
      }
      function Ce(At) {
        if (At.length === 0)
          return null;
        var kt = At[0], Zt = At.pop();
        return Zt !== kt && (At[0] = Zt, at(At, Zt, 0)), kt;
      }
      function rt(At, kt, Zt) {
        for (var pr = Zt; pr > 0; ) {
          var Sr = pr - 1 >>> 1, Tr = At[Sr];
          if (ht(Tr, kt) > 0)
            At[Sr] = kt, At[pr] = Tr, pr = Sr;
          else
            return;
        }
      }
      function at(At, kt, Zt) {
        for (var pr = Zt, Sr = At.length, Tr = Sr >>> 1; pr < Tr; ) {
          var fn = (pr + 1) * 2 - 1, On = At[fn], tn = fn + 1, In = At[tn];
          if (ht(On, kt) < 0)
            tn < Sr && ht(In, On) < 0 ? (At[pr] = In, At[tn] = kt, pr = tn) : (At[pr] = On, At[fn] = kt, pr = fn);
          else if (tn < Sr && ht(In, kt) < 0)
            At[pr] = In, At[tn] = kt, pr = tn;
          else
            return;
        }
      }
      function ht(At, kt) {
        var Zt = At.sortIndex - kt.sortIndex;
        return Zt !== 0 ? Zt : At.id - kt.id;
      }
      var it = 1, lt = 2, Et = 3, wt = 4, Rt = 5;
      function Mt(At, kt) {
      }
      var Lt = typeof performance == "object" && typeof performance.now == "function";
      if (Lt) {
        var zt = performance;
        B.unstable_now = function() {
          return zt.now();
        };
      } else {
        var Ot = Date, It = Ot.now();
        B.unstable_now = function() {
          return Ot.now() - It;
        };
      }
      var Ft = 1073741823, Jt = -1, Vt = 250, yr = 5e3, jt = 1e4, Ut = Ft, er = [], Ht = [], ct = 1, dt = null, ot = Et, ut = !1, mt = !1, gt = !1, St = typeof setTimeout == "function" ? setTimeout : null, xt = typeof clearTimeout == "function" ? clearTimeout : null, vt = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function $t(At) {
        for (var kt = ce(Ht); kt !== null; ) {
          if (kt.callback === null)
            Ce(Ht);
          else if (kt.startTime <= At)
            Ce(Ht), kt.sortIndex = kt.expirationTime, oe(er, kt);
          else
            return;
          kt = ce(Ht);
        }
      }
      function yt(At) {
        if (gt = !1, $t(At), !mt)
          if (ce(er) !== null)
            mt = !0, ti(Bt);
          else {
            var kt = ce(Ht);
            kt !== null && gn(yt, kt.startTime - At);
          }
      }
      function Bt(At, kt) {
        mt = !1, gt && (gt = !1, Kn()), ut = !0;
        var Zt = ot;
        try {
          var pr;
          if (!J) return rr(At, kt);
        } finally {
          dt = null, ot = Zt, ut = !1;
        }
      }
      function rr(At, kt) {
        var Zt = kt;
        for ($t(Zt), dt = ce(er); dt !== null && !L && !(dt.expirationTime > Zt && (!At || Mr())); ) {
          var pr = dt.callback;
          if (typeof pr == "function") {
            dt.callback = null, ot = dt.priorityLevel;
            var Sr = dt.expirationTime <= Zt, Tr = pr(Sr);
            Zt = B.unstable_now(), typeof Tr == "function" ? dt.callback = Tr : dt === ce(er) && Ce(er), $t(Zt);
          } else
            Ce(er);
          dt = ce(er);
        }
        if (dt !== null)
          return !0;
        var fn = ce(Ht);
        return fn !== null && gn(yt, fn.startTime - Zt), !1;
      }
      function dr(At, kt) {
        switch (At) {
          case it:
          case lt:
          case Et:
          case wt:
          case Rt:
            break;
          default:
            At = Et;
        }
        var Zt = ot;
        ot = At;
        try {
          return kt();
        } finally {
          ot = Zt;
        }
      }
      function tr(At) {
        var kt;
        switch (ot) {
          case it:
          case lt:
          case Et:
            kt = Et;
            break;
          default:
            kt = ot;
            break;
        }
        var Zt = ot;
        ot = kt;
        try {
          return At();
        } finally {
          ot = Zt;
        }
      }
      function Dt(At) {
        var kt = ot;
        return function() {
          var Zt = ot;
          ot = kt;
          try {
            return At.apply(this, arguments);
          } finally {
            ot = Zt;
          }
        };
      }
      function Wt(At, kt, Zt) {
        var pr = B.unstable_now(), Sr;
        if (typeof Zt == "object" && Zt !== null) {
          var Tr = Zt.delay;
          typeof Tr == "number" && Tr > 0 ? Sr = pr + Tr : Sr = pr;
        } else
          Sr = pr;
        var fn;
        switch (At) {
          case it:
            fn = Jt;
            break;
          case lt:
            fn = Vt;
            break;
          case Rt:
            fn = Ut;
            break;
          case wt:
            fn = jt;
            break;
          case Et:
          default:
            fn = yr;
            break;
        }
        var On = Sr + fn, tn = {
          id: ct++,
          callback: kt,
          priorityLevel: At,
          startTime: Sr,
          expirationTime: On,
          sortIndex: -1
        };
        return Sr > pr ? (tn.sortIndex = Sr, oe(Ht, tn), ce(er) === null && tn === ce(Ht) && (gt ? Kn() : gt = !0, gn(yt, Sr - pr))) : (tn.sortIndex = On, oe(er, tn), !mt && !ut && (mt = !0, ti(Bt))), tn;
      }
      function or() {
      }
      function _r() {
        !mt && !ut && (mt = !0, ti(Bt));
      }
      function Xt() {
        return ce(er);
      }
      function Qt(At) {
        At.callback = null;
      }
      function br() {
        return ot;
      }
      var Dr = !1, Vr = null, Zr = -1, ln = ne, _n = -1;
      function Mr() {
        var At = B.unstable_now() - _n;
        return !(At < ln);
      }
      function Wn() {
      }
      function xn(At) {
        if (At < 0 || At > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        At > 0 ? ln = Math.floor(1e3 / At) : ln = ne;
      }
      var ni = function() {
        if (Vr !== null) {
          var At = B.unstable_now();
          _n = At;
          var kt = !0, Zt = !0;
          try {
            Zt = Vr(kt, At);
          } finally {
            Zt ? Gn() : (Dr = !1, Vr = null);
          }
        } else
          Dr = !1;
      }, Gn;
      if (typeof vt == "function")
        Gn = function() {
          vt(ni);
        };
      else if (typeof MessageChannel < "u") {
        var En = new MessageChannel(), Pn = En.port2;
        En.port1.onmessage = ni, Gn = function() {
          Pn.postMessage(null);
        };
      } else
        Gn = function() {
          St(ni, 0);
        };
      function ti(At) {
        Vr = At, Dr || (Dr = !0, Gn());
      }
      function gn(At, kt) {
        Zr = St(function() {
          At(B.unstable_now());
        }, kt);
      }
      function Kn() {
        xt(Zr), Zr = -1;
      }
      var gi = Wn, Gt = null;
      B.unstable_IdlePriority = Rt, B.unstable_ImmediatePriority = it, B.unstable_LowPriority = wt, B.unstable_NormalPriority = Et, B.unstable_Profiling = Gt, B.unstable_UserBlockingPriority = lt, B.unstable_cancelCallback = Qt, B.unstable_continueExecution = _r, B.unstable_forceFrameRate = xn, B.unstable_getCurrentPriorityLevel = br, B.unstable_getFirstCallbackNode = Xt, B.unstable_next = tr, B.unstable_pauseExecution = or, B.unstable_requestPaint = gi, B.unstable_runWithPriority = dr, B.unstable_scheduleCallback = Wt, B.unstable_shouldYield = Mr, B.unstable_wrapCallback = Dt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(scheduler_development)), scheduler_development;
}
var hasRequiredScheduler;
function requireScheduler() {
  return hasRequiredScheduler || (hasRequiredScheduler = 1, process$1.env.NODE_ENV === "production" ? scheduler.exports = requireScheduler_production_min() : scheduler.exports = requireScheduler_development()), scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var B = reactExports, L = requireScheduler();
  function J(ie) {
    for (var pe = "https://reactjs.org/docs/error-decoder.html?invariant=" + ie, nt = 1; nt < arguments.length; nt++) pe += "&args[]=" + encodeURIComponent(arguments[nt]);
    return "Minified React error #" + ie + "; visit " + pe + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var ne = /* @__PURE__ */ new Set(), oe = {};
  function ce(ie, pe) {
    Ce(ie, pe), Ce(ie + "Capture", pe);
  }
  function Ce(ie, pe) {
    for (oe[ie] = pe, ie = 0; ie < pe.length; ie++) ne.add(pe[ie]);
  }
  var rt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), at = Object.prototype.hasOwnProperty, ht = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, it = {}, lt = {};
  function Et(ie) {
    return at.call(lt, ie) ? !0 : at.call(it, ie) ? !1 : ht.test(ie) ? lt[ie] = !0 : (it[ie] = !0, !1);
  }
  function wt(ie, pe, nt, pt) {
    if (nt !== null && nt.type === 0) return !1;
    switch (typeof pe) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return pt ? !1 : nt !== null ? !nt.acceptsBooleans : (ie = ie.toLowerCase().slice(0, 5), ie !== "data-" && ie !== "aria-");
      default:
        return !1;
    }
  }
  function Rt(ie, pe, nt, pt) {
    if (pe === null || typeof pe > "u" || wt(ie, pe, nt, pt)) return !0;
    if (pt) return !1;
    if (nt !== null) switch (nt.type) {
      case 3:
        return !pe;
      case 4:
        return pe === !1;
      case 5:
        return isNaN(pe);
      case 6:
        return isNaN(pe) || 1 > pe;
    }
    return !1;
  }
  function Mt(ie, pe, nt, pt, Tt, Pt, Yt) {
    this.acceptsBooleans = pe === 2 || pe === 3 || pe === 4, this.attributeName = pt, this.attributeNamespace = Tt, this.mustUseProperty = nt, this.propertyName = ie, this.type = pe, this.sanitizeURL = Pt, this.removeEmptyString = Yt;
  }
  var Lt = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(ie) {
    Lt[ie] = new Mt(ie, 0, !1, ie, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(ie) {
    var pe = ie[0];
    Lt[pe] = new Mt(pe, 1, !1, ie[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 2, !1, ie.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 2, !1, ie, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(ie) {
    Lt[ie] = new Mt(ie, 3, !1, ie.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 3, !0, ie, null, !1, !1);
  }), ["capture", "download"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 4, !1, ie, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 6, !1, ie, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 5, !1, ie.toLowerCase(), null, !1, !1);
  });
  var zt = /[\-:]([a-z])/g;
  function Ot(ie) {
    return ie[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(ie) {
    var pe = ie.replace(
      zt,
      Ot
    );
    Lt[pe] = new Mt(pe, 1, !1, ie, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(ie) {
    var pe = ie.replace(zt, Ot);
    Lt[pe] = new Mt(pe, 1, !1, ie, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(ie) {
    var pe = ie.replace(zt, Ot);
    Lt[pe] = new Mt(pe, 1, !1, ie, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 1, !1, ie.toLowerCase(), null, !1, !1);
  }), Lt.xlinkHref = new Mt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(ie) {
    Lt[ie] = new Mt(ie, 1, !1, ie.toLowerCase(), null, !0, !0);
  });
  function It(ie, pe, nt, pt) {
    var Tt = Lt.hasOwnProperty(pe) ? Lt[pe] : null;
    (Tt !== null ? Tt.type !== 0 : pt || !(2 < pe.length) || pe[0] !== "o" && pe[0] !== "O" || pe[1] !== "n" && pe[1] !== "N") && (Rt(pe, nt, Tt, pt) && (nt = null), pt || Tt === null ? Et(pe) && (nt === null ? ie.removeAttribute(pe) : ie.setAttribute(pe, "" + nt)) : Tt.mustUseProperty ? ie[Tt.propertyName] = nt === null ? Tt.type === 3 ? !1 : "" : nt : (pe = Tt.attributeName, pt = Tt.attributeNamespace, nt === null ? ie.removeAttribute(pe) : (Tt = Tt.type, nt = Tt === 3 || Tt === 4 && nt === !0 ? "" : "" + nt, pt ? ie.setAttributeNS(pt, pe, nt) : ie.setAttribute(pe, nt))));
  }
  var Ft = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Jt = Symbol.for("react.element"), Vt = Symbol.for("react.portal"), yr = Symbol.for("react.fragment"), jt = Symbol.for("react.strict_mode"), Ut = Symbol.for("react.profiler"), er = Symbol.for("react.provider"), Ht = Symbol.for("react.context"), ct = Symbol.for("react.forward_ref"), dt = Symbol.for("react.suspense"), ot = Symbol.for("react.suspense_list"), ut = Symbol.for("react.memo"), mt = Symbol.for("react.lazy"), gt = Symbol.for("react.offscreen"), St = Symbol.iterator;
  function xt(ie) {
    return ie === null || typeof ie != "object" ? null : (ie = St && ie[St] || ie["@@iterator"], typeof ie == "function" ? ie : null);
  }
  var vt = Object.assign, $t;
  function yt(ie) {
    if ($t === void 0) try {
      throw Error();
    } catch (nt) {
      var pe = nt.stack.trim().match(/\n( *(at )?)/);
      $t = pe && pe[1] || "";
    }
    return `
` + $t + ie;
  }
  var Bt = !1;
  function rr(ie, pe) {
    if (!ie || Bt) return "";
    Bt = !0;
    var nt = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (pe) if (pe = function() {
        throw Error();
      }, Object.defineProperty(pe.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(pe, []);
        } catch (Lr) {
          var pt = Lr;
        }
        Reflect.construct(ie, [], pe);
      } else {
        try {
          pe.call();
        } catch (Lr) {
          pt = Lr;
        }
        ie.call(pe.prototype);
      }
      else {
        try {
          throw Error();
        } catch (Lr) {
          pt = Lr;
        }
        ie();
      }
    } catch (Lr) {
      if (Lr && pt && typeof Lr.stack == "string") {
        for (var Tt = Lr.stack.split(`
`), Pt = pt.stack.split(`
`), Yt = Tt.length - 1, cr = Pt.length - 1; 1 <= Yt && 0 <= cr && Tt[Yt] !== Pt[cr]; ) cr--;
        for (; 1 <= Yt && 0 <= cr; Yt--, cr--) if (Tt[Yt] !== Pt[cr]) {
          if (Yt !== 1 || cr !== 1)
            do
              if (Yt--, cr--, 0 > cr || Tt[Yt] !== Pt[cr]) {
                var wr = `
` + Tt[Yt].replace(" at new ", " at ");
                return ie.displayName && wr.includes("<anonymous>") && (wr = wr.replace("<anonymous>", ie.displayName)), wr;
              }
            while (1 <= Yt && 0 <= cr);
          break;
        }
      }
    } finally {
      Bt = !1, Error.prepareStackTrace = nt;
    }
    return (ie = ie ? ie.displayName || ie.name : "") ? yt(ie) : "";
  }
  function dr(ie) {
    switch (ie.tag) {
      case 5:
        return yt(ie.type);
      case 16:
        return yt("Lazy");
      case 13:
        return yt("Suspense");
      case 19:
        return yt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return ie = rr(ie.type, !1), ie;
      case 11:
        return ie = rr(ie.type.render, !1), ie;
      case 1:
        return ie = rr(ie.type, !0), ie;
      default:
        return "";
    }
  }
  function tr(ie) {
    if (ie == null) return null;
    if (typeof ie == "function") return ie.displayName || ie.name || null;
    if (typeof ie == "string") return ie;
    switch (ie) {
      case yr:
        return "Fragment";
      case Vt:
        return "Portal";
      case Ut:
        return "Profiler";
      case jt:
        return "StrictMode";
      case dt:
        return "Suspense";
      case ot:
        return "SuspenseList";
    }
    if (typeof ie == "object") switch (ie.$$typeof) {
      case Ht:
        return (ie.displayName || "Context") + ".Consumer";
      case er:
        return (ie._context.displayName || "Context") + ".Provider";
      case ct:
        var pe = ie.render;
        return ie = ie.displayName, ie || (ie = pe.displayName || pe.name || "", ie = ie !== "" ? "ForwardRef(" + ie + ")" : "ForwardRef"), ie;
      case ut:
        return pe = ie.displayName || null, pe !== null ? pe : tr(ie.type) || "Memo";
      case mt:
        pe = ie._payload, ie = ie._init;
        try {
          return tr(ie(pe));
        } catch {
        }
    }
    return null;
  }
  function Dt(ie) {
    var pe = ie.type;
    switch (ie.tag) {
      case 24:
        return "Cache";
      case 9:
        return (pe.displayName || "Context") + ".Consumer";
      case 10:
        return (pe._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return ie = pe.render, ie = ie.displayName || ie.name || "", pe.displayName || (ie !== "" ? "ForwardRef(" + ie + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return pe;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return tr(pe);
      case 8:
        return pe === jt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof pe == "function") return pe.displayName || pe.name || null;
        if (typeof pe == "string") return pe;
    }
    return null;
  }
  function Wt(ie) {
    switch (typeof ie) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return ie;
      case "object":
        return ie;
      default:
        return "";
    }
  }
  function or(ie) {
    var pe = ie.type;
    return (ie = ie.nodeName) && ie.toLowerCase() === "input" && (pe === "checkbox" || pe === "radio");
  }
  function _r(ie) {
    var pe = or(ie) ? "checked" : "value", nt = Object.getOwnPropertyDescriptor(ie.constructor.prototype, pe), pt = "" + ie[pe];
    if (!ie.hasOwnProperty(pe) && typeof nt < "u" && typeof nt.get == "function" && typeof nt.set == "function") {
      var Tt = nt.get, Pt = nt.set;
      return Object.defineProperty(ie, pe, { configurable: !0, get: function() {
        return Tt.call(this);
      }, set: function(Yt) {
        pt = "" + Yt, Pt.call(this, Yt);
      } }), Object.defineProperty(ie, pe, { enumerable: nt.enumerable }), { getValue: function() {
        return pt;
      }, setValue: function(Yt) {
        pt = "" + Yt;
      }, stopTracking: function() {
        ie._valueTracker = null, delete ie[pe];
      } };
    }
  }
  function Xt(ie) {
    ie._valueTracker || (ie._valueTracker = _r(ie));
  }
  function Qt(ie) {
    if (!ie) return !1;
    var pe = ie._valueTracker;
    if (!pe) return !0;
    var nt = pe.getValue(), pt = "";
    return ie && (pt = or(ie) ? ie.checked ? "true" : "false" : ie.value), ie = pt, ie !== nt ? (pe.setValue(ie), !0) : !1;
  }
  function br(ie) {
    if (ie = ie || (typeof document < "u" ? document : void 0), typeof ie > "u") return null;
    try {
      return ie.activeElement || ie.body;
    } catch {
      return ie.body;
    }
  }
  function Dr(ie, pe) {
    var nt = pe.checked;
    return vt({}, pe, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: nt ?? ie._wrapperState.initialChecked });
  }
  function Vr(ie, pe) {
    var nt = pe.defaultValue == null ? "" : pe.defaultValue, pt = pe.checked != null ? pe.checked : pe.defaultChecked;
    nt = Wt(pe.value != null ? pe.value : nt), ie._wrapperState = { initialChecked: pt, initialValue: nt, controlled: pe.type === "checkbox" || pe.type === "radio" ? pe.checked != null : pe.value != null };
  }
  function Zr(ie, pe) {
    pe = pe.checked, pe != null && It(ie, "checked", pe, !1);
  }
  function ln(ie, pe) {
    Zr(ie, pe);
    var nt = Wt(pe.value), pt = pe.type;
    if (nt != null) pt === "number" ? (nt === 0 && ie.value === "" || ie.value != nt) && (ie.value = "" + nt) : ie.value !== "" + nt && (ie.value = "" + nt);
    else if (pt === "submit" || pt === "reset") {
      ie.removeAttribute("value");
      return;
    }
    pe.hasOwnProperty("value") ? Mr(ie, pe.type, nt) : pe.hasOwnProperty("defaultValue") && Mr(ie, pe.type, Wt(pe.defaultValue)), pe.checked == null && pe.defaultChecked != null && (ie.defaultChecked = !!pe.defaultChecked);
  }
  function _n(ie, pe, nt) {
    if (pe.hasOwnProperty("value") || pe.hasOwnProperty("defaultValue")) {
      var pt = pe.type;
      if (!(pt !== "submit" && pt !== "reset" || pe.value !== void 0 && pe.value !== null)) return;
      pe = "" + ie._wrapperState.initialValue, nt || pe === ie.value || (ie.value = pe), ie.defaultValue = pe;
    }
    nt = ie.name, nt !== "" && (ie.name = ""), ie.defaultChecked = !!ie._wrapperState.initialChecked, nt !== "" && (ie.name = nt);
  }
  function Mr(ie, pe, nt) {
    (pe !== "number" || br(ie.ownerDocument) !== ie) && (nt == null ? ie.defaultValue = "" + ie._wrapperState.initialValue : ie.defaultValue !== "" + nt && (ie.defaultValue = "" + nt));
  }
  var Wn = Array.isArray;
  function xn(ie, pe, nt, pt) {
    if (ie = ie.options, pe) {
      pe = {};
      for (var Tt = 0; Tt < nt.length; Tt++) pe["$" + nt[Tt]] = !0;
      for (nt = 0; nt < ie.length; nt++) Tt = pe.hasOwnProperty("$" + ie[nt].value), ie[nt].selected !== Tt && (ie[nt].selected = Tt), Tt && pt && (ie[nt].defaultSelected = !0);
    } else {
      for (nt = "" + Wt(nt), pe = null, Tt = 0; Tt < ie.length; Tt++) {
        if (ie[Tt].value === nt) {
          ie[Tt].selected = !0, pt && (ie[Tt].defaultSelected = !0);
          return;
        }
        pe !== null || ie[Tt].disabled || (pe = ie[Tt]);
      }
      pe !== null && (pe.selected = !0);
    }
  }
  function ni(ie, pe) {
    if (pe.dangerouslySetInnerHTML != null) throw Error(J(91));
    return vt({}, pe, { value: void 0, defaultValue: void 0, children: "" + ie._wrapperState.initialValue });
  }
  function Gn(ie, pe) {
    var nt = pe.value;
    if (nt == null) {
      if (nt = pe.children, pe = pe.defaultValue, nt != null) {
        if (pe != null) throw Error(J(92));
        if (Wn(nt)) {
          if (1 < nt.length) throw Error(J(93));
          nt = nt[0];
        }
        pe = nt;
      }
      pe == null && (pe = ""), nt = pe;
    }
    ie._wrapperState = { initialValue: Wt(nt) };
  }
  function En(ie, pe) {
    var nt = Wt(pe.value), pt = Wt(pe.defaultValue);
    nt != null && (nt = "" + nt, nt !== ie.value && (ie.value = nt), pe.defaultValue == null && ie.defaultValue !== nt && (ie.defaultValue = nt)), pt != null && (ie.defaultValue = "" + pt);
  }
  function Pn(ie) {
    var pe = ie.textContent;
    pe === ie._wrapperState.initialValue && pe !== "" && pe !== null && (ie.value = pe);
  }
  function ti(ie) {
    switch (ie) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function gn(ie, pe) {
    return ie == null || ie === "http://www.w3.org/1999/xhtml" ? ti(pe) : ie === "http://www.w3.org/2000/svg" && pe === "foreignObject" ? "http://www.w3.org/1999/xhtml" : ie;
  }
  var Kn, gi = function(ie) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(pe, nt, pt, Tt) {
      MSApp.execUnsafeLocalFunction(function() {
        return ie(pe, nt, pt, Tt);
      });
    } : ie;
  }(function(ie, pe) {
    if (ie.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in ie) ie.innerHTML = pe;
    else {
      for (Kn = Kn || document.createElement("div"), Kn.innerHTML = "<svg>" + pe.valueOf().toString() + "</svg>", pe = Kn.firstChild; ie.firstChild; ) ie.removeChild(ie.firstChild);
      for (; pe.firstChild; ) ie.appendChild(pe.firstChild);
    }
  });
  function Gt(ie, pe) {
    if (pe) {
      var nt = ie.firstChild;
      if (nt && nt === ie.lastChild && nt.nodeType === 3) {
        nt.nodeValue = pe;
        return;
      }
    }
    ie.textContent = pe;
  }
  var At = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, kt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(At).forEach(function(ie) {
    kt.forEach(function(pe) {
      pe = pe + ie.charAt(0).toUpperCase() + ie.substring(1), At[pe] = At[ie];
    });
  });
  function Zt(ie, pe, nt) {
    return pe == null || typeof pe == "boolean" || pe === "" ? "" : nt || typeof pe != "number" || pe === 0 || At.hasOwnProperty(ie) && At[ie] ? ("" + pe).trim() : pe + "px";
  }
  function pr(ie, pe) {
    ie = ie.style;
    for (var nt in pe) if (pe.hasOwnProperty(nt)) {
      var pt = nt.indexOf("--") === 0, Tt = Zt(nt, pe[nt], pt);
      nt === "float" && (nt = "cssFloat"), pt ? ie.setProperty(nt, Tt) : ie[nt] = Tt;
    }
  }
  var Sr = vt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Tr(ie, pe) {
    if (pe) {
      if (Sr[ie] && (pe.children != null || pe.dangerouslySetInnerHTML != null)) throw Error(J(137, ie));
      if (pe.dangerouslySetInnerHTML != null) {
        if (pe.children != null) throw Error(J(60));
        if (typeof pe.dangerouslySetInnerHTML != "object" || !("__html" in pe.dangerouslySetInnerHTML)) throw Error(J(61));
      }
      if (pe.style != null && typeof pe.style != "object") throw Error(J(62));
    }
  }
  function fn(ie, pe) {
    if (ie.indexOf("-") === -1) return typeof pe.is == "string";
    switch (ie) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var On = null;
  function tn(ie) {
    return ie = ie.target || ie.srcElement || window, ie.correspondingUseElement && (ie = ie.correspondingUseElement), ie.nodeType === 3 ? ie.parentNode : ie;
  }
  var In = null, hn = null, cn = null;
  function ci(ie) {
    if (ie = lc(ie)) {
      if (typeof In != "function") throw Error(J(280));
      var pe = ie.stateNode;
      pe && (pe = Xn(pe), In(ie.stateNode, ie.type, pe));
    }
  }
  function pi(ie) {
    hn ? cn ? cn.push(ie) : cn = [ie] : hn = ie;
  }
  function ur() {
    if (hn) {
      var ie = hn, pe = cn;
      if (cn = hn = null, ci(ie), pe) for (ie = 0; ie < pe.length; ie++) ci(pe[ie]);
    }
  }
  function ir(ie, pe) {
    return ie(pe);
  }
  function lr() {
  }
  var gr = !1;
  function Ar(ie, pe, nt) {
    if (gr) return ie(pe, nt);
    gr = !0;
    try {
      return ir(ie, pe, nt);
    } finally {
      gr = !1, (hn !== null || cn !== null) && (lr(), ur());
    }
  }
  function Fr(ie, pe) {
    var nt = ie.stateNode;
    if (nt === null) return null;
    var pt = Xn(nt);
    if (pt === null) return null;
    nt = pt[pe];
    e: switch (pe) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (pt = !pt.disabled) || (ie = ie.type, pt = !(ie === "button" || ie === "input" || ie === "select" || ie === "textarea")), ie = !pt;
        break e;
      default:
        ie = !1;
    }
    if (ie) return null;
    if (nt && typeof nt != "function") throw Error(J(231, pe, typeof nt));
    return nt;
  }
  var jr = !1;
  if (rt) try {
    var Xr = {};
    Object.defineProperty(Xr, "passive", { get: function() {
      jr = !0;
    } }), window.addEventListener("test", Xr, Xr), window.removeEventListener("test", Xr, Xr);
  } catch {
    jr = !1;
  }
  function pn(ie, pe, nt, pt, Tt, Pt, Yt, cr, wr) {
    var Lr = Array.prototype.slice.call(arguments, 3);
    try {
      pe.apply(nt, Lr);
    } catch (en) {
      this.onError(en);
    }
  }
  var Yr = !1, vn = null, Cn = !1, dn = null, fr = { onError: function(ie) {
    Yr = !0, vn = ie;
  } };
  function Nr(ie, pe, nt, pt, Tt, Pt, Yt, cr, wr) {
    Yr = !1, vn = null, pn.apply(fr, arguments);
  }
  function Ir(ie, pe, nt, pt, Tt, Pt, Yt, cr, wr) {
    if (Nr.apply(this, arguments), Yr) {
      if (Yr) {
        var Lr = vn;
        Yr = !1, vn = null;
      } else throw Error(J(198));
      Cn || (Cn = !0, dn = Lr);
    }
  }
  function sn(ie) {
    var pe = ie, nt = ie;
    if (ie.alternate) for (; pe.return; ) pe = pe.return;
    else {
      ie = pe;
      do
        pe = ie, pe.flags & 4098 && (nt = pe.return), ie = pe.return;
      while (ie);
    }
    return pe.tag === 3 ? nt : null;
  }
  function Tn(ie) {
    if (ie.tag === 13) {
      var pe = ie.memoizedState;
      if (pe === null && (ie = ie.alternate, ie !== null && (pe = ie.memoizedState)), pe !== null) return pe.dehydrated;
    }
    return null;
  }
  function kn(ie) {
    if (sn(ie) !== ie) throw Error(J(188));
  }
  function Dn(ie) {
    var pe = ie.alternate;
    if (!pe) {
      if (pe = sn(ie), pe === null) throw Error(J(188));
      return pe !== ie ? null : ie;
    }
    for (var nt = ie, pt = pe; ; ) {
      var Tt = nt.return;
      if (Tt === null) break;
      var Pt = Tt.alternate;
      if (Pt === null) {
        if (pt = Tt.return, pt !== null) {
          nt = pt;
          continue;
        }
        break;
      }
      if (Tt.child === Pt.child) {
        for (Pt = Tt.child; Pt; ) {
          if (Pt === nt) return kn(Tt), ie;
          if (Pt === pt) return kn(Tt), pe;
          Pt = Pt.sibling;
        }
        throw Error(J(188));
      }
      if (nt.return !== pt.return) nt = Tt, pt = Pt;
      else {
        for (var Yt = !1, cr = Tt.child; cr; ) {
          if (cr === nt) {
            Yt = !0, nt = Tt, pt = Pt;
            break;
          }
          if (cr === pt) {
            Yt = !0, pt = Tt, nt = Pt;
            break;
          }
          cr = cr.sibling;
        }
        if (!Yt) {
          for (cr = Pt.child; cr; ) {
            if (cr === nt) {
              Yt = !0, nt = Pt, pt = Tt;
              break;
            }
            if (cr === pt) {
              Yt = !0, pt = Pt, nt = Tt;
              break;
            }
            cr = cr.sibling;
          }
          if (!Yt) throw Error(J(189));
        }
      }
      if (nt.alternate !== pt) throw Error(J(190));
    }
    if (nt.tag !== 3) throw Error(J(188));
    return nt.stateNode.current === nt ? ie : pe;
  }
  function Jn(ie) {
    return ie = Dn(ie), ie !== null ? Ti(ie) : null;
  }
  function Ti(ie) {
    if (ie.tag === 5 || ie.tag === 6) return ie;
    for (ie = ie.child; ie !== null; ) {
      var pe = Ti(ie);
      if (pe !== null) return pe;
      ie = ie.sibling;
    }
    return null;
  }
  var _i = L.unstable_scheduleCallback, Ri = L.unstable_cancelCallback, Qi = L.unstable_shouldYield, Ca = L.unstable_requestPaint, vi = L.unstable_now, Wi = L.unstable_getCurrentPriorityLevel, ra = L.unstable_ImmediatePriority, ii = L.unstable_UserBlockingPriority, ma = L.unstable_NormalPriority, Ga = L.unstable_LowPriority, po = L.unstable_IdlePriority, Xa = null, sa = null;
  function Oo(ie) {
    if (sa && typeof sa.onCommitFiberRoot == "function") try {
      sa.onCommitFiberRoot(Xa, ie, void 0, (ie.current.flags & 128) === 128);
    } catch {
    }
  }
  var Sa = Math.clz32 ? Math.clz32 : Zc, Ls = Math.log, Gl = Math.LN2;
  function Zc(ie) {
    return ie >>>= 0, ie === 0 ? 32 : 31 - (Ls(ie) / Gl | 0) | 0;
  }
  var Pf = 64, pu = 4194304;
  function ds(ie) {
    switch (ie & -ie) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return ie & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return ie & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return ie;
    }
  }
  function to(ie, pe) {
    var nt = ie.pendingLanes;
    if (nt === 0) return 0;
    var pt = 0, Tt = ie.suspendedLanes, Pt = ie.pingedLanes, Yt = nt & 268435455;
    if (Yt !== 0) {
      var cr = Yt & ~Tt;
      cr !== 0 ? pt = ds(cr) : (Pt &= Yt, Pt !== 0 && (pt = ds(Pt)));
    } else Yt = nt & ~Tt, Yt !== 0 ? pt = ds(Yt) : Pt !== 0 && (pt = ds(Pt));
    if (pt === 0) return 0;
    if (pe !== 0 && pe !== pt && !(pe & Tt) && (Tt = pt & -pt, Pt = pe & -pe, Tt >= Pt || Tt === 16 && (Pt & 4194240) !== 0)) return pe;
    if (pt & 4 && (pt |= nt & 16), pe = ie.entangledLanes, pe !== 0) for (ie = ie.entanglements, pe &= pt; 0 < pe; ) nt = 31 - Sa(pe), Tt = 1 << nt, pt |= ie[nt], pe &= ~Tt;
    return pt;
  }
  function vu(ie, pe) {
    switch (ie) {
      case 1:
      case 2:
      case 4:
        return pe + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return pe + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function yu(ie, pe) {
    for (var nt = ie.suspendedLanes, pt = ie.pingedLanes, Tt = ie.expirationTimes, Pt = ie.pendingLanes; 0 < Pt; ) {
      var Yt = 31 - Sa(Pt), cr = 1 << Yt, wr = Tt[Yt];
      wr === -1 ? (!(cr & nt) || cr & pt) && (Tt[Yt] = vu(cr, pe)) : wr <= pe && (ie.expiredLanes |= cr), Pt &= ~cr;
    }
  }
  function mu(ie) {
    return ie = ie.pendingLanes & -1073741825, ie !== 0 ? ie : ie & 1073741824 ? 1073741824 : 0;
  }
  function If() {
    var ie = Pf;
    return Pf <<= 1, !(Pf & 4194240) && (Pf = 64), ie;
  }
  function Df(ie) {
    for (var pe = [], nt = 0; 31 > nt; nt++) pe.push(ie);
    return pe;
  }
  function Us(ie, pe, nt) {
    ie.pendingLanes |= pe, pe !== 536870912 && (ie.suspendedLanes = 0, ie.pingedLanes = 0), ie = ie.eventTimes, pe = 31 - Sa(pe), ie[pe] = nt;
  }
  function Yh(ie, pe) {
    var nt = ie.pendingLanes & ~pe;
    ie.pendingLanes = pe, ie.suspendedLanes = 0, ie.pingedLanes = 0, ie.expiredLanes &= pe, ie.mutableReadLanes &= pe, ie.entangledLanes &= pe, pe = ie.entanglements;
    var pt = ie.eventTimes;
    for (ie = ie.expirationTimes; 0 < nt; ) {
      var Tt = 31 - Sa(nt), Pt = 1 << Tt;
      pe[Tt] = 0, pt[Tt] = -1, ie[Tt] = -1, nt &= ~Pt;
    }
  }
  function Ss(ie, pe) {
    var nt = ie.entangledLanes |= pe;
    for (ie = ie.entanglements; nt; ) {
      var pt = 31 - Sa(nt), Tt = 1 << pt;
      Tt & pe | ie[pt] & pe && (ie[pt] |= pe), nt &= ~Tt;
    }
  }
  var Ci = 0;
  function Nf(ie) {
    return ie &= -ie, 1 < ie ? 4 < ie ? ie & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Gu, Lf, Si, Uf, Ff, ui = !1, Xu = [], na = null, vo = null, ro = null, gu = /* @__PURE__ */ new Map(), ua = /* @__PURE__ */ new Map(), Ii = [], ed = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function yo(ie, pe) {
    switch (ie) {
      case "focusin":
      case "focusout":
        na = null;
        break;
      case "dragenter":
      case "dragleave":
        vo = null;
        break;
      case "mouseover":
      case "mouseout":
        ro = null;
        break;
      case "pointerover":
      case "pointerout":
        gu.delete(pe.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ua.delete(pe.pointerId);
    }
  }
  function Ba(ie, pe, nt, pt, Tt, Pt) {
    return ie === null || ie.nativeEvent !== Pt ? (ie = { blockedOn: pe, domEventName: nt, eventSystemFlags: pt, nativeEvent: Pt, targetContainers: [Tt] }, pe !== null && (pe = lc(pe), pe !== null && Lf(pe)), ie) : (ie.eventSystemFlags |= pt, pe = ie.targetContainers, Tt !== null && pe.indexOf(Tt) === -1 && pe.push(Tt), ie);
  }
  function Es(ie, pe, nt, pt, Tt) {
    switch (pe) {
      case "focusin":
        return na = Ba(na, ie, pe, nt, pt, Tt), !0;
      case "dragenter":
        return vo = Ba(vo, ie, pe, nt, pt, Tt), !0;
      case "mouseover":
        return ro = Ba(ro, ie, pe, nt, pt, Tt), !0;
      case "pointerover":
        var Pt = Tt.pointerId;
        return gu.set(Pt, Ba(gu.get(Pt) || null, ie, pe, nt, pt, Tt)), !0;
      case "gotpointercapture":
        return Pt = Tt.pointerId, ua.set(Pt, Ba(ua.get(Pt) || null, ie, pe, nt, pt, Tt)), !0;
    }
    return !1;
  }
  function td(ie) {
    var pe = Go(ie.target);
    if (pe !== null) {
      var nt = sn(pe);
      if (nt !== null) {
        if (pe = nt.tag, pe === 13) {
          if (pe = Tn(nt), pe !== null) {
            ie.blockedOn = pe, Ff(ie.priority, function() {
              Si(nt);
            });
            return;
          }
        } else if (pe === 3 && nt.stateNode.current.memoizedState.isDehydrated) {
          ie.blockedOn = nt.tag === 3 ? nt.stateNode.containerInfo : null;
          return;
        }
      }
    }
    ie.blockedOn = null;
  }
  function Fs(ie) {
    if (ie.blockedOn !== null) return !1;
    for (var pe = ie.targetContainers; 0 < pe.length; ) {
      var nt = jf(ie.domEventName, ie.eventSystemFlags, pe[0], ie.nativeEvent);
      if (nt === null) {
        nt = ie.nativeEvent;
        var pt = new nt.constructor(nt.type, nt);
        On = pt, nt.target.dispatchEvent(pt), On = null;
      } else return pe = lc(nt), pe !== null && Lf(pe), ie.blockedOn = nt, !1;
      pe.shift();
    }
    return !0;
  }
  function bu(ie, pe, nt) {
    Fs(ie) && nt.delete(pe);
  }
  function rd() {
    ui = !1, na !== null && Fs(na) && (na = null), vo !== null && Fs(vo) && (vo = null), ro !== null && Fs(ro) && (ro = null), gu.forEach(bu), ua.forEach(bu);
  }
  function Wo(ie, pe) {
    ie.blockedOn === pe && (ie.blockedOn = null, ui || (ui = !0, L.unstable_scheduleCallback(L.unstable_NormalPriority, rd)));
  }
  function wu(ie) {
    function pe(Tt) {
      return Wo(Tt, ie);
    }
    if (0 < Xu.length) {
      Wo(Xu[0], ie);
      for (var nt = 1; nt < Xu.length; nt++) {
        var pt = Xu[nt];
        pt.blockedOn === ie && (pt.blockedOn = null);
      }
    }
    for (na !== null && Wo(na, ie), vo !== null && Wo(vo, ie), ro !== null && Wo(ro, ie), gu.forEach(pe), ua.forEach(pe), nt = 0; nt < Ii.length; nt++) pt = Ii[nt], pt.blockedOn === ie && (pt.blockedOn = null);
    for (; 0 < Ii.length && (nt = Ii[0], nt.blockedOn === null); ) td(nt), nt.blockedOn === null && Ii.shift();
  }
  var Hs = Ft.ReactCurrentBatchConfig, Ko = !0;
  function Hf(ie, pe, nt, pt) {
    var Tt = Ci, Pt = Hs.transition;
    Hs.transition = null;
    try {
      Ci = 1, Su(ie, pe, nt, pt);
    } finally {
      Ci = Tt, Hs.transition = Pt;
    }
  }
  function _u(ie, pe, nt, pt) {
    var Tt = Ci, Pt = Hs.transition;
    Hs.transition = null;
    try {
      Ci = 4, Su(ie, pe, nt, pt);
    } finally {
      Ci = Tt, Hs.transition = Pt;
    }
  }
  function Su(ie, pe, nt, pt) {
    if (Ko) {
      var Tt = jf(ie, pe, nt, pt);
      if (Tt === null) cd(ie, pe, pt, Yu, nt), yo(ie, pt);
      else if (Es(Tt, ie, pe, nt, pt)) pt.stopPropagation();
      else if (yo(ie, pt), pe & 4 && -1 < ed.indexOf(ie)) {
        for (; Tt !== null; ) {
          var Pt = lc(Tt);
          if (Pt !== null && Gu(Pt), Pt = jf(ie, pe, nt, pt), Pt === null && cd(ie, pe, pt, Yu, nt), Pt === Tt) break;
          Tt = Pt;
        }
        Tt !== null && pt.stopPropagation();
      } else cd(ie, pe, pt, null, nt);
    }
  }
  var Yu = null;
  function jf(ie, pe, nt, pt) {
    if (Yu = null, ie = tn(pt), ie = Go(ie), ie !== null) if (pe = sn(ie), pe === null) ie = null;
    else if (nt = pe.tag, nt === 13) {
      if (ie = Tn(pe), ie !== null) return ie;
      ie = null;
    } else if (nt === 3) {
      if (pe.stateNode.current.memoizedState.isDehydrated) return pe.tag === 3 ? pe.stateNode.containerInfo : null;
      ie = null;
    } else pe !== ie && (ie = null);
    return Yu = ie, null;
  }
  function Xl(ie) {
    switch (ie) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Wi()) {
          case ra:
            return 1;
          case ii:
            return 4;
          case ma:
          case Ga:
            return 16;
          case po:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var hs = null, Kt = null, vr = null;
  function Pr() {
    if (vr) return vr;
    var ie, pe = Kt, nt = pe.length, pt, Tt = "value" in hs ? hs.value : hs.textContent, Pt = Tt.length;
    for (ie = 0; ie < nt && pe[ie] === Tt[ie]; ie++) ;
    var Yt = nt - ie;
    for (pt = 1; pt <= Yt && pe[nt - pt] === Tt[Pt - pt]; pt++) ;
    return vr = Tt.slice(ie, 1 < pt ? 1 - pt : void 0);
  }
  function Hr(ie) {
    var pe = ie.keyCode;
    return "charCode" in ie ? (ie = ie.charCode, ie === 0 && pe === 13 && (ie = 13)) : ie = pe, ie === 10 && (ie = 13), 32 <= ie || ie === 13 ? ie : 0;
  }
  function an() {
    return !0;
  }
  function Zn() {
    return !1;
  }
  function wn(ie) {
    function pe(nt, pt, Tt, Pt, Yt) {
      this._reactName = nt, this._targetInst = Tt, this.type = pt, this.nativeEvent = Pt, this.target = Yt, this.currentTarget = null;
      for (var cr in ie) ie.hasOwnProperty(cr) && (nt = ie[cr], this[cr] = nt ? nt(Pt) : Pt[cr]);
      return this.isDefaultPrevented = (Pt.defaultPrevented != null ? Pt.defaultPrevented : Pt.returnValue === !1) ? an : Zn, this.isPropagationStopped = Zn, this;
    }
    return vt(pe.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var nt = this.nativeEvent;
      nt && (nt.preventDefault ? nt.preventDefault() : typeof nt.returnValue != "unknown" && (nt.returnValue = !1), this.isDefaultPrevented = an);
    }, stopPropagation: function() {
      var nt = this.nativeEvent;
      nt && (nt.stopPropagation ? nt.stopPropagation() : typeof nt.cancelBubble != "unknown" && (nt.cancelBubble = !0), this.isPropagationStopped = an);
    }, persist: function() {
    }, isPersistent: an }), pe;
  }
  var Qn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(ie) {
    return ie.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, yi = wn(Qn), Ai = vt({}, Qn, { view: 0, detail: 0 }), ji = wn(Ai), Ui, zi, Ki, Ei = vt({}, Ai, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: tp, button: 0, buttons: 0, relatedTarget: function(ie) {
    return ie.relatedTarget === void 0 ? ie.fromElement === ie.srcElement ? ie.toElement : ie.fromElement : ie.relatedTarget;
  }, movementX: function(ie) {
    return "movementX" in ie ? ie.movementX : (ie !== Ki && (Ki && ie.type === "mousemove" ? (Ui = ie.screenX - Ki.screenX, zi = ie.screenY - Ki.screenY) : zi = Ui = 0, Ki = ie), Ui);
  }, movementY: function(ie) {
    return "movementY" in ie ? ie.movementY : zi;
  } }), js = wn(Ei), zf = vt({}, Ei, { dataTransfer: 0 }), Yl = wn(zf), Jh = vt({}, Ai, { relatedTarget: 0 }), ps = wn(Jh), Jl = vt({}, Qn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Ql = wn(Jl), Qh = vt({}, Qn, { clipboardData: function(ie) {
    return "clipboardData" in ie ? ie.clipboardData : window.clipboardData;
  } }), zy = wn(Qh), qy = vt({}, Qn, { data: 0 }), Zh = wn(qy), ep = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Z0 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, e1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function t1(ie) {
    var pe = this.nativeEvent;
    return pe.getModifierState ? pe.getModifierState(ie) : (ie = e1[ie]) ? !!pe[ie] : !1;
  }
  function tp() {
    return t1;
  }
  var zs = vt({}, Ai, { key: function(ie) {
    if (ie.key) {
      var pe = ep[ie.key] || ie.key;
      if (pe !== "Unidentified") return pe;
    }
    return ie.type === "keypress" ? (ie = Hr(ie), ie === 13 ? "Enter" : String.fromCharCode(ie)) : ie.type === "keydown" || ie.type === "keyup" ? Z0[ie.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: tp, charCode: function(ie) {
    return ie.type === "keypress" ? Hr(ie) : 0;
  }, keyCode: function(ie) {
    return ie.type === "keydown" || ie.type === "keyup" ? ie.keyCode : 0;
  }, which: function(ie) {
    return ie.type === "keypress" ? Hr(ie) : ie.type === "keydown" || ie.type === "keyup" ? ie.keyCode : 0;
  } }), Wy = wn(zs), rp = vt({}, Ei, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), nd = wn(rp), np = vt({}, Ai, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: tp }), Ky = wn(np), id = vt({}, Qn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), r1 = wn(id), mo = vt({}, Ei, {
    deltaX: function(ie) {
      return "deltaX" in ie ? ie.deltaX : "wheelDeltaX" in ie ? -ie.wheelDeltaX : 0;
    },
    deltaY: function(ie) {
      return "deltaY" in ie ? ie.deltaY : "wheelDeltaY" in ie ? -ie.wheelDeltaY : "wheelDelta" in ie ? -ie.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), qs = wn(mo), ga = [9, 13, 27, 32], vs = rt && "CompositionEvent" in window, Ju = null;
  rt && "documentMode" in document && (Ju = document.documentMode);
  var ad = rt && "TextEvent" in window && !Ju, n1 = rt && (!vs || Ju && 8 < Ju && 11 >= Ju), qf = " ", i1 = !1;
  function a1(ie, pe) {
    switch (ie) {
      case "keyup":
        return ga.indexOf(pe.keyCode) !== -1;
      case "keydown":
        return pe.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function od(ie) {
    return ie = ie.detail, typeof ie == "object" && "data" in ie ? ie.data : null;
  }
  var Wf = !1;
  function Vy(ie, pe) {
    switch (ie) {
      case "compositionend":
        return od(pe);
      case "keypress":
        return pe.which !== 32 ? null : (i1 = !0, qf);
      case "textInput":
        return ie = pe.data, ie === qf && i1 ? null : ie;
      default:
        return null;
    }
  }
  function Gy(ie, pe) {
    if (Wf) return ie === "compositionend" || !vs && a1(ie, pe) ? (ie = Pr(), vr = Kt = hs = null, Wf = !1, ie) : null;
    switch (ie) {
      case "paste":
        return null;
      case "keypress":
        if (!(pe.ctrlKey || pe.altKey || pe.metaKey) || pe.ctrlKey && pe.altKey) {
          if (pe.char && 1 < pe.char.length) return pe.char;
          if (pe.which) return String.fromCharCode(pe.which);
        }
        return null;
      case "compositionend":
        return n1 && pe.locale !== "ko" ? null : pe.data;
      default:
        return null;
    }
  }
  var o1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function s1(ie) {
    var pe = ie && ie.nodeName && ie.nodeName.toLowerCase();
    return pe === "input" ? !!o1[ie.type] : pe === "textarea";
  }
  function u1(ie, pe, nt, pt) {
    pi(pt), pe = sc(pe, "onChange"), 0 < pe.length && (nt = new yi("onChange", "change", null, nt, pt), ie.push({ event: nt, listeners: pe }));
  }
  var Zl = null, Kf = null;
  function Vf(ie) {
    ld(ie, 0);
  }
  function Gf(ie) {
    var pe = Yf(ie);
    if (Qt(pe)) return ie;
  }
  function f1(ie, pe) {
    if (ie === "change") return pe;
  }
  var ip = !1;
  if (rt) {
    var ap;
    if (rt) {
      var op = "oninput" in document;
      if (!op) {
        var l1 = document.createElement("div");
        l1.setAttribute("oninput", "return;"), op = typeof l1.oninput == "function";
      }
      ap = op;
    } else ap = !1;
    ip = ap && (!document.documentMode || 9 < document.documentMode);
  }
  function c1() {
    Zl && (Zl.detachEvent("onpropertychange", d1), Kf = Zl = null);
  }
  function d1(ie) {
    if (ie.propertyName === "value" && Gf(Kf)) {
      var pe = [];
      u1(pe, Kf, ie, tn(ie)), Ar(Vf, pe);
    }
  }
  function Xy(ie, pe, nt) {
    ie === "focusin" ? (c1(), Zl = pe, Kf = nt, Zl.attachEvent("onpropertychange", d1)) : ie === "focusout" && c1();
  }
  function Yy(ie) {
    if (ie === "selectionchange" || ie === "keyup" || ie === "keydown") return Gf(Kf);
  }
  function Jy(ie, pe) {
    if (ie === "click") return Gf(pe);
  }
  function h1(ie, pe) {
    if (ie === "input" || ie === "change") return Gf(pe);
  }
  function Qy(ie, pe) {
    return ie === pe && (ie !== 0 || 1 / ie === 1 / pe) || ie !== ie && pe !== pe;
  }
  var Vo = typeof Object.is == "function" ? Object.is : Qy;
  function tc(ie, pe) {
    if (Vo(ie, pe)) return !0;
    if (typeof ie != "object" || ie === null || typeof pe != "object" || pe === null) return !1;
    var nt = Object.keys(ie), pt = Object.keys(pe);
    if (nt.length !== pt.length) return !1;
    for (pt = 0; pt < nt.length; pt++) {
      var Tt = nt[pt];
      if (!at.call(pe, Tt) || !Vo(ie[Tt], pe[Tt])) return !1;
    }
    return !0;
  }
  function p1(ie) {
    for (; ie && ie.firstChild; ) ie = ie.firstChild;
    return ie;
  }
  function v1(ie, pe) {
    var nt = p1(ie);
    ie = 0;
    for (var pt; nt; ) {
      if (nt.nodeType === 3) {
        if (pt = ie + nt.textContent.length, ie <= pe && pt >= pe) return { node: nt, offset: pe - ie };
        ie = pt;
      }
      e: {
        for (; nt; ) {
          if (nt.nextSibling) {
            nt = nt.nextSibling;
            break e;
          }
          nt = nt.parentNode;
        }
        nt = void 0;
      }
      nt = p1(nt);
    }
  }
  function y1(ie, pe) {
    return ie && pe ? ie === pe ? !0 : ie && ie.nodeType === 3 ? !1 : pe && pe.nodeType === 3 ? y1(ie, pe.parentNode) : "contains" in ie ? ie.contains(pe) : ie.compareDocumentPosition ? !!(ie.compareDocumentPosition(pe) & 16) : !1 : !1;
  }
  function sd() {
    for (var ie = window, pe = br(); pe instanceof ie.HTMLIFrameElement; ) {
      try {
        var nt = typeof pe.contentWindow.location.href == "string";
      } catch {
        nt = !1;
      }
      if (nt) ie = pe.contentWindow;
      else break;
      pe = br(ie.document);
    }
    return pe;
  }
  function Ws(ie) {
    var pe = ie && ie.nodeName && ie.nodeName.toLowerCase();
    return pe && (pe === "input" && (ie.type === "text" || ie.type === "search" || ie.type === "tel" || ie.type === "url" || ie.type === "password") || pe === "textarea" || ie.contentEditable === "true");
  }
  function ud(ie) {
    var pe = sd(), nt = ie.focusedElem, pt = ie.selectionRange;
    if (pe !== nt && nt && nt.ownerDocument && y1(nt.ownerDocument.documentElement, nt)) {
      if (pt !== null && Ws(nt)) {
        if (pe = pt.start, ie = pt.end, ie === void 0 && (ie = pe), "selectionStart" in nt) nt.selectionStart = pe, nt.selectionEnd = Math.min(ie, nt.value.length);
        else if (ie = (pe = nt.ownerDocument || document) && pe.defaultView || window, ie.getSelection) {
          ie = ie.getSelection();
          var Tt = nt.textContent.length, Pt = Math.min(pt.start, Tt);
          pt = pt.end === void 0 ? Pt : Math.min(pt.end, Tt), !ie.extend && Pt > pt && (Tt = pt, pt = Pt, Pt = Tt), Tt = v1(nt, Pt);
          var Yt = v1(
            nt,
            pt
          );
          Tt && Yt && (ie.rangeCount !== 1 || ie.anchorNode !== Tt.node || ie.anchorOffset !== Tt.offset || ie.focusNode !== Yt.node || ie.focusOffset !== Yt.offset) && (pe = pe.createRange(), pe.setStart(Tt.node, Tt.offset), ie.removeAllRanges(), Pt > pt ? (ie.addRange(pe), ie.extend(Yt.node, Yt.offset)) : (pe.setEnd(Yt.node, Yt.offset), ie.addRange(pe)));
        }
      }
      for (pe = [], ie = nt; ie = ie.parentNode; ) ie.nodeType === 1 && pe.push({ element: ie, left: ie.scrollLeft, top: ie.scrollTop });
      for (typeof nt.focus == "function" && nt.focus(), nt = 0; nt < pe.length; nt++) ie = pe[nt], ie.element.scrollLeft = ie.left, ie.element.scrollTop = ie.top;
    }
  }
  var m1 = rt && "documentMode" in document && 11 >= document.documentMode, ys = null, sp = null, rc = null, up = !1;
  function g1(ie, pe, nt) {
    var pt = nt.window === nt ? nt.document : nt.nodeType === 9 ? nt : nt.ownerDocument;
    up || ys == null || ys !== br(pt) || (pt = ys, "selectionStart" in pt && Ws(pt) ? pt = { start: pt.selectionStart, end: pt.selectionEnd } : (pt = (pt.ownerDocument && pt.ownerDocument.defaultView || window).getSelection(), pt = { anchorNode: pt.anchorNode, anchorOffset: pt.anchorOffset, focusNode: pt.focusNode, focusOffset: pt.focusOffset }), rc && tc(rc, pt) || (rc = pt, pt = sc(sp, "onSelect"), 0 < pt.length && (pe = new yi("onSelect", "select", null, pe, nt), ie.push({ event: pe, listeners: pt }), pe.target = ys)));
  }
  function fd(ie, pe) {
    var nt = {};
    return nt[ie.toLowerCase()] = pe.toLowerCase(), nt["Webkit" + ie] = "webkit" + pe, nt["Moz" + ie] = "moz" + pe, nt;
  }
  var Qu = { animationend: fd("Animation", "AnimationEnd"), animationiteration: fd("Animation", "AnimationIteration"), animationstart: fd("Animation", "AnimationStart"), transitionend: fd("Transition", "TransitionEnd") }, fp = {}, lp = {};
  rt && (lp = document.createElement("div").style, "AnimationEvent" in window || (delete Qu.animationend.animation, delete Qu.animationiteration.animation, delete Qu.animationstart.animation), "TransitionEvent" in window || delete Qu.transitionend.transition);
  function ka(ie) {
    if (fp[ie]) return fp[ie];
    if (!Qu[ie]) return ie;
    var pe = Qu[ie], nt;
    for (nt in pe) if (pe.hasOwnProperty(nt) && nt in lp) return fp[ie] = pe[nt];
    return ie;
  }
  var cp = ka("animationend"), b1 = ka("animationiteration"), w1 = ka("animationstart"), S1 = ka("transitionend"), E1 = /* @__PURE__ */ new Map(), $1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Ks(ie, pe) {
    E1.set(ie, pe), ce(pe, [ie]);
  }
  for (var nc = 0; nc < $1.length; nc++) {
    var Zu = $1[nc], Zy = Zu.toLowerCase(), ic = Zu[0].toUpperCase() + Zu.slice(1);
    Ks(Zy, "on" + ic);
  }
  Ks(cp, "onAnimationEnd"), Ks(b1, "onAnimationIteration"), Ks(w1, "onAnimationStart"), Ks("dblclick", "onDoubleClick"), Ks("focusin", "onFocus"), Ks("focusout", "onBlur"), Ks(S1, "onTransitionEnd"), Ce("onMouseEnter", ["mouseout", "mouseover"]), Ce("onMouseLeave", ["mouseout", "mouseover"]), Ce("onPointerEnter", ["pointerout", "pointerover"]), Ce("onPointerLeave", ["pointerout", "pointerover"]), ce("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), ce("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), ce("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ce("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), ce("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), ce("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var ac = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), em = new Set("cancel close invalid load scroll toggle".split(" ").concat(ac));
  function x1(ie, pe, nt) {
    var pt = ie.type || "unknown-event";
    ie.currentTarget = nt, Ir(pt, pe, void 0, ie), ie.currentTarget = null;
  }
  function ld(ie, pe) {
    pe = (pe & 4) !== 0;
    for (var nt = 0; nt < ie.length; nt++) {
      var pt = ie[nt], Tt = pt.event;
      pt = pt.listeners;
      e: {
        var Pt = void 0;
        if (pe) for (var Yt = pt.length - 1; 0 <= Yt; Yt--) {
          var cr = pt[Yt], wr = cr.instance, Lr = cr.currentTarget;
          if (cr = cr.listener, wr !== Pt && Tt.isPropagationStopped()) break e;
          x1(Tt, cr, Lr), Pt = wr;
        }
        else for (Yt = 0; Yt < pt.length; Yt++) {
          if (cr = pt[Yt], wr = cr.instance, Lr = cr.currentTarget, cr = cr.listener, wr !== Pt && Tt.isPropagationStopped()) break e;
          x1(Tt, cr, Lr), Pt = wr;
        }
      }
    }
    if (Cn) throw ie = dn, Cn = !1, dn = null, ie;
  }
  function qi(ie, pe) {
    var nt = pe[gp];
    nt === void 0 && (nt = pe[gp] = /* @__PURE__ */ new Set());
    var pt = ie + "__bubble";
    nt.has(pt) || (T1(pe, ie, 2, !1), nt.add(pt));
  }
  function Eu(ie, pe, nt) {
    var pt = 0;
    pe && (pt |= 4), T1(nt, ie, pt, pe);
  }
  var Vs = "_reactListening" + Math.random().toString(36).slice(2);
  function Xf(ie) {
    if (!ie[Vs]) {
      ie[Vs] = !0, ne.forEach(function(nt) {
        nt !== "selectionchange" && (em.has(nt) || Eu(nt, !1, ie), Eu(nt, !0, ie));
      });
      var pe = ie.nodeType === 9 ? ie : ie.ownerDocument;
      pe === null || pe[Vs] || (pe[Vs] = !0, Eu("selectionchange", !1, pe));
    }
  }
  function T1(ie, pe, nt, pt) {
    switch (Xl(pe)) {
      case 1:
        var Tt = Hf;
        break;
      case 4:
        Tt = _u;
        break;
      default:
        Tt = Su;
    }
    nt = Tt.bind(null, pe, nt, ie), Tt = void 0, !jr || pe !== "touchstart" && pe !== "touchmove" && pe !== "wheel" || (Tt = !0), pt ? Tt !== void 0 ? ie.addEventListener(pe, nt, { capture: !0, passive: Tt }) : ie.addEventListener(pe, nt, !0) : Tt !== void 0 ? ie.addEventListener(pe, nt, { passive: Tt }) : ie.addEventListener(pe, nt, !1);
  }
  function cd(ie, pe, nt, pt, Tt) {
    var Pt = pt;
    if (!(pe & 1) && !(pe & 2) && pt !== null) e: for (; ; ) {
      if (pt === null) return;
      var Yt = pt.tag;
      if (Yt === 3 || Yt === 4) {
        var cr = pt.stateNode.containerInfo;
        if (cr === Tt || cr.nodeType === 8 && cr.parentNode === Tt) break;
        if (Yt === 4) for (Yt = pt.return; Yt !== null; ) {
          var wr = Yt.tag;
          if ((wr === 3 || wr === 4) && (wr = Yt.stateNode.containerInfo, wr === Tt || wr.nodeType === 8 && wr.parentNode === Tt)) return;
          Yt = Yt.return;
        }
        for (; cr !== null; ) {
          if (Yt = Go(cr), Yt === null) return;
          if (wr = Yt.tag, wr === 5 || wr === 6) {
            pt = Pt = Yt;
            continue e;
          }
          cr = cr.parentNode;
        }
      }
      pt = pt.return;
    }
    Ar(function() {
      var Lr = Pt, en = tn(nt), rn = [];
      e: {
        var Qr = E1.get(ie);
        if (Qr !== void 0) {
          var An = yi, Nn = ie;
          switch (ie) {
            case "keypress":
              if (Hr(nt) === 0) break e;
            case "keydown":
            case "keyup":
              An = Wy;
              break;
            case "focusin":
              Nn = "focus", An = ps;
              break;
            case "focusout":
              Nn = "blur", An = ps;
              break;
            case "beforeblur":
            case "afterblur":
              An = ps;
              break;
            case "click":
              if (nt.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              An = js;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              An = Yl;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              An = Ky;
              break;
            case cp:
            case b1:
            case w1:
              An = Ql;
              break;
            case S1:
              An = r1;
              break;
            case "scroll":
              An = ji;
              break;
            case "wheel":
              An = qs;
              break;
            case "copy":
            case "cut":
            case "paste":
              An = zy;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              An = nd;
          }
          var Fn = (pe & 4) !== 0, va = !Fn && ie === "scroll", Rr = Fn ? Qr !== null ? Qr + "Capture" : null : Qr;
          Fn = [];
          for (var $r = Lr, kr; $r !== null; ) {
            kr = $r;
            var un = kr.stateNode;
            if (kr.tag === 5 && un !== null && (kr = un, Rr !== null && (un = Fr($r, Rr), un != null && Fn.push(oc($r, un, kr)))), va) break;
            $r = $r.return;
          }
          0 < Fn.length && (Qr = new An(Qr, Nn, null, nt, en), rn.push({ event: Qr, listeners: Fn }));
        }
      }
      if (!(pe & 7)) {
        e: {
          if (Qr = ie === "mouseover" || ie === "pointerover", An = ie === "mouseout" || ie === "pointerout", Qr && nt !== On && (Nn = nt.relatedTarget || nt.fromElement) && (Go(Nn) || Nn[Gs])) break e;
          if ((An || Qr) && (Qr = en.window === en ? en : (Qr = en.ownerDocument) ? Qr.defaultView || Qr.parentWindow : window, An ? (Nn = nt.relatedTarget || nt.toElement, An = Lr, Nn = Nn ? Go(Nn) : null, Nn !== null && (va = sn(Nn), Nn !== va || Nn.tag !== 5 && Nn.tag !== 6) && (Nn = null)) : (An = null, Nn = Lr), An !== Nn)) {
            if (Fn = js, un = "onMouseLeave", Rr = "onMouseEnter", $r = "mouse", (ie === "pointerout" || ie === "pointerover") && (Fn = nd, un = "onPointerLeave", Rr = "onPointerEnter", $r = "pointer"), va = An == null ? Qr : Yf(An), kr = Nn == null ? Qr : Yf(Nn), Qr = new Fn(un, $r + "leave", An, nt, en), Qr.target = va, Qr.relatedTarget = kr, un = null, Go(en) === Lr && (Fn = new Fn(Rr, $r + "enter", Nn, nt, en), Fn.target = kr, Fn.relatedTarget = va, un = Fn), va = un, An && Nn) t: {
              for (Fn = An, Rr = Nn, $r = 0, kr = Fn; kr; kr = ef(kr)) $r++;
              for (kr = 0, un = Rr; un; un = ef(un)) kr++;
              for (; 0 < $r - kr; ) Fn = ef(Fn), $r--;
              for (; 0 < kr - $r; ) Rr = ef(Rr), kr--;
              for (; $r--; ) {
                if (Fn === Rr || Rr !== null && Fn === Rr.alternate) break t;
                Fn = ef(Fn), Rr = ef(Rr);
              }
              Fn = null;
            }
            else Fn = null;
            An !== null && dp(rn, Qr, An, Fn, !1), Nn !== null && va !== null && dp(rn, va, Nn, Fn, !0);
          }
        }
        e: {
          if (Qr = Lr ? Yf(Lr) : window, An = Qr.nodeName && Qr.nodeName.toLowerCase(), An === "select" || An === "input" && Qr.type === "file") var jn = f1;
          else if (s1(Qr)) if (ip) jn = h1;
          else {
            jn = Yy;
            var ei = Xy;
          }
          else (An = Qr.nodeName) && An.toLowerCase() === "input" && (Qr.type === "checkbox" || Qr.type === "radio") && (jn = Jy);
          if (jn && (jn = jn(ie, Lr))) {
            u1(rn, jn, nt, en);
            break e;
          }
          ei && ei(ie, Qr, Lr), ie === "focusout" && (ei = Qr._wrapperState) && ei.controlled && Qr.type === "number" && Mr(Qr, "number", Qr.value);
        }
        switch (ei = Lr ? Yf(Lr) : window, ie) {
          case "focusin":
            (s1(ei) || ei.contentEditable === "true") && (ys = ei, sp = Lr, rc = null);
            break;
          case "focusout":
            rc = sp = ys = null;
            break;
          case "mousedown":
            up = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            up = !1, g1(rn, nt, en);
            break;
          case "selectionchange":
            if (m1) break;
          case "keydown":
          case "keyup":
            g1(rn, nt, en);
        }
        var Ln;
        if (vs) e: {
          switch (ie) {
            case "compositionstart":
              var ri = "onCompositionStart";
              break e;
            case "compositionend":
              ri = "onCompositionEnd";
              break e;
            case "compositionupdate":
              ri = "onCompositionUpdate";
              break e;
          }
          ri = void 0;
        }
        else Wf ? a1(ie, nt) && (ri = "onCompositionEnd") : ie === "keydown" && nt.keyCode === 229 && (ri = "onCompositionStart");
        ri && (n1 && nt.locale !== "ko" && (Wf || ri !== "onCompositionStart" ? ri === "onCompositionEnd" && Wf && (Ln = Pr()) : (hs = en, Kt = "value" in hs ? hs.value : hs.textContent, Wf = !0)), ei = sc(Lr, ri), 0 < ei.length && (ri = new Zh(ri, ie, null, nt, en), rn.push({ event: ri, listeners: ei }), Ln ? ri.data = Ln : (Ln = od(nt), Ln !== null && (ri.data = Ln)))), (Ln = ad ? Vy(ie, nt) : Gy(ie, nt)) && (Lr = sc(Lr, "onBeforeInput"), 0 < Lr.length && (en = new Zh("onBeforeInput", "beforeinput", null, nt, en), rn.push({ event: en, listeners: Lr }), en.data = Ln));
      }
      ld(rn, pe);
    });
  }
  function oc(ie, pe, nt) {
    return { instance: ie, listener: pe, currentTarget: nt };
  }
  function sc(ie, pe) {
    for (var nt = pe + "Capture", pt = []; ie !== null; ) {
      var Tt = ie, Pt = Tt.stateNode;
      Tt.tag === 5 && Pt !== null && (Tt = Pt, Pt = Fr(ie, nt), Pt != null && pt.unshift(oc(ie, Pt, Tt)), Pt = Fr(ie, pe), Pt != null && pt.push(oc(ie, Pt, Tt))), ie = ie.return;
    }
    return pt;
  }
  function ef(ie) {
    if (ie === null) return null;
    do
      ie = ie.return;
    while (ie && ie.tag !== 5);
    return ie || null;
  }
  function dp(ie, pe, nt, pt, Tt) {
    for (var Pt = pe._reactName, Yt = []; nt !== null && nt !== pt; ) {
      var cr = nt, wr = cr.alternate, Lr = cr.stateNode;
      if (wr !== null && wr === pt) break;
      cr.tag === 5 && Lr !== null && (cr = Lr, Tt ? (wr = Fr(nt, Pt), wr != null && Yt.unshift(oc(nt, wr, cr))) : Tt || (wr = Fr(nt, Pt), wr != null && Yt.push(oc(nt, wr, cr)))), nt = nt.return;
    }
    Yt.length !== 0 && ie.push({ event: pe, listeners: Yt });
  }
  var hp = /\r\n?/g, tm = /\u0000|\uFFFD/g;
  function pp(ie) {
    return (typeof ie == "string" ? ie : "" + ie).replace(hp, `
`).replace(tm, "");
  }
  function dd(ie, pe, nt) {
    if (pe = pp(pe), pp(ie) !== pe && nt) throw Error(J(425));
  }
  function hd() {
  }
  var vp = null, tf = null;
  function uc(ie, pe) {
    return ie === "textarea" || ie === "noscript" || typeof pe.children == "string" || typeof pe.children == "number" || typeof pe.dangerouslySetInnerHTML == "object" && pe.dangerouslySetInnerHTML !== null && pe.dangerouslySetInnerHTML.__html != null;
  }
  var rf = typeof setTimeout == "function" ? setTimeout : void 0, A1 = typeof clearTimeout == "function" ? clearTimeout : void 0, yp = typeof Promise == "function" ? Promise : void 0, mp = typeof queueMicrotask == "function" ? queueMicrotask : typeof yp < "u" ? function(ie) {
    return yp.resolve(null).then(ie).catch(rm);
  } : rf;
  function rm(ie) {
    setTimeout(function() {
      throw ie;
    });
  }
  function $u(ie, pe) {
    var nt = pe, pt = 0;
    do {
      var Tt = nt.nextSibling;
      if (ie.removeChild(nt), Tt && Tt.nodeType === 8) if (nt = Tt.data, nt === "/$") {
        if (pt === 0) {
          ie.removeChild(Tt), wu(pe);
          return;
        }
        pt--;
      } else nt !== "$" && nt !== "$?" && nt !== "$!" || pt++;
      nt = Tt;
    } while (nt);
    wu(pe);
  }
  function ms(ie) {
    for (; ie != null; ie = ie.nextSibling) {
      var pe = ie.nodeType;
      if (pe === 1 || pe === 3) break;
      if (pe === 8) {
        if (pe = ie.data, pe === "$" || pe === "$!" || pe === "$?") break;
        if (pe === "/$") return null;
      }
    }
    return ie;
  }
  function fc(ie) {
    ie = ie.previousSibling;
    for (var pe = 0; ie; ) {
      if (ie.nodeType === 8) {
        var nt = ie.data;
        if (nt === "$" || nt === "$!" || nt === "$?") {
          if (pe === 0) return ie;
          pe--;
        } else nt === "/$" && pe++;
      }
      ie = ie.previousSibling;
    }
    return null;
  }
  var xu = Math.random().toString(36).slice(2), $s = "__reactFiber$" + xu, nf = "__reactProps$" + xu, Gs = "__reactContainer$" + xu, gp = "__reactEvents$" + xu, nm = "__reactListeners$" + xu, bp = "__reactHandles$" + xu;
  function Go(ie) {
    var pe = ie[$s];
    if (pe) return pe;
    for (var nt = ie.parentNode; nt; ) {
      if (pe = nt[Gs] || nt[$s]) {
        if (nt = pe.alternate, pe.child !== null || nt !== null && nt.child !== null) for (ie = fc(ie); ie !== null; ) {
          if (nt = ie[$s]) return nt;
          ie = fc(ie);
        }
        return pe;
      }
      ie = nt, nt = ie.parentNode;
    }
    return null;
  }
  function lc(ie) {
    return ie = ie[$s] || ie[Gs], !ie || ie.tag !== 5 && ie.tag !== 6 && ie.tag !== 13 && ie.tag !== 3 ? null : ie;
  }
  function Yf(ie) {
    if (ie.tag === 5 || ie.tag === 6) return ie.stateNode;
    throw Error(J(33));
  }
  function Xn(ie) {
    return ie[nf] || null;
  }
  var Tu = [], Gi = -1;
  function hi(ie) {
    return { current: ie };
  }
  function Oi(ie) {
    0 > Gi || (ie.current = Tu[Gi], Tu[Gi] = null, Gi--);
  }
  function Di(ie, pe) {
    Gi++, Tu[Gi] = ie.current, ie.current = pe;
  }
  var xs = {}, oi = hi(xs), fa = hi(!1), go = xs;
  function Xo(ie, pe) {
    var nt = ie.type.contextTypes;
    if (!nt) return xs;
    var pt = ie.stateNode;
    if (pt && pt.__reactInternalMemoizedUnmaskedChildContext === pe) return pt.__reactInternalMemoizedMaskedChildContext;
    var Tt = {}, Pt;
    for (Pt in nt) Tt[Pt] = pe[Pt];
    return pt && (ie = ie.stateNode, ie.__reactInternalMemoizedUnmaskedChildContext = pe, ie.__reactInternalMemoizedMaskedChildContext = Tt), Tt;
  }
  function Zi(ie) {
    return ie = ie.childContextTypes, ie != null;
  }
  function Yo() {
    Oi(fa), Oi(oi);
  }
  function Au(ie, pe, nt) {
    if (oi.current !== xs) throw Error(J(168));
    Di(oi, pe), Di(fa, nt);
  }
  function cc(ie, pe, nt) {
    var pt = ie.stateNode;
    if (pe = pe.childContextTypes, typeof pt.getChildContext != "function") return nt;
    pt = pt.getChildContext();
    for (var Tt in pt) if (!(Tt in pe)) throw Error(J(108, Dt(ie) || "Unknown", Tt));
    return vt({}, nt, pt);
  }
  function pd(ie) {
    return ie = (ie = ie.stateNode) && ie.__reactInternalMemoizedMergedChildContext || xs, go = oi.current, Di(oi, ie), Di(fa, fa.current), !0;
  }
  function R1(ie, pe, nt) {
    var pt = ie.stateNode;
    if (!pt) throw Error(J(169));
    nt ? (ie = cc(ie, pe, go), pt.__reactInternalMemoizedMergedChildContext = ie, Oi(fa), Oi(oi), Di(oi, ie)) : Oi(fa), Di(fa, nt);
  }
  var Po = null, Ma = !1, dc = !1;
  function wp(ie) {
    Po === null ? Po = [ie] : Po.push(ie);
  }
  function _p(ie) {
    Ma = !0, wp(ie);
  }
  function bo() {
    if (!dc && Po !== null) {
      dc = !0;
      var ie = 0, pe = Ci;
      try {
        var nt = Po;
        for (Ci = 1; ie < nt.length; ie++) {
          var pt = nt[ie];
          do
            pt = pt(!0);
          while (pt !== null);
        }
        Po = null, Ma = !1;
      } catch (Tt) {
        throw Po !== null && (Po = Po.slice(ie + 1)), _i(ra, bo), Tt;
      } finally {
        Ci = pe, dc = !1;
      }
    }
    return null;
  }
  var Ru = [], wo = 0, af = null, Jf = 0, _o = [], Ya = 0, Jo = null, Na = 1, Xs = "";
  function Io(ie, pe) {
    Ru[wo++] = Jf, Ru[wo++] = af, af = ie, Jf = pe;
  }
  function Sp(ie, pe, nt) {
    _o[Ya++] = Na, _o[Ya++] = Xs, _o[Ya++] = Jo, Jo = ie;
    var pt = Na;
    ie = Xs;
    var Tt = 32 - Sa(pt) - 1;
    pt &= ~(1 << Tt), nt += 1;
    var Pt = 32 - Sa(pe) + Tt;
    if (30 < Pt) {
      var Yt = Tt - Tt % 5;
      Pt = (pt & (1 << Yt) - 1).toString(32), pt >>= Yt, Tt -= Yt, Na = 1 << 32 - Sa(pe) + Tt | nt << Tt | pt, Xs = Pt + ie;
    } else Na = 1 << Pt | nt << Tt | pt, Xs = ie;
  }
  function vd(ie) {
    ie.return !== null && (Io(ie, 1), Sp(ie, 1, 0));
  }
  function Ep(ie) {
    for (; ie === af; ) af = Ru[--wo], Ru[wo] = null, Jf = Ru[--wo], Ru[wo] = null;
    for (; ie === Jo; ) Jo = _o[--Ya], _o[Ya] = null, Xs = _o[--Ya], _o[Ya] = null, Na = _o[--Ya], _o[Ya] = null;
  }
  var Do = null, So = null, Xi = !1, Qo = null;
  function $p(ie, pe) {
    var nt = os(5, null, null, 0);
    nt.elementType = "DELETED", nt.stateNode = pe, nt.return = ie, pe = ie.deletions, pe === null ? (ie.deletions = [nt], ie.flags |= 16) : pe.push(nt);
  }
  function C1(ie, pe) {
    switch (ie.tag) {
      case 5:
        var nt = ie.type;
        return pe = pe.nodeType !== 1 || nt.toLowerCase() !== pe.nodeName.toLowerCase() ? null : pe, pe !== null ? (ie.stateNode = pe, Do = ie, So = ms(pe.firstChild), !0) : !1;
      case 6:
        return pe = ie.pendingProps === "" || pe.nodeType !== 3 ? null : pe, pe !== null ? (ie.stateNode = pe, Do = ie, So = null, !0) : !1;
      case 13:
        return pe = pe.nodeType !== 8 ? null : pe, pe !== null ? (nt = Jo !== null ? { id: Na, overflow: Xs } : null, ie.memoizedState = { dehydrated: pe, treeContext: nt, retryLane: 1073741824 }, nt = os(18, null, null, 0), nt.stateNode = pe, nt.return = ie, ie.child = nt, Do = ie, So = null, !0) : !1;
      default:
        return !1;
    }
  }
  function yd(ie) {
    return (ie.mode & 1) !== 0 && (ie.flags & 128) === 0;
  }
  function md(ie) {
    if (Xi) {
      var pe = So;
      if (pe) {
        var nt = pe;
        if (!C1(ie, pe)) {
          if (yd(ie)) throw Error(J(418));
          pe = ms(nt.nextSibling);
          var pt = Do;
          pe && C1(ie, pe) ? $p(pt, nt) : (ie.flags = ie.flags & -4097 | 2, Xi = !1, Do = ie);
        }
      } else {
        if (yd(ie)) throw Error(J(418));
        ie.flags = ie.flags & -4097 | 2, Xi = !1, Do = ie;
      }
    }
  }
  function B1(ie) {
    for (ie = ie.return; ie !== null && ie.tag !== 5 && ie.tag !== 3 && ie.tag !== 13; ) ie = ie.return;
    Do = ie;
  }
  function gd(ie) {
    if (ie !== Do) return !1;
    if (!Xi) return B1(ie), Xi = !0, !1;
    var pe;
    if ((pe = ie.tag !== 3) && !(pe = ie.tag !== 5) && (pe = ie.type, pe = pe !== "head" && pe !== "body" && !uc(ie.type, ie.memoizedProps)), pe && (pe = So)) {
      if (yd(ie)) throw k1(), Error(J(418));
      for (; pe; ) $p(ie, pe), pe = ms(pe.nextSibling);
    }
    if (B1(ie), ie.tag === 13) {
      if (ie = ie.memoizedState, ie = ie !== null ? ie.dehydrated : null, !ie) throw Error(J(317));
      e: {
        for (ie = ie.nextSibling, pe = 0; ie; ) {
          if (ie.nodeType === 8) {
            var nt = ie.data;
            if (nt === "/$") {
              if (pe === 0) {
                So = ms(ie.nextSibling);
                break e;
              }
              pe--;
            } else nt !== "$" && nt !== "$!" && nt !== "$?" || pe++;
          }
          ie = ie.nextSibling;
        }
        So = null;
      }
    } else So = Do ? ms(ie.stateNode.nextSibling) : null;
    return !0;
  }
  function k1() {
    for (var ie = So; ie; ) ie = ms(ie.nextSibling);
  }
  function ia() {
    So = Do = null, Xi = !1;
  }
  function xp(ie) {
    Qo === null ? Qo = [ie] : Qo.push(ie);
  }
  var bd = Ft.ReactCurrentBatchConfig;
  function of(ie, pe, nt) {
    if (ie = nt.ref, ie !== null && typeof ie != "function" && typeof ie != "object") {
      if (nt._owner) {
        if (nt = nt._owner, nt) {
          if (nt.tag !== 1) throw Error(J(309));
          var pt = nt.stateNode;
        }
        if (!pt) throw Error(J(147, ie));
        var Tt = pt, Pt = "" + ie;
        return pe !== null && pe.ref !== null && typeof pe.ref == "function" && pe.ref._stringRef === Pt ? pe.ref : (pe = function(Yt) {
          var cr = Tt.refs;
          Yt === null ? delete cr[Pt] : cr[Pt] = Yt;
        }, pe._stringRef = Pt, pe);
      }
      if (typeof ie != "string") throw Error(J(284));
      if (!nt._owner) throw Error(J(290, ie));
    }
    return ie;
  }
  function Ts(ie, pe) {
    throw ie = Object.prototype.toString.call(pe), Error(J(31, ie === "[object Object]" ? "object with keys {" + Object.keys(pe).join(", ") + "}" : ie));
  }
  function M1(ie) {
    var pe = ie._init;
    return pe(ie._payload);
  }
  function wd(ie) {
    function pe(Rr, $r) {
      if (ie) {
        var kr = Rr.deletions;
        kr === null ? (Rr.deletions = [$r], Rr.flags |= 16) : kr.push($r);
      }
    }
    function nt(Rr, $r) {
      if (!ie) return null;
      for (; $r !== null; ) pe(Rr, $r), $r = $r.sibling;
      return null;
    }
    function pt(Rr, $r) {
      for (Rr = /* @__PURE__ */ new Map(); $r !== null; ) $r.key !== null ? Rr.set($r.key, $r) : Rr.set($r.index, $r), $r = $r.sibling;
      return Rr;
    }
    function Tt(Rr, $r) {
      return Rr = Du(Rr, $r), Rr.index = 0, Rr.sibling = null, Rr;
    }
    function Pt(Rr, $r, kr) {
      return Rr.index = kr, ie ? (kr = Rr.alternate, kr !== null ? (kr = kr.index, kr < $r ? (Rr.flags |= 2, $r) : kr) : (Rr.flags |= 2, $r)) : (Rr.flags |= 1048576, $r);
    }
    function Yt(Rr) {
      return ie && Rr.alternate === null && (Rr.flags |= 2), Rr;
    }
    function cr(Rr, $r, kr, un) {
      return $r === null || $r.tag !== 6 ? ($r = lh(kr, Rr.mode, un), $r.return = Rr, $r) : ($r = Tt($r, kr), $r.return = Rr, $r);
    }
    function wr(Rr, $r, kr, un) {
      var jn = kr.type;
      return jn === yr ? en(Rr, $r, kr.props.children, un, kr.key) : $r !== null && ($r.elementType === jn || typeof jn == "object" && jn !== null && jn.$$typeof === mt && M1(jn) === $r.type) ? (un = Tt($r, kr.props), un.ref = of(Rr, $r, kr), un.return = Rr, un) : (un = uh(kr.type, kr.key, kr.props, null, Rr.mode, un), un.ref = of(Rr, $r, kr), un.return = Rr, un);
    }
    function Lr(Rr, $r, kr, un) {
      return $r === null || $r.tag !== 4 || $r.stateNode.containerInfo !== kr.containerInfo || $r.stateNode.implementation !== kr.implementation ? ($r = Bc(kr, Rr.mode, un), $r.return = Rr, $r) : ($r = Tt($r, kr.children || []), $r.return = Rr, $r);
    }
    function en(Rr, $r, kr, un, jn) {
      return $r === null || $r.tag !== 7 ? ($r = _f(kr, Rr.mode, un, jn), $r.return = Rr, $r) : ($r = Tt($r, kr), $r.return = Rr, $r);
    }
    function rn(Rr, $r, kr) {
      if (typeof $r == "string" && $r !== "" || typeof $r == "number") return $r = lh("" + $r, Rr.mode, kr), $r.return = Rr, $r;
      if (typeof $r == "object" && $r !== null) {
        switch ($r.$$typeof) {
          case Jt:
            return kr = uh($r.type, $r.key, $r.props, null, Rr.mode, kr), kr.ref = of(Rr, null, $r), kr.return = Rr, kr;
          case Vt:
            return $r = Bc($r, Rr.mode, kr), $r.return = Rr, $r;
          case mt:
            var un = $r._init;
            return rn(Rr, un($r._payload), kr);
        }
        if (Wn($r) || xt($r)) return $r = _f($r, Rr.mode, kr, null), $r.return = Rr, $r;
        Ts(Rr, $r);
      }
      return null;
    }
    function Qr(Rr, $r, kr, un) {
      var jn = $r !== null ? $r.key : null;
      if (typeof kr == "string" && kr !== "" || typeof kr == "number") return jn !== null ? null : cr(Rr, $r, "" + kr, un);
      if (typeof kr == "object" && kr !== null) {
        switch (kr.$$typeof) {
          case Jt:
            return kr.key === jn ? wr(Rr, $r, kr, un) : null;
          case Vt:
            return kr.key === jn ? Lr(Rr, $r, kr, un) : null;
          case mt:
            return jn = kr._init, Qr(
              Rr,
              $r,
              jn(kr._payload),
              un
            );
        }
        if (Wn(kr) || xt(kr)) return jn !== null ? null : en(Rr, $r, kr, un, null);
        Ts(Rr, kr);
      }
      return null;
    }
    function An(Rr, $r, kr, un, jn) {
      if (typeof un == "string" && un !== "" || typeof un == "number") return Rr = Rr.get(kr) || null, cr($r, Rr, "" + un, jn);
      if (typeof un == "object" && un !== null) {
        switch (un.$$typeof) {
          case Jt:
            return Rr = Rr.get(un.key === null ? kr : un.key) || null, wr($r, Rr, un, jn);
          case Vt:
            return Rr = Rr.get(un.key === null ? kr : un.key) || null, Lr($r, Rr, un, jn);
          case mt:
            var ei = un._init;
            return An(Rr, $r, kr, ei(un._payload), jn);
        }
        if (Wn(un) || xt(un)) return Rr = Rr.get(kr) || null, en($r, Rr, un, jn, null);
        Ts($r, un);
      }
      return null;
    }
    function Nn(Rr, $r, kr, un) {
      for (var jn = null, ei = null, Ln = $r, ri = $r = 0, Aa = null; Ln !== null && ri < kr.length; ri++) {
        Ln.index > ri ? (Aa = Ln, Ln = null) : Aa = Ln.sibling;
        var Bi = Qr(Rr, Ln, kr[ri], un);
        if (Bi === null) {
          Ln === null && (Ln = Aa);
          break;
        }
        ie && Ln && Bi.alternate === null && pe(Rr, Ln), $r = Pt(Bi, $r, ri), ei === null ? jn = Bi : ei.sibling = Bi, ei = Bi, Ln = Aa;
      }
      if (ri === kr.length) return nt(Rr, Ln), Xi && Io(Rr, ri), jn;
      if (Ln === null) {
        for (; ri < kr.length; ri++) Ln = rn(Rr, kr[ri], un), Ln !== null && ($r = Pt(Ln, $r, ri), ei === null ? jn = Ln : ei.sibling = Ln, ei = Ln);
        return Xi && Io(Rr, ri), jn;
      }
      for (Ln = pt(Rr, Ln); ri < kr.length; ri++) Aa = An(Ln, Rr, ri, kr[ri], un), Aa !== null && (ie && Aa.alternate !== null && Ln.delete(Aa.key === null ? ri : Aa.key), $r = Pt(Aa, $r, ri), ei === null ? jn = Aa : ei.sibling = Aa, ei = Aa);
      return ie && Ln.forEach(function(ru) {
        return pe(Rr, ru);
      }), Xi && Io(Rr, ri), jn;
    }
    function Fn(Rr, $r, kr, un) {
      var jn = xt(kr);
      if (typeof jn != "function") throw Error(J(150));
      if (kr = jn.call(kr), kr == null) throw Error(J(151));
      for (var ei = jn = null, Ln = $r, ri = $r = 0, Aa = null, Bi = kr.next(); Ln !== null && !Bi.done; ri++, Bi = kr.next()) {
        Ln.index > ri ? (Aa = Ln, Ln = null) : Aa = Ln.sibling;
        var ru = Qr(Rr, Ln, Bi.value, un);
        if (ru === null) {
          Ln === null && (Ln = Aa);
          break;
        }
        ie && Ln && ru.alternate === null && pe(Rr, Ln), $r = Pt(ru, $r, ri), ei === null ? jn = ru : ei.sibling = ru, ei = ru, Ln = Aa;
      }
      if (Bi.done) return nt(
        Rr,
        Ln
      ), Xi && Io(Rr, ri), jn;
      if (Ln === null) {
        for (; !Bi.done; ri++, Bi = kr.next()) Bi = rn(Rr, Bi.value, un), Bi !== null && ($r = Pt(Bi, $r, ri), ei === null ? jn = Bi : ei.sibling = Bi, ei = Bi);
        return Xi && Io(Rr, ri), jn;
      }
      for (Ln = pt(Rr, Ln); !Bi.done; ri++, Bi = kr.next()) Bi = An(Ln, Rr, ri, Bi.value, un), Bi !== null && (ie && Bi.alternate !== null && Ln.delete(Bi.key === null ? ri : Bi.key), $r = Pt(Bi, $r, ri), ei === null ? jn = Bi : ei.sibling = Bi, ei = Bi);
      return ie && Ln.forEach(function(_m) {
        return pe(Rr, _m);
      }), Xi && Io(Rr, ri), jn;
    }
    function va(Rr, $r, kr, un) {
      if (typeof kr == "object" && kr !== null && kr.type === yr && kr.key === null && (kr = kr.props.children), typeof kr == "object" && kr !== null) {
        switch (kr.$$typeof) {
          case Jt:
            e: {
              for (var jn = kr.key, ei = $r; ei !== null; ) {
                if (ei.key === jn) {
                  if (jn = kr.type, jn === yr) {
                    if (ei.tag === 7) {
                      nt(Rr, ei.sibling), $r = Tt(ei, kr.props.children), $r.return = Rr, Rr = $r;
                      break e;
                    }
                  } else if (ei.elementType === jn || typeof jn == "object" && jn !== null && jn.$$typeof === mt && M1(jn) === ei.type) {
                    nt(Rr, ei.sibling), $r = Tt(ei, kr.props), $r.ref = of(Rr, ei, kr), $r.return = Rr, Rr = $r;
                    break e;
                  }
                  nt(Rr, ei);
                  break;
                } else pe(Rr, ei);
                ei = ei.sibling;
              }
              kr.type === yr ? ($r = _f(kr.props.children, Rr.mode, un, kr.key), $r.return = Rr, Rr = $r) : (un = uh(kr.type, kr.key, kr.props, null, Rr.mode, un), un.ref = of(Rr, $r, kr), un.return = Rr, Rr = un);
            }
            return Yt(Rr);
          case Vt:
            e: {
              for (ei = kr.key; $r !== null; ) {
                if ($r.key === ei) if ($r.tag === 4 && $r.stateNode.containerInfo === kr.containerInfo && $r.stateNode.implementation === kr.implementation) {
                  nt(Rr, $r.sibling), $r = Tt($r, kr.children || []), $r.return = Rr, Rr = $r;
                  break e;
                } else {
                  nt(Rr, $r);
                  break;
                }
                else pe(Rr, $r);
                $r = $r.sibling;
              }
              $r = Bc(kr, Rr.mode, un), $r.return = Rr, Rr = $r;
            }
            return Yt(Rr);
          case mt:
            return ei = kr._init, va(Rr, $r, ei(kr._payload), un);
        }
        if (Wn(kr)) return Nn(Rr, $r, kr, un);
        if (xt(kr)) return Fn(Rr, $r, kr, un);
        Ts(Rr, kr);
      }
      return typeof kr == "string" && kr !== "" || typeof kr == "number" ? (kr = "" + kr, $r !== null && $r.tag === 6 ? (nt(Rr, $r.sibling), $r = Tt($r, kr), $r.return = Rr, Rr = $r) : (nt(Rr, $r), $r = lh(kr, Rr.mode, un), $r.return = Rr, Rr = $r), Yt(Rr)) : nt(Rr, $r);
    }
    return va;
  }
  var Qf = wd(!0), O1 = wd(!1), Ys = hi(null), Ea = null, yn = null, Zo = null;
  function No() {
    Zo = yn = Ea = null;
  }
  function Tp(ie) {
    var pe = Ys.current;
    Oi(Ys), ie._currentValue = pe;
  }
  function Ap(ie, pe, nt) {
    for (; ie !== null; ) {
      var pt = ie.alternate;
      if ((ie.childLanes & pe) !== pe ? (ie.childLanes |= pe, pt !== null && (pt.childLanes |= pe)) : pt !== null && (pt.childLanes & pe) !== pe && (pt.childLanes |= pe), ie === nt) break;
      ie = ie.return;
    }
  }
  function Zf(ie, pe) {
    Ea = ie, Zo = yn = null, ie = ie.dependencies, ie !== null && ie.firstContext !== null && (ie.lanes & pe && (xo = !0), ie.firstContext = null);
  }
  function es(ie) {
    var pe = ie._currentValue;
    if (Zo !== ie) if (ie = { context: ie, memoizedValue: pe, next: null }, yn === null) {
      if (Ea === null) throw Error(J(308));
      yn = ie, Ea.dependencies = { lanes: 0, firstContext: ie };
    } else yn = yn.next = ie;
    return pe;
  }
  var sf = null;
  function ba(ie) {
    sf === null ? sf = [ie] : sf.push(ie);
  }
  function P1(ie, pe, nt, pt) {
    var Tt = pe.interleaved;
    return Tt === null ? (nt.next = nt, ba(pe)) : (nt.next = Tt.next, Tt.next = nt), pe.interleaved = nt, Js(ie, pt);
  }
  function Js(ie, pe) {
    ie.lanes |= pe;
    var nt = ie.alternate;
    for (nt !== null && (nt.lanes |= pe), nt = ie, ie = ie.return; ie !== null; ) ie.childLanes |= pe, nt = ie.alternate, nt !== null && (nt.childLanes |= pe), nt = ie, ie = ie.return;
    return nt.tag === 3 ? nt.stateNode : null;
  }
  var Cu = !1;
  function _d(ie) {
    ie.updateQueue = { baseState: ie.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function el(ie, pe) {
    ie = ie.updateQueue, pe.updateQueue === ie && (pe.updateQueue = { baseState: ie.baseState, firstBaseUpdate: ie.firstBaseUpdate, lastBaseUpdate: ie.lastBaseUpdate, shared: ie.shared, effects: ie.effects });
  }
  function Eo(ie, pe) {
    return { eventTime: ie, lane: pe, tag: 0, payload: null, callback: null, next: null };
  }
  function Bu(ie, pe, nt) {
    var pt = ie.updateQueue;
    if (pt === null) return null;
    if (pt = pt.shared, bi & 2) {
      var Tt = pt.pending;
      return Tt === null ? pe.next = pe : (pe.next = Tt.next, Tt.next = pe), pt.pending = pe, Js(ie, nt);
    }
    return Tt = pt.interleaved, Tt === null ? (pe.next = pe, ba(pt)) : (pe.next = Tt.next, Tt.next = pe), pt.interleaved = pe, Js(ie, nt);
  }
  function Sd(ie, pe, nt) {
    if (pe = pe.updateQueue, pe !== null && (pe = pe.shared, (nt & 4194240) !== 0)) {
      var pt = pe.lanes;
      pt &= ie.pendingLanes, nt |= pt, pe.lanes = nt, Ss(ie, nt);
    }
  }
  function I1(ie, pe) {
    var nt = ie.updateQueue, pt = ie.alternate;
    if (pt !== null && (pt = pt.updateQueue, nt === pt)) {
      var Tt = null, Pt = null;
      if (nt = nt.firstBaseUpdate, nt !== null) {
        do {
          var Yt = { eventTime: nt.eventTime, lane: nt.lane, tag: nt.tag, payload: nt.payload, callback: nt.callback, next: null };
          Pt === null ? Tt = Pt = Yt : Pt = Pt.next = Yt, nt = nt.next;
        } while (nt !== null);
        Pt === null ? Tt = Pt = pe : Pt = Pt.next = pe;
      } else Tt = Pt = pe;
      nt = { baseState: pt.baseState, firstBaseUpdate: Tt, lastBaseUpdate: Pt, shared: pt.shared, effects: pt.effects }, ie.updateQueue = nt;
      return;
    }
    ie = nt.lastBaseUpdate, ie === null ? nt.firstBaseUpdate = pe : ie.next = pe, nt.lastBaseUpdate = pe;
  }
  function Ed(ie, pe, nt, pt) {
    var Tt = ie.updateQueue;
    Cu = !1;
    var Pt = Tt.firstBaseUpdate, Yt = Tt.lastBaseUpdate, cr = Tt.shared.pending;
    if (cr !== null) {
      Tt.shared.pending = null;
      var wr = cr, Lr = wr.next;
      wr.next = null, Yt === null ? Pt = Lr : Yt.next = Lr, Yt = wr;
      var en = ie.alternate;
      en !== null && (en = en.updateQueue, cr = en.lastBaseUpdate, cr !== Yt && (cr === null ? en.firstBaseUpdate = Lr : cr.next = Lr, en.lastBaseUpdate = wr));
    }
    if (Pt !== null) {
      var rn = Tt.baseState;
      Yt = 0, en = Lr = wr = null, cr = Pt;
      do {
        var Qr = cr.lane, An = cr.eventTime;
        if ((pt & Qr) === Qr) {
          en !== null && (en = en.next = {
            eventTime: An,
            lane: 0,
            tag: cr.tag,
            payload: cr.payload,
            callback: cr.callback,
            next: null
          });
          e: {
            var Nn = ie, Fn = cr;
            switch (Qr = pe, An = nt, Fn.tag) {
              case 1:
                if (Nn = Fn.payload, typeof Nn == "function") {
                  rn = Nn.call(An, rn, Qr);
                  break e;
                }
                rn = Nn;
                break e;
              case 3:
                Nn.flags = Nn.flags & -65537 | 128;
              case 0:
                if (Nn = Fn.payload, Qr = typeof Nn == "function" ? Nn.call(An, rn, Qr) : Nn, Qr == null) break e;
                rn = vt({}, rn, Qr);
                break e;
              case 2:
                Cu = !0;
            }
          }
          cr.callback !== null && cr.lane !== 0 && (ie.flags |= 64, Qr = Tt.effects, Qr === null ? Tt.effects = [cr] : Qr.push(cr));
        } else An = { eventTime: An, lane: Qr, tag: cr.tag, payload: cr.payload, callback: cr.callback, next: null }, en === null ? (Lr = en = An, wr = rn) : en = en.next = An, Yt |= Qr;
        if (cr = cr.next, cr === null) {
          if (cr = Tt.shared.pending, cr === null) break;
          Qr = cr, cr = Qr.next, Qr.next = null, Tt.lastBaseUpdate = Qr, Tt.shared.pending = null;
        }
      } while (!0);
      if (en === null && (wr = rn), Tt.baseState = wr, Tt.firstBaseUpdate = Lr, Tt.lastBaseUpdate = en, pe = Tt.shared.interleaved, pe !== null) {
        Tt = pe;
        do
          Yt |= Tt.lane, Tt = Tt.next;
        while (Tt !== pe);
      } else Pt === null && (Tt.shared.lanes = 0);
      mf |= Yt, ie.lanes = Yt, ie.memoizedState = rn;
    }
  }
  function D1(ie, pe, nt) {
    if (ie = pe.effects, pe.effects = null, ie !== null) for (pe = 0; pe < ie.length; pe++) {
      var pt = ie[pe], Tt = pt.callback;
      if (Tt !== null) {
        if (pt.callback = null, pt = nt, typeof Tt != "function") throw Error(J(191, Tt));
        Tt.call(pt);
      }
    }
  }
  var hc = {}, gs = hi(hc), tl = hi(hc), pc = hi(hc);
  function uf(ie) {
    if (ie === hc) throw Error(J(174));
    return ie;
  }
  function Rp(ie, pe) {
    switch (Di(pc, pe), Di(tl, ie), Di(gs, hc), ie = pe.nodeType, ie) {
      case 9:
      case 11:
        pe = (pe = pe.documentElement) ? pe.namespaceURI : gn(null, "");
        break;
      default:
        ie = ie === 8 ? pe.parentNode : pe, pe = ie.namespaceURI || null, ie = ie.tagName, pe = gn(pe, ie);
    }
    Oi(gs), Di(gs, pe);
  }
  function rl() {
    Oi(gs), Oi(tl), Oi(pc);
  }
  function N1(ie) {
    uf(pc.current);
    var pe = uf(gs.current), nt = gn(pe, ie.type);
    pe !== nt && (Di(tl, ie), Di(gs, nt));
  }
  function Cp(ie) {
    tl.current === ie && (Oi(gs), Oi(tl));
  }
  var ea = hi(0);
  function $d(ie) {
    for (var pe = ie; pe !== null; ) {
      if (pe.tag === 13) {
        var nt = pe.memoizedState;
        if (nt !== null && (nt = nt.dehydrated, nt === null || nt.data === "$?" || nt.data === "$!")) return pe;
      } else if (pe.tag === 19 && pe.memoizedProps.revealOrder !== void 0) {
        if (pe.flags & 128) return pe;
      } else if (pe.child !== null) {
        pe.child.return = pe, pe = pe.child;
        continue;
      }
      if (pe === ie) break;
      for (; pe.sibling === null; ) {
        if (pe.return === null || pe.return === ie) return null;
        pe = pe.return;
      }
      pe.sibling.return = pe.return, pe = pe.sibling;
    }
    return null;
  }
  var xd = [];
  function Bp() {
    for (var ie = 0; ie < xd.length; ie++) xd[ie]._workInProgressVersionPrimary = null;
    xd.length = 0;
  }
  var Td = Ft.ReactCurrentDispatcher, vc = Ft.ReactCurrentBatchConfig, Hn = 0, zn = null, si = null, mi = null, Lo = !1, nl = !1, yc = 0, im = 0;
  function Ja() {
    throw Error(J(321));
  }
  function mc(ie, pe) {
    if (pe === null) return !1;
    for (var nt = 0; nt < pe.length && nt < ie.length; nt++) if (!Vo(ie[nt], pe[nt])) return !1;
    return !0;
  }
  function Jr(ie, pe, nt, pt, Tt, Pt) {
    if (Hn = Pt, zn = pe, pe.memoizedState = null, pe.updateQueue = null, pe.lanes = 0, Td.current = ie === null || ie.memoizedState === null ? am : Vi, ie = nt(pt, Tt), nl) {
      Pt = 0;
      do {
        if (nl = !1, yc = 0, 25 <= Pt) throw Error(J(301));
        Pt += 1, mi = si = null, pe.updateQueue = null, Td.current = jd, ie = nt(pt, Tt);
      } while (nl);
    }
    if (Td.current = Qa, pe = si !== null && si.next !== null, Hn = 0, mi = si = zn = null, Lo = !1, pe) throw Error(J(300));
    return ie;
  }
  function wa() {
    var ie = yc !== 0;
    return yc = 0, ie;
  }
  function Vn() {
    var ie = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return mi === null ? zn.memoizedState = mi = ie : mi = mi.next = ie, mi;
  }
  function La() {
    if (si === null) {
      var ie = zn.alternate;
      ie = ie !== null ? ie.memoizedState : null;
    } else ie = si.next;
    var pe = mi === null ? zn.memoizedState : mi.next;
    if (pe !== null) mi = pe, si = ie;
    else {
      if (ie === null) throw Error(J(310));
      si = ie, ie = { memoizedState: si.memoizedState, baseState: si.baseState, baseQueue: si.baseQueue, queue: si.queue, next: null }, mi === null ? zn.memoizedState = mi = ie : mi = mi.next = ie;
    }
    return mi;
  }
  function Uo(ie, pe) {
    return typeof pe == "function" ? pe(ie) : pe;
  }
  function Qs(ie) {
    var pe = La(), nt = pe.queue;
    if (nt === null) throw Error(J(311));
    nt.lastRenderedReducer = ie;
    var pt = si, Tt = pt.baseQueue, Pt = nt.pending;
    if (Pt !== null) {
      if (Tt !== null) {
        var Yt = Tt.next;
        Tt.next = Pt.next, Pt.next = Yt;
      }
      pt.baseQueue = Tt = Pt, nt.pending = null;
    }
    if (Tt !== null) {
      Pt = Tt.next, pt = pt.baseState;
      var cr = Yt = null, wr = null, Lr = Pt;
      do {
        var en = Lr.lane;
        if ((Hn & en) === en) wr !== null && (wr = wr.next = { lane: 0, action: Lr.action, hasEagerState: Lr.hasEagerState, eagerState: Lr.eagerState, next: null }), pt = Lr.hasEagerState ? Lr.eagerState : ie(pt, Lr.action);
        else {
          var rn = {
            lane: en,
            action: Lr.action,
            hasEagerState: Lr.hasEagerState,
            eagerState: Lr.eagerState,
            next: null
          };
          wr === null ? (cr = wr = rn, Yt = pt) : wr = wr.next = rn, zn.lanes |= en, mf |= en;
        }
        Lr = Lr.next;
      } while (Lr !== null && Lr !== Pt);
      wr === null ? Yt = pt : wr.next = cr, Vo(pt, pe.memoizedState) || (xo = !0), pe.memoizedState = pt, pe.baseState = Yt, pe.baseQueue = wr, nt.lastRenderedState = pt;
    }
    if (ie = nt.interleaved, ie !== null) {
      Tt = ie;
      do
        Pt = Tt.lane, zn.lanes |= Pt, mf |= Pt, Tt = Tt.next;
      while (Tt !== ie);
    } else Tt === null && (nt.lanes = 0);
    return [pe.memoizedState, nt.dispatch];
  }
  function ts(ie) {
    var pe = La(), nt = pe.queue;
    if (nt === null) throw Error(J(311));
    nt.lastRenderedReducer = ie;
    var pt = nt.dispatch, Tt = nt.pending, Pt = pe.memoizedState;
    if (Tt !== null) {
      nt.pending = null;
      var Yt = Tt = Tt.next;
      do
        Pt = ie(Pt, Yt.action), Yt = Yt.next;
      while (Yt !== Tt);
      Vo(Pt, pe.memoizedState) || (xo = !0), pe.memoizedState = Pt, pe.baseQueue === null && (pe.baseState = Pt), nt.lastRenderedState = Pt;
    }
    return [Pt, pt];
  }
  function il() {
  }
  function ff(ie, pe) {
    var nt = zn, pt = La(), Tt = pe(), Pt = !Vo(pt.memoizedState, Tt);
    if (Pt && (pt.memoizedState = Tt, xo = !0), pt = pt.queue, gc(Rd.bind(null, nt, pt, ie), [ie]), pt.getSnapshot !== pe || Pt || mi !== null && mi.memoizedState.tag & 1) {
      if (nt.flags |= 2048, lf(9, Ad.bind(null, nt, pt, Tt, pe), void 0, null), ca === null) throw Error(J(349));
      Hn & 30 || al(nt, pe, Tt);
    }
    return Tt;
  }
  function al(ie, pe, nt) {
    ie.flags |= 16384, ie = { getSnapshot: pe, value: nt }, pe = zn.updateQueue, pe === null ? (pe = { lastEffect: null, stores: null }, zn.updateQueue = pe, pe.stores = [ie]) : (nt = pe.stores, nt === null ? pe.stores = [ie] : nt.push(ie));
  }
  function Ad(ie, pe, nt, pt) {
    pe.value = nt, pe.getSnapshot = pt, Cd(pe) && Bd(ie);
  }
  function Rd(ie, pe, nt) {
    return nt(function() {
      Cd(pe) && Bd(ie);
    });
  }
  function Cd(ie) {
    var pe = ie.getSnapshot;
    ie = ie.value;
    try {
      var nt = pe();
      return !Vo(ie, nt);
    } catch {
      return !0;
    }
  }
  function Bd(ie) {
    var pe = Js(ie, 1);
    pe !== null && aa(pe, ie, 1, -1);
  }
  function kd(ie) {
    var pe = Vn();
    return typeof ie == "function" && (ie = ie()), pe.memoizedState = pe.baseState = ie, ie = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Uo, lastRenderedState: ie }, pe.queue = ie, ie = ie.dispatch = bc.bind(null, zn, ie), [pe.memoizedState, ie];
  }
  function lf(ie, pe, nt, pt) {
    return ie = { tag: ie, create: pe, destroy: nt, deps: pt, next: null }, pe = zn.updateQueue, pe === null ? (pe = { lastEffect: null, stores: null }, zn.updateQueue = pe, pe.lastEffect = ie.next = ie) : (nt = pe.lastEffect, nt === null ? pe.lastEffect = ie.next = ie : (pt = nt.next, nt.next = ie, ie.next = pt, pe.lastEffect = ie)), ie;
  }
  function Md() {
    return La().memoizedState;
  }
  function ol(ie, pe, nt, pt) {
    var Tt = Vn();
    zn.flags |= ie, Tt.memoizedState = lf(1 | pe, nt, void 0, pt === void 0 ? null : pt);
  }
  function ul(ie, pe, nt, pt) {
    var Tt = La();
    pt = pt === void 0 ? null : pt;
    var Pt = void 0;
    if (si !== null) {
      var Yt = si.memoizedState;
      if (Pt = Yt.destroy, pt !== null && mc(pt, Yt.deps)) {
        Tt.memoizedState = lf(pe, nt, Pt, pt);
        return;
      }
    }
    zn.flags |= ie, Tt.memoizedState = lf(1 | pe, nt, Pt, pt);
  }
  function Od(ie, pe) {
    return ol(8390656, 8, ie, pe);
  }
  function gc(ie, pe) {
    return ul(2048, 8, ie, pe);
  }
  function Pd(ie, pe) {
    return ul(4, 2, ie, pe);
  }
  function Dd(ie, pe) {
    return ul(4, 4, ie, pe);
  }
  function Nd(ie, pe) {
    if (typeof pe == "function") return ie = ie(), pe(ie), function() {
      pe(null);
    };
    if (pe != null) return ie = ie(), pe.current = ie, function() {
      pe.current = null;
    };
  }
  function Ld(ie, pe, nt) {
    return nt = nt != null ? nt.concat([ie]) : null, ul(4, 4, Nd.bind(null, pe, ie), nt);
  }
  function fl() {
  }
  function cf(ie, pe) {
    var nt = La();
    pe = pe === void 0 ? null : pe;
    var pt = nt.memoizedState;
    return pt !== null && pe !== null && mc(pe, pt[1]) ? pt[0] : (nt.memoizedState = [ie, pe], ie);
  }
  function Ud(ie, pe) {
    var nt = La();
    pe = pe === void 0 ? null : pe;
    var pt = nt.memoizedState;
    return pt !== null && pe !== null && mc(pe, pt[1]) ? pt[0] : (ie = ie(), nt.memoizedState = [ie, pe], ie);
  }
  function Fd(ie, pe, nt) {
    return Hn & 21 ? (Vo(nt, pe) || (nt = If(), zn.lanes |= nt, mf |= nt, ie.baseState = !0), pe) : (ie.baseState && (ie.baseState = !1, xo = !0), ie.memoizedState = nt);
  }
  function kp(ie, pe) {
    var nt = Ci;
    Ci = nt !== 0 && 4 > nt ? nt : 4, ie(!0);
    var pt = vc.transition;
    vc.transition = {};
    try {
      ie(!1), pe();
    } finally {
      Ci = nt, vc.transition = pt;
    }
  }
  function Hd() {
    return La().memoizedState;
  }
  function L1(ie, pe, nt) {
    var pt = tu(ie);
    if (nt = { lane: pt, action: nt, hasEagerState: !1, eagerState: null, next: null }, Mp(ie)) ll(pe, nt);
    else if (nt = P1(ie, pe, nt, pt), nt !== null) {
      var Tt = Ia();
      aa(nt, ie, pt, Tt), ku(nt, pe, pt);
    }
  }
  function bc(ie, pe, nt) {
    var pt = tu(ie), Tt = { lane: pt, action: nt, hasEagerState: !1, eagerState: null, next: null };
    if (Mp(ie)) ll(pe, Tt);
    else {
      var Pt = ie.alternate;
      if (ie.lanes === 0 && (Pt === null || Pt.lanes === 0) && (Pt = pe.lastRenderedReducer, Pt !== null)) try {
        var Yt = pe.lastRenderedState, cr = Pt(Yt, nt);
        if (Tt.hasEagerState = !0, Tt.eagerState = cr, Vo(cr, Yt)) {
          var wr = pe.interleaved;
          wr === null ? (Tt.next = Tt, ba(pe)) : (Tt.next = wr.next, wr.next = Tt), pe.interleaved = Tt;
          return;
        }
      } catch {
      } finally {
      }
      nt = P1(ie, pe, Tt, pt), nt !== null && (Tt = Ia(), aa(nt, ie, pt, Tt), ku(nt, pe, pt));
    }
  }
  function Mp(ie) {
    var pe = ie.alternate;
    return ie === zn || pe !== null && pe === zn;
  }
  function ll(ie, pe) {
    nl = Lo = !0;
    var nt = ie.pending;
    nt === null ? pe.next = pe : (pe.next = nt.next, nt.next = pe), ie.pending = pe;
  }
  function ku(ie, pe, nt) {
    if (nt & 4194240) {
      var pt = pe.lanes;
      pt &= ie.pendingLanes, nt |= pt, pe.lanes = nt, Ss(ie, nt);
    }
  }
  var Qa = { readContext: es, useCallback: Ja, useContext: Ja, useEffect: Ja, useImperativeHandle: Ja, useInsertionEffect: Ja, useLayoutEffect: Ja, useMemo: Ja, useReducer: Ja, useRef: Ja, useState: Ja, useDebugValue: Ja, useDeferredValue: Ja, useTransition: Ja, useMutableSource: Ja, useSyncExternalStore: Ja, useId: Ja, unstable_isNewReconciler: !1 }, am = { readContext: es, useCallback: function(ie, pe) {
    return Vn().memoizedState = [ie, pe === void 0 ? null : pe], ie;
  }, useContext: es, useEffect: Od, useImperativeHandle: function(ie, pe, nt) {
    return nt = nt != null ? nt.concat([ie]) : null, ol(
      4194308,
      4,
      Nd.bind(null, pe, ie),
      nt
    );
  }, useLayoutEffect: function(ie, pe) {
    return ol(4194308, 4, ie, pe);
  }, useInsertionEffect: function(ie, pe) {
    return ol(4, 2, ie, pe);
  }, useMemo: function(ie, pe) {
    var nt = Vn();
    return pe = pe === void 0 ? null : pe, ie = ie(), nt.memoizedState = [ie, pe], ie;
  }, useReducer: function(ie, pe, nt) {
    var pt = Vn();
    return pe = nt !== void 0 ? nt(pe) : pe, pt.memoizedState = pt.baseState = pe, ie = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ie, lastRenderedState: pe }, pt.queue = ie, ie = ie.dispatch = L1.bind(null, zn, ie), [pt.memoizedState, ie];
  }, useRef: function(ie) {
    var pe = Vn();
    return ie = { current: ie }, pe.memoizedState = ie;
  }, useState: kd, useDebugValue: fl, useDeferredValue: function(ie) {
    return Vn().memoizedState = ie;
  }, useTransition: function() {
    var ie = kd(!1), pe = ie[0];
    return ie = kp.bind(null, ie[1]), Vn().memoizedState = ie, [pe, ie];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(ie, pe, nt) {
    var pt = zn, Tt = Vn();
    if (Xi) {
      if (nt === void 0) throw Error(J(407));
      nt = nt();
    } else {
      if (nt = pe(), ca === null) throw Error(J(349));
      Hn & 30 || al(pt, pe, nt);
    }
    Tt.memoizedState = nt;
    var Pt = { value: nt, getSnapshot: pe };
    return Tt.queue = Pt, Od(Rd.bind(
      null,
      pt,
      Pt,
      ie
    ), [ie]), pt.flags |= 2048, lf(9, Ad.bind(null, pt, Pt, nt, pe), void 0, null), nt;
  }, useId: function() {
    var ie = Vn(), pe = ca.identifierPrefix;
    if (Xi) {
      var nt = Xs, pt = Na;
      nt = (pt & ~(1 << 32 - Sa(pt) - 1)).toString(32) + nt, pe = ":" + pe + "R" + nt, nt = yc++, 0 < nt && (pe += "H" + nt.toString(32)), pe += ":";
    } else nt = im++, pe = ":" + pe + "r" + nt.toString(32) + ":";
    return ie.memoizedState = pe;
  }, unstable_isNewReconciler: !1 }, Vi = {
    readContext: es,
    useCallback: cf,
    useContext: es,
    useEffect: gc,
    useImperativeHandle: Ld,
    useInsertionEffect: Pd,
    useLayoutEffect: Dd,
    useMemo: Ud,
    useReducer: Qs,
    useRef: Md,
    useState: function() {
      return Qs(Uo);
    },
    useDebugValue: fl,
    useDeferredValue: function(ie) {
      var pe = La();
      return Fd(pe, si.memoizedState, ie);
    },
    useTransition: function() {
      var ie = Qs(Uo)[0], pe = La().memoizedState;
      return [ie, pe];
    },
    useMutableSource: il,
    useSyncExternalStore: ff,
    useId: Hd,
    unstable_isNewReconciler: !1
  }, jd = { readContext: es, useCallback: cf, useContext: es, useEffect: gc, useImperativeHandle: Ld, useInsertionEffect: Pd, useLayoutEffect: Dd, useMemo: Ud, useReducer: ts, useRef: Md, useState: function() {
    return ts(Uo);
  }, useDebugValue: fl, useDeferredValue: function(ie) {
    var pe = La();
    return si === null ? pe.memoizedState = ie : Fd(pe, si.memoizedState, ie);
  }, useTransition: function() {
    var ie = ts(Uo)[0], pe = La().memoizedState;
    return [ie, pe];
  }, useMutableSource: il, useSyncExternalStore: ff, useId: Hd, unstable_isNewReconciler: !1 };
  function $o(ie, pe) {
    if (ie && ie.defaultProps) {
      pe = vt({}, pe), ie = ie.defaultProps;
      for (var nt in ie) pe[nt] === void 0 && (pe[nt] = ie[nt]);
      return pe;
    }
    return pe;
  }
  function df(ie, pe, nt, pt) {
    pe = ie.memoizedState, nt = nt(pt, pe), nt = nt == null ? pe : vt({}, pe, nt), ie.memoizedState = nt, ie.lanes === 0 && (ie.updateQueue.baseState = nt);
  }
  var hf = { isMounted: function(ie) {
    return (ie = ie._reactInternals) ? sn(ie) === ie : !1;
  }, enqueueSetState: function(ie, pe, nt) {
    ie = ie._reactInternals;
    var pt = Ia(), Tt = tu(ie), Pt = Eo(pt, Tt);
    Pt.payload = pe, nt != null && (Pt.callback = nt), pe = Bu(ie, Pt, Tt), pe !== null && (aa(pe, ie, Tt, pt), Sd(pe, ie, Tt));
  }, enqueueReplaceState: function(ie, pe, nt) {
    ie = ie._reactInternals;
    var pt = Ia(), Tt = tu(ie), Pt = Eo(pt, Tt);
    Pt.tag = 1, Pt.payload = pe, nt != null && (Pt.callback = nt), pe = Bu(ie, Pt, Tt), pe !== null && (aa(pe, ie, Tt, pt), Sd(pe, ie, Tt));
  }, enqueueForceUpdate: function(ie, pe) {
    ie = ie._reactInternals;
    var nt = Ia(), pt = tu(ie), Tt = Eo(nt, pt);
    Tt.tag = 2, pe != null && (Tt.callback = pe), pe = Bu(ie, Tt, pt), pe !== null && (aa(pe, ie, pt, nt), Sd(pe, ie, pt));
  } };
  function U1(ie, pe, nt, pt, Tt, Pt, Yt) {
    return ie = ie.stateNode, typeof ie.shouldComponentUpdate == "function" ? ie.shouldComponentUpdate(pt, Pt, Yt) : pe.prototype && pe.prototype.isPureReactComponent ? !tc(nt, pt) || !tc(Tt, Pt) : !0;
  }
  function F1(ie, pe, nt) {
    var pt = !1, Tt = xs, Pt = pe.contextType;
    return typeof Pt == "object" && Pt !== null ? Pt = es(Pt) : (Tt = Zi(pe) ? go : oi.current, pt = pe.contextTypes, Pt = (pt = pt != null) ? Xo(ie, Tt) : xs), pe = new pe(nt, Pt), ie.memoizedState = pe.state !== null && pe.state !== void 0 ? pe.state : null, pe.updater = hf, ie.stateNode = pe, pe._reactInternals = ie, pt && (ie = ie.stateNode, ie.__reactInternalMemoizedUnmaskedChildContext = Tt, ie.__reactInternalMemoizedMaskedChildContext = Pt), pe;
  }
  function H1(ie, pe, nt, pt) {
    ie = pe.state, typeof pe.componentWillReceiveProps == "function" && pe.componentWillReceiveProps(nt, pt), typeof pe.UNSAFE_componentWillReceiveProps == "function" && pe.UNSAFE_componentWillReceiveProps(nt, pt), pe.state !== ie && hf.enqueueReplaceState(pe, pe.state, null);
  }
  function Op(ie, pe, nt, pt) {
    var Tt = ie.stateNode;
    Tt.props = nt, Tt.state = ie.memoizedState, Tt.refs = {}, _d(ie);
    var Pt = pe.contextType;
    typeof Pt == "object" && Pt !== null ? Tt.context = es(Pt) : (Pt = Zi(pe) ? go : oi.current, Tt.context = Xo(ie, Pt)), Tt.state = ie.memoizedState, Pt = pe.getDerivedStateFromProps, typeof Pt == "function" && (df(ie, pe, Pt, nt), Tt.state = ie.memoizedState), typeof pe.getDerivedStateFromProps == "function" || typeof Tt.getSnapshotBeforeUpdate == "function" || typeof Tt.UNSAFE_componentWillMount != "function" && typeof Tt.componentWillMount != "function" || (pe = Tt.state, typeof Tt.componentWillMount == "function" && Tt.componentWillMount(), typeof Tt.UNSAFE_componentWillMount == "function" && Tt.UNSAFE_componentWillMount(), pe !== Tt.state && hf.enqueueReplaceState(Tt, Tt.state, null), Ed(ie, nt, Tt, pt), Tt.state = ie.memoizedState), typeof Tt.componentDidMount == "function" && (ie.flags |= 4194308);
  }
  function Mu(ie, pe) {
    try {
      var nt = "", pt = pe;
      do
        nt += dr(pt), pt = pt.return;
      while (pt);
      var Tt = nt;
    } catch (Pt) {
      Tt = `
Error generating stack: ` + Pt.message + `
` + Pt.stack;
    }
    return { value: ie, source: pe, stack: Tt, digest: null };
  }
  function Pp(ie, pe, nt) {
    return { value: ie, source: null, stack: nt ?? null, digest: pe ?? null };
  }
  function wc(ie, pe) {
    try {
      console.error(pe.value);
    } catch (nt) {
      setTimeout(function() {
        throw nt;
      });
    }
  }
  var j1 = typeof WeakMap == "function" ? WeakMap : Map;
  function z1(ie, pe, nt) {
    nt = Eo(-1, nt), nt.tag = 3, nt.payload = { element: null };
    var pt = pe.value;
    return nt.callback = function() {
      eh || (eh = !0, zp = pt), wc(ie, pe);
    }, nt;
  }
  function q1(ie, pe, nt) {
    nt = Eo(-1, nt), nt.tag = 3;
    var pt = ie.type.getDerivedStateFromError;
    if (typeof pt == "function") {
      var Tt = pe.value;
      nt.payload = function() {
        return pt(Tt);
      }, nt.callback = function() {
        wc(ie, pe);
      };
    }
    var Pt = ie.stateNode;
    return Pt !== null && typeof Pt.componentDidCatch == "function" && (nt.callback = function() {
      wc(ie, pe), typeof pt != "function" && (is === null ? is = /* @__PURE__ */ new Set([this]) : is.add(this));
      var Yt = pe.stack;
      this.componentDidCatch(pe.value, { componentStack: Yt !== null ? Yt : "" });
    }), nt;
  }
  function _c(ie, pe, nt) {
    var pt = ie.pingCache;
    if (pt === null) {
      pt = ie.pingCache = new j1();
      var Tt = /* @__PURE__ */ new Set();
      pt.set(pe, Tt);
    } else Tt = pt.get(pe), Tt === void 0 && (Tt = /* @__PURE__ */ new Set(), pt.set(pe, Tt));
    Tt.has(nt) || (Tt.add(nt), ie = vm.bind(null, ie, pe, nt), pe.then(ie, ie));
  }
  function W1(ie) {
    do {
      var pe;
      if ((pe = ie.tag === 13) && (pe = ie.memoizedState, pe = pe !== null ? pe.dehydrated !== null : !0), pe) return ie;
      ie = ie.return;
    } while (ie !== null);
    return null;
  }
  function Ip(ie, pe, nt, pt, Tt) {
    return ie.mode & 1 ? (ie.flags |= 65536, ie.lanes = Tt, ie) : (ie === pe ? ie.flags |= 65536 : (ie.flags |= 128, nt.flags |= 131072, nt.flags &= -52805, nt.tag === 1 && (nt.alternate === null ? nt.tag = 17 : (pe = Eo(-1, 1), pe.tag = 2, Bu(nt, pe, 1))), nt.lanes |= 1), ie);
  }
  var K1 = Ft.ReactCurrentOwner, xo = !1;
  function ha(ie, pe, nt, pt) {
    pe.child = ie === null ? O1(pe, null, nt, pt) : Qf(pe, ie.child, nt, pt);
  }
  function cl(ie, pe, nt, pt, Tt) {
    nt = nt.render;
    var Pt = pe.ref;
    return Zf(pe, Tt), pt = Jr(ie, pe, nt, pt, Pt, Tt), nt = wa(), ie !== null && !xo ? (pe.updateQueue = ie.updateQueue, pe.flags &= -2053, ie.lanes &= ~Tt, pa(ie, pe, Tt)) : (Xi && nt && vd(pe), pe.flags |= 1, ha(ie, pe, pt, Tt), pe.child);
  }
  function Ou(ie, pe, nt, pt, Tt) {
    if (ie === null) {
      var Pt = nt.type;
      return typeof Pt == "function" && !Gp(Pt) && Pt.defaultProps === void 0 && nt.compare === null && nt.defaultProps === void 0 ? (pe.tag = 15, pe.type = Pt, zd(ie, pe, Pt, pt, Tt)) : (ie = uh(nt.type, null, pt, pe, pe.mode, Tt), ie.ref = pe.ref, ie.return = pe, pe.child = ie);
    }
    if (Pt = ie.child, !(ie.lanes & Tt)) {
      var Yt = Pt.memoizedProps;
      if (nt = nt.compare, nt = nt !== null ? nt : tc, nt(Yt, pt) && ie.ref === pe.ref) return pa(ie, pe, Tt);
    }
    return pe.flags |= 1, ie = Du(Pt, pt), ie.ref = pe.ref, ie.return = pe, pe.child = ie;
  }
  function zd(ie, pe, nt, pt, Tt) {
    if (ie !== null) {
      var Pt = ie.memoizedProps;
      if (tc(Pt, pt) && ie.ref === pe.ref) if (xo = !1, pe.pendingProps = pt = Pt, (ie.lanes & Tt) !== 0) ie.flags & 131072 && (xo = !0);
      else return pe.lanes = ie.lanes, pa(ie, pe, Tt);
    }
    return di(ie, pe, nt, pt, Tt);
  }
  function To(ie, pe, nt) {
    var pt = pe.pendingProps, Tt = pt.children, Pt = ie !== null ? ie.memoizedState : null;
    if (pt.mode === "hidden") if (!(pe.mode & 1)) pe.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Di(Sl, Ao), Ao |= nt;
    else {
      if (!(nt & 1073741824)) return ie = Pt !== null ? Pt.baseLanes | nt : nt, pe.lanes = pe.childLanes = 1073741824, pe.memoizedState = { baseLanes: ie, cachePool: null, transitions: null }, pe.updateQueue = null, Di(Sl, Ao), Ao |= ie, null;
      pe.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, pt = Pt !== null ? Pt.baseLanes : nt, Di(Sl, Ao), Ao |= pt;
    }
    else Pt !== null ? (pt = Pt.baseLanes | nt, pe.memoizedState = null) : pt = nt, Di(Sl, Ao), Ao |= pt;
    return ha(ie, pe, Tt, nt), pe.child;
  }
  function pf(ie, pe) {
    var nt = pe.ref;
    (ie === null && nt !== null || ie !== null && ie.ref !== nt) && (pe.flags |= 512, pe.flags |= 2097152);
  }
  function di(ie, pe, nt, pt, Tt) {
    var Pt = Zi(nt) ? go : oi.current;
    return Pt = Xo(pe, Pt), Zf(pe, Tt), nt = Jr(ie, pe, nt, pt, Pt, Tt), pt = wa(), ie !== null && !xo ? (pe.updateQueue = ie.updateQueue, pe.flags &= -2053, ie.lanes &= ~Tt, pa(ie, pe, Tt)) : (Xi && pt && vd(pe), pe.flags |= 1, ha(ie, pe, nt, Tt), pe.child);
  }
  function Sc(ie, pe, nt, pt, Tt) {
    if (Zi(nt)) {
      var Pt = !0;
      pd(pe);
    } else Pt = !1;
    if (Zf(pe, Tt), pe.stateNode === null) $c(ie, pe), F1(pe, nt, pt), Op(pe, nt, pt, Tt), pt = !0;
    else if (ie === null) {
      var Yt = pe.stateNode, cr = pe.memoizedProps;
      Yt.props = cr;
      var wr = Yt.context, Lr = nt.contextType;
      typeof Lr == "object" && Lr !== null ? Lr = es(Lr) : (Lr = Zi(nt) ? go : oi.current, Lr = Xo(pe, Lr));
      var en = nt.getDerivedStateFromProps, rn = typeof en == "function" || typeof Yt.getSnapshotBeforeUpdate == "function";
      rn || typeof Yt.UNSAFE_componentWillReceiveProps != "function" && typeof Yt.componentWillReceiveProps != "function" || (cr !== pt || wr !== Lr) && H1(pe, Yt, pt, Lr), Cu = !1;
      var Qr = pe.memoizedState;
      Yt.state = Qr, Ed(pe, pt, Yt, Tt), wr = pe.memoizedState, cr !== pt || Qr !== wr || fa.current || Cu ? (typeof en == "function" && (df(pe, nt, en, pt), wr = pe.memoizedState), (cr = Cu || U1(pe, nt, cr, pt, Qr, wr, Lr)) ? (rn || typeof Yt.UNSAFE_componentWillMount != "function" && typeof Yt.componentWillMount != "function" || (typeof Yt.componentWillMount == "function" && Yt.componentWillMount(), typeof Yt.UNSAFE_componentWillMount == "function" && Yt.UNSAFE_componentWillMount()), typeof Yt.componentDidMount == "function" && (pe.flags |= 4194308)) : (typeof Yt.componentDidMount == "function" && (pe.flags |= 4194308), pe.memoizedProps = pt, pe.memoizedState = wr), Yt.props = pt, Yt.state = wr, Yt.context = Lr, pt = cr) : (typeof Yt.componentDidMount == "function" && (pe.flags |= 4194308), pt = !1);
    } else {
      Yt = pe.stateNode, el(ie, pe), cr = pe.memoizedProps, Lr = pe.type === pe.elementType ? cr : $o(pe.type, cr), Yt.props = Lr, rn = pe.pendingProps, Qr = Yt.context, wr = nt.contextType, typeof wr == "object" && wr !== null ? wr = es(wr) : (wr = Zi(nt) ? go : oi.current, wr = Xo(pe, wr));
      var An = nt.getDerivedStateFromProps;
      (en = typeof An == "function" || typeof Yt.getSnapshotBeforeUpdate == "function") || typeof Yt.UNSAFE_componentWillReceiveProps != "function" && typeof Yt.componentWillReceiveProps != "function" || (cr !== rn || Qr !== wr) && H1(pe, Yt, pt, wr), Cu = !1, Qr = pe.memoizedState, Yt.state = Qr, Ed(pe, pt, Yt, Tt);
      var Nn = pe.memoizedState;
      cr !== rn || Qr !== Nn || fa.current || Cu ? (typeof An == "function" && (df(pe, nt, An, pt), Nn = pe.memoizedState), (Lr = Cu || U1(pe, nt, Lr, pt, Qr, Nn, wr) || !1) ? (en || typeof Yt.UNSAFE_componentWillUpdate != "function" && typeof Yt.componentWillUpdate != "function" || (typeof Yt.componentWillUpdate == "function" && Yt.componentWillUpdate(pt, Nn, wr), typeof Yt.UNSAFE_componentWillUpdate == "function" && Yt.UNSAFE_componentWillUpdate(pt, Nn, wr)), typeof Yt.componentDidUpdate == "function" && (pe.flags |= 4), typeof Yt.getSnapshotBeforeUpdate == "function" && (pe.flags |= 1024)) : (typeof Yt.componentDidUpdate != "function" || cr === ie.memoizedProps && Qr === ie.memoizedState || (pe.flags |= 4), typeof Yt.getSnapshotBeforeUpdate != "function" || cr === ie.memoizedProps && Qr === ie.memoizedState || (pe.flags |= 1024), pe.memoizedProps = pt, pe.memoizedState = Nn), Yt.props = pt, Yt.state = Nn, Yt.context = wr, pt = Lr) : (typeof Yt.componentDidUpdate != "function" || cr === ie.memoizedProps && Qr === ie.memoizedState || (pe.flags |= 4), typeof Yt.getSnapshotBeforeUpdate != "function" || cr === ie.memoizedProps && Qr === ie.memoizedState || (pe.flags |= 1024), pt = !1);
    }
    return qd(ie, pe, nt, pt, Pt, Tt);
  }
  function qd(ie, pe, nt, pt, Tt, Pt) {
    pf(ie, pe);
    var Yt = (pe.flags & 128) !== 0;
    if (!pt && !Yt) return Tt && R1(pe, nt, !1), pa(ie, pe, Pt);
    pt = pe.stateNode, K1.current = pe;
    var cr = Yt && typeof nt.getDerivedStateFromError != "function" ? null : pt.render();
    return pe.flags |= 1, ie !== null && Yt ? (pe.child = Qf(pe, ie.child, null, Pt), pe.child = Qf(pe, null, cr, Pt)) : ha(ie, pe, cr, Pt), pe.memoizedState = pt.state, Tt && R1(pe, nt, !0), pe.child;
  }
  function om(ie) {
    var pe = ie.stateNode;
    pe.pendingContext ? Au(ie, pe.pendingContext, pe.pendingContext !== pe.context) : pe.context && Au(ie, pe.context, !1), Rp(ie, pe.containerInfo);
  }
  function V1(ie, pe, nt, pt, Tt) {
    return ia(), xp(Tt), pe.flags |= 256, ha(ie, pe, nt, pt), pe.child;
  }
  var Ec = { dehydrated: null, treeContext: null, retryLane: 0 };
  function vf(ie) {
    return { baseLanes: ie, cachePool: null, transitions: null };
  }
  function G1(ie, pe, nt) {
    var pt = pe.pendingProps, Tt = ea.current, Pt = !1, Yt = (pe.flags & 128) !== 0, cr;
    if ((cr = Yt) || (cr = ie !== null && ie.memoizedState === null ? !1 : (Tt & 2) !== 0), cr ? (Pt = !0, pe.flags &= -129) : (ie === null || ie.memoizedState !== null) && (Tt |= 1), Di(ea, Tt & 1), ie === null)
      return md(pe), ie = pe.memoizedState, ie !== null && (ie = ie.dehydrated, ie !== null) ? (pe.mode & 1 ? ie.data === "$!" ? pe.lanes = 8 : pe.lanes = 1073741824 : pe.lanes = 1, null) : (Yt = pt.children, ie = pt.fallback, Pt ? (pt = pe.mode, Pt = pe.child, Yt = { mode: "hidden", children: Yt }, !(pt & 1) && Pt !== null ? (Pt.childLanes = 0, Pt.pendingProps = Yt) : Pt = fh(Yt, pt, 0, null), ie = _f(ie, pt, nt, null), Pt.return = pe, ie.return = pe, Pt.sibling = ie, pe.child = Pt, pe.child.memoizedState = vf(nt), pe.memoizedState = Ec, ie) : Wd(pe, Yt));
    if (Tt = ie.memoizedState, Tt !== null && (cr = Tt.dehydrated, cr !== null)) return Dp(ie, pe, Yt, pt, cr, Tt, nt);
    if (Pt) {
      Pt = pt.fallback, Yt = pe.mode, Tt = ie.child, cr = Tt.sibling;
      var wr = { mode: "hidden", children: pt.children };
      return !(Yt & 1) && pe.child !== Tt ? (pt = pe.child, pt.childLanes = 0, pt.pendingProps = wr, pe.deletions = null) : (pt = Du(Tt, wr), pt.subtreeFlags = Tt.subtreeFlags & 14680064), cr !== null ? Pt = Du(cr, Pt) : (Pt = _f(Pt, Yt, nt, null), Pt.flags |= 2), Pt.return = pe, pt.return = pe, pt.sibling = Pt, pe.child = pt, pt = Pt, Pt = pe.child, Yt = ie.child.memoizedState, Yt = Yt === null ? vf(nt) : { baseLanes: Yt.baseLanes | nt, cachePool: null, transitions: Yt.transitions }, Pt.memoizedState = Yt, Pt.childLanes = ie.childLanes & ~nt, pe.memoizedState = Ec, pt;
    }
    return Pt = ie.child, ie = Pt.sibling, pt = Du(Pt, { mode: "visible", children: pt.children }), !(pe.mode & 1) && (pt.lanes = nt), pt.return = pe, pt.sibling = null, ie !== null && (nt = pe.deletions, nt === null ? (pe.deletions = [ie], pe.flags |= 16) : nt.push(ie)), pe.child = pt, pe.memoizedState = null, pt;
  }
  function Wd(ie, pe) {
    return pe = fh({ mode: "visible", children: pe }, ie.mode, 0, null), pe.return = ie, ie.child = pe;
  }
  function Kd(ie, pe, nt, pt) {
    return pt !== null && xp(pt), Qf(pe, ie.child, null, nt), ie = Wd(pe, pe.pendingProps.children), ie.flags |= 2, pe.memoizedState = null, ie;
  }
  function Dp(ie, pe, nt, pt, Tt, Pt, Yt) {
    if (nt)
      return pe.flags & 256 ? (pe.flags &= -257, pt = Pp(Error(J(422))), Kd(ie, pe, Yt, pt)) : pe.memoizedState !== null ? (pe.child = ie.child, pe.flags |= 128, null) : (Pt = pt.fallback, Tt = pe.mode, pt = fh({ mode: "visible", children: pt.children }, Tt, 0, null), Pt = _f(Pt, Tt, Yt, null), Pt.flags |= 2, pt.return = pe, Pt.return = pe, pt.sibling = Pt, pe.child = pt, pe.mode & 1 && Qf(pe, ie.child, null, Yt), pe.child.memoizedState = vf(Yt), pe.memoizedState = Ec, Pt);
    if (!(pe.mode & 1)) return Kd(ie, pe, Yt, null);
    if (Tt.data === "$!") {
      if (pt = Tt.nextSibling && Tt.nextSibling.dataset, pt) var cr = pt.dgst;
      return pt = cr, Pt = Error(J(419)), pt = Pp(Pt, pt, void 0), Kd(ie, pe, Yt, pt);
    }
    if (cr = (Yt & ie.childLanes) !== 0, xo || cr) {
      if (pt = ca, pt !== null) {
        switch (Yt & -Yt) {
          case 4:
            Tt = 2;
            break;
          case 16:
            Tt = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            Tt = 32;
            break;
          case 536870912:
            Tt = 268435456;
            break;
          default:
            Tt = 0;
        }
        Tt = Tt & (pt.suspendedLanes | Yt) ? 0 : Tt, Tt !== 0 && Tt !== Pt.retryLane && (Pt.retryLane = Tt, Js(ie, Tt), aa(pt, ie, Tt, -1));
      }
      return Cc(), pt = Pp(Error(J(421))), Kd(ie, pe, Yt, pt);
    }
    return Tt.data === "$?" ? (pe.flags |= 128, pe.child = ie.child, pe = Vp.bind(null, ie), Tt._reactRetry = pe, null) : (ie = Pt.treeContext, So = ms(Tt.nextSibling), Do = pe, Xi = !0, Qo = null, ie !== null && (_o[Ya++] = Na, _o[Ya++] = Xs, _o[Ya++] = Jo, Na = ie.id, Xs = ie.overflow, Jo = pe), pe = Wd(pe, pt.children), pe.flags |= 4096, pe);
  }
  function X1(ie, pe, nt) {
    ie.lanes |= pe;
    var pt = ie.alternate;
    pt !== null && (pt.lanes |= pe), Ap(ie.return, pe, nt);
  }
  function Vd(ie, pe, nt, pt, Tt) {
    var Pt = ie.memoizedState;
    Pt === null ? ie.memoizedState = { isBackwards: pe, rendering: null, renderingStartTime: 0, last: pt, tail: nt, tailMode: Tt } : (Pt.isBackwards = pe, Pt.rendering = null, Pt.renderingStartTime = 0, Pt.last = pt, Pt.tail = nt, Pt.tailMode = Tt);
  }
  function Np(ie, pe, nt) {
    var pt = pe.pendingProps, Tt = pt.revealOrder, Pt = pt.tail;
    if (ha(ie, pe, pt.children, nt), pt = ea.current, pt & 2) pt = pt & 1 | 2, pe.flags |= 128;
    else {
      if (ie !== null && ie.flags & 128) e: for (ie = pe.child; ie !== null; ) {
        if (ie.tag === 13) ie.memoizedState !== null && X1(ie, nt, pe);
        else if (ie.tag === 19) X1(ie, nt, pe);
        else if (ie.child !== null) {
          ie.child.return = ie, ie = ie.child;
          continue;
        }
        if (ie === pe) break e;
        for (; ie.sibling === null; ) {
          if (ie.return === null || ie.return === pe) break e;
          ie = ie.return;
        }
        ie.sibling.return = ie.return, ie = ie.sibling;
      }
      pt &= 1;
    }
    if (Di(ea, pt), !(pe.mode & 1)) pe.memoizedState = null;
    else switch (Tt) {
      case "forwards":
        for (nt = pe.child, Tt = null; nt !== null; ) ie = nt.alternate, ie !== null && $d(ie) === null && (Tt = nt), nt = nt.sibling;
        nt = Tt, nt === null ? (Tt = pe.child, pe.child = null) : (Tt = nt.sibling, nt.sibling = null), Vd(pe, !1, Tt, nt, Pt);
        break;
      case "backwards":
        for (nt = null, Tt = pe.child, pe.child = null; Tt !== null; ) {
          if (ie = Tt.alternate, ie !== null && $d(ie) === null) {
            pe.child = Tt;
            break;
          }
          ie = Tt.sibling, Tt.sibling = nt, nt = Tt, Tt = ie;
        }
        Vd(pe, !0, nt, null, Pt);
        break;
      case "together":
        Vd(pe, !1, null, null, void 0);
        break;
      default:
        pe.memoizedState = null;
    }
    return pe.child;
  }
  function $c(ie, pe) {
    !(pe.mode & 1) && ie !== null && (ie.alternate = null, pe.alternate = null, pe.flags |= 2);
  }
  function pa(ie, pe, nt) {
    if (ie !== null && (pe.dependencies = ie.dependencies), mf |= pe.lanes, !(nt & pe.childLanes)) return null;
    if (ie !== null && pe.child !== ie.child) throw Error(J(153));
    if (pe.child !== null) {
      for (ie = pe.child, nt = Du(ie, ie.pendingProps), pe.child = nt, nt.return = pe; ie.sibling !== null; ) ie = ie.sibling, nt = nt.sibling = Du(ie, ie.pendingProps), nt.return = pe;
      nt.sibling = null;
    }
    return pe.child;
  }
  function Zs(ie, pe, nt) {
    switch (pe.tag) {
      case 3:
        om(pe), ia();
        break;
      case 5:
        N1(pe);
        break;
      case 1:
        Zi(pe.type) && pd(pe);
        break;
      case 4:
        Rp(pe, pe.stateNode.containerInfo);
        break;
      case 10:
        var pt = pe.type._context, Tt = pe.memoizedProps.value;
        Di(Ys, pt._currentValue), pt._currentValue = Tt;
        break;
      case 13:
        if (pt = pe.memoizedState, pt !== null)
          return pt.dehydrated !== null ? (Di(ea, ea.current & 1), pe.flags |= 128, null) : nt & pe.child.childLanes ? G1(ie, pe, nt) : (Di(ea, ea.current & 1), ie = pa(ie, pe, nt), ie !== null ? ie.sibling : null);
        Di(ea, ea.current & 1);
        break;
      case 19:
        if (pt = (nt & pe.childLanes) !== 0, ie.flags & 128) {
          if (pt) return Np(ie, pe, nt);
          pe.flags |= 128;
        }
        if (Tt = pe.memoizedState, Tt !== null && (Tt.rendering = null, Tt.tail = null, Tt.lastEffect = null), Di(ea, ea.current), pt) break;
        return null;
      case 22:
      case 23:
        return pe.lanes = 0, To(ie, pe, nt);
    }
    return pa(ie, pe, nt);
  }
  var As, dl, pl, rs;
  As = function(ie, pe) {
    for (var nt = pe.child; nt !== null; ) {
      if (nt.tag === 5 || nt.tag === 6) ie.appendChild(nt.stateNode);
      else if (nt.tag !== 4 && nt.child !== null) {
        nt.child.return = nt, nt = nt.child;
        continue;
      }
      if (nt === pe) break;
      for (; nt.sibling === null; ) {
        if (nt.return === null || nt.return === pe) return;
        nt = nt.return;
      }
      nt.sibling.return = nt.return, nt = nt.sibling;
    }
  }, dl = function() {
  }, pl = function(ie, pe, nt, pt) {
    var Tt = ie.memoizedProps;
    if (Tt !== pt) {
      ie = pe.stateNode, uf(gs.current);
      var Pt = null;
      switch (nt) {
        case "input":
          Tt = Dr(ie, Tt), pt = Dr(ie, pt), Pt = [];
          break;
        case "select":
          Tt = vt({}, Tt, { value: void 0 }), pt = vt({}, pt, { value: void 0 }), Pt = [];
          break;
        case "textarea":
          Tt = ni(ie, Tt), pt = ni(ie, pt), Pt = [];
          break;
        default:
          typeof Tt.onClick != "function" && typeof pt.onClick == "function" && (ie.onclick = hd);
      }
      Tr(nt, pt);
      var Yt;
      nt = null;
      for (Lr in Tt) if (!pt.hasOwnProperty(Lr) && Tt.hasOwnProperty(Lr) && Tt[Lr] != null) if (Lr === "style") {
        var cr = Tt[Lr];
        for (Yt in cr) cr.hasOwnProperty(Yt) && (nt || (nt = {}), nt[Yt] = "");
      } else Lr !== "dangerouslySetInnerHTML" && Lr !== "children" && Lr !== "suppressContentEditableWarning" && Lr !== "suppressHydrationWarning" && Lr !== "autoFocus" && (oe.hasOwnProperty(Lr) ? Pt || (Pt = []) : (Pt = Pt || []).push(Lr, null));
      for (Lr in pt) {
        var wr = pt[Lr];
        if (cr = Tt != null ? Tt[Lr] : void 0, pt.hasOwnProperty(Lr) && wr !== cr && (wr != null || cr != null)) if (Lr === "style") if (cr) {
          for (Yt in cr) !cr.hasOwnProperty(Yt) || wr && wr.hasOwnProperty(Yt) || (nt || (nt = {}), nt[Yt] = "");
          for (Yt in wr) wr.hasOwnProperty(Yt) && cr[Yt] !== wr[Yt] && (nt || (nt = {}), nt[Yt] = wr[Yt]);
        } else nt || (Pt || (Pt = []), Pt.push(
          Lr,
          nt
        )), nt = wr;
        else Lr === "dangerouslySetInnerHTML" ? (wr = wr ? wr.__html : void 0, cr = cr ? cr.__html : void 0, wr != null && cr !== wr && (Pt = Pt || []).push(Lr, wr)) : Lr === "children" ? typeof wr != "string" && typeof wr != "number" || (Pt = Pt || []).push(Lr, "" + wr) : Lr !== "suppressContentEditableWarning" && Lr !== "suppressHydrationWarning" && (oe.hasOwnProperty(Lr) ? (wr != null && Lr === "onScroll" && qi("scroll", ie), Pt || cr === wr || (Pt = [])) : (Pt = Pt || []).push(Lr, wr));
      }
      nt && (Pt = Pt || []).push("style", nt);
      var Lr = Pt;
      (pe.updateQueue = Lr) && (pe.flags |= 4);
    }
  }, rs = function(ie, pe, nt, pt) {
    nt !== pt && (pe.flags |= 4);
  };
  function la(ie, pe) {
    if (!Xi) switch (ie.tailMode) {
      case "hidden":
        pe = ie.tail;
        for (var nt = null; pe !== null; ) pe.alternate !== null && (nt = pe), pe = pe.sibling;
        nt === null ? ie.tail = null : nt.sibling = null;
        break;
      case "collapsed":
        nt = ie.tail;
        for (var pt = null; nt !== null; ) nt.alternate !== null && (pt = nt), nt = nt.sibling;
        pt === null ? pe || ie.tail === null ? ie.tail = null : ie.tail.sibling = null : pt.sibling = null;
    }
  }
  function Za(ie) {
    var pe = ie.alternate !== null && ie.alternate.child === ie.child, nt = 0, pt = 0;
    if (pe) for (var Tt = ie.child; Tt !== null; ) nt |= Tt.lanes | Tt.childLanes, pt |= Tt.subtreeFlags & 14680064, pt |= Tt.flags & 14680064, Tt.return = ie, Tt = Tt.sibling;
    else for (Tt = ie.child; Tt !== null; ) nt |= Tt.lanes | Tt.childLanes, pt |= Tt.subtreeFlags, pt |= Tt.flags, Tt.return = ie, Tt = Tt.sibling;
    return ie.subtreeFlags |= pt, ie.childLanes = nt, pe;
  }
  function sm(ie, pe, nt) {
    var pt = pe.pendingProps;
    switch (Ep(pe), pe.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Za(pe), null;
      case 1:
        return Zi(pe.type) && Yo(), Za(pe), null;
      case 3:
        return pt = pe.stateNode, rl(), Oi(fa), Oi(oi), Bp(), pt.pendingContext && (pt.context = pt.pendingContext, pt.pendingContext = null), (ie === null || ie.child === null) && (gd(pe) ? pe.flags |= 4 : ie === null || ie.memoizedState.isDehydrated && !(pe.flags & 256) || (pe.flags |= 1024, Qo !== null && (qp(Qo), Qo = null))), dl(ie, pe), Za(pe), null;
      case 5:
        Cp(pe);
        var Tt = uf(pc.current);
        if (nt = pe.type, ie !== null && pe.stateNode != null) pl(ie, pe, nt, pt, Tt), ie.ref !== pe.ref && (pe.flags |= 512, pe.flags |= 2097152);
        else {
          if (!pt) {
            if (pe.stateNode === null) throw Error(J(166));
            return Za(pe), null;
          }
          if (ie = uf(gs.current), gd(pe)) {
            pt = pe.stateNode, nt = pe.type;
            var Pt = pe.memoizedProps;
            switch (pt[$s] = pe, pt[nf] = Pt, ie = (pe.mode & 1) !== 0, nt) {
              case "dialog":
                qi("cancel", pt), qi("close", pt);
                break;
              case "iframe":
              case "object":
              case "embed":
                qi("load", pt);
                break;
              case "video":
              case "audio":
                for (Tt = 0; Tt < ac.length; Tt++) qi(ac[Tt], pt);
                break;
              case "source":
                qi("error", pt);
                break;
              case "img":
              case "image":
              case "link":
                qi(
                  "error",
                  pt
                ), qi("load", pt);
                break;
              case "details":
                qi("toggle", pt);
                break;
              case "input":
                Vr(pt, Pt), qi("invalid", pt);
                break;
              case "select":
                pt._wrapperState = { wasMultiple: !!Pt.multiple }, qi("invalid", pt);
                break;
              case "textarea":
                Gn(pt, Pt), qi("invalid", pt);
            }
            Tr(nt, Pt), Tt = null;
            for (var Yt in Pt) if (Pt.hasOwnProperty(Yt)) {
              var cr = Pt[Yt];
              Yt === "children" ? typeof cr == "string" ? pt.textContent !== cr && (Pt.suppressHydrationWarning !== !0 && dd(pt.textContent, cr, ie), Tt = ["children", cr]) : typeof cr == "number" && pt.textContent !== "" + cr && (Pt.suppressHydrationWarning !== !0 && dd(
                pt.textContent,
                cr,
                ie
              ), Tt = ["children", "" + cr]) : oe.hasOwnProperty(Yt) && cr != null && Yt === "onScroll" && qi("scroll", pt);
            }
            switch (nt) {
              case "input":
                Xt(pt), _n(pt, Pt, !0);
                break;
              case "textarea":
                Xt(pt), Pn(pt);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof Pt.onClick == "function" && (pt.onclick = hd);
            }
            pt = Tt, pe.updateQueue = pt, pt !== null && (pe.flags |= 4);
          } else {
            Yt = Tt.nodeType === 9 ? Tt : Tt.ownerDocument, ie === "http://www.w3.org/1999/xhtml" && (ie = ti(nt)), ie === "http://www.w3.org/1999/xhtml" ? nt === "script" ? (ie = Yt.createElement("div"), ie.innerHTML = "<script><\/script>", ie = ie.removeChild(ie.firstChild)) : typeof pt.is == "string" ? ie = Yt.createElement(nt, { is: pt.is }) : (ie = Yt.createElement(nt), nt === "select" && (Yt = ie, pt.multiple ? Yt.multiple = !0 : pt.size && (Yt.size = pt.size))) : ie = Yt.createElementNS(ie, nt), ie[$s] = pe, ie[nf] = pt, As(ie, pe, !1, !1), pe.stateNode = ie;
            e: {
              switch (Yt = fn(nt, pt), nt) {
                case "dialog":
                  qi("cancel", ie), qi("close", ie), Tt = pt;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  qi("load", ie), Tt = pt;
                  break;
                case "video":
                case "audio":
                  for (Tt = 0; Tt < ac.length; Tt++) qi(ac[Tt], ie);
                  Tt = pt;
                  break;
                case "source":
                  qi("error", ie), Tt = pt;
                  break;
                case "img":
                case "image":
                case "link":
                  qi(
                    "error",
                    ie
                  ), qi("load", ie), Tt = pt;
                  break;
                case "details":
                  qi("toggle", ie), Tt = pt;
                  break;
                case "input":
                  Vr(ie, pt), Tt = Dr(ie, pt), qi("invalid", ie);
                  break;
                case "option":
                  Tt = pt;
                  break;
                case "select":
                  ie._wrapperState = { wasMultiple: !!pt.multiple }, Tt = vt({}, pt, { value: void 0 }), qi("invalid", ie);
                  break;
                case "textarea":
                  Gn(ie, pt), Tt = ni(ie, pt), qi("invalid", ie);
                  break;
                default:
                  Tt = pt;
              }
              Tr(nt, Tt), cr = Tt;
              for (Pt in cr) if (cr.hasOwnProperty(Pt)) {
                var wr = cr[Pt];
                Pt === "style" ? pr(ie, wr) : Pt === "dangerouslySetInnerHTML" ? (wr = wr ? wr.__html : void 0, wr != null && gi(ie, wr)) : Pt === "children" ? typeof wr == "string" ? (nt !== "textarea" || wr !== "") && Gt(ie, wr) : typeof wr == "number" && Gt(ie, "" + wr) : Pt !== "suppressContentEditableWarning" && Pt !== "suppressHydrationWarning" && Pt !== "autoFocus" && (oe.hasOwnProperty(Pt) ? wr != null && Pt === "onScroll" && qi("scroll", ie) : wr != null && It(ie, Pt, wr, Yt));
              }
              switch (nt) {
                case "input":
                  Xt(ie), _n(ie, pt, !1);
                  break;
                case "textarea":
                  Xt(ie), Pn(ie);
                  break;
                case "option":
                  pt.value != null && ie.setAttribute("value", "" + Wt(pt.value));
                  break;
                case "select":
                  ie.multiple = !!pt.multiple, Pt = pt.value, Pt != null ? xn(ie, !!pt.multiple, Pt, !1) : pt.defaultValue != null && xn(
                    ie,
                    !!pt.multiple,
                    pt.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof Tt.onClick == "function" && (ie.onclick = hd);
              }
              switch (nt) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  pt = !!pt.autoFocus;
                  break e;
                case "img":
                  pt = !0;
                  break e;
                default:
                  pt = !1;
              }
            }
            pt && (pe.flags |= 4);
          }
          pe.ref !== null && (pe.flags |= 512, pe.flags |= 2097152);
        }
        return Za(pe), null;
      case 6:
        if (ie && pe.stateNode != null) rs(ie, pe, ie.memoizedProps, pt);
        else {
          if (typeof pt != "string" && pe.stateNode === null) throw Error(J(166));
          if (nt = uf(pc.current), uf(gs.current), gd(pe)) {
            if (pt = pe.stateNode, nt = pe.memoizedProps, pt[$s] = pe, (Pt = pt.nodeValue !== nt) && (ie = Do, ie !== null)) switch (ie.tag) {
              case 3:
                dd(pt.nodeValue, nt, (ie.mode & 1) !== 0);
                break;
              case 5:
                ie.memoizedProps.suppressHydrationWarning !== !0 && dd(pt.nodeValue, nt, (ie.mode & 1) !== 0);
            }
            Pt && (pe.flags |= 4);
          } else pt = (nt.nodeType === 9 ? nt : nt.ownerDocument).createTextNode(pt), pt[$s] = pe, pe.stateNode = pt;
        }
        return Za(pe), null;
      case 13:
        if (Oi(ea), pt = pe.memoizedState, ie === null || ie.memoizedState !== null && ie.memoizedState.dehydrated !== null) {
          if (Xi && So !== null && pe.mode & 1 && !(pe.flags & 128)) k1(), ia(), pe.flags |= 98560, Pt = !1;
          else if (Pt = gd(pe), pt !== null && pt.dehydrated !== null) {
            if (ie === null) {
              if (!Pt) throw Error(J(318));
              if (Pt = pe.memoizedState, Pt = Pt !== null ? Pt.dehydrated : null, !Pt) throw Error(J(317));
              Pt[$s] = pe;
            } else ia(), !(pe.flags & 128) && (pe.memoizedState = null), pe.flags |= 4;
            Za(pe), Pt = !1;
          } else Qo !== null && (qp(Qo), Qo = null), Pt = !0;
          if (!Pt) return pe.flags & 65536 ? pe : null;
        }
        return pe.flags & 128 ? (pe.lanes = nt, pe) : (pt = pt !== null, pt !== (ie !== null && ie.memoizedState !== null) && pt && (pe.child.flags |= 8192, pe.mode & 1 && (ie === null || ea.current & 1 ? xa === 0 && (xa = 3) : Cc())), pe.updateQueue !== null && (pe.flags |= 4), Za(pe), null);
      case 4:
        return rl(), dl(ie, pe), ie === null && Xf(pe.stateNode.containerInfo), Za(pe), null;
      case 10:
        return Tp(pe.type._context), Za(pe), null;
      case 17:
        return Zi(pe.type) && Yo(), Za(pe), null;
      case 19:
        if (Oi(ea), Pt = pe.memoizedState, Pt === null) return Za(pe), null;
        if (pt = (pe.flags & 128) !== 0, Yt = Pt.rendering, Yt === null) if (pt) la(Pt, !1);
        else {
          if (xa !== 0 || ie !== null && ie.flags & 128) for (ie = pe.child; ie !== null; ) {
            if (Yt = $d(ie), Yt !== null) {
              for (pe.flags |= 128, la(Pt, !1), pt = Yt.updateQueue, pt !== null && (pe.updateQueue = pt, pe.flags |= 4), pe.subtreeFlags = 0, pt = nt, nt = pe.child; nt !== null; ) Pt = nt, ie = pt, Pt.flags &= 14680066, Yt = Pt.alternate, Yt === null ? (Pt.childLanes = 0, Pt.lanes = ie, Pt.child = null, Pt.subtreeFlags = 0, Pt.memoizedProps = null, Pt.memoizedState = null, Pt.updateQueue = null, Pt.dependencies = null, Pt.stateNode = null) : (Pt.childLanes = Yt.childLanes, Pt.lanes = Yt.lanes, Pt.child = Yt.child, Pt.subtreeFlags = 0, Pt.deletions = null, Pt.memoizedProps = Yt.memoizedProps, Pt.memoizedState = Yt.memoizedState, Pt.updateQueue = Yt.updateQueue, Pt.type = Yt.type, ie = Yt.dependencies, Pt.dependencies = ie === null ? null : { lanes: ie.lanes, firstContext: ie.firstContext }), nt = nt.sibling;
              return Di(ea, ea.current & 1 | 2), pe.child;
            }
            ie = ie.sibling;
          }
          Pt.tail !== null && vi() > $l && (pe.flags |= 128, pt = !0, la(Pt, !1), pe.lanes = 4194304);
        }
        else {
          if (!pt) if (ie = $d(Yt), ie !== null) {
            if (pe.flags |= 128, pt = !0, nt = ie.updateQueue, nt !== null && (pe.updateQueue = nt, pe.flags |= 4), la(Pt, !0), Pt.tail === null && Pt.tailMode === "hidden" && !Yt.alternate && !Xi) return Za(pe), null;
          } else 2 * vi() - Pt.renderingStartTime > $l && nt !== 1073741824 && (pe.flags |= 128, pt = !0, la(Pt, !1), pe.lanes = 4194304);
          Pt.isBackwards ? (Yt.sibling = pe.child, pe.child = Yt) : (nt = Pt.last, nt !== null ? nt.sibling = Yt : pe.child = Yt, Pt.last = Yt);
        }
        return Pt.tail !== null ? (pe = Pt.tail, Pt.rendering = pe, Pt.tail = pe.sibling, Pt.renderingStartTime = vi(), pe.sibling = null, nt = ea.current, Di(ea, pt ? nt & 1 | 2 : nt & 1), pe) : (Za(pe), null);
      case 22:
      case 23:
        return ah(), pt = pe.memoizedState !== null, ie !== null && ie.memoizedState !== null !== pt && (pe.flags |= 8192), pt && pe.mode & 1 ? Ao & 1073741824 && (Za(pe), pe.subtreeFlags & 6 && (pe.flags |= 8192)) : Za(pe), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(J(156, pe.tag));
  }
  function um(ie, pe) {
    switch (Ep(pe), pe.tag) {
      case 1:
        return Zi(pe.type) && Yo(), ie = pe.flags, ie & 65536 ? (pe.flags = ie & -65537 | 128, pe) : null;
      case 3:
        return rl(), Oi(fa), Oi(oi), Bp(), ie = pe.flags, ie & 65536 && !(ie & 128) ? (pe.flags = ie & -65537 | 128, pe) : null;
      case 5:
        return Cp(pe), null;
      case 13:
        if (Oi(ea), ie = pe.memoizedState, ie !== null && ie.dehydrated !== null) {
          if (pe.alternate === null) throw Error(J(340));
          ia();
        }
        return ie = pe.flags, ie & 65536 ? (pe.flags = ie & -65537 | 128, pe) : null;
      case 19:
        return Oi(ea), null;
      case 4:
        return rl(), null;
      case 10:
        return Tp(pe.type._context), null;
      case 22:
      case 23:
        return ah(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var vl = !1, Ua = !1, Gd = typeof WeakSet == "function" ? WeakSet : Set, Mn = null;
  function yl(ie, pe) {
    var nt = ie.ref;
    if (nt !== null) if (typeof nt == "function") try {
      nt(null);
    } catch (pt) {
      da(ie, pe, pt);
    }
    else nt.current = null;
  }
  function Lp(ie, pe, nt) {
    try {
      nt();
    } catch (pt) {
      da(ie, pe, pt);
    }
  }
  var Xd = !1;
  function fm(ie, pe) {
    if (vp = Ko, ie = sd(), Ws(ie)) {
      if ("selectionStart" in ie) var nt = { start: ie.selectionStart, end: ie.selectionEnd };
      else e: {
        nt = (nt = ie.ownerDocument) && nt.defaultView || window;
        var pt = nt.getSelection && nt.getSelection();
        if (pt && pt.rangeCount !== 0) {
          nt = pt.anchorNode;
          var Tt = pt.anchorOffset, Pt = pt.focusNode;
          pt = pt.focusOffset;
          try {
            nt.nodeType, Pt.nodeType;
          } catch {
            nt = null;
            break e;
          }
          var Yt = 0, cr = -1, wr = -1, Lr = 0, en = 0, rn = ie, Qr = null;
          t: for (; ; ) {
            for (var An; rn !== nt || Tt !== 0 && rn.nodeType !== 3 || (cr = Yt + Tt), rn !== Pt || pt !== 0 && rn.nodeType !== 3 || (wr = Yt + pt), rn.nodeType === 3 && (Yt += rn.nodeValue.length), (An = rn.firstChild) !== null; )
              Qr = rn, rn = An;
            for (; ; ) {
              if (rn === ie) break t;
              if (Qr === nt && ++Lr === Tt && (cr = Yt), Qr === Pt && ++en === pt && (wr = Yt), (An = rn.nextSibling) !== null) break;
              rn = Qr, Qr = rn.parentNode;
            }
            rn = An;
          }
          nt = cr === -1 || wr === -1 ? null : { start: cr, end: wr };
        } else nt = null;
      }
      nt = nt || { start: 0, end: 0 };
    } else nt = null;
    for (tf = { focusedElem: ie, selectionRange: nt }, Ko = !1, Mn = pe; Mn !== null; ) if (pe = Mn, ie = pe.child, (pe.subtreeFlags & 1028) !== 0 && ie !== null) ie.return = pe, Mn = ie;
    else for (; Mn !== null; ) {
      pe = Mn;
      try {
        var Nn = pe.alternate;
        if (pe.flags & 1024) switch (pe.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (Nn !== null) {
              var Fn = Nn.memoizedProps, va = Nn.memoizedState, Rr = pe.stateNode, $r = Rr.getSnapshotBeforeUpdate(pe.elementType === pe.type ? Fn : $o(pe.type, Fn), va);
              Rr.__reactInternalSnapshotBeforeUpdate = $r;
            }
            break;
          case 3:
            var kr = pe.stateNode.containerInfo;
            kr.nodeType === 1 ? kr.textContent = "" : kr.nodeType === 9 && kr.documentElement && kr.removeChild(kr.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(J(163));
        }
      } catch (un) {
        da(pe, pe.return, un);
      }
      if (ie = pe.sibling, ie !== null) {
        ie.return = pe.return, Mn = ie;
        break;
      }
      Mn = pe.return;
    }
    return Nn = Xd, Xd = !1, Nn;
  }
  function ml(ie, pe, nt) {
    var pt = pe.updateQueue;
    if (pt = pt !== null ? pt.lastEffect : null, pt !== null) {
      var Tt = pt = pt.next;
      do {
        if ((Tt.tag & ie) === ie) {
          var Pt = Tt.destroy;
          Tt.destroy = void 0, Pt !== void 0 && Lp(pe, nt, Pt);
        }
        Tt = Tt.next;
      } while (Tt !== pt);
    }
  }
  function Yd(ie, pe) {
    if (pe = pe.updateQueue, pe = pe !== null ? pe.lastEffect : null, pe !== null) {
      var nt = pe = pe.next;
      do {
        if ((nt.tag & ie) === ie) {
          var pt = nt.create;
          nt.destroy = pt();
        }
        nt = nt.next;
      } while (nt !== pe);
    }
  }
  function Jd(ie) {
    var pe = ie.ref;
    if (pe !== null) {
      var nt = ie.stateNode;
      switch (ie.tag) {
        case 5:
          ie = nt;
          break;
        default:
          ie = nt;
      }
      typeof pe == "function" ? pe(ie) : pe.current = ie;
    }
  }
  function Y1(ie) {
    var pe = ie.alternate;
    pe !== null && (ie.alternate = null, Y1(pe)), ie.child = null, ie.deletions = null, ie.sibling = null, ie.tag === 5 && (pe = ie.stateNode, pe !== null && (delete pe[$s], delete pe[nf], delete pe[gp], delete pe[nm], delete pe[bp])), ie.stateNode = null, ie.return = null, ie.dependencies = null, ie.memoizedProps = null, ie.memoizedState = null, ie.pendingProps = null, ie.stateNode = null, ie.updateQueue = null;
  }
  function Up(ie) {
    return ie.tag === 5 || ie.tag === 3 || ie.tag === 4;
  }
  function J1(ie) {
    e: for (; ; ) {
      for (; ie.sibling === null; ) {
        if (ie.return === null || Up(ie.return)) return null;
        ie = ie.return;
      }
      for (ie.sibling.return = ie.return, ie = ie.sibling; ie.tag !== 5 && ie.tag !== 6 && ie.tag !== 18; ) {
        if (ie.flags & 2 || ie.child === null || ie.tag === 4) continue e;
        ie.child.return = ie, ie = ie.child;
      }
      if (!(ie.flags & 2)) return ie.stateNode;
    }
  }
  function xc(ie, pe, nt) {
    var pt = ie.tag;
    if (pt === 5 || pt === 6) ie = ie.stateNode, pe ? nt.nodeType === 8 ? nt.parentNode.insertBefore(ie, pe) : nt.insertBefore(ie, pe) : (nt.nodeType === 8 ? (pe = nt.parentNode, pe.insertBefore(ie, nt)) : (pe = nt, pe.appendChild(ie)), nt = nt._reactRootContainer, nt != null || pe.onclick !== null || (pe.onclick = hd));
    else if (pt !== 4 && (ie = ie.child, ie !== null)) for (xc(ie, pe, nt), ie = ie.sibling; ie !== null; ) xc(ie, pe, nt), ie = ie.sibling;
  }
  function gl(ie, pe, nt) {
    var pt = ie.tag;
    if (pt === 5 || pt === 6) ie = ie.stateNode, pe ? nt.insertBefore(ie, pe) : nt.appendChild(ie);
    else if (pt !== 4 && (ie = ie.child, ie !== null)) for (gl(ie, pe, nt), ie = ie.sibling; ie !== null; ) gl(ie, pe, nt), ie = ie.sibling;
  }
  var ta = null, Oa = !1;
  function no(ie, pe, nt) {
    for (nt = nt.child; nt !== null; ) bl(ie, pe, nt), nt = nt.sibling;
  }
  function bl(ie, pe, nt) {
    if (sa && typeof sa.onCommitFiberUnmount == "function") try {
      sa.onCommitFiberUnmount(Xa, nt);
    } catch {
    }
    switch (nt.tag) {
      case 5:
        Ua || yl(nt, pe);
      case 6:
        var pt = ta, Tt = Oa;
        ta = null, no(ie, pe, nt), ta = pt, Oa = Tt, ta !== null && (Oa ? (ie = ta, nt = nt.stateNode, ie.nodeType === 8 ? ie.parentNode.removeChild(nt) : ie.removeChild(nt)) : ta.removeChild(nt.stateNode));
        break;
      case 18:
        ta !== null && (Oa ? (ie = ta, nt = nt.stateNode, ie.nodeType === 8 ? $u(ie.parentNode, nt) : ie.nodeType === 1 && $u(ie, nt), wu(ie)) : $u(ta, nt.stateNode));
        break;
      case 4:
        pt = ta, Tt = Oa, ta = nt.stateNode.containerInfo, Oa = !0, no(ie, pe, nt), ta = pt, Oa = Tt;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Ua && (pt = nt.updateQueue, pt !== null && (pt = pt.lastEffect, pt !== null))) {
          Tt = pt = pt.next;
          do {
            var Pt = Tt, Yt = Pt.destroy;
            Pt = Pt.tag, Yt !== void 0 && (Pt & 2 || Pt & 4) && Lp(nt, pe, Yt), Tt = Tt.next;
          } while (Tt !== pt);
        }
        no(ie, pe, nt);
        break;
      case 1:
        if (!Ua && (yl(nt, pe), pt = nt.stateNode, typeof pt.componentWillUnmount == "function")) try {
          pt.props = nt.memoizedProps, pt.state = nt.memoizedState, pt.componentWillUnmount();
        } catch (cr) {
          da(nt, pe, cr);
        }
        no(ie, pe, nt);
        break;
      case 21:
        no(ie, pe, nt);
        break;
      case 22:
        nt.mode & 1 ? (Ua = (pt = Ua) || nt.memoizedState !== null, no(ie, pe, nt), Ua = pt) : no(ie, pe, nt);
        break;
      default:
        no(ie, pe, nt);
    }
  }
  function wl(ie) {
    var pe = ie.updateQueue;
    if (pe !== null) {
      ie.updateQueue = null;
      var nt = ie.stateNode;
      nt === null && (nt = ie.stateNode = new Gd()), pe.forEach(function(pt) {
        var Tt = ym.bind(null, ie, pt);
        nt.has(pt) || (nt.add(pt), pt.then(Tt, Tt));
      });
    }
  }
  function Pa(ie, pe) {
    var nt = pe.deletions;
    if (nt !== null) for (var pt = 0; pt < nt.length; pt++) {
      var Tt = nt[pt];
      try {
        var Pt = ie, Yt = pe, cr = Yt;
        e: for (; cr !== null; ) {
          switch (cr.tag) {
            case 5:
              ta = cr.stateNode, Oa = !1;
              break e;
            case 3:
              ta = cr.stateNode.containerInfo, Oa = !0;
              break e;
            case 4:
              ta = cr.stateNode.containerInfo, Oa = !0;
              break e;
          }
          cr = cr.return;
        }
        if (ta === null) throw Error(J(160));
        bl(Pt, Yt, Tt), ta = null, Oa = !1;
        var wr = Tt.alternate;
        wr !== null && (wr.return = null), Tt.return = null;
      } catch (Lr) {
        da(Tt, pe, Lr);
      }
    }
    if (pe.subtreeFlags & 12854) for (pe = pe.child; pe !== null; ) Q1(pe, ie), pe = pe.sibling;
  }
  function Q1(ie, pe) {
    var nt = ie.alternate, pt = ie.flags;
    switch (ie.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Pa(pe, ie), Rs(ie), pt & 4) {
          try {
            ml(3, ie, ie.return), Yd(3, ie);
          } catch (Fn) {
            da(ie, ie.return, Fn);
          }
          try {
            ml(5, ie, ie.return);
          } catch (Fn) {
            da(ie, ie.return, Fn);
          }
        }
        break;
      case 1:
        Pa(pe, ie), Rs(ie), pt & 512 && nt !== null && yl(nt, nt.return);
        break;
      case 5:
        if (Pa(pe, ie), Rs(ie), pt & 512 && nt !== null && yl(nt, nt.return), ie.flags & 32) {
          var Tt = ie.stateNode;
          try {
            Gt(Tt, "");
          } catch (Fn) {
            da(ie, ie.return, Fn);
          }
        }
        if (pt & 4 && (Tt = ie.stateNode, Tt != null)) {
          var Pt = ie.memoizedProps, Yt = nt !== null ? nt.memoizedProps : Pt, cr = ie.type, wr = ie.updateQueue;
          if (ie.updateQueue = null, wr !== null) try {
            cr === "input" && Pt.type === "radio" && Pt.name != null && Zr(Tt, Pt), fn(cr, Yt);
            var Lr = fn(cr, Pt);
            for (Yt = 0; Yt < wr.length; Yt += 2) {
              var en = wr[Yt], rn = wr[Yt + 1];
              en === "style" ? pr(Tt, rn) : en === "dangerouslySetInnerHTML" ? gi(Tt, rn) : en === "children" ? Gt(Tt, rn) : It(Tt, en, rn, Lr);
            }
            switch (cr) {
              case "input":
                ln(Tt, Pt);
                break;
              case "textarea":
                En(Tt, Pt);
                break;
              case "select":
                var Qr = Tt._wrapperState.wasMultiple;
                Tt._wrapperState.wasMultiple = !!Pt.multiple;
                var An = Pt.value;
                An != null ? xn(Tt, !!Pt.multiple, An, !1) : Qr !== !!Pt.multiple && (Pt.defaultValue != null ? xn(
                  Tt,
                  !!Pt.multiple,
                  Pt.defaultValue,
                  !0
                ) : xn(Tt, !!Pt.multiple, Pt.multiple ? [] : "", !1));
            }
            Tt[nf] = Pt;
          } catch (Fn) {
            da(ie, ie.return, Fn);
          }
        }
        break;
      case 6:
        if (Pa(pe, ie), Rs(ie), pt & 4) {
          if (ie.stateNode === null) throw Error(J(162));
          Tt = ie.stateNode, Pt = ie.memoizedProps;
          try {
            Tt.nodeValue = Pt;
          } catch (Fn) {
            da(ie, ie.return, Fn);
          }
        }
        break;
      case 3:
        if (Pa(pe, ie), Rs(ie), pt & 4 && nt !== null && nt.memoizedState.isDehydrated) try {
          wu(pe.containerInfo);
        } catch (Fn) {
          da(ie, ie.return, Fn);
        }
        break;
      case 4:
        Pa(pe, ie), Rs(ie);
        break;
      case 13:
        Pa(pe, ie), Rs(ie), Tt = ie.child, Tt.flags & 8192 && (Pt = Tt.memoizedState !== null, Tt.stateNode.isHidden = Pt, !Pt || Tt.alternate !== null && Tt.alternate.memoizedState !== null || (Zd = vi())), pt & 4 && wl(ie);
        break;
      case 22:
        if (en = nt !== null && nt.memoizedState !== null, ie.mode & 1 ? (Ua = (Lr = Ua) || en, Pa(pe, ie), Ua = Lr) : Pa(pe, ie), Rs(ie), pt & 8192) {
          if (Lr = ie.memoizedState !== null, (ie.stateNode.isHidden = Lr) && !en && ie.mode & 1) for (Mn = ie, en = ie.child; en !== null; ) {
            for (rn = Mn = en; Mn !== null; ) {
              switch (Qr = Mn, An = Qr.child, Qr.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  ml(4, Qr, Qr.return);
                  break;
                case 1:
                  yl(Qr, Qr.return);
                  var Nn = Qr.stateNode;
                  if (typeof Nn.componentWillUnmount == "function") {
                    pt = Qr, nt = Qr.return;
                    try {
                      pe = pt, Nn.props = pe.memoizedProps, Nn.state = pe.memoizedState, Nn.componentWillUnmount();
                    } catch (Fn) {
                      da(pt, nt, Fn);
                    }
                  }
                  break;
                case 5:
                  yl(Qr, Qr.return);
                  break;
                case 22:
                  if (Qr.memoizedState !== null) {
                    Z1(rn);
                    continue;
                  }
              }
              An !== null ? (An.return = Qr, Mn = An) : Z1(rn);
            }
            en = en.sibling;
          }
          e: for (en = null, rn = ie; ; ) {
            if (rn.tag === 5) {
              if (en === null) {
                en = rn;
                try {
                  Tt = rn.stateNode, Lr ? (Pt = Tt.style, typeof Pt.setProperty == "function" ? Pt.setProperty("display", "none", "important") : Pt.display = "none") : (cr = rn.stateNode, wr = rn.memoizedProps.style, Yt = wr != null && wr.hasOwnProperty("display") ? wr.display : null, cr.style.display = Zt("display", Yt));
                } catch (Fn) {
                  da(ie, ie.return, Fn);
                }
              }
            } else if (rn.tag === 6) {
              if (en === null) try {
                rn.stateNode.nodeValue = Lr ? "" : rn.memoizedProps;
              } catch (Fn) {
                da(ie, ie.return, Fn);
              }
            } else if ((rn.tag !== 22 && rn.tag !== 23 || rn.memoizedState === null || rn === ie) && rn.child !== null) {
              rn.child.return = rn, rn = rn.child;
              continue;
            }
            if (rn === ie) break e;
            for (; rn.sibling === null; ) {
              if (rn.return === null || rn.return === ie) break e;
              en === rn && (en = null), rn = rn.return;
            }
            en === rn && (en = null), rn.sibling.return = rn.return, rn = rn.sibling;
          }
        }
        break;
      case 19:
        Pa(pe, ie), Rs(ie), pt & 4 && wl(ie);
        break;
      case 21:
        break;
      default:
        Pa(
          pe,
          ie
        ), Rs(ie);
    }
  }
  function Rs(ie) {
    var pe = ie.flags;
    if (pe & 2) {
      try {
        e: {
          for (var nt = ie.return; nt !== null; ) {
            if (Up(nt)) {
              var pt = nt;
              break e;
            }
            nt = nt.return;
          }
          throw Error(J(160));
        }
        switch (pt.tag) {
          case 5:
            var Tt = pt.stateNode;
            pt.flags & 32 && (Gt(Tt, ""), pt.flags &= -33);
            var Pt = J1(ie);
            gl(ie, Pt, Tt);
            break;
          case 3:
          case 4:
            var Yt = pt.stateNode.containerInfo, cr = J1(ie);
            xc(ie, cr, Yt);
            break;
          default:
            throw Error(J(161));
        }
      } catch (wr) {
        da(ie, ie.return, wr);
      }
      ie.flags &= -3;
    }
    pe & 4096 && (ie.flags &= -4097);
  }
  function lm(ie, pe, nt) {
    Mn = ie, Fp(ie);
  }
  function Fp(ie, pe, nt) {
    for (var pt = (ie.mode & 1) !== 0; Mn !== null; ) {
      var Tt = Mn, Pt = Tt.child;
      if (Tt.tag === 22 && pt) {
        var Yt = Tt.memoizedState !== null || vl;
        if (!Yt) {
          var cr = Tt.alternate, wr = cr !== null && cr.memoizedState !== null || Ua;
          cr = vl;
          var Lr = Ua;
          if (vl = Yt, (Ua = wr) && !Lr) for (Mn = Tt; Mn !== null; ) Yt = Mn, wr = Yt.child, Yt.tag === 22 && Yt.memoizedState !== null ? Hp(Tt) : wr !== null ? (wr.return = Yt, Mn = wr) : Hp(Tt);
          for (; Pt !== null; ) Mn = Pt, Fp(Pt), Pt = Pt.sibling;
          Mn = Tt, vl = cr, Ua = Lr;
        }
        _l(ie);
      } else Tt.subtreeFlags & 8772 && Pt !== null ? (Pt.return = Tt, Mn = Pt) : _l(ie);
    }
  }
  function _l(ie) {
    for (; Mn !== null; ) {
      var pe = Mn;
      if (pe.flags & 8772) {
        var nt = pe.alternate;
        try {
          if (pe.flags & 8772) switch (pe.tag) {
            case 0:
            case 11:
            case 15:
              Ua || Yd(5, pe);
              break;
            case 1:
              var pt = pe.stateNode;
              if (pe.flags & 4 && !Ua) if (nt === null) pt.componentDidMount();
              else {
                var Tt = pe.elementType === pe.type ? nt.memoizedProps : $o(pe.type, nt.memoizedProps);
                pt.componentDidUpdate(Tt, nt.memoizedState, pt.__reactInternalSnapshotBeforeUpdate);
              }
              var Pt = pe.updateQueue;
              Pt !== null && D1(pe, Pt, pt);
              break;
            case 3:
              var Yt = pe.updateQueue;
              if (Yt !== null) {
                if (nt = null, pe.child !== null) switch (pe.child.tag) {
                  case 5:
                    nt = pe.child.stateNode;
                    break;
                  case 1:
                    nt = pe.child.stateNode;
                }
                D1(pe, Yt, nt);
              }
              break;
            case 5:
              var cr = pe.stateNode;
              if (nt === null && pe.flags & 4) {
                nt = cr;
                var wr = pe.memoizedProps;
                switch (pe.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    wr.autoFocus && nt.focus();
                    break;
                  case "img":
                    wr.src && (nt.src = wr.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (pe.memoizedState === null) {
                var Lr = pe.alternate;
                if (Lr !== null) {
                  var en = Lr.memoizedState;
                  if (en !== null) {
                    var rn = en.dehydrated;
                    rn !== null && wu(rn);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(J(163));
          }
          Ua || pe.flags & 512 && Jd(pe);
        } catch (Qr) {
          da(pe, pe.return, Qr);
        }
      }
      if (pe === ie) {
        Mn = null;
        break;
      }
      if (nt = pe.sibling, nt !== null) {
        nt.return = pe.return, Mn = nt;
        break;
      }
      Mn = pe.return;
    }
  }
  function Z1(ie) {
    for (; Mn !== null; ) {
      var pe = Mn;
      if (pe === ie) {
        Mn = null;
        break;
      }
      var nt = pe.sibling;
      if (nt !== null) {
        nt.return = pe.return, Mn = nt;
        break;
      }
      Mn = pe.return;
    }
  }
  function Hp(ie) {
    for (; Mn !== null; ) {
      var pe = Mn;
      try {
        switch (pe.tag) {
          case 0:
          case 11:
          case 15:
            var nt = pe.return;
            try {
              Yd(4, pe);
            } catch (wr) {
              da(pe, nt, wr);
            }
            break;
          case 1:
            var pt = pe.stateNode;
            if (typeof pt.componentDidMount == "function") {
              var Tt = pe.return;
              try {
                pt.componentDidMount();
              } catch (wr) {
                da(pe, Tt, wr);
              }
            }
            var Pt = pe.return;
            try {
              Jd(pe);
            } catch (wr) {
              da(pe, Pt, wr);
            }
            break;
          case 5:
            var Yt = pe.return;
            try {
              Jd(pe);
            } catch (wr) {
              da(pe, Yt, wr);
            }
        }
      } catch (wr) {
        da(pe, pe.return, wr);
      }
      if (pe === ie) {
        Mn = null;
        break;
      }
      var cr = pe.sibling;
      if (cr !== null) {
        cr.return = pe.return, Mn = cr;
        break;
      }
      Mn = pe.return;
    }
  }
  var cm = Math.ceil, yf = Ft.ReactCurrentDispatcher, Qd = Ft.ReactCurrentOwner, ns = Ft.ReactCurrentBatchConfig, bi = 0, ca = null, Yi = null, $a = 0, Ao = 0, Sl = hi(0), xa = 0, Tc = null, mf = 0, El = 0, jp = 0, Pu = null, eo = null, Zd = 0, $l = 1 / 0, eu = null, eh = !1, zp = null, is = null, xl = !1, as = null, th = 0, Ac = 0, nh = null, Rc = -1, gf = 0;
  function Ia() {
    return bi & 6 ? vi() : Rc !== -1 ? Rc : Rc = vi();
  }
  function tu(ie) {
    return ie.mode & 1 ? bi & 2 && $a !== 0 ? $a & -$a : bd.transition !== null ? (gf === 0 && (gf = If()), gf) : (ie = Ci, ie !== 0 || (ie = window.event, ie = ie === void 0 ? 16 : Xl(ie.type)), ie) : 1;
  }
  function aa(ie, pe, nt, pt) {
    if (50 < Ac) throw Ac = 0, nh = null, Error(J(185));
    Us(ie, nt, pt), (!(bi & 2) || ie !== ca) && (ie === ca && (!(bi & 2) && (El |= nt), xa === 4 && Cs(ie, $a)), Ta(ie, pt), nt === 1 && bi === 0 && !(pe.mode & 1) && ($l = vi() + 500, Ma && bo()));
  }
  function Ta(ie, pe) {
    var nt = ie.callbackNode;
    yu(ie, pe);
    var pt = to(ie, ie === ca ? $a : 0);
    if (pt === 0) nt !== null && Ri(nt), ie.callbackNode = null, ie.callbackPriority = 0;
    else if (pe = pt & -pt, ie.callbackPriority !== pe) {
      if (nt != null && Ri(nt), pe === 1) ie.tag === 0 ? _p(Tl.bind(null, ie)) : wp(Tl.bind(null, ie)), mp(function() {
        !(bi & 6) && bo();
      }), nt = null;
      else {
        switch (Nf(pt)) {
          case 1:
            nt = ra;
            break;
          case 4:
            nt = ii;
            break;
          case 16:
            nt = ma;
            break;
          case 536870912:
            nt = po;
            break;
          default:
            nt = ma;
        }
        nt = sv(nt, ih.bind(null, ie));
      }
      ie.callbackPriority = pe, ie.callbackNode = nt;
    }
  }
  function ih(ie, pe) {
    if (Rc = -1, gf = 0, bi & 6) throw Error(J(327));
    var nt = ie.callbackNode;
    if (Al() && ie.callbackNode !== nt) return null;
    var pt = to(ie, ie === ca ? $a : 0);
    if (pt === 0) return null;
    if (pt & 30 || pt & ie.expiredLanes || pe) pe = oh(ie, pt);
    else {
      pe = pt;
      var Tt = bi;
      bi |= 2;
      var Pt = tv();
      (ca !== ie || $a !== pe) && (eu = null, $l = vi() + 500, wf(ie, pe));
      do
        try {
          hm();
          break;
        } catch (cr) {
          ev(ie, cr);
        }
      while (!0);
      No(), yf.current = Pt, bi = Tt, Yi !== null ? pe = 0 : (ca = null, $a = 0, pe = xa);
    }
    if (pe !== 0) {
      if (pe === 2 && (Tt = mu(ie), Tt !== 0 && (pt = Tt, pe = bf(ie, Tt))), pe === 1) throw nt = Tc, wf(ie, 0), Cs(ie, pt), Ta(ie, vi()), nt;
      if (pe === 6) Cs(ie, pt);
      else {
        if (Tt = ie.current.alternate, !(pt & 30) && !Wp(Tt) && (pe = oh(ie, pt), pe === 2 && (Pt = mu(ie), Pt !== 0 && (pt = Pt, pe = bf(ie, Pt))), pe === 1)) throw nt = Tc, wf(ie, 0), Cs(ie, pt), Ta(ie, vi()), nt;
        switch (ie.finishedWork = Tt, ie.finishedLanes = pt, pe) {
          case 0:
          case 1:
            throw Error(J(345));
          case 2:
            Iu(ie, eo, eu);
            break;
          case 3:
            if (Cs(ie, pt), (pt & 130023424) === pt && (pe = Zd + 500 - vi(), 10 < pe)) {
              if (to(ie, 0) !== 0) break;
              if (Tt = ie.suspendedLanes, (Tt & pt) !== pt) {
                Ia(), ie.pingedLanes |= ie.suspendedLanes & Tt;
                break;
              }
              ie.timeoutHandle = rf(Iu.bind(null, ie, eo, eu), pe);
              break;
            }
            Iu(ie, eo, eu);
            break;
          case 4:
            if (Cs(ie, pt), (pt & 4194240) === pt) break;
            for (pe = ie.eventTimes, Tt = -1; 0 < pt; ) {
              var Yt = 31 - Sa(pt);
              Pt = 1 << Yt, Yt = pe[Yt], Yt > Tt && (Tt = Yt), pt &= ~Pt;
            }
            if (pt = Tt, pt = vi() - pt, pt = (120 > pt ? 120 : 480 > pt ? 480 : 1080 > pt ? 1080 : 1920 > pt ? 1920 : 3e3 > pt ? 3e3 : 4320 > pt ? 4320 : 1960 * cm(pt / 1960)) - pt, 10 < pt) {
              ie.timeoutHandle = rf(Iu.bind(null, ie, eo, eu), pt);
              break;
            }
            Iu(ie, eo, eu);
            break;
          case 5:
            Iu(ie, eo, eu);
            break;
          default:
            throw Error(J(329));
        }
      }
    }
    return Ta(ie, vi()), ie.callbackNode === nt ? ih.bind(null, ie) : null;
  }
  function bf(ie, pe) {
    var nt = Pu;
    return ie.current.memoizedState.isDehydrated && (wf(ie, pe).flags |= 256), ie = oh(ie, pe), ie !== 2 && (pe = eo, eo = nt, pe !== null && qp(pe)), ie;
  }
  function qp(ie) {
    eo === null ? eo = ie : eo.push.apply(eo, ie);
  }
  function Wp(ie) {
    for (var pe = ie; ; ) {
      if (pe.flags & 16384) {
        var nt = pe.updateQueue;
        if (nt !== null && (nt = nt.stores, nt !== null)) for (var pt = 0; pt < nt.length; pt++) {
          var Tt = nt[pt], Pt = Tt.getSnapshot;
          Tt = Tt.value;
          try {
            if (!Vo(Pt(), Tt)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (nt = pe.child, pe.subtreeFlags & 16384 && nt !== null) nt.return = pe, pe = nt;
      else {
        if (pe === ie) break;
        for (; pe.sibling === null; ) {
          if (pe.return === null || pe.return === ie) return !0;
          pe = pe.return;
        }
        pe.sibling.return = pe.return, pe = pe.sibling;
      }
    }
    return !0;
  }
  function Cs(ie, pe) {
    for (pe &= ~jp, pe &= ~El, ie.suspendedLanes |= pe, ie.pingedLanes &= ~pe, ie = ie.expirationTimes; 0 < pe; ) {
      var nt = 31 - Sa(pe), pt = 1 << nt;
      ie[nt] = -1, pe &= ~pt;
    }
  }
  function Tl(ie) {
    if (bi & 6) throw Error(J(327));
    Al();
    var pe = to(ie, 0);
    if (!(pe & 1)) return Ta(ie, vi()), null;
    var nt = oh(ie, pe);
    if (ie.tag !== 0 && nt === 2) {
      var pt = mu(ie);
      pt !== 0 && (pe = pt, nt = bf(ie, pt));
    }
    if (nt === 1) throw nt = Tc, wf(ie, 0), Cs(ie, pe), Ta(ie, vi()), nt;
    if (nt === 6) throw Error(J(345));
    return ie.finishedWork = ie.current.alternate, ie.finishedLanes = pe, Iu(ie, eo, eu), Ta(ie, vi()), null;
  }
  function Kp(ie, pe) {
    var nt = bi;
    bi |= 1;
    try {
      return ie(pe);
    } finally {
      bi = nt, bi === 0 && ($l = vi() + 500, Ma && bo());
    }
  }
  function Bs(ie) {
    as !== null && as.tag === 0 && !(bi & 6) && Al();
    var pe = bi;
    bi |= 1;
    var nt = ns.transition, pt = Ci;
    try {
      if (ns.transition = null, Ci = 1, ie) return ie();
    } finally {
      Ci = pt, ns.transition = nt, bi = pe, !(bi & 6) && bo();
    }
  }
  function ah() {
    Ao = Sl.current, Oi(Sl);
  }
  function wf(ie, pe) {
    ie.finishedWork = null, ie.finishedLanes = 0;
    var nt = ie.timeoutHandle;
    if (nt !== -1 && (ie.timeoutHandle = -1, A1(nt)), Yi !== null) for (nt = Yi.return; nt !== null; ) {
      var pt = nt;
      switch (Ep(pt), pt.tag) {
        case 1:
          pt = pt.type.childContextTypes, pt != null && Yo();
          break;
        case 3:
          rl(), Oi(fa), Oi(oi), Bp();
          break;
        case 5:
          Cp(pt);
          break;
        case 4:
          rl();
          break;
        case 13:
          Oi(ea);
          break;
        case 19:
          Oi(ea);
          break;
        case 10:
          Tp(pt.type._context);
          break;
        case 22:
        case 23:
          ah();
      }
      nt = nt.return;
    }
    if (ca = ie, Yi = ie = Du(ie.current, null), $a = Ao = pe, xa = 0, Tc = null, jp = El = mf = 0, eo = Pu = null, sf !== null) {
      for (pe = 0; pe < sf.length; pe++) if (nt = sf[pe], pt = nt.interleaved, pt !== null) {
        nt.interleaved = null;
        var Tt = pt.next, Pt = nt.pending;
        if (Pt !== null) {
          var Yt = Pt.next;
          Pt.next = Tt, pt.next = Yt;
        }
        nt.pending = pt;
      }
      sf = null;
    }
    return ie;
  }
  function ev(ie, pe) {
    do {
      var nt = Yi;
      try {
        if (No(), Td.current = Qa, Lo) {
          for (var pt = zn.memoizedState; pt !== null; ) {
            var Tt = pt.queue;
            Tt !== null && (Tt.pending = null), pt = pt.next;
          }
          Lo = !1;
        }
        if (Hn = 0, mi = si = zn = null, nl = !1, yc = 0, Qd.current = null, nt === null || nt.return === null) {
          xa = 1, Tc = pe, Yi = null;
          break;
        }
        e: {
          var Pt = ie, Yt = nt.return, cr = nt, wr = pe;
          if (pe = $a, cr.flags |= 32768, wr !== null && typeof wr == "object" && typeof wr.then == "function") {
            var Lr = wr, en = cr, rn = en.tag;
            if (!(en.mode & 1) && (rn === 0 || rn === 11 || rn === 15)) {
              var Qr = en.alternate;
              Qr ? (en.updateQueue = Qr.updateQueue, en.memoizedState = Qr.memoizedState, en.lanes = Qr.lanes) : (en.updateQueue = null, en.memoizedState = null);
            }
            var An = W1(Yt);
            if (An !== null) {
              An.flags &= -257, Ip(An, Yt, cr, Pt, pe), An.mode & 1 && _c(Pt, Lr, pe), pe = An, wr = Lr;
              var Nn = pe.updateQueue;
              if (Nn === null) {
                var Fn = /* @__PURE__ */ new Set();
                Fn.add(wr), pe.updateQueue = Fn;
              } else Nn.add(wr);
              break e;
            } else {
              if (!(pe & 1)) {
                _c(Pt, Lr, pe), Cc();
                break e;
              }
              wr = Error(J(426));
            }
          } else if (Xi && cr.mode & 1) {
            var va = W1(Yt);
            if (va !== null) {
              !(va.flags & 65536) && (va.flags |= 256), Ip(va, Yt, cr, Pt, pe), xp(Mu(wr, cr));
              break e;
            }
          }
          Pt = wr = Mu(wr, cr), xa !== 4 && (xa = 2), Pu === null ? Pu = [Pt] : Pu.push(Pt), Pt = Yt;
          do {
            switch (Pt.tag) {
              case 3:
                Pt.flags |= 65536, pe &= -pe, Pt.lanes |= pe;
                var Rr = z1(Pt, wr, pe);
                I1(Pt, Rr);
                break e;
              case 1:
                cr = wr;
                var $r = Pt.type, kr = Pt.stateNode;
                if (!(Pt.flags & 128) && (typeof $r.getDerivedStateFromError == "function" || kr !== null && typeof kr.componentDidCatch == "function" && (is === null || !is.has(kr)))) {
                  Pt.flags |= 65536, pe &= -pe, Pt.lanes |= pe;
                  var un = q1(Pt, cr, pe);
                  I1(Pt, un);
                  break e;
                }
            }
            Pt = Pt.return;
          } while (Pt !== null);
        }
        nv(nt);
      } catch (jn) {
        pe = jn, Yi === nt && nt !== null && (Yi = nt = nt.return);
        continue;
      }
      break;
    } while (!0);
  }
  function tv() {
    var ie = yf.current;
    return yf.current = Qa, ie === null ? Qa : ie;
  }
  function Cc() {
    (xa === 0 || xa === 3 || xa === 2) && (xa = 4), ca === null || !(mf & 268435455) && !(El & 268435455) || Cs(ca, $a);
  }
  function oh(ie, pe) {
    var nt = bi;
    bi |= 2;
    var pt = tv();
    (ca !== ie || $a !== pe) && (eu = null, wf(ie, pe));
    do
      try {
        dm();
        break;
      } catch (Tt) {
        ev(ie, Tt);
      }
    while (!0);
    if (No(), bi = nt, yf.current = pt, Yi !== null) throw Error(J(261));
    return ca = null, $a = 0, xa;
  }
  function dm() {
    for (; Yi !== null; ) rv(Yi);
  }
  function hm() {
    for (; Yi !== null && !Qi(); ) rv(Yi);
  }
  function rv(ie) {
    var pe = ov(ie.alternate, ie, Ao);
    ie.memoizedProps = ie.pendingProps, pe === null ? nv(ie) : Yi = pe, Qd.current = null;
  }
  function nv(ie) {
    var pe = ie;
    do {
      var nt = pe.alternate;
      if (ie = pe.return, pe.flags & 32768) {
        if (nt = um(nt, pe), nt !== null) {
          nt.flags &= 32767, Yi = nt;
          return;
        }
        if (ie !== null) ie.flags |= 32768, ie.subtreeFlags = 0, ie.deletions = null;
        else {
          xa = 6, Yi = null;
          return;
        }
      } else if (nt = sm(nt, pe, Ao), nt !== null) {
        Yi = nt;
        return;
      }
      if (pe = pe.sibling, pe !== null) {
        Yi = pe;
        return;
      }
      Yi = pe = ie;
    } while (pe !== null);
    xa === 0 && (xa = 5);
  }
  function Iu(ie, pe, nt) {
    var pt = Ci, Tt = ns.transition;
    try {
      ns.transition = null, Ci = 1, pm(ie, pe, nt, pt);
    } finally {
      ns.transition = Tt, Ci = pt;
    }
    return null;
  }
  function pm(ie, pe, nt, pt) {
    do
      Al();
    while (as !== null);
    if (bi & 6) throw Error(J(327));
    nt = ie.finishedWork;
    var Tt = ie.finishedLanes;
    if (nt === null) return null;
    if (ie.finishedWork = null, ie.finishedLanes = 0, nt === ie.current) throw Error(J(177));
    ie.callbackNode = null, ie.callbackPriority = 0;
    var Pt = nt.lanes | nt.childLanes;
    if (Yh(ie, Pt), ie === ca && (Yi = ca = null, $a = 0), !(nt.subtreeFlags & 2064) && !(nt.flags & 2064) || xl || (xl = !0, sv(ma, function() {
      return Al(), null;
    })), Pt = (nt.flags & 15990) !== 0, nt.subtreeFlags & 15990 || Pt) {
      Pt = ns.transition, ns.transition = null;
      var Yt = Ci;
      Ci = 1;
      var cr = bi;
      bi |= 4, Qd.current = null, fm(ie, nt), Q1(nt, ie), ud(tf), Ko = !!vp, tf = vp = null, ie.current = nt, lm(nt), Ca(), bi = cr, Ci = Yt, ns.transition = Pt;
    } else ie.current = nt;
    if (xl && (xl = !1, as = ie, th = Tt), Pt = ie.pendingLanes, Pt === 0 && (is = null), Oo(nt.stateNode), Ta(ie, vi()), pe !== null) for (pt = ie.onRecoverableError, nt = 0; nt < pe.length; nt++) Tt = pe[nt], pt(Tt.value, { componentStack: Tt.stack, digest: Tt.digest });
    if (eh) throw eh = !1, ie = zp, zp = null, ie;
    return th & 1 && ie.tag !== 0 && Al(), Pt = ie.pendingLanes, Pt & 1 ? ie === nh ? Ac++ : (Ac = 0, nh = ie) : Ac = 0, bo(), null;
  }
  function Al() {
    if (as !== null) {
      var ie = Nf(th), pe = ns.transition, nt = Ci;
      try {
        if (ns.transition = null, Ci = 16 > ie ? 16 : ie, as === null) var pt = !1;
        else {
          if (ie = as, as = null, th = 0, bi & 6) throw Error(J(331));
          var Tt = bi;
          for (bi |= 4, Mn = ie.current; Mn !== null; ) {
            var Pt = Mn, Yt = Pt.child;
            if (Mn.flags & 16) {
              var cr = Pt.deletions;
              if (cr !== null) {
                for (var wr = 0; wr < cr.length; wr++) {
                  var Lr = cr[wr];
                  for (Mn = Lr; Mn !== null; ) {
                    var en = Mn;
                    switch (en.tag) {
                      case 0:
                      case 11:
                      case 15:
                        ml(8, en, Pt);
                    }
                    var rn = en.child;
                    if (rn !== null) rn.return = en, Mn = rn;
                    else for (; Mn !== null; ) {
                      en = Mn;
                      var Qr = en.sibling, An = en.return;
                      if (Y1(en), en === Lr) {
                        Mn = null;
                        break;
                      }
                      if (Qr !== null) {
                        Qr.return = An, Mn = Qr;
                        break;
                      }
                      Mn = An;
                    }
                  }
                }
                var Nn = Pt.alternate;
                if (Nn !== null) {
                  var Fn = Nn.child;
                  if (Fn !== null) {
                    Nn.child = null;
                    do {
                      var va = Fn.sibling;
                      Fn.sibling = null, Fn = va;
                    } while (Fn !== null);
                  }
                }
                Mn = Pt;
              }
            }
            if (Pt.subtreeFlags & 2064 && Yt !== null) Yt.return = Pt, Mn = Yt;
            else e: for (; Mn !== null; ) {
              if (Pt = Mn, Pt.flags & 2048) switch (Pt.tag) {
                case 0:
                case 11:
                case 15:
                  ml(9, Pt, Pt.return);
              }
              var Rr = Pt.sibling;
              if (Rr !== null) {
                Rr.return = Pt.return, Mn = Rr;
                break e;
              }
              Mn = Pt.return;
            }
          }
          var $r = ie.current;
          for (Mn = $r; Mn !== null; ) {
            Yt = Mn;
            var kr = Yt.child;
            if (Yt.subtreeFlags & 2064 && kr !== null) kr.return = Yt, Mn = kr;
            else e: for (Yt = $r; Mn !== null; ) {
              if (cr = Mn, cr.flags & 2048) try {
                switch (cr.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Yd(9, cr);
                }
              } catch (jn) {
                da(cr, cr.return, jn);
              }
              if (cr === Yt) {
                Mn = null;
                break e;
              }
              var un = cr.sibling;
              if (un !== null) {
                un.return = cr.return, Mn = un;
                break e;
              }
              Mn = cr.return;
            }
          }
          if (bi = Tt, bo(), sa && typeof sa.onPostCommitFiberRoot == "function") try {
            sa.onPostCommitFiberRoot(Xa, ie);
          } catch {
          }
          pt = !0;
        }
        return pt;
      } finally {
        Ci = nt, ns.transition = pe;
      }
    }
    return !1;
  }
  function iv(ie, pe, nt) {
    pe = Mu(nt, pe), pe = z1(ie, pe, 1), ie = Bu(ie, pe, 1), pe = Ia(), ie !== null && (Us(ie, 1, pe), Ta(ie, pe));
  }
  function da(ie, pe, nt) {
    if (ie.tag === 3) iv(ie, ie, nt);
    else for (; pe !== null; ) {
      if (pe.tag === 3) {
        iv(pe, ie, nt);
        break;
      } else if (pe.tag === 1) {
        var pt = pe.stateNode;
        if (typeof pe.type.getDerivedStateFromError == "function" || typeof pt.componentDidCatch == "function" && (is === null || !is.has(pt))) {
          ie = Mu(nt, ie), ie = q1(pe, ie, 1), pe = Bu(pe, ie, 1), ie = Ia(), pe !== null && (Us(pe, 1, ie), Ta(pe, ie));
          break;
        }
      }
      pe = pe.return;
    }
  }
  function vm(ie, pe, nt) {
    var pt = ie.pingCache;
    pt !== null && pt.delete(pe), pe = Ia(), ie.pingedLanes |= ie.suspendedLanes & nt, ca === ie && ($a & nt) === nt && (xa === 4 || xa === 3 && ($a & 130023424) === $a && 500 > vi() - Zd ? wf(ie, 0) : jp |= nt), Ta(ie, pe);
  }
  function av(ie, pe) {
    pe === 0 && (ie.mode & 1 ? (pe = pu, pu <<= 1, !(pu & 130023424) && (pu = 4194304)) : pe = 1);
    var nt = Ia();
    ie = Js(ie, pe), ie !== null && (Us(ie, pe, nt), Ta(ie, nt));
  }
  function Vp(ie) {
    var pe = ie.memoizedState, nt = 0;
    pe !== null && (nt = pe.retryLane), av(ie, nt);
  }
  function ym(ie, pe) {
    var nt = 0;
    switch (ie.tag) {
      case 13:
        var pt = ie.stateNode, Tt = ie.memoizedState;
        Tt !== null && (nt = Tt.retryLane);
        break;
      case 19:
        pt = ie.stateNode;
        break;
      default:
        throw Error(J(314));
    }
    pt !== null && pt.delete(pe), av(ie, nt);
  }
  var ov;
  ov = function(ie, pe, nt) {
    if (ie !== null) if (ie.memoizedProps !== pe.pendingProps || fa.current) xo = !0;
    else {
      if (!(ie.lanes & nt) && !(pe.flags & 128)) return xo = !1, Zs(ie, pe, nt);
      xo = !!(ie.flags & 131072);
    }
    else xo = !1, Xi && pe.flags & 1048576 && Sp(pe, Jf, pe.index);
    switch (pe.lanes = 0, pe.tag) {
      case 2:
        var pt = pe.type;
        $c(ie, pe), ie = pe.pendingProps;
        var Tt = Xo(pe, oi.current);
        Zf(pe, nt), Tt = Jr(null, pe, pt, ie, Tt, nt);
        var Pt = wa();
        return pe.flags |= 1, typeof Tt == "object" && Tt !== null && typeof Tt.render == "function" && Tt.$$typeof === void 0 ? (pe.tag = 1, pe.memoizedState = null, pe.updateQueue = null, Zi(pt) ? (Pt = !0, pd(pe)) : Pt = !1, pe.memoizedState = Tt.state !== null && Tt.state !== void 0 ? Tt.state : null, _d(pe), Tt.updater = hf, pe.stateNode = Tt, Tt._reactInternals = pe, Op(pe, pt, ie, nt), pe = qd(null, pe, pt, !0, Pt, nt)) : (pe.tag = 0, Xi && Pt && vd(pe), ha(null, pe, Tt, nt), pe = pe.child), pe;
      case 16:
        pt = pe.elementType;
        e: {
          switch ($c(ie, pe), ie = pe.pendingProps, Tt = pt._init, pt = Tt(pt._payload), pe.type = pt, Tt = pe.tag = mm(pt), ie = $o(pt, ie), Tt) {
            case 0:
              pe = di(null, pe, pt, ie, nt);
              break e;
            case 1:
              pe = Sc(null, pe, pt, ie, nt);
              break e;
            case 11:
              pe = cl(null, pe, pt, ie, nt);
              break e;
            case 14:
              pe = Ou(null, pe, pt, $o(pt.type, ie), nt);
              break e;
          }
          throw Error(J(
            306,
            pt,
            ""
          ));
        }
        return pe;
      case 0:
        return pt = pe.type, Tt = pe.pendingProps, Tt = pe.elementType === pt ? Tt : $o(pt, Tt), di(ie, pe, pt, Tt, nt);
      case 1:
        return pt = pe.type, Tt = pe.pendingProps, Tt = pe.elementType === pt ? Tt : $o(pt, Tt), Sc(ie, pe, pt, Tt, nt);
      case 3:
        e: {
          if (om(pe), ie === null) throw Error(J(387));
          pt = pe.pendingProps, Pt = pe.memoizedState, Tt = Pt.element, el(ie, pe), Ed(pe, pt, null, nt);
          var Yt = pe.memoizedState;
          if (pt = Yt.element, Pt.isDehydrated) if (Pt = { element: pt, isDehydrated: !1, cache: Yt.cache, pendingSuspenseBoundaries: Yt.pendingSuspenseBoundaries, transitions: Yt.transitions }, pe.updateQueue.baseState = Pt, pe.memoizedState = Pt, pe.flags & 256) {
            Tt = Mu(Error(J(423)), pe), pe = V1(ie, pe, pt, nt, Tt);
            break e;
          } else if (pt !== Tt) {
            Tt = Mu(Error(J(424)), pe), pe = V1(ie, pe, pt, nt, Tt);
            break e;
          } else for (So = ms(pe.stateNode.containerInfo.firstChild), Do = pe, Xi = !0, Qo = null, nt = O1(pe, null, pt, nt), pe.child = nt; nt; ) nt.flags = nt.flags & -3 | 4096, nt = nt.sibling;
          else {
            if (ia(), pt === Tt) {
              pe = pa(ie, pe, nt);
              break e;
            }
            ha(ie, pe, pt, nt);
          }
          pe = pe.child;
        }
        return pe;
      case 5:
        return N1(pe), ie === null && md(pe), pt = pe.type, Tt = pe.pendingProps, Pt = ie !== null ? ie.memoizedProps : null, Yt = Tt.children, uc(pt, Tt) ? Yt = null : Pt !== null && uc(pt, Pt) && (pe.flags |= 32), pf(ie, pe), ha(ie, pe, Yt, nt), pe.child;
      case 6:
        return ie === null && md(pe), null;
      case 13:
        return G1(ie, pe, nt);
      case 4:
        return Rp(pe, pe.stateNode.containerInfo), pt = pe.pendingProps, ie === null ? pe.child = Qf(pe, null, pt, nt) : ha(ie, pe, pt, nt), pe.child;
      case 11:
        return pt = pe.type, Tt = pe.pendingProps, Tt = pe.elementType === pt ? Tt : $o(pt, Tt), cl(ie, pe, pt, Tt, nt);
      case 7:
        return ha(ie, pe, pe.pendingProps, nt), pe.child;
      case 8:
        return ha(ie, pe, pe.pendingProps.children, nt), pe.child;
      case 12:
        return ha(ie, pe, pe.pendingProps.children, nt), pe.child;
      case 10:
        e: {
          if (pt = pe.type._context, Tt = pe.pendingProps, Pt = pe.memoizedProps, Yt = Tt.value, Di(Ys, pt._currentValue), pt._currentValue = Yt, Pt !== null) if (Vo(Pt.value, Yt)) {
            if (Pt.children === Tt.children && !fa.current) {
              pe = pa(ie, pe, nt);
              break e;
            }
          } else for (Pt = pe.child, Pt !== null && (Pt.return = pe); Pt !== null; ) {
            var cr = Pt.dependencies;
            if (cr !== null) {
              Yt = Pt.child;
              for (var wr = cr.firstContext; wr !== null; ) {
                if (wr.context === pt) {
                  if (Pt.tag === 1) {
                    wr = Eo(-1, nt & -nt), wr.tag = 2;
                    var Lr = Pt.updateQueue;
                    if (Lr !== null) {
                      Lr = Lr.shared;
                      var en = Lr.pending;
                      en === null ? wr.next = wr : (wr.next = en.next, en.next = wr), Lr.pending = wr;
                    }
                  }
                  Pt.lanes |= nt, wr = Pt.alternate, wr !== null && (wr.lanes |= nt), Ap(
                    Pt.return,
                    nt,
                    pe
                  ), cr.lanes |= nt;
                  break;
                }
                wr = wr.next;
              }
            } else if (Pt.tag === 10) Yt = Pt.type === pe.type ? null : Pt.child;
            else if (Pt.tag === 18) {
              if (Yt = Pt.return, Yt === null) throw Error(J(341));
              Yt.lanes |= nt, cr = Yt.alternate, cr !== null && (cr.lanes |= nt), Ap(Yt, nt, pe), Yt = Pt.sibling;
            } else Yt = Pt.child;
            if (Yt !== null) Yt.return = Pt;
            else for (Yt = Pt; Yt !== null; ) {
              if (Yt === pe) {
                Yt = null;
                break;
              }
              if (Pt = Yt.sibling, Pt !== null) {
                Pt.return = Yt.return, Yt = Pt;
                break;
              }
              Yt = Yt.return;
            }
            Pt = Yt;
          }
          ha(ie, pe, Tt.children, nt), pe = pe.child;
        }
        return pe;
      case 9:
        return Tt = pe.type, pt = pe.pendingProps.children, Zf(pe, nt), Tt = es(Tt), pt = pt(Tt), pe.flags |= 1, ha(ie, pe, pt, nt), pe.child;
      case 14:
        return pt = pe.type, Tt = $o(pt, pe.pendingProps), Tt = $o(pt.type, Tt), Ou(ie, pe, pt, Tt, nt);
      case 15:
        return zd(ie, pe, pe.type, pe.pendingProps, nt);
      case 17:
        return pt = pe.type, Tt = pe.pendingProps, Tt = pe.elementType === pt ? Tt : $o(pt, Tt), $c(ie, pe), pe.tag = 1, Zi(pt) ? (ie = !0, pd(pe)) : ie = !1, Zf(pe, nt), F1(pe, pt, Tt), Op(pe, pt, Tt, nt), qd(null, pe, pt, !0, ie, nt);
      case 19:
        return Np(ie, pe, nt);
      case 22:
        return To(ie, pe, nt);
    }
    throw Error(J(156, pe.tag));
  };
  function sv(ie, pe) {
    return _i(ie, pe);
  }
  function uv(ie, pe, nt, pt) {
    this.tag = ie, this.key = nt, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = pe, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = pt, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function os(ie, pe, nt, pt) {
    return new uv(ie, pe, nt, pt);
  }
  function Gp(ie) {
    return ie = ie.prototype, !(!ie || !ie.isReactComponent);
  }
  function mm(ie) {
    if (typeof ie == "function") return Gp(ie) ? 1 : 0;
    if (ie != null) {
      if (ie = ie.$$typeof, ie === ct) return 11;
      if (ie === ut) return 14;
    }
    return 2;
  }
  function Du(ie, pe) {
    var nt = ie.alternate;
    return nt === null ? (nt = os(ie.tag, pe, ie.key, ie.mode), nt.elementType = ie.elementType, nt.type = ie.type, nt.stateNode = ie.stateNode, nt.alternate = ie, ie.alternate = nt) : (nt.pendingProps = pe, nt.type = ie.type, nt.flags = 0, nt.subtreeFlags = 0, nt.deletions = null), nt.flags = ie.flags & 14680064, nt.childLanes = ie.childLanes, nt.lanes = ie.lanes, nt.child = ie.child, nt.memoizedProps = ie.memoizedProps, nt.memoizedState = ie.memoizedState, nt.updateQueue = ie.updateQueue, pe = ie.dependencies, nt.dependencies = pe === null ? null : { lanes: pe.lanes, firstContext: pe.firstContext }, nt.sibling = ie.sibling, nt.index = ie.index, nt.ref = ie.ref, nt;
  }
  function uh(ie, pe, nt, pt, Tt, Pt) {
    var Yt = 2;
    if (pt = ie, typeof ie == "function") Gp(ie) && (Yt = 1);
    else if (typeof ie == "string") Yt = 5;
    else e: switch (ie) {
      case yr:
        return _f(nt.children, Tt, Pt, pe);
      case jt:
        Yt = 8, Tt |= 8;
        break;
      case Ut:
        return ie = os(12, nt, pe, Tt | 2), ie.elementType = Ut, ie.lanes = Pt, ie;
      case dt:
        return ie = os(13, nt, pe, Tt), ie.elementType = dt, ie.lanes = Pt, ie;
      case ot:
        return ie = os(19, nt, pe, Tt), ie.elementType = ot, ie.lanes = Pt, ie;
      case gt:
        return fh(nt, Tt, Pt, pe);
      default:
        if (typeof ie == "object" && ie !== null) switch (ie.$$typeof) {
          case er:
            Yt = 10;
            break e;
          case Ht:
            Yt = 9;
            break e;
          case ct:
            Yt = 11;
            break e;
          case ut:
            Yt = 14;
            break e;
          case mt:
            Yt = 16, pt = null;
            break e;
        }
        throw Error(J(130, ie == null ? ie : typeof ie, ""));
    }
    return pe = os(Yt, nt, pe, Tt), pe.elementType = ie, pe.type = pt, pe.lanes = Pt, pe;
  }
  function _f(ie, pe, nt, pt) {
    return ie = os(7, ie, pt, pe), ie.lanes = nt, ie;
  }
  function fh(ie, pe, nt, pt) {
    return ie = os(22, ie, pt, pe), ie.elementType = gt, ie.lanes = nt, ie.stateNode = { isHidden: !1 }, ie;
  }
  function lh(ie, pe, nt) {
    return ie = os(6, ie, null, pe), ie.lanes = nt, ie;
  }
  function Bc(ie, pe, nt) {
    return pe = os(4, ie.children !== null ? ie.children : [], ie.key, pe), pe.lanes = nt, pe.stateNode = { containerInfo: ie.containerInfo, pendingChildren: null, implementation: ie.implementation }, pe;
  }
  function kc(ie, pe, nt, pt, Tt) {
    this.tag = pe, this.containerInfo = ie, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Df(0), this.expirationTimes = Df(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Df(0), this.identifierPrefix = pt, this.onRecoverableError = Tt, this.mutableSourceEagerHydrationData = null;
  }
  function Xp(ie, pe, nt, pt, Tt, Pt, Yt, cr, wr) {
    return ie = new kc(ie, pe, nt, cr, wr), pe === 1 ? (pe = 1, Pt === !0 && (pe |= 8)) : pe = 0, Pt = os(3, null, null, pe), ie.current = Pt, Pt.stateNode = ie, Pt.memoizedState = { element: pt, isDehydrated: nt, cache: null, transitions: null, pendingSuspenseBoundaries: null }, _d(Pt), ie;
  }
  function fv(ie, pe, nt) {
    var pt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Vt, key: pt == null ? null : "" + pt, children: ie, containerInfo: pe, implementation: nt };
  }
  function Yp(ie) {
    if (!ie) return xs;
    ie = ie._reactInternals;
    e: {
      if (sn(ie) !== ie || ie.tag !== 1) throw Error(J(170));
      var pe = ie;
      do {
        switch (pe.tag) {
          case 3:
            pe = pe.stateNode.context;
            break e;
          case 1:
            if (Zi(pe.type)) {
              pe = pe.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        pe = pe.return;
      } while (pe !== null);
      throw Error(J(171));
    }
    if (ie.tag === 1) {
      var nt = ie.type;
      if (Zi(nt)) return cc(ie, nt, pe);
    }
    return pe;
  }
  function Jp(ie, pe, nt, pt, Tt, Pt, Yt, cr, wr) {
    return ie = Xp(nt, pt, !0, ie, Tt, Pt, Yt, cr, wr), ie.context = Yp(null), nt = ie.current, pt = Ia(), Tt = tu(nt), Pt = Eo(pt, Tt), Pt.callback = pe ?? null, Bu(nt, Pt, Tt), ie.current.lanes = Tt, Us(ie, Tt, pt), Ta(ie, pt), ie;
  }
  function hh(ie, pe, nt, pt) {
    var Tt = pe.current, Pt = Ia(), Yt = tu(Tt);
    return nt = Yp(nt), pe.context === null ? pe.context = nt : pe.pendingContext = nt, pe = Eo(Pt, Yt), pe.payload = { element: ie }, pt = pt === void 0 ? null : pt, pt !== null && (pe.callback = pt), ie = Bu(Tt, pe, Yt), ie !== null && (aa(ie, Tt, Yt, Pt), Sd(ie, Tt, Yt)), Yt;
  }
  function Mc(ie) {
    if (ie = ie.current, !ie.child) return null;
    switch (ie.child.tag) {
      case 5:
        return ie.child.stateNode;
      default:
        return ie.child.stateNode;
    }
  }
  function lv(ie, pe) {
    if (ie = ie.memoizedState, ie !== null && ie.dehydrated !== null) {
      var nt = ie.retryLane;
      ie.retryLane = nt !== 0 && nt < pe ? nt : pe;
    }
  }
  function Qp(ie, pe) {
    lv(ie, pe), (ie = ie.alternate) && lv(ie, pe);
  }
  function gm() {
    return null;
  }
  var Zp = typeof reportError == "function" ? reportError : function(ie) {
    console.error(ie);
  };
  function ph(ie) {
    this._internalRoot = ie;
  }
  Oc.prototype.render = ph.prototype.render = function(ie) {
    var pe = this._internalRoot;
    if (pe === null) throw Error(J(409));
    hh(ie, pe, null, null);
  }, Oc.prototype.unmount = ph.prototype.unmount = function() {
    var ie = this._internalRoot;
    if (ie !== null) {
      this._internalRoot = null;
      var pe = ie.containerInfo;
      Bs(function() {
        hh(null, ie, null, null);
      }), pe[Gs] = null;
    }
  };
  function Oc(ie) {
    this._internalRoot = ie;
  }
  Oc.prototype.unstable_scheduleHydration = function(ie) {
    if (ie) {
      var pe = Uf();
      ie = { blockedOn: null, target: ie, priority: pe };
      for (var nt = 0; nt < Ii.length && pe !== 0 && pe < Ii[nt].priority; nt++) ;
      Ii.splice(nt, 0, ie), nt === 0 && td(ie);
    }
  };
  function Nu(ie) {
    return !(!ie || ie.nodeType !== 1 && ie.nodeType !== 9 && ie.nodeType !== 11);
  }
  function vh(ie) {
    return !(!ie || ie.nodeType !== 1 && ie.nodeType !== 9 && ie.nodeType !== 11 && (ie.nodeType !== 8 || ie.nodeValue !== " react-mount-point-unstable "));
  }
  function cv() {
  }
  function bm(ie, pe, nt, pt, Tt) {
    if (Tt) {
      if (typeof pt == "function") {
        var Pt = pt;
        pt = function() {
          var Lr = Mc(Yt);
          Pt.call(Lr);
        };
      }
      var Yt = Jp(pe, pt, ie, 0, null, !1, !1, "", cv);
      return ie._reactRootContainer = Yt, ie[Gs] = Yt.current, Xf(ie.nodeType === 8 ? ie.parentNode : ie), Bs(), Yt;
    }
    for (; Tt = ie.lastChild; ) ie.removeChild(Tt);
    if (typeof pt == "function") {
      var cr = pt;
      pt = function() {
        var Lr = Mc(wr);
        cr.call(Lr);
      };
    }
    var wr = Xp(ie, 0, !1, null, null, !1, !1, "", cv);
    return ie._reactRootContainer = wr, ie[Gs] = wr.current, Xf(ie.nodeType === 8 ? ie.parentNode : ie), Bs(function() {
      hh(pe, wr, nt, pt);
    }), wr;
  }
  function yh(ie, pe, nt, pt, Tt) {
    var Pt = nt._reactRootContainer;
    if (Pt) {
      var Yt = Pt;
      if (typeof Tt == "function") {
        var cr = Tt;
        Tt = function() {
          var wr = Mc(Yt);
          cr.call(wr);
        };
      }
      hh(pe, Yt, ie, Tt);
    } else Yt = bm(nt, pe, ie, Tt, pt);
    return Mc(Yt);
  }
  Gu = function(ie) {
    switch (ie.tag) {
      case 3:
        var pe = ie.stateNode;
        if (pe.current.memoizedState.isDehydrated) {
          var nt = ds(pe.pendingLanes);
          nt !== 0 && (Ss(pe, nt | 1), Ta(pe, vi()), !(bi & 6) && ($l = vi() + 500, bo()));
        }
        break;
      case 13:
        Bs(function() {
          var pt = Js(ie, 1);
          if (pt !== null) {
            var Tt = Ia();
            aa(pt, ie, 1, Tt);
          }
        }), Qp(ie, 1);
    }
  }, Lf = function(ie) {
    if (ie.tag === 13) {
      var pe = Js(ie, 134217728);
      if (pe !== null) {
        var nt = Ia();
        aa(pe, ie, 134217728, nt);
      }
      Qp(ie, 134217728);
    }
  }, Si = function(ie) {
    if (ie.tag === 13) {
      var pe = tu(ie), nt = Js(ie, pe);
      if (nt !== null) {
        var pt = Ia();
        aa(nt, ie, pe, pt);
      }
      Qp(ie, pe);
    }
  }, Uf = function() {
    return Ci;
  }, Ff = function(ie, pe) {
    var nt = Ci;
    try {
      return Ci = ie, pe();
    } finally {
      Ci = nt;
    }
  }, In = function(ie, pe, nt) {
    switch (pe) {
      case "input":
        if (ln(ie, nt), pe = nt.name, nt.type === "radio" && pe != null) {
          for (nt = ie; nt.parentNode; ) nt = nt.parentNode;
          for (nt = nt.querySelectorAll("input[name=" + JSON.stringify("" + pe) + '][type="radio"]'), pe = 0; pe < nt.length; pe++) {
            var pt = nt[pe];
            if (pt !== ie && pt.form === ie.form) {
              var Tt = Xn(pt);
              if (!Tt) throw Error(J(90));
              Qt(pt), ln(pt, Tt);
            }
          }
        }
        break;
      case "textarea":
        En(ie, nt);
        break;
      case "select":
        pe = nt.value, pe != null && xn(ie, !!nt.multiple, pe, !1);
    }
  }, ir = Kp, lr = Bs;
  var wm = { usingClientEntryPoint: !1, Events: [lc, Yf, Xn, pi, ur, Kp] }, Pc = { findFiberByHostInstance: Go, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, dv = { bundleType: Pc.bundleType, version: Pc.version, rendererPackageName: Pc.rendererPackageName, rendererConfig: Pc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ft.ReactCurrentDispatcher, findHostInstanceByFiber: function(ie) {
    return ie = Jn(ie), ie === null ? null : ie.stateNode;
  }, findFiberByHostInstance: Pc.findFiberByHostInstance || gm, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var mh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!mh.isDisabled && mh.supportsFiber) try {
      Xa = mh.inject(dv), sa = mh;
    } catch {
    }
  }
  return reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = wm, reactDom_production_min.createPortal = function(ie, pe) {
    var nt = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Nu(pe)) throw Error(J(200));
    return fv(ie, pe, null, nt);
  }, reactDom_production_min.createRoot = function(ie, pe) {
    if (!Nu(ie)) throw Error(J(299));
    var nt = !1, pt = "", Tt = Zp;
    return pe != null && (pe.unstable_strictMode === !0 && (nt = !0), pe.identifierPrefix !== void 0 && (pt = pe.identifierPrefix), pe.onRecoverableError !== void 0 && (Tt = pe.onRecoverableError)), pe = Xp(ie, 1, !1, null, null, nt, !1, pt, Tt), ie[Gs] = pe.current, Xf(ie.nodeType === 8 ? ie.parentNode : ie), new ph(pe);
  }, reactDom_production_min.findDOMNode = function(ie) {
    if (ie == null) return null;
    if (ie.nodeType === 1) return ie;
    var pe = ie._reactInternals;
    if (pe === void 0)
      throw typeof ie.render == "function" ? Error(J(188)) : (ie = Object.keys(ie).join(","), Error(J(268, ie)));
    return ie = Jn(pe), ie = ie === null ? null : ie.stateNode, ie;
  }, reactDom_production_min.flushSync = function(ie) {
    return Bs(ie);
  }, reactDom_production_min.hydrate = function(ie, pe, nt) {
    if (!vh(pe)) throw Error(J(200));
    return yh(null, ie, pe, !0, nt);
  }, reactDom_production_min.hydrateRoot = function(ie, pe, nt) {
    if (!Nu(ie)) throw Error(J(405));
    var pt = nt != null && nt.hydratedSources || null, Tt = !1, Pt = "", Yt = Zp;
    if (nt != null && (nt.unstable_strictMode === !0 && (Tt = !0), nt.identifierPrefix !== void 0 && (Pt = nt.identifierPrefix), nt.onRecoverableError !== void 0 && (Yt = nt.onRecoverableError)), pe = Jp(pe, null, ie, 1, nt ?? null, Tt, !1, Pt, Yt), ie[Gs] = pe.current, Xf(ie), pt) for (ie = 0; ie < pt.length; ie++) nt = pt[ie], Tt = nt._getVersion, Tt = Tt(nt._source), pe.mutableSourceEagerHydrationData == null ? pe.mutableSourceEagerHydrationData = [nt, Tt] : pe.mutableSourceEagerHydrationData.push(
      nt,
      Tt
    );
    return new Oc(pe);
  }, reactDom_production_min.render = function(ie, pe, nt) {
    if (!vh(pe)) throw Error(J(200));
    return yh(null, ie, pe, !1, nt);
  }, reactDom_production_min.unmountComponentAtNode = function(ie) {
    if (!vh(ie)) throw Error(J(40));
    return ie._reactRootContainer ? (Bs(function() {
      yh(null, null, ie, !1, function() {
        ie._reactRootContainer = null, ie[Gs] = null;
      });
    }), !0) : !1;
  }, reactDom_production_min.unstable_batchedUpdates = Kp, reactDom_production_min.unstable_renderSubtreeIntoContainer = function(ie, pe, nt, pt) {
    if (!vh(nt)) throw Error(J(200));
    if (ie == null || ie._reactInternals === void 0) throw Error(J(38));
    return yh(ie, pe, nt, !1, pt);
  }, reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426", reactDom_production_min;
}
var reactDom_development = {}, hasRequiredReactDom_development;
function requireReactDom_development() {
  return hasRequiredReactDom_development || (hasRequiredReactDom_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var B = reactExports, L = requireScheduler(), J = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ne = !1;
    function oe(V) {
      ne = V;
    }
    function ce(V) {
      if (!ne) {
        for (var re = arguments.length, ke = new Array(re > 1 ? re - 1 : 0), Oe = 1; Oe < re; Oe++)
          ke[Oe - 1] = arguments[Oe];
        rt("warn", V, ke);
      }
    }
    function Ce(V) {
      if (!ne) {
        for (var re = arguments.length, ke = new Array(re > 1 ? re - 1 : 0), Oe = 1; Oe < re; Oe++)
          ke[Oe - 1] = arguments[Oe];
        rt("error", V, ke);
      }
    }
    function rt(V, re, ke) {
      {
        var Oe = J.ReactDebugCurrentFrame, st = Oe.getStackAddendum();
        st !== "" && (re += "%s", ke = ke.concat([st]));
        var bt = ke.map(function(Ct) {
          return String(Ct);
        });
        bt.unshift("Warning: " + re), Function.prototype.apply.call(console[V], console, bt);
      }
    }
    var at = 0, ht = 1, it = 2, lt = 3, Et = 4, wt = 5, Rt = 6, Mt = 7, Lt = 8, zt = 9, Ot = 10, It = 11, Ft = 12, Jt = 13, Vt = 14, yr = 15, jt = 16, Ut = 17, er = 18, Ht = 19, ct = 21, dt = 22, ot = 23, ut = 24, mt = 25, gt = !0, St = !1, xt = !1, vt = !1, $t = !1, yt = !0, Bt = !1, rr = !0, dr = !0, tr = !0, Dt = !0, Wt = /* @__PURE__ */ new Set(), or = {}, _r = {};
    function Xt(V, re) {
      Qt(V, re), Qt(V + "Capture", re);
    }
    function Qt(V, re) {
      or[V] && Ce("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", V), or[V] = re;
      {
        var ke = V.toLowerCase();
        _r[ke] = V, V === "onDoubleClick" && (_r.ondblclick = V);
      }
      for (var Oe = 0; Oe < re.length; Oe++)
        Wt.add(re[Oe]);
    }
    var br = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Dr = Object.prototype.hasOwnProperty;
    function Vr(V) {
      {
        var re = typeof Symbol == "function" && Symbol.toStringTag, ke = re && V[Symbol.toStringTag] || V.constructor.name || "Object";
        return ke;
      }
    }
    function Zr(V) {
      try {
        return ln(V), !1;
      } catch {
        return !0;
      }
    }
    function ln(V) {
      return "" + V;
    }
    function _n(V, re) {
      if (Zr(V))
        return Ce("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", re, Vr(V)), ln(V);
    }
    function Mr(V) {
      if (Zr(V))
        return Ce("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Vr(V)), ln(V);
    }
    function Wn(V, re) {
      if (Zr(V))
        return Ce("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", re, Vr(V)), ln(V);
    }
    function xn(V, re) {
      if (Zr(V))
        return Ce("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", re, Vr(V)), ln(V);
    }
    function ni(V) {
      if (Zr(V))
        return Ce("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Vr(V)), ln(V);
    }
    function Gn(V) {
      if (Zr(V))
        return Ce("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Vr(V)), ln(V);
    }
    var En = 0, Pn = 1, ti = 2, gn = 3, Kn = 4, gi = 5, Gt = 6, At = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", kt = At + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Zt = new RegExp("^[" + At + "][" + kt + "]*$"), pr = {}, Sr = {};
    function Tr(V) {
      return Dr.call(Sr, V) ? !0 : Dr.call(pr, V) ? !1 : Zt.test(V) ? (Sr[V] = !0, !0) : (pr[V] = !0, Ce("Invalid attribute name: `%s`", V), !1);
    }
    function fn(V, re, ke) {
      return re !== null ? re.type === En : ke ? !1 : V.length > 2 && (V[0] === "o" || V[0] === "O") && (V[1] === "n" || V[1] === "N");
    }
    function On(V, re, ke, Oe) {
      if (ke !== null && ke.type === En)
        return !1;
      switch (typeof re) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (Oe)
            return !1;
          if (ke !== null)
            return !ke.acceptsBooleans;
          var st = V.toLowerCase().slice(0, 5);
          return st !== "data-" && st !== "aria-";
        }
        default:
          return !1;
      }
    }
    function tn(V, re, ke, Oe) {
      if (re === null || typeof re > "u" || On(V, re, ke, Oe))
        return !0;
      if (Oe)
        return !1;
      if (ke !== null)
        switch (ke.type) {
          case gn:
            return !re;
          case Kn:
            return re === !1;
          case gi:
            return isNaN(re);
          case Gt:
            return isNaN(re) || re < 1;
        }
      return !1;
    }
    function In(V) {
      return cn.hasOwnProperty(V) ? cn[V] : null;
    }
    function hn(V, re, ke, Oe, st, bt, Ct) {
      this.acceptsBooleans = re === ti || re === gn || re === Kn, this.attributeName = Oe, this.attributeNamespace = st, this.mustUseProperty = ke, this.propertyName = V, this.type = re, this.sanitizeURL = bt, this.removeEmptyString = Ct;
    }
    var cn = {}, ci = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ci.forEach(function(V) {
      cn[V] = new hn(
        V,
        En,
        !1,
        // mustUseProperty
        V,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(V) {
      var re = V[0], ke = V[1];
      cn[re] = new hn(
        re,
        Pn,
        !1,
        // mustUseProperty
        ke,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(V) {
      cn[V] = new hn(
        V,
        ti,
        !1,
        // mustUseProperty
        V.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(V) {
      cn[V] = new hn(
        V,
        ti,
        !1,
        // mustUseProperty
        V,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(V) {
      cn[V] = new hn(
        V,
        gn,
        !1,
        // mustUseProperty
        V.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(V) {
      cn[V] = new hn(
        V,
        gn,
        !0,
        // mustUseProperty
        V,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(V) {
      cn[V] = new hn(
        V,
        Kn,
        !1,
        // mustUseProperty
        V,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(V) {
      cn[V] = new hn(
        V,
        Gt,
        !1,
        // mustUseProperty
        V,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(V) {
      cn[V] = new hn(
        V,
        gi,
        !1,
        // mustUseProperty
        V.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var pi = /[\-\:]([a-z])/g, ur = function(V) {
      return V[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(V) {
      var re = V.replace(pi, ur);
      cn[re] = new hn(
        re,
        Pn,
        !1,
        // mustUseProperty
        V,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(V) {
      var re = V.replace(pi, ur);
      cn[re] = new hn(
        re,
        Pn,
        !1,
        // mustUseProperty
        V,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(V) {
      var re = V.replace(pi, ur);
      cn[re] = new hn(
        re,
        Pn,
        !1,
        // mustUseProperty
        V,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(V) {
      cn[V] = new hn(
        V,
        Pn,
        !1,
        // mustUseProperty
        V.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ir = "xlinkHref";
    cn[ir] = new hn(
      "xlinkHref",
      Pn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(V) {
      cn[V] = new hn(
        V,
        Pn,
        !1,
        // mustUseProperty
        V.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var lr = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, gr = !1;
    function Ar(V) {
      !gr && lr.test(V) && (gr = !0, Ce("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(V)));
    }
    function Fr(V, re, ke, Oe) {
      if (Oe.mustUseProperty) {
        var st = Oe.propertyName;
        return V[st];
      } else {
        _n(ke, re), Oe.sanitizeURL && Ar("" + ke);
        var bt = Oe.attributeName, Ct = null;
        if (Oe.type === Kn) {
          if (V.hasAttribute(bt)) {
            var Nt = V.getAttribute(bt);
            return Nt === "" ? !0 : tn(re, ke, Oe, !1) ? Nt : Nt === "" + ke ? ke : Nt;
          }
        } else if (V.hasAttribute(bt)) {
          if (tn(re, ke, Oe, !1))
            return V.getAttribute(bt);
          if (Oe.type === gn)
            return ke;
          Ct = V.getAttribute(bt);
        }
        return tn(re, ke, Oe, !1) ? Ct === null ? ke : Ct : Ct === "" + ke ? ke : Ct;
      }
    }
    function jr(V, re, ke, Oe) {
      {
        if (!Tr(re))
          return;
        if (!V.hasAttribute(re))
          return ke === void 0 ? void 0 : null;
        var st = V.getAttribute(re);
        return _n(ke, re), st === "" + ke ? ke : st;
      }
    }
    function Xr(V, re, ke, Oe) {
      var st = In(re);
      if (!fn(re, st, Oe)) {
        if (tn(re, ke, st, Oe) && (ke = null), Oe || st === null) {
          if (Tr(re)) {
            var bt = re;
            ke === null ? V.removeAttribute(bt) : (_n(ke, re), V.setAttribute(bt, "" + ke));
          }
          return;
        }
        var Ct = st.mustUseProperty;
        if (Ct) {
          var Nt = st.propertyName;
          if (ke === null) {
            var qt = st.type;
            V[Nt] = qt === gn ? !1 : "";
          } else
            V[Nt] = ke;
          return;
        }
        var nr = st.attributeName, ar = st.attributeNamespace;
        if (ke === null)
          V.removeAttribute(nr);
        else {
          var xr = st.type, Er;
          xr === gn || xr === Kn && ke === !0 ? Er = "" : (_n(ke, nr), Er = "" + ke, st.sanitizeURL && Ar(Er.toString())), ar ? V.setAttributeNS(ar, nr, Er) : V.setAttribute(nr, Er);
        }
      }
    }
    var pn = Symbol.for("react.element"), Yr = Symbol.for("react.portal"), vn = Symbol.for("react.fragment"), Cn = Symbol.for("react.strict_mode"), dn = Symbol.for("react.profiler"), fr = Symbol.for("react.provider"), Nr = Symbol.for("react.context"), Ir = Symbol.for("react.forward_ref"), sn = Symbol.for("react.suspense"), Tn = Symbol.for("react.suspense_list"), kn = Symbol.for("react.memo"), Dn = Symbol.for("react.lazy"), Jn = Symbol.for("react.scope"), Ti = Symbol.for("react.debug_trace_mode"), _i = Symbol.for("react.offscreen"), Ri = Symbol.for("react.legacy_hidden"), Qi = Symbol.for("react.cache"), Ca = Symbol.for("react.tracing_marker"), vi = Symbol.iterator, Wi = "@@iterator";
    function ra(V) {
      if (V === null || typeof V != "object")
        return null;
      var re = vi && V[vi] || V[Wi];
      return typeof re == "function" ? re : null;
    }
    var ii = Object.assign, ma = 0, Ga, po, Xa, sa, Oo, Sa, Ls;
    function Gl() {
    }
    Gl.__reactDisabledLog = !0;
    function Zc() {
      {
        if (ma === 0) {
          Ga = console.log, po = console.info, Xa = console.warn, sa = console.error, Oo = console.group, Sa = console.groupCollapsed, Ls = console.groupEnd;
          var V = {
            configurable: !0,
            enumerable: !0,
            value: Gl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: V,
            log: V,
            warn: V,
            error: V,
            group: V,
            groupCollapsed: V,
            groupEnd: V
          });
        }
        ma++;
      }
    }
    function Pf() {
      {
        if (ma--, ma === 0) {
          var V = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ii({}, V, {
              value: Ga
            }),
            info: ii({}, V, {
              value: po
            }),
            warn: ii({}, V, {
              value: Xa
            }),
            error: ii({}, V, {
              value: sa
            }),
            group: ii({}, V, {
              value: Oo
            }),
            groupCollapsed: ii({}, V, {
              value: Sa
            }),
            groupEnd: ii({}, V, {
              value: Ls
            })
          });
        }
        ma < 0 && Ce("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var pu = J.ReactCurrentDispatcher, ds;
    function to(V, re, ke) {
      {
        if (ds === void 0)
          try {
            throw Error();
          } catch (st) {
            var Oe = st.stack.trim().match(/\n( *(at )?)/);
            ds = Oe && Oe[1] || "";
          }
        return `
` + ds + V;
      }
    }
    var vu = !1, yu;
    {
      var mu = typeof WeakMap == "function" ? WeakMap : Map;
      yu = new mu();
    }
    function If(V, re) {
      if (!V || vu)
        return "";
      {
        var ke = yu.get(V);
        if (ke !== void 0)
          return ke;
      }
      var Oe;
      vu = !0;
      var st = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var bt;
      bt = pu.current, pu.current = null, Zc();
      try {
        if (re) {
          var Ct = function() {
            throw Error();
          };
          if (Object.defineProperty(Ct.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ct, []);
            } catch (Ur) {
              Oe = Ur;
            }
            Reflect.construct(V, [], Ct);
          } else {
            try {
              Ct.call();
            } catch (Ur) {
              Oe = Ur;
            }
            V.call(Ct.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ur) {
            Oe = Ur;
          }
          V();
        }
      } catch (Ur) {
        if (Ur && Oe && typeof Ur.stack == "string") {
          for (var Nt = Ur.stack.split(`
`), qt = Oe.stack.split(`
`), nr = Nt.length - 1, ar = qt.length - 1; nr >= 1 && ar >= 0 && Nt[nr] !== qt[ar]; )
            ar--;
          for (; nr >= 1 && ar >= 0; nr--, ar--)
            if (Nt[nr] !== qt[ar]) {
              if (nr !== 1 || ar !== 1)
                do
                  if (nr--, ar--, ar < 0 || Nt[nr] !== qt[ar]) {
                    var xr = `
` + Nt[nr].replace(" at new ", " at ");
                    return V.displayName && xr.includes("<anonymous>") && (xr = xr.replace("<anonymous>", V.displayName)), typeof V == "function" && yu.set(V, xr), xr;
                  }
                while (nr >= 1 && ar >= 0);
              break;
            }
        }
      } finally {
        vu = !1, pu.current = bt, Pf(), Error.prepareStackTrace = st;
      }
      var Er = V ? V.displayName || V.name : "", Or = Er ? to(Er) : "";
      return typeof V == "function" && yu.set(V, Or), Or;
    }
    function Df(V, re, ke) {
      return If(V, !0);
    }
    function Us(V, re, ke) {
      return If(V, !1);
    }
    function Yh(V) {
      var re = V.prototype;
      return !!(re && re.isReactComponent);
    }
    function Ss(V, re, ke) {
      if (V == null)
        return "";
      if (typeof V == "function")
        return If(V, Yh(V));
      if (typeof V == "string")
        return to(V);
      switch (V) {
        case sn:
          return to("Suspense");
        case Tn:
          return to("SuspenseList");
      }
      if (typeof V == "object")
        switch (V.$$typeof) {
          case Ir:
            return Us(V.render);
          case kn:
            return Ss(V.type, re, ke);
          case Dn: {
            var Oe = V, st = Oe._payload, bt = Oe._init;
            try {
              return Ss(bt(st), re, ke);
            } catch {
            }
          }
        }
      return "";
    }
    function Ci(V) {
      switch (V._debugOwner && V._debugOwner.type, V._debugSource, V.tag) {
        case wt:
          return to(V.type);
        case jt:
          return to("Lazy");
        case Jt:
          return to("Suspense");
        case Ht:
          return to("SuspenseList");
        case at:
        case it:
        case yr:
          return Us(V.type);
        case It:
          return Us(V.type.render);
        case ht:
          return Df(V.type);
        default:
          return "";
      }
    }
    function Nf(V) {
      try {
        var re = "", ke = V;
        do
          re += Ci(ke), ke = ke.return;
        while (ke);
        return re;
      } catch (Oe) {
        return `
Error generating stack: ` + Oe.message + `
` + Oe.stack;
      }
    }
    function Gu(V, re, ke) {
      var Oe = V.displayName;
      if (Oe)
        return Oe;
      var st = re.displayName || re.name || "";
      return st !== "" ? ke + "(" + st + ")" : ke;
    }
    function Lf(V) {
      return V.displayName || "Context";
    }
    function Si(V) {
      if (V == null)
        return null;
      if (typeof V.tag == "number" && Ce("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof V == "function")
        return V.displayName || V.name || null;
      if (typeof V == "string")
        return V;
      switch (V) {
        case vn:
          return "Fragment";
        case Yr:
          return "Portal";
        case dn:
          return "Profiler";
        case Cn:
          return "StrictMode";
        case sn:
          return "Suspense";
        case Tn:
          return "SuspenseList";
      }
      if (typeof V == "object")
        switch (V.$$typeof) {
          case Nr:
            var re = V;
            return Lf(re) + ".Consumer";
          case fr:
            var ke = V;
            return Lf(ke._context) + ".Provider";
          case Ir:
            return Gu(V, V.render, "ForwardRef");
          case kn:
            var Oe = V.displayName || null;
            return Oe !== null ? Oe : Si(V.type) || "Memo";
          case Dn: {
            var st = V, bt = st._payload, Ct = st._init;
            try {
              return Si(Ct(bt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Uf(V, re, ke) {
      var Oe = re.displayName || re.name || "";
      return V.displayName || (Oe !== "" ? ke + "(" + Oe + ")" : ke);
    }
    function Ff(V) {
      return V.displayName || "Context";
    }
    function ui(V) {
      var re = V.tag, ke = V.type;
      switch (re) {
        case ut:
          return "Cache";
        case zt:
          var Oe = ke;
          return Ff(Oe) + ".Consumer";
        case Ot:
          var st = ke;
          return Ff(st._context) + ".Provider";
        case er:
          return "DehydratedFragment";
        case It:
          return Uf(ke, ke.render, "ForwardRef");
        case Mt:
          return "Fragment";
        case wt:
          return ke;
        case Et:
          return "Portal";
        case lt:
          return "Root";
        case Rt:
          return "Text";
        case jt:
          return Si(ke);
        case Lt:
          return ke === Cn ? "StrictMode" : "Mode";
        case dt:
          return "Offscreen";
        case Ft:
          return "Profiler";
        case ct:
          return "Scope";
        case Jt:
          return "Suspense";
        case Ht:
          return "SuspenseList";
        case mt:
          return "TracingMarker";
        case ht:
        case at:
        case Ut:
        case it:
        case Vt:
        case yr:
          if (typeof ke == "function")
            return ke.displayName || ke.name || null;
          if (typeof ke == "string")
            return ke;
          break;
      }
      return null;
    }
    var Xu = J.ReactDebugCurrentFrame, na = null, vo = !1;
    function ro() {
      {
        if (na === null)
          return null;
        var V = na._debugOwner;
        if (V !== null && typeof V < "u")
          return ui(V);
      }
      return null;
    }
    function gu() {
      return na === null ? "" : Nf(na);
    }
    function ua() {
      Xu.getCurrentStack = null, na = null, vo = !1;
    }
    function Ii(V) {
      Xu.getCurrentStack = V === null ? null : gu, na = V, vo = !1;
    }
    function ed() {
      return na;
    }
    function yo(V) {
      vo = V;
    }
    function Ba(V) {
      return "" + V;
    }
    function Es(V) {
      switch (typeof V) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return V;
        case "object":
          return Gn(V), V;
        default:
          return "";
      }
    }
    var td = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Fs(V, re) {
      td[re.type] || re.onChange || re.onInput || re.readOnly || re.disabled || re.value == null || Ce("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), re.onChange || re.readOnly || re.disabled || re.checked == null || Ce("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function bu(V) {
      var re = V.type, ke = V.nodeName;
      return ke && ke.toLowerCase() === "input" && (re === "checkbox" || re === "radio");
    }
    function rd(V) {
      return V._valueTracker;
    }
    function Wo(V) {
      V._valueTracker = null;
    }
    function wu(V) {
      var re = "";
      return V && (bu(V) ? re = V.checked ? "true" : "false" : re = V.value), re;
    }
    function Hs(V) {
      var re = bu(V) ? "checked" : "value", ke = Object.getOwnPropertyDescriptor(V.constructor.prototype, re);
      Gn(V[re]);
      var Oe = "" + V[re];
      if (!(V.hasOwnProperty(re) || typeof ke > "u" || typeof ke.get != "function" || typeof ke.set != "function")) {
        var st = ke.get, bt = ke.set;
        Object.defineProperty(V, re, {
          configurable: !0,
          get: function() {
            return st.call(this);
          },
          set: function(Nt) {
            Gn(Nt), Oe = "" + Nt, bt.call(this, Nt);
          }
        }), Object.defineProperty(V, re, {
          enumerable: ke.enumerable
        });
        var Ct = {
          getValue: function() {
            return Oe;
          },
          setValue: function(Nt) {
            Gn(Nt), Oe = "" + Nt;
          },
          stopTracking: function() {
            Wo(V), delete V[re];
          }
        };
        return Ct;
      }
    }
    function Ko(V) {
      rd(V) || (V._valueTracker = Hs(V));
    }
    function Hf(V) {
      if (!V)
        return !1;
      var re = rd(V);
      if (!re)
        return !0;
      var ke = re.getValue(), Oe = wu(V);
      return Oe !== ke ? (re.setValue(Oe), !0) : !1;
    }
    function _u(V) {
      if (V = V || (typeof document < "u" ? document : void 0), typeof V > "u")
        return null;
      try {
        return V.activeElement || V.body;
      } catch {
        return V.body;
      }
    }
    var Su = !1, Yu = !1, jf = !1, Xl = !1;
    function hs(V) {
      var re = V.type === "checkbox" || V.type === "radio";
      return re ? V.checked != null : V.value != null;
    }
    function Kt(V, re) {
      var ke = V, Oe = re.checked, st = ii({}, re, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: Oe ?? ke._wrapperState.initialChecked
      });
      return st;
    }
    function vr(V, re) {
      Fs("input", re), re.checked !== void 0 && re.defaultChecked !== void 0 && !Yu && (Ce("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ro() || "A component", re.type), Yu = !0), re.value !== void 0 && re.defaultValue !== void 0 && !Su && (Ce("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ro() || "A component", re.type), Su = !0);
      var ke = V, Oe = re.defaultValue == null ? "" : re.defaultValue;
      ke._wrapperState = {
        initialChecked: re.checked != null ? re.checked : re.defaultChecked,
        initialValue: Es(re.value != null ? re.value : Oe),
        controlled: hs(re)
      };
    }
    function Pr(V, re) {
      var ke = V, Oe = re.checked;
      Oe != null && Xr(ke, "checked", Oe, !1);
    }
    function Hr(V, re) {
      var ke = V;
      {
        var Oe = hs(re);
        !ke._wrapperState.controlled && Oe && !Xl && (Ce("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Xl = !0), ke._wrapperState.controlled && !Oe && !jf && (Ce("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), jf = !0);
      }
      Pr(V, re);
      var st = Es(re.value), bt = re.type;
      if (st != null)
        bt === "number" ? (st === 0 && ke.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        ke.value != st) && (ke.value = Ba(st)) : ke.value !== Ba(st) && (ke.value = Ba(st));
      else if (bt === "submit" || bt === "reset") {
        ke.removeAttribute("value");
        return;
      }
      re.hasOwnProperty("value") ? Qn(ke, re.type, st) : re.hasOwnProperty("defaultValue") && Qn(ke, re.type, Es(re.defaultValue)), re.checked == null && re.defaultChecked != null && (ke.defaultChecked = !!re.defaultChecked);
    }
    function an(V, re, ke) {
      var Oe = V;
      if (re.hasOwnProperty("value") || re.hasOwnProperty("defaultValue")) {
        var st = re.type, bt = st === "submit" || st === "reset";
        if (bt && (re.value === void 0 || re.value === null))
          return;
        var Ct = Ba(Oe._wrapperState.initialValue);
        ke || Ct !== Oe.value && (Oe.value = Ct), Oe.defaultValue = Ct;
      }
      var Nt = Oe.name;
      Nt !== "" && (Oe.name = ""), Oe.defaultChecked = !Oe.defaultChecked, Oe.defaultChecked = !!Oe._wrapperState.initialChecked, Nt !== "" && (Oe.name = Nt);
    }
    function Zn(V, re) {
      var ke = V;
      Hr(ke, re), wn(ke, re);
    }
    function wn(V, re) {
      var ke = re.name;
      if (re.type === "radio" && ke != null) {
        for (var Oe = V; Oe.parentNode; )
          Oe = Oe.parentNode;
        _n(ke, "name");
        for (var st = Oe.querySelectorAll("input[name=" + JSON.stringify("" + ke) + '][type="radio"]'), bt = 0; bt < st.length; bt++) {
          var Ct = st[bt];
          if (!(Ct === V || Ct.form !== V.form)) {
            var Nt = Cv(Ct);
            if (!Nt)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Hf(Ct), Hr(Ct, Nt);
          }
        }
      }
    }
    function Qn(V, re, ke) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (re !== "number" || _u(V.ownerDocument) !== V) && (ke == null ? V.defaultValue = Ba(V._wrapperState.initialValue) : V.defaultValue !== Ba(ke) && (V.defaultValue = Ba(ke)));
    }
    var yi = !1, Ai = !1, ji = !1;
    function Ui(V, re) {
      re.value == null && (typeof re.children == "object" && re.children !== null ? B.Children.forEach(re.children, function(ke) {
        ke != null && (typeof ke == "string" || typeof ke == "number" || Ai || (Ai = !0, Ce("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : re.dangerouslySetInnerHTML != null && (ji || (ji = !0, Ce("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), re.selected != null && !yi && (Ce("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), yi = !0);
    }
    function zi(V, re) {
      re.value != null && V.setAttribute("value", Ba(Es(re.value)));
    }
    var Ki = Array.isArray;
    function Ei(V) {
      return Ki(V);
    }
    var js;
    js = !1;
    function zf() {
      var V = ro();
      return V ? `

Check the render method of \`` + V + "`." : "";
    }
    var Yl = ["value", "defaultValue"];
    function Jh(V) {
      {
        Fs("select", V);
        for (var re = 0; re < Yl.length; re++) {
          var ke = Yl[re];
          if (V[ke] != null) {
            var Oe = Ei(V[ke]);
            V.multiple && !Oe ? Ce("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", ke, zf()) : !V.multiple && Oe && Ce("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", ke, zf());
          }
        }
      }
    }
    function ps(V, re, ke, Oe) {
      var st = V.options;
      if (re) {
        for (var bt = ke, Ct = {}, Nt = 0; Nt < bt.length; Nt++)
          Ct["$" + bt[Nt]] = !0;
        for (var qt = 0; qt < st.length; qt++) {
          var nr = Ct.hasOwnProperty("$" + st[qt].value);
          st[qt].selected !== nr && (st[qt].selected = nr), nr && Oe && (st[qt].defaultSelected = !0);
        }
      } else {
        for (var ar = Ba(Es(ke)), xr = null, Er = 0; Er < st.length; Er++) {
          if (st[Er].value === ar) {
            st[Er].selected = !0, Oe && (st[Er].defaultSelected = !0);
            return;
          }
          xr === null && !st[Er].disabled && (xr = st[Er]);
        }
        xr !== null && (xr.selected = !0);
      }
    }
    function Jl(V, re) {
      return ii({}, re, {
        value: void 0
      });
    }
    function Ql(V, re) {
      var ke = V;
      Jh(re), ke._wrapperState = {
        wasMultiple: !!re.multiple
      }, re.value !== void 0 && re.defaultValue !== void 0 && !js && (Ce("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), js = !0);
    }
    function Qh(V, re) {
      var ke = V;
      ke.multiple = !!re.multiple;
      var Oe = re.value;
      Oe != null ? ps(ke, !!re.multiple, Oe, !1) : re.defaultValue != null && ps(ke, !!re.multiple, re.defaultValue, !0);
    }
    function zy(V, re) {
      var ke = V, Oe = ke._wrapperState.wasMultiple;
      ke._wrapperState.wasMultiple = !!re.multiple;
      var st = re.value;
      st != null ? ps(ke, !!re.multiple, st, !1) : Oe !== !!re.multiple && (re.defaultValue != null ? ps(ke, !!re.multiple, re.defaultValue, !0) : ps(ke, !!re.multiple, re.multiple ? [] : "", !1));
    }
    function qy(V, re) {
      var ke = V, Oe = re.value;
      Oe != null && ps(ke, !!re.multiple, Oe, !1);
    }
    var Zh = !1;
    function ep(V, re) {
      var ke = V;
      if (re.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var Oe = ii({}, re, {
        value: void 0,
        defaultValue: void 0,
        children: Ba(ke._wrapperState.initialValue)
      });
      return Oe;
    }
    function Z0(V, re) {
      var ke = V;
      Fs("textarea", re), re.value !== void 0 && re.defaultValue !== void 0 && !Zh && (Ce("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", ro() || "A component"), Zh = !0);
      var Oe = re.value;
      if (Oe == null) {
        var st = re.children, bt = re.defaultValue;
        if (st != null) {
          Ce("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (bt != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Ei(st)) {
              if (st.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              st = st[0];
            }
            bt = st;
          }
        }
        bt == null && (bt = ""), Oe = bt;
      }
      ke._wrapperState = {
        initialValue: Es(Oe)
      };
    }
    function e1(V, re) {
      var ke = V, Oe = Es(re.value), st = Es(re.defaultValue);
      if (Oe != null) {
        var bt = Ba(Oe);
        bt !== ke.value && (ke.value = bt), re.defaultValue == null && ke.defaultValue !== bt && (ke.defaultValue = bt);
      }
      st != null && (ke.defaultValue = Ba(st));
    }
    function t1(V, re) {
      var ke = V, Oe = ke.textContent;
      Oe === ke._wrapperState.initialValue && Oe !== "" && Oe !== null && (ke.value = Oe);
    }
    function tp(V, re) {
      e1(V, re);
    }
    var zs = "http://www.w3.org/1999/xhtml", Wy = "http://www.w3.org/1998/Math/MathML", rp = "http://www.w3.org/2000/svg";
    function nd(V) {
      switch (V) {
        case "svg":
          return rp;
        case "math":
          return Wy;
        default:
          return zs;
      }
    }
    function np(V, re) {
      return V == null || V === zs ? nd(re) : V === rp && re === "foreignObject" ? zs : V;
    }
    var Ky = function(V) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(re, ke, Oe, st) {
        MSApp.execUnsafeLocalFunction(function() {
          return V(re, ke, Oe, st);
        });
      } : V;
    }, id, r1 = Ky(function(V, re) {
      if (V.namespaceURI === rp && !("innerHTML" in V)) {
        id = id || document.createElement("div"), id.innerHTML = "<svg>" + re.valueOf().toString() + "</svg>";
        for (var ke = id.firstChild; V.firstChild; )
          V.removeChild(V.firstChild);
        for (; ke.firstChild; )
          V.appendChild(ke.firstChild);
        return;
      }
      V.innerHTML = re;
    }), mo = 1, qs = 3, ga = 8, vs = 9, Ju = 11, ad = function(V, re) {
      if (re) {
        var ke = V.firstChild;
        if (ke && ke === V.lastChild && ke.nodeType === qs) {
          ke.nodeValue = re;
          return;
        }
      }
      V.textContent = re;
    }, n1 = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, qf = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function i1(V, re) {
      return V + re.charAt(0).toUpperCase() + re.substring(1);
    }
    var a1 = ["Webkit", "ms", "Moz", "O"];
    Object.keys(qf).forEach(function(V) {
      a1.forEach(function(re) {
        qf[i1(re, V)] = qf[V];
      });
    });
    function od(V, re, ke) {
      var Oe = re == null || typeof re == "boolean" || re === "";
      return Oe ? "" : !ke && typeof re == "number" && re !== 0 && !(qf.hasOwnProperty(V) && qf[V]) ? re + "px" : (xn(re, V), ("" + re).trim());
    }
    var Wf = /([A-Z])/g, Vy = /^ms-/;
    function Gy(V) {
      return V.replace(Wf, "-$1").toLowerCase().replace(Vy, "-ms-");
    }
    var o1 = function() {
    };
    {
      var s1 = /^(?:webkit|moz|o)[A-Z]/, u1 = /^-ms-/, Zl = /-(.)/g, Kf = /;\s*$/, Vf = {}, Gf = {}, f1 = !1, ip = !1, ap = function(V) {
        return V.replace(Zl, function(re, ke) {
          return ke.toUpperCase();
        });
      }, op = function(V) {
        Vf.hasOwnProperty(V) && Vf[V] || (Vf[V] = !0, Ce(
          "Unsupported style property %s. Did you mean %s?",
          V,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          ap(V.replace(u1, "ms-"))
        ));
      }, l1 = function(V) {
        Vf.hasOwnProperty(V) && Vf[V] || (Vf[V] = !0, Ce("Unsupported vendor-prefixed style property %s. Did you mean %s?", V, V.charAt(0).toUpperCase() + V.slice(1)));
      }, c1 = function(V, re) {
        Gf.hasOwnProperty(re) && Gf[re] || (Gf[re] = !0, Ce(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, V, re.replace(Kf, "")));
      }, d1 = function(V, re) {
        f1 || (f1 = !0, Ce("`NaN` is an invalid value for the `%s` css style property.", V));
      }, Xy = function(V, re) {
        ip || (ip = !0, Ce("`Infinity` is an invalid value for the `%s` css style property.", V));
      };
      o1 = function(V, re) {
        V.indexOf("-") > -1 ? op(V) : s1.test(V) ? l1(V) : Kf.test(re) && c1(V, re), typeof re == "number" && (isNaN(re) ? d1(V, re) : isFinite(re) || Xy(V, re));
      };
    }
    var Yy = o1;
    function Jy(V) {
      {
        var re = "", ke = "";
        for (var Oe in V)
          if (V.hasOwnProperty(Oe)) {
            var st = V[Oe];
            if (st != null) {
              var bt = Oe.indexOf("--") === 0;
              re += ke + (bt ? Oe : Gy(Oe)) + ":", re += od(Oe, st, bt), ke = ";";
            }
          }
        return re || null;
      }
    }
    function h1(V, re) {
      var ke = V.style;
      for (var Oe in re)
        if (re.hasOwnProperty(Oe)) {
          var st = Oe.indexOf("--") === 0;
          st || Yy(Oe, re[Oe]);
          var bt = od(Oe, re[Oe], st);
          Oe === "float" && (Oe = "cssFloat"), st ? ke.setProperty(Oe, bt) : ke[Oe] = bt;
        }
    }
    function Qy(V) {
      return V == null || typeof V == "boolean" || V === "";
    }
    function Vo(V) {
      var re = {};
      for (var ke in V)
        for (var Oe = n1[ke] || [ke], st = 0; st < Oe.length; st++)
          re[Oe[st]] = ke;
      return re;
    }
    function tc(V, re) {
      {
        if (!re)
          return;
        var ke = Vo(V), Oe = Vo(re), st = {};
        for (var bt in ke) {
          var Ct = ke[bt], Nt = Oe[bt];
          if (Nt && Ct !== Nt) {
            var qt = Ct + "," + Nt;
            if (st[qt])
              continue;
            st[qt] = !0, Ce("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Qy(V[Ct]) ? "Removing" : "Updating", Ct, Nt);
          }
        }
      }
    }
    var p1 = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, v1 = ii({
      menuitem: !0
    }, p1), y1 = "__html";
    function sd(V, re) {
      if (re) {
        if (v1[V] && (re.children != null || re.dangerouslySetInnerHTML != null))
          throw new Error(V + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (re.dangerouslySetInnerHTML != null) {
          if (re.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof re.dangerouslySetInnerHTML != "object" || !(y1 in re.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!re.suppressContentEditableWarning && re.contentEditable && re.children != null && Ce("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), re.style != null && typeof re.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Ws(V, re) {
      if (V.indexOf("-") === -1)
        return typeof re.is == "string";
      switch (V) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ud = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, m1 = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ys = {}, sp = new RegExp("^(aria)-[" + kt + "]*$"), rc = new RegExp("^(aria)[A-Z][" + kt + "]*$");
    function up(V, re) {
      {
        if (Dr.call(ys, re) && ys[re])
          return !0;
        if (rc.test(re)) {
          var ke = "aria-" + re.slice(4).toLowerCase(), Oe = m1.hasOwnProperty(ke) ? ke : null;
          if (Oe == null)
            return Ce("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", re), ys[re] = !0, !0;
          if (re !== Oe)
            return Ce("Invalid ARIA attribute `%s`. Did you mean `%s`?", re, Oe), ys[re] = !0, !0;
        }
        if (sp.test(re)) {
          var st = re.toLowerCase(), bt = m1.hasOwnProperty(st) ? st : null;
          if (bt == null)
            return ys[re] = !0, !1;
          if (re !== bt)
            return Ce("Unknown ARIA attribute `%s`. Did you mean `%s`?", re, bt), ys[re] = !0, !0;
        }
      }
      return !0;
    }
    function g1(V, re) {
      {
        var ke = [];
        for (var Oe in re) {
          var st = up(V, Oe);
          st || ke.push(Oe);
        }
        var bt = ke.map(function(Ct) {
          return "`" + Ct + "`";
        }).join(", ");
        ke.length === 1 ? Ce("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", bt, V) : ke.length > 1 && Ce("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", bt, V);
      }
    }
    function fd(V, re) {
      Ws(V, re) || g1(V, re);
    }
    var Qu = !1;
    function fp(V, re) {
      {
        if (V !== "input" && V !== "textarea" && V !== "select")
          return;
        re != null && re.value === null && !Qu && (Qu = !0, V === "select" && re.multiple ? Ce("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", V) : Ce("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", V));
      }
    }
    var lp = function() {
    };
    {
      var ka = {}, cp = /^on./, b1 = /^on[^A-Z]/, w1 = new RegExp("^(aria)-[" + kt + "]*$"), S1 = new RegExp("^(aria)[A-Z][" + kt + "]*$");
      lp = function(V, re, ke, Oe) {
        if (Dr.call(ka, re) && ka[re])
          return !0;
        var st = re.toLowerCase();
        if (st === "onfocusin" || st === "onfocusout")
          return Ce("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ka[re] = !0, !0;
        if (Oe != null) {
          var bt = Oe.registrationNameDependencies, Ct = Oe.possibleRegistrationNames;
          if (bt.hasOwnProperty(re))
            return !0;
          var Nt = Ct.hasOwnProperty(st) ? Ct[st] : null;
          if (Nt != null)
            return Ce("Invalid event handler property `%s`. Did you mean `%s`?", re, Nt), ka[re] = !0, !0;
          if (cp.test(re))
            return Ce("Unknown event handler property `%s`. It will be ignored.", re), ka[re] = !0, !0;
        } else if (cp.test(re))
          return b1.test(re) && Ce("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", re), ka[re] = !0, !0;
        if (w1.test(re) || S1.test(re))
          return !0;
        if (st === "innerhtml")
          return Ce("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ka[re] = !0, !0;
        if (st === "aria")
          return Ce("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ka[re] = !0, !0;
        if (st === "is" && ke !== null && ke !== void 0 && typeof ke != "string")
          return Ce("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof ke), ka[re] = !0, !0;
        if (typeof ke == "number" && isNaN(ke))
          return Ce("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", re), ka[re] = !0, !0;
        var qt = In(re), nr = qt !== null && qt.type === En;
        if (ud.hasOwnProperty(st)) {
          var ar = ud[st];
          if (ar !== re)
            return Ce("Invalid DOM property `%s`. Did you mean `%s`?", re, ar), ka[re] = !0, !0;
        } else if (!nr && re !== st)
          return Ce("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", re, st), ka[re] = !0, !0;
        return typeof ke == "boolean" && On(re, ke, qt, !1) ? (ke ? Ce('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', ke, re, re, ke, re) : Ce('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', ke, re, re, ke, re, re, re), ka[re] = !0, !0) : nr ? !0 : On(re, ke, qt, !1) ? (ka[re] = !0, !1) : ((ke === "false" || ke === "true") && qt !== null && qt.type === gn && (Ce("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", ke, re, ke === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', re, ke), ka[re] = !0), !0);
      };
    }
    var E1 = function(V, re, ke) {
      {
        var Oe = [];
        for (var st in re) {
          var bt = lp(V, st, re[st], ke);
          bt || Oe.push(st);
        }
        var Ct = Oe.map(function(Nt) {
          return "`" + Nt + "`";
        }).join(", ");
        Oe.length === 1 ? Ce("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Ct, V) : Oe.length > 1 && Ce("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Ct, V);
      }
    };
    function $1(V, re, ke) {
      Ws(V, re) || E1(V, re, ke);
    }
    var Ks = 1, nc = 2, Zu = 4, Zy = Ks | nc | Zu, ic = null;
    function ac(V) {
      ic !== null && Ce("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), ic = V;
    }
    function em() {
      ic === null && Ce("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), ic = null;
    }
    function x1(V) {
      return V === ic;
    }
    function ld(V) {
      var re = V.target || V.srcElement || window;
      return re.correspondingUseElement && (re = re.correspondingUseElement), re.nodeType === qs ? re.parentNode : re;
    }
    var qi = null, Eu = null, Vs = null;
    function Xf(V) {
      var re = Bl(V);
      if (re) {
        if (typeof qi != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var ke = re.stateNode;
        if (ke) {
          var Oe = Cv(ke);
          qi(re.stateNode, re.type, Oe);
        }
      }
    }
    function T1(V) {
      qi = V;
    }
    function cd(V) {
      Eu ? Vs ? Vs.push(V) : Vs = [V] : Eu = V;
    }
    function oc() {
      return Eu !== null || Vs !== null;
    }
    function sc() {
      if (Eu) {
        var V = Eu, re = Vs;
        if (Eu = null, Vs = null, Xf(V), re)
          for (var ke = 0; ke < re.length; ke++)
            Xf(re[ke]);
      }
    }
    var ef = function(V, re) {
      return V(re);
    }, dp = function() {
    }, hp = !1;
    function tm() {
      var V = oc();
      V && (dp(), sc());
    }
    function pp(V, re, ke) {
      if (hp)
        return V(re, ke);
      hp = !0;
      try {
        return ef(V, re, ke);
      } finally {
        hp = !1, tm();
      }
    }
    function dd(V, re, ke) {
      ef = V, dp = ke;
    }
    function hd(V) {
      return V === "button" || V === "input" || V === "select" || V === "textarea";
    }
    function vp(V, re, ke) {
      switch (V) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(ke.disabled && hd(re));
        default:
          return !1;
      }
    }
    function tf(V, re) {
      var ke = V.stateNode;
      if (ke === null)
        return null;
      var Oe = Cv(ke);
      if (Oe === null)
        return null;
      var st = Oe[re];
      if (vp(re, V.type, Oe))
        return null;
      if (st && typeof st != "function")
        throw new Error("Expected `" + re + "` listener to be a function, instead got a value of `" + typeof st + "` type.");
      return st;
    }
    var uc = !1;
    if (br)
      try {
        var rf = {};
        Object.defineProperty(rf, "passive", {
          get: function() {
            uc = !0;
          }
        }), window.addEventListener("test", rf, rf), window.removeEventListener("test", rf, rf);
      } catch {
        uc = !1;
      }
    function A1(V, re, ke, Oe, st, bt, Ct, Nt, qt) {
      var nr = Array.prototype.slice.call(arguments, 3);
      try {
        re.apply(ke, nr);
      } catch (ar) {
        this.onError(ar);
      }
    }
    var yp = A1;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var mp = document.createElement("react");
      yp = function(re, ke, Oe, st, bt, Ct, Nt, qt, nr) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ar = document.createEvent("Event"), xr = !1, Er = !0, Or = window.event, Ur = Object.getOwnPropertyDescriptor(window, "event");
        function qr() {
          mp.removeEventListener(Wr, Yn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Or);
        }
        var Sn = Array.prototype.slice.call(arguments, 3);
        function Yn() {
          xr = !0, qr(), ke.apply(Oe, Sn), Er = !1;
        }
        var qn, xi = !1, wi = !1;
        function Cr(Br) {
          if (qn = Br.error, xi = !0, qn === null && Br.colno === 0 && Br.lineno === 0 && (wi = !0), Br.defaultPrevented && qn != null && typeof qn == "object")
            try {
              qn._suppressLogging = !0;
            } catch {
            }
        }
        var Wr = "react-" + (re || "invokeguardedcallback");
        if (window.addEventListener("error", Cr), mp.addEventListener(Wr, Yn, !1), ar.initEvent(Wr, !1, !1), mp.dispatchEvent(ar), Ur && Object.defineProperty(window, "event", Ur), xr && Er && (xi ? wi && (qn = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : qn = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(qn)), window.removeEventListener("error", Cr), !xr)
          return qr(), A1.apply(this, arguments);
      };
    }
    var rm = yp, $u = !1, ms = null, fc = !1, xu = null, $s = {
      onError: function(V) {
        $u = !0, ms = V;
      }
    };
    function nf(V, re, ke, Oe, st, bt, Ct, Nt, qt) {
      $u = !1, ms = null, rm.apply($s, arguments);
    }
    function Gs(V, re, ke, Oe, st, bt, Ct, Nt, qt) {
      if (nf.apply(this, arguments), $u) {
        var nr = bp();
        fc || (fc = !0, xu = nr);
      }
    }
    function gp() {
      if (fc) {
        var V = xu;
        throw fc = !1, xu = null, V;
      }
    }
    function nm() {
      return $u;
    }
    function bp() {
      if ($u) {
        var V = ms;
        return $u = !1, ms = null, V;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Go(V) {
      return V._reactInternals;
    }
    function lc(V) {
      return V._reactInternals !== void 0;
    }
    function Yf(V, re) {
      V._reactInternals = re;
    }
    var Xn = (
      /*                      */
      0
    ), Tu = (
      /*                */
      1
    ), Gi = (
      /*                    */
      2
    ), hi = (
      /*                       */
      4
    ), Oi = (
      /*                */
      16
    ), Di = (
      /*                 */
      32
    ), xs = (
      /*                     */
      64
    ), oi = (
      /*                   */
      128
    ), fa = (
      /*            */
      256
    ), go = (
      /*                          */
      512
    ), Xo = (
      /*                     */
      1024
    ), Zi = (
      /*                      */
      2048
    ), Yo = (
      /*                    */
      4096
    ), Au = (
      /*                   */
      8192
    ), cc = (
      /*             */
      16384
    ), pd = Zi | hi | xs | go | Xo | cc, R1 = (
      /*               */
      32767
    ), Po = (
      /*                   */
      32768
    ), Ma = (
      /*                */
      65536
    ), dc = (
      /* */
      131072
    ), wp = (
      /*                       */
      1048576
    ), _p = (
      /*                    */
      2097152
    ), bo = (
      /*                 */
      4194304
    ), Ru = (
      /*                */
      8388608
    ), wo = (
      /*               */
      16777216
    ), af = (
      /*              */
      33554432
    ), Jf = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      hi | Xo | 0
    ), _o = Gi | hi | Oi | Di | go | Yo | Au, Ya = hi | xs | go | Au, Jo = Zi | Oi, Na = bo | Ru | _p, Xs = J.ReactCurrentOwner;
    function Io(V) {
      var re = V, ke = V;
      if (V.alternate)
        for (; re.return; )
          re = re.return;
      else {
        var Oe = re;
        do
          re = Oe, (re.flags & (Gi | Yo)) !== Xn && (ke = re.return), Oe = re.return;
        while (Oe);
      }
      return re.tag === lt ? ke : null;
    }
    function Sp(V) {
      if (V.tag === Jt) {
        var re = V.memoizedState;
        if (re === null) {
          var ke = V.alternate;
          ke !== null && (re = ke.memoizedState);
        }
        if (re !== null)
          return re.dehydrated;
      }
      return null;
    }
    function vd(V) {
      return V.tag === lt ? V.stateNode.containerInfo : null;
    }
    function Ep(V) {
      return Io(V) === V;
    }
    function Do(V) {
      {
        var re = Xs.current;
        if (re !== null && re.tag === ht) {
          var ke = re, Oe = ke.stateNode;
          Oe._warnedAboutRefsInRender || Ce("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ui(ke) || "A component"), Oe._warnedAboutRefsInRender = !0;
        }
      }
      var st = Go(V);
      return st ? Io(st) === st : !1;
    }
    function So(V) {
      if (Io(V) !== V)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Xi(V) {
      var re = V.alternate;
      if (!re) {
        var ke = Io(V);
        if (ke === null)
          throw new Error("Unable to find node on an unmounted component.");
        return ke !== V ? null : V;
      }
      for (var Oe = V, st = re; ; ) {
        var bt = Oe.return;
        if (bt === null)
          break;
        var Ct = bt.alternate;
        if (Ct === null) {
          var Nt = bt.return;
          if (Nt !== null) {
            Oe = st = Nt;
            continue;
          }
          break;
        }
        if (bt.child === Ct.child) {
          for (var qt = bt.child; qt; ) {
            if (qt === Oe)
              return So(bt), V;
            if (qt === st)
              return So(bt), re;
            qt = qt.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (Oe.return !== st.return)
          Oe = bt, st = Ct;
        else {
          for (var nr = !1, ar = bt.child; ar; ) {
            if (ar === Oe) {
              nr = !0, Oe = bt, st = Ct;
              break;
            }
            if (ar === st) {
              nr = !0, st = bt, Oe = Ct;
              break;
            }
            ar = ar.sibling;
          }
          if (!nr) {
            for (ar = Ct.child; ar; ) {
              if (ar === Oe) {
                nr = !0, Oe = Ct, st = bt;
                break;
              }
              if (ar === st) {
                nr = !0, st = Ct, Oe = bt;
                break;
              }
              ar = ar.sibling;
            }
            if (!nr)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (Oe.alternate !== st)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (Oe.tag !== lt)
        throw new Error("Unable to find node on an unmounted component.");
      return Oe.stateNode.current === Oe ? V : re;
    }
    function Qo(V) {
      var re = Xi(V);
      return re !== null ? $p(re) : null;
    }
    function $p(V) {
      if (V.tag === wt || V.tag === Rt)
        return V;
      for (var re = V.child; re !== null; ) {
        var ke = $p(re);
        if (ke !== null)
          return ke;
        re = re.sibling;
      }
      return null;
    }
    function C1(V) {
      var re = Xi(V);
      return re !== null ? yd(re) : null;
    }
    function yd(V) {
      if (V.tag === wt || V.tag === Rt)
        return V;
      for (var re = V.child; re !== null; ) {
        if (re.tag !== Et) {
          var ke = yd(re);
          if (ke !== null)
            return ke;
        }
        re = re.sibling;
      }
      return null;
    }
    var md = L.unstable_scheduleCallback, B1 = L.unstable_cancelCallback, gd = L.unstable_shouldYield, k1 = L.unstable_requestPaint, ia = L.unstable_now, xp = L.unstable_getCurrentPriorityLevel, bd = L.unstable_ImmediatePriority, of = L.unstable_UserBlockingPriority, Ts = L.unstable_NormalPriority, M1 = L.unstable_LowPriority, wd = L.unstable_IdlePriority, Qf = L.unstable_yieldValue, O1 = L.unstable_setDisableYieldValue, Ys = null, Ea = null, yn = null, Zo = !1, No = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Tp(V) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var re = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (re.isDisabled)
        return !0;
      if (!re.supportsFiber)
        return Ce("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        dr && (V = ii({}, V, {
          getLaneLabelMap: Js,
          injectProfilingHooks: P1
        })), Ys = re.inject(V), Ea = re;
      } catch (ke) {
        Ce("React instrumentation encountered an error: %s.", ke);
      }
      return !!re.checkDCE;
    }
    function Ap(V, re) {
      if (Ea && typeof Ea.onScheduleFiberRoot == "function")
        try {
          Ea.onScheduleFiberRoot(Ys, V, re);
        } catch (ke) {
          Zo || (Zo = !0, Ce("React instrumentation encountered an error: %s", ke));
        }
    }
    function Zf(V, re) {
      if (Ea && typeof Ea.onCommitFiberRoot == "function")
        try {
          var ke = (V.current.flags & oi) === oi;
          if (tr) {
            var Oe;
            switch (re) {
              case pa:
                Oe = bd;
                break;
              case Zs:
                Oe = of;
                break;
              case As:
                Oe = Ts;
                break;
              case dl:
                Oe = wd;
                break;
              default:
                Oe = Ts;
                break;
            }
            Ea.onCommitFiberRoot(Ys, V, Oe, ke);
          }
        } catch (st) {
          Zo || (Zo = !0, Ce("React instrumentation encountered an error: %s", st));
        }
    }
    function es(V) {
      if (Ea && typeof Ea.onPostCommitFiberRoot == "function")
        try {
          Ea.onPostCommitFiberRoot(Ys, V);
        } catch (re) {
          Zo || (Zo = !0, Ce("React instrumentation encountered an error: %s", re));
        }
    }
    function sf(V) {
      if (Ea && typeof Ea.onCommitFiberUnmount == "function")
        try {
          Ea.onCommitFiberUnmount(Ys, V);
        } catch (re) {
          Zo || (Zo = !0, Ce("React instrumentation encountered an error: %s", re));
        }
    }
    function ba(V) {
      if (typeof Qf == "function" && (O1(V), oe(V)), Ea && typeof Ea.setStrictMode == "function")
        try {
          Ea.setStrictMode(Ys, V);
        } catch (re) {
          Zo || (Zo = !0, Ce("React instrumentation encountered an error: %s", re));
        }
    }
    function P1(V) {
      yn = V;
    }
    function Js() {
      {
        for (var V = /* @__PURE__ */ new Map(), re = 1, ke = 0; ke < mc; ke++) {
          var Oe = am(re);
          V.set(re, Oe), re *= 2;
        }
        return V;
      }
    }
    function Cu(V) {
      yn !== null && typeof yn.markCommitStarted == "function" && yn.markCommitStarted(V);
    }
    function _d() {
      yn !== null && typeof yn.markCommitStopped == "function" && yn.markCommitStopped();
    }
    function el(V) {
      yn !== null && typeof yn.markComponentRenderStarted == "function" && yn.markComponentRenderStarted(V);
    }
    function Eo() {
      yn !== null && typeof yn.markComponentRenderStopped == "function" && yn.markComponentRenderStopped();
    }
    function Bu(V) {
      yn !== null && typeof yn.markComponentPassiveEffectMountStarted == "function" && yn.markComponentPassiveEffectMountStarted(V);
    }
    function Sd() {
      yn !== null && typeof yn.markComponentPassiveEffectMountStopped == "function" && yn.markComponentPassiveEffectMountStopped();
    }
    function I1(V) {
      yn !== null && typeof yn.markComponentPassiveEffectUnmountStarted == "function" && yn.markComponentPassiveEffectUnmountStarted(V);
    }
    function Ed() {
      yn !== null && typeof yn.markComponentPassiveEffectUnmountStopped == "function" && yn.markComponentPassiveEffectUnmountStopped();
    }
    function D1(V) {
      yn !== null && typeof yn.markComponentLayoutEffectMountStarted == "function" && yn.markComponentLayoutEffectMountStarted(V);
    }
    function hc() {
      yn !== null && typeof yn.markComponentLayoutEffectMountStopped == "function" && yn.markComponentLayoutEffectMountStopped();
    }
    function gs(V) {
      yn !== null && typeof yn.markComponentLayoutEffectUnmountStarted == "function" && yn.markComponentLayoutEffectUnmountStarted(V);
    }
    function tl() {
      yn !== null && typeof yn.markComponentLayoutEffectUnmountStopped == "function" && yn.markComponentLayoutEffectUnmountStopped();
    }
    function pc(V, re, ke) {
      yn !== null && typeof yn.markComponentErrored == "function" && yn.markComponentErrored(V, re, ke);
    }
    function uf(V, re, ke) {
      yn !== null && typeof yn.markComponentSuspended == "function" && yn.markComponentSuspended(V, re, ke);
    }
    function Rp(V) {
      yn !== null && typeof yn.markLayoutEffectsStarted == "function" && yn.markLayoutEffectsStarted(V);
    }
    function rl() {
      yn !== null && typeof yn.markLayoutEffectsStopped == "function" && yn.markLayoutEffectsStopped();
    }
    function N1(V) {
      yn !== null && typeof yn.markPassiveEffectsStarted == "function" && yn.markPassiveEffectsStarted(V);
    }
    function Cp() {
      yn !== null && typeof yn.markPassiveEffectsStopped == "function" && yn.markPassiveEffectsStopped();
    }
    function ea(V) {
      yn !== null && typeof yn.markRenderStarted == "function" && yn.markRenderStarted(V);
    }
    function $d() {
      yn !== null && typeof yn.markRenderYielded == "function" && yn.markRenderYielded();
    }
    function xd() {
      yn !== null && typeof yn.markRenderStopped == "function" && yn.markRenderStopped();
    }
    function Bp(V) {
      yn !== null && typeof yn.markRenderScheduled == "function" && yn.markRenderScheduled(V);
    }
    function Td(V, re) {
      yn !== null && typeof yn.markForceUpdateScheduled == "function" && yn.markForceUpdateScheduled(V, re);
    }
    function vc(V, re) {
      yn !== null && typeof yn.markStateUpdateScheduled == "function" && yn.markStateUpdateScheduled(V, re);
    }
    var Hn = (
      /*                         */
      0
    ), zn = (
      /*                 */
      1
    ), si = (
      /*                    */
      2
    ), mi = (
      /*               */
      8
    ), Lo = (
      /*              */
      16
    ), nl = Math.clz32 ? Math.clz32 : Ja, yc = Math.log, im = Math.LN2;
    function Ja(V) {
      var re = V >>> 0;
      return re === 0 ? 32 : 31 - (yc(re) / im | 0) | 0;
    }
    var mc = 31, Jr = (
      /*                        */
      0
    ), wa = (
      /*                          */
      0
    ), Vn = (
      /*                        */
      1
    ), La = (
      /*    */
      2
    ), Uo = (
      /*             */
      4
    ), Qs = (
      /*            */
      8
    ), ts = (
      /*                     */
      16
    ), il = (
      /*                */
      32
    ), ff = (
      /*                       */
      4194240
    ), al = (
      /*                        */
      64
    ), Ad = (
      /*                        */
      128
    ), Rd = (
      /*                        */
      256
    ), Cd = (
      /*                        */
      512
    ), Bd = (
      /*                        */
      1024
    ), kd = (
      /*                        */
      2048
    ), lf = (
      /*                        */
      4096
    ), Md = (
      /*                        */
      8192
    ), ol = (
      /*                        */
      16384
    ), ul = (
      /*                       */
      32768
    ), Od = (
      /*                       */
      65536
    ), gc = (
      /*                       */
      131072
    ), Pd = (
      /*                       */
      262144
    ), Dd = (
      /*                       */
      524288
    ), Nd = (
      /*                       */
      1048576
    ), Ld = (
      /*                       */
      2097152
    ), fl = (
      /*                            */
      130023424
    ), cf = (
      /*                             */
      4194304
    ), Ud = (
      /*                             */
      8388608
    ), Fd = (
      /*                             */
      16777216
    ), kp = (
      /*                             */
      33554432
    ), Hd = (
      /*                             */
      67108864
    ), L1 = cf, bc = (
      /*          */
      134217728
    ), Mp = (
      /*                          */
      268435455
    ), ll = (
      /*               */
      268435456
    ), ku = (
      /*                        */
      536870912
    ), Qa = (
      /*                   */
      1073741824
    );
    function am(V) {
      {
        if (V & Vn)
          return "Sync";
        if (V & La)
          return "InputContinuousHydration";
        if (V & Uo)
          return "InputContinuous";
        if (V & Qs)
          return "DefaultHydration";
        if (V & ts)
          return "Default";
        if (V & il)
          return "TransitionHydration";
        if (V & ff)
          return "Transition";
        if (V & fl)
          return "Retry";
        if (V & bc)
          return "SelectiveHydration";
        if (V & ll)
          return "IdleHydration";
        if (V & ku)
          return "Idle";
        if (V & Qa)
          return "Offscreen";
      }
    }
    var Vi = -1, jd = al, $o = cf;
    function df(V) {
      switch (ha(V)) {
        case Vn:
          return Vn;
        case La:
          return La;
        case Uo:
          return Uo;
        case Qs:
          return Qs;
        case ts:
          return ts;
        case il:
          return il;
        case al:
        case Ad:
        case Rd:
        case Cd:
        case Bd:
        case kd:
        case lf:
        case Md:
        case ol:
        case ul:
        case Od:
        case gc:
        case Pd:
        case Dd:
        case Nd:
        case Ld:
          return V & ff;
        case cf:
        case Ud:
        case Fd:
        case kp:
        case Hd:
          return V & fl;
        case bc:
          return bc;
        case ll:
          return ll;
        case ku:
          return ku;
        case Qa:
          return Qa;
        default:
          return Ce("Should have found matching lanes. This is a bug in React."), V;
      }
    }
    function hf(V, re) {
      var ke = V.pendingLanes;
      if (ke === Jr)
        return Jr;
      var Oe = Jr, st = V.suspendedLanes, bt = V.pingedLanes, Ct = ke & Mp;
      if (Ct !== Jr) {
        var Nt = Ct & ~st;
        if (Nt !== Jr)
          Oe = df(Nt);
        else {
          var qt = Ct & bt;
          qt !== Jr && (Oe = df(qt));
        }
      } else {
        var nr = ke & ~st;
        nr !== Jr ? Oe = df(nr) : bt !== Jr && (Oe = df(bt));
      }
      if (Oe === Jr)
        return Jr;
      if (re !== Jr && re !== Oe && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (re & st) === Jr) {
        var ar = ha(Oe), xr = ha(re);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ar >= xr || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ar === ts && (xr & ff) !== Jr
        )
          return re;
      }
      (Oe & Uo) !== Jr && (Oe |= ke & ts);
      var Er = V.entangledLanes;
      if (Er !== Jr)
        for (var Or = V.entanglements, Ur = Oe & Er; Ur > 0; ) {
          var qr = Ou(Ur), Sn = 1 << qr;
          Oe |= Or[qr], Ur &= ~Sn;
        }
      return Oe;
    }
    function U1(V, re) {
      for (var ke = V.eventTimes, Oe = Vi; re > 0; ) {
        var st = Ou(re), bt = 1 << st, Ct = ke[st];
        Ct > Oe && (Oe = Ct), re &= ~bt;
      }
      return Oe;
    }
    function F1(V, re) {
      switch (V) {
        case Vn:
        case La:
        case Uo:
          return re + 250;
        case Qs:
        case ts:
        case il:
        case al:
        case Ad:
        case Rd:
        case Cd:
        case Bd:
        case kd:
        case lf:
        case Md:
        case ol:
        case ul:
        case Od:
        case gc:
        case Pd:
        case Dd:
        case Nd:
        case Ld:
          return re + 5e3;
        case cf:
        case Ud:
        case Fd:
        case kp:
        case Hd:
          return Vi;
        case bc:
        case ll:
        case ku:
        case Qa:
          return Vi;
        default:
          return Ce("Should have found matching lanes. This is a bug in React."), Vi;
      }
    }
    function H1(V, re) {
      for (var ke = V.pendingLanes, Oe = V.suspendedLanes, st = V.pingedLanes, bt = V.expirationTimes, Ct = ke; Ct > 0; ) {
        var Nt = Ou(Ct), qt = 1 << Nt, nr = bt[Nt];
        nr === Vi ? ((qt & Oe) === Jr || (qt & st) !== Jr) && (bt[Nt] = F1(qt, re)) : nr <= re && (V.expiredLanes |= qt), Ct &= ~qt;
      }
    }
    function Op(V) {
      return df(V.pendingLanes);
    }
    function Mu(V) {
      var re = V.pendingLanes & ~Qa;
      return re !== Jr ? re : re & Qa ? Qa : Jr;
    }
    function Pp(V) {
      return (V & Vn) !== Jr;
    }
    function wc(V) {
      return (V & Mp) !== Jr;
    }
    function j1(V) {
      return (V & fl) === V;
    }
    function z1(V) {
      var re = Vn | Uo | ts;
      return (V & re) === Jr;
    }
    function q1(V) {
      return (V & ff) === V;
    }
    function _c(V, re) {
      var ke = La | Uo | Qs | ts;
      return (re & ke) !== Jr;
    }
    function W1(V, re) {
      return (re & V.expiredLanes) !== Jr;
    }
    function Ip(V) {
      return (V & ff) !== Jr;
    }
    function K1() {
      var V = jd;
      return jd <<= 1, (jd & ff) === Jr && (jd = al), V;
    }
    function xo() {
      var V = $o;
      return $o <<= 1, ($o & fl) === Jr && ($o = cf), V;
    }
    function ha(V) {
      return V & -V;
    }
    function cl(V) {
      return ha(V);
    }
    function Ou(V) {
      return 31 - nl(V);
    }
    function zd(V) {
      return Ou(V);
    }
    function To(V, re) {
      return (V & re) !== Jr;
    }
    function pf(V, re) {
      return (V & re) === re;
    }
    function di(V, re) {
      return V | re;
    }
    function Sc(V, re) {
      return V & ~re;
    }
    function qd(V, re) {
      return V & re;
    }
    function om(V) {
      return V;
    }
    function V1(V, re) {
      return V !== wa && V < re ? V : re;
    }
    function Ec(V) {
      for (var re = [], ke = 0; ke < mc; ke++)
        re.push(V);
      return re;
    }
    function vf(V, re, ke) {
      V.pendingLanes |= re, re !== ku && (V.suspendedLanes = Jr, V.pingedLanes = Jr);
      var Oe = V.eventTimes, st = zd(re);
      Oe[st] = ke;
    }
    function G1(V, re) {
      V.suspendedLanes |= re, V.pingedLanes &= ~re;
      for (var ke = V.expirationTimes, Oe = re; Oe > 0; ) {
        var st = Ou(Oe), bt = 1 << st;
        ke[st] = Vi, Oe &= ~bt;
      }
    }
    function Wd(V, re, ke) {
      V.pingedLanes |= V.suspendedLanes & re;
    }
    function Kd(V, re) {
      var ke = V.pendingLanes & ~re;
      V.pendingLanes = re, V.suspendedLanes = Jr, V.pingedLanes = Jr, V.expiredLanes &= re, V.mutableReadLanes &= re, V.entangledLanes &= re;
      for (var Oe = V.entanglements, st = V.eventTimes, bt = V.expirationTimes, Ct = ke; Ct > 0; ) {
        var Nt = Ou(Ct), qt = 1 << Nt;
        Oe[Nt] = Jr, st[Nt] = Vi, bt[Nt] = Vi, Ct &= ~qt;
      }
    }
    function Dp(V, re) {
      for (var ke = V.entangledLanes |= re, Oe = V.entanglements, st = ke; st; ) {
        var bt = Ou(st), Ct = 1 << bt;
        // Is this one of the newly entangled lanes?
        Ct & re | // Is this lane transitively entangled with the newly entangled lanes?
        Oe[bt] & re && (Oe[bt] |= re), st &= ~Ct;
      }
    }
    function X1(V, re) {
      var ke = ha(re), Oe;
      switch (ke) {
        case Uo:
          Oe = La;
          break;
        case ts:
          Oe = Qs;
          break;
        case al:
        case Ad:
        case Rd:
        case Cd:
        case Bd:
        case kd:
        case lf:
        case Md:
        case ol:
        case ul:
        case Od:
        case gc:
        case Pd:
        case Dd:
        case Nd:
        case Ld:
        case cf:
        case Ud:
        case Fd:
        case kp:
        case Hd:
          Oe = il;
          break;
        case ku:
          Oe = ll;
          break;
        default:
          Oe = wa;
          break;
      }
      return (Oe & (V.suspendedLanes | re)) !== wa ? wa : Oe;
    }
    function Vd(V, re, ke) {
      if (No)
        for (var Oe = V.pendingUpdatersLaneMap; ke > 0; ) {
          var st = zd(ke), bt = 1 << st, Ct = Oe[st];
          Ct.add(re), ke &= ~bt;
        }
    }
    function Np(V, re) {
      if (No)
        for (var ke = V.pendingUpdatersLaneMap, Oe = V.memoizedUpdaters; re > 0; ) {
          var st = zd(re), bt = 1 << st, Ct = ke[st];
          Ct.size > 0 && (Ct.forEach(function(Nt) {
            var qt = Nt.alternate;
            (qt === null || !Oe.has(qt)) && Oe.add(Nt);
          }), Ct.clear()), re &= ~bt;
        }
    }
    function $c(V, re) {
      return null;
    }
    var pa = Vn, Zs = Uo, As = ts, dl = ku, pl = wa;
    function rs() {
      return pl;
    }
    function la(V) {
      pl = V;
    }
    function Za(V, re) {
      var ke = pl;
      try {
        return pl = V, re();
      } finally {
        pl = ke;
      }
    }
    function sm(V, re) {
      return V !== 0 && V < re ? V : re;
    }
    function um(V, re) {
      return V > re ? V : re;
    }
    function vl(V, re) {
      return V !== 0 && V < re;
    }
    function Ua(V) {
      var re = ha(V);
      return vl(pa, re) ? vl(Zs, re) ? wc(re) ? As : dl : Zs : pa;
    }
    function Gd(V) {
      var re = V.current.memoizedState;
      return re.isDehydrated;
    }
    var Mn;
    function yl(V) {
      Mn = V;
    }
    function Lp(V) {
      Mn(V);
    }
    var Xd;
    function fm(V) {
      Xd = V;
    }
    var ml;
    function Yd(V) {
      ml = V;
    }
    var Jd;
    function Y1(V) {
      Jd = V;
    }
    var Up;
    function J1(V) {
      Up = V;
    }
    var xc = !1, gl = [], ta = null, Oa = null, no = null, bl = /* @__PURE__ */ new Map(), wl = /* @__PURE__ */ new Map(), Pa = [], Q1 = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Rs(V) {
      return Q1.indexOf(V) > -1;
    }
    function lm(V, re, ke, Oe, st) {
      return {
        blockedOn: V,
        domEventName: re,
        eventSystemFlags: ke,
        nativeEvent: st,
        targetContainers: [Oe]
      };
    }
    function Fp(V, re) {
      switch (V) {
        case "focusin":
        case "focusout":
          ta = null;
          break;
        case "dragenter":
        case "dragleave":
          Oa = null;
          break;
        case "mouseover":
        case "mouseout":
          no = null;
          break;
        case "pointerover":
        case "pointerout": {
          var ke = re.pointerId;
          bl.delete(ke);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var Oe = re.pointerId;
          wl.delete(Oe);
          break;
        }
      }
    }
    function _l(V, re, ke, Oe, st, bt) {
      if (V === null || V.nativeEvent !== bt) {
        var Ct = lm(re, ke, Oe, st, bt);
        if (re !== null) {
          var Nt = Bl(re);
          Nt !== null && Xd(Nt);
        }
        return Ct;
      }
      V.eventSystemFlags |= Oe;
      var qt = V.targetContainers;
      return st !== null && qt.indexOf(st) === -1 && qt.push(st), V;
    }
    function Z1(V, re, ke, Oe, st) {
      switch (re) {
        case "focusin": {
          var bt = st;
          return ta = _l(ta, V, re, ke, Oe, bt), !0;
        }
        case "dragenter": {
          var Ct = st;
          return Oa = _l(Oa, V, re, ke, Oe, Ct), !0;
        }
        case "mouseover": {
          var Nt = st;
          return no = _l(no, V, re, ke, Oe, Nt), !0;
        }
        case "pointerover": {
          var qt = st, nr = qt.pointerId;
          return bl.set(nr, _l(bl.get(nr) || null, V, re, ke, Oe, qt)), !0;
        }
        case "gotpointercapture": {
          var ar = st, xr = ar.pointerId;
          return wl.set(xr, _l(wl.get(xr) || null, V, re, ke, Oe, ar)), !0;
        }
      }
      return !1;
    }
    function Hp(V) {
      var re = Nc(V.target);
      if (re !== null) {
        var ke = Io(re);
        if (ke !== null) {
          var Oe = ke.tag;
          if (Oe === Jt) {
            var st = Sp(ke);
            if (st !== null) {
              V.blockedOn = st, Up(V.priority, function() {
                ml(ke);
              });
              return;
            }
          } else if (Oe === lt) {
            var bt = ke.stateNode;
            if (Gd(bt)) {
              V.blockedOn = vd(ke);
              return;
            }
          }
        }
      }
      V.blockedOn = null;
    }
    function cm(V) {
      for (var re = Jd(), ke = {
        blockedOn: null,
        target: V,
        priority: re
      }, Oe = 0; Oe < Pa.length && vl(re, Pa[Oe].priority); Oe++)
        ;
      Pa.splice(Oe, 0, ke), Oe === 0 && Hp(ke);
    }
    function yf(V) {
      if (V.blockedOn !== null)
        return !1;
      for (var re = V.targetContainers; re.length > 0; ) {
        var ke = re[0], Oe = eo(V.domEventName, V.eventSystemFlags, ke, V.nativeEvent);
        if (Oe === null) {
          var st = V.nativeEvent, bt = new st.constructor(st.type, st);
          ac(bt), st.target.dispatchEvent(bt), em();
        } else {
          var Ct = Bl(Oe);
          return Ct !== null && Xd(Ct), V.blockedOn = Oe, !1;
        }
        re.shift();
      }
      return !0;
    }
    function Qd(V, re, ke) {
      yf(V) && ke.delete(re);
    }
    function ns() {
      xc = !1, ta !== null && yf(ta) && (ta = null), Oa !== null && yf(Oa) && (Oa = null), no !== null && yf(no) && (no = null), bl.forEach(Qd), wl.forEach(Qd);
    }
    function bi(V, re) {
      V.blockedOn === re && (V.blockedOn = null, xc || (xc = !0, L.unstable_scheduleCallback(L.unstable_NormalPriority, ns)));
    }
    function ca(V) {
      if (gl.length > 0) {
        bi(gl[0], V);
        for (var re = 1; re < gl.length; re++) {
          var ke = gl[re];
          ke.blockedOn === V && (ke.blockedOn = null);
        }
      }
      ta !== null && bi(ta, V), Oa !== null && bi(Oa, V), no !== null && bi(no, V);
      var Oe = function(Nt) {
        return bi(Nt, V);
      };
      bl.forEach(Oe), wl.forEach(Oe);
      for (var st = 0; st < Pa.length; st++) {
        var bt = Pa[st];
        bt.blockedOn === V && (bt.blockedOn = null);
      }
      for (; Pa.length > 0; ) {
        var Ct = Pa[0];
        if (Ct.blockedOn !== null)
          break;
        Hp(Ct), Ct.blockedOn === null && Pa.shift();
      }
    }
    var Yi = J.ReactCurrentBatchConfig, $a = !0;
    function Ao(V) {
      $a = !!V;
    }
    function Sl() {
      return $a;
    }
    function xa(V, re, ke) {
      var Oe = Zd(re), st;
      switch (Oe) {
        case pa:
          st = Tc;
          break;
        case Zs:
          st = mf;
          break;
        case As:
        default:
          st = El;
          break;
      }
      return st.bind(null, re, ke, V);
    }
    function Tc(V, re, ke, Oe) {
      var st = rs(), bt = Yi.transition;
      Yi.transition = null;
      try {
        la(pa), El(V, re, ke, Oe);
      } finally {
        la(st), Yi.transition = bt;
      }
    }
    function mf(V, re, ke, Oe) {
      var st = rs(), bt = Yi.transition;
      Yi.transition = null;
      try {
        la(Zs), El(V, re, ke, Oe);
      } finally {
        la(st), Yi.transition = bt;
      }
    }
    function El(V, re, ke, Oe) {
      $a && jp(V, re, ke, Oe);
    }
    function jp(V, re, ke, Oe) {
      var st = eo(V, re, ke, Oe);
      if (st === null) {
        Rm(V, re, Oe, Pu, ke), Fp(V, Oe);
        return;
      }
      if (Z1(st, V, re, ke, Oe)) {
        Oe.stopPropagation();
        return;
      }
      if (Fp(V, Oe), re & Zu && Rs(V)) {
        for (; st !== null; ) {
          var bt = Bl(st);
          bt !== null && Lp(bt);
          var Ct = eo(V, re, ke, Oe);
          if (Ct === null && Rm(V, re, Oe, Pu, ke), Ct === st)
            break;
          st = Ct;
        }
        st !== null && Oe.stopPropagation();
        return;
      }
      Rm(V, re, Oe, null, ke);
    }
    var Pu = null;
    function eo(V, re, ke, Oe) {
      Pu = null;
      var st = ld(Oe), bt = Nc(st);
      if (bt !== null) {
        var Ct = Io(bt);
        if (Ct === null)
          bt = null;
        else {
          var Nt = Ct.tag;
          if (Nt === Jt) {
            var qt = Sp(Ct);
            if (qt !== null)
              return qt;
            bt = null;
          } else if (Nt === lt) {
            var nr = Ct.stateNode;
            if (Gd(nr))
              return vd(Ct);
            bt = null;
          } else Ct !== bt && (bt = null);
        }
      }
      return Pu = bt, null;
    }
    function Zd(V) {
      switch (V) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return pa;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Zs;
        case "message": {
          var re = xp();
          switch (re) {
            case bd:
              return pa;
            case of:
              return Zs;
            case Ts:
            case M1:
              return As;
            case wd:
              return dl;
            default:
              return As;
          }
        }
        default:
          return As;
      }
    }
    function $l(V, re, ke) {
      return V.addEventListener(re, ke, !1), ke;
    }
    function eu(V, re, ke) {
      return V.addEventListener(re, ke, !0), ke;
    }
    function eh(V, re, ke, Oe) {
      return V.addEventListener(re, ke, {
        capture: !0,
        passive: Oe
      }), ke;
    }
    function zp(V, re, ke, Oe) {
      return V.addEventListener(re, ke, {
        passive: Oe
      }), ke;
    }
    var is = null, xl = null, as = null;
    function th(V) {
      return is = V, xl = Rc(), !0;
    }
    function Ac() {
      is = null, xl = null, as = null;
    }
    function nh() {
      if (as)
        return as;
      var V, re = xl, ke = re.length, Oe, st = Rc(), bt = st.length;
      for (V = 0; V < ke && re[V] === st[V]; V++)
        ;
      var Ct = ke - V;
      for (Oe = 1; Oe <= Ct && re[ke - Oe] === st[bt - Oe]; Oe++)
        ;
      var Nt = Oe > 1 ? 1 - Oe : void 0;
      return as = st.slice(V, Nt), as;
    }
    function Rc() {
      return "value" in is ? is.value : is.textContent;
    }
    function gf(V) {
      var re, ke = V.keyCode;
      return "charCode" in V ? (re = V.charCode, re === 0 && ke === 13 && (re = 13)) : re = ke, re === 10 && (re = 13), re >= 32 || re === 13 ? re : 0;
    }
    function Ia() {
      return !0;
    }
    function tu() {
      return !1;
    }
    function aa(V) {
      function re(ke, Oe, st, bt, Ct) {
        this._reactName = ke, this._targetInst = st, this.type = Oe, this.nativeEvent = bt, this.target = Ct, this.currentTarget = null;
        for (var Nt in V)
          if (V.hasOwnProperty(Nt)) {
            var qt = V[Nt];
            qt ? this[Nt] = qt(bt) : this[Nt] = bt[Nt];
          }
        var nr = bt.defaultPrevented != null ? bt.defaultPrevented : bt.returnValue === !1;
        return nr ? this.isDefaultPrevented = Ia : this.isDefaultPrevented = tu, this.isPropagationStopped = tu, this;
      }
      return ii(re.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var ke = this.nativeEvent;
          ke && (ke.preventDefault ? ke.preventDefault() : typeof ke.returnValue != "unknown" && (ke.returnValue = !1), this.isDefaultPrevented = Ia);
        },
        stopPropagation: function() {
          var ke = this.nativeEvent;
          ke && (ke.stopPropagation ? ke.stopPropagation() : typeof ke.cancelBubble != "unknown" && (ke.cancelBubble = !0), this.isPropagationStopped = Ia);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Ia
      }), re;
    }
    var Ta = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(V) {
        return V.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, ih = aa(Ta), bf = ii({}, Ta, {
      view: 0,
      detail: 0
    }), qp = aa(bf), Wp, Cs, Tl;
    function Kp(V) {
      V !== Tl && (Tl && V.type === "mousemove" ? (Wp = V.screenX - Tl.screenX, Cs = V.screenY - Tl.screenY) : (Wp = 0, Cs = 0), Tl = V);
    }
    var Bs = ii({}, bf, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Vp,
      button: 0,
      buttons: 0,
      relatedTarget: function(V) {
        return V.relatedTarget === void 0 ? V.fromElement === V.srcElement ? V.toElement : V.fromElement : V.relatedTarget;
      },
      movementX: function(V) {
        return "movementX" in V ? V.movementX : (Kp(V), Wp);
      },
      movementY: function(V) {
        return "movementY" in V ? V.movementY : Cs;
      }
    }), ah = aa(Bs), wf = ii({}, Bs, {
      dataTransfer: 0
    }), ev = aa(wf), tv = ii({}, bf, {
      relatedTarget: 0
    }), Cc = aa(tv), oh = ii({}, Ta, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), dm = aa(oh), hm = ii({}, Ta, {
      clipboardData: function(V) {
        return "clipboardData" in V ? V.clipboardData : window.clipboardData;
      }
    }), rv = aa(hm), nv = ii({}, Ta, {
      data: 0
    }), Iu = aa(nv), pm = Iu, Al = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, iv = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function da(V) {
      if (V.key) {
        var re = Al[V.key] || V.key;
        if (re !== "Unidentified")
          return re;
      }
      if (V.type === "keypress") {
        var ke = gf(V);
        return ke === 13 ? "Enter" : String.fromCharCode(ke);
      }
      return V.type === "keydown" || V.type === "keyup" ? iv[V.keyCode] || "Unidentified" : "";
    }
    var vm = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function av(V) {
      var re = this, ke = re.nativeEvent;
      if (ke.getModifierState)
        return ke.getModifierState(V);
      var Oe = vm[V];
      return Oe ? !!ke[Oe] : !1;
    }
    function Vp(V) {
      return av;
    }
    var ym = ii({}, bf, {
      key: da,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Vp,
      // Legacy Interface
      charCode: function(V) {
        return V.type === "keypress" ? gf(V) : 0;
      },
      keyCode: function(V) {
        return V.type === "keydown" || V.type === "keyup" ? V.keyCode : 0;
      },
      which: function(V) {
        return V.type === "keypress" ? gf(V) : V.type === "keydown" || V.type === "keyup" ? V.keyCode : 0;
      }
    }), ov = aa(ym), sv = ii({}, Bs, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), uv = aa(sv), os = ii({}, bf, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Vp
    }), Gp = aa(os), mm = ii({}, Ta, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Du = aa(mm), uh = ii({}, Bs, {
      deltaX: function(V) {
        return "deltaX" in V ? V.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in V ? -V.wheelDeltaX : 0
        );
      },
      deltaY: function(V) {
        return "deltaY" in V ? V.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in V ? -V.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in V ? -V.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), _f = aa(uh), fh = [9, 13, 27, 32], lh = 229, Bc = br && "CompositionEvent" in window, kc = null;
    br && "documentMode" in document && (kc = document.documentMode);
    var Xp = br && "TextEvent" in window && !kc, fv = br && (!Bc || kc && kc > 8 && kc <= 11), Yp = 32, Jp = String.fromCharCode(Yp);
    function hh() {
      Xt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Xt("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Xt("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Xt("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Mc = !1;
    function lv(V) {
      return (V.ctrlKey || V.altKey || V.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(V.ctrlKey && V.altKey);
    }
    function Qp(V) {
      switch (V) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function gm(V, re) {
      return V === "keydown" && re.keyCode === lh;
    }
    function Zp(V, re) {
      switch (V) {
        case "keyup":
          return fh.indexOf(re.keyCode) !== -1;
        case "keydown":
          return re.keyCode !== lh;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function ph(V) {
      var re = V.detail;
      return typeof re == "object" && "data" in re ? re.data : null;
    }
    function Oc(V) {
      return V.locale === "ko";
    }
    var Nu = !1;
    function vh(V, re, ke, Oe, st) {
      var bt, Ct;
      if (Bc ? bt = Qp(re) : Nu ? Zp(re, Oe) && (bt = "onCompositionEnd") : gm(re, Oe) && (bt = "onCompositionStart"), !bt)
        return null;
      fv && !Oc(Oe) && (!Nu && bt === "onCompositionStart" ? Nu = th(st) : bt === "onCompositionEnd" && Nu && (Ct = nh()));
      var Nt = yv(ke, bt);
      if (Nt.length > 0) {
        var qt = new Iu(bt, re, null, Oe, st);
        if (V.push({
          event: qt,
          listeners: Nt
        }), Ct)
          qt.data = Ct;
        else {
          var nr = ph(Oe);
          nr !== null && (qt.data = nr);
        }
      }
    }
    function cv(V, re) {
      switch (V) {
        case "compositionend":
          return ph(re);
        case "keypress":
          var ke = re.which;
          return ke !== Yp ? null : (Mc = !0, Jp);
        case "textInput":
          var Oe = re.data;
          return Oe === Jp && Mc ? null : Oe;
        default:
          return null;
      }
    }
    function bm(V, re) {
      if (Nu) {
        if (V === "compositionend" || !Bc && Zp(V, re)) {
          var ke = nh();
          return Ac(), Nu = !1, ke;
        }
        return null;
      }
      switch (V) {
        case "paste":
          return null;
        case "keypress":
          if (!lv(re)) {
            if (re.char && re.char.length > 1)
              return re.char;
            if (re.which)
              return String.fromCharCode(re.which);
          }
          return null;
        case "compositionend":
          return fv && !Oc(re) ? null : re.data;
        default:
          return null;
      }
    }
    function yh(V, re, ke, Oe, st) {
      var bt;
      if (Xp ? bt = cv(re, Oe) : bt = bm(re, Oe), !bt)
        return null;
      var Ct = yv(ke, "onBeforeInput");
      if (Ct.length > 0) {
        var Nt = new pm("onBeforeInput", "beforeinput", null, Oe, st);
        V.push({
          event: Nt,
          listeners: Ct
        }), Nt.data = bt;
      }
    }
    function wm(V, re, ke, Oe, st, bt, Ct) {
      vh(V, re, ke, Oe, st), yh(V, re, ke, Oe, st);
    }
    var Pc = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function dv(V) {
      var re = V && V.nodeName && V.nodeName.toLowerCase();
      return re === "input" ? !!Pc[V.type] : re === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function mh(V) {
      if (!br)
        return !1;
      var re = "on" + V, ke = re in document;
      if (!ke) {
        var Oe = document.createElement("div");
        Oe.setAttribute(re, "return;"), ke = typeof Oe[re] == "function";
      }
      return ke;
    }
    function ie() {
      Xt("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function pe(V, re, ke, Oe) {
      cd(Oe);
      var st = yv(re, "onChange");
      if (st.length > 0) {
        var bt = new ih("onChange", "change", null, ke, Oe);
        V.push({
          event: bt,
          listeners: st
        });
      }
    }
    var nt = null, pt = null;
    function Tt(V) {
      var re = V.nodeName && V.nodeName.toLowerCase();
      return re === "select" || re === "input" && V.type === "file";
    }
    function Pt(V) {
      var re = [];
      pe(re, pt, V, ld(V)), pp(Yt, re);
    }
    function Yt(V) {
      $b(V, 0);
    }
    function cr(V) {
      var re = Eh(V);
      if (Hf(re))
        return V;
    }
    function wr(V, re) {
      if (V === "change")
        return re;
    }
    var Lr = !1;
    br && (Lr = mh("input") && (!document.documentMode || document.documentMode > 9));
    function en(V, re) {
      nt = V, pt = re, nt.attachEvent("onpropertychange", Qr);
    }
    function rn() {
      nt && (nt.detachEvent("onpropertychange", Qr), nt = null, pt = null);
    }
    function Qr(V) {
      V.propertyName === "value" && cr(pt) && Pt(V);
    }
    function An(V, re, ke) {
      V === "focusin" ? (rn(), en(re, ke)) : V === "focusout" && rn();
    }
    function Nn(V, re) {
      if (V === "selectionchange" || V === "keyup" || V === "keydown")
        return cr(pt);
    }
    function Fn(V) {
      var re = V.nodeName;
      return re && re.toLowerCase() === "input" && (V.type === "checkbox" || V.type === "radio");
    }
    function va(V, re) {
      if (V === "click")
        return cr(re);
    }
    function Rr(V, re) {
      if (V === "input" || V === "change")
        return cr(re);
    }
    function $r(V) {
      var re = V._wrapperState;
      !re || !re.controlled || V.type !== "number" || Qn(V, "number", V.value);
    }
    function kr(V, re, ke, Oe, st, bt, Ct) {
      var Nt = ke ? Eh(ke) : window, qt, nr;
      if (Tt(Nt) ? qt = wr : dv(Nt) ? Lr ? qt = Rr : (qt = Nn, nr = An) : Fn(Nt) && (qt = va), qt) {
        var ar = qt(re, ke);
        if (ar) {
          pe(V, ar, Oe, st);
          return;
        }
      }
      nr && nr(re, Nt, ke), re === "focusout" && $r(Nt);
    }
    function un() {
      Qt("onMouseEnter", ["mouseout", "mouseover"]), Qt("onMouseLeave", ["mouseout", "mouseover"]), Qt("onPointerEnter", ["pointerout", "pointerover"]), Qt("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function jn(V, re, ke, Oe, st, bt, Ct) {
      var Nt = re === "mouseover" || re === "pointerover", qt = re === "mouseout" || re === "pointerout";
      if (Nt && !x1(Oe)) {
        var nr = Oe.relatedTarget || Oe.fromElement;
        if (nr && (Nc(nr) || h0(nr)))
          return;
      }
      if (!(!qt && !Nt)) {
        var ar;
        if (st.window === st)
          ar = st;
        else {
          var xr = st.ownerDocument;
          xr ? ar = xr.defaultView || xr.parentWindow : ar = window;
        }
        var Er, Or;
        if (qt) {
          var Ur = Oe.relatedTarget || Oe.toElement;
          if (Er = ke, Or = Ur ? Nc(Ur) : null, Or !== null) {
            var qr = Io(Or);
            (Or !== qr || Or.tag !== wt && Or.tag !== Rt) && (Or = null);
          }
        } else
          Er = null, Or = ke;
        if (Er !== Or) {
          var Sn = ah, Yn = "onMouseLeave", qn = "onMouseEnter", xi = "mouse";
          (re === "pointerout" || re === "pointerover") && (Sn = uv, Yn = "onPointerLeave", qn = "onPointerEnter", xi = "pointer");
          var wi = Er == null ? ar : Eh(Er), Cr = Or == null ? ar : Eh(Or), Wr = new Sn(Yn, xi + "leave", Er, Oe, st);
          Wr.target = wi, Wr.relatedTarget = Cr;
          var Br = null, nn = Nc(st);
          if (nn === ke) {
            var Bn = new Sn(qn, xi + "enter", Or, Oe, st);
            Bn.target = Cr, Bn.relatedTarget = wi, Br = Bn;
          }
          h6(V, Wr, Br, Er, Or);
        }
      }
    }
    function ei(V, re) {
      return V === re && (V !== 0 || 1 / V === 1 / re) || V !== V && re !== re;
    }
    var Ln = typeof Object.is == "function" ? Object.is : ei;
    function ri(V, re) {
      if (Ln(V, re))
        return !0;
      if (typeof V != "object" || V === null || typeof re != "object" || re === null)
        return !1;
      var ke = Object.keys(V), Oe = Object.keys(re);
      if (ke.length !== Oe.length)
        return !1;
      for (var st = 0; st < ke.length; st++) {
        var bt = ke[st];
        if (!Dr.call(re, bt) || !Ln(V[bt], re[bt]))
          return !1;
      }
      return !0;
    }
    function Aa(V) {
      for (; V && V.firstChild; )
        V = V.firstChild;
      return V;
    }
    function Bi(V) {
      for (; V; ) {
        if (V.nextSibling)
          return V.nextSibling;
        V = V.parentNode;
      }
    }
    function ru(V, re) {
      for (var ke = Aa(V), Oe = 0, st = 0; ke; ) {
        if (ke.nodeType === qs) {
          if (st = Oe + ke.textContent.length, Oe <= re && st >= re)
            return {
              node: ke,
              offset: re - Oe
            };
          Oe = st;
        }
        ke = Aa(Bi(ke));
      }
    }
    function _m(V) {
      var re = V.ownerDocument, ke = re && re.defaultView || window, Oe = ke.getSelection && ke.getSelection();
      if (!Oe || Oe.rangeCount === 0)
        return null;
      var st = Oe.anchorNode, bt = Oe.anchorOffset, Ct = Oe.focusNode, Nt = Oe.focusOffset;
      try {
        st.nodeType, Ct.nodeType;
      } catch {
        return null;
      }
      return V_(V, st, bt, Ct, Nt);
    }
    function V_(V, re, ke, Oe, st) {
      var bt = 0, Ct = -1, Nt = -1, qt = 0, nr = 0, ar = V, xr = null;
      e: for (; ; ) {
        for (var Er = null; ar === re && (ke === 0 || ar.nodeType === qs) && (Ct = bt + ke), ar === Oe && (st === 0 || ar.nodeType === qs) && (Nt = bt + st), ar.nodeType === qs && (bt += ar.nodeValue.length), (Er = ar.firstChild) !== null; )
          xr = ar, ar = Er;
        for (; ; ) {
          if (ar === V)
            break e;
          if (xr === re && ++qt === ke && (Ct = bt), xr === Oe && ++nr === st && (Nt = bt), (Er = ar.nextSibling) !== null)
            break;
          ar = xr, xr = ar.parentNode;
        }
        ar = Er;
      }
      return Ct === -1 || Nt === -1 ? null : {
        start: Ct,
        end: Nt
      };
    }
    function G_(V, re) {
      var ke = V.ownerDocument || document, Oe = ke && ke.defaultView || window;
      if (Oe.getSelection) {
        var st = Oe.getSelection(), bt = V.textContent.length, Ct = Math.min(re.start, bt), Nt = re.end === void 0 ? Ct : Math.min(re.end, bt);
        if (!st.extend && Ct > Nt) {
          var qt = Nt;
          Nt = Ct, Ct = qt;
        }
        var nr = ru(V, Ct), ar = ru(V, Nt);
        if (nr && ar) {
          if (st.rangeCount === 1 && st.anchorNode === nr.node && st.anchorOffset === nr.offset && st.focusNode === ar.node && st.focusOffset === ar.offset)
            return;
          var xr = ke.createRange();
          xr.setStart(nr.node, nr.offset), st.removeAllRanges(), Ct > Nt ? (st.addRange(xr), st.extend(ar.node, ar.offset)) : (xr.setEnd(ar.node, ar.offset), st.addRange(xr));
        }
      }
    }
    function db(V) {
      return V && V.nodeType === qs;
    }
    function hb(V, re) {
      return !V || !re ? !1 : V === re ? !0 : db(V) ? !1 : db(re) ? hb(V, re.parentNode) : "contains" in V ? V.contains(re) : V.compareDocumentPosition ? !!(V.compareDocumentPosition(re) & 16) : !1;
    }
    function X_(V) {
      return V && V.ownerDocument && hb(V.ownerDocument.documentElement, V);
    }
    function Y_(V) {
      try {
        return typeof V.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function pb() {
      for (var V = window, re = _u(); re instanceof V.HTMLIFrameElement; ) {
        if (Y_(re))
          V = re.contentWindow;
        else
          return re;
        re = _u(V.document);
      }
      return re;
    }
    function Sm(V) {
      var re = V && V.nodeName && V.nodeName.toLowerCase();
      return re && (re === "input" && (V.type === "text" || V.type === "search" || V.type === "tel" || V.type === "url" || V.type === "password") || re === "textarea" || V.contentEditable === "true");
    }
    function J_() {
      var V = pb();
      return {
        focusedElem: V,
        selectionRange: Sm(V) ? Z_(V) : null
      };
    }
    function Q_(V) {
      var re = pb(), ke = V.focusedElem, Oe = V.selectionRange;
      if (re !== ke && X_(ke)) {
        Oe !== null && Sm(ke) && e6(ke, Oe);
        for (var st = [], bt = ke; bt = bt.parentNode; )
          bt.nodeType === mo && st.push({
            element: bt,
            left: bt.scrollLeft,
            top: bt.scrollTop
          });
        typeof ke.focus == "function" && ke.focus();
        for (var Ct = 0; Ct < st.length; Ct++) {
          var Nt = st[Ct];
          Nt.element.scrollLeft = Nt.left, Nt.element.scrollTop = Nt.top;
        }
      }
    }
    function Z_(V) {
      var re;
      return "selectionStart" in V ? re = {
        start: V.selectionStart,
        end: V.selectionEnd
      } : re = _m(V), re || {
        start: 0,
        end: 0
      };
    }
    function e6(V, re) {
      var ke = re.start, Oe = re.end;
      Oe === void 0 && (Oe = ke), "selectionStart" in V ? (V.selectionStart = ke, V.selectionEnd = Math.min(Oe, V.value.length)) : G_(V, re);
    }
    var t6 = br && "documentMode" in document && document.documentMode <= 11;
    function r6() {
      Xt("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var gh = null, Em = null, e0 = null, $m = !1;
    function n6(V) {
      if ("selectionStart" in V && Sm(V))
        return {
          start: V.selectionStart,
          end: V.selectionEnd
        };
      var re = V.ownerDocument && V.ownerDocument.defaultView || window, ke = re.getSelection();
      return {
        anchorNode: ke.anchorNode,
        anchorOffset: ke.anchorOffset,
        focusNode: ke.focusNode,
        focusOffset: ke.focusOffset
      };
    }
    function i6(V) {
      return V.window === V ? V.document : V.nodeType === vs ? V : V.ownerDocument;
    }
    function vb(V, re, ke) {
      var Oe = i6(ke);
      if (!($m || gh == null || gh !== _u(Oe))) {
        var st = n6(gh);
        if (!e0 || !ri(e0, st)) {
          e0 = st;
          var bt = yv(Em, "onSelect");
          if (bt.length > 0) {
            var Ct = new ih("onSelect", "select", null, re, ke);
            V.push({
              event: Ct,
              listeners: bt
            }), Ct.target = gh;
          }
        }
      }
    }
    function a6(V, re, ke, Oe, st, bt, Ct) {
      var Nt = ke ? Eh(ke) : window;
      switch (re) {
        case "focusin":
          (dv(Nt) || Nt.contentEditable === "true") && (gh = Nt, Em = ke, e0 = null);
          break;
        case "focusout":
          gh = null, Em = null, e0 = null;
          break;
        case "mousedown":
          $m = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          $m = !1, vb(V, Oe, st);
          break;
        case "selectionchange":
          if (t6)
            break;
        case "keydown":
        case "keyup":
          vb(V, Oe, st);
      }
    }
    function hv(V, re) {
      var ke = {};
      return ke[V.toLowerCase()] = re.toLowerCase(), ke["Webkit" + V] = "webkit" + re, ke["Moz" + V] = "moz" + re, ke;
    }
    var bh = {
      animationend: hv("Animation", "AnimationEnd"),
      animationiteration: hv("Animation", "AnimationIteration"),
      animationstart: hv("Animation", "AnimationStart"),
      transitionend: hv("Transition", "TransitionEnd")
    }, xm = {}, yb = {};
    br && (yb = document.createElement("div").style, "AnimationEvent" in window || (delete bh.animationend.animation, delete bh.animationiteration.animation, delete bh.animationstart.animation), "TransitionEvent" in window || delete bh.transitionend.transition);
    function pv(V) {
      if (xm[V])
        return xm[V];
      if (!bh[V])
        return V;
      var re = bh[V];
      for (var ke in re)
        if (re.hasOwnProperty(ke) && ke in yb)
          return xm[V] = re[ke];
      return V;
    }
    var mb = pv("animationend"), gb = pv("animationiteration"), bb = pv("animationstart"), wb = pv("transitionend"), _b = /* @__PURE__ */ new Map(), Sb = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Rl(V, re) {
      _b.set(V, re), Xt(re, [V]);
    }
    function o6() {
      for (var V = 0; V < Sb.length; V++) {
        var re = Sb[V], ke = re.toLowerCase(), Oe = re[0].toUpperCase() + re.slice(1);
        Rl(ke, "on" + Oe);
      }
      Rl(mb, "onAnimationEnd"), Rl(gb, "onAnimationIteration"), Rl(bb, "onAnimationStart"), Rl("dblclick", "onDoubleClick"), Rl("focusin", "onFocus"), Rl("focusout", "onBlur"), Rl(wb, "onTransitionEnd");
    }
    function s6(V, re, ke, Oe, st, bt, Ct) {
      var Nt = _b.get(re);
      if (Nt !== void 0) {
        var qt = ih, nr = re;
        switch (re) {
          case "keypress":
            if (gf(Oe) === 0)
              return;
          case "keydown":
          case "keyup":
            qt = ov;
            break;
          case "focusin":
            nr = "focus", qt = Cc;
            break;
          case "focusout":
            nr = "blur", qt = Cc;
            break;
          case "beforeblur":
          case "afterblur":
            qt = Cc;
            break;
          case "click":
            if (Oe.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            qt = ah;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            qt = ev;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            qt = Gp;
            break;
          case mb:
          case gb:
          case bb:
            qt = dm;
            break;
          case wb:
            qt = Du;
            break;
          case "scroll":
            qt = qp;
            break;
          case "wheel":
            qt = _f;
            break;
          case "copy":
          case "cut":
          case "paste":
            qt = rv;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            qt = uv;
            break;
        }
        var ar = (bt & Zu) !== 0;
        {
          var xr = !ar && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          re === "scroll", Er = c6(ke, Nt, Oe.type, ar, xr);
          if (Er.length > 0) {
            var Or = new qt(Nt, nr, null, Oe, st);
            V.push({
              event: Or,
              listeners: Er
            });
          }
        }
      }
    }
    o6(), un(), ie(), r6(), hh();
    function u6(V, re, ke, Oe, st, bt, Ct) {
      s6(V, re, ke, Oe, st, bt);
      var Nt = (bt & Zy) === 0;
      Nt && (jn(V, re, ke, Oe, st), kr(V, re, ke, Oe, st), a6(V, re, ke, Oe, st), wm(V, re, ke, Oe, st));
    }
    var t0 = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Tm = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(t0));
    function Eb(V, re, ke) {
      var Oe = V.type || "unknown-event";
      V.currentTarget = ke, Gs(Oe, re, void 0, V), V.currentTarget = null;
    }
    function f6(V, re, ke) {
      var Oe;
      if (ke)
        for (var st = re.length - 1; st >= 0; st--) {
          var bt = re[st], Ct = bt.instance, Nt = bt.currentTarget, qt = bt.listener;
          if (Ct !== Oe && V.isPropagationStopped())
            return;
          Eb(V, qt, Nt), Oe = Ct;
        }
      else
        for (var nr = 0; nr < re.length; nr++) {
          var ar = re[nr], xr = ar.instance, Er = ar.currentTarget, Or = ar.listener;
          if (xr !== Oe && V.isPropagationStopped())
            return;
          Eb(V, Or, Er), Oe = xr;
        }
    }
    function $b(V, re) {
      for (var ke = (re & Zu) !== 0, Oe = 0; Oe < V.length; Oe++) {
        var st = V[Oe], bt = st.event, Ct = st.listeners;
        f6(bt, Ct, ke);
      }
      gp();
    }
    function l6(V, re, ke, Oe, st) {
      var bt = ld(ke), Ct = [];
      u6(Ct, V, Oe, ke, bt, re), $b(Ct, re);
    }
    function oa(V, re) {
      Tm.has(V) || Ce('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', V);
      var ke = !1, Oe = FS(re), st = p6(V);
      Oe.has(st) || (xb(re, V, nc, ke), Oe.add(st));
    }
    function Am(V, re, ke) {
      Tm.has(V) && !re && Ce('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', V);
      var Oe = 0;
      re && (Oe |= Zu), xb(ke, V, Oe, re);
    }
    var vv = "_reactListening" + Math.random().toString(36).slice(2);
    function r0(V) {
      if (!V[vv]) {
        V[vv] = !0, Wt.forEach(function(ke) {
          ke !== "selectionchange" && (Tm.has(ke) || Am(ke, !1, V), Am(ke, !0, V));
        });
        var re = V.nodeType === vs ? V : V.ownerDocument;
        re !== null && (re[vv] || (re[vv] = !0, Am("selectionchange", !1, re)));
      }
    }
    function xb(V, re, ke, Oe, st) {
      var bt = xa(V, re, ke), Ct = void 0;
      uc && (re === "touchstart" || re === "touchmove" || re === "wheel") && (Ct = !0), V = V, Oe ? Ct !== void 0 ? eh(V, re, bt, Ct) : eu(V, re, bt) : Ct !== void 0 ? zp(V, re, bt, Ct) : $l(V, re, bt);
    }
    function Tb(V, re) {
      return V === re || V.nodeType === ga && V.parentNode === re;
    }
    function Rm(V, re, ke, Oe, st) {
      var bt = Oe;
      if (!(re & Ks) && !(re & nc)) {
        var Ct = st;
        if (Oe !== null) {
          var Nt = Oe;
          e: for (; ; ) {
            if (Nt === null)
              return;
            var qt = Nt.tag;
            if (qt === lt || qt === Et) {
              var nr = Nt.stateNode.containerInfo;
              if (Tb(nr, Ct))
                break;
              if (qt === Et)
                for (var ar = Nt.return; ar !== null; ) {
                  var xr = ar.tag;
                  if (xr === lt || xr === Et) {
                    var Er = ar.stateNode.containerInfo;
                    if (Tb(Er, Ct))
                      return;
                  }
                  ar = ar.return;
                }
              for (; nr !== null; ) {
                var Or = Nc(nr);
                if (Or === null)
                  return;
                var Ur = Or.tag;
                if (Ur === wt || Ur === Rt) {
                  Nt = bt = Or;
                  continue e;
                }
                nr = nr.parentNode;
              }
            }
            Nt = Nt.return;
          }
        }
      }
      pp(function() {
        return l6(V, re, ke, bt);
      });
    }
    function n0(V, re, ke) {
      return {
        instance: V,
        listener: re,
        currentTarget: ke
      };
    }
    function c6(V, re, ke, Oe, st, bt) {
      for (var Ct = re !== null ? re + "Capture" : null, Nt = Oe ? Ct : re, qt = [], nr = V, ar = null; nr !== null; ) {
        var xr = nr, Er = xr.stateNode, Or = xr.tag;
        if (Or === wt && Er !== null && (ar = Er, Nt !== null)) {
          var Ur = tf(nr, Nt);
          Ur != null && qt.push(n0(nr, Ur, ar));
        }
        if (st)
          break;
        nr = nr.return;
      }
      return qt;
    }
    function yv(V, re) {
      for (var ke = re + "Capture", Oe = [], st = V; st !== null; ) {
        var bt = st, Ct = bt.stateNode, Nt = bt.tag;
        if (Nt === wt && Ct !== null) {
          var qt = Ct, nr = tf(st, ke);
          nr != null && Oe.unshift(n0(st, nr, qt));
          var ar = tf(st, re);
          ar != null && Oe.push(n0(st, ar, qt));
        }
        st = st.return;
      }
      return Oe;
    }
    function wh(V) {
      if (V === null)
        return null;
      do
        V = V.return;
      while (V && V.tag !== wt);
      return V || null;
    }
    function d6(V, re) {
      for (var ke = V, Oe = re, st = 0, bt = ke; bt; bt = wh(bt))
        st++;
      for (var Ct = 0, Nt = Oe; Nt; Nt = wh(Nt))
        Ct++;
      for (; st - Ct > 0; )
        ke = wh(ke), st--;
      for (; Ct - st > 0; )
        Oe = wh(Oe), Ct--;
      for (var qt = st; qt--; ) {
        if (ke === Oe || Oe !== null && ke === Oe.alternate)
          return ke;
        ke = wh(ke), Oe = wh(Oe);
      }
      return null;
    }
    function Ab(V, re, ke, Oe, st) {
      for (var bt = re._reactName, Ct = [], Nt = ke; Nt !== null && Nt !== Oe; ) {
        var qt = Nt, nr = qt.alternate, ar = qt.stateNode, xr = qt.tag;
        if (nr !== null && nr === Oe)
          break;
        if (xr === wt && ar !== null) {
          var Er = ar;
          if (st) {
            var Or = tf(Nt, bt);
            Or != null && Ct.unshift(n0(Nt, Or, Er));
          } else if (!st) {
            var Ur = tf(Nt, bt);
            Ur != null && Ct.push(n0(Nt, Ur, Er));
          }
        }
        Nt = Nt.return;
      }
      Ct.length !== 0 && V.push({
        event: re,
        listeners: Ct
      });
    }
    function h6(V, re, ke, Oe, st) {
      var bt = Oe && st ? d6(Oe, st) : null;
      Oe !== null && Ab(V, re, Oe, bt, !1), st !== null && ke !== null && Ab(V, ke, st, bt, !0);
    }
    function p6(V, re) {
      return V + "__bubble";
    }
    var ss = !1, i0 = "dangerouslySetInnerHTML", mv = "suppressContentEditableWarning", Cl = "suppressHydrationWarning", Rb = "autoFocus", Ic = "children", Dc = "style", gv = "__html", Cm, bv, a0, Cb, wv, Bb, kb;
    Cm = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, bv = function(V, re) {
      fd(V, re), fp(V, re), $1(V, re, {
        registrationNameDependencies: or,
        possibleRegistrationNames: _r
      });
    }, Bb = br && !document.documentMode, a0 = function(V, re, ke) {
      if (!ss) {
        var Oe = _v(ke), st = _v(re);
        st !== Oe && (ss = !0, Ce("Prop `%s` did not match. Server: %s Client: %s", V, JSON.stringify(st), JSON.stringify(Oe)));
      }
    }, Cb = function(V) {
      if (!ss) {
        ss = !0;
        var re = [];
        V.forEach(function(ke) {
          re.push(ke);
        }), Ce("Extra attributes from the server: %s", re);
      }
    }, wv = function(V, re) {
      re === !1 ? Ce("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", V, V, V) : Ce("Expected `%s` listener to be a function, instead got a value of `%s` type.", V, typeof re);
    }, kb = function(V, re) {
      var ke = V.namespaceURI === zs ? V.ownerDocument.createElement(V.tagName) : V.ownerDocument.createElementNS(V.namespaceURI, V.tagName);
      return ke.innerHTML = re, ke.innerHTML;
    };
    var v6 = /\r\n?/g, y6 = /\u0000|\uFFFD/g;
    function _v(V) {
      ni(V);
      var re = typeof V == "string" ? V : "" + V;
      return re.replace(v6, `
`).replace(y6, "");
    }
    function Sv(V, re, ke, Oe) {
      var st = _v(re), bt = _v(V);
      if (bt !== st && (Oe && (ss || (ss = !0, Ce('Text content did not match. Server: "%s" Client: "%s"', bt, st))), ke && gt))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function Mb(V) {
      return V.nodeType === vs ? V : V.ownerDocument;
    }
    function m6() {
    }
    function Ev(V) {
      V.onclick = m6;
    }
    function g6(V, re, ke, Oe, st) {
      for (var bt in Oe)
        if (Oe.hasOwnProperty(bt)) {
          var Ct = Oe[bt];
          if (bt === Dc)
            Ct && Object.freeze(Ct), h1(re, Ct);
          else if (bt === i0) {
            var Nt = Ct ? Ct[gv] : void 0;
            Nt != null && r1(re, Nt);
          } else if (bt === Ic)
            if (typeof Ct == "string") {
              var qt = V !== "textarea" || Ct !== "";
              qt && ad(re, Ct);
            } else typeof Ct == "number" && ad(re, "" + Ct);
          else bt === mv || bt === Cl || bt === Rb || (or.hasOwnProperty(bt) ? Ct != null && (typeof Ct != "function" && wv(bt, Ct), bt === "onScroll" && oa("scroll", re)) : Ct != null && Xr(re, bt, Ct, st));
        }
    }
    function b6(V, re, ke, Oe) {
      for (var st = 0; st < re.length; st += 2) {
        var bt = re[st], Ct = re[st + 1];
        bt === Dc ? h1(V, Ct) : bt === i0 ? r1(V, Ct) : bt === Ic ? ad(V, Ct) : Xr(V, bt, Ct, Oe);
      }
    }
    function w6(V, re, ke, Oe) {
      var st, bt = Mb(ke), Ct, Nt = Oe;
      if (Nt === zs && (Nt = nd(V)), Nt === zs) {
        if (st = Ws(V, re), !st && V !== V.toLowerCase() && Ce("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", V), V === "script") {
          var qt = bt.createElement("div");
          qt.innerHTML = "<script><\/script>";
          var nr = qt.firstChild;
          Ct = qt.removeChild(nr);
        } else if (typeof re.is == "string")
          Ct = bt.createElement(V, {
            is: re.is
          });
        else if (Ct = bt.createElement(V), V === "select") {
          var ar = Ct;
          re.multiple ? ar.multiple = !0 : re.size && (ar.size = re.size);
        }
      } else
        Ct = bt.createElementNS(Nt, V);
      return Nt === zs && !st && Object.prototype.toString.call(Ct) === "[object HTMLUnknownElement]" && !Dr.call(Cm, V) && (Cm[V] = !0, Ce("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", V)), Ct;
    }
    function _6(V, re) {
      return Mb(re).createTextNode(V);
    }
    function S6(V, re, ke, Oe) {
      var st = Ws(re, ke);
      bv(re, ke);
      var bt;
      switch (re) {
        case "dialog":
          oa("cancel", V), oa("close", V), bt = ke;
          break;
        case "iframe":
        case "object":
        case "embed":
          oa("load", V), bt = ke;
          break;
        case "video":
        case "audio":
          for (var Ct = 0; Ct < t0.length; Ct++)
            oa(t0[Ct], V);
          bt = ke;
          break;
        case "source":
          oa("error", V), bt = ke;
          break;
        case "img":
        case "image":
        case "link":
          oa("error", V), oa("load", V), bt = ke;
          break;
        case "details":
          oa("toggle", V), bt = ke;
          break;
        case "input":
          vr(V, ke), bt = Kt(V, ke), oa("invalid", V);
          break;
        case "option":
          Ui(V, ke), bt = ke;
          break;
        case "select":
          Ql(V, ke), bt = Jl(V, ke), oa("invalid", V);
          break;
        case "textarea":
          Z0(V, ke), bt = ep(V, ke), oa("invalid", V);
          break;
        default:
          bt = ke;
      }
      switch (sd(re, bt), g6(re, V, Oe, bt, st), re) {
        case "input":
          Ko(V), an(V, ke, !1);
          break;
        case "textarea":
          Ko(V), t1(V);
          break;
        case "option":
          zi(V, ke);
          break;
        case "select":
          Qh(V, ke);
          break;
        default:
          typeof bt.onClick == "function" && Ev(V);
          break;
      }
    }
    function E6(V, re, ke, Oe, st) {
      bv(re, Oe);
      var bt = null, Ct, Nt;
      switch (re) {
        case "input":
          Ct = Kt(V, ke), Nt = Kt(V, Oe), bt = [];
          break;
        case "select":
          Ct = Jl(V, ke), Nt = Jl(V, Oe), bt = [];
          break;
        case "textarea":
          Ct = ep(V, ke), Nt = ep(V, Oe), bt = [];
          break;
        default:
          Ct = ke, Nt = Oe, typeof Ct.onClick != "function" && typeof Nt.onClick == "function" && Ev(V);
          break;
      }
      sd(re, Nt);
      var qt, nr, ar = null;
      for (qt in Ct)
        if (!(Nt.hasOwnProperty(qt) || !Ct.hasOwnProperty(qt) || Ct[qt] == null))
          if (qt === Dc) {
            var xr = Ct[qt];
            for (nr in xr)
              xr.hasOwnProperty(nr) && (ar || (ar = {}), ar[nr] = "");
          } else qt === i0 || qt === Ic || qt === mv || qt === Cl || qt === Rb || (or.hasOwnProperty(qt) ? bt || (bt = []) : (bt = bt || []).push(qt, null));
      for (qt in Nt) {
        var Er = Nt[qt], Or = Ct != null ? Ct[qt] : void 0;
        if (!(!Nt.hasOwnProperty(qt) || Er === Or || Er == null && Or == null))
          if (qt === Dc)
            if (Er && Object.freeze(Er), Or) {
              for (nr in Or)
                Or.hasOwnProperty(nr) && (!Er || !Er.hasOwnProperty(nr)) && (ar || (ar = {}), ar[nr] = "");
              for (nr in Er)
                Er.hasOwnProperty(nr) && Or[nr] !== Er[nr] && (ar || (ar = {}), ar[nr] = Er[nr]);
            } else
              ar || (bt || (bt = []), bt.push(qt, ar)), ar = Er;
          else if (qt === i0) {
            var Ur = Er ? Er[gv] : void 0, qr = Or ? Or[gv] : void 0;
            Ur != null && qr !== Ur && (bt = bt || []).push(qt, Ur);
          } else qt === Ic ? (typeof Er == "string" || typeof Er == "number") && (bt = bt || []).push(qt, "" + Er) : qt === mv || qt === Cl || (or.hasOwnProperty(qt) ? (Er != null && (typeof Er != "function" && wv(qt, Er), qt === "onScroll" && oa("scroll", V)), !bt && Or !== Er && (bt = [])) : (bt = bt || []).push(qt, Er));
      }
      return ar && (tc(ar, Nt[Dc]), (bt = bt || []).push(Dc, ar)), bt;
    }
    function $6(V, re, ke, Oe, st) {
      ke === "input" && st.type === "radio" && st.name != null && Pr(V, st);
      var bt = Ws(ke, Oe), Ct = Ws(ke, st);
      switch (b6(V, re, bt, Ct), ke) {
        case "input":
          Hr(V, st);
          break;
        case "textarea":
          e1(V, st);
          break;
        case "select":
          zy(V, st);
          break;
      }
    }
    function x6(V) {
      {
        var re = V.toLowerCase();
        return ud.hasOwnProperty(re) && ud[re] || null;
      }
    }
    function T6(V, re, ke, Oe, st, bt, Ct) {
      var Nt, qt;
      switch (Nt = Ws(re, ke), bv(re, ke), re) {
        case "dialog":
          oa("cancel", V), oa("close", V);
          break;
        case "iframe":
        case "object":
        case "embed":
          oa("load", V);
          break;
        case "video":
        case "audio":
          for (var nr = 0; nr < t0.length; nr++)
            oa(t0[nr], V);
          break;
        case "source":
          oa("error", V);
          break;
        case "img":
        case "image":
        case "link":
          oa("error", V), oa("load", V);
          break;
        case "details":
          oa("toggle", V);
          break;
        case "input":
          vr(V, ke), oa("invalid", V);
          break;
        case "option":
          Ui(V, ke);
          break;
        case "select":
          Ql(V, ke), oa("invalid", V);
          break;
        case "textarea":
          Z0(V, ke), oa("invalid", V);
          break;
      }
      sd(re, ke);
      {
        qt = /* @__PURE__ */ new Set();
        for (var ar = V.attributes, xr = 0; xr < ar.length; xr++) {
          var Er = ar[xr].name.toLowerCase();
          switch (Er) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              qt.add(ar[xr].name);
          }
        }
      }
      var Or = null;
      for (var Ur in ke)
        if (ke.hasOwnProperty(Ur)) {
          var qr = ke[Ur];
          if (Ur === Ic)
            typeof qr == "string" ? V.textContent !== qr && (ke[Cl] !== !0 && Sv(V.textContent, qr, bt, Ct), Or = [Ic, qr]) : typeof qr == "number" && V.textContent !== "" + qr && (ke[Cl] !== !0 && Sv(V.textContent, qr, bt, Ct), Or = [Ic, "" + qr]);
          else if (or.hasOwnProperty(Ur))
            qr != null && (typeof qr != "function" && wv(Ur, qr), Ur === "onScroll" && oa("scroll", V));
          else if (Ct && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof Nt == "boolean") {
            var Sn = void 0, Yn = Nt && Bt ? null : In(Ur);
            if (ke[Cl] !== !0) {
              if (!(Ur === mv || Ur === Cl || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Ur === "value" || Ur === "checked" || Ur === "selected")) {
                if (Ur === i0) {
                  var qn = V.innerHTML, xi = qr ? qr[gv] : void 0;
                  if (xi != null) {
                    var wi = kb(V, xi);
                    wi !== qn && a0(Ur, qn, wi);
                  }
                } else if (Ur === Dc) {
                  if (qt.delete(Ur), Bb) {
                    var Cr = Jy(qr);
                    Sn = V.getAttribute("style"), Cr !== Sn && a0(Ur, Sn, Cr);
                  }
                } else if (Nt && !Bt)
                  qt.delete(Ur.toLowerCase()), Sn = jr(V, Ur, qr), qr !== Sn && a0(Ur, Sn, qr);
                else if (!fn(Ur, Yn, Nt) && !tn(Ur, qr, Yn, Nt)) {
                  var Wr = !1;
                  if (Yn !== null)
                    qt.delete(Yn.attributeName), Sn = Fr(V, Ur, qr, Yn);
                  else {
                    var Br = Oe;
                    if (Br === zs && (Br = nd(re)), Br === zs)
                      qt.delete(Ur.toLowerCase());
                    else {
                      var nn = x6(Ur);
                      nn !== null && nn !== Ur && (Wr = !0, qt.delete(nn)), qt.delete(Ur);
                    }
                    Sn = jr(V, Ur, qr);
                  }
                  var Bn = Bt;
                  !Bn && qr !== Sn && !Wr && a0(Ur, Sn, qr);
                }
              }
            }
          }
        }
      switch (Ct && // $FlowFixMe - Should be inferred as not undefined.
      qt.size > 0 && ke[Cl] !== !0 && Cb(qt), re) {
        case "input":
          Ko(V), an(V, ke, !0);
          break;
        case "textarea":
          Ko(V), t1(V);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof ke.onClick == "function" && Ev(V);
          break;
      }
      return Or;
    }
    function A6(V, re, ke) {
      var Oe = V.nodeValue !== re;
      return Oe;
    }
    function Bm(V, re) {
      {
        if (ss)
          return;
        ss = !0, Ce("Did not expect server HTML to contain a <%s> in <%s>.", re.nodeName.toLowerCase(), V.nodeName.toLowerCase());
      }
    }
    function km(V, re) {
      {
        if (ss)
          return;
        ss = !0, Ce('Did not expect server HTML to contain the text node "%s" in <%s>.', re.nodeValue, V.nodeName.toLowerCase());
      }
    }
    function Mm(V, re, ke) {
      {
        if (ss)
          return;
        ss = !0, Ce("Expected server HTML to contain a matching <%s> in <%s>.", re, V.nodeName.toLowerCase());
      }
    }
    function Om(V, re) {
      {
        if (re === "" || ss)
          return;
        ss = !0, Ce('Expected server HTML to contain a matching text node for "%s" in <%s>.', re, V.nodeName.toLowerCase());
      }
    }
    function R6(V, re, ke) {
      switch (re) {
        case "input":
          Zn(V, ke);
          return;
        case "textarea":
          tp(V, ke);
          return;
        case "select":
          qy(V, ke);
          return;
      }
    }
    var o0 = function() {
    }, s0 = function() {
    };
    {
      var C6 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], Ob = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], B6 = Ob.concat(["button"]), k6 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], Pb = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      s0 = function(V, re) {
        var ke = ii({}, V || Pb), Oe = {
          tag: re
        };
        return Ob.indexOf(re) !== -1 && (ke.aTagInScope = null, ke.buttonTagInScope = null, ke.nobrTagInScope = null), B6.indexOf(re) !== -1 && (ke.pTagInButtonScope = null), C6.indexOf(re) !== -1 && re !== "address" && re !== "div" && re !== "p" && (ke.listItemTagAutoclosing = null, ke.dlItemTagAutoclosing = null), ke.current = Oe, re === "form" && (ke.formTag = Oe), re === "a" && (ke.aTagInScope = Oe), re === "button" && (ke.buttonTagInScope = Oe), re === "nobr" && (ke.nobrTagInScope = Oe), re === "p" && (ke.pTagInButtonScope = Oe), re === "li" && (ke.listItemTagAutoclosing = Oe), (re === "dd" || re === "dt") && (ke.dlItemTagAutoclosing = Oe), ke;
      };
      var M6 = function(V, re) {
        switch (re) {
          case "select":
            return V === "option" || V === "optgroup" || V === "#text";
          case "optgroup":
            return V === "option" || V === "#text";
          case "option":
            return V === "#text";
          case "tr":
            return V === "th" || V === "td" || V === "style" || V === "script" || V === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return V === "tr" || V === "style" || V === "script" || V === "template";
          case "colgroup":
            return V === "col" || V === "template";
          case "table":
            return V === "caption" || V === "colgroup" || V === "tbody" || V === "tfoot" || V === "thead" || V === "style" || V === "script" || V === "template";
          case "head":
            return V === "base" || V === "basefont" || V === "bgsound" || V === "link" || V === "meta" || V === "title" || V === "noscript" || V === "noframes" || V === "style" || V === "script" || V === "template";
          case "html":
            return V === "head" || V === "body" || V === "frameset";
          case "frameset":
            return V === "frame";
          case "#document":
            return V === "html";
        }
        switch (V) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return re !== "h1" && re !== "h2" && re !== "h3" && re !== "h4" && re !== "h5" && re !== "h6";
          case "rp":
          case "rt":
            return k6.indexOf(re) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return re == null;
        }
        return !0;
      }, O6 = function(V, re) {
        switch (V) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return re.pTagInButtonScope;
          case "form":
            return re.formTag || re.pTagInButtonScope;
          case "li":
            return re.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return re.dlItemTagAutoclosing;
          case "button":
            return re.buttonTagInScope;
          case "a":
            return re.aTagInScope;
          case "nobr":
            return re.nobrTagInScope;
        }
        return null;
      }, Ib = {};
      o0 = function(V, re, ke) {
        ke = ke || Pb;
        var Oe = ke.current, st = Oe && Oe.tag;
        re != null && (V != null && Ce("validateDOMNesting: when childText is passed, childTag should be null"), V = "#text");
        var bt = M6(V, st) ? null : Oe, Ct = bt ? null : O6(V, ke), Nt = bt || Ct;
        if (Nt) {
          var qt = Nt.tag, nr = !!bt + "|" + V + "|" + qt;
          if (!Ib[nr]) {
            Ib[nr] = !0;
            var ar = V, xr = "";
            if (V === "#text" ? /\S/.test(re) ? ar = "Text nodes" : (ar = "Whitespace text nodes", xr = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : ar = "<" + V + ">", bt) {
              var Er = "";
              qt === "table" && V === "tr" && (Er += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), Ce("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", ar, qt, xr, Er);
            } else
              Ce("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", ar, qt);
          }
        }
      };
    }
    var $v = "suppressHydrationWarning", xv = "$", Tv = "/$", u0 = "$?", f0 = "$!", P6 = "style", Pm = null, Im = null;
    function I6(V) {
      var re, ke, Oe = V.nodeType;
      switch (Oe) {
        case vs:
        case Ju: {
          re = Oe === vs ? "#document" : "#fragment";
          var st = V.documentElement;
          ke = st ? st.namespaceURI : np(null, "");
          break;
        }
        default: {
          var bt = Oe === ga ? V.parentNode : V, Ct = bt.namespaceURI || null;
          re = bt.tagName, ke = np(Ct, re);
          break;
        }
      }
      {
        var Nt = re.toLowerCase(), qt = s0(null, Nt);
        return {
          namespace: ke,
          ancestorInfo: qt
        };
      }
    }
    function D6(V, re, ke) {
      {
        var Oe = V, st = np(Oe.namespace, re), bt = s0(Oe.ancestorInfo, re);
        return {
          namespace: st,
          ancestorInfo: bt
        };
      }
    }
    function L8(V) {
      return V;
    }
    function N6(V) {
      Pm = Sl(), Im = J_();
      var re = null;
      return Ao(!1), re;
    }
    function L6(V) {
      Q_(Im), Ao(Pm), Pm = null, Im = null;
    }
    function U6(V, re, ke, Oe, st) {
      var bt;
      {
        var Ct = Oe;
        if (o0(V, null, Ct.ancestorInfo), typeof re.children == "string" || typeof re.children == "number") {
          var Nt = "" + re.children, qt = s0(Ct.ancestorInfo, V);
          o0(null, Nt, qt);
        }
        bt = Ct.namespace;
      }
      var nr = w6(V, re, ke, bt);
      return d0(st, nr), zm(nr, re), nr;
    }
    function F6(V, re) {
      V.appendChild(re);
    }
    function H6(V, re, ke, Oe, st) {
      switch (S6(V, re, ke, Oe), re) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!ke.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function j6(V, re, ke, Oe, st, bt) {
      {
        var Ct = bt;
        if (typeof Oe.children != typeof ke.children && (typeof Oe.children == "string" || typeof Oe.children == "number")) {
          var Nt = "" + Oe.children, qt = s0(Ct.ancestorInfo, re);
          o0(null, Nt, qt);
        }
      }
      return E6(V, re, ke, Oe);
    }
    function Dm(V, re) {
      return V === "textarea" || V === "noscript" || typeof re.children == "string" || typeof re.children == "number" || typeof re.dangerouslySetInnerHTML == "object" && re.dangerouslySetInnerHTML !== null && re.dangerouslySetInnerHTML.__html != null;
    }
    function z6(V, re, ke, Oe) {
      {
        var st = ke;
        o0(null, V, st.ancestorInfo);
      }
      var bt = _6(V, re);
      return d0(Oe, bt), bt;
    }
    function q6() {
      var V = window.event;
      return V === void 0 ? As : Zd(V.type);
    }
    var Nm = typeof setTimeout == "function" ? setTimeout : void 0, W6 = typeof clearTimeout == "function" ? clearTimeout : void 0, Lm = -1, Db = typeof Promise == "function" ? Promise : void 0, K6 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Db < "u" ? function(V) {
      return Db.resolve(null).then(V).catch(V6);
    } : Nm;
    function V6(V) {
      setTimeout(function() {
        throw V;
      });
    }
    function G6(V, re, ke, Oe) {
      switch (re) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          ke.autoFocus && V.focus();
          return;
        case "img": {
          ke.src && (V.src = ke.src);
          return;
        }
      }
    }
    function X6(V, re, ke, Oe, st, bt) {
      $6(V, re, ke, Oe, st), zm(V, st);
    }
    function Nb(V) {
      ad(V, "");
    }
    function Y6(V, re, ke) {
      V.nodeValue = ke;
    }
    function J6(V, re) {
      V.appendChild(re);
    }
    function Q6(V, re) {
      var ke;
      V.nodeType === ga ? (ke = V.parentNode, ke.insertBefore(re, V)) : (ke = V, ke.appendChild(re));
      var Oe = V._reactRootContainer;
      Oe == null && ke.onclick === null && Ev(ke);
    }
    function Z6(V, re, ke) {
      V.insertBefore(re, ke);
    }
    function eS(V, re, ke) {
      V.nodeType === ga ? V.parentNode.insertBefore(re, ke) : V.insertBefore(re, ke);
    }
    function tS(V, re) {
      V.removeChild(re);
    }
    function rS(V, re) {
      V.nodeType === ga ? V.parentNode.removeChild(re) : V.removeChild(re);
    }
    function Um(V, re) {
      var ke = re, Oe = 0;
      do {
        var st = ke.nextSibling;
        if (V.removeChild(ke), st && st.nodeType === ga) {
          var bt = st.data;
          if (bt === Tv)
            if (Oe === 0) {
              V.removeChild(st), ca(re);
              return;
            } else
              Oe--;
          else (bt === xv || bt === u0 || bt === f0) && Oe++;
        }
        ke = st;
      } while (ke);
      ca(re);
    }
    function nS(V, re) {
      V.nodeType === ga ? Um(V.parentNode, re) : V.nodeType === mo && Um(V, re), ca(V);
    }
    function iS(V) {
      V = V;
      var re = V.style;
      typeof re.setProperty == "function" ? re.setProperty("display", "none", "important") : re.display = "none";
    }
    function aS(V) {
      V.nodeValue = "";
    }
    function oS(V, re) {
      V = V;
      var ke = re[P6], Oe = ke != null && ke.hasOwnProperty("display") ? ke.display : null;
      V.style.display = od("display", Oe);
    }
    function sS(V, re) {
      V.nodeValue = re;
    }
    function uS(V) {
      V.nodeType === mo ? V.textContent = "" : V.nodeType === vs && V.documentElement && V.removeChild(V.documentElement);
    }
    function fS(V, re, ke) {
      return V.nodeType !== mo || re.toLowerCase() !== V.nodeName.toLowerCase() ? null : V;
    }
    function lS(V, re) {
      return re === "" || V.nodeType !== qs ? null : V;
    }
    function cS(V) {
      return V.nodeType !== ga ? null : V;
    }
    function Lb(V) {
      return V.data === u0;
    }
    function Fm(V) {
      return V.data === f0;
    }
    function dS(V) {
      var re = V.nextSibling && V.nextSibling.dataset, ke, Oe, st;
      return re && (ke = re.dgst, Oe = re.msg, st = re.stck), {
        message: Oe,
        digest: ke,
        stack: st
      };
    }
    function hS(V, re) {
      V._reactRetry = re;
    }
    function Av(V) {
      for (; V != null; V = V.nextSibling) {
        var re = V.nodeType;
        if (re === mo || re === qs)
          break;
        if (re === ga) {
          var ke = V.data;
          if (ke === xv || ke === f0 || ke === u0)
            break;
          if (ke === Tv)
            return null;
        }
      }
      return V;
    }
    function l0(V) {
      return Av(V.nextSibling);
    }
    function pS(V) {
      return Av(V.firstChild);
    }
    function vS(V) {
      return Av(V.firstChild);
    }
    function yS(V) {
      return Av(V.nextSibling);
    }
    function mS(V, re, ke, Oe, st, bt, Ct) {
      d0(bt, V), zm(V, ke);
      var Nt;
      {
        var qt = st;
        Nt = qt.namespace;
      }
      var nr = (bt.mode & zn) !== Hn;
      return T6(V, re, ke, Nt, Oe, nr, Ct);
    }
    function gS(V, re, ke, Oe) {
      return d0(ke, V), ke.mode & zn, A6(V, re);
    }
    function bS(V, re) {
      d0(re, V);
    }
    function wS(V) {
      for (var re = V.nextSibling, ke = 0; re; ) {
        if (re.nodeType === ga) {
          var Oe = re.data;
          if (Oe === Tv) {
            if (ke === 0)
              return l0(re);
            ke--;
          } else (Oe === xv || Oe === f0 || Oe === u0) && ke++;
        }
        re = re.nextSibling;
      }
      return null;
    }
    function Ub(V) {
      for (var re = V.previousSibling, ke = 0; re; ) {
        if (re.nodeType === ga) {
          var Oe = re.data;
          if (Oe === xv || Oe === f0 || Oe === u0) {
            if (ke === 0)
              return re;
            ke--;
          } else Oe === Tv && ke++;
        }
        re = re.previousSibling;
      }
      return null;
    }
    function _S(V) {
      ca(V);
    }
    function SS(V) {
      ca(V);
    }
    function ES(V) {
      return V !== "head" && V !== "body";
    }
    function $S(V, re, ke, Oe) {
      var st = !0;
      Sv(re.nodeValue, ke, Oe, st);
    }
    function xS(V, re, ke, Oe, st, bt) {
      if (re[$v] !== !0) {
        var Ct = !0;
        Sv(Oe.nodeValue, st, bt, Ct);
      }
    }
    function TS(V, re) {
      re.nodeType === mo ? Bm(V, re) : re.nodeType === ga || km(V, re);
    }
    function AS(V, re) {
      {
        var ke = V.parentNode;
        ke !== null && (re.nodeType === mo ? Bm(ke, re) : re.nodeType === ga || km(ke, re));
      }
    }
    function RS(V, re, ke, Oe, st) {
      (st || re[$v] !== !0) && (Oe.nodeType === mo ? Bm(ke, Oe) : Oe.nodeType === ga || km(ke, Oe));
    }
    function CS(V, re, ke) {
      Mm(V, re);
    }
    function BS(V, re) {
      Om(V, re);
    }
    function kS(V, re, ke) {
      {
        var Oe = V.parentNode;
        Oe !== null && Mm(Oe, re);
      }
    }
    function MS(V, re) {
      {
        var ke = V.parentNode;
        ke !== null && Om(ke, re);
      }
    }
    function OS(V, re, ke, Oe, st, bt) {
      (bt || re[$v] !== !0) && Mm(ke, Oe);
    }
    function PS(V, re, ke, Oe, st) {
      (st || re[$v] !== !0) && Om(ke, Oe);
    }
    function IS(V) {
      Ce("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", V.nodeName.toLowerCase());
    }
    function DS(V) {
      r0(V);
    }
    var _h = Math.random().toString(36).slice(2), Sh = "__reactFiber$" + _h, Hm = "__reactProps$" + _h, c0 = "__reactContainer$" + _h, jm = "__reactEvents$" + _h, NS = "__reactListeners$" + _h, LS = "__reactHandles$" + _h;
    function US(V) {
      delete V[Sh], delete V[Hm], delete V[jm], delete V[NS], delete V[LS];
    }
    function d0(V, re) {
      re[Sh] = V;
    }
    function Rv(V, re) {
      re[c0] = V;
    }
    function Fb(V) {
      V[c0] = null;
    }
    function h0(V) {
      return !!V[c0];
    }
    function Nc(V) {
      var re = V[Sh];
      if (re)
        return re;
      for (var ke = V.parentNode; ke; ) {
        if (re = ke[c0] || ke[Sh], re) {
          var Oe = re.alternate;
          if (re.child !== null || Oe !== null && Oe.child !== null)
            for (var st = Ub(V); st !== null; ) {
              var bt = st[Sh];
              if (bt)
                return bt;
              st = Ub(st);
            }
          return re;
        }
        V = ke, ke = V.parentNode;
      }
      return null;
    }
    function Bl(V) {
      var re = V[Sh] || V[c0];
      return re && (re.tag === wt || re.tag === Rt || re.tag === Jt || re.tag === lt) ? re : null;
    }
    function Eh(V) {
      if (V.tag === wt || V.tag === Rt)
        return V.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Cv(V) {
      return V[Hm] || null;
    }
    function zm(V, re) {
      V[Hm] = re;
    }
    function FS(V) {
      var re = V[jm];
      return re === void 0 && (re = V[jm] = /* @__PURE__ */ new Set()), re;
    }
    var Hb = {}, jb = J.ReactDebugCurrentFrame;
    function Bv(V) {
      if (V) {
        var re = V._owner, ke = Ss(V.type, V._source, re ? re.type : null);
        jb.setExtraStackFrame(ke);
      } else
        jb.setExtraStackFrame(null);
    }
    function nu(V, re, ke, Oe, st) {
      {
        var bt = Function.call.bind(Dr);
        for (var Ct in V)
          if (bt(V, Ct)) {
            var Nt = void 0;
            try {
              if (typeof V[Ct] != "function") {
                var qt = Error((Oe || "React class") + ": " + ke + " type `" + Ct + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof V[Ct] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw qt.name = "Invariant Violation", qt;
              }
              Nt = V[Ct](re, Ct, Oe, ke, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (nr) {
              Nt = nr;
            }
            Nt && !(Nt instanceof Error) && (Bv(st), Ce("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Oe || "React class", ke, Ct, typeof Nt), Bv(null)), Nt instanceof Error && !(Nt.message in Hb) && (Hb[Nt.message] = !0, Bv(st), Ce("Failed %s type: %s", ke, Nt.message), Bv(null));
          }
      }
    }
    var qm = [], kv;
    kv = [];
    var Sf = -1;
    function kl(V) {
      return {
        current: V
      };
    }
    function Ro(V, re) {
      if (Sf < 0) {
        Ce("Unexpected pop.");
        return;
      }
      re !== kv[Sf] && Ce("Unexpected Fiber popped."), V.current = qm[Sf], qm[Sf] = null, kv[Sf] = null, Sf--;
    }
    function Co(V, re, ke) {
      Sf++, qm[Sf] = V.current, kv[Sf] = ke, V.current = re;
    }
    var Wm;
    Wm = {};
    var bs = {};
    Object.freeze(bs);
    var Ef = kl(bs), Lu = kl(!1), Km = bs;
    function $h(V, re, ke) {
      return ke && Uu(re) ? Km : Ef.current;
    }
    function zb(V, re, ke) {
      {
        var Oe = V.stateNode;
        Oe.__reactInternalMemoizedUnmaskedChildContext = re, Oe.__reactInternalMemoizedMaskedChildContext = ke;
      }
    }
    function xh(V, re) {
      {
        var ke = V.type, Oe = ke.contextTypes;
        if (!Oe)
          return bs;
        var st = V.stateNode;
        if (st && st.__reactInternalMemoizedUnmaskedChildContext === re)
          return st.__reactInternalMemoizedMaskedChildContext;
        var bt = {};
        for (var Ct in Oe)
          bt[Ct] = re[Ct];
        {
          var Nt = ui(V) || "Unknown";
          nu(Oe, bt, "context", Nt);
        }
        return st && zb(V, re, bt), bt;
      }
    }
    function Mv() {
      return Lu.current;
    }
    function Uu(V) {
      {
        var re = V.childContextTypes;
        return re != null;
      }
    }
    function Ov(V) {
      Ro(Lu, V), Ro(Ef, V);
    }
    function Vm(V) {
      Ro(Lu, V), Ro(Ef, V);
    }
    function qb(V, re, ke) {
      {
        if (Ef.current !== bs)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Co(Ef, re, V), Co(Lu, ke, V);
      }
    }
    function Wb(V, re, ke) {
      {
        var Oe = V.stateNode, st = re.childContextTypes;
        if (typeof Oe.getChildContext != "function") {
          {
            var bt = ui(V) || "Unknown";
            Wm[bt] || (Wm[bt] = !0, Ce("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", bt, bt));
          }
          return ke;
        }
        var Ct = Oe.getChildContext();
        for (var Nt in Ct)
          if (!(Nt in st))
            throw new Error((ui(V) || "Unknown") + '.getChildContext(): key "' + Nt + '" is not defined in childContextTypes.');
        {
          var qt = ui(V) || "Unknown";
          nu(st, Ct, "child context", qt);
        }
        return ii({}, ke, Ct);
      }
    }
    function Pv(V) {
      {
        var re = V.stateNode, ke = re && re.__reactInternalMemoizedMergedChildContext || bs;
        return Km = Ef.current, Co(Ef, ke, V), Co(Lu, Lu.current, V), !0;
      }
    }
    function Kb(V, re, ke) {
      {
        var Oe = V.stateNode;
        if (!Oe)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (ke) {
          var st = Wb(V, re, Km);
          Oe.__reactInternalMemoizedMergedChildContext = st, Ro(Lu, V), Ro(Ef, V), Co(Ef, st, V), Co(Lu, ke, V);
        } else
          Ro(Lu, V), Co(Lu, ke, V);
      }
    }
    function HS(V) {
      {
        if (!Ep(V) || V.tag !== ht)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var re = V;
        do {
          switch (re.tag) {
            case lt:
              return re.stateNode.context;
            case ht: {
              var ke = re.type;
              if (Uu(ke))
                return re.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          re = re.return;
        } while (re !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ml = 0, Iv = 1, $f = null, Gm = !1, Xm = !1;
    function Vb(V) {
      $f === null ? $f = [V] : $f.push(V);
    }
    function jS(V) {
      Gm = !0, Vb(V);
    }
    function Gb() {
      Gm && Ol();
    }
    function Ol() {
      if (!Xm && $f !== null) {
        Xm = !0;
        var V = 0, re = rs();
        try {
          var ke = !0, Oe = $f;
          for (la(pa); V < Oe.length; V++) {
            var st = Oe[V];
            do
              st = st(ke);
            while (st !== null);
          }
          $f = null, Gm = !1;
        } catch (bt) {
          throw $f !== null && ($f = $f.slice(V + 1)), md(bd, Ol), bt;
        } finally {
          la(re), Xm = !1;
        }
      }
      return null;
    }
    var Th = [], Ah = 0, Dv = null, Nv = 0, ks = [], Ms = 0, Lc = null, xf = 1, Tf = "";
    function zS(V) {
      return Fc(), (V.flags & wp) !== Xn;
    }
    function qS(V) {
      return Fc(), Nv;
    }
    function WS() {
      var V = Tf, re = xf, ke = re & ~KS(re);
      return ke.toString(32) + V;
    }
    function Uc(V, re) {
      Fc(), Th[Ah++] = Nv, Th[Ah++] = Dv, Dv = V, Nv = re;
    }
    function Xb(V, re, ke) {
      Fc(), ks[Ms++] = xf, ks[Ms++] = Tf, ks[Ms++] = Lc, Lc = V;
      var Oe = xf, st = Tf, bt = Lv(Oe) - 1, Ct = Oe & ~(1 << bt), Nt = ke + 1, qt = Lv(re) + bt;
      if (qt > 30) {
        var nr = bt - bt % 5, ar = (1 << nr) - 1, xr = (Ct & ar).toString(32), Er = Ct >> nr, Or = bt - nr, Ur = Lv(re) + Or, qr = Nt << Or, Sn = qr | Er, Yn = xr + st;
        xf = 1 << Ur | Sn, Tf = Yn;
      } else {
        var qn = Nt << bt, xi = qn | Ct, wi = st;
        xf = 1 << qt | xi, Tf = wi;
      }
    }
    function Ym(V) {
      Fc();
      var re = V.return;
      if (re !== null) {
        var ke = 1, Oe = 0;
        Uc(V, ke), Xb(V, ke, Oe);
      }
    }
    function Lv(V) {
      return 32 - nl(V);
    }
    function KS(V) {
      return 1 << Lv(V) - 1;
    }
    function Jm(V) {
      for (; V === Dv; )
        Dv = Th[--Ah], Th[Ah] = null, Nv = Th[--Ah], Th[Ah] = null;
      for (; V === Lc; )
        Lc = ks[--Ms], ks[Ms] = null, Tf = ks[--Ms], ks[Ms] = null, xf = ks[--Ms], ks[Ms] = null;
    }
    function VS() {
      return Fc(), Lc !== null ? {
        id: xf,
        overflow: Tf
      } : null;
    }
    function GS(V, re) {
      Fc(), ks[Ms++] = xf, ks[Ms++] = Tf, ks[Ms++] = Lc, xf = re.id, Tf = re.overflow, Lc = V;
    }
    function Fc() {
      ao() || Ce("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var io = null, Os = null, iu = !1, Hc = !1, Pl = null;
    function XS() {
      iu && Ce("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Yb() {
      Hc = !0;
    }
    function YS() {
      return Hc;
    }
    function JS(V) {
      var re = V.stateNode.containerInfo;
      return Os = vS(re), io = V, iu = !0, Pl = null, Hc = !1, !0;
    }
    function QS(V, re, ke) {
      return Os = yS(re), io = V, iu = !0, Pl = null, Hc = !1, ke !== null && GS(V, ke), !0;
    }
    function Jb(V, re) {
      switch (V.tag) {
        case lt: {
          TS(V.stateNode.containerInfo, re);
          break;
        }
        case wt: {
          var ke = (V.mode & zn) !== Hn;
          RS(
            V.type,
            V.memoizedProps,
            V.stateNode,
            re,
            // TODO: Delete this argument when we remove the legacy root API.
            ke
          );
          break;
        }
        case Jt: {
          var Oe = V.memoizedState;
          Oe.dehydrated !== null && AS(Oe.dehydrated, re);
          break;
        }
      }
    }
    function Qb(V, re) {
      Jb(V, re);
      var ke = n8();
      ke.stateNode = re, ke.return = V;
      var Oe = V.deletions;
      Oe === null ? (V.deletions = [ke], V.flags |= Oi) : Oe.push(ke);
    }
    function Qm(V, re) {
      {
        if (Hc)
          return;
        switch (V.tag) {
          case lt: {
            var ke = V.stateNode.containerInfo;
            switch (re.tag) {
              case wt:
                var Oe = re.type;
                re.pendingProps, CS(ke, Oe);
                break;
              case Rt:
                var st = re.pendingProps;
                BS(ke, st);
                break;
            }
            break;
          }
          case wt: {
            var bt = V.type, Ct = V.memoizedProps, Nt = V.stateNode;
            switch (re.tag) {
              case wt: {
                var qt = re.type, nr = re.pendingProps, ar = (V.mode & zn) !== Hn;
                OS(
                  bt,
                  Ct,
                  Nt,
                  qt,
                  nr,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ar
                );
                break;
              }
              case Rt: {
                var xr = re.pendingProps, Er = (V.mode & zn) !== Hn;
                PS(
                  bt,
                  Ct,
                  Nt,
                  xr,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Er
                );
                break;
              }
            }
            break;
          }
          case Jt: {
            var Or = V.memoizedState, Ur = Or.dehydrated;
            if (Ur !== null) switch (re.tag) {
              case wt:
                var qr = re.type;
                re.pendingProps, kS(Ur, qr);
                break;
              case Rt:
                var Sn = re.pendingProps;
                MS(Ur, Sn);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function Zb(V, re) {
      re.flags = re.flags & ~Yo | Gi, Qm(V, re);
    }
    function ew(V, re) {
      switch (V.tag) {
        case wt: {
          var ke = V.type;
          V.pendingProps;
          var Oe = fS(re, ke);
          return Oe !== null ? (V.stateNode = Oe, io = V, Os = pS(Oe), !0) : !1;
        }
        case Rt: {
          var st = V.pendingProps, bt = lS(re, st);
          return bt !== null ? (V.stateNode = bt, io = V, Os = null, !0) : !1;
        }
        case Jt: {
          var Ct = cS(re);
          if (Ct !== null) {
            var Nt = {
              dehydrated: Ct,
              treeContext: VS(),
              retryLane: Qa
            };
            V.memoizedState = Nt;
            var qt = i8(Ct);
            return qt.return = V, V.child = qt, io = V, Os = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Zm(V) {
      return (V.mode & zn) !== Hn && (V.flags & oi) === Xn;
    }
    function e2(V) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function t2(V) {
      if (iu) {
        var re = Os;
        if (!re) {
          Zm(V) && (Qm(io, V), e2()), Zb(io, V), iu = !1, io = V;
          return;
        }
        var ke = re;
        if (!ew(V, re)) {
          Zm(V) && (Qm(io, V), e2()), re = l0(ke);
          var Oe = io;
          if (!re || !ew(V, re)) {
            Zb(io, V), iu = !1, io = V;
            return;
          }
          Qb(Oe, ke);
        }
      }
    }
    function ZS(V, re, ke) {
      var Oe = V.stateNode, st = !Hc, bt = mS(Oe, V.type, V.memoizedProps, re, ke, V, st);
      return V.updateQueue = bt, bt !== null;
    }
    function e4(V) {
      var re = V.stateNode, ke = V.memoizedProps, Oe = gS(re, ke, V);
      if (Oe) {
        var st = io;
        if (st !== null)
          switch (st.tag) {
            case lt: {
              var bt = st.stateNode.containerInfo, Ct = (st.mode & zn) !== Hn;
              $S(
                bt,
                re,
                ke,
                // TODO: Delete this argument when we remove the legacy root API.
                Ct
              );
              break;
            }
            case wt: {
              var Nt = st.type, qt = st.memoizedProps, nr = st.stateNode, ar = (st.mode & zn) !== Hn;
              xS(
                Nt,
                qt,
                nr,
                re,
                ke,
                // TODO: Delete this argument when we remove the legacy root API.
                ar
              );
              break;
            }
          }
      }
      return Oe;
    }
    function t4(V) {
      var re = V.memoizedState, ke = re !== null ? re.dehydrated : null;
      if (!ke)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      bS(ke, V);
    }
    function r4(V) {
      var re = V.memoizedState, ke = re !== null ? re.dehydrated : null;
      if (!ke)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return wS(ke);
    }
    function tw(V) {
      for (var re = V.return; re !== null && re.tag !== wt && re.tag !== lt && re.tag !== Jt; )
        re = re.return;
      io = re;
    }
    function Uv(V) {
      if (V !== io)
        return !1;
      if (!iu)
        return tw(V), iu = !0, !1;
      if (V.tag !== lt && (V.tag !== wt || ES(V.type) && !Dm(V.type, V.memoizedProps))) {
        var re = Os;
        if (re)
          if (Zm(V))
            rw(V), e2();
          else
            for (; re; )
              Qb(V, re), re = l0(re);
      }
      return tw(V), V.tag === Jt ? Os = r4(V) : Os = io ? l0(V.stateNode) : null, !0;
    }
    function n4() {
      return iu && Os !== null;
    }
    function rw(V) {
      for (var re = Os; re; )
        Jb(V, re), re = l0(re);
    }
    function Rh() {
      io = null, Os = null, iu = !1, Hc = !1;
    }
    function nw() {
      Pl !== null && (Y3(Pl), Pl = null);
    }
    function ao() {
      return iu;
    }
    function r2(V) {
      Pl === null ? Pl = [V] : Pl.push(V);
    }
    var i4 = J.ReactCurrentBatchConfig, a4 = null;
    function o4() {
      return i4.transition;
    }
    var au = {
      recordUnsafeLifecycleWarnings: function(V, re) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(V, re) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var s4 = function(V) {
        for (var re = null, ke = V; ke !== null; )
          ke.mode & mi && (re = ke), ke = ke.return;
        return re;
      }, jc = function(V) {
        var re = [];
        return V.forEach(function(ke) {
          re.push(ke);
        }), re.sort().join(", ");
      }, p0 = [], v0 = [], y0 = [], m0 = [], g0 = [], b0 = [], zc = /* @__PURE__ */ new Set();
      au.recordUnsafeLifecycleWarnings = function(V, re) {
        zc.has(V.type) || (typeof re.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        re.componentWillMount.__suppressDeprecationWarning !== !0 && p0.push(V), V.mode & mi && typeof re.UNSAFE_componentWillMount == "function" && v0.push(V), typeof re.componentWillReceiveProps == "function" && re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && y0.push(V), V.mode & mi && typeof re.UNSAFE_componentWillReceiveProps == "function" && m0.push(V), typeof re.componentWillUpdate == "function" && re.componentWillUpdate.__suppressDeprecationWarning !== !0 && g0.push(V), V.mode & mi && typeof re.UNSAFE_componentWillUpdate == "function" && b0.push(V));
      }, au.flushPendingUnsafeLifecycleWarnings = function() {
        var V = /* @__PURE__ */ new Set();
        p0.length > 0 && (p0.forEach(function(Er) {
          V.add(ui(Er) || "Component"), zc.add(Er.type);
        }), p0 = []);
        var re = /* @__PURE__ */ new Set();
        v0.length > 0 && (v0.forEach(function(Er) {
          re.add(ui(Er) || "Component"), zc.add(Er.type);
        }), v0 = []);
        var ke = /* @__PURE__ */ new Set();
        y0.length > 0 && (y0.forEach(function(Er) {
          ke.add(ui(Er) || "Component"), zc.add(Er.type);
        }), y0 = []);
        var Oe = /* @__PURE__ */ new Set();
        m0.length > 0 && (m0.forEach(function(Er) {
          Oe.add(ui(Er) || "Component"), zc.add(Er.type);
        }), m0 = []);
        var st = /* @__PURE__ */ new Set();
        g0.length > 0 && (g0.forEach(function(Er) {
          st.add(ui(Er) || "Component"), zc.add(Er.type);
        }), g0 = []);
        var bt = /* @__PURE__ */ new Set();
        if (b0.length > 0 && (b0.forEach(function(Er) {
          bt.add(ui(Er) || "Component"), zc.add(Er.type);
        }), b0 = []), re.size > 0) {
          var Ct = jc(re);
          Ce(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Ct);
        }
        if (Oe.size > 0) {
          var Nt = jc(Oe);
          Ce(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, Nt);
        }
        if (bt.size > 0) {
          var qt = jc(bt);
          Ce(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, qt);
        }
        if (V.size > 0) {
          var nr = jc(V);
          ce(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, nr);
        }
        if (ke.size > 0) {
          var ar = jc(ke);
          ce(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ar);
        }
        if (st.size > 0) {
          var xr = jc(st);
          ce(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, xr);
        }
      };
      var Fv = /* @__PURE__ */ new Map(), iw = /* @__PURE__ */ new Set();
      au.recordLegacyContextWarning = function(V, re) {
        var ke = s4(V);
        if (ke === null) {
          Ce("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!iw.has(V.type)) {
          var Oe = Fv.get(ke);
          (V.type.contextTypes != null || V.type.childContextTypes != null || re !== null && typeof re.getChildContext == "function") && (Oe === void 0 && (Oe = [], Fv.set(ke, Oe)), Oe.push(V));
        }
      }, au.flushLegacyContextWarning = function() {
        Fv.forEach(function(V, re) {
          if (V.length !== 0) {
            var ke = V[0], Oe = /* @__PURE__ */ new Set();
            V.forEach(function(bt) {
              Oe.add(ui(bt) || "Component"), iw.add(bt.type);
            });
            var st = jc(Oe);
            try {
              Ii(ke), Ce(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, st);
            } finally {
              ua();
            }
          }
        });
      }, au.discardPendingWarnings = function() {
        p0 = [], v0 = [], y0 = [], m0 = [], g0 = [], b0 = [], Fv = /* @__PURE__ */ new Map();
      };
    }
    var n2, i2, a2, o2, s2, aw = function(V, re) {
    };
    n2 = !1, i2 = !1, a2 = {}, o2 = {}, s2 = {}, aw = function(V, re) {
      if (!(V === null || typeof V != "object") && !(!V._store || V._store.validated || V.key != null)) {
        if (typeof V._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        V._store.validated = !0;
        var ke = ui(re) || "Component";
        o2[ke] || (o2[ke] = !0, Ce('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function u4(V) {
      return V.prototype && V.prototype.isReactComponent;
    }
    function w0(V, re, ke) {
      var Oe = ke.ref;
      if (Oe !== null && typeof Oe != "function" && typeof Oe != "object") {
        if ((V.mode & mi || rr) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(ke._owner && ke._self && ke._owner.stateNode !== ke._self) && // Will already throw with "Function components cannot have string refs"
        !(ke._owner && ke._owner.tag !== ht) && // Will already warn with "Function components cannot be given refs"
        !(typeof ke.type == "function" && !u4(ke.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        ke._owner) {
          var st = ui(V) || "Component";
          a2[st] || (Ce('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', st, Oe), a2[st] = !0);
        }
        if (ke._owner) {
          var bt = ke._owner, Ct;
          if (bt) {
            var Nt = bt;
            if (Nt.tag !== ht)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            Ct = Nt.stateNode;
          }
          if (!Ct)
            throw new Error("Missing owner for string ref " + Oe + ". This error is likely caused by a bug in React. Please file an issue.");
          var qt = Ct;
          Wn(Oe, "ref");
          var nr = "" + Oe;
          if (re !== null && re.ref !== null && typeof re.ref == "function" && re.ref._stringRef === nr)
            return re.ref;
          var ar = function(xr) {
            var Er = qt.refs;
            xr === null ? delete Er[nr] : Er[nr] = xr;
          };
          return ar._stringRef = nr, ar;
        } else {
          if (typeof Oe != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!ke._owner)
            throw new Error("Element ref was specified as a string (" + Oe + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return Oe;
    }
    function Hv(V, re) {
      var ke = Object.prototype.toString.call(re);
      throw new Error("Objects are not valid as a React child (found: " + (ke === "[object Object]" ? "object with keys {" + Object.keys(re).join(", ") + "}" : ke) + "). If you meant to render a collection of children, use an array instead.");
    }
    function jv(V) {
      {
        var re = ui(V) || "Component";
        if (s2[re])
          return;
        s2[re] = !0, Ce("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function ow(V) {
      var re = V._payload, ke = V._init;
      return ke(re);
    }
    function sw(V) {
      function re(Cr, Wr) {
        if (V) {
          var Br = Cr.deletions;
          Br === null ? (Cr.deletions = [Wr], Cr.flags |= Oi) : Br.push(Wr);
        }
      }
      function ke(Cr, Wr) {
        if (!V)
          return null;
        for (var Br = Wr; Br !== null; )
          re(Cr, Br), Br = Br.sibling;
        return null;
      }
      function Oe(Cr, Wr) {
        for (var Br = /* @__PURE__ */ new Map(), nn = Wr; nn !== null; )
          nn.key !== null ? Br.set(nn.key, nn) : Br.set(nn.index, nn), nn = nn.sibling;
        return Br;
      }
      function st(Cr, Wr) {
        var Br = Qc(Cr, Wr);
        return Br.index = 0, Br.sibling = null, Br;
      }
      function bt(Cr, Wr, Br) {
        if (Cr.index = Br, !V)
          return Cr.flags |= wp, Wr;
        var nn = Cr.alternate;
        if (nn !== null) {
          var Bn = nn.index;
          return Bn < Wr ? (Cr.flags |= Gi, Wr) : Bn;
        } else
          return Cr.flags |= Gi, Wr;
      }
      function Ct(Cr) {
        return V && Cr.alternate === null && (Cr.flags |= Gi), Cr;
      }
      function Nt(Cr, Wr, Br, nn) {
        if (Wr === null || Wr.tag !== Rt) {
          var Bn = rb(Br, Cr.mode, nn);
          return Bn.return = Cr, Bn;
        } else {
          var $n = st(Wr, Br);
          return $n.return = Cr, $n;
        }
      }
      function qt(Cr, Wr, Br, nn) {
        var Bn = Br.type;
        if (Bn === vn)
          return ar(Cr, Wr, Br.props.children, nn, Br.key);
        if (Wr !== null && (Wr.elementType === Bn || // Keep this check inline so it only runs on the false path:
        d_(Wr, Br) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Bn == "object" && Bn !== null && Bn.$$typeof === Dn && ow(Bn) === Wr.type)) {
          var $n = st(Wr, Br.props);
          return $n.ref = w0(Cr, Wr, Br), $n.return = Cr, $n._debugSource = Br._source, $n._debugOwner = Br._owner, $n;
        }
        var ai = tb(Br, Cr.mode, nn);
        return ai.ref = w0(Cr, Wr, Br), ai.return = Cr, ai;
      }
      function nr(Cr, Wr, Br, nn) {
        if (Wr === null || Wr.tag !== Et || Wr.stateNode.containerInfo !== Br.containerInfo || Wr.stateNode.implementation !== Br.implementation) {
          var Bn = nb(Br, Cr.mode, nn);
          return Bn.return = Cr, Bn;
        } else {
          var $n = st(Wr, Br.children || []);
          return $n.return = Cr, $n;
        }
      }
      function ar(Cr, Wr, Br, nn, Bn) {
        if (Wr === null || Wr.tag !== Mt) {
          var $n = Vl(Br, Cr.mode, nn, Bn);
          return $n.return = Cr, $n;
        } else {
          var ai = st(Wr, Br);
          return ai.return = Cr, ai;
        }
      }
      function xr(Cr, Wr, Br) {
        if (typeof Wr == "string" && Wr !== "" || typeof Wr == "number") {
          var nn = rb("" + Wr, Cr.mode, Br);
          return nn.return = Cr, nn;
        }
        if (typeof Wr == "object" && Wr !== null) {
          switch (Wr.$$typeof) {
            case pn: {
              var Bn = tb(Wr, Cr.mode, Br);
              return Bn.ref = w0(Cr, null, Wr), Bn.return = Cr, Bn;
            }
            case Yr: {
              var $n = nb(Wr, Cr.mode, Br);
              return $n.return = Cr, $n;
            }
            case Dn: {
              var ai = Wr._payload, li = Wr._init;
              return xr(Cr, li(ai), Br);
            }
          }
          if (Ei(Wr) || ra(Wr)) {
            var Hi = Vl(Wr, Cr.mode, Br, null);
            return Hi.return = Cr, Hi;
          }
          Hv(Cr, Wr);
        }
        return typeof Wr == "function" && jv(Cr), null;
      }
      function Er(Cr, Wr, Br, nn) {
        var Bn = Wr !== null ? Wr.key : null;
        if (typeof Br == "string" && Br !== "" || typeof Br == "number")
          return Bn !== null ? null : Nt(Cr, Wr, "" + Br, nn);
        if (typeof Br == "object" && Br !== null) {
          switch (Br.$$typeof) {
            case pn:
              return Br.key === Bn ? qt(Cr, Wr, Br, nn) : null;
            case Yr:
              return Br.key === Bn ? nr(Cr, Wr, Br, nn) : null;
            case Dn: {
              var $n = Br._payload, ai = Br._init;
              return Er(Cr, Wr, ai($n), nn);
            }
          }
          if (Ei(Br) || ra(Br))
            return Bn !== null ? null : ar(Cr, Wr, Br, nn, null);
          Hv(Cr, Br);
        }
        return typeof Br == "function" && jv(Cr), null;
      }
      function Or(Cr, Wr, Br, nn, Bn) {
        if (typeof nn == "string" && nn !== "" || typeof nn == "number") {
          var $n = Cr.get(Br) || null;
          return Nt(Wr, $n, "" + nn, Bn);
        }
        if (typeof nn == "object" && nn !== null) {
          switch (nn.$$typeof) {
            case pn: {
              var ai = Cr.get(nn.key === null ? Br : nn.key) || null;
              return qt(Wr, ai, nn, Bn);
            }
            case Yr: {
              var li = Cr.get(nn.key === null ? Br : nn.key) || null;
              return nr(Wr, li, nn, Bn);
            }
            case Dn:
              var Hi = nn._payload, ki = nn._init;
              return Or(Cr, Wr, Br, ki(Hi), Bn);
          }
          if (Ei(nn) || ra(nn)) {
            var Ra = Cr.get(Br) || null;
            return ar(Wr, Ra, nn, Bn, null);
          }
          Hv(Wr, nn);
        }
        return typeof nn == "function" && jv(Wr), null;
      }
      function Ur(Cr, Wr, Br) {
        {
          if (typeof Cr != "object" || Cr === null)
            return Wr;
          switch (Cr.$$typeof) {
            case pn:
            case Yr:
              aw(Cr, Br);
              var nn = Cr.key;
              if (typeof nn != "string")
                break;
              if (Wr === null) {
                Wr = /* @__PURE__ */ new Set(), Wr.add(nn);
                break;
              }
              if (!Wr.has(nn)) {
                Wr.add(nn);
                break;
              }
              Ce("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", nn);
              break;
            case Dn:
              var Bn = Cr._payload, $n = Cr._init;
              Ur($n(Bn), Wr, Br);
              break;
          }
        }
        return Wr;
      }
      function qr(Cr, Wr, Br, nn) {
        for (var Bn = null, $n = 0; $n < Br.length; $n++) {
          var ai = Br[$n];
          Bn = Ur(ai, Bn, Cr);
        }
        for (var li = null, Hi = null, ki = Wr, Ra = 0, Mi = 0, _a = null; ki !== null && Mi < Br.length; Mi++) {
          ki.index > Mi ? (_a = ki, ki = null) : _a = ki.sibling;
          var ko = Er(Cr, ki, Br[Mi], nn);
          if (ko === null) {
            ki === null && (ki = _a);
            break;
          }
          V && ki && ko.alternate === null && re(Cr, ki), Ra = bt(ko, Ra, Mi), Hi === null ? li = ko : Hi.sibling = ko, Hi = ko, ki = _a;
        }
        if (Mi === Br.length) {
          if (ke(Cr, ki), ao()) {
            var ho = Mi;
            Uc(Cr, ho);
          }
          return li;
        }
        if (ki === null) {
          for (; Mi < Br.length; Mi++) {
            var _s = xr(Cr, Br[Mi], nn);
            _s !== null && (Ra = bt(_s, Ra, Mi), Hi === null ? li = _s : Hi.sibling = _s, Hi = _s);
          }
          if (ao()) {
            var zo = Mi;
            Uc(Cr, zo);
          }
          return li;
        }
        for (var qo = Oe(Cr, ki); Mi < Br.length; Mi++) {
          var Mo = Or(qo, Cr, Mi, Br[Mi], nn);
          Mo !== null && (V && Mo.alternate !== null && qo.delete(Mo.key === null ? Mi : Mo.key), Ra = bt(Mo, Ra, Mi), Hi === null ? li = Mo : Hi.sibling = Mo, Hi = Mo);
        }
        if (V && qo.forEach(function(Xh) {
          return re(Cr, Xh);
        }), ao()) {
          var Of = Mi;
          Uc(Cr, Of);
        }
        return li;
      }
      function Sn(Cr, Wr, Br, nn) {
        var Bn = ra(Br);
        if (typeof Bn != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Br[Symbol.toStringTag] === "Generator" && (i2 || Ce("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), i2 = !0), Br.entries === Bn && (n2 || Ce("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), n2 = !0);
          var $n = Bn.call(Br);
          if ($n)
            for (var ai = null, li = $n.next(); !li.done; li = $n.next()) {
              var Hi = li.value;
              ai = Ur(Hi, ai, Cr);
            }
        }
        var ki = Bn.call(Br);
        if (ki == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Ra = null, Mi = null, _a = Wr, ko = 0, ho = 0, _s = null, zo = ki.next(); _a !== null && !zo.done; ho++, zo = ki.next()) {
          _a.index > ho ? (_s = _a, _a = null) : _s = _a.sibling;
          var qo = Er(Cr, _a, zo.value, nn);
          if (qo === null) {
            _a === null && (_a = _s);
            break;
          }
          V && _a && qo.alternate === null && re(Cr, _a), ko = bt(qo, ko, ho), Mi === null ? Ra = qo : Mi.sibling = qo, Mi = qo, _a = _s;
        }
        if (zo.done) {
          if (ke(Cr, _a), ao()) {
            var Mo = ho;
            Uc(Cr, Mo);
          }
          return Ra;
        }
        if (_a === null) {
          for (; !zo.done; ho++, zo = ki.next()) {
            var Of = xr(Cr, zo.value, nn);
            Of !== null && (ko = bt(Of, ko, ho), Mi === null ? Ra = Of : Mi.sibling = Of, Mi = Of);
          }
          if (ao()) {
            var Xh = ho;
            Uc(Cr, Xh);
          }
          return Ra;
        }
        for (var Q0 = Oe(Cr, _a); !zo.done; ho++, zo = ki.next()) {
          var Vu = Or(Q0, Cr, ho, zo.value, nn);
          Vu !== null && (V && Vu.alternate !== null && Q0.delete(Vu.key === null ? ho : Vu.key), ko = bt(Vu, ko, ho), Mi === null ? Ra = Vu : Mi.sibling = Vu, Mi = Vu);
        }
        if (V && Q0.forEach(function(I8) {
          return re(Cr, I8);
        }), ao()) {
          var P8 = ho;
          Uc(Cr, P8);
        }
        return Ra;
      }
      function Yn(Cr, Wr, Br, nn) {
        if (Wr !== null && Wr.tag === Rt) {
          ke(Cr, Wr.sibling);
          var Bn = st(Wr, Br);
          return Bn.return = Cr, Bn;
        }
        ke(Cr, Wr);
        var $n = rb(Br, Cr.mode, nn);
        return $n.return = Cr, $n;
      }
      function qn(Cr, Wr, Br, nn) {
        for (var Bn = Br.key, $n = Wr; $n !== null; ) {
          if ($n.key === Bn) {
            var ai = Br.type;
            if (ai === vn) {
              if ($n.tag === Mt) {
                ke(Cr, $n.sibling);
                var li = st($n, Br.props.children);
                return li.return = Cr, li._debugSource = Br._source, li._debugOwner = Br._owner, li;
              }
            } else if ($n.elementType === ai || // Keep this check inline so it only runs on the false path:
            d_($n, Br) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof ai == "object" && ai !== null && ai.$$typeof === Dn && ow(ai) === $n.type) {
              ke(Cr, $n.sibling);
              var Hi = st($n, Br.props);
              return Hi.ref = w0(Cr, $n, Br), Hi.return = Cr, Hi._debugSource = Br._source, Hi._debugOwner = Br._owner, Hi;
            }
            ke(Cr, $n);
            break;
          } else
            re(Cr, $n);
          $n = $n.sibling;
        }
        if (Br.type === vn) {
          var ki = Vl(Br.props.children, Cr.mode, nn, Br.key);
          return ki.return = Cr, ki;
        } else {
          var Ra = tb(Br, Cr.mode, nn);
          return Ra.ref = w0(Cr, Wr, Br), Ra.return = Cr, Ra;
        }
      }
      function xi(Cr, Wr, Br, nn) {
        for (var Bn = Br.key, $n = Wr; $n !== null; ) {
          if ($n.key === Bn)
            if ($n.tag === Et && $n.stateNode.containerInfo === Br.containerInfo && $n.stateNode.implementation === Br.implementation) {
              ke(Cr, $n.sibling);
              var ai = st($n, Br.children || []);
              return ai.return = Cr, ai;
            } else {
              ke(Cr, $n);
              break;
            }
          else
            re(Cr, $n);
          $n = $n.sibling;
        }
        var li = nb(Br, Cr.mode, nn);
        return li.return = Cr, li;
      }
      function wi(Cr, Wr, Br, nn) {
        var Bn = typeof Br == "object" && Br !== null && Br.type === vn && Br.key === null;
        if (Bn && (Br = Br.props.children), typeof Br == "object" && Br !== null) {
          switch (Br.$$typeof) {
            case pn:
              return Ct(qn(Cr, Wr, Br, nn));
            case Yr:
              return Ct(xi(Cr, Wr, Br, nn));
            case Dn:
              var $n = Br._payload, ai = Br._init;
              return wi(Cr, Wr, ai($n), nn);
          }
          if (Ei(Br))
            return qr(Cr, Wr, Br, nn);
          if (ra(Br))
            return Sn(Cr, Wr, Br, nn);
          Hv(Cr, Br);
        }
        return typeof Br == "string" && Br !== "" || typeof Br == "number" ? Ct(Yn(Cr, Wr, "" + Br, nn)) : (typeof Br == "function" && jv(Cr), ke(Cr, Wr));
      }
      return wi;
    }
    var Bh = sw(!0), uw = sw(!1);
    function f4(V, re) {
      if (V !== null && re.child !== V.child)
        throw new Error("Resuming work not yet implemented.");
      if (re.child !== null) {
        var ke = re.child, Oe = Qc(ke, ke.pendingProps);
        for (re.child = Oe, Oe.return = re; ke.sibling !== null; )
          ke = ke.sibling, Oe = Oe.sibling = Qc(ke, ke.pendingProps), Oe.return = re;
        Oe.sibling = null;
      }
    }
    function l4(V, re) {
      for (var ke = V.child; ke !== null; )
        Q5(ke, re), ke = ke.sibling;
    }
    var u2 = kl(null), f2;
    f2 = {};
    var zv = null, kh = null, l2 = null, qv = !1;
    function Wv() {
      zv = null, kh = null, l2 = null, qv = !1;
    }
    function fw() {
      qv = !0;
    }
    function lw() {
      qv = !1;
    }
    function cw(V, re, ke) {
      Co(u2, re._currentValue, V), re._currentValue = ke, re._currentRenderer !== void 0 && re._currentRenderer !== null && re._currentRenderer !== f2 && Ce("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), re._currentRenderer = f2;
    }
    function c2(V, re) {
      var ke = u2.current;
      Ro(u2, re), V._currentValue = ke;
    }
    function d2(V, re, ke) {
      for (var Oe = V; Oe !== null; ) {
        var st = Oe.alternate;
        if (pf(Oe.childLanes, re) ? st !== null && !pf(st.childLanes, re) && (st.childLanes = di(st.childLanes, re)) : (Oe.childLanes = di(Oe.childLanes, re), st !== null && (st.childLanes = di(st.childLanes, re))), Oe === ke)
          break;
        Oe = Oe.return;
      }
      Oe !== ke && Ce("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function c4(V, re, ke) {
      d4(V, re, ke);
    }
    function d4(V, re, ke) {
      var Oe = V.child;
      for (Oe !== null && (Oe.return = V); Oe !== null; ) {
        var st = void 0, bt = Oe.dependencies;
        if (bt !== null) {
          st = Oe.child;
          for (var Ct = bt.firstContext; Ct !== null; ) {
            if (Ct.context === re) {
              if (Oe.tag === ht) {
                var Nt = cl(ke), qt = Af(Vi, Nt);
                qt.tag = Vv;
                var nr = Oe.updateQueue;
                if (nr !== null) {
                  var ar = nr.shared, xr = ar.pending;
                  xr === null ? qt.next = qt : (qt.next = xr.next, xr.next = qt), ar.pending = qt;
                }
              }
              Oe.lanes = di(Oe.lanes, ke);
              var Er = Oe.alternate;
              Er !== null && (Er.lanes = di(Er.lanes, ke)), d2(Oe.return, ke, V), bt.lanes = di(bt.lanes, ke);
              break;
            }
            Ct = Ct.next;
          }
        } else if (Oe.tag === Ot)
          st = Oe.type === V.type ? null : Oe.child;
        else if (Oe.tag === er) {
          var Or = Oe.return;
          if (Or === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Or.lanes = di(Or.lanes, ke);
          var Ur = Or.alternate;
          Ur !== null && (Ur.lanes = di(Ur.lanes, ke)), d2(Or, ke, V), st = Oe.sibling;
        } else
          st = Oe.child;
        if (st !== null)
          st.return = Oe;
        else
          for (st = Oe; st !== null; ) {
            if (st === V) {
              st = null;
              break;
            }
            var qr = st.sibling;
            if (qr !== null) {
              qr.return = st.return, st = qr;
              break;
            }
            st = st.return;
          }
        Oe = st;
      }
    }
    function Mh(V, re) {
      zv = V, kh = null, l2 = null;
      var ke = V.dependencies;
      if (ke !== null) {
        var Oe = ke.firstContext;
        Oe !== null && (To(ke.lanes, re) && I0(), ke.firstContext = null);
      }
    }
    function Da(V) {
      qv && Ce("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var re = V._currentValue;
      if (l2 !== V) {
        var ke = {
          context: V,
          memoizedValue: re,
          next: null
        };
        if (kh === null) {
          if (zv === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          kh = ke, zv.dependencies = {
            lanes: Jr,
            firstContext: ke
          };
        } else
          kh = kh.next = ke;
      }
      return re;
    }
    var qc = null;
    function h2(V) {
      qc === null ? qc = [V] : qc.push(V);
    }
    function h4() {
      if (qc !== null) {
        for (var V = 0; V < qc.length; V++) {
          var re = qc[V], ke = re.interleaved;
          if (ke !== null) {
            re.interleaved = null;
            var Oe = ke.next, st = re.pending;
            if (st !== null) {
              var bt = st.next;
              st.next = Oe, ke.next = bt;
            }
            re.pending = ke;
          }
        }
        qc = null;
      }
    }
    function dw(V, re, ke, Oe) {
      var st = re.interleaved;
      return st === null ? (ke.next = ke, h2(re)) : (ke.next = st.next, st.next = ke), re.interleaved = ke, Kv(V, Oe);
    }
    function p4(V, re, ke, Oe) {
      var st = re.interleaved;
      st === null ? (ke.next = ke, h2(re)) : (ke.next = st.next, st.next = ke), re.interleaved = ke;
    }
    function v4(V, re, ke, Oe) {
      var st = re.interleaved;
      return st === null ? (ke.next = ke, h2(re)) : (ke.next = st.next, st.next = ke), re.interleaved = ke, Kv(V, Oe);
    }
    function us(V, re) {
      return Kv(V, re);
    }
    var y4 = Kv;
    function Kv(V, re) {
      V.lanes = di(V.lanes, re);
      var ke = V.alternate;
      ke !== null && (ke.lanes = di(ke.lanes, re)), ke === null && (V.flags & (Gi | Yo)) !== Xn && u_(V);
      for (var Oe = V, st = V.return; st !== null; )
        st.childLanes = di(st.childLanes, re), ke = st.alternate, ke !== null ? ke.childLanes = di(ke.childLanes, re) : (st.flags & (Gi | Yo)) !== Xn && u_(V), Oe = st, st = st.return;
      if (Oe.tag === lt) {
        var bt = Oe.stateNode;
        return bt;
      } else
        return null;
    }
    var hw = 0, pw = 1, Vv = 2, p2 = 3, Gv = !1, v2, Xv;
    v2 = !1, Xv = null;
    function y2(V) {
      var re = {
        baseState: V.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Jr
        },
        effects: null
      };
      V.updateQueue = re;
    }
    function vw(V, re) {
      var ke = re.updateQueue, Oe = V.updateQueue;
      if (ke === Oe) {
        var st = {
          baseState: Oe.baseState,
          firstBaseUpdate: Oe.firstBaseUpdate,
          lastBaseUpdate: Oe.lastBaseUpdate,
          shared: Oe.shared,
          effects: Oe.effects
        };
        re.updateQueue = st;
      }
    }
    function Af(V, re) {
      var ke = {
        eventTime: V,
        lane: re,
        tag: hw,
        payload: null,
        callback: null,
        next: null
      };
      return ke;
    }
    function Il(V, re, ke) {
      var Oe = V.updateQueue;
      if (Oe === null)
        return null;
      var st = Oe.shared;
      if (Xv === st && !v2 && (Ce("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), v2 = !0), v5()) {
        var bt = st.pending;
        return bt === null ? re.next = re : (re.next = bt.next, bt.next = re), st.pending = re, y4(V, ke);
      } else
        return v4(V, st, re, ke);
    }
    function Yv(V, re, ke) {
      var Oe = re.updateQueue;
      if (Oe !== null) {
        var st = Oe.shared;
        if (Ip(ke)) {
          var bt = st.lanes;
          bt = qd(bt, V.pendingLanes);
          var Ct = di(bt, ke);
          st.lanes = Ct, Dp(V, Ct);
        }
      }
    }
    function m2(V, re) {
      var ke = V.updateQueue, Oe = V.alternate;
      if (Oe !== null) {
        var st = Oe.updateQueue;
        if (ke === st) {
          var bt = null, Ct = null, Nt = ke.firstBaseUpdate;
          if (Nt !== null) {
            var qt = Nt;
            do {
              var nr = {
                eventTime: qt.eventTime,
                lane: qt.lane,
                tag: qt.tag,
                payload: qt.payload,
                callback: qt.callback,
                next: null
              };
              Ct === null ? bt = Ct = nr : (Ct.next = nr, Ct = nr), qt = qt.next;
            } while (qt !== null);
            Ct === null ? bt = Ct = re : (Ct.next = re, Ct = re);
          } else
            bt = Ct = re;
          ke = {
            baseState: st.baseState,
            firstBaseUpdate: bt,
            lastBaseUpdate: Ct,
            shared: st.shared,
            effects: st.effects
          }, V.updateQueue = ke;
          return;
        }
      }
      var ar = ke.lastBaseUpdate;
      ar === null ? ke.firstBaseUpdate = re : ar.next = re, ke.lastBaseUpdate = re;
    }
    function m4(V, re, ke, Oe, st, bt) {
      switch (ke.tag) {
        case pw: {
          var Ct = ke.payload;
          if (typeof Ct == "function") {
            fw();
            var Nt = Ct.call(bt, Oe, st);
            {
              if (V.mode & mi) {
                ba(!0);
                try {
                  Ct.call(bt, Oe, st);
                } finally {
                  ba(!1);
                }
              }
              lw();
            }
            return Nt;
          }
          return Ct;
        }
        case p2:
          V.flags = V.flags & ~Ma | oi;
        case hw: {
          var qt = ke.payload, nr;
          if (typeof qt == "function") {
            fw(), nr = qt.call(bt, Oe, st);
            {
              if (V.mode & mi) {
                ba(!0);
                try {
                  qt.call(bt, Oe, st);
                } finally {
                  ba(!1);
                }
              }
              lw();
            }
          } else
            nr = qt;
          return nr == null ? Oe : ii({}, Oe, nr);
        }
        case Vv:
          return Gv = !0, Oe;
      }
      return Oe;
    }
    function Jv(V, re, ke, Oe) {
      var st = V.updateQueue;
      Gv = !1, Xv = st.shared;
      var bt = st.firstBaseUpdate, Ct = st.lastBaseUpdate, Nt = st.shared.pending;
      if (Nt !== null) {
        st.shared.pending = null;
        var qt = Nt, nr = qt.next;
        qt.next = null, Ct === null ? bt = nr : Ct.next = nr, Ct = qt;
        var ar = V.alternate;
        if (ar !== null) {
          var xr = ar.updateQueue, Er = xr.lastBaseUpdate;
          Er !== Ct && (Er === null ? xr.firstBaseUpdate = nr : Er.next = nr, xr.lastBaseUpdate = qt);
        }
      }
      if (bt !== null) {
        var Or = st.baseState, Ur = Jr, qr = null, Sn = null, Yn = null, qn = bt;
        do {
          var xi = qn.lane, wi = qn.eventTime;
          if (pf(Oe, xi)) {
            if (Yn !== null) {
              var Wr = {
                eventTime: wi,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: wa,
                tag: qn.tag,
                payload: qn.payload,
                callback: qn.callback,
                next: null
              };
              Yn = Yn.next = Wr;
            }
            Or = m4(V, st, qn, Or, re, ke);
            var Br = qn.callback;
            if (Br !== null && // If the update was already committed, we should not queue its
            // callback again.
            qn.lane !== wa) {
              V.flags |= xs;
              var nn = st.effects;
              nn === null ? st.effects = [qn] : nn.push(qn);
            }
          } else {
            var Cr = {
              eventTime: wi,
              lane: xi,
              tag: qn.tag,
              payload: qn.payload,
              callback: qn.callback,
              next: null
            };
            Yn === null ? (Sn = Yn = Cr, qr = Or) : Yn = Yn.next = Cr, Ur = di(Ur, xi);
          }
          if (qn = qn.next, qn === null) {
            if (Nt = st.shared.pending, Nt === null)
              break;
            var Bn = Nt, $n = Bn.next;
            Bn.next = null, qn = $n, st.lastBaseUpdate = Bn, st.shared.pending = null;
          }
        } while (!0);
        Yn === null && (qr = Or), st.baseState = qr, st.firstBaseUpdate = Sn, st.lastBaseUpdate = Yn;
        var ai = st.shared.interleaved;
        if (ai !== null) {
          var li = ai;
          do
            Ur = di(Ur, li.lane), li = li.next;
          while (li !== ai);
        } else bt === null && (st.shared.lanes = Jr);
        V0(Ur), V.lanes = Ur, V.memoizedState = Or;
      }
      Xv = null;
    }
    function g4(V, re) {
      if (typeof V != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + V));
      V.call(re);
    }
    function yw() {
      Gv = !1;
    }
    function Qv() {
      return Gv;
    }
    function mw(V, re, ke) {
      var Oe = re.effects;
      if (re.effects = null, Oe !== null)
        for (var st = 0; st < Oe.length; st++) {
          var bt = Oe[st], Ct = bt.callback;
          Ct !== null && (bt.callback = null, g4(Ct, ke));
        }
    }
    var _0 = {}, Dl = kl(_0), S0 = kl(_0), Zv = kl(_0);
    function ey(V) {
      if (V === _0)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return V;
    }
    function gw() {
      var V = ey(Zv.current);
      return V;
    }
    function g2(V, re) {
      Co(Zv, re, V), Co(S0, V, V), Co(Dl, _0, V);
      var ke = I6(re);
      Ro(Dl, V), Co(Dl, ke, V);
    }
    function Oh(V) {
      Ro(Dl, V), Ro(S0, V), Ro(Zv, V);
    }
    function b2() {
      var V = ey(Dl.current);
      return V;
    }
    function bw(V) {
      ey(Zv.current);
      var re = ey(Dl.current), ke = D6(re, V.type);
      re !== ke && (Co(S0, V, V), Co(Dl, ke, V));
    }
    function w2(V) {
      S0.current === V && (Ro(Dl, V), Ro(S0, V));
    }
    var b4 = 0, ww = 1, _w = 1, E0 = 2, ou = kl(b4);
    function _2(V, re) {
      return (V & re) !== 0;
    }
    function Ph(V) {
      return V & ww;
    }
    function S2(V, re) {
      return V & ww | re;
    }
    function w4(V, re) {
      return V | re;
    }
    function Nl(V, re) {
      Co(ou, re, V);
    }
    function Ih(V) {
      Ro(ou, V);
    }
    function _4(V, re) {
      var ke = V.memoizedState;
      return ke !== null ? ke.dehydrated !== null : (V.memoizedProps, !0);
    }
    function ty(V) {
      for (var re = V; re !== null; ) {
        if (re.tag === Jt) {
          var ke = re.memoizedState;
          if (ke !== null) {
            var Oe = ke.dehydrated;
            if (Oe === null || Lb(Oe) || Fm(Oe))
              return re;
          }
        } else if (re.tag === Ht && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        re.memoizedProps.revealOrder !== void 0) {
          var st = (re.flags & oi) !== Xn;
          if (st)
            return re;
        } else if (re.child !== null) {
          re.child.return = re, re = re.child;
          continue;
        }
        if (re === V)
          return null;
        for (; re.sibling === null; ) {
          if (re.return === null || re.return === V)
            return null;
          re = re.return;
        }
        re.sibling.return = re.return, re = re.sibling;
      }
      return null;
    }
    var fs = (
      /*   */
      0
    ), Fa = (
      /* */
      1
    ), Fu = (
      /*  */
      2
    ), Ha = (
      /*    */
      4
    ), oo = (
      /*   */
      8
    ), E2 = [];
    function $2() {
      for (var V = 0; V < E2.length; V++) {
        var re = E2[V];
        re._workInProgressVersionPrimary = null;
      }
      E2.length = 0;
    }
    function S4(V, re) {
      var ke = re._getVersion, Oe = ke(re._source);
      V.mutableSourceEagerHydrationData == null ? V.mutableSourceEagerHydrationData = [re, Oe] : V.mutableSourceEagerHydrationData.push(re, Oe);
    }
    var Rn = J.ReactCurrentDispatcher, $0 = J.ReactCurrentBatchConfig, x2, Dh;
    x2 = /* @__PURE__ */ new Set();
    var Wc = Jr, Fi = null, ja = null, za = null, ry = !1, x0 = !1, T0 = 0, E4 = 0, $4 = 25, Gr = null, Ps = null, Ll = -1, T2 = !1;
    function Ni() {
      {
        var V = Gr;
        Ps === null ? Ps = [V] : Ps.push(V);
      }
    }
    function mn() {
      {
        var V = Gr;
        Ps !== null && (Ll++, Ps[Ll] !== V && x4(V));
      }
    }
    function Nh(V) {
      V != null && !Ei(V) && Ce("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Gr, typeof V);
    }
    function x4(V) {
      {
        var re = ui(Fi);
        if (!x2.has(re) && (x2.add(re), Ps !== null)) {
          for (var ke = "", Oe = 30, st = 0; st <= Ll; st++) {
            for (var bt = Ps[st], Ct = st === Ll ? V : bt, Nt = st + 1 + ". " + bt; Nt.length < Oe; )
              Nt += " ";
            Nt += Ct + `
`, ke += Nt;
          }
          Ce(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, re, ke);
        }
      }
    }
    function Bo() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function A2(V, re) {
      if (T2)
        return !1;
      if (re === null)
        return Ce("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Gr), !1;
      V.length !== re.length && Ce(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Gr, "[" + re.join(", ") + "]", "[" + V.join(", ") + "]");
      for (var ke = 0; ke < re.length && ke < V.length; ke++)
        if (!Ln(V[ke], re[ke]))
          return !1;
      return !0;
    }
    function Lh(V, re, ke, Oe, st, bt) {
      Wc = bt, Fi = re, Ps = V !== null ? V._debugHookTypes : null, Ll = -1, T2 = V !== null && V.type !== re.type, re.memoizedState = null, re.updateQueue = null, re.lanes = Jr, V !== null && V.memoizedState !== null ? Rn.current = zw : Ps !== null ? Rn.current = jw : Rn.current = Hw;
      var Ct = ke(Oe, st);
      if (x0) {
        var Nt = 0;
        do {
          if (x0 = !1, T0 = 0, Nt >= $4)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          Nt += 1, T2 = !1, ja = null, za = null, re.updateQueue = null, Ll = -1, Rn.current = qw, Ct = ke(Oe, st);
        } while (x0);
      }
      Rn.current = vy, re._debugHookTypes = Ps;
      var qt = ja !== null && ja.next !== null;
      if (Wc = Jr, Fi = null, ja = null, za = null, Gr = null, Ps = null, Ll = -1, V !== null && (V.flags & Na) !== (re.flags & Na) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (V.mode & zn) !== Hn && Ce("Internal React error: Expected static flag was missing. Please notify the React team."), ry = !1, qt)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return Ct;
    }
    function Uh() {
      var V = T0 !== 0;
      return T0 = 0, V;
    }
    function Sw(V, re, ke) {
      re.updateQueue = V.updateQueue, (re.mode & Lo) !== Hn ? re.flags &= ~(af | wo | Zi | hi) : re.flags &= ~(Zi | hi), V.lanes = Sc(V.lanes, ke);
    }
    function Ew() {
      if (Rn.current = vy, ry) {
        for (var V = Fi.memoizedState; V !== null; ) {
          var re = V.queue;
          re !== null && (re.pending = null), V = V.next;
        }
        ry = !1;
      }
      Wc = Jr, Fi = null, ja = null, za = null, Ps = null, Ll = -1, Gr = null, Dw = !1, x0 = !1, T0 = 0;
    }
    function Hu() {
      var V = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return za === null ? Fi.memoizedState = za = V : za = za.next = V, za;
    }
    function Is() {
      var V;
      if (ja === null) {
        var re = Fi.alternate;
        re !== null ? V = re.memoizedState : V = null;
      } else
        V = ja.next;
      var ke;
      if (za === null ? ke = Fi.memoizedState : ke = za.next, ke !== null)
        za = ke, ke = za.next, ja = V;
      else {
        if (V === null)
          throw new Error("Rendered more hooks than during the previous render.");
        ja = V;
        var Oe = {
          memoizedState: ja.memoizedState,
          baseState: ja.baseState,
          baseQueue: ja.baseQueue,
          queue: ja.queue,
          next: null
        };
        za === null ? Fi.memoizedState = za = Oe : za = za.next = Oe;
      }
      return za;
    }
    function $w() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function R2(V, re) {
      return typeof re == "function" ? re(V) : re;
    }
    function C2(V, re, ke) {
      var Oe = Hu(), st;
      ke !== void 0 ? st = ke(re) : st = re, Oe.memoizedState = Oe.baseState = st;
      var bt = {
        pending: null,
        interleaved: null,
        lanes: Jr,
        dispatch: null,
        lastRenderedReducer: V,
        lastRenderedState: st
      };
      Oe.queue = bt;
      var Ct = bt.dispatch = C4.bind(null, Fi, bt);
      return [Oe.memoizedState, Ct];
    }
    function B2(V, re, ke) {
      var Oe = Is(), st = Oe.queue;
      if (st === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      st.lastRenderedReducer = V;
      var bt = ja, Ct = bt.baseQueue, Nt = st.pending;
      if (Nt !== null) {
        if (Ct !== null) {
          var qt = Ct.next, nr = Nt.next;
          Ct.next = nr, Nt.next = qt;
        }
        bt.baseQueue !== Ct && Ce("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), bt.baseQueue = Ct = Nt, st.pending = null;
      }
      if (Ct !== null) {
        var ar = Ct.next, xr = bt.baseState, Er = null, Or = null, Ur = null, qr = ar;
        do {
          var Sn = qr.lane;
          if (pf(Wc, Sn)) {
            if (Ur !== null) {
              var qn = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: wa,
                action: qr.action,
                hasEagerState: qr.hasEagerState,
                eagerState: qr.eagerState,
                next: null
              };
              Ur = Ur.next = qn;
            }
            if (qr.hasEagerState)
              xr = qr.eagerState;
            else {
              var xi = qr.action;
              xr = V(xr, xi);
            }
          } else {
            var Yn = {
              lane: Sn,
              action: qr.action,
              hasEagerState: qr.hasEagerState,
              eagerState: qr.eagerState,
              next: null
            };
            Ur === null ? (Or = Ur = Yn, Er = xr) : Ur = Ur.next = Yn, Fi.lanes = di(Fi.lanes, Sn), V0(Sn);
          }
          qr = qr.next;
        } while (qr !== null && qr !== ar);
        Ur === null ? Er = xr : Ur.next = Or, Ln(xr, Oe.memoizedState) || I0(), Oe.memoizedState = xr, Oe.baseState = Er, Oe.baseQueue = Ur, st.lastRenderedState = xr;
      }
      var wi = st.interleaved;
      if (wi !== null) {
        var Cr = wi;
        do {
          var Wr = Cr.lane;
          Fi.lanes = di(Fi.lanes, Wr), V0(Wr), Cr = Cr.next;
        } while (Cr !== wi);
      } else Ct === null && (st.lanes = Jr);
      var Br = st.dispatch;
      return [Oe.memoizedState, Br];
    }
    function k2(V, re, ke) {
      var Oe = Is(), st = Oe.queue;
      if (st === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      st.lastRenderedReducer = V;
      var bt = st.dispatch, Ct = st.pending, Nt = Oe.memoizedState;
      if (Ct !== null) {
        st.pending = null;
        var qt = Ct.next, nr = qt;
        do {
          var ar = nr.action;
          Nt = V(Nt, ar), nr = nr.next;
        } while (nr !== qt);
        Ln(Nt, Oe.memoizedState) || I0(), Oe.memoizedState = Nt, Oe.baseQueue === null && (Oe.baseState = Nt), st.lastRenderedState = Nt;
      }
      return [Nt, bt];
    }
    function U8(V, re, ke) {
    }
    function F8(V, re, ke) {
    }
    function M2(V, re, ke) {
      var Oe = Fi, st = Hu(), bt, Ct = ao();
      if (Ct) {
        if (ke === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        bt = ke(), Dh || bt !== ke() && (Ce("The result of getServerSnapshot should be cached to avoid an infinite loop"), Dh = !0);
      } else {
        if (bt = re(), !Dh) {
          var Nt = re();
          Ln(bt, Nt) || (Ce("The result of getSnapshot should be cached to avoid an infinite loop"), Dh = !0);
        }
        var qt = Py();
        if (qt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        _c(qt, Wc) || xw(Oe, re, bt);
      }
      st.memoizedState = bt;
      var nr = {
        value: bt,
        getSnapshot: re
      };
      return st.queue = nr, sy(Aw.bind(null, Oe, nr, V), [V]), Oe.flags |= Zi, A0(Fa | oo, Tw.bind(null, Oe, nr, bt, re), void 0, null), bt;
    }
    function ny(V, re, ke) {
      var Oe = Fi, st = Is(), bt = re();
      if (!Dh) {
        var Ct = re();
        Ln(bt, Ct) || (Ce("The result of getSnapshot should be cached to avoid an infinite loop"), Dh = !0);
      }
      var Nt = st.memoizedState, qt = !Ln(Nt, bt);
      qt && (st.memoizedState = bt, I0());
      var nr = st.queue;
      if (C0(Aw.bind(null, Oe, nr, V), [V]), nr.getSnapshot !== re || qt || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      za !== null && za.memoizedState.tag & Fa) {
        Oe.flags |= Zi, A0(Fa | oo, Tw.bind(null, Oe, nr, bt, re), void 0, null);
        var ar = Py();
        if (ar === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        _c(ar, Wc) || xw(Oe, re, bt);
      }
      return bt;
    }
    function xw(V, re, ke) {
      V.flags |= cc;
      var Oe = {
        getSnapshot: re,
        value: ke
      }, st = Fi.updateQueue;
      if (st === null)
        st = $w(), Fi.updateQueue = st, st.stores = [Oe];
      else {
        var bt = st.stores;
        bt === null ? st.stores = [Oe] : bt.push(Oe);
      }
    }
    function Tw(V, re, ke, Oe) {
      re.value = ke, re.getSnapshot = Oe, Rw(re) && Cw(V);
    }
    function Aw(V, re, ke) {
      var Oe = function() {
        Rw(re) && Cw(V);
      };
      return ke(Oe);
    }
    function Rw(V) {
      var re = V.getSnapshot, ke = V.value;
      try {
        var Oe = re();
        return !Ln(ke, Oe);
      } catch {
        return !0;
      }
    }
    function Cw(V) {
      var re = us(V, Vn);
      re !== null && Va(re, V, Vn, Vi);
    }
    function iy(V) {
      var re = Hu();
      typeof V == "function" && (V = V()), re.memoizedState = re.baseState = V;
      var ke = {
        pending: null,
        interleaved: null,
        lanes: Jr,
        dispatch: null,
        lastRenderedReducer: R2,
        lastRenderedState: V
      };
      re.queue = ke;
      var Oe = ke.dispatch = B4.bind(null, Fi, ke);
      return [re.memoizedState, Oe];
    }
    function O2(V) {
      return B2(R2);
    }
    function P2(V) {
      return k2(R2);
    }
    function A0(V, re, ke, Oe) {
      var st = {
        tag: V,
        create: re,
        destroy: ke,
        deps: Oe,
        // Circular
        next: null
      }, bt = Fi.updateQueue;
      if (bt === null)
        bt = $w(), Fi.updateQueue = bt, bt.lastEffect = st.next = st;
      else {
        var Ct = bt.lastEffect;
        if (Ct === null)
          bt.lastEffect = st.next = st;
        else {
          var Nt = Ct.next;
          Ct.next = st, st.next = Nt, bt.lastEffect = st;
        }
      }
      return st;
    }
    function I2(V) {
      var re = Hu();
      {
        var ke = {
          current: V
        };
        return re.memoizedState = ke, ke;
      }
    }
    function ay(V) {
      var re = Is();
      return re.memoizedState;
    }
    function R0(V, re, ke, Oe) {
      var st = Hu(), bt = Oe === void 0 ? null : Oe;
      Fi.flags |= V, st.memoizedState = A0(Fa | re, ke, void 0, bt);
    }
    function oy(V, re, ke, Oe) {
      var st = Is(), bt = Oe === void 0 ? null : Oe, Ct = void 0;
      if (ja !== null) {
        var Nt = ja.memoizedState;
        if (Ct = Nt.destroy, bt !== null) {
          var qt = Nt.deps;
          if (A2(bt, qt)) {
            st.memoizedState = A0(re, ke, Ct, bt);
            return;
          }
        }
      }
      Fi.flags |= V, st.memoizedState = A0(Fa | re, ke, Ct, bt);
    }
    function sy(V, re) {
      return (Fi.mode & Lo) !== Hn ? R0(af | Zi | Ru, oo, V, re) : R0(Zi | Ru, oo, V, re);
    }
    function C0(V, re) {
      return oy(Zi, oo, V, re);
    }
    function D2(V, re) {
      return R0(hi, Fu, V, re);
    }
    function uy(V, re) {
      return oy(hi, Fu, V, re);
    }
    function N2(V, re) {
      var ke = hi;
      return ke |= bo, (Fi.mode & Lo) !== Hn && (ke |= wo), R0(ke, Ha, V, re);
    }
    function fy(V, re) {
      return oy(hi, Ha, V, re);
    }
    function Bw(V, re) {
      if (typeof re == "function") {
        var ke = re, Oe = V();
        return ke(Oe), function() {
          ke(null);
        };
      } else if (re != null) {
        var st = re;
        st.hasOwnProperty("current") || Ce("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(st).join(", ") + "}");
        var bt = V();
        return st.current = bt, function() {
          st.current = null;
        };
      }
    }
    function L2(V, re, ke) {
      typeof re != "function" && Ce("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", re !== null ? typeof re : "null");
      var Oe = ke != null ? ke.concat([V]) : null, st = hi;
      return st |= bo, (Fi.mode & Lo) !== Hn && (st |= wo), R0(st, Ha, Bw.bind(null, re, V), Oe);
    }
    function ly(V, re, ke) {
      typeof re != "function" && Ce("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", re !== null ? typeof re : "null");
      var Oe = ke != null ? ke.concat([V]) : null;
      return oy(hi, Ha, Bw.bind(null, re, V), Oe);
    }
    function T4(V, re) {
    }
    var cy = T4;
    function U2(V, re) {
      var ke = Hu(), Oe = re === void 0 ? null : re;
      return ke.memoizedState = [V, Oe], V;
    }
    function dy(V, re) {
      var ke = Is(), Oe = re === void 0 ? null : re, st = ke.memoizedState;
      if (st !== null && Oe !== null) {
        var bt = st[1];
        if (A2(Oe, bt))
          return st[0];
      }
      return ke.memoizedState = [V, Oe], V;
    }
    function F2(V, re) {
      var ke = Hu(), Oe = re === void 0 ? null : re, st = V();
      return ke.memoizedState = [st, Oe], st;
    }
    function hy(V, re) {
      var ke = Is(), Oe = re === void 0 ? null : re, st = ke.memoizedState;
      if (st !== null && Oe !== null) {
        var bt = st[1];
        if (A2(Oe, bt))
          return st[0];
      }
      var Ct = V();
      return ke.memoizedState = [Ct, Oe], Ct;
    }
    function H2(V) {
      var re = Hu();
      return re.memoizedState = V, V;
    }
    function kw(V) {
      var re = Is(), ke = ja, Oe = ke.memoizedState;
      return Ow(re, Oe, V);
    }
    function Mw(V) {
      var re = Is();
      if (ja === null)
        return re.memoizedState = V, V;
      var ke = ja.memoizedState;
      return Ow(re, ke, V);
    }
    function Ow(V, re, ke) {
      var Oe = !z1(Wc);
      if (Oe) {
        if (!Ln(ke, re)) {
          var st = K1();
          Fi.lanes = di(Fi.lanes, st), V0(st), V.baseState = !0;
        }
        return re;
      } else
        return V.baseState && (V.baseState = !1, I0()), V.memoizedState = ke, ke;
    }
    function A4(V, re, ke) {
      var Oe = rs();
      la(sm(Oe, Zs)), V(!0);
      var st = $0.transition;
      $0.transition = {};
      var bt = $0.transition;
      $0.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        V(!1), re();
      } finally {
        if (la(Oe), $0.transition = st, st === null && bt._updatedFibers) {
          var Ct = bt._updatedFibers.size;
          Ct > 10 && ce("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), bt._updatedFibers.clear();
        }
      }
    }
    function j2() {
      var V = iy(!1), re = V[0], ke = V[1], Oe = A4.bind(null, ke), st = Hu();
      return st.memoizedState = Oe, [re, Oe];
    }
    function Pw() {
      var V = O2(), re = V[0], ke = Is(), Oe = ke.memoizedState;
      return [re, Oe];
    }
    function Iw() {
      var V = P2(), re = V[0], ke = Is(), Oe = ke.memoizedState;
      return [re, Oe];
    }
    var Dw = !1;
    function R4() {
      return Dw;
    }
    function z2() {
      var V = Hu(), re = Py(), ke = re.identifierPrefix, Oe;
      if (ao()) {
        var st = WS();
        Oe = ":" + ke + "R" + st;
        var bt = T0++;
        bt > 0 && (Oe += "H" + bt.toString(32)), Oe += ":";
      } else {
        var Ct = E4++;
        Oe = ":" + ke + "r" + Ct.toString(32) + ":";
      }
      return V.memoizedState = Oe, Oe;
    }
    function py() {
      var V = Is(), re = V.memoizedState;
      return re;
    }
    function C4(V, re, ke) {
      typeof arguments[3] == "function" && Ce("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Oe = ql(V), st = {
        lane: Oe,
        action: ke,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Nw(V))
        Lw(re, st);
      else {
        var bt = dw(V, re, st, Oe);
        if (bt !== null) {
          var Ct = jo();
          Va(bt, V, Oe, Ct), Uw(bt, re, Oe);
        }
      }
      Fw(V, Oe);
    }
    function B4(V, re, ke) {
      typeof arguments[3] == "function" && Ce("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var Oe = ql(V), st = {
        lane: Oe,
        action: ke,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Nw(V))
        Lw(re, st);
      else {
        var bt = V.alternate;
        if (V.lanes === Jr && (bt === null || bt.lanes === Jr)) {
          var Ct = re.lastRenderedReducer;
          if (Ct !== null) {
            var Nt;
            Nt = Rn.current, Rn.current = su;
            try {
              var qt = re.lastRenderedState, nr = Ct(qt, ke);
              if (st.hasEagerState = !0, st.eagerState = nr, Ln(nr, qt)) {
                p4(V, re, st, Oe);
                return;
              }
            } catch {
            } finally {
              Rn.current = Nt;
            }
          }
        }
        var ar = dw(V, re, st, Oe);
        if (ar !== null) {
          var xr = jo();
          Va(ar, V, Oe, xr), Uw(ar, re, Oe);
        }
      }
      Fw(V, Oe);
    }
    function Nw(V) {
      var re = V.alternate;
      return V === Fi || re !== null && re === Fi;
    }
    function Lw(V, re) {
      x0 = ry = !0;
      var ke = V.pending;
      ke === null ? re.next = re : (re.next = ke.next, ke.next = re), V.pending = re;
    }
    function Uw(V, re, ke) {
      if (Ip(ke)) {
        var Oe = re.lanes;
        Oe = qd(Oe, V.pendingLanes);
        var st = di(Oe, ke);
        re.lanes = st, Dp(V, st);
      }
    }
    function Fw(V, re, ke) {
      vc(V, re);
    }
    var vy = {
      readContext: Da,
      useCallback: Bo,
      useContext: Bo,
      useEffect: Bo,
      useImperativeHandle: Bo,
      useInsertionEffect: Bo,
      useLayoutEffect: Bo,
      useMemo: Bo,
      useReducer: Bo,
      useRef: Bo,
      useState: Bo,
      useDebugValue: Bo,
      useDeferredValue: Bo,
      useTransition: Bo,
      useMutableSource: Bo,
      useSyncExternalStore: Bo,
      useId: Bo,
      unstable_isNewReconciler: St
    }, Hw = null, jw = null, zw = null, qw = null, ju = null, su = null, yy = null;
    {
      var q2 = function() {
        Ce("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, fi = function() {
        Ce("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Hw = {
        readContext: function(V) {
          return Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", Ni(), Nh(re), U2(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", Ni(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", Ni(), Nh(re), sy(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", Ni(), Nh(ke), L2(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", Ni(), Nh(re), D2(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", Ni(), Nh(re), N2(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", Ni(), Nh(re);
          var ke = Rn.current;
          Rn.current = ju;
          try {
            return F2(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", Ni();
          var Oe = Rn.current;
          Rn.current = ju;
          try {
            return C2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", Ni(), I2(V);
        },
        useState: function(V) {
          Gr = "useState", Ni();
          var re = Rn.current;
          Rn.current = ju;
          try {
            return iy(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", Ni(), void 0;
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", Ni(), H2(V);
        },
        useTransition: function() {
          return Gr = "useTransition", Ni(), j2();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", Ni(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", Ni(), M2(V, re, ke);
        },
        useId: function() {
          return Gr = "useId", Ni(), z2();
        },
        unstable_isNewReconciler: St
      }, jw = {
        readContext: function(V) {
          return Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", mn(), U2(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", mn(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", mn(), sy(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", mn(), L2(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", mn(), D2(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", mn(), N2(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", mn();
          var ke = Rn.current;
          Rn.current = ju;
          try {
            return F2(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", mn();
          var Oe = Rn.current;
          Rn.current = ju;
          try {
            return C2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", mn(), I2(V);
        },
        useState: function(V) {
          Gr = "useState", mn();
          var re = Rn.current;
          Rn.current = ju;
          try {
            return iy(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", mn(), void 0;
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", mn(), H2(V);
        },
        useTransition: function() {
          return Gr = "useTransition", mn(), j2();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", mn(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", mn(), M2(V, re, ke);
        },
        useId: function() {
          return Gr = "useId", mn(), z2();
        },
        unstable_isNewReconciler: St
      }, zw = {
        readContext: function(V) {
          return Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", mn(), dy(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", mn(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", mn(), C0(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", mn(), ly(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", mn(), uy(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", mn(), fy(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", mn();
          var ke = Rn.current;
          Rn.current = su;
          try {
            return hy(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", mn();
          var Oe = Rn.current;
          Rn.current = su;
          try {
            return B2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", mn(), ay();
        },
        useState: function(V) {
          Gr = "useState", mn();
          var re = Rn.current;
          Rn.current = su;
          try {
            return O2(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", mn(), cy();
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", mn(), kw(V);
        },
        useTransition: function() {
          return Gr = "useTransition", mn(), Pw();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", mn(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", mn(), ny(V, re);
        },
        useId: function() {
          return Gr = "useId", mn(), py();
        },
        unstable_isNewReconciler: St
      }, qw = {
        readContext: function(V) {
          return Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", mn(), dy(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", mn(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", mn(), C0(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", mn(), ly(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", mn(), uy(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", mn(), fy(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", mn();
          var ke = Rn.current;
          Rn.current = yy;
          try {
            return hy(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", mn();
          var Oe = Rn.current;
          Rn.current = yy;
          try {
            return k2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", mn(), ay();
        },
        useState: function(V) {
          Gr = "useState", mn();
          var re = Rn.current;
          Rn.current = yy;
          try {
            return P2(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", mn(), cy();
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", mn(), Mw(V);
        },
        useTransition: function() {
          return Gr = "useTransition", mn(), Iw();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", mn(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", mn(), ny(V, re);
        },
        useId: function() {
          return Gr = "useId", mn(), py();
        },
        unstable_isNewReconciler: St
      }, ju = {
        readContext: function(V) {
          return q2(), Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", fi(), Ni(), U2(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", fi(), Ni(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", fi(), Ni(), sy(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", fi(), Ni(), L2(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", fi(), Ni(), D2(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", fi(), Ni(), N2(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", fi(), Ni();
          var ke = Rn.current;
          Rn.current = ju;
          try {
            return F2(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", fi(), Ni();
          var Oe = Rn.current;
          Rn.current = ju;
          try {
            return C2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", fi(), Ni(), I2(V);
        },
        useState: function(V) {
          Gr = "useState", fi(), Ni();
          var re = Rn.current;
          Rn.current = ju;
          try {
            return iy(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", fi(), Ni(), void 0;
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", fi(), Ni(), H2(V);
        },
        useTransition: function() {
          return Gr = "useTransition", fi(), Ni(), j2();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", fi(), Ni(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", fi(), Ni(), M2(V, re, ke);
        },
        useId: function() {
          return Gr = "useId", fi(), Ni(), z2();
        },
        unstable_isNewReconciler: St
      }, su = {
        readContext: function(V) {
          return q2(), Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", fi(), mn(), dy(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", fi(), mn(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", fi(), mn(), C0(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", fi(), mn(), ly(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", fi(), mn(), uy(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", fi(), mn(), fy(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", fi(), mn();
          var ke = Rn.current;
          Rn.current = su;
          try {
            return hy(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", fi(), mn();
          var Oe = Rn.current;
          Rn.current = su;
          try {
            return B2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", fi(), mn(), ay();
        },
        useState: function(V) {
          Gr = "useState", fi(), mn();
          var re = Rn.current;
          Rn.current = su;
          try {
            return O2(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", fi(), mn(), cy();
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", fi(), mn(), kw(V);
        },
        useTransition: function() {
          return Gr = "useTransition", fi(), mn(), Pw();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", fi(), mn(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", fi(), mn(), ny(V, re);
        },
        useId: function() {
          return Gr = "useId", fi(), mn(), py();
        },
        unstable_isNewReconciler: St
      }, yy = {
        readContext: function(V) {
          return q2(), Da(V);
        },
        useCallback: function(V, re) {
          return Gr = "useCallback", fi(), mn(), dy(V, re);
        },
        useContext: function(V) {
          return Gr = "useContext", fi(), mn(), Da(V);
        },
        useEffect: function(V, re) {
          return Gr = "useEffect", fi(), mn(), C0(V, re);
        },
        useImperativeHandle: function(V, re, ke) {
          return Gr = "useImperativeHandle", fi(), mn(), ly(V, re, ke);
        },
        useInsertionEffect: function(V, re) {
          return Gr = "useInsertionEffect", fi(), mn(), uy(V, re);
        },
        useLayoutEffect: function(V, re) {
          return Gr = "useLayoutEffect", fi(), mn(), fy(V, re);
        },
        useMemo: function(V, re) {
          Gr = "useMemo", fi(), mn();
          var ke = Rn.current;
          Rn.current = su;
          try {
            return hy(V, re);
          } finally {
            Rn.current = ke;
          }
        },
        useReducer: function(V, re, ke) {
          Gr = "useReducer", fi(), mn();
          var Oe = Rn.current;
          Rn.current = su;
          try {
            return k2(V, re, ke);
          } finally {
            Rn.current = Oe;
          }
        },
        useRef: function(V) {
          return Gr = "useRef", fi(), mn(), ay();
        },
        useState: function(V) {
          Gr = "useState", fi(), mn();
          var re = Rn.current;
          Rn.current = su;
          try {
            return P2(V);
          } finally {
            Rn.current = re;
          }
        },
        useDebugValue: function(V, re) {
          return Gr = "useDebugValue", fi(), mn(), cy();
        },
        useDeferredValue: function(V) {
          return Gr = "useDeferredValue", fi(), mn(), Mw(V);
        },
        useTransition: function() {
          return Gr = "useTransition", fi(), mn(), Iw();
        },
        useMutableSource: function(V, re, ke) {
          return Gr = "useMutableSource", fi(), mn(), void 0;
        },
        useSyncExternalStore: function(V, re, ke) {
          return Gr = "useSyncExternalStore", fi(), mn(), ny(V, re);
        },
        useId: function() {
          return Gr = "useId", fi(), mn(), py();
        },
        unstable_isNewReconciler: St
      };
    }
    var Ul = L.unstable_now, Ww = 0, my = -1, B0 = -1, gy = -1, W2 = !1, by = !1;
    function Kw() {
      return W2;
    }
    function k4() {
      by = !0;
    }
    function M4() {
      W2 = !1, by = !1;
    }
    function O4() {
      W2 = by, by = !1;
    }
    function Vw() {
      return Ww;
    }
    function Gw() {
      Ww = Ul();
    }
    function K2(V) {
      B0 = Ul(), V.actualStartTime < 0 && (V.actualStartTime = Ul());
    }
    function Xw(V) {
      B0 = -1;
    }
    function wy(V, re) {
      if (B0 >= 0) {
        var ke = Ul() - B0;
        V.actualDuration += ke, re && (V.selfBaseDuration = ke), B0 = -1;
      }
    }
    function zu(V) {
      if (my >= 0) {
        var re = Ul() - my;
        my = -1;
        for (var ke = V.return; ke !== null; ) {
          switch (ke.tag) {
            case lt:
              var Oe = ke.stateNode;
              Oe.effectDuration += re;
              return;
            case Ft:
              var st = ke.stateNode;
              st.effectDuration += re;
              return;
          }
          ke = ke.return;
        }
      }
    }
    function V2(V) {
      if (gy >= 0) {
        var re = Ul() - gy;
        gy = -1;
        for (var ke = V.return; ke !== null; ) {
          switch (ke.tag) {
            case lt:
              var Oe = ke.stateNode;
              Oe !== null && (Oe.passiveEffectDuration += re);
              return;
            case Ft:
              var st = ke.stateNode;
              st !== null && (st.passiveEffectDuration += re);
              return;
          }
          ke = ke.return;
        }
      }
    }
    function qu() {
      my = Ul();
    }
    function G2() {
      gy = Ul();
    }
    function X2(V) {
      for (var re = V.child; re; )
        V.actualDuration += re.actualDuration, re = re.sibling;
    }
    function uu(V, re) {
      if (V && V.defaultProps) {
        var ke = ii({}, re), Oe = V.defaultProps;
        for (var st in Oe)
          ke[st] === void 0 && (ke[st] = Oe[st]);
        return ke;
      }
      return re;
    }
    var Y2 = {}, J2, Q2, Z2, eg, tg, Yw, _y, rg, ng, ig, k0;
    {
      J2 = /* @__PURE__ */ new Set(), Q2 = /* @__PURE__ */ new Set(), Z2 = /* @__PURE__ */ new Set(), eg = /* @__PURE__ */ new Set(), rg = /* @__PURE__ */ new Set(), tg = /* @__PURE__ */ new Set(), ng = /* @__PURE__ */ new Set(), ig = /* @__PURE__ */ new Set(), k0 = /* @__PURE__ */ new Set();
      var Jw = /* @__PURE__ */ new Set();
      _y = function(V, re) {
        if (!(V === null || typeof V == "function")) {
          var ke = re + "_" + V;
          Jw.has(ke) || (Jw.add(ke), Ce("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", re, V));
        }
      }, Yw = function(V, re) {
        if (re === void 0) {
          var ke = Si(V) || "Component";
          tg.has(ke) || (tg.add(ke), Ce("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ke));
        }
      }, Object.defineProperty(Y2, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Y2);
    }
    function ag(V, re, ke, Oe) {
      var st = V.memoizedState, bt = ke(Oe, st);
      {
        if (V.mode & mi) {
          ba(!0);
          try {
            bt = ke(Oe, st);
          } finally {
            ba(!1);
          }
        }
        Yw(re, bt);
      }
      var Ct = bt == null ? st : ii({}, st, bt);
      if (V.memoizedState = Ct, V.lanes === Jr) {
        var Nt = V.updateQueue;
        Nt.baseState = Ct;
      }
    }
    var og = {
      isMounted: Do,
      enqueueSetState: function(V, re, ke) {
        var Oe = Go(V), st = jo(), bt = ql(Oe), Ct = Af(st, bt);
        Ct.payload = re, ke != null && (_y(ke, "setState"), Ct.callback = ke);
        var Nt = Il(Oe, Ct, bt);
        Nt !== null && (Va(Nt, Oe, bt, st), Yv(Nt, Oe, bt)), vc(Oe, bt);
      },
      enqueueReplaceState: function(V, re, ke) {
        var Oe = Go(V), st = jo(), bt = ql(Oe), Ct = Af(st, bt);
        Ct.tag = pw, Ct.payload = re, ke != null && (_y(ke, "replaceState"), Ct.callback = ke);
        var Nt = Il(Oe, Ct, bt);
        Nt !== null && (Va(Nt, Oe, bt, st), Yv(Nt, Oe, bt)), vc(Oe, bt);
      },
      enqueueForceUpdate: function(V, re) {
        var ke = Go(V), Oe = jo(), st = ql(ke), bt = Af(Oe, st);
        bt.tag = Vv, re != null && (_y(re, "forceUpdate"), bt.callback = re);
        var Ct = Il(ke, bt, st);
        Ct !== null && (Va(Ct, ke, st, Oe), Yv(Ct, ke, st)), Td(ke, st);
      }
    };
    function Qw(V, re, ke, Oe, st, bt, Ct) {
      var Nt = V.stateNode;
      if (typeof Nt.shouldComponentUpdate == "function") {
        var qt = Nt.shouldComponentUpdate(Oe, bt, Ct);
        {
          if (V.mode & mi) {
            ba(!0);
            try {
              qt = Nt.shouldComponentUpdate(Oe, bt, Ct);
            } finally {
              ba(!1);
            }
          }
          qt === void 0 && Ce("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Si(re) || "Component");
        }
        return qt;
      }
      return re.prototype && re.prototype.isPureReactComponent ? !ri(ke, Oe) || !ri(st, bt) : !0;
    }
    function P4(V, re, ke) {
      var Oe = V.stateNode;
      {
        var st = Si(re) || "Component", bt = Oe.render;
        bt || (re.prototype && typeof re.prototype.render == "function" ? Ce("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", st) : Ce("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", st)), Oe.getInitialState && !Oe.getInitialState.isReactClassApproved && !Oe.state && Ce("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", st), Oe.getDefaultProps && !Oe.getDefaultProps.isReactClassApproved && Ce("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", st), Oe.propTypes && Ce("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", st), Oe.contextType && Ce("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", st), re.childContextTypes && !k0.has(re) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (V.mode & mi) === Hn && (k0.add(re), Ce(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, st)), re.contextTypes && !k0.has(re) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (V.mode & mi) === Hn && (k0.add(re), Ce(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, st)), Oe.contextTypes && Ce("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", st), re.contextType && re.contextTypes && !ng.has(re) && (ng.add(re), Ce("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", st)), typeof Oe.componentShouldUpdate == "function" && Ce("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", st), re.prototype && re.prototype.isPureReactComponent && typeof Oe.shouldComponentUpdate < "u" && Ce("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Si(re) || "A pure component"), typeof Oe.componentDidUnmount == "function" && Ce("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", st), typeof Oe.componentDidReceiveProps == "function" && Ce("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", st), typeof Oe.componentWillRecieveProps == "function" && Ce("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", st), typeof Oe.UNSAFE_componentWillRecieveProps == "function" && Ce("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", st);
        var Ct = Oe.props !== ke;
        Oe.props !== void 0 && Ct && Ce("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", st, st), Oe.defaultProps && Ce("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", st, st), typeof Oe.getSnapshotBeforeUpdate == "function" && typeof Oe.componentDidUpdate != "function" && !Z2.has(re) && (Z2.add(re), Ce("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Si(re))), typeof Oe.getDerivedStateFromProps == "function" && Ce("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", st), typeof Oe.getDerivedStateFromError == "function" && Ce("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", st), typeof re.getSnapshotBeforeUpdate == "function" && Ce("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", st);
        var Nt = Oe.state;
        Nt && (typeof Nt != "object" || Ei(Nt)) && Ce("%s.state: must be set to an object or null", st), typeof Oe.getChildContext == "function" && typeof re.childContextTypes != "object" && Ce("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", st);
      }
    }
    function Zw(V, re) {
      re.updater = og, V.stateNode = re, Yf(re, V), re._reactInternalInstance = Y2;
    }
    function e3(V, re, ke) {
      var Oe = !1, st = bs, bt = bs, Ct = re.contextType;
      if ("contextType" in re) {
        var Nt = (
          // Allow null for conditional declaration
          Ct === null || Ct !== void 0 && Ct.$$typeof === Nr && Ct._context === void 0
        );
        if (!Nt && !ig.has(re)) {
          ig.add(re);
          var qt = "";
          Ct === void 0 ? qt = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Ct != "object" ? qt = " However, it is set to a " + typeof Ct + "." : Ct.$$typeof === fr ? qt = " Did you accidentally pass the Context.Provider instead?" : Ct._context !== void 0 ? qt = " Did you accidentally pass the Context.Consumer instead?" : qt = " However, it is set to an object with keys {" + Object.keys(Ct).join(", ") + "}.", Ce("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Si(re) || "Component", qt);
        }
      }
      if (typeof Ct == "object" && Ct !== null)
        bt = Da(Ct);
      else {
        st = $h(V, re, !0);
        var nr = re.contextTypes;
        Oe = nr != null, bt = Oe ? xh(V, st) : bs;
      }
      var ar = new re(ke, bt);
      if (V.mode & mi) {
        ba(!0);
        try {
          ar = new re(ke, bt);
        } finally {
          ba(!1);
        }
      }
      var xr = V.memoizedState = ar.state !== null && ar.state !== void 0 ? ar.state : null;
      Zw(V, ar);
      {
        if (typeof re.getDerivedStateFromProps == "function" && xr === null) {
          var Er = Si(re) || "Component";
          Q2.has(Er) || (Q2.add(Er), Ce("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Er, ar.state === null ? "null" : "undefined", Er));
        }
        if (typeof re.getDerivedStateFromProps == "function" || typeof ar.getSnapshotBeforeUpdate == "function") {
          var Or = null, Ur = null, qr = null;
          if (typeof ar.componentWillMount == "function" && ar.componentWillMount.__suppressDeprecationWarning !== !0 ? Or = "componentWillMount" : typeof ar.UNSAFE_componentWillMount == "function" && (Or = "UNSAFE_componentWillMount"), typeof ar.componentWillReceiveProps == "function" && ar.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ur = "componentWillReceiveProps" : typeof ar.UNSAFE_componentWillReceiveProps == "function" && (Ur = "UNSAFE_componentWillReceiveProps"), typeof ar.componentWillUpdate == "function" && ar.componentWillUpdate.__suppressDeprecationWarning !== !0 ? qr = "componentWillUpdate" : typeof ar.UNSAFE_componentWillUpdate == "function" && (qr = "UNSAFE_componentWillUpdate"), Or !== null || Ur !== null || qr !== null) {
            var Sn = Si(re) || "Component", Yn = typeof re.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            eg.has(Sn) || (eg.add(Sn), Ce(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Sn, Yn, Or !== null ? `
  ` + Or : "", Ur !== null ? `
  ` + Ur : "", qr !== null ? `
  ` + qr : ""));
          }
        }
      }
      return Oe && zb(V, st, bt), ar;
    }
    function I4(V, re) {
      var ke = re.state;
      typeof re.componentWillMount == "function" && re.componentWillMount(), typeof re.UNSAFE_componentWillMount == "function" && re.UNSAFE_componentWillMount(), ke !== re.state && (Ce("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", ui(V) || "Component"), og.enqueueReplaceState(re, re.state, null));
    }
    function t3(V, re, ke, Oe) {
      var st = re.state;
      if (typeof re.componentWillReceiveProps == "function" && re.componentWillReceiveProps(ke, Oe), typeof re.UNSAFE_componentWillReceiveProps == "function" && re.UNSAFE_componentWillReceiveProps(ke, Oe), re.state !== st) {
        {
          var bt = ui(V) || "Component";
          J2.has(bt) || (J2.add(bt), Ce("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", bt));
        }
        og.enqueueReplaceState(re, re.state, null);
      }
    }
    function sg(V, re, ke, Oe) {
      P4(V, re, ke);
      var st = V.stateNode;
      st.props = ke, st.state = V.memoizedState, st.refs = {}, y2(V);
      var bt = re.contextType;
      if (typeof bt == "object" && bt !== null)
        st.context = Da(bt);
      else {
        var Ct = $h(V, re, !0);
        st.context = xh(V, Ct);
      }
      {
        if (st.state === ke) {
          var Nt = Si(re) || "Component";
          rg.has(Nt) || (rg.add(Nt), Ce("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Nt));
        }
        V.mode & mi && au.recordLegacyContextWarning(V, st), au.recordUnsafeLifecycleWarnings(V, st);
      }
      st.state = V.memoizedState;
      var qt = re.getDerivedStateFromProps;
      if (typeof qt == "function" && (ag(V, re, qt, ke), st.state = V.memoizedState), typeof re.getDerivedStateFromProps != "function" && typeof st.getSnapshotBeforeUpdate != "function" && (typeof st.UNSAFE_componentWillMount == "function" || typeof st.componentWillMount == "function") && (I4(V, st), Jv(V, ke, st, Oe), st.state = V.memoizedState), typeof st.componentDidMount == "function") {
        var nr = hi;
        nr |= bo, (V.mode & Lo) !== Hn && (nr |= wo), V.flags |= nr;
      }
    }
    function D4(V, re, ke, Oe) {
      var st = V.stateNode, bt = V.memoizedProps;
      st.props = bt;
      var Ct = st.context, Nt = re.contextType, qt = bs;
      if (typeof Nt == "object" && Nt !== null)
        qt = Da(Nt);
      else {
        var nr = $h(V, re, !0);
        qt = xh(V, nr);
      }
      var ar = re.getDerivedStateFromProps, xr = typeof ar == "function" || typeof st.getSnapshotBeforeUpdate == "function";
      !xr && (typeof st.UNSAFE_componentWillReceiveProps == "function" || typeof st.componentWillReceiveProps == "function") && (bt !== ke || Ct !== qt) && t3(V, st, ke, qt), yw();
      var Er = V.memoizedState, Or = st.state = Er;
      if (Jv(V, ke, st, Oe), Or = V.memoizedState, bt === ke && Er === Or && !Mv() && !Qv()) {
        if (typeof st.componentDidMount == "function") {
          var Ur = hi;
          Ur |= bo, (V.mode & Lo) !== Hn && (Ur |= wo), V.flags |= Ur;
        }
        return !1;
      }
      typeof ar == "function" && (ag(V, re, ar, ke), Or = V.memoizedState);
      var qr = Qv() || Qw(V, re, bt, ke, Er, Or, qt);
      if (qr) {
        if (!xr && (typeof st.UNSAFE_componentWillMount == "function" || typeof st.componentWillMount == "function") && (typeof st.componentWillMount == "function" && st.componentWillMount(), typeof st.UNSAFE_componentWillMount == "function" && st.UNSAFE_componentWillMount()), typeof st.componentDidMount == "function") {
          var Sn = hi;
          Sn |= bo, (V.mode & Lo) !== Hn && (Sn |= wo), V.flags |= Sn;
        }
      } else {
        if (typeof st.componentDidMount == "function") {
          var Yn = hi;
          Yn |= bo, (V.mode & Lo) !== Hn && (Yn |= wo), V.flags |= Yn;
        }
        V.memoizedProps = ke, V.memoizedState = Or;
      }
      return st.props = ke, st.state = Or, st.context = qt, qr;
    }
    function N4(V, re, ke, Oe, st) {
      var bt = re.stateNode;
      vw(V, re);
      var Ct = re.memoizedProps, Nt = re.type === re.elementType ? Ct : uu(re.type, Ct);
      bt.props = Nt;
      var qt = re.pendingProps, nr = bt.context, ar = ke.contextType, xr = bs;
      if (typeof ar == "object" && ar !== null)
        xr = Da(ar);
      else {
        var Er = $h(re, ke, !0);
        xr = xh(re, Er);
      }
      var Or = ke.getDerivedStateFromProps, Ur = typeof Or == "function" || typeof bt.getSnapshotBeforeUpdate == "function";
      !Ur && (typeof bt.UNSAFE_componentWillReceiveProps == "function" || typeof bt.componentWillReceiveProps == "function") && (Ct !== qt || nr !== xr) && t3(re, bt, Oe, xr), yw();
      var qr = re.memoizedState, Sn = bt.state = qr;
      if (Jv(re, Oe, bt, st), Sn = re.memoizedState, Ct === qt && qr === Sn && !Mv() && !Qv() && !xt)
        return typeof bt.componentDidUpdate == "function" && (Ct !== V.memoizedProps || qr !== V.memoizedState) && (re.flags |= hi), typeof bt.getSnapshotBeforeUpdate == "function" && (Ct !== V.memoizedProps || qr !== V.memoizedState) && (re.flags |= Xo), !1;
      typeof Or == "function" && (ag(re, ke, Or, Oe), Sn = re.memoizedState);
      var Yn = Qv() || Qw(re, ke, Nt, Oe, qr, Sn, xr) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      xt;
      return Yn ? (!Ur && (typeof bt.UNSAFE_componentWillUpdate == "function" || typeof bt.componentWillUpdate == "function") && (typeof bt.componentWillUpdate == "function" && bt.componentWillUpdate(Oe, Sn, xr), typeof bt.UNSAFE_componentWillUpdate == "function" && bt.UNSAFE_componentWillUpdate(Oe, Sn, xr)), typeof bt.componentDidUpdate == "function" && (re.flags |= hi), typeof bt.getSnapshotBeforeUpdate == "function" && (re.flags |= Xo)) : (typeof bt.componentDidUpdate == "function" && (Ct !== V.memoizedProps || qr !== V.memoizedState) && (re.flags |= hi), typeof bt.getSnapshotBeforeUpdate == "function" && (Ct !== V.memoizedProps || qr !== V.memoizedState) && (re.flags |= Xo), re.memoizedProps = Oe, re.memoizedState = Sn), bt.props = Oe, bt.state = Sn, bt.context = xr, Yn;
    }
    function Kc(V, re) {
      return {
        value: V,
        source: re,
        stack: Nf(re),
        digest: null
      };
    }
    function ug(V, re, ke) {
      return {
        value: V,
        source: null,
        stack: ke ?? null,
        digest: re ?? null
      };
    }
    function L4(V, re) {
      return !0;
    }
    function fg(V, re) {
      try {
        var ke = L4(V, re);
        if (ke === !1)
          return;
        var Oe = re.value, st = re.source, bt = re.stack, Ct = bt !== null ? bt : "";
        if (Oe != null && Oe._suppressLogging) {
          if (V.tag === ht)
            return;
          console.error(Oe);
        }
        var Nt = st ? ui(st) : null, qt = Nt ? "The above error occurred in the <" + Nt + "> component:" : "The above error occurred in one of your React components:", nr;
        if (V.tag === lt)
          nr = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ar = ui(V) || "Anonymous";
          nr = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ar + ".");
        }
        var xr = qt + `
` + Ct + `

` + ("" + nr);
        console.error(xr);
      } catch (Er) {
        setTimeout(function() {
          throw Er;
        });
      }
    }
    var U4 = typeof WeakMap == "function" ? WeakMap : Map;
    function r3(V, re, ke) {
      var Oe = Af(Vi, ke);
      Oe.tag = p2, Oe.payload = {
        element: null
      };
      var st = re.value;
      return Oe.callback = function() {
        M5(st), fg(V, re);
      }, Oe;
    }
    function lg(V, re, ke) {
      var Oe = Af(Vi, ke);
      Oe.tag = p2;
      var st = V.type.getDerivedStateFromError;
      if (typeof st == "function") {
        var bt = re.value;
        Oe.payload = function() {
          return st(bt);
        }, Oe.callback = function() {
          h_(V), fg(V, re);
        };
      }
      var Ct = V.stateNode;
      return Ct !== null && typeof Ct.componentDidCatch == "function" && (Oe.callback = function() {
        h_(V), fg(V, re), typeof st != "function" && B5(this);
        var qt = re.value, nr = re.stack;
        this.componentDidCatch(qt, {
          componentStack: nr !== null ? nr : ""
        }), typeof st != "function" && (To(V.lanes, Vn) || Ce("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", ui(V) || "Unknown"));
      }), Oe;
    }
    function n3(V, re, ke) {
      var Oe = V.pingCache, st;
      if (Oe === null ? (Oe = V.pingCache = new U4(), st = /* @__PURE__ */ new Set(), Oe.set(re, st)) : (st = Oe.get(re), st === void 0 && (st = /* @__PURE__ */ new Set(), Oe.set(re, st))), !st.has(ke)) {
        st.add(ke);
        var bt = O5.bind(null, V, re, ke);
        No && G0(V, ke), re.then(bt, bt);
      }
    }
    function F4(V, re, ke, Oe) {
      var st = V.updateQueue;
      if (st === null) {
        var bt = /* @__PURE__ */ new Set();
        bt.add(ke), V.updateQueue = bt;
      } else
        st.add(ke);
    }
    function H4(V, re) {
      var ke = V.tag;
      if ((V.mode & zn) === Hn && (ke === at || ke === It || ke === yr)) {
        var Oe = V.alternate;
        Oe ? (V.updateQueue = Oe.updateQueue, V.memoizedState = Oe.memoizedState, V.lanes = Oe.lanes) : (V.updateQueue = null, V.memoizedState = null);
      }
    }
    function i3(V) {
      var re = V;
      do {
        if (re.tag === Jt && _4(re))
          return re;
        re = re.return;
      } while (re !== null);
      return null;
    }
    function a3(V, re, ke, Oe, st) {
      if ((V.mode & zn) === Hn) {
        if (V === re)
          V.flags |= Ma;
        else {
          if (V.flags |= oi, ke.flags |= dc, ke.flags &= ~(pd | Po), ke.tag === ht) {
            var bt = ke.alternate;
            if (bt === null)
              ke.tag = Ut;
            else {
              var Ct = Af(Vi, Vn);
              Ct.tag = Vv, Il(ke, Ct, Vn);
            }
          }
          ke.lanes = di(ke.lanes, Vn);
        }
        return V;
      }
      return V.flags |= Ma, V.lanes = st, V;
    }
    function j4(V, re, ke, Oe, st) {
      if (ke.flags |= Po, No && G0(V, st), Oe !== null && typeof Oe == "object" && typeof Oe.then == "function") {
        var bt = Oe;
        H4(ke), ao() && ke.mode & zn && Yb();
        var Ct = i3(re);
        if (Ct !== null) {
          Ct.flags &= ~fa, a3(Ct, re, ke, V, st), Ct.mode & zn && n3(V, bt, st), F4(Ct, V, bt);
          return;
        } else {
          if (!Pp(st)) {
            n3(V, bt, st), zg();
            return;
          }
          var Nt = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          Oe = Nt;
        }
      } else if (ao() && ke.mode & zn) {
        Yb();
        var qt = i3(re);
        if (qt !== null) {
          (qt.flags & Ma) === Xn && (qt.flags |= fa), a3(qt, re, ke, V, st), r2(Kc(Oe, ke));
          return;
        }
      }
      Oe = Kc(Oe, ke), S5(Oe);
      var nr = re;
      do {
        switch (nr.tag) {
          case lt: {
            var ar = Oe;
            nr.flags |= Ma;
            var xr = cl(st);
            nr.lanes = di(nr.lanes, xr);
            var Er = r3(nr, ar, xr);
            m2(nr, Er);
            return;
          }
          case ht:
            var Or = Oe, Ur = nr.type, qr = nr.stateNode;
            if ((nr.flags & oi) === Xn && (typeof Ur.getDerivedStateFromError == "function" || qr !== null && typeof qr.componentDidCatch == "function" && !i_(qr))) {
              nr.flags |= Ma;
              var Sn = cl(st);
              nr.lanes = di(nr.lanes, Sn);
              var Yn = lg(nr, Or, Sn);
              m2(nr, Yn);
              return;
            }
            break;
        }
        nr = nr.return;
      } while (nr !== null);
    }
    function z4() {
      return null;
    }
    var M0 = J.ReactCurrentOwner, fu = !1, cg, O0, dg, hg, pg, Vc, vg, Sy, P0;
    cg = {}, O0 = {}, dg = {}, hg = {}, pg = {}, Vc = !1, vg = {}, Sy = {}, P0 = {};
    function Fo(V, re, ke, Oe) {
      V === null ? re.child = uw(re, null, ke, Oe) : re.child = Bh(re, V.child, ke, Oe);
    }
    function q4(V, re, ke, Oe) {
      re.child = Bh(re, V.child, null, Oe), re.child = Bh(re, null, ke, Oe);
    }
    function o3(V, re, ke, Oe, st) {
      if (re.type !== re.elementType) {
        var bt = ke.propTypes;
        bt && nu(
          bt,
          Oe,
          // Resolved props
          "prop",
          Si(ke)
        );
      }
      var Ct = ke.render, Nt = re.ref, qt, nr;
      Mh(re, st), el(re);
      {
        if (M0.current = re, yo(!0), qt = Lh(V, re, Ct, Oe, Nt, st), nr = Uh(), re.mode & mi) {
          ba(!0);
          try {
            qt = Lh(V, re, Ct, Oe, Nt, st), nr = Uh();
          } finally {
            ba(!1);
          }
        }
        yo(!1);
      }
      return Eo(), V !== null && !fu ? (Sw(V, re, st), Rf(V, re, st)) : (ao() && nr && Ym(re), re.flags |= Tu, Fo(V, re, qt, st), re.child);
    }
    function s3(V, re, ke, Oe, st) {
      if (V === null) {
        var bt = ke.type;
        if (Y5(bt) && ke.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        ke.defaultProps === void 0) {
          var Ct = bt;
          return Ct = Gh(bt), re.tag = yr, re.type = Ct, gg(re, bt), u3(V, re, Ct, Oe, st);
        }
        {
          var Nt = bt.propTypes;
          if (Nt && nu(
            Nt,
            Oe,
            // Resolved props
            "prop",
            Si(bt)
          ), ke.defaultProps !== void 0) {
            var qt = Si(bt) || "Unknown";
            P0[qt] || (Ce("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", qt), P0[qt] = !0);
          }
        }
        var nr = eb(ke.type, null, Oe, re, re.mode, st);
        return nr.ref = re.ref, nr.return = re, re.child = nr, nr;
      }
      {
        var ar = ke.type, xr = ar.propTypes;
        xr && nu(
          xr,
          Oe,
          // Resolved props
          "prop",
          Si(ar)
        );
      }
      var Er = V.child, Or = $g(V, st);
      if (!Or) {
        var Ur = Er.memoizedProps, qr = ke.compare;
        if (qr = qr !== null ? qr : ri, qr(Ur, Oe) && V.ref === re.ref)
          return Rf(V, re, st);
      }
      re.flags |= Tu;
      var Sn = Qc(Er, Oe);
      return Sn.ref = re.ref, Sn.return = re, re.child = Sn, Sn;
    }
    function u3(V, re, ke, Oe, st) {
      if (re.type !== re.elementType) {
        var bt = re.elementType;
        if (bt.$$typeof === Dn) {
          var Ct = bt, Nt = Ct._payload, qt = Ct._init;
          try {
            bt = qt(Nt);
          } catch {
            bt = null;
          }
          var nr = bt && bt.propTypes;
          nr && nu(
            nr,
            Oe,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Si(bt)
          );
        }
      }
      if (V !== null) {
        var ar = V.memoizedProps;
        if (ri(ar, Oe) && V.ref === re.ref && // Prevent bailout if the implementation changed due to hot reload.
        re.type === V.type)
          if (fu = !1, re.pendingProps = Oe = ar, $g(V, st))
            (V.flags & dc) !== Xn && (fu = !0);
          else return re.lanes = V.lanes, Rf(V, re, st);
      }
      return yg(V, re, ke, Oe, st);
    }
    function f3(V, re, ke) {
      var Oe = re.pendingProps, st = Oe.children, bt = V !== null ? V.memoizedState : null;
      if (Oe.mode === "hidden" || vt)
        if ((re.mode & zn) === Hn) {
          var Ct = {
            baseLanes: Jr,
            cachePool: null,
            transitions: null
          };
          re.memoizedState = Ct, Iy(re, ke);
        } else if (To(ke, Qa)) {
          var xr = {
            baseLanes: Jr,
            cachePool: null,
            transitions: null
          };
          re.memoizedState = xr;
          var Er = bt !== null ? bt.baseLanes : ke;
          Iy(re, Er);
        } else {
          var Nt = null, qt;
          if (bt !== null) {
            var nr = bt.baseLanes;
            qt = di(nr, ke);
          } else
            qt = ke;
          re.lanes = re.childLanes = Qa;
          var ar = {
            baseLanes: qt,
            cachePool: Nt,
            transitions: null
          };
          return re.memoizedState = ar, re.updateQueue = null, Iy(re, qt), null;
        }
      else {
        var Or;
        bt !== null ? (Or = di(bt.baseLanes, ke), re.memoizedState = null) : Or = ke, Iy(re, Or);
      }
      return Fo(V, re, st, ke), re.child;
    }
    function W4(V, re, ke) {
      var Oe = re.pendingProps;
      return Fo(V, re, Oe, ke), re.child;
    }
    function K4(V, re, ke) {
      var Oe = re.pendingProps.children;
      return Fo(V, re, Oe, ke), re.child;
    }
    function V4(V, re, ke) {
      {
        re.flags |= hi;
        {
          var Oe = re.stateNode;
          Oe.effectDuration = 0, Oe.passiveEffectDuration = 0;
        }
      }
      var st = re.pendingProps, bt = st.children;
      return Fo(V, re, bt, ke), re.child;
    }
    function l3(V, re) {
      var ke = re.ref;
      (V === null && ke !== null || V !== null && V.ref !== ke) && (re.flags |= go, re.flags |= _p);
    }
    function yg(V, re, ke, Oe, st) {
      if (re.type !== re.elementType) {
        var bt = ke.propTypes;
        bt && nu(
          bt,
          Oe,
          // Resolved props
          "prop",
          Si(ke)
        );
      }
      var Ct;
      {
        var Nt = $h(re, ke, !0);
        Ct = xh(re, Nt);
      }
      var qt, nr;
      Mh(re, st), el(re);
      {
        if (M0.current = re, yo(!0), qt = Lh(V, re, ke, Oe, Ct, st), nr = Uh(), re.mode & mi) {
          ba(!0);
          try {
            qt = Lh(V, re, ke, Oe, Ct, st), nr = Uh();
          } finally {
            ba(!1);
          }
        }
        yo(!1);
      }
      return Eo(), V !== null && !fu ? (Sw(V, re, st), Rf(V, re, st)) : (ao() && nr && Ym(re), re.flags |= Tu, Fo(V, re, qt, st), re.child);
    }
    function c3(V, re, ke, Oe, st) {
      {
        switch (c8(re)) {
          case !1: {
            var bt = re.stateNode, Ct = re.type, Nt = new Ct(re.memoizedProps, bt.context), qt = Nt.state;
            bt.updater.enqueueSetState(bt, qt, null);
            break;
          }
          case !0: {
            re.flags |= oi, re.flags |= Ma;
            var nr = new Error("Simulated error coming from DevTools"), ar = cl(st);
            re.lanes = di(re.lanes, ar);
            var xr = lg(re, Kc(nr, re), ar);
            m2(re, xr);
            break;
          }
        }
        if (re.type !== re.elementType) {
          var Er = ke.propTypes;
          Er && nu(
            Er,
            Oe,
            // Resolved props
            "prop",
            Si(ke)
          );
        }
      }
      var Or;
      Uu(ke) ? (Or = !0, Pv(re)) : Or = !1, Mh(re, st);
      var Ur = re.stateNode, qr;
      Ur === null ? ($y(V, re), e3(re, ke, Oe), sg(re, ke, Oe, st), qr = !0) : V === null ? qr = D4(re, ke, Oe, st) : qr = N4(V, re, ke, Oe, st);
      var Sn = mg(V, re, ke, qr, Or, st);
      {
        var Yn = re.stateNode;
        qr && Yn.props !== Oe && (Vc || Ce("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", ui(re) || "a component"), Vc = !0);
      }
      return Sn;
    }
    function mg(V, re, ke, Oe, st, bt) {
      l3(V, re);
      var Ct = (re.flags & oi) !== Xn;
      if (!Oe && !Ct)
        return st && Kb(re, ke, !1), Rf(V, re, bt);
      var Nt = re.stateNode;
      M0.current = re;
      var qt;
      if (Ct && typeof ke.getDerivedStateFromError != "function")
        qt = null, Xw();
      else {
        el(re);
        {
          if (yo(!0), qt = Nt.render(), re.mode & mi) {
            ba(!0);
            try {
              Nt.render();
            } finally {
              ba(!1);
            }
          }
          yo(!1);
        }
        Eo();
      }
      return re.flags |= Tu, V !== null && Ct ? q4(V, re, qt, bt) : Fo(V, re, qt, bt), re.memoizedState = Nt.state, st && Kb(re, ke, !0), re.child;
    }
    function d3(V) {
      var re = V.stateNode;
      re.pendingContext ? qb(V, re.pendingContext, re.pendingContext !== re.context) : re.context && qb(V, re.context, !1), g2(V, re.containerInfo);
    }
    function G4(V, re, ke) {
      if (d3(re), V === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var Oe = re.pendingProps, st = re.memoizedState, bt = st.element;
      vw(V, re), Jv(re, Oe, null, ke);
      var Ct = re.memoizedState;
      re.stateNode;
      var Nt = Ct.element;
      if (st.isDehydrated) {
        var qt = {
          element: Nt,
          isDehydrated: !1,
          cache: Ct.cache,
          pendingSuspenseBoundaries: Ct.pendingSuspenseBoundaries,
          transitions: Ct.transitions
        }, nr = re.updateQueue;
        if (nr.baseState = qt, re.memoizedState = qt, re.flags & fa) {
          var ar = Kc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), re);
          return h3(V, re, Nt, ke, ar);
        } else if (Nt !== bt) {
          var xr = Kc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), re);
          return h3(V, re, Nt, ke, xr);
        } else {
          JS(re);
          var Er = uw(re, null, Nt, ke);
          re.child = Er;
          for (var Or = Er; Or; )
            Or.flags = Or.flags & ~Gi | Yo, Or = Or.sibling;
        }
      } else {
        if (Rh(), Nt === bt)
          return Rf(V, re, ke);
        Fo(V, re, Nt, ke);
      }
      return re.child;
    }
    function h3(V, re, ke, Oe, st) {
      return Rh(), r2(st), re.flags |= fa, Fo(V, re, ke, Oe), re.child;
    }
    function X4(V, re, ke) {
      bw(re), V === null && t2(re);
      var Oe = re.type, st = re.pendingProps, bt = V !== null ? V.memoizedProps : null, Ct = st.children, Nt = Dm(Oe, st);
      return Nt ? Ct = null : bt !== null && Dm(Oe, bt) && (re.flags |= Di), l3(V, re), Fo(V, re, Ct, ke), re.child;
    }
    function Y4(V, re) {
      return V === null && t2(re), null;
    }
    function J4(V, re, ke, Oe) {
      $y(V, re);
      var st = re.pendingProps, bt = ke, Ct = bt._payload, Nt = bt._init, qt = Nt(Ct);
      re.type = qt;
      var nr = re.tag = J5(qt), ar = uu(qt, st), xr;
      switch (nr) {
        case at:
          return gg(re, qt), re.type = qt = Gh(qt), xr = yg(null, re, qt, ar, Oe), xr;
        case ht:
          return re.type = qt = Gg(qt), xr = c3(null, re, qt, ar, Oe), xr;
        case It:
          return re.type = qt = Xg(qt), xr = o3(null, re, qt, ar, Oe), xr;
        case Vt: {
          if (re.type !== re.elementType) {
            var Er = qt.propTypes;
            Er && nu(
              Er,
              ar,
              // Resolved for outer only
              "prop",
              Si(qt)
            );
          }
          return xr = s3(
            null,
            re,
            qt,
            uu(qt.type, ar),
            // The inner type can have defaults too
            Oe
          ), xr;
        }
      }
      var Or = "";
      throw qt !== null && typeof qt == "object" && qt.$$typeof === Dn && (Or = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + qt + ". " + ("Lazy element type must resolve to a class or function." + Or));
    }
    function Q4(V, re, ke, Oe, st) {
      $y(V, re), re.tag = ht;
      var bt;
      return Uu(ke) ? (bt = !0, Pv(re)) : bt = !1, Mh(re, st), e3(re, ke, Oe), sg(re, ke, Oe, st), mg(null, re, ke, !0, bt, st);
    }
    function Z4(V, re, ke, Oe) {
      $y(V, re);
      var st = re.pendingProps, bt;
      {
        var Ct = $h(re, ke, !1);
        bt = xh(re, Ct);
      }
      Mh(re, Oe);
      var Nt, qt;
      el(re);
      {
        if (ke.prototype && typeof ke.prototype.render == "function") {
          var nr = Si(ke) || "Unknown";
          cg[nr] || (Ce("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", nr, nr), cg[nr] = !0);
        }
        re.mode & mi && au.recordLegacyContextWarning(re, null), yo(!0), M0.current = re, Nt = Lh(null, re, ke, st, bt, Oe), qt = Uh(), yo(!1);
      }
      if (Eo(), re.flags |= Tu, typeof Nt == "object" && Nt !== null && typeof Nt.render == "function" && Nt.$$typeof === void 0) {
        var ar = Si(ke) || "Unknown";
        O0[ar] || (Ce("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ar, ar, ar), O0[ar] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof Nt == "object" && Nt !== null && typeof Nt.render == "function" && Nt.$$typeof === void 0
      ) {
        {
          var xr = Si(ke) || "Unknown";
          O0[xr] || (Ce("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", xr, xr, xr), O0[xr] = !0);
        }
        re.tag = ht, re.memoizedState = null, re.updateQueue = null;
        var Er = !1;
        return Uu(ke) ? (Er = !0, Pv(re)) : Er = !1, re.memoizedState = Nt.state !== null && Nt.state !== void 0 ? Nt.state : null, y2(re), Zw(re, Nt), sg(re, ke, st, Oe), mg(null, re, ke, !0, Er, Oe);
      } else {
        if (re.tag = at, re.mode & mi) {
          ba(!0);
          try {
            Nt = Lh(null, re, ke, st, bt, Oe), qt = Uh();
          } finally {
            ba(!1);
          }
        }
        return ao() && qt && Ym(re), Fo(null, re, Nt, Oe), gg(re, ke), re.child;
      }
    }
    function gg(V, re) {
      {
        if (re && re.childContextTypes && Ce("%s(...): childContextTypes cannot be defined on a function component.", re.displayName || re.name || "Component"), V.ref !== null) {
          var ke = "", Oe = ro();
          Oe && (ke += `

Check the render method of \`` + Oe + "`.");
          var st = Oe || "", bt = V._debugSource;
          bt && (st = bt.fileName + ":" + bt.lineNumber), pg[st] || (pg[st] = !0, Ce("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", ke));
        }
        if (re.defaultProps !== void 0) {
          var Ct = Si(re) || "Unknown";
          P0[Ct] || (Ce("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", Ct), P0[Ct] = !0);
        }
        if (typeof re.getDerivedStateFromProps == "function") {
          var Nt = Si(re) || "Unknown";
          hg[Nt] || (Ce("%s: Function components do not support getDerivedStateFromProps.", Nt), hg[Nt] = !0);
        }
        if (typeof re.contextType == "object" && re.contextType !== null) {
          var qt = Si(re) || "Unknown";
          dg[qt] || (Ce("%s: Function components do not support contextType.", qt), dg[qt] = !0);
        }
      }
    }
    var bg = {
      dehydrated: null,
      treeContext: null,
      retryLane: wa
    };
    function wg(V) {
      return {
        baseLanes: V,
        cachePool: z4(),
        transitions: null
      };
    }
    function eE(V, re) {
      var ke = null;
      return {
        baseLanes: di(V.baseLanes, re),
        cachePool: ke,
        transitions: V.transitions
      };
    }
    function tE(V, re, ke, Oe) {
      if (re !== null) {
        var st = re.memoizedState;
        if (st === null)
          return !1;
      }
      return _2(V, E0);
    }
    function rE(V, re) {
      return Sc(V.childLanes, re);
    }
    function p3(V, re, ke) {
      var Oe = re.pendingProps;
      d8(re) && (re.flags |= oi);
      var st = ou.current, bt = !1, Ct = (re.flags & oi) !== Xn;
      if (Ct || tE(st, V) ? (bt = !0, re.flags &= ~oi) : (V === null || V.memoizedState !== null) && (st = w4(st, _w)), st = Ph(st), Nl(re, st), V === null) {
        t2(re);
        var Nt = re.memoizedState;
        if (Nt !== null) {
          var qt = Nt.dehydrated;
          if (qt !== null)
            return sE(re, qt);
        }
        var nr = Oe.children, ar = Oe.fallback;
        if (bt) {
          var xr = nE(re, nr, ar, ke), Er = re.child;
          return Er.memoizedState = wg(ke), re.memoizedState = bg, xr;
        } else
          return _g(re, nr);
      } else {
        var Or = V.memoizedState;
        if (Or !== null) {
          var Ur = Or.dehydrated;
          if (Ur !== null)
            return uE(V, re, Ct, Oe, Ur, Or, ke);
        }
        if (bt) {
          var qr = Oe.fallback, Sn = Oe.children, Yn = aE(V, re, Sn, qr, ke), qn = re.child, xi = V.child.memoizedState;
          return qn.memoizedState = xi === null ? wg(ke) : eE(xi, ke), qn.childLanes = rE(V, ke), re.memoizedState = bg, Yn;
        } else {
          var wi = Oe.children, Cr = iE(V, re, wi, ke);
          return re.memoizedState = null, Cr;
        }
      }
    }
    function _g(V, re, ke) {
      var Oe = V.mode, st = {
        mode: "visible",
        children: re
      }, bt = Sg(st, Oe);
      return bt.return = V, V.child = bt, bt;
    }
    function nE(V, re, ke, Oe) {
      var st = V.mode, bt = V.child, Ct = {
        mode: "hidden",
        children: re
      }, Nt, qt;
      return (st & zn) === Hn && bt !== null ? (Nt = bt, Nt.childLanes = Jr, Nt.pendingProps = Ct, V.mode & si && (Nt.actualDuration = 0, Nt.actualStartTime = -1, Nt.selfBaseDuration = 0, Nt.treeBaseDuration = 0), qt = Vl(ke, st, Oe, null)) : (Nt = Sg(Ct, st), qt = Vl(ke, st, Oe, null)), Nt.return = V, qt.return = V, Nt.sibling = qt, V.child = Nt, qt;
    }
    function Sg(V, re, ke) {
      return v_(V, re, Jr, null);
    }
    function v3(V, re) {
      return Qc(V, re);
    }
    function iE(V, re, ke, Oe) {
      var st = V.child, bt = st.sibling, Ct = v3(st, {
        mode: "visible",
        children: ke
      });
      if ((re.mode & zn) === Hn && (Ct.lanes = Oe), Ct.return = re, Ct.sibling = null, bt !== null) {
        var Nt = re.deletions;
        Nt === null ? (re.deletions = [bt], re.flags |= Oi) : Nt.push(bt);
      }
      return re.child = Ct, Ct;
    }
    function aE(V, re, ke, Oe, st) {
      var bt = re.mode, Ct = V.child, Nt = Ct.sibling, qt = {
        mode: "hidden",
        children: ke
      }, nr;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (bt & zn) === Hn && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        re.child !== Ct
      ) {
        var ar = re.child;
        nr = ar, nr.childLanes = Jr, nr.pendingProps = qt, re.mode & si && (nr.actualDuration = 0, nr.actualStartTime = -1, nr.selfBaseDuration = Ct.selfBaseDuration, nr.treeBaseDuration = Ct.treeBaseDuration), re.deletions = null;
      } else
        nr = v3(Ct, qt), nr.subtreeFlags = Ct.subtreeFlags & Na;
      var xr;
      return Nt !== null ? xr = Qc(Nt, Oe) : (xr = Vl(Oe, bt, st, null), xr.flags |= Gi), xr.return = re, nr.return = re, nr.sibling = xr, re.child = nr, xr;
    }
    function Ey(V, re, ke, Oe) {
      Oe !== null && r2(Oe), Bh(re, V.child, null, ke);
      var st = re.pendingProps, bt = st.children, Ct = _g(re, bt);
      return Ct.flags |= Gi, re.memoizedState = null, Ct;
    }
    function oE(V, re, ke, Oe, st) {
      var bt = re.mode, Ct = {
        mode: "visible",
        children: ke
      }, Nt = Sg(Ct, bt), qt = Vl(Oe, bt, st, null);
      return qt.flags |= Gi, Nt.return = re, qt.return = re, Nt.sibling = qt, re.child = Nt, (re.mode & zn) !== Hn && Bh(re, V.child, null, st), qt;
    }
    function sE(V, re, ke) {
      return (V.mode & zn) === Hn ? (Ce("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), V.lanes = Vn) : Fm(re) ? V.lanes = Qs : V.lanes = Qa, null;
    }
    function uE(V, re, ke, Oe, st, bt, Ct) {
      if (ke)
        if (re.flags & fa) {
          re.flags &= ~fa;
          var Cr = ug(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Ey(V, re, Ct, Cr);
        } else {
          if (re.memoizedState !== null)
            return re.child = V.child, re.flags |= oi, null;
          var Wr = Oe.children, Br = Oe.fallback, nn = oE(V, re, Wr, Br, Ct), Bn = re.child;
          return Bn.memoizedState = wg(Ct), re.memoizedState = bg, nn;
        }
      else {
        if (XS(), (re.mode & zn) === Hn)
          return Ey(
            V,
            re,
            Ct,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (Fm(st)) {
          var Nt, qt, nr;
          {
            var ar = dS(st);
            Nt = ar.digest, qt = ar.message, nr = ar.stack;
          }
          var xr;
          qt ? xr = new Error(qt) : xr = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var Er = ug(xr, Nt, nr);
          return Ey(V, re, Ct, Er);
        }
        var Or = To(Ct, V.childLanes);
        if (fu || Or) {
          var Ur = Py();
          if (Ur !== null) {
            var qr = X1(Ur, Ct);
            if (qr !== wa && qr !== bt.retryLane) {
              bt.retryLane = qr;
              var Sn = Vi;
              us(V, qr), Va(Ur, V, qr, Sn);
            }
          }
          zg();
          var Yn = ug(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Ey(V, re, Ct, Yn);
        } else if (Lb(st)) {
          re.flags |= oi, re.child = V.child;
          var qn = P5.bind(null, V);
          return hS(st, qn), null;
        } else {
          QS(re, st, bt.treeContext);
          var xi = Oe.children, wi = _g(re, xi);
          return wi.flags |= Yo, wi;
        }
      }
    }
    function y3(V, re, ke) {
      V.lanes = di(V.lanes, re);
      var Oe = V.alternate;
      Oe !== null && (Oe.lanes = di(Oe.lanes, re)), d2(V.return, re, ke);
    }
    function fE(V, re, ke) {
      for (var Oe = re; Oe !== null; ) {
        if (Oe.tag === Jt) {
          var st = Oe.memoizedState;
          st !== null && y3(Oe, ke, V);
        } else if (Oe.tag === Ht)
          y3(Oe, ke, V);
        else if (Oe.child !== null) {
          Oe.child.return = Oe, Oe = Oe.child;
          continue;
        }
        if (Oe === V)
          return;
        for (; Oe.sibling === null; ) {
          if (Oe.return === null || Oe.return === V)
            return;
          Oe = Oe.return;
        }
        Oe.sibling.return = Oe.return, Oe = Oe.sibling;
      }
    }
    function lE(V) {
      for (var re = V, ke = null; re !== null; ) {
        var Oe = re.alternate;
        Oe !== null && ty(Oe) === null && (ke = re), re = re.sibling;
      }
      return ke;
    }
    function cE(V) {
      if (V !== void 0 && V !== "forwards" && V !== "backwards" && V !== "together" && !vg[V])
        if (vg[V] = !0, typeof V == "string")
          switch (V.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              Ce('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', V, V.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              Ce('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', V, V.toLowerCase());
              break;
            }
            default:
              Ce('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', V);
              break;
          }
        else
          Ce('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', V);
    }
    function dE(V, re) {
      V !== void 0 && !Sy[V] && (V !== "collapsed" && V !== "hidden" ? (Sy[V] = !0, Ce('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', V)) : re !== "forwards" && re !== "backwards" && (Sy[V] = !0, Ce('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', V)));
    }
    function m3(V, re) {
      {
        var ke = Ei(V), Oe = !ke && typeof ra(V) == "function";
        if (ke || Oe) {
          var st = ke ? "array" : "iterable";
          return Ce("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", st, re, st), !1;
        }
      }
      return !0;
    }
    function hE(V, re) {
      if ((re === "forwards" || re === "backwards") && V !== void 0 && V !== null && V !== !1)
        if (Ei(V)) {
          for (var ke = 0; ke < V.length; ke++)
            if (!m3(V[ke], ke))
              return;
        } else {
          var Oe = ra(V);
          if (typeof Oe == "function") {
            var st = Oe.call(V);
            if (st)
              for (var bt = st.next(), Ct = 0; !bt.done; bt = st.next()) {
                if (!m3(bt.value, Ct))
                  return;
                Ct++;
              }
          } else
            Ce('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', re);
        }
    }
    function Eg(V, re, ke, Oe, st) {
      var bt = V.memoizedState;
      bt === null ? V.memoizedState = {
        isBackwards: re,
        rendering: null,
        renderingStartTime: 0,
        last: Oe,
        tail: ke,
        tailMode: st
      } : (bt.isBackwards = re, bt.rendering = null, bt.renderingStartTime = 0, bt.last = Oe, bt.tail = ke, bt.tailMode = st);
    }
    function g3(V, re, ke) {
      var Oe = re.pendingProps, st = Oe.revealOrder, bt = Oe.tail, Ct = Oe.children;
      cE(st), dE(bt, st), hE(Ct, st), Fo(V, re, Ct, ke);
      var Nt = ou.current, qt = _2(Nt, E0);
      if (qt)
        Nt = S2(Nt, E0), re.flags |= oi;
      else {
        var nr = V !== null && (V.flags & oi) !== Xn;
        nr && fE(re, re.child, ke), Nt = Ph(Nt);
      }
      if (Nl(re, Nt), (re.mode & zn) === Hn)
        re.memoizedState = null;
      else
        switch (st) {
          case "forwards": {
            var ar = lE(re.child), xr;
            ar === null ? (xr = re.child, re.child = null) : (xr = ar.sibling, ar.sibling = null), Eg(
              re,
              !1,
              // isBackwards
              xr,
              ar,
              bt
            );
            break;
          }
          case "backwards": {
            var Er = null, Or = re.child;
            for (re.child = null; Or !== null; ) {
              var Ur = Or.alternate;
              if (Ur !== null && ty(Ur) === null) {
                re.child = Or;
                break;
              }
              var qr = Or.sibling;
              Or.sibling = Er, Er = Or, Or = qr;
            }
            Eg(
              re,
              !0,
              // isBackwards
              Er,
              null,
              // last
              bt
            );
            break;
          }
          case "together": {
            Eg(
              re,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            re.memoizedState = null;
        }
      return re.child;
    }
    function pE(V, re, ke) {
      g2(re, re.stateNode.containerInfo);
      var Oe = re.pendingProps;
      return V === null ? re.child = Bh(re, null, Oe, ke) : Fo(V, re, Oe, ke), re.child;
    }
    var b3 = !1;
    function vE(V, re, ke) {
      var Oe = re.type, st = Oe._context, bt = re.pendingProps, Ct = re.memoizedProps, Nt = bt.value;
      {
        "value" in bt || b3 || (b3 = !0, Ce("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var qt = re.type.propTypes;
        qt && nu(qt, bt, "prop", "Context.Provider");
      }
      if (cw(re, st, Nt), Ct !== null) {
        var nr = Ct.value;
        if (Ln(nr, Nt)) {
          if (Ct.children === bt.children && !Mv())
            return Rf(V, re, ke);
        } else
          c4(re, st, ke);
      }
      var ar = bt.children;
      return Fo(V, re, ar, ke), re.child;
    }
    var w3 = !1;
    function yE(V, re, ke) {
      var Oe = re.type;
      Oe._context === void 0 ? Oe !== Oe.Consumer && (w3 || (w3 = !0, Ce("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : Oe = Oe._context;
      var st = re.pendingProps, bt = st.children;
      typeof bt != "function" && Ce("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Mh(re, ke);
      var Ct = Da(Oe);
      el(re);
      var Nt;
      return M0.current = re, yo(!0), Nt = bt(Ct), yo(!1), Eo(), re.flags |= Tu, Fo(V, re, Nt, ke), re.child;
    }
    function I0() {
      fu = !0;
    }
    function $y(V, re) {
      (re.mode & zn) === Hn && V !== null && (V.alternate = null, re.alternate = null, re.flags |= Gi);
    }
    function Rf(V, re, ke) {
      return V !== null && (re.dependencies = V.dependencies), Xw(), V0(re.lanes), To(ke, re.childLanes) ? (f4(V, re), re.child) : null;
    }
    function mE(V, re, ke) {
      {
        var Oe = re.return;
        if (Oe === null)
          throw new Error("Cannot swap the root fiber.");
        if (V.alternate = null, re.alternate = null, ke.index = re.index, ke.sibling = re.sibling, ke.return = re.return, ke.ref = re.ref, re === Oe.child)
          Oe.child = ke;
        else {
          var st = Oe.child;
          if (st === null)
            throw new Error("Expected parent to have a child.");
          for (; st.sibling !== re; )
            if (st = st.sibling, st === null)
              throw new Error("Expected to find the previous sibling.");
          st.sibling = ke;
        }
        var bt = Oe.deletions;
        return bt === null ? (Oe.deletions = [V], Oe.flags |= Oi) : bt.push(V), ke.flags |= Gi, ke;
      }
    }
    function $g(V, re) {
      var ke = V.lanes;
      return !!To(ke, re);
    }
    function gE(V, re, ke) {
      switch (re.tag) {
        case lt:
          d3(re), re.stateNode, Rh();
          break;
        case wt:
          bw(re);
          break;
        case ht: {
          var Oe = re.type;
          Uu(Oe) && Pv(re);
          break;
        }
        case Et:
          g2(re, re.stateNode.containerInfo);
          break;
        case Ot: {
          var st = re.memoizedProps.value, bt = re.type._context;
          cw(re, bt, st);
          break;
        }
        case Ft:
          {
            var Ct = To(ke, re.childLanes);
            Ct && (re.flags |= hi);
            {
              var Nt = re.stateNode;
              Nt.effectDuration = 0, Nt.passiveEffectDuration = 0;
            }
          }
          break;
        case Jt: {
          var qt = re.memoizedState;
          if (qt !== null) {
            if (qt.dehydrated !== null)
              return Nl(re, Ph(ou.current)), re.flags |= oi, null;
            var nr = re.child, ar = nr.childLanes;
            if (To(ke, ar))
              return p3(V, re, ke);
            Nl(re, Ph(ou.current));
            var xr = Rf(V, re, ke);
            return xr !== null ? xr.sibling : null;
          } else
            Nl(re, Ph(ou.current));
          break;
        }
        case Ht: {
          var Er = (V.flags & oi) !== Xn, Or = To(ke, re.childLanes);
          if (Er) {
            if (Or)
              return g3(V, re, ke);
            re.flags |= oi;
          }
          var Ur = re.memoizedState;
          if (Ur !== null && (Ur.rendering = null, Ur.tail = null, Ur.lastEffect = null), Nl(re, ou.current), Or)
            break;
          return null;
        }
        case dt:
        case ot:
          return re.lanes = Jr, f3(V, re, ke);
      }
      return Rf(V, re, ke);
    }
    function _3(V, re, ke) {
      if (re._debugNeedsRemount && V !== null)
        return mE(V, re, eb(re.type, re.key, re.pendingProps, re._debugOwner || null, re.mode, re.lanes));
      if (V !== null) {
        var Oe = V.memoizedProps, st = re.pendingProps;
        if (Oe !== st || Mv() || // Force a re-render if the implementation changed due to hot reload:
        re.type !== V.type)
          fu = !0;
        else {
          var bt = $g(V, ke);
          if (!bt && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (re.flags & oi) === Xn)
            return fu = !1, gE(V, re, ke);
          (V.flags & dc) !== Xn ? fu = !0 : fu = !1;
        }
      } else if (fu = !1, ao() && zS(re)) {
        var Ct = re.index, Nt = qS();
        Xb(re, Nt, Ct);
      }
      switch (re.lanes = Jr, re.tag) {
        case it:
          return Z4(V, re, re.type, ke);
        case jt: {
          var qt = re.elementType;
          return J4(V, re, qt, ke);
        }
        case at: {
          var nr = re.type, ar = re.pendingProps, xr = re.elementType === nr ? ar : uu(nr, ar);
          return yg(V, re, nr, xr, ke);
        }
        case ht: {
          var Er = re.type, Or = re.pendingProps, Ur = re.elementType === Er ? Or : uu(Er, Or);
          return c3(V, re, Er, Ur, ke);
        }
        case lt:
          return G4(V, re, ke);
        case wt:
          return X4(V, re, ke);
        case Rt:
          return Y4(V, re);
        case Jt:
          return p3(V, re, ke);
        case Et:
          return pE(V, re, ke);
        case It: {
          var qr = re.type, Sn = re.pendingProps, Yn = re.elementType === qr ? Sn : uu(qr, Sn);
          return o3(V, re, qr, Yn, ke);
        }
        case Mt:
          return W4(V, re, ke);
        case Lt:
          return K4(V, re, ke);
        case Ft:
          return V4(V, re, ke);
        case Ot:
          return vE(V, re, ke);
        case zt:
          return yE(V, re, ke);
        case Vt: {
          var qn = re.type, xi = re.pendingProps, wi = uu(qn, xi);
          if (re.type !== re.elementType) {
            var Cr = qn.propTypes;
            Cr && nu(
              Cr,
              wi,
              // Resolved for outer only
              "prop",
              Si(qn)
            );
          }
          return wi = uu(qn.type, wi), s3(V, re, qn, wi, ke);
        }
        case yr:
          return u3(V, re, re.type, re.pendingProps, ke);
        case Ut: {
          var Wr = re.type, Br = re.pendingProps, nn = re.elementType === Wr ? Br : uu(Wr, Br);
          return Q4(V, re, Wr, nn, ke);
        }
        case Ht:
          return g3(V, re, ke);
        case ct:
          break;
        case dt:
          return f3(V, re, ke);
      }
      throw new Error("Unknown unit of work tag (" + re.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Fh(V) {
      V.flags |= hi;
    }
    function S3(V) {
      V.flags |= go, V.flags |= _p;
    }
    var E3, xg, $3, x3;
    E3 = function(V, re, ke, Oe) {
      for (var st = re.child; st !== null; ) {
        if (st.tag === wt || st.tag === Rt)
          F6(V, st.stateNode);
        else if (st.tag !== Et) {
          if (st.child !== null) {
            st.child.return = st, st = st.child;
            continue;
          }
        }
        if (st === re)
          return;
        for (; st.sibling === null; ) {
          if (st.return === null || st.return === re)
            return;
          st = st.return;
        }
        st.sibling.return = st.return, st = st.sibling;
      }
    }, xg = function(V, re) {
    }, $3 = function(V, re, ke, Oe, st) {
      var bt = V.memoizedProps;
      if (bt !== Oe) {
        var Ct = re.stateNode, Nt = b2(), qt = j6(Ct, ke, bt, Oe, st, Nt);
        re.updateQueue = qt, qt && Fh(re);
      }
    }, x3 = function(V, re, ke, Oe) {
      ke !== Oe && Fh(re);
    };
    function D0(V, re) {
      if (!ao())
        switch (V.tailMode) {
          case "hidden": {
            for (var ke = V.tail, Oe = null; ke !== null; )
              ke.alternate !== null && (Oe = ke), ke = ke.sibling;
            Oe === null ? V.tail = null : Oe.sibling = null;
            break;
          }
          case "collapsed": {
            for (var st = V.tail, bt = null; st !== null; )
              st.alternate !== null && (bt = st), st = st.sibling;
            bt === null ? !re && V.tail !== null ? V.tail.sibling = null : V.tail = null : bt.sibling = null;
            break;
          }
        }
    }
    function so(V) {
      var re = V.alternate !== null && V.alternate.child === V.child, ke = Jr, Oe = Xn;
      if (re) {
        if ((V.mode & si) !== Hn) {
          for (var qt = V.selfBaseDuration, nr = V.child; nr !== null; )
            ke = di(ke, di(nr.lanes, nr.childLanes)), Oe |= nr.subtreeFlags & Na, Oe |= nr.flags & Na, qt += nr.treeBaseDuration, nr = nr.sibling;
          V.treeBaseDuration = qt;
        } else
          for (var ar = V.child; ar !== null; )
            ke = di(ke, di(ar.lanes, ar.childLanes)), Oe |= ar.subtreeFlags & Na, Oe |= ar.flags & Na, ar.return = V, ar = ar.sibling;
        V.subtreeFlags |= Oe;
      } else {
        if ((V.mode & si) !== Hn) {
          for (var st = V.actualDuration, bt = V.selfBaseDuration, Ct = V.child; Ct !== null; )
            ke = di(ke, di(Ct.lanes, Ct.childLanes)), Oe |= Ct.subtreeFlags, Oe |= Ct.flags, st += Ct.actualDuration, bt += Ct.treeBaseDuration, Ct = Ct.sibling;
          V.actualDuration = st, V.treeBaseDuration = bt;
        } else
          for (var Nt = V.child; Nt !== null; )
            ke = di(ke, di(Nt.lanes, Nt.childLanes)), Oe |= Nt.subtreeFlags, Oe |= Nt.flags, Nt.return = V, Nt = Nt.sibling;
        V.subtreeFlags |= Oe;
      }
      return V.childLanes = ke, re;
    }
    function bE(V, re, ke) {
      if (n4() && (re.mode & zn) !== Hn && (re.flags & oi) === Xn)
        return rw(re), Rh(), re.flags |= fa | Po | Ma, !1;
      var Oe = Uv(re);
      if (ke !== null && ke.dehydrated !== null)
        if (V === null) {
          if (!Oe)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (t4(re), so(re), (re.mode & si) !== Hn) {
            var st = ke !== null;
            if (st) {
              var bt = re.child;
              bt !== null && (re.treeBaseDuration -= bt.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Rh(), (re.flags & oi) === Xn && (re.memoizedState = null), re.flags |= hi, so(re), (re.mode & si) !== Hn) {
            var Ct = ke !== null;
            if (Ct) {
              var Nt = re.child;
              Nt !== null && (re.treeBaseDuration -= Nt.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return nw(), !0;
    }
    function T3(V, re, ke) {
      var Oe = re.pendingProps;
      switch (Jm(re), re.tag) {
        case it:
        case jt:
        case yr:
        case at:
        case It:
        case Mt:
        case Lt:
        case Ft:
        case zt:
        case Vt:
          return so(re), null;
        case ht: {
          var st = re.type;
          return Uu(st) && Ov(re), so(re), null;
        }
        case lt: {
          var bt = re.stateNode;
          if (Oh(re), Vm(re), $2(), bt.pendingContext && (bt.context = bt.pendingContext, bt.pendingContext = null), V === null || V.child === null) {
            var Ct = Uv(re);
            if (Ct)
              Fh(re);
            else if (V !== null) {
              var Nt = V.memoizedState;
              // Check if this is a client root
              (!Nt.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (re.flags & fa) !== Xn) && (re.flags |= Xo, nw());
            }
          }
          return xg(V, re), so(re), null;
        }
        case wt: {
          w2(re);
          var qt = gw(), nr = re.type;
          if (V !== null && re.stateNode != null)
            $3(V, re, nr, Oe, qt), V.ref !== re.ref && S3(re);
          else {
            if (!Oe) {
              if (re.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return so(re), null;
            }
            var ar = b2(), xr = Uv(re);
            if (xr)
              ZS(re, qt, ar) && Fh(re);
            else {
              var Er = U6(nr, Oe, qt, ar, re);
              E3(Er, re, !1, !1), re.stateNode = Er, H6(Er, nr, Oe, qt) && Fh(re);
            }
            re.ref !== null && S3(re);
          }
          return so(re), null;
        }
        case Rt: {
          var Or = Oe;
          if (V && re.stateNode != null) {
            var Ur = V.memoizedProps;
            x3(V, re, Ur, Or);
          } else {
            if (typeof Or != "string" && re.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var qr = gw(), Sn = b2(), Yn = Uv(re);
            Yn ? e4(re) && Fh(re) : re.stateNode = z6(Or, qr, Sn, re);
          }
          return so(re), null;
        }
        case Jt: {
          Ih(re);
          var qn = re.memoizedState;
          if (V === null || V.memoizedState !== null && V.memoizedState.dehydrated !== null) {
            var xi = bE(V, re, qn);
            if (!xi)
              return re.flags & Ma ? re : null;
          }
          if ((re.flags & oi) !== Xn)
            return re.lanes = ke, (re.mode & si) !== Hn && X2(re), re;
          var wi = qn !== null, Cr = V !== null && V.memoizedState !== null;
          if (wi !== Cr && wi) {
            var Wr = re.child;
            if (Wr.flags |= Au, (re.mode & zn) !== Hn) {
              var Br = V === null && (re.memoizedProps.unstable_avoidThisFallback !== !0 || !$t);
              Br || _2(ou.current, _w) ? _5() : zg();
            }
          }
          var nn = re.updateQueue;
          if (nn !== null && (re.flags |= hi), so(re), (re.mode & si) !== Hn && wi) {
            var Bn = re.child;
            Bn !== null && (re.treeBaseDuration -= Bn.treeBaseDuration);
          }
          return null;
        }
        case Et:
          return Oh(re), xg(V, re), V === null && DS(re.stateNode.containerInfo), so(re), null;
        case Ot:
          var $n = re.type._context;
          return c2($n, re), so(re), null;
        case Ut: {
          var ai = re.type;
          return Uu(ai) && Ov(re), so(re), null;
        }
        case Ht: {
          Ih(re);
          var li = re.memoizedState;
          if (li === null)
            return so(re), null;
          var Hi = (re.flags & oi) !== Xn, ki = li.rendering;
          if (ki === null)
            if (Hi)
              D0(li, !1);
            else {
              var Ra = E5() && (V === null || (V.flags & oi) === Xn);
              if (!Ra)
                for (var Mi = re.child; Mi !== null; ) {
                  var _a = ty(Mi);
                  if (_a !== null) {
                    Hi = !0, re.flags |= oi, D0(li, !1);
                    var ko = _a.updateQueue;
                    return ko !== null && (re.updateQueue = ko, re.flags |= hi), re.subtreeFlags = Xn, l4(re, ke), Nl(re, S2(ou.current, E0)), re.child;
                  }
                  Mi = Mi.sibling;
                }
              li.tail !== null && ia() > V3() && (re.flags |= oi, Hi = !0, D0(li, !1), re.lanes = L1);
            }
          else {
            if (!Hi) {
              var ho = ty(ki);
              if (ho !== null) {
                re.flags |= oi, Hi = !0;
                var _s = ho.updateQueue;
                if (_s !== null && (re.updateQueue = _s, re.flags |= hi), D0(li, !0), li.tail === null && li.tailMode === "hidden" && !ki.alternate && !ao())
                  return so(re), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              ia() * 2 - li.renderingStartTime > V3() && ke !== Qa && (re.flags |= oi, Hi = !0, D0(li, !1), re.lanes = L1);
            }
            if (li.isBackwards)
              ki.sibling = re.child, re.child = ki;
            else {
              var zo = li.last;
              zo !== null ? zo.sibling = ki : re.child = ki, li.last = ki;
            }
          }
          if (li.tail !== null) {
            var qo = li.tail;
            li.rendering = qo, li.tail = qo.sibling, li.renderingStartTime = ia(), qo.sibling = null;
            var Mo = ou.current;
            return Hi ? Mo = S2(Mo, E0) : Mo = Ph(Mo), Nl(re, Mo), qo;
          }
          return so(re), null;
        }
        case ct:
          break;
        case dt:
        case ot: {
          jg(re);
          var Of = re.memoizedState, Xh = Of !== null;
          if (V !== null) {
            var Q0 = V.memoizedState, Vu = Q0 !== null;
            Vu !== Xh && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !vt && (re.flags |= Au);
          }
          return !Xh || (re.mode & zn) === Hn ? so(re) : To(Ku, Qa) && (so(re), re.subtreeFlags & (Gi | hi) && (re.flags |= Au)), null;
        }
        case ut:
          return null;
        case mt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + re.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function wE(V, re, ke) {
      switch (Jm(re), re.tag) {
        case ht: {
          var Oe = re.type;
          Uu(Oe) && Ov(re);
          var st = re.flags;
          return st & Ma ? (re.flags = st & ~Ma | oi, (re.mode & si) !== Hn && X2(re), re) : null;
        }
        case lt: {
          re.stateNode, Oh(re), Vm(re), $2();
          var bt = re.flags;
          return (bt & Ma) !== Xn && (bt & oi) === Xn ? (re.flags = bt & ~Ma | oi, re) : null;
        }
        case wt:
          return w2(re), null;
        case Jt: {
          Ih(re);
          var Ct = re.memoizedState;
          if (Ct !== null && Ct.dehydrated !== null) {
            if (re.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Rh();
          }
          var Nt = re.flags;
          return Nt & Ma ? (re.flags = Nt & ~Ma | oi, (re.mode & si) !== Hn && X2(re), re) : null;
        }
        case Ht:
          return Ih(re), null;
        case Et:
          return Oh(re), null;
        case Ot:
          var qt = re.type._context;
          return c2(qt, re), null;
        case dt:
        case ot:
          return jg(re), null;
        case ut:
          return null;
        default:
          return null;
      }
    }
    function A3(V, re, ke) {
      switch (Jm(re), re.tag) {
        case ht: {
          var Oe = re.type.childContextTypes;
          Oe != null && Ov(re);
          break;
        }
        case lt: {
          re.stateNode, Oh(re), Vm(re), $2();
          break;
        }
        case wt: {
          w2(re);
          break;
        }
        case Et:
          Oh(re);
          break;
        case Jt:
          Ih(re);
          break;
        case Ht:
          Ih(re);
          break;
        case Ot:
          var st = re.type._context;
          c2(st, re);
          break;
        case dt:
        case ot:
          jg(re);
          break;
      }
    }
    var R3 = null;
    R3 = /* @__PURE__ */ new Set();
    var xy = !1, uo = !1, _E = typeof WeakSet == "function" ? WeakSet : Set, Un = null, Hh = null, jh = null;
    function SE(V) {
      nf(null, function() {
        throw V;
      }), bp();
    }
    var $E = function(V, re) {
      if (re.props = V.memoizedProps, re.state = V.memoizedState, V.mode & si)
        try {
          qu(), re.componentWillUnmount();
        } finally {
          zu(V);
        }
      else
        re.componentWillUnmount();
    };
    function C3(V, re) {
      try {
        Fl(Ha, V);
      } catch (ke) {
        Ji(V, re, ke);
      }
    }
    function Tg(V, re, ke) {
      try {
        $E(V, ke);
      } catch (Oe) {
        Ji(V, re, Oe);
      }
    }
    function xE(V, re, ke) {
      try {
        ke.componentDidMount();
      } catch (Oe) {
        Ji(V, re, Oe);
      }
    }
    function B3(V, re) {
      try {
        M3(V);
      } catch (ke) {
        Ji(V, re, ke);
      }
    }
    function zh(V, re) {
      var ke = V.ref;
      if (ke !== null)
        if (typeof ke == "function") {
          var Oe;
          try {
            if (tr && Dt && V.mode & si)
              try {
                qu(), Oe = ke(null);
              } finally {
                zu(V);
              }
            else
              Oe = ke(null);
          } catch (st) {
            Ji(V, re, st);
          }
          typeof Oe == "function" && Ce("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", ui(V));
        } else
          ke.current = null;
    }
    function Ty(V, re, ke) {
      try {
        ke();
      } catch (Oe) {
        Ji(V, re, Oe);
      }
    }
    var k3 = !1;
    function TE(V, re) {
      N6(V.containerInfo), Un = re, AE();
      var ke = k3;
      return k3 = !1, ke;
    }
    function AE() {
      for (; Un !== null; ) {
        var V = Un, re = V.child;
        (V.subtreeFlags & Jf) !== Xn && re !== null ? (re.return = V, Un = re) : RE();
      }
    }
    function RE() {
      for (; Un !== null; ) {
        var V = Un;
        Ii(V);
        try {
          CE(V);
        } catch (ke) {
          Ji(V, V.return, ke);
        }
        ua();
        var re = V.sibling;
        if (re !== null) {
          re.return = V.return, Un = re;
          return;
        }
        Un = V.return;
      }
    }
    function CE(V) {
      var re = V.alternate, ke = V.flags;
      if ((ke & Xo) !== Xn) {
        switch (Ii(V), V.tag) {
          case at:
          case It:
          case yr:
            break;
          case ht: {
            if (re !== null) {
              var Oe = re.memoizedProps, st = re.memoizedState, bt = V.stateNode;
              V.type === V.elementType && !Vc && (bt.props !== V.memoizedProps && Ce("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ui(V) || "instance"), bt.state !== V.memoizedState && Ce("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ui(V) || "instance"));
              var Ct = bt.getSnapshotBeforeUpdate(V.elementType === V.type ? Oe : uu(V.type, Oe), st);
              {
                var Nt = R3;
                Ct === void 0 && !Nt.has(V.type) && (Nt.add(V.type), Ce("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", ui(V)));
              }
              bt.__reactInternalSnapshotBeforeUpdate = Ct;
            }
            break;
          }
          case lt: {
            {
              var qt = V.stateNode;
              uS(qt.containerInfo);
            }
            break;
          }
          case wt:
          case Rt:
          case Et:
          case Ut:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ua();
      }
    }
    function lu(V, re, ke) {
      var Oe = re.updateQueue, st = Oe !== null ? Oe.lastEffect : null;
      if (st !== null) {
        var bt = st.next, Ct = bt;
        do {
          if ((Ct.tag & V) === V) {
            var Nt = Ct.destroy;
            Ct.destroy = void 0, Nt !== void 0 && ((V & oo) !== fs ? I1(re) : (V & Ha) !== fs && gs(re), (V & Fu) !== fs && X0(!0), Ty(re, ke, Nt), (V & Fu) !== fs && X0(!1), (V & oo) !== fs ? Ed() : (V & Ha) !== fs && tl());
          }
          Ct = Ct.next;
        } while (Ct !== bt);
      }
    }
    function Fl(V, re) {
      var ke = re.updateQueue, Oe = ke !== null ? ke.lastEffect : null;
      if (Oe !== null) {
        var st = Oe.next, bt = st;
        do {
          if ((bt.tag & V) === V) {
            (V & oo) !== fs ? Bu(re) : (V & Ha) !== fs && D1(re);
            var Ct = bt.create;
            (V & Fu) !== fs && X0(!0), bt.destroy = Ct(), (V & Fu) !== fs && X0(!1), (V & oo) !== fs ? Sd() : (V & Ha) !== fs && hc();
            {
              var Nt = bt.destroy;
              if (Nt !== void 0 && typeof Nt != "function") {
                var qt = void 0;
                (bt.tag & Ha) !== Xn ? qt = "useLayoutEffect" : (bt.tag & Fu) !== Xn ? qt = "useInsertionEffect" : qt = "useEffect";
                var nr = void 0;
                Nt === null ? nr = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof Nt.then == "function" ? nr = `

It looks like you wrote ` + qt + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + qt + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : nr = " You returned: " + Nt, Ce("%s must not return anything besides a function, which is used for clean-up.%s", qt, nr);
              }
            }
          }
          bt = bt.next;
        } while (bt !== st);
      }
    }
    function BE(V, re) {
      if ((re.flags & hi) !== Xn)
        switch (re.tag) {
          case Ft: {
            var ke = re.stateNode.passiveEffectDuration, Oe = re.memoizedProps, st = Oe.id, bt = Oe.onPostCommit, Ct = Vw(), Nt = re.alternate === null ? "mount" : "update";
            Kw() && (Nt = "nested-update"), typeof bt == "function" && bt(st, Nt, ke, Ct);
            var qt = re.return;
            e: for (; qt !== null; ) {
              switch (qt.tag) {
                case lt:
                  var nr = qt.stateNode;
                  nr.passiveEffectDuration += ke;
                  break e;
                case Ft:
                  var ar = qt.stateNode;
                  ar.passiveEffectDuration += ke;
                  break e;
              }
              qt = qt.return;
            }
            break;
          }
        }
    }
    function kE(V, re, ke, Oe) {
      if ((ke.flags & Ya) !== Xn)
        switch (ke.tag) {
          case at:
          case It:
          case yr: {
            if (!uo)
              if (ke.mode & si)
                try {
                  qu(), Fl(Ha | Fa, ke);
                } finally {
                  zu(ke);
                }
              else
                Fl(Ha | Fa, ke);
            break;
          }
          case ht: {
            var st = ke.stateNode;
            if (ke.flags & hi && !uo)
              if (re === null)
                if (ke.type === ke.elementType && !Vc && (st.props !== ke.memoizedProps && Ce("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ui(ke) || "instance"), st.state !== ke.memoizedState && Ce("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ui(ke) || "instance")), ke.mode & si)
                  try {
                    qu(), st.componentDidMount();
                  } finally {
                    zu(ke);
                  }
                else
                  st.componentDidMount();
              else {
                var bt = ke.elementType === ke.type ? re.memoizedProps : uu(ke.type, re.memoizedProps), Ct = re.memoizedState;
                if (ke.type === ke.elementType && !Vc && (st.props !== ke.memoizedProps && Ce("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ui(ke) || "instance"), st.state !== ke.memoizedState && Ce("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ui(ke) || "instance")), ke.mode & si)
                  try {
                    qu(), st.componentDidUpdate(bt, Ct, st.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    zu(ke);
                  }
                else
                  st.componentDidUpdate(bt, Ct, st.__reactInternalSnapshotBeforeUpdate);
              }
            var Nt = ke.updateQueue;
            Nt !== null && (ke.type === ke.elementType && !Vc && (st.props !== ke.memoizedProps && Ce("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ui(ke) || "instance"), st.state !== ke.memoizedState && Ce("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ui(ke) || "instance")), mw(ke, Nt, st));
            break;
          }
          case lt: {
            var qt = ke.updateQueue;
            if (qt !== null) {
              var nr = null;
              if (ke.child !== null)
                switch (ke.child.tag) {
                  case wt:
                    nr = ke.child.stateNode;
                    break;
                  case ht:
                    nr = ke.child.stateNode;
                    break;
                }
              mw(ke, qt, nr);
            }
            break;
          }
          case wt: {
            var ar = ke.stateNode;
            if (re === null && ke.flags & hi) {
              var xr = ke.type, Er = ke.memoizedProps;
              G6(ar, xr, Er);
            }
            break;
          }
          case Rt:
            break;
          case Et:
            break;
          case Ft: {
            {
              var Or = ke.memoizedProps, Ur = Or.onCommit, qr = Or.onRender, Sn = ke.stateNode.effectDuration, Yn = Vw(), qn = re === null ? "mount" : "update";
              Kw() && (qn = "nested-update"), typeof qr == "function" && qr(ke.memoizedProps.id, qn, ke.actualDuration, ke.treeBaseDuration, ke.actualStartTime, Yn);
              {
                typeof Ur == "function" && Ur(ke.memoizedProps.id, qn, Sn, Yn), R5(ke);
                var xi = ke.return;
                e: for (; xi !== null; ) {
                  switch (xi.tag) {
                    case lt:
                      var wi = xi.stateNode;
                      wi.effectDuration += Sn;
                      break e;
                    case Ft:
                      var Cr = xi.stateNode;
                      Cr.effectDuration += Sn;
                      break e;
                  }
                  xi = xi.return;
                }
              }
            }
            break;
          }
          case Jt: {
            UE(V, ke);
            break;
          }
          case Ht:
          case Ut:
          case ct:
          case dt:
          case ot:
          case mt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      uo || ke.flags & go && M3(ke);
    }
    function ME(V) {
      switch (V.tag) {
        case at:
        case It:
        case yr: {
          if (V.mode & si)
            try {
              qu(), C3(V, V.return);
            } finally {
              zu(V);
            }
          else
            C3(V, V.return);
          break;
        }
        case ht: {
          var re = V.stateNode;
          typeof re.componentDidMount == "function" && xE(V, V.return, re), B3(V, V.return);
          break;
        }
        case wt: {
          B3(V, V.return);
          break;
        }
      }
    }
    function OE(V, re) {
      for (var ke = null, Oe = V; ; ) {
        if (Oe.tag === wt) {
          if (ke === null) {
            ke = Oe;
            try {
              var st = Oe.stateNode;
              re ? iS(st) : oS(Oe.stateNode, Oe.memoizedProps);
            } catch (Ct) {
              Ji(V, V.return, Ct);
            }
          }
        } else if (Oe.tag === Rt) {
          if (ke === null)
            try {
              var bt = Oe.stateNode;
              re ? aS(bt) : sS(bt, Oe.memoizedProps);
            } catch (Ct) {
              Ji(V, V.return, Ct);
            }
        } else if (!((Oe.tag === dt || Oe.tag === ot) && Oe.memoizedState !== null && Oe !== V)) {
          if (Oe.child !== null) {
            Oe.child.return = Oe, Oe = Oe.child;
            continue;
          }
        }
        if (Oe === V)
          return;
        for (; Oe.sibling === null; ) {
          if (Oe.return === null || Oe.return === V)
            return;
          ke === Oe && (ke = null), Oe = Oe.return;
        }
        ke === Oe && (ke = null), Oe.sibling.return = Oe.return, Oe = Oe.sibling;
      }
    }
    function M3(V) {
      var re = V.ref;
      if (re !== null) {
        var ke = V.stateNode, Oe;
        switch (V.tag) {
          case wt:
            Oe = ke;
            break;
          default:
            Oe = ke;
        }
        if (typeof re == "function") {
          var st;
          if (V.mode & si)
            try {
              qu(), st = re(Oe);
            } finally {
              zu(V);
            }
          else
            st = re(Oe);
          typeof st == "function" && Ce("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", ui(V));
        } else
          re.hasOwnProperty("current") || Ce("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", ui(V)), re.current = Oe;
      }
    }
    function PE(V) {
      var re = V.alternate;
      re !== null && (re.return = null), V.return = null;
    }
    function O3(V) {
      var re = V.alternate;
      re !== null && (V.alternate = null, O3(re));
      {
        if (V.child = null, V.deletions = null, V.sibling = null, V.tag === wt) {
          var ke = V.stateNode;
          ke !== null && US(ke);
        }
        V.stateNode = null, V._debugOwner = null, V.return = null, V.dependencies = null, V.memoizedProps = null, V.memoizedState = null, V.pendingProps = null, V.stateNode = null, V.updateQueue = null;
      }
    }
    function IE(V) {
      for (var re = V.return; re !== null; ) {
        if (P3(re))
          return re;
        re = re.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function P3(V) {
      return V.tag === wt || V.tag === lt || V.tag === Et;
    }
    function I3(V) {
      var re = V;
      e: for (; ; ) {
        for (; re.sibling === null; ) {
          if (re.return === null || P3(re.return))
            return null;
          re = re.return;
        }
        for (re.sibling.return = re.return, re = re.sibling; re.tag !== wt && re.tag !== Rt && re.tag !== er; ) {
          if (re.flags & Gi || re.child === null || re.tag === Et)
            continue e;
          re.child.return = re, re = re.child;
        }
        if (!(re.flags & Gi))
          return re.stateNode;
      }
    }
    function DE(V) {
      var re = IE(V);
      switch (re.tag) {
        case wt: {
          var ke = re.stateNode;
          re.flags & Di && (Nb(ke), re.flags &= ~Di);
          var Oe = I3(V);
          Rg(V, Oe, ke);
          break;
        }
        case lt:
        case Et: {
          var st = re.stateNode.containerInfo, bt = I3(V);
          Ag(V, bt, st);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Ag(V, re, ke) {
      var Oe = V.tag, st = Oe === wt || Oe === Rt;
      if (st) {
        var bt = V.stateNode;
        re ? eS(ke, bt, re) : Q6(ke, bt);
      } else if (Oe !== Et) {
        var Ct = V.child;
        if (Ct !== null) {
          Ag(Ct, re, ke);
          for (var Nt = Ct.sibling; Nt !== null; )
            Ag(Nt, re, ke), Nt = Nt.sibling;
        }
      }
    }
    function Rg(V, re, ke) {
      var Oe = V.tag, st = Oe === wt || Oe === Rt;
      if (st) {
        var bt = V.stateNode;
        re ? Z6(ke, bt, re) : J6(ke, bt);
      } else if (Oe !== Et) {
        var Ct = V.child;
        if (Ct !== null) {
          Rg(Ct, re, ke);
          for (var Nt = Ct.sibling; Nt !== null; )
            Rg(Nt, re, ke), Nt = Nt.sibling;
        }
      }
    }
    var fo = null, cu = !1;
    function NE(V, re, ke) {
      {
        var Oe = re;
        e: for (; Oe !== null; ) {
          switch (Oe.tag) {
            case wt: {
              fo = Oe.stateNode, cu = !1;
              break e;
            }
            case lt: {
              fo = Oe.stateNode.containerInfo, cu = !0;
              break e;
            }
            case Et: {
              fo = Oe.stateNode.containerInfo, cu = !0;
              break e;
            }
          }
          Oe = Oe.return;
        }
        if (fo === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        D3(V, re, ke), fo = null, cu = !1;
      }
      PE(ke);
    }
    function Hl(V, re, ke) {
      for (var Oe = ke.child; Oe !== null; )
        D3(V, re, Oe), Oe = Oe.sibling;
    }
    function D3(V, re, ke) {
      switch (sf(ke), ke.tag) {
        case wt:
          uo || zh(ke, re);
        case Rt: {
          {
            var Oe = fo, st = cu;
            fo = null, Hl(V, re, ke), fo = Oe, cu = st, fo !== null && (cu ? rS(fo, ke.stateNode) : tS(fo, ke.stateNode));
          }
          return;
        }
        case er: {
          fo !== null && (cu ? nS(fo, ke.stateNode) : Um(fo, ke.stateNode));
          return;
        }
        case Et: {
          {
            var bt = fo, Ct = cu;
            fo = ke.stateNode.containerInfo, cu = !0, Hl(V, re, ke), fo = bt, cu = Ct;
          }
          return;
        }
        case at:
        case It:
        case Vt:
        case yr: {
          if (!uo) {
            var Nt = ke.updateQueue;
            if (Nt !== null) {
              var qt = Nt.lastEffect;
              if (qt !== null) {
                var nr = qt.next, ar = nr;
                do {
                  var xr = ar, Er = xr.destroy, Or = xr.tag;
                  Er !== void 0 && ((Or & Fu) !== fs ? Ty(ke, re, Er) : (Or & Ha) !== fs && (gs(ke), ke.mode & si ? (qu(), Ty(ke, re, Er), zu(ke)) : Ty(ke, re, Er), tl())), ar = ar.next;
                } while (ar !== nr);
              }
            }
          }
          Hl(V, re, ke);
          return;
        }
        case ht: {
          if (!uo) {
            zh(ke, re);
            var Ur = ke.stateNode;
            typeof Ur.componentWillUnmount == "function" && Tg(ke, re, Ur);
          }
          Hl(V, re, ke);
          return;
        }
        case ct: {
          Hl(V, re, ke);
          return;
        }
        case dt: {
          if (
            // TODO: Remove this dead flag
            ke.mode & zn
          ) {
            var qr = uo;
            uo = qr || ke.memoizedState !== null, Hl(V, re, ke), uo = qr;
          } else
            Hl(V, re, ke);
          break;
        }
        default: {
          Hl(V, re, ke);
          return;
        }
      }
    }
    function LE(V) {
      V.memoizedState;
    }
    function UE(V, re) {
      var ke = re.memoizedState;
      if (ke === null) {
        var Oe = re.alternate;
        if (Oe !== null) {
          var st = Oe.memoizedState;
          if (st !== null) {
            var bt = st.dehydrated;
            bt !== null && SS(bt);
          }
        }
      }
    }
    function N3(V) {
      var re = V.updateQueue;
      if (re !== null) {
        V.updateQueue = null;
        var ke = V.stateNode;
        ke === null && (ke = V.stateNode = new _E()), re.forEach(function(Oe) {
          var st = I5.bind(null, V, Oe);
          if (!ke.has(Oe)) {
            if (ke.add(Oe), No)
              if (Hh !== null && jh !== null)
                G0(jh, Hh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            Oe.then(st, st);
          }
        });
      }
    }
    function FE(V, re, ke) {
      Hh = ke, jh = V, Ii(re), L3(re, V), Ii(re), Hh = null, jh = null;
    }
    function du(V, re, ke) {
      var Oe = re.deletions;
      if (Oe !== null)
        for (var st = 0; st < Oe.length; st++) {
          var bt = Oe[st];
          try {
            NE(V, re, bt);
          } catch (qt) {
            Ji(bt, re, qt);
          }
        }
      var Ct = ed();
      if (re.subtreeFlags & _o)
        for (var Nt = re.child; Nt !== null; )
          Ii(Nt), L3(Nt, V), Nt = Nt.sibling;
      Ii(Ct);
    }
    function L3(V, re, ke) {
      var Oe = V.alternate, st = V.flags;
      switch (V.tag) {
        case at:
        case It:
        case Vt:
        case yr: {
          if (du(re, V), Wu(V), st & hi) {
            try {
              lu(Fu | Fa, V, V.return), Fl(Fu | Fa, V);
            } catch (ai) {
              Ji(V, V.return, ai);
            }
            if (V.mode & si) {
              try {
                qu(), lu(Ha | Fa, V, V.return);
              } catch (ai) {
                Ji(V, V.return, ai);
              }
              zu(V);
            } else
              try {
                lu(Ha | Fa, V, V.return);
              } catch (ai) {
                Ji(V, V.return, ai);
              }
          }
          return;
        }
        case ht: {
          du(re, V), Wu(V), st & go && Oe !== null && zh(Oe, Oe.return);
          return;
        }
        case wt: {
          du(re, V), Wu(V), st & go && Oe !== null && zh(Oe, Oe.return);
          {
            if (V.flags & Di) {
              var bt = V.stateNode;
              try {
                Nb(bt);
              } catch (ai) {
                Ji(V, V.return, ai);
              }
            }
            if (st & hi) {
              var Ct = V.stateNode;
              if (Ct != null) {
                var Nt = V.memoizedProps, qt = Oe !== null ? Oe.memoizedProps : Nt, nr = V.type, ar = V.updateQueue;
                if (V.updateQueue = null, ar !== null)
                  try {
                    X6(Ct, ar, nr, qt, Nt, V);
                  } catch (ai) {
                    Ji(V, V.return, ai);
                  }
              }
            }
          }
          return;
        }
        case Rt: {
          if (du(re, V), Wu(V), st & hi) {
            if (V.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var xr = V.stateNode, Er = V.memoizedProps, Or = Oe !== null ? Oe.memoizedProps : Er;
            try {
              Y6(xr, Or, Er);
            } catch (ai) {
              Ji(V, V.return, ai);
            }
          }
          return;
        }
        case lt: {
          if (du(re, V), Wu(V), st & hi && Oe !== null) {
            var Ur = Oe.memoizedState;
            if (Ur.isDehydrated)
              try {
                _S(re.containerInfo);
              } catch (ai) {
                Ji(V, V.return, ai);
              }
          }
          return;
        }
        case Et: {
          du(re, V), Wu(V);
          return;
        }
        case Jt: {
          du(re, V), Wu(V);
          var qr = V.child;
          if (qr.flags & Au) {
            var Sn = qr.stateNode, Yn = qr.memoizedState, qn = Yn !== null;
            if (Sn.isHidden = qn, qn) {
              var xi = qr.alternate !== null && qr.alternate.memoizedState !== null;
              xi || w5();
            }
          }
          if (st & hi) {
            try {
              LE(V);
            } catch (ai) {
              Ji(V, V.return, ai);
            }
            N3(V);
          }
          return;
        }
        case dt: {
          var wi = Oe !== null && Oe.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            V.mode & zn
          ) {
            var Cr = uo;
            uo = Cr || wi, du(re, V), uo = Cr;
          } else
            du(re, V);
          if (Wu(V), st & Au) {
            var Wr = V.stateNode, Br = V.memoizedState, nn = Br !== null, Bn = V;
            if (Wr.isHidden = nn, nn && !wi && (Bn.mode & zn) !== Hn) {
              Un = Bn;
              for (var $n = Bn.child; $n !== null; )
                Un = $n, jE($n), $n = $n.sibling;
            }
            OE(Bn, nn);
          }
          return;
        }
        case Ht: {
          du(re, V), Wu(V), st & hi && N3(V);
          return;
        }
        case ct:
          return;
        default: {
          du(re, V), Wu(V);
          return;
        }
      }
    }
    function Wu(V) {
      var re = V.flags;
      if (re & Gi) {
        try {
          DE(V);
        } catch (ke) {
          Ji(V, V.return, ke);
        }
        V.flags &= ~Gi;
      }
      re & Yo && (V.flags &= ~Yo);
    }
    function HE(V, re, ke) {
      Hh = ke, jh = re, Un = V, U3(V, re, ke), Hh = null, jh = null;
    }
    function U3(V, re, ke) {
      for (var Oe = (V.mode & zn) !== Hn; Un !== null; ) {
        var st = Un, bt = st.child;
        if (st.tag === dt && Oe) {
          var Ct = st.memoizedState !== null, Nt = Ct || xy;
          if (Nt) {
            Cg(V, re, ke);
            continue;
          } else {
            var qt = st.alternate, nr = qt !== null && qt.memoizedState !== null, ar = nr || uo, xr = xy, Er = uo;
            xy = Nt, uo = ar, uo && !Er && (Un = st, zE(st));
            for (var Or = bt; Or !== null; )
              Un = Or, U3(
                Or,
                // New root; bubble back up to here and stop.
                re,
                ke
              ), Or = Or.sibling;
            Un = st, xy = xr, uo = Er, Cg(V, re, ke);
            continue;
          }
        }
        (st.subtreeFlags & Ya) !== Xn && bt !== null ? (bt.return = st, Un = bt) : Cg(V, re, ke);
      }
    }
    function Cg(V, re, ke) {
      for (; Un !== null; ) {
        var Oe = Un;
        if ((Oe.flags & Ya) !== Xn) {
          var st = Oe.alternate;
          Ii(Oe);
          try {
            kE(re, st, Oe, ke);
          } catch (Ct) {
            Ji(Oe, Oe.return, Ct);
          }
          ua();
        }
        if (Oe === V) {
          Un = null;
          return;
        }
        var bt = Oe.sibling;
        if (bt !== null) {
          bt.return = Oe.return, Un = bt;
          return;
        }
        Un = Oe.return;
      }
    }
    function jE(V) {
      for (; Un !== null; ) {
        var re = Un, ke = re.child;
        switch (re.tag) {
          case at:
          case It:
          case Vt:
          case yr: {
            if (re.mode & si)
              try {
                qu(), lu(Ha, re, re.return);
              } finally {
                zu(re);
              }
            else
              lu(Ha, re, re.return);
            break;
          }
          case ht: {
            zh(re, re.return);
            var Oe = re.stateNode;
            typeof Oe.componentWillUnmount == "function" && Tg(re, re.return, Oe);
            break;
          }
          case wt: {
            zh(re, re.return);
            break;
          }
          case dt: {
            var st = re.memoizedState !== null;
            if (st) {
              F3(V);
              continue;
            }
            break;
          }
        }
        ke !== null ? (ke.return = re, Un = ke) : F3(V);
      }
    }
    function F3(V) {
      for (; Un !== null; ) {
        var re = Un;
        if (re === V) {
          Un = null;
          return;
        }
        var ke = re.sibling;
        if (ke !== null) {
          ke.return = re.return, Un = ke;
          return;
        }
        Un = re.return;
      }
    }
    function zE(V) {
      for (; Un !== null; ) {
        var re = Un, ke = re.child;
        if (re.tag === dt) {
          var Oe = re.memoizedState !== null;
          if (Oe) {
            H3(V);
            continue;
          }
        }
        ke !== null ? (ke.return = re, Un = ke) : H3(V);
      }
    }
    function H3(V) {
      for (; Un !== null; ) {
        var re = Un;
        Ii(re);
        try {
          ME(re);
        } catch (Oe) {
          Ji(re, re.return, Oe);
        }
        if (ua(), re === V) {
          Un = null;
          return;
        }
        var ke = re.sibling;
        if (ke !== null) {
          ke.return = re.return, Un = ke;
          return;
        }
        Un = re.return;
      }
    }
    function qE(V, re, ke, Oe) {
      Un = re, WE(re, V, ke, Oe);
    }
    function WE(V, re, ke, Oe) {
      for (; Un !== null; ) {
        var st = Un, bt = st.child;
        (st.subtreeFlags & Jo) !== Xn && bt !== null ? (bt.return = st, Un = bt) : KE(V, re, ke, Oe);
      }
    }
    function KE(V, re, ke, Oe) {
      for (; Un !== null; ) {
        var st = Un;
        if ((st.flags & Zi) !== Xn) {
          Ii(st);
          try {
            VE(re, st, ke, Oe);
          } catch (Ct) {
            Ji(st, st.return, Ct);
          }
          ua();
        }
        if (st === V) {
          Un = null;
          return;
        }
        var bt = st.sibling;
        if (bt !== null) {
          bt.return = st.return, Un = bt;
          return;
        }
        Un = st.return;
      }
    }
    function VE(V, re, ke, Oe) {
      switch (re.tag) {
        case at:
        case It:
        case yr: {
          if (re.mode & si) {
            G2();
            try {
              Fl(oo | Fa, re);
            } finally {
              V2(re);
            }
          } else
            Fl(oo | Fa, re);
          break;
        }
      }
    }
    function GE(V) {
      Un = V, XE();
    }
    function XE() {
      for (; Un !== null; ) {
        var V = Un, re = V.child;
        if ((Un.flags & Oi) !== Xn) {
          var ke = V.deletions;
          if (ke !== null) {
            for (var Oe = 0; Oe < ke.length; Oe++) {
              var st = ke[Oe];
              Un = st, QE(st, V);
            }
            {
              var bt = V.alternate;
              if (bt !== null) {
                var Ct = bt.child;
                if (Ct !== null) {
                  bt.child = null;
                  do {
                    var Nt = Ct.sibling;
                    Ct.sibling = null, Ct = Nt;
                  } while (Ct !== null);
                }
              }
            }
            Un = V;
          }
        }
        (V.subtreeFlags & Jo) !== Xn && re !== null ? (re.return = V, Un = re) : YE();
      }
    }
    function YE() {
      for (; Un !== null; ) {
        var V = Un;
        (V.flags & Zi) !== Xn && (Ii(V), JE(V), ua());
        var re = V.sibling;
        if (re !== null) {
          re.return = V.return, Un = re;
          return;
        }
        Un = V.return;
      }
    }
    function JE(V) {
      switch (V.tag) {
        case at:
        case It:
        case yr: {
          V.mode & si ? (G2(), lu(oo | Fa, V, V.return), V2(V)) : lu(oo | Fa, V, V.return);
          break;
        }
      }
    }
    function QE(V, re) {
      for (; Un !== null; ) {
        var ke = Un;
        Ii(ke), e5(ke, re), ua();
        var Oe = ke.child;
        Oe !== null ? (Oe.return = ke, Un = Oe) : ZE(V);
      }
    }
    function ZE(V) {
      for (; Un !== null; ) {
        var re = Un, ke = re.sibling, Oe = re.return;
        if (O3(re), re === V) {
          Un = null;
          return;
        }
        if (ke !== null) {
          ke.return = Oe, Un = ke;
          return;
        }
        Un = Oe;
      }
    }
    function e5(V, re) {
      switch (V.tag) {
        case at:
        case It:
        case yr: {
          V.mode & si ? (G2(), lu(oo, V, re), V2(V)) : lu(oo, V, re);
          break;
        }
      }
    }
    function t5(V) {
      switch (V.tag) {
        case at:
        case It:
        case yr: {
          try {
            Fl(Ha | Fa, V);
          } catch (ke) {
            Ji(V, V.return, ke);
          }
          break;
        }
        case ht: {
          var re = V.stateNode;
          try {
            re.componentDidMount();
          } catch (ke) {
            Ji(V, V.return, ke);
          }
          break;
        }
      }
    }
    function r5(V) {
      switch (V.tag) {
        case at:
        case It:
        case yr: {
          try {
            Fl(oo | Fa, V);
          } catch (re) {
            Ji(V, V.return, re);
          }
          break;
        }
      }
    }
    function n5(V) {
      switch (V.tag) {
        case at:
        case It:
        case yr: {
          try {
            lu(Ha | Fa, V, V.return);
          } catch (ke) {
            Ji(V, V.return, ke);
          }
          break;
        }
        case ht: {
          var re = V.stateNode;
          typeof re.componentWillUnmount == "function" && Tg(V, V.return, re);
          break;
        }
      }
    }
    function i5(V) {
      switch (V.tag) {
        case at:
        case It:
        case yr:
          try {
            lu(oo | Fa, V, V.return);
          } catch (re) {
            Ji(V, V.return, re);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var N0 = Symbol.for;
      N0("selector.component"), N0("selector.has_pseudo_class"), N0("selector.role"), N0("selector.test_id"), N0("selector.text");
    }
    var a5 = [];
    function o5() {
      a5.forEach(function(V) {
        return V();
      });
    }
    var s5 = J.ReactCurrentActQueue;
    function u5(V) {
      {
        var re = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), ke = typeof jest < "u";
        return ke && re !== !1;
      }
    }
    function j3() {
      {
        var V = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !V && s5.current !== null && Ce("The current testing environment is not configured to support act(...)"), V;
      }
    }
    var f5 = Math.ceil, Bg = J.ReactCurrentDispatcher, kg = J.ReactCurrentOwner, lo = J.ReactCurrentBatchConfig, hu = J.ReactCurrentActQueue, qa = (
      /*             */
      0
    ), z3 = (
      /*               */
      1
    ), co = (
      /*                */
      2
    ), Ds = (
      /*                */
      4
    ), Cf = 0, L0 = 1, Gc = 2, Ay = 3, U0 = 4, q3 = 5, Mg = 6, $i = qa, Ho = null, ya = null, Wa = Jr, Ku = Jr, Og = kl(Jr), Ka = Cf, F0 = null, Ry = Jr, H0 = Jr, Cy = Jr, j0 = null, ls = null, Pg = 0, W3 = 500, K3 = 1 / 0, l5 = 500, Bf = null;
    function z0() {
      K3 = ia() + l5;
    }
    function V3() {
      return K3;
    }
    var By = !1, Ig = null, qh = null, Xc = !1, jl = null, q0 = Jr, Dg = [], Ng = null, c5 = 50, W0 = 0, Lg = null, Ug = !1, ky = !1, d5 = 50, Wh = 0, My = null, K0 = Vi, Oy = Jr, G3 = !1;
    function Py() {
      return Ho;
    }
    function jo() {
      return ($i & (co | Ds)) !== qa ? ia() : (K0 !== Vi || (K0 = ia()), K0);
    }
    function ql(V) {
      var re = V.mode;
      if ((re & zn) === Hn)
        return Vn;
      if (($i & co) !== qa && Wa !== Jr)
        return cl(Wa);
      var ke = o4() !== a4;
      if (ke) {
        if (lo.transition !== null) {
          var Oe = lo.transition;
          Oe._updatedFibers || (Oe._updatedFibers = /* @__PURE__ */ new Set()), Oe._updatedFibers.add(V);
        }
        return Oy === wa && (Oy = K1()), Oy;
      }
      var st = rs();
      if (st !== wa)
        return st;
      var bt = q6();
      return bt;
    }
    function h5(V) {
      var re = V.mode;
      return (re & zn) === Hn ? Vn : xo();
    }
    function Va(V, re, ke, Oe) {
      N5(), G3 && Ce("useInsertionEffect must not schedule updates."), Ug && (ky = !0), vf(V, ke, Oe), ($i & co) !== Jr && V === Ho ? F5(re) : (No && Vd(V, re, ke), H5(re), V === Ho && (($i & co) === qa && (H0 = di(H0, ke)), Ka === U0 && Wl(V, Wa)), cs(V, Oe), ke === Vn && $i === qa && (re.mode & zn) === Hn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !hu.isBatchingLegacy && (z0(), Gb()));
    }
    function p5(V, re, ke) {
      var Oe = V.current;
      Oe.lanes = re, vf(V, re, ke), cs(V, ke);
    }
    function v5(V) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        ($i & co) !== qa
      );
    }
    function cs(V, re) {
      var ke = V.callbackNode;
      H1(V, re);
      var Oe = hf(V, V === Ho ? Wa : Jr);
      if (Oe === Jr) {
        ke !== null && l_(ke), V.callbackNode = null, V.callbackPriority = wa;
        return;
      }
      var st = ha(Oe), bt = V.callbackPriority;
      if (bt === st && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(hu.current !== null && ke !== Kg)) {
        ke == null && bt !== Vn && Ce("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      ke != null && l_(ke);
      var Ct;
      if (st === Vn)
        V.tag === Ml ? (hu.isBatchingLegacy !== null && (hu.didScheduleLegacyUpdate = !0), jS(J3.bind(null, V))) : Vb(J3.bind(null, V)), hu.current !== null ? hu.current.push(Ol) : K6(function() {
          ($i & (co | Ds)) === qa && Ol();
        }), Ct = null;
      else {
        var Nt;
        switch (Ua(Oe)) {
          case pa:
            Nt = bd;
            break;
          case Zs:
            Nt = of;
            break;
          case As:
            Nt = Ts;
            break;
          case dl:
            Nt = wd;
            break;
          default:
            Nt = Ts;
            break;
        }
        Ct = Vg(Nt, X3.bind(null, V));
      }
      V.callbackPriority = st, V.callbackNode = Ct;
    }
    function X3(V, re) {
      if (M4(), K0 = Vi, Oy = Jr, ($i & (co | Ds)) !== qa)
        throw new Error("Should not already be working.");
      var ke = V.callbackNode, Oe = Mf();
      if (Oe && V.callbackNode !== ke)
        return null;
      var st = hf(V, V === Ho ? Wa : Jr);
      if (st === Jr)
        return null;
      var bt = !_c(V, st) && !W1(V, st) && !re, Ct = bt ? x5(V, st) : Dy(V, st);
      if (Ct !== Cf) {
        if (Ct === Gc) {
          var Nt = Mu(V);
          Nt !== Jr && (st = Nt, Ct = Fg(V, Nt));
        }
        if (Ct === L0) {
          var qt = F0;
          throw Yc(V, Jr), Wl(V, st), cs(V, ia()), qt;
        }
        if (Ct === Mg)
          Wl(V, st);
        else {
          var nr = !_c(V, st), ar = V.current.alternate;
          if (nr && !m5(ar)) {
            if (Ct = Dy(V, st), Ct === Gc) {
              var xr = Mu(V);
              xr !== Jr && (st = xr, Ct = Fg(V, xr));
            }
            if (Ct === L0) {
              var Er = F0;
              throw Yc(V, Jr), Wl(V, st), cs(V, ia()), Er;
            }
          }
          V.finishedWork = ar, V.finishedLanes = st, y5(V, Ct, st);
        }
      }
      return cs(V, ia()), V.callbackNode === ke ? X3.bind(null, V) : null;
    }
    function Fg(V, re) {
      var ke = j0;
      if (Gd(V)) {
        var Oe = Yc(V, re);
        Oe.flags |= fa, IS(V.containerInfo);
      }
      var st = Dy(V, re);
      if (st !== Gc) {
        var bt = ls;
        ls = ke, bt !== null && Y3(bt);
      }
      return st;
    }
    function Y3(V) {
      ls === null ? ls = V : ls.push.apply(ls, V);
    }
    function y5(V, re, ke) {
      switch (re) {
        case Cf:
        case L0:
          throw new Error("Root did not complete. This is a bug in React.");
        case Gc: {
          Jc(V, ls, Bf);
          break;
        }
        case Ay: {
          if (Wl(V, ke), j1(ke) && // do not delay if we're inside an act() scope
          !c_()) {
            var Oe = Pg + W3 - ia();
            if (Oe > 10) {
              var st = hf(V, Jr);
              if (st !== Jr)
                break;
              var bt = V.suspendedLanes;
              if (!pf(bt, ke)) {
                jo(), Wd(V, bt);
                break;
              }
              V.timeoutHandle = Nm(Jc.bind(null, V, ls, Bf), Oe);
              break;
            }
          }
          Jc(V, ls, Bf);
          break;
        }
        case U0: {
          if (Wl(V, ke), q1(ke))
            break;
          if (!c_()) {
            var Ct = U1(V, ke), Nt = Ct, qt = ia() - Nt, nr = D5(qt) - qt;
            if (nr > 10) {
              V.timeoutHandle = Nm(Jc.bind(null, V, ls, Bf), nr);
              break;
            }
          }
          Jc(V, ls, Bf);
          break;
        }
        case q3: {
          Jc(V, ls, Bf);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function m5(V) {
      for (var re = V; ; ) {
        if (re.flags & cc) {
          var ke = re.updateQueue;
          if (ke !== null) {
            var Oe = ke.stores;
            if (Oe !== null)
              for (var st = 0; st < Oe.length; st++) {
                var bt = Oe[st], Ct = bt.getSnapshot, Nt = bt.value;
                try {
                  if (!Ln(Ct(), Nt))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var qt = re.child;
        if (re.subtreeFlags & cc && qt !== null) {
          qt.return = re, re = qt;
          continue;
        }
        if (re === V)
          return !0;
        for (; re.sibling === null; ) {
          if (re.return === null || re.return === V)
            return !0;
          re = re.return;
        }
        re.sibling.return = re.return, re = re.sibling;
      }
      return !0;
    }
    function Wl(V, re) {
      re = Sc(re, Cy), re = Sc(re, H0), G1(V, re);
    }
    function J3(V) {
      if (O4(), ($i & (co | Ds)) !== qa)
        throw new Error("Should not already be working.");
      Mf();
      var re = hf(V, Jr);
      if (!To(re, Vn))
        return cs(V, ia()), null;
      var ke = Dy(V, re);
      if (V.tag !== Ml && ke === Gc) {
        var Oe = Mu(V);
        Oe !== Jr && (re = Oe, ke = Fg(V, Oe));
      }
      if (ke === L0) {
        var st = F0;
        throw Yc(V, Jr), Wl(V, re), cs(V, ia()), st;
      }
      if (ke === Mg)
        throw new Error("Root did not complete. This is a bug in React.");
      var bt = V.current.alternate;
      return V.finishedWork = bt, V.finishedLanes = re, Jc(V, ls, Bf), cs(V, ia()), null;
    }
    function g5(V, re) {
      re !== Jr && (Dp(V, di(re, Vn)), cs(V, ia()), ($i & (co | Ds)) === qa && (z0(), Ol()));
    }
    function Hg(V, re) {
      var ke = $i;
      $i |= z3;
      try {
        return V(re);
      } finally {
        $i = ke, $i === qa && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !hu.isBatchingLegacy && (z0(), Gb());
      }
    }
    function b5(V, re, ke, Oe, st) {
      var bt = rs(), Ct = lo.transition;
      try {
        return lo.transition = null, la(pa), V(re, ke, Oe, st);
      } finally {
        la(bt), lo.transition = Ct, $i === qa && z0();
      }
    }
    function kf(V) {
      jl !== null && jl.tag === Ml && ($i & (co | Ds)) === qa && Mf();
      var re = $i;
      $i |= z3;
      var ke = lo.transition, Oe = rs();
      try {
        return lo.transition = null, la(pa), V ? V() : void 0;
      } finally {
        la(Oe), lo.transition = ke, $i = re, ($i & (co | Ds)) === qa && Ol();
      }
    }
    function Q3() {
      return ($i & (co | Ds)) !== qa;
    }
    function Iy(V, re) {
      Co(Og, Ku, V), Ku = di(Ku, re);
    }
    function jg(V) {
      Ku = Og.current, Ro(Og, V);
    }
    function Yc(V, re) {
      V.finishedWork = null, V.finishedLanes = Jr;
      var ke = V.timeoutHandle;
      if (ke !== Lm && (V.timeoutHandle = Lm, W6(ke)), ya !== null)
        for (var Oe = ya.return; Oe !== null; ) {
          var st = Oe.alternate;
          A3(st, Oe), Oe = Oe.return;
        }
      Ho = V;
      var bt = Qc(V.current, null);
      return ya = bt, Wa = Ku = re, Ka = Cf, F0 = null, Ry = Jr, H0 = Jr, Cy = Jr, j0 = null, ls = null, h4(), au.discardPendingWarnings(), bt;
    }
    function Z3(V, re) {
      do {
        var ke = ya;
        try {
          if (Wv(), Ew(), ua(), kg.current = null, ke === null || ke.return === null) {
            Ka = L0, F0 = re, ya = null;
            return;
          }
          if (tr && ke.mode & si && wy(ke, !0), dr)
            if (Eo(), re !== null && typeof re == "object" && typeof re.then == "function") {
              var Oe = re;
              uf(ke, Oe, Wa);
            } else
              pc(ke, re, Wa);
          j4(V, ke.return, ke, re, Wa), n_(ke);
        } catch (st) {
          re = st, ya === ke && ke !== null ? (ke = ke.return, ya = ke) : ke = ya;
          continue;
        }
        return;
      } while (!0);
    }
    function e_() {
      var V = Bg.current;
      return Bg.current = vy, V === null ? vy : V;
    }
    function t_(V) {
      Bg.current = V;
    }
    function w5() {
      Pg = ia();
    }
    function V0(V) {
      Ry = di(V, Ry);
    }
    function _5() {
      Ka === Cf && (Ka = Ay);
    }
    function zg() {
      (Ka === Cf || Ka === Ay || Ka === Gc) && (Ka = U0), Ho !== null && (wc(Ry) || wc(H0)) && Wl(Ho, Wa);
    }
    function S5(V) {
      Ka !== U0 && (Ka = Gc), j0 === null ? j0 = [V] : j0.push(V);
    }
    function E5() {
      return Ka === Cf;
    }
    function Dy(V, re) {
      var ke = $i;
      $i |= co;
      var Oe = e_();
      if (Ho !== V || Wa !== re) {
        if (No) {
          var st = V.memoizedUpdaters;
          st.size > 0 && (G0(V, Wa), st.clear()), Np(V, re);
        }
        Bf = $c(), Yc(V, re);
      }
      ea(re);
      do
        try {
          $5();
          break;
        } catch (bt) {
          Z3(V, bt);
        }
      while (!0);
      if (Wv(), $i = ke, t_(Oe), ya !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return xd(), Ho = null, Wa = Jr, Ka;
    }
    function $5() {
      for (; ya !== null; )
        r_(ya);
    }
    function x5(V, re) {
      var ke = $i;
      $i |= co;
      var Oe = e_();
      if (Ho !== V || Wa !== re) {
        if (No) {
          var st = V.memoizedUpdaters;
          st.size > 0 && (G0(V, Wa), st.clear()), Np(V, re);
        }
        Bf = $c(), z0(), Yc(V, re);
      }
      ea(re);
      do
        try {
          T5();
          break;
        } catch (bt) {
          Z3(V, bt);
        }
      while (!0);
      return Wv(), t_(Oe), $i = ke, ya !== null ? ($d(), Cf) : (xd(), Ho = null, Wa = Jr, Ka);
    }
    function T5() {
      for (; ya !== null && !gd(); )
        r_(ya);
    }
    function r_(V) {
      var re = V.alternate;
      Ii(V);
      var ke;
      (V.mode & si) !== Hn ? (K2(V), ke = qg(re, V, Ku), wy(V, !0)) : ke = qg(re, V, Ku), ua(), V.memoizedProps = V.pendingProps, ke === null ? n_(V) : ya = ke, kg.current = null;
    }
    function n_(V) {
      var re = V;
      do {
        var ke = re.alternate, Oe = re.return;
        if ((re.flags & Po) === Xn) {
          Ii(re);
          var st = void 0;
          if ((re.mode & si) === Hn ? st = T3(ke, re, Ku) : (K2(re), st = T3(ke, re, Ku), wy(re, !1)), ua(), st !== null) {
            ya = st;
            return;
          }
        } else {
          var bt = wE(ke, re);
          if (bt !== null) {
            bt.flags &= R1, ya = bt;
            return;
          }
          if ((re.mode & si) !== Hn) {
            wy(re, !1);
            for (var Ct = re.actualDuration, Nt = re.child; Nt !== null; )
              Ct += Nt.actualDuration, Nt = Nt.sibling;
            re.actualDuration = Ct;
          }
          if (Oe !== null)
            Oe.flags |= Po, Oe.subtreeFlags = Xn, Oe.deletions = null;
          else {
            Ka = Mg, ya = null;
            return;
          }
        }
        var qt = re.sibling;
        if (qt !== null) {
          ya = qt;
          return;
        }
        re = Oe, ya = re;
      } while (re !== null);
      Ka === Cf && (Ka = q3);
    }
    function Jc(V, re, ke) {
      var Oe = rs(), st = lo.transition;
      try {
        lo.transition = null, la(pa), A5(V, re, ke, Oe);
      } finally {
        lo.transition = st, la(Oe);
      }
      return null;
    }
    function A5(V, re, ke, Oe) {
      do
        Mf();
      while (jl !== null);
      if (L5(), ($i & (co | Ds)) !== qa)
        throw new Error("Should not already be working.");
      var st = V.finishedWork, bt = V.finishedLanes;
      if (Cu(bt), st === null)
        return _d(), null;
      if (bt === Jr && Ce("root.finishedLanes should not be empty during a commit. This is a bug in React."), V.finishedWork = null, V.finishedLanes = Jr, st === V.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      V.callbackNode = null, V.callbackPriority = wa;
      var Ct = di(st.lanes, st.childLanes);
      Kd(V, Ct), V === Ho && (Ho = null, ya = null, Wa = Jr), ((st.subtreeFlags & Jo) !== Xn || (st.flags & Jo) !== Xn) && (Xc || (Xc = !0, Ng = ke, Vg(Ts, function() {
        return Mf(), null;
      })));
      var Nt = (st.subtreeFlags & (Jf | _o | Ya | Jo)) !== Xn, qt = (st.flags & (Jf | _o | Ya | Jo)) !== Xn;
      if (Nt || qt) {
        var nr = lo.transition;
        lo.transition = null;
        var ar = rs();
        la(pa);
        var xr = $i;
        $i |= Ds, kg.current = null, TE(V, st), Gw(), FE(V, st, bt), L6(V.containerInfo), V.current = st, Rp(bt), HE(st, V, bt), rl(), k1(), $i = xr, la(ar), lo.transition = nr;
      } else
        V.current = st, Gw();
      var Er = Xc;
      if (Xc ? (Xc = !1, jl = V, q0 = bt) : (Wh = 0, My = null), Ct = V.pendingLanes, Ct === Jr && (qh = null), Er || s_(V.current, !1), Zf(st.stateNode, Oe), No && V.memoizedUpdaters.clear(), o5(), cs(V, ia()), re !== null)
        for (var Or = V.onRecoverableError, Ur = 0; Ur < re.length; Ur++) {
          var qr = re[Ur], Sn = qr.stack, Yn = qr.digest;
          Or(qr.value, {
            componentStack: Sn,
            digest: Yn
          });
        }
      if (By) {
        By = !1;
        var qn = Ig;
        throw Ig = null, qn;
      }
      return To(q0, Vn) && V.tag !== Ml && Mf(), Ct = V.pendingLanes, To(Ct, Vn) ? (k4(), V === Lg ? W0++ : (W0 = 0, Lg = V)) : W0 = 0, Ol(), _d(), null;
    }
    function Mf() {
      if (jl !== null) {
        var V = Ua(q0), re = um(As, V), ke = lo.transition, Oe = rs();
        try {
          return lo.transition = null, la(re), C5();
        } finally {
          la(Oe), lo.transition = ke;
        }
      }
      return !1;
    }
    function R5(V) {
      Dg.push(V), Xc || (Xc = !0, Vg(Ts, function() {
        return Mf(), null;
      }));
    }
    function C5() {
      if (jl === null)
        return !1;
      var V = Ng;
      Ng = null;
      var re = jl, ke = q0;
      if (jl = null, q0 = Jr, ($i & (co | Ds)) !== qa)
        throw new Error("Cannot flush passive effects while already rendering.");
      Ug = !0, ky = !1, N1(ke);
      var Oe = $i;
      $i |= Ds, GE(re.current), qE(re, re.current, ke, V);
      {
        var st = Dg;
        Dg = [];
        for (var bt = 0; bt < st.length; bt++) {
          var Ct = st[bt];
          BE(re, Ct);
        }
      }
      Cp(), s_(re.current, !0), $i = Oe, Ol(), ky ? re === My ? Wh++ : (Wh = 0, My = re) : Wh = 0, Ug = !1, ky = !1, es(re);
      {
        var Nt = re.current.stateNode;
        Nt.effectDuration = 0, Nt.passiveEffectDuration = 0;
      }
      return !0;
    }
    function i_(V) {
      return qh !== null && qh.has(V);
    }
    function B5(V) {
      qh === null ? qh = /* @__PURE__ */ new Set([V]) : qh.add(V);
    }
    function k5(V) {
      By || (By = !0, Ig = V);
    }
    var M5 = k5;
    function a_(V, re, ke) {
      var Oe = Kc(ke, re), st = r3(V, Oe, Vn), bt = Il(V, st, Vn), Ct = jo();
      bt !== null && (vf(bt, Vn, Ct), cs(bt, Ct));
    }
    function Ji(V, re, ke) {
      if (SE(ke), X0(!1), V.tag === lt) {
        a_(V, V, ke);
        return;
      }
      var Oe = null;
      for (Oe = re; Oe !== null; ) {
        if (Oe.tag === lt) {
          a_(Oe, V, ke);
          return;
        } else if (Oe.tag === ht) {
          var st = Oe.type, bt = Oe.stateNode;
          if (typeof st.getDerivedStateFromError == "function" || typeof bt.componentDidCatch == "function" && !i_(bt)) {
            var Ct = Kc(ke, V), Nt = lg(Oe, Ct, Vn), qt = Il(Oe, Nt, Vn), nr = jo();
            qt !== null && (vf(qt, Vn, nr), cs(qt, nr));
            return;
          }
        }
        Oe = Oe.return;
      }
      Ce(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, ke);
    }
    function O5(V, re, ke) {
      var Oe = V.pingCache;
      Oe !== null && Oe.delete(re);
      var st = jo();
      Wd(V, ke), j5(V), Ho === V && pf(Wa, ke) && (Ka === U0 || Ka === Ay && j1(Wa) && ia() - Pg < W3 ? Yc(V, Jr) : Cy = di(Cy, ke)), cs(V, st);
    }
    function o_(V, re) {
      re === wa && (re = h5(V));
      var ke = jo(), Oe = us(V, re);
      Oe !== null && (vf(Oe, re, ke), cs(Oe, ke));
    }
    function P5(V) {
      var re = V.memoizedState, ke = wa;
      re !== null && (ke = re.retryLane), o_(V, ke);
    }
    function I5(V, re) {
      var ke = wa, Oe;
      switch (V.tag) {
        case Jt:
          Oe = V.stateNode;
          var st = V.memoizedState;
          st !== null && (ke = st.retryLane);
          break;
        case Ht:
          Oe = V.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      Oe !== null && Oe.delete(re), o_(V, ke);
    }
    function D5(V) {
      return V < 120 ? 120 : V < 480 ? 480 : V < 1080 ? 1080 : V < 1920 ? 1920 : V < 3e3 ? 3e3 : V < 4320 ? 4320 : f5(V / 1960) * 1960;
    }
    function N5() {
      if (W0 > c5)
        throw W0 = 0, Lg = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Wh > d5 && (Wh = 0, My = null, Ce("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function L5() {
      au.flushLegacyContextWarning(), au.flushPendingUnsafeLifecycleWarnings();
    }
    function s_(V, re) {
      Ii(V), Ny(V, wo, n5), re && Ny(V, af, i5), Ny(V, wo, t5), re && Ny(V, af, r5), ua();
    }
    function Ny(V, re, ke) {
      for (var Oe = V, st = null; Oe !== null; ) {
        var bt = Oe.subtreeFlags & re;
        Oe !== st && Oe.child !== null && bt !== Xn ? Oe = Oe.child : ((Oe.flags & re) !== Xn && ke(Oe), Oe.sibling !== null ? Oe = Oe.sibling : Oe = st = Oe.return);
      }
    }
    var Ly = null;
    function u_(V) {
      {
        if (($i & co) !== qa || !(V.mode & zn))
          return;
        var re = V.tag;
        if (re !== it && re !== lt && re !== ht && re !== at && re !== It && re !== Vt && re !== yr)
          return;
        var ke = ui(V) || "ReactComponent";
        if (Ly !== null) {
          if (Ly.has(ke))
            return;
          Ly.add(ke);
        } else
          Ly = /* @__PURE__ */ new Set([ke]);
        var Oe = na;
        try {
          Ii(V), Ce("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          Oe ? Ii(V) : ua();
        }
      }
    }
    var qg;
    {
      var U5 = null;
      qg = function(V, re, ke) {
        var Oe = y_(U5, re);
        try {
          return _3(V, re, ke);
        } catch (bt) {
          if (YS() || bt !== null && typeof bt == "object" && typeof bt.then == "function")
            throw bt;
          if (Wv(), Ew(), A3(V, re), y_(re, Oe), re.mode & si && K2(re), nf(null, _3, null, V, re, ke), nm()) {
            var st = bp();
            typeof st == "object" && st !== null && st._suppressLogging && typeof bt == "object" && bt !== null && !bt._suppressLogging && (bt._suppressLogging = !0);
          }
          throw bt;
        }
      };
    }
    var f_ = !1, Wg;
    Wg = /* @__PURE__ */ new Set();
    function F5(V) {
      if (vo && !R4())
        switch (V.tag) {
          case at:
          case It:
          case yr: {
            var re = ya && ui(ya) || "Unknown", ke = re;
            if (!Wg.has(ke)) {
              Wg.add(ke);
              var Oe = ui(V) || "Unknown";
              Ce("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", Oe, re, re);
            }
            break;
          }
          case ht: {
            f_ || (Ce("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), f_ = !0);
            break;
          }
        }
    }
    function G0(V, re) {
      if (No) {
        var ke = V.memoizedUpdaters;
        ke.forEach(function(Oe) {
          Vd(V, Oe, re);
        });
      }
    }
    var Kg = {};
    function Vg(V, re) {
      {
        var ke = hu.current;
        return ke !== null ? (ke.push(re), Kg) : md(V, re);
      }
    }
    function l_(V) {
      if (V !== Kg)
        return B1(V);
    }
    function c_() {
      return hu.current !== null;
    }
    function H5(V) {
      {
        if (V.mode & zn) {
          if (!j3())
            return;
        } else if (!u5() || $i !== qa || V.tag !== at && V.tag !== It && V.tag !== yr)
          return;
        if (hu.current === null) {
          var re = na;
          try {
            Ii(V), Ce(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, ui(V));
          } finally {
            re ? Ii(V) : ua();
          }
        }
      }
    }
    function j5(V) {
      V.tag !== Ml && j3() && hu.current === null && Ce(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function X0(V) {
      G3 = V;
    }
    var Ns = null, Vh = null, z5 = function(V) {
      Ns = V;
    };
    function Gh(V) {
      {
        if (Ns === null)
          return V;
        var re = Ns(V);
        return re === void 0 ? V : re.current;
      }
    }
    function Gg(V) {
      return Gh(V);
    }
    function Xg(V) {
      {
        if (Ns === null)
          return V;
        var re = Ns(V);
        if (re === void 0) {
          if (V != null && typeof V.render == "function") {
            var ke = Gh(V.render);
            if (V.render !== ke) {
              var Oe = {
                $$typeof: Ir,
                render: ke
              };
              return V.displayName !== void 0 && (Oe.displayName = V.displayName), Oe;
            }
          }
          return V;
        }
        return re.current;
      }
    }
    function d_(V, re) {
      {
        if (Ns === null)
          return !1;
        var ke = V.elementType, Oe = re.type, st = !1, bt = typeof Oe == "object" && Oe !== null ? Oe.$$typeof : null;
        switch (V.tag) {
          case ht: {
            typeof Oe == "function" && (st = !0);
            break;
          }
          case at: {
            (typeof Oe == "function" || bt === Dn) && (st = !0);
            break;
          }
          case It: {
            (bt === Ir || bt === Dn) && (st = !0);
            break;
          }
          case Vt:
          case yr: {
            (bt === kn || bt === Dn) && (st = !0);
            break;
          }
          default:
            return !1;
        }
        if (st) {
          var Ct = Ns(ke);
          if (Ct !== void 0 && Ct === Ns(Oe))
            return !0;
        }
        return !1;
      }
    }
    function h_(V) {
      {
        if (Ns === null || typeof WeakSet != "function")
          return;
        Vh === null && (Vh = /* @__PURE__ */ new WeakSet()), Vh.add(V);
      }
    }
    var q5 = function(V, re) {
      {
        if (Ns === null)
          return;
        var ke = re.staleFamilies, Oe = re.updatedFamilies;
        Mf(), kf(function() {
          Yg(V.current, Oe, ke);
        });
      }
    }, W5 = function(V, re) {
      {
        if (V.context !== bs)
          return;
        Mf(), kf(function() {
          Y0(re, V, null, null);
        });
      }
    };
    function Yg(V, re, ke) {
      {
        var Oe = V.alternate, st = V.child, bt = V.sibling, Ct = V.tag, Nt = V.type, qt = null;
        switch (Ct) {
          case at:
          case yr:
          case ht:
            qt = Nt;
            break;
          case It:
            qt = Nt.render;
            break;
        }
        if (Ns === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var nr = !1, ar = !1;
        if (qt !== null) {
          var xr = Ns(qt);
          xr !== void 0 && (ke.has(xr) ? ar = !0 : re.has(xr) && (Ct === ht ? ar = !0 : nr = !0));
        }
        if (Vh !== null && (Vh.has(V) || Oe !== null && Vh.has(Oe)) && (ar = !0), ar && (V._debugNeedsRemount = !0), ar || nr) {
          var Er = us(V, Vn);
          Er !== null && Va(Er, V, Vn, Vi);
        }
        st !== null && !ar && Yg(st, re, ke), bt !== null && Yg(bt, re, ke);
      }
    }
    var K5 = function(V, re) {
      {
        var ke = /* @__PURE__ */ new Set(), Oe = new Set(re.map(function(st) {
          return st.current;
        }));
        return Jg(V.current, Oe, ke), ke;
      }
    };
    function Jg(V, re, ke) {
      {
        var Oe = V.child, st = V.sibling, bt = V.tag, Ct = V.type, Nt = null;
        switch (bt) {
          case at:
          case yr:
          case ht:
            Nt = Ct;
            break;
          case It:
            Nt = Ct.render;
            break;
        }
        var qt = !1;
        Nt !== null && re.has(Nt) && (qt = !0), qt ? V5(V, ke) : Oe !== null && Jg(Oe, re, ke), st !== null && Jg(st, re, ke);
      }
    }
    function V5(V, re) {
      {
        var ke = G5(V, re);
        if (ke)
          return;
        for (var Oe = V; ; ) {
          switch (Oe.tag) {
            case wt:
              re.add(Oe.stateNode);
              return;
            case Et:
              re.add(Oe.stateNode.containerInfo);
              return;
            case lt:
              re.add(Oe.stateNode.containerInfo);
              return;
          }
          if (Oe.return === null)
            throw new Error("Expected to reach root first.");
          Oe = Oe.return;
        }
      }
    }
    function G5(V, re) {
      for (var ke = V, Oe = !1; ; ) {
        if (ke.tag === wt)
          Oe = !0, re.add(ke.stateNode);
        else if (ke.child !== null) {
          ke.child.return = ke, ke = ke.child;
          continue;
        }
        if (ke === V)
          return Oe;
        for (; ke.sibling === null; ) {
          if (ke.return === null || ke.return === V)
            return Oe;
          ke = ke.return;
        }
        ke.sibling.return = ke.return, ke = ke.sibling;
      }
      return !1;
    }
    var Qg;
    {
      Qg = !1;
      try {
        var p_ = Object.preventExtensions({});
      } catch {
        Qg = !0;
      }
    }
    function X5(V, re, ke, Oe) {
      this.tag = V, this.key = ke, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = re, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = Oe, this.flags = Xn, this.subtreeFlags = Xn, this.deletions = null, this.lanes = Jr, this.childLanes = Jr, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Qg && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ws = function(V, re, ke, Oe) {
      return new X5(V, re, ke, Oe);
    };
    function Zg(V) {
      var re = V.prototype;
      return !!(re && re.isReactComponent);
    }
    function Y5(V) {
      return typeof V == "function" && !Zg(V) && V.defaultProps === void 0;
    }
    function J5(V) {
      if (typeof V == "function")
        return Zg(V) ? ht : at;
      if (V != null) {
        var re = V.$$typeof;
        if (re === Ir)
          return It;
        if (re === kn)
          return Vt;
      }
      return it;
    }
    function Qc(V, re) {
      var ke = V.alternate;
      ke === null ? (ke = ws(V.tag, re, V.key, V.mode), ke.elementType = V.elementType, ke.type = V.type, ke.stateNode = V.stateNode, ke._debugSource = V._debugSource, ke._debugOwner = V._debugOwner, ke._debugHookTypes = V._debugHookTypes, ke.alternate = V, V.alternate = ke) : (ke.pendingProps = re, ke.type = V.type, ke.flags = Xn, ke.subtreeFlags = Xn, ke.deletions = null, ke.actualDuration = 0, ke.actualStartTime = -1), ke.flags = V.flags & Na, ke.childLanes = V.childLanes, ke.lanes = V.lanes, ke.child = V.child, ke.memoizedProps = V.memoizedProps, ke.memoizedState = V.memoizedState, ke.updateQueue = V.updateQueue;
      var Oe = V.dependencies;
      switch (ke.dependencies = Oe === null ? null : {
        lanes: Oe.lanes,
        firstContext: Oe.firstContext
      }, ke.sibling = V.sibling, ke.index = V.index, ke.ref = V.ref, ke.selfBaseDuration = V.selfBaseDuration, ke.treeBaseDuration = V.treeBaseDuration, ke._debugNeedsRemount = V._debugNeedsRemount, ke.tag) {
        case it:
        case at:
        case yr:
          ke.type = Gh(V.type);
          break;
        case ht:
          ke.type = Gg(V.type);
          break;
        case It:
          ke.type = Xg(V.type);
          break;
      }
      return ke;
    }
    function Q5(V, re) {
      V.flags &= Na | Gi;
      var ke = V.alternate;
      if (ke === null)
        V.childLanes = Jr, V.lanes = re, V.child = null, V.subtreeFlags = Xn, V.memoizedProps = null, V.memoizedState = null, V.updateQueue = null, V.dependencies = null, V.stateNode = null, V.selfBaseDuration = 0, V.treeBaseDuration = 0;
      else {
        V.childLanes = ke.childLanes, V.lanes = ke.lanes, V.child = ke.child, V.subtreeFlags = Xn, V.deletions = null, V.memoizedProps = ke.memoizedProps, V.memoizedState = ke.memoizedState, V.updateQueue = ke.updateQueue, V.type = ke.type;
        var Oe = ke.dependencies;
        V.dependencies = Oe === null ? null : {
          lanes: Oe.lanes,
          firstContext: Oe.firstContext
        }, V.selfBaseDuration = ke.selfBaseDuration, V.treeBaseDuration = ke.treeBaseDuration;
      }
      return V;
    }
    function Z5(V, re, ke) {
      var Oe;
      return V === Iv ? (Oe = zn, re === !0 && (Oe |= mi, Oe |= Lo)) : Oe = Hn, No && (Oe |= si), ws(lt, null, null, Oe);
    }
    function eb(V, re, ke, Oe, st, bt) {
      var Ct = it, Nt = V;
      if (typeof V == "function")
        Zg(V) ? (Ct = ht, Nt = Gg(Nt)) : Nt = Gh(Nt);
      else if (typeof V == "string")
        Ct = wt;
      else
        e: switch (V) {
          case vn:
            return Vl(ke.children, st, bt, re);
          case Cn:
            Ct = Lt, st |= mi, (st & zn) !== Hn && (st |= Lo);
            break;
          case dn:
            return e8(ke, st, bt, re);
          case sn:
            return t8(ke, st, bt, re);
          case Tn:
            return r8(ke, st, bt, re);
          case _i:
            return v_(ke, st, bt, re);
          case Ri:
          case Jn:
          case Qi:
          case Ca:
          case Ti:
          default: {
            if (typeof V == "object" && V !== null)
              switch (V.$$typeof) {
                case fr:
                  Ct = Ot;
                  break e;
                case Nr:
                  Ct = zt;
                  break e;
                case Ir:
                  Ct = It, Nt = Xg(Nt);
                  break e;
                case kn:
                  Ct = Vt;
                  break e;
                case Dn:
                  Ct = jt, Nt = null;
                  break e;
              }
            var qt = "";
            {
              (V === void 0 || typeof V == "object" && V !== null && Object.keys(V).length === 0) && (qt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var nr = Oe ? ui(Oe) : null;
              nr && (qt += `

Check the render method of \`` + nr + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (V == null ? V : typeof V) + "." + qt));
          }
        }
      var ar = ws(Ct, ke, re, st);
      return ar.elementType = V, ar.type = Nt, ar.lanes = bt, ar._debugOwner = Oe, ar;
    }
    function tb(V, re, ke) {
      var Oe = null;
      Oe = V._owner;
      var st = V.type, bt = V.key, Ct = V.props, Nt = eb(st, bt, Ct, Oe, re, ke);
      return Nt._debugSource = V._source, Nt._debugOwner = V._owner, Nt;
    }
    function Vl(V, re, ke, Oe) {
      var st = ws(Mt, V, Oe, re);
      return st.lanes = ke, st;
    }
    function e8(V, re, ke, Oe) {
      typeof V.id != "string" && Ce('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof V.id);
      var st = ws(Ft, V, Oe, re | si);
      return st.elementType = dn, st.lanes = ke, st.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, st;
    }
    function t8(V, re, ke, Oe) {
      var st = ws(Jt, V, Oe, re);
      return st.elementType = sn, st.lanes = ke, st;
    }
    function r8(V, re, ke, Oe) {
      var st = ws(Ht, V, Oe, re);
      return st.elementType = Tn, st.lanes = ke, st;
    }
    function v_(V, re, ke, Oe) {
      var st = ws(dt, V, Oe, re);
      st.elementType = _i, st.lanes = ke;
      var bt = {
        isHidden: !1
      };
      return st.stateNode = bt, st;
    }
    function rb(V, re, ke) {
      var Oe = ws(Rt, V, null, re);
      return Oe.lanes = ke, Oe;
    }
    function n8() {
      var V = ws(wt, null, null, Hn);
      return V.elementType = "DELETED", V;
    }
    function i8(V) {
      var re = ws(er, null, null, Hn);
      return re.stateNode = V, re;
    }
    function nb(V, re, ke) {
      var Oe = V.children !== null ? V.children : [], st = ws(Et, Oe, V.key, re);
      return st.lanes = ke, st.stateNode = {
        containerInfo: V.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: V.implementation
      }, st;
    }
    function y_(V, re) {
      return V === null && (V = ws(it, null, null, Hn)), V.tag = re.tag, V.key = re.key, V.elementType = re.elementType, V.type = re.type, V.stateNode = re.stateNode, V.return = re.return, V.child = re.child, V.sibling = re.sibling, V.index = re.index, V.ref = re.ref, V.pendingProps = re.pendingProps, V.memoizedProps = re.memoizedProps, V.updateQueue = re.updateQueue, V.memoizedState = re.memoizedState, V.dependencies = re.dependencies, V.mode = re.mode, V.flags = re.flags, V.subtreeFlags = re.subtreeFlags, V.deletions = re.deletions, V.lanes = re.lanes, V.childLanes = re.childLanes, V.alternate = re.alternate, V.actualDuration = re.actualDuration, V.actualStartTime = re.actualStartTime, V.selfBaseDuration = re.selfBaseDuration, V.treeBaseDuration = re.treeBaseDuration, V._debugSource = re._debugSource, V._debugOwner = re._debugOwner, V._debugNeedsRemount = re._debugNeedsRemount, V._debugHookTypes = re._debugHookTypes, V;
    }
    function a8(V, re, ke, Oe, st) {
      this.tag = re, this.containerInfo = V, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Lm, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = wa, this.eventTimes = Ec(Jr), this.expirationTimes = Ec(Vi), this.pendingLanes = Jr, this.suspendedLanes = Jr, this.pingedLanes = Jr, this.expiredLanes = Jr, this.mutableReadLanes = Jr, this.finishedLanes = Jr, this.entangledLanes = Jr, this.entanglements = Ec(Jr), this.identifierPrefix = Oe, this.onRecoverableError = st, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var bt = this.pendingUpdatersLaneMap = [], Ct = 0; Ct < mc; Ct++)
          bt.push(/* @__PURE__ */ new Set());
      }
      switch (re) {
        case Iv:
          this._debugRootType = ke ? "hydrateRoot()" : "createRoot()";
          break;
        case Ml:
          this._debugRootType = ke ? "hydrate()" : "render()";
          break;
      }
    }
    function m_(V, re, ke, Oe, st, bt, Ct, Nt, qt, nr) {
      var ar = new a8(V, re, ke, Nt, qt), xr = Z5(re, bt);
      ar.current = xr, xr.stateNode = ar;
      {
        var Er = {
          element: Oe,
          isDehydrated: ke,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        xr.memoizedState = Er;
      }
      return y2(xr), ar;
    }
    var ib = "18.3.1";
    function o8(V, re, ke) {
      var Oe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Mr(Oe), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Yr,
        key: Oe == null ? null : "" + Oe,
        children: V,
        containerInfo: re,
        implementation: ke
      };
    }
    var ab, ob;
    ab = !1, ob = {};
    function g_(V) {
      if (!V)
        return bs;
      var re = Go(V), ke = HS(re);
      if (re.tag === ht) {
        var Oe = re.type;
        if (Uu(Oe))
          return Wb(re, Oe, ke);
      }
      return ke;
    }
    function s8(V, re) {
      {
        var ke = Go(V);
        if (ke === void 0) {
          if (typeof V.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var Oe = Object.keys(V).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + Oe);
        }
        var st = Qo(ke);
        if (st === null)
          return null;
        if (st.mode & mi) {
          var bt = ui(ke) || "Component";
          if (!ob[bt]) {
            ob[bt] = !0;
            var Ct = na;
            try {
              Ii(st), ke.mode & mi ? Ce("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", re, re, bt) : Ce("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", re, re, bt);
            } finally {
              Ct ? Ii(Ct) : ua();
            }
          }
        }
        return st.stateNode;
      }
    }
    function b_(V, re, ke, Oe, st, bt, Ct, Nt) {
      var qt = !1, nr = null;
      return m_(V, re, qt, nr, ke, Oe, st, bt, Ct);
    }
    function w_(V, re, ke, Oe, st, bt, Ct, Nt, qt, nr) {
      var ar = !0, xr = m_(ke, Oe, ar, V, st, bt, Ct, Nt, qt);
      xr.context = g_(null);
      var Er = xr.current, Or = jo(), Ur = ql(Er), qr = Af(Or, Ur);
      return qr.callback = re ?? null, Il(Er, qr, Ur), p5(xr, Ur, Or), xr;
    }
    function Y0(V, re, ke, Oe) {
      Ap(re, V);
      var st = re.current, bt = jo(), Ct = ql(st);
      Bp(Ct);
      var Nt = g_(ke);
      re.context === null ? re.context = Nt : re.pendingContext = Nt, vo && na !== null && !ab && (ab = !0, Ce(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, ui(na) || "Unknown"));
      var qt = Af(bt, Ct);
      qt.payload = {
        element: V
      }, Oe = Oe === void 0 ? null : Oe, Oe !== null && (typeof Oe != "function" && Ce("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", Oe), qt.callback = Oe);
      var nr = Il(st, qt, Ct);
      return nr !== null && (Va(nr, st, Ct, bt), Yv(nr, st, Ct)), Ct;
    }
    function Uy(V) {
      var re = V.current;
      if (!re.child)
        return null;
      switch (re.child.tag) {
        case wt:
          return re.child.stateNode;
        default:
          return re.child.stateNode;
      }
    }
    function u8(V) {
      switch (V.tag) {
        case lt: {
          var re = V.stateNode;
          if (Gd(re)) {
            var ke = Op(re);
            g5(re, ke);
          }
          break;
        }
        case Jt: {
          kf(function() {
            var st = us(V, Vn);
            if (st !== null) {
              var bt = jo();
              Va(st, V, Vn, bt);
            }
          });
          var Oe = Vn;
          sb(V, Oe);
          break;
        }
      }
    }
    function __(V, re) {
      var ke = V.memoizedState;
      ke !== null && ke.dehydrated !== null && (ke.retryLane = V1(ke.retryLane, re));
    }
    function sb(V, re) {
      __(V, re);
      var ke = V.alternate;
      ke && __(ke, re);
    }
    function f8(V) {
      if (V.tag === Jt) {
        var re = bc, ke = us(V, re);
        if (ke !== null) {
          var Oe = jo();
          Va(ke, V, re, Oe);
        }
        sb(V, re);
      }
    }
    function l8(V) {
      if (V.tag === Jt) {
        var re = ql(V), ke = us(V, re);
        if (ke !== null) {
          var Oe = jo();
          Va(ke, V, re, Oe);
        }
        sb(V, re);
      }
    }
    function S_(V) {
      var re = C1(V);
      return re === null ? null : re.stateNode;
    }
    var E_ = function(V) {
      return null;
    };
    function c8(V) {
      return E_(V);
    }
    var $_ = function(V) {
      return !1;
    };
    function d8(V) {
      return $_(V);
    }
    var x_ = null, T_ = null, A_ = null, R_ = null, C_ = null, B_ = null, k_ = null, M_ = null, O_ = null;
    {
      var P_ = function(V, re, ke) {
        var Oe = re[ke], st = Ei(V) ? V.slice() : ii({}, V);
        return ke + 1 === re.length ? (Ei(st) ? st.splice(Oe, 1) : delete st[Oe], st) : (st[Oe] = P_(V[Oe], re, ke + 1), st);
      }, I_ = function(V, re) {
        return P_(V, re, 0);
      }, D_ = function(V, re, ke, Oe) {
        var st = re[Oe], bt = Ei(V) ? V.slice() : ii({}, V);
        if (Oe + 1 === re.length) {
          var Ct = ke[Oe];
          bt[Ct] = bt[st], Ei(bt) ? bt.splice(st, 1) : delete bt[st];
        } else
          bt[st] = D_(
            // $FlowFixMe number or string is fine here
            V[st],
            re,
            ke,
            Oe + 1
          );
        return bt;
      }, N_ = function(V, re, ke) {
        if (re.length !== ke.length) {
          ce("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var Oe = 0; Oe < ke.length - 1; Oe++)
            if (re[Oe] !== ke[Oe]) {
              ce("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return D_(V, re, ke, 0);
      }, L_ = function(V, re, ke, Oe) {
        if (ke >= re.length)
          return Oe;
        var st = re[ke], bt = Ei(V) ? V.slice() : ii({}, V);
        return bt[st] = L_(V[st], re, ke + 1, Oe), bt;
      }, U_ = function(V, re, ke) {
        return L_(V, re, 0, ke);
      }, ub = function(V, re) {
        for (var ke = V.memoizedState; ke !== null && re > 0; )
          ke = ke.next, re--;
        return ke;
      };
      x_ = function(V, re, ke, Oe) {
        var st = ub(V, re);
        if (st !== null) {
          var bt = U_(st.memoizedState, ke, Oe);
          st.memoizedState = bt, st.baseState = bt, V.memoizedProps = ii({}, V.memoizedProps);
          var Ct = us(V, Vn);
          Ct !== null && Va(Ct, V, Vn, Vi);
        }
      }, T_ = function(V, re, ke) {
        var Oe = ub(V, re);
        if (Oe !== null) {
          var st = I_(Oe.memoizedState, ke);
          Oe.memoizedState = st, Oe.baseState = st, V.memoizedProps = ii({}, V.memoizedProps);
          var bt = us(V, Vn);
          bt !== null && Va(bt, V, Vn, Vi);
        }
      }, A_ = function(V, re, ke, Oe) {
        var st = ub(V, re);
        if (st !== null) {
          var bt = N_(st.memoizedState, ke, Oe);
          st.memoizedState = bt, st.baseState = bt, V.memoizedProps = ii({}, V.memoizedProps);
          var Ct = us(V, Vn);
          Ct !== null && Va(Ct, V, Vn, Vi);
        }
      }, R_ = function(V, re, ke) {
        V.pendingProps = U_(V.memoizedProps, re, ke), V.alternate && (V.alternate.pendingProps = V.pendingProps);
        var Oe = us(V, Vn);
        Oe !== null && Va(Oe, V, Vn, Vi);
      }, C_ = function(V, re) {
        V.pendingProps = I_(V.memoizedProps, re), V.alternate && (V.alternate.pendingProps = V.pendingProps);
        var ke = us(V, Vn);
        ke !== null && Va(ke, V, Vn, Vi);
      }, B_ = function(V, re, ke) {
        V.pendingProps = N_(V.memoizedProps, re, ke), V.alternate && (V.alternate.pendingProps = V.pendingProps);
        var Oe = us(V, Vn);
        Oe !== null && Va(Oe, V, Vn, Vi);
      }, k_ = function(V) {
        var re = us(V, Vn);
        re !== null && Va(re, V, Vn, Vi);
      }, M_ = function(V) {
        E_ = V;
      }, O_ = function(V) {
        $_ = V;
      };
    }
    function h8(V) {
      var re = Qo(V);
      return re === null ? null : re.stateNode;
    }
    function p8(V) {
      return null;
    }
    function v8() {
      return na;
    }
    function y8(V) {
      var re = V.findFiberByHostInstance, ke = J.ReactCurrentDispatcher;
      return Tp({
        bundleType: V.bundleType,
        version: V.version,
        rendererPackageName: V.rendererPackageName,
        rendererConfig: V.rendererConfig,
        overrideHookState: x_,
        overrideHookStateDeletePath: T_,
        overrideHookStateRenamePath: A_,
        overrideProps: R_,
        overridePropsDeletePath: C_,
        overridePropsRenamePath: B_,
        setErrorHandler: M_,
        setSuspenseHandler: O_,
        scheduleUpdate: k_,
        currentDispatcherRef: ke,
        findHostInstanceByFiber: h8,
        findFiberByHostInstance: re || p8,
        // React Refresh
        findHostInstancesForRefresh: K5,
        scheduleRefresh: q5,
        scheduleRoot: W5,
        setRefreshHandler: z5,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: v8,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: ib
      });
    }
    var F_ = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(V) {
      console.error(V);
    };
    function fb(V) {
      this._internalRoot = V;
    }
    Fy.prototype.render = fb.prototype.render = function(V) {
      var re = this._internalRoot;
      if (re === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? Ce("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Hy(arguments[1]) ? Ce("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && Ce("You passed a second argument to root.render(...) but it only accepts one argument.");
        var ke = re.containerInfo;
        if (ke.nodeType !== ga) {
          var Oe = S_(re.current);
          Oe && Oe.parentNode !== ke && Ce("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Y0(V, re, null, null);
    }, Fy.prototype.unmount = fb.prototype.unmount = function() {
      typeof arguments[0] == "function" && Ce("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var V = this._internalRoot;
      if (V !== null) {
        this._internalRoot = null;
        var re = V.containerInfo;
        Q3() && Ce("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), kf(function() {
          Y0(null, V, null, null);
        }), Fb(re);
      }
    };
    function m8(V, re) {
      if (!Hy(V))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      H_(V);
      var ke = !1, Oe = !1, st = "", bt = F_;
      re != null && (re.hydrate ? ce("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof re == "object" && re !== null && re.$$typeof === pn && Ce(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), re.unstable_strictMode === !0 && (ke = !0), re.identifierPrefix !== void 0 && (st = re.identifierPrefix), re.onRecoverableError !== void 0 && (bt = re.onRecoverableError), re.transitionCallbacks !== void 0 && re.transitionCallbacks);
      var Ct = b_(V, Iv, null, ke, Oe, st, bt);
      Rv(Ct.current, V);
      var Nt = V.nodeType === ga ? V.parentNode : V;
      return r0(Nt), new fb(Ct);
    }
    function Fy(V) {
      this._internalRoot = V;
    }
    function g8(V) {
      V && cm(V);
    }
    Fy.prototype.unstable_scheduleHydration = g8;
    function b8(V, re, ke) {
      if (!Hy(V))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      H_(V), re === void 0 && Ce("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var Oe = ke ?? null, st = ke != null && ke.hydratedSources || null, bt = !1, Ct = !1, Nt = "", qt = F_;
      ke != null && (ke.unstable_strictMode === !0 && (bt = !0), ke.identifierPrefix !== void 0 && (Nt = ke.identifierPrefix), ke.onRecoverableError !== void 0 && (qt = ke.onRecoverableError));
      var nr = w_(re, null, V, Iv, Oe, bt, Ct, Nt, qt);
      if (Rv(nr.current, V), r0(V), st)
        for (var ar = 0; ar < st.length; ar++) {
          var xr = st[ar];
          S4(nr, xr);
        }
      return new Fy(nr);
    }
    function Hy(V) {
      return !!(V && (V.nodeType === mo || V.nodeType === vs || V.nodeType === Ju || !yt));
    }
    function J0(V) {
      return !!(V && (V.nodeType === mo || V.nodeType === vs || V.nodeType === Ju || V.nodeType === ga && V.nodeValue === " react-mount-point-unstable "));
    }
    function H_(V) {
      V.nodeType === mo && V.tagName && V.tagName.toUpperCase() === "BODY" && Ce("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), h0(V) && (V._reactRootContainer ? Ce("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : Ce("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var w8 = J.ReactCurrentOwner, j_;
    j_ = function(V) {
      if (V._reactRootContainer && V.nodeType !== ga) {
        var re = S_(V._reactRootContainer.current);
        re && re.parentNode !== V && Ce("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var ke = !!V._reactRootContainer, Oe = lb(V), st = !!(Oe && Bl(Oe));
      st && !ke && Ce("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), V.nodeType === mo && V.tagName && V.tagName.toUpperCase() === "BODY" && Ce("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function lb(V) {
      return V ? V.nodeType === vs ? V.documentElement : V.firstChild : null;
    }
    function z_() {
    }
    function _8(V, re, ke, Oe, st) {
      if (st) {
        if (typeof Oe == "function") {
          var bt = Oe;
          Oe = function() {
            var Er = Uy(Ct);
            bt.call(Er);
          };
        }
        var Ct = w_(
          re,
          Oe,
          V,
          Ml,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          z_
        );
        V._reactRootContainer = Ct, Rv(Ct.current, V);
        var Nt = V.nodeType === ga ? V.parentNode : V;
        return r0(Nt), kf(), Ct;
      } else {
        for (var qt; qt = V.lastChild; )
          V.removeChild(qt);
        if (typeof Oe == "function") {
          var nr = Oe;
          Oe = function() {
            var Er = Uy(ar);
            nr.call(Er);
          };
        }
        var ar = b_(
          V,
          Ml,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          z_
        );
        V._reactRootContainer = ar, Rv(ar.current, V);
        var xr = V.nodeType === ga ? V.parentNode : V;
        return r0(xr), kf(function() {
          Y0(re, ar, ke, Oe);
        }), ar;
      }
    }
    function S8(V, re) {
      V !== null && typeof V != "function" && Ce("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", re, V);
    }
    function jy(V, re, ke, Oe, st) {
      j_(ke), S8(st === void 0 ? null : st, "render");
      var bt = ke._reactRootContainer, Ct;
      if (!bt)
        Ct = _8(ke, re, V, st, Oe);
      else {
        if (Ct = bt, typeof st == "function") {
          var Nt = st;
          st = function() {
            var qt = Uy(Ct);
            Nt.call(qt);
          };
        }
        Y0(re, Ct, V, st);
      }
      return Uy(Ct);
    }
    var q_ = !1;
    function E8(V) {
      {
        q_ || (q_ = !0, Ce("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var re = w8.current;
        if (re !== null && re.stateNode !== null) {
          var ke = re.stateNode._warnedAboutRefsInRender;
          ke || Ce("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Si(re.type) || "A component"), re.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return V == null ? null : V.nodeType === mo ? V : s8(V, "findDOMNode");
    }
    function $8(V, re, ke) {
      if (Ce("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !J0(re))
        throw new Error("Target container is not a DOM element.");
      {
        var Oe = h0(re) && re._reactRootContainer === void 0;
        Oe && Ce("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return jy(null, V, re, !0, ke);
    }
    function x8(V, re, ke) {
      if (Ce("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !J0(re))
        throw new Error("Target container is not a DOM element.");
      {
        var Oe = h0(re) && re._reactRootContainer === void 0;
        Oe && Ce("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return jy(null, V, re, !1, ke);
    }
    function T8(V, re, ke, Oe) {
      if (Ce("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !J0(ke))
        throw new Error("Target container is not a DOM element.");
      if (V == null || !lc(V))
        throw new Error("parentComponent must be a valid React Component");
      return jy(V, re, ke, !1, Oe);
    }
    var W_ = !1;
    function A8(V) {
      if (W_ || (W_ = !0, Ce("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !J0(V))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var re = h0(V) && V._reactRootContainer === void 0;
        re && Ce("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (V._reactRootContainer) {
        {
          var ke = lb(V), Oe = ke && !Bl(ke);
          Oe && Ce("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return kf(function() {
          jy(null, null, V, !1, function() {
            V._reactRootContainer = null, Fb(V);
          });
        }), !0;
      } else {
        {
          var st = lb(V), bt = !!(st && Bl(st)), Ct = V.nodeType === mo && J0(V.parentNode) && !!V.parentNode._reactRootContainer;
          bt && Ce("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", Ct ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    yl(u8), fm(f8), Yd(l8), Y1(rs), J1(Za), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && Ce("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), T1(R6), dd(Hg, b5, kf);
    function R8(V, re) {
      var ke = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Hy(re))
        throw new Error("Target container is not a DOM element.");
      return o8(V, re, null, ke);
    }
    function C8(V, re, ke, Oe) {
      return T8(V, re, ke, Oe);
    }
    var cb = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Bl, Eh, Cv, cd, sc, Hg]
    };
    function B8(V, re) {
      return cb.usingClientEntryPoint || Ce('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), m8(V, re);
    }
    function k8(V, re, ke) {
      return cb.usingClientEntryPoint || Ce('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), b8(V, re, ke);
    }
    function M8(V) {
      return Q3() && Ce("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), kf(V);
    }
    var O8 = y8({
      findFiberByHostInstance: Nc,
      bundleType: 1,
      version: ib,
      rendererPackageName: "react-dom"
    });
    if (!O8 && br && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var K_ = window.location.protocol;
      /^(https?|file):$/.test(K_) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (K_ === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cb, reactDom_development.createPortal = R8, reactDom_development.createRoot = B8, reactDom_development.findDOMNode = E8, reactDom_development.flushSync = M8, reactDom_development.hydrate = $8, reactDom_development.hydrateRoot = k8, reactDom_development.render = x8, reactDom_development.unmountComponentAtNode = A8, reactDom_development.unstable_batchedUpdates = Hg, reactDom_development.unstable_renderSubtreeIntoContainer = C8, reactDom_development.version = ib, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), reactDom_development;
}
function checkDCE() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process$1.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (B) {
      console.error(B);
    }
  }
}
process$1.env.NODE_ENV === "production" ? (checkDCE(), reactDom.exports = requireReactDom_production_min()) : reactDom.exports = requireReactDom_development();
var reactDomExports = reactDom.exports, i$7 = Object.defineProperty, d$6 = (B, L, J) => L in B ? i$7(B, L, { enumerable: !0, configurable: !0, writable: !0, value: J }) : B[L] = J, r$5 = (B, L, J) => (d$6(B, typeof L != "symbol" ? L + "" : L, J), J);
let o$7 = class {
  constructor() {
    r$5(this, "current", this.detect()), r$5(this, "handoffState", "pending"), r$5(this, "currentId", 0);
  }
  set(L) {
    this.current !== L && (this.handoffState = "pending", this.currentId = 0, this.current = L);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$b = new o$7(), l$6 = (B, L) => {
  s$b.isServer ? reactExports.useEffect(B, L) : reactExports.useLayoutEffect(B, L);
};
function s$a(B) {
  let L = reactExports.useRef(B);
  return l$6(() => {
    L.current = B;
  }, [B]), L;
}
let o$6 = function(B) {
  let L = s$a(B);
  return m$4.useCallback((...J) => L.current(...J), [L]);
};
function t$8(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((L) => setTimeout(() => {
    throw L;
  }));
}
function o$5() {
  let B = [], L = { addEventListener(J, ne, oe, ce) {
    return J.addEventListener(ne, oe, ce), L.add(() => J.removeEventListener(ne, oe, ce));
  }, requestAnimationFrame(...J) {
    let ne = requestAnimationFrame(...J);
    return L.add(() => cancelAnimationFrame(ne));
  }, nextFrame(...J) {
    return L.requestAnimationFrame(() => L.requestAnimationFrame(...J));
  }, setTimeout(...J) {
    let ne = setTimeout(...J);
    return L.add(() => clearTimeout(ne));
  }, microTask(...J) {
    let ne = { current: !0 };
    return t$8(() => {
      ne.current && J[0]();
    }), L.add(() => {
      ne.current = !1;
    });
  }, style(J, ne, oe) {
    let ce = J.style.getPropertyValue(ne);
    return Object.assign(J.style, { [ne]: oe }), this.add(() => {
      Object.assign(J.style, { [ne]: ce });
    });
  }, group(J) {
    let ne = o$5();
    return J(ne), this.add(() => ne.dispose());
  }, add(J) {
    return B.push(J), () => {
      let ne = B.indexOf(J);
      if (ne >= 0) for (let oe of B.splice(ne, 1)) oe();
    };
  }, dispose() {
    for (let J of B.splice(0)) J();
  } };
  return L;
}
function p$4() {
  let [B] = reactExports.useState(o$5);
  return reactExports.useEffect(() => () => B.dispose(), [B]), B;
}
function s$9() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in e$2 ? ((L) => L.useSyncExternalStore)(e$2)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$5() {
  let B = s$9(), [L, J] = reactExports.useState(s$b.isHandoffComplete);
  return L && s$b.isHandoffComplete === !1 && J(!1), reactExports.useEffect(() => {
    L !== !0 && J(!0);
  }, [L]), reactExports.useEffect(() => s$b.handoff(), []), B ? !1 : L;
}
var o$4;
let I$6 = (o$4 = m$4.useId) != null ? o$4 : function() {
  let B = l$5(), [L, J] = m$4.useState(B ? () => s$b.nextId() : null);
  return l$6(() => {
    L === null && J(s$b.nextId());
  }, [L]), L != null ? "" + L : void 0;
};
function u$7(B, L, ...J) {
  if (B in L) {
    let oe = L[B];
    return typeof oe == "function" ? oe(...J) : oe;
  }
  let ne = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(L).map((oe) => `"${oe}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(ne, u$7), ne;
}
function o$3(B) {
  return s$b.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
let c$6 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var M$2 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B))(M$2 || {}), N$2 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(N$2 || {}), F$3 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(F$3 || {});
function f$8(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(c$6)).sort((L, J) => Math.sign((L.tabIndex || Number.MAX_SAFE_INTEGER) - (J.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(T$2 || {});
function h$6(B, L = 0) {
  var J;
  return B === ((J = o$3(B)) == null ? void 0 : J.body) ? !1 : u$7(L, { 0() {
    return B.matches(c$6);
  }, 1() {
    let ne = B;
    for (; ne !== null; ) {
      if (ne.matches(c$6)) return !0;
      ne = ne.parentElement;
    }
    return !1;
  } });
}
function D$3(B) {
  let L = o$3(B);
  o$5().nextFrame(() => {
    L && !h$6(L.activeElement, 0) && y$4(B);
  });
}
var w$3 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(w$3 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$4(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(B) {
  var L, J;
  return (J = (L = B == null ? void 0 : B.matches) == null ? void 0 : L.call(B, S$5)) != null ? J : !1;
}
function I$5(B, L = (J) => J) {
  return B.slice().sort((J, ne) => {
    let oe = L(J), ce = L(ne);
    if (oe === null || ce === null) return 0;
    let Ce = oe.compareDocumentPosition(ce);
    return Ce & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : Ce & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$3(B, L) {
  return O$2(f$8(), L, { relativeTo: B });
}
function O$2(B, L, { sorted: J = !0, relativeTo: ne = null, skipElements: oe = [] } = {}) {
  let ce = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, Ce = Array.isArray(B) ? J ? I$5(B) : B : f$8(B);
  oe.length > 0 && Ce.length > 1 && (Ce = Ce.filter((wt) => !oe.includes(wt))), ne = ne ?? ce.activeElement;
  let rt = (() => {
    if (L & 5) return 1;
    if (L & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), at = (() => {
    if (L & 1) return 0;
    if (L & 2) return Math.max(0, Ce.indexOf(ne)) - 1;
    if (L & 4) return Math.max(0, Ce.indexOf(ne)) + 1;
    if (L & 8) return Ce.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ht = L & 32 ? { preventScroll: !0 } : {}, it = 0, lt = Ce.length, Et;
  do {
    if (it >= lt || it + lt <= 0) return 0;
    let wt = at + it;
    if (L & 16) wt = (wt + lt) % lt;
    else {
      if (wt < 0) return 3;
      if (wt >= lt) return 1;
    }
    Et = Ce[wt], Et == null || Et.focus(ht), it += rt;
  } while (Et !== ce.activeElement);
  return L & 6 && H(Et) && Et.select(), 2;
}
function t$7() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$4() {
  return t$7() || i$6();
}
function d$5(B, L, J) {
  let ne = s$a(L);
  reactExports.useEffect(() => {
    function oe(ce) {
      ne.current(ce);
    }
    return document.addEventListener(B, oe, J), () => document.removeEventListener(B, oe, J);
  }, [B, J]);
}
function s$8(B, L, J) {
  let ne = s$a(L);
  reactExports.useEffect(() => {
    function oe(ce) {
      ne.current(ce);
    }
    return window.addEventListener(B, oe, J), () => window.removeEventListener(B, oe, J);
  }, [B, J]);
}
function y$3(B, L, J = !0) {
  let ne = reactExports.useRef(!1);
  reactExports.useEffect(() => {
    requestAnimationFrame(() => {
      ne.current = J;
    });
  }, [J]);
  function oe(Ce, rt) {
    if (!ne.current || Ce.defaultPrevented) return;
    let at = rt(Ce);
    if (at === null || !at.getRootNode().contains(at) || !at.isConnected) return;
    let ht = function it(lt) {
      return typeof lt == "function" ? it(lt()) : Array.isArray(lt) || lt instanceof Set ? lt : [lt];
    }(B);
    for (let it of ht) {
      if (it === null) continue;
      let lt = it instanceof HTMLElement ? it : it.current;
      if (lt != null && lt.contains(at) || Ce.composed && Ce.composedPath().includes(lt)) return;
    }
    return !h$6(at, T$2.Loose) && at.tabIndex !== -1 && Ce.preventDefault(), L(Ce, at);
  }
  let ce = reactExports.useRef(null);
  d$5("pointerdown", (Ce) => {
    var rt, at;
    ne.current && (ce.current = ((at = (rt = Ce.composedPath) == null ? void 0 : rt.call(Ce)) == null ? void 0 : at[0]) || Ce.target);
  }, !0), d$5("mousedown", (Ce) => {
    var rt, at;
    ne.current && (ce.current = ((at = (rt = Ce.composedPath) == null ? void 0 : rt.call(Ce)) == null ? void 0 : at[0]) || Ce.target);
  }, !0), d$5("click", (Ce) => {
    n$4() || ce.current && (oe(Ce, () => ce.current), ce.current = null);
  }, !0), d$5("touchend", (Ce) => oe(Ce, () => Ce.target instanceof HTMLElement ? Ce.target : null), !0), s$8("blur", (Ce) => oe(Ce, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$3(...B) {
  return reactExports.useMemo(() => o$3(...B), [...B]);
}
function i$5(B) {
  var L;
  if (B.type) return B.type;
  let J = (L = B.as) != null ? L : "button";
  if (typeof J == "string" && J.toLowerCase() === "button") return "button";
}
function T$1(B, L) {
  let [J, ne] = reactExports.useState(() => i$5(B));
  return l$6(() => {
    ne(i$5(B));
  }, [B.type, B.as]), l$6(() => {
    J || L.current && L.current instanceof HTMLButtonElement && !L.current.hasAttribute("type") && ne("button");
  }, [J, L]), J;
}
let u$6 = Symbol();
function T(B, L = !0) {
  return Object.assign(B, { [u$6]: L });
}
function y$2(...B) {
  let L = reactExports.useRef(B);
  reactExports.useEffect(() => {
    L.current = B;
  }, [B]);
  let J = o$6((ne) => {
    for (let oe of L.current) oe != null && (typeof oe == "function" ? oe(ne) : oe.current = ne);
  });
  return B.every((ne) => ne == null || (ne == null ? void 0 : ne[u$6])) ? void 0 : J;
}
function t$6(B) {
  return [B.screenX, B.screenY];
}
function u$5() {
  let B = reactExports.useRef([-1, -1]);
  return { wasMoved(L) {
    let J = t$6(L);
    return B.current[0] === J[0] && B.current[1] === J[1] ? !1 : (B.current = J, !0);
  }, update(L) {
    B.current = t$6(L);
  } };
}
function F$2({ container: B, accept: L, walk: J, enabled: ne = !0 }) {
  let oe = reactExports.useRef(L), ce = reactExports.useRef(J);
  reactExports.useEffect(() => {
    oe.current = L, ce.current = J;
  }, [L, J]), l$6(() => {
    if (!B || !ne) return;
    let Ce = o$3(B);
    if (!Ce) return;
    let rt = oe.current, at = ce.current, ht = Object.assign((lt) => rt(lt), { acceptNode: rt }), it = Ce.createTreeWalker(B, NodeFilter.SHOW_ELEMENT, ht, !1);
    for (; it.nextNode(); ) at(it.currentNode);
  }, [B, ne, oe, ce]);
}
function m$3(B, L) {
  let J = reactExports.useRef([]), ne = o$6(B);
  reactExports.useEffect(() => {
    let oe = [...J.current];
    for (let [ce, Ce] of L.entries()) if (J.current[ce] !== Ce) {
      let rt = ne(L, oe);
      return J.current = L, rt;
    }
  }, [ne, ...L]);
}
function t$5(...B) {
  return Array.from(new Set(B.flatMap((L) => typeof L == "string" ? L.split(" ") : []))).filter(Boolean).join(" ");
}
var O$1 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$1 || {}), v$2 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(v$2 || {});
function C$2({ ourProps: B, theirProps: L, slot: J, defaultTag: ne, features: oe, visible: ce = !0, name: Ce, mergeRefs: rt }) {
  rt = rt ?? k$1;
  let at = R$1(L, B);
  if (ce) return m$2(at, J, ne, Ce, rt);
  let ht = oe ?? 0;
  if (ht & 2) {
    let { static: it = !1, ...lt } = at;
    if (it) return m$2(lt, J, ne, Ce, rt);
  }
  if (ht & 1) {
    let { unmount: it = !0, ...lt } = at;
    return u$7(it ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$2({ ...lt, hidden: !0, style: { display: "none" } }, J, ne, Ce, rt);
    } });
  }
  return m$2(at, J, ne, Ce, rt);
}
function m$2(B, L = {}, J, ne, oe) {
  let { as: ce = J, children: Ce, refName: rt = "ref", ...at } = F$1(B, ["unmount", "static"]), ht = B.ref !== void 0 ? { [rt]: B.ref } : {}, it = typeof Ce == "function" ? Ce(L) : Ce;
  "className" in at && at.className && typeof at.className == "function" && (at.className = at.className(L));
  let lt = {};
  if (L) {
    let Et = !1, wt = [];
    for (let [Rt, Mt] of Object.entries(L)) typeof Mt == "boolean" && (Et = !0), Mt === !0 && wt.push(Rt);
    Et && (lt["data-headlessui-state"] = wt.join(" "));
  }
  if (ce === reactExports.Fragment && Object.keys(x$2(at)).length > 0) {
    if (!reactExports.isValidElement(it) || Array.isArray(it) && it.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${ne} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(at).map((Mt) => `  - ${Mt}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((Mt) => `  - ${Mt}`).join(`
`)].join(`
`));
    let Et = it.props, wt = typeof (Et == null ? void 0 : Et.className) == "function" ? (...Mt) => t$5(Et == null ? void 0 : Et.className(...Mt), at.className) : t$5(Et == null ? void 0 : Et.className, at.className), Rt = wt ? { className: wt } : {};
    return reactExports.cloneElement(it, Object.assign({}, R$1(it.props, x$2(F$1(at, ["ref"]))), lt, ht, { ref: oe(it.ref, ht.ref) }, Rt));
  }
  return reactExports.createElement(ce, Object.assign({}, F$1(at, ["ref"]), ce !== reactExports.Fragment && ht, ce !== reactExports.Fragment && lt), it);
}
function k$1(...B) {
  return B.every((L) => L == null) ? void 0 : (L) => {
    for (let J of B) J != null && (typeof J == "function" ? J(L) : J.current = L);
  };
}
function R$1(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let L = {}, J = {};
  for (let ne of B) for (let oe in ne) oe.startsWith("on") && typeof ne[oe] == "function" ? (J[oe] != null || (J[oe] = []), J[oe].push(ne[oe])) : L[oe] = ne[oe];
  if (L.disabled || L["aria-disabled"]) return Object.assign(L, Object.fromEntries(Object.keys(J).map((ne) => [ne, void 0])));
  for (let ne in J) Object.assign(L, { [ne](oe, ...ce) {
    let Ce = J[ne];
    for (let rt of Ce) {
      if ((oe instanceof Event || (oe == null ? void 0 : oe.nativeEvent) instanceof Event) && oe.defaultPrevented) return;
      rt(oe, ...ce);
    }
  } });
  return L;
}
function U$3(B) {
  var L;
  return Object.assign(reactExports.forwardRef(B), { displayName: (L = B.displayName) != null ? L : B.name });
}
function x$2(B) {
  let L = Object.assign({}, B);
  for (let J in L) L[J] === void 0 && delete L[J];
  return L;
}
function F$1(B, L = []) {
  let J = Object.assign({}, B);
  for (let ne of L) ne in J && delete J[ne];
  return J;
}
let p$3 = "div";
var s$7 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$7 || {});
function l$4(B, L) {
  var J;
  let { features: ne = 1, ...oe } = B, ce = { ref: L, "aria-hidden": (ne & 2) === 2 ? !0 : (J = oe["aria-hidden"]) != null ? J : void 0, hidden: (ne & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ne & 4) === 4 && (ne & 2) !== 2 && { display: "none" } } };
  return C$2({ ourProps: ce, theirProps: oe, slot: {}, defaultTag: p$3, name: "Hidden" });
}
let u$4 = U$3(l$4), n$2 = reactExports.createContext(null);
n$2.displayName = "OpenClosedContext";
var d$4 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(d$4 || {});
function u$3() {
  return reactExports.useContext(n$2);
}
function s$6({ value: B, children: L }) {
  return m$4.createElement(n$2.Provider, { value: B }, L);
}
function t$4(B) {
  function L() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", L));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", L), L());
}
let t$3 = [];
t$4(() => {
  function B(L) {
    L.target instanceof HTMLElement && L.target !== document.body && t$3[0] !== L.target && (t$3.unshift(L.target), t$3 = t$3.filter((J) => J != null && J.isConnected), t$3.splice(10));
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function r$4(B) {
  let L = B.parentElement, J = null;
  for (; L && !(L instanceof HTMLFieldSetElement); ) L instanceof HTMLLegendElement && (J = L), L = L.parentElement;
  let ne = (L == null ? void 0 : L.getAttribute("disabled")) === "";
  return ne && i$4(J) ? !1 : ne;
}
function i$4(B) {
  if (!B) return !1;
  let L = B.previousElementSibling;
  for (; L !== null; ) {
    if (L instanceof HTMLLegendElement) return !1;
    L = L.previousElementSibling;
  }
  return !0;
}
function u$2(B) {
  throw new Error("Unexpected object: " + B);
}
var c$5 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$5 || {});
function f$7(B, L) {
  let J = L.resolveItems();
  if (J.length <= 0) return null;
  let ne = L.resolveActiveIndex(), oe = ne ?? -1;
  switch (B.focus) {
    case 0: {
      for (let ce = 0; ce < J.length; ++ce) if (!L.resolveDisabled(J[ce], ce, J)) return ce;
      return ne;
    }
    case 1: {
      for (let ce = oe - 1; ce >= 0; --ce) if (!L.resolveDisabled(J[ce], ce, J)) return ce;
      return ne;
    }
    case 2: {
      for (let ce = oe + 1; ce < J.length; ++ce) if (!L.resolveDisabled(J[ce], ce, J)) return ce;
      return ne;
    }
    case 3: {
      for (let ce = J.length - 1; ce >= 0; --ce) if (!L.resolveDisabled(J[ce], ce, J)) return ce;
      return ne;
    }
    case 4: {
      for (let ce = 0; ce < J.length; ++ce) if (L.resolveId(J[ce], ce, J) === B.id) return ce;
      return ne;
    }
    case 5:
      return null;
    default:
      u$2(B);
  }
}
var o$2 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$2 || {});
function E$1(B, L, J, ne) {
  let oe = s$a(J);
  reactExports.useEffect(() => {
    B = B ?? window;
    function ce(Ce) {
      oe.current(Ce);
    }
    return B.addEventListener(L, ce, ne), () => B.removeEventListener(L, ce, ne);
  }, [B, L, ne]);
}
function f$6() {
  let B = reactExports.useRef(!1);
  return l$6(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
function c$4(B) {
  let L = o$6(B), J = reactExports.useRef(!1);
  reactExports.useEffect(() => (J.current = !1, () => {
    J.current = !0, t$8(() => {
      J.current && L();
    });
  }), [L]);
}
var s$5 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(s$5 || {});
function n$1() {
  let B = reactExports.useRef(0);
  return s$8("keydown", (L) => {
    L.key === "Tab" && (B.current = L.shiftKey ? 1 : 0);
  }, !0), B;
}
function P(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let L = /* @__PURE__ */ new Set();
  for (let J of B.current) J.current instanceof HTMLElement && L.add(J.current);
  return L;
}
let X = "div";
var _$2 = ((B) => (B[B.None = 1] = "None", B[B.InitialFocus = 2] = "InitialFocus", B[B.TabLock = 4] = "TabLock", B[B.FocusLock = 8] = "FocusLock", B[B.RestoreFocus = 16] = "RestoreFocus", B[B.All = 30] = "All", B))(_$2 || {});
function z$1(B, L) {
  let J = reactExports.useRef(null), ne = y$2(J, L), { initialFocus: oe, containers: ce, features: Ce = 30, ...rt } = B;
  l$5() || (Ce = 1);
  let at = n$3(J);
  Y({ ownerDocument: at }, !!(Ce & 16));
  let ht = Z({ ownerDocument: at, container: J, initialFocus: oe }, !!(Ce & 2));
  $({ ownerDocument: at, container: J, containers: ce, previousActiveElement: ht }, !!(Ce & 8));
  let it = n$1(), lt = o$6((Mt) => {
    let Lt = J.current;
    Lt && ((zt) => zt())(() => {
      u$7(it.current, { [s$5.Forwards]: () => {
        O$2(Lt, M$2.First, { skipElements: [Mt.relatedTarget] });
      }, [s$5.Backwards]: () => {
        O$2(Lt, M$2.Last, { skipElements: [Mt.relatedTarget] });
      } });
    });
  }), Et = p$4(), wt = reactExports.useRef(!1), Rt = { ref: ne, onKeyDown(Mt) {
    Mt.key == "Tab" && (wt.current = !0, Et.requestAnimationFrame(() => {
      wt.current = !1;
    }));
  }, onBlur(Mt) {
    let Lt = P(ce);
    J.current instanceof HTMLElement && Lt.add(J.current);
    let zt = Mt.relatedTarget;
    zt instanceof HTMLElement && zt.dataset.headlessuiFocusGuard !== "true" && (S$4(Lt, zt) || (wt.current ? O$2(J.current, u$7(it.current, { [s$5.Forwards]: () => M$2.Next, [s$5.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: Mt.target }) : Mt.target instanceof HTMLElement && y$4(Mt.target)));
  } };
  return m$4.createElement(m$4.Fragment, null, !!(Ce & 4) && m$4.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: lt, features: s$7.Focusable }), C$2({ ourProps: Rt, theirProps: rt, defaultTag: X, name: "FocusTrap" }), !!(Ce & 4) && m$4.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: lt, features: s$7.Focusable }));
}
let D$2 = U$3(z$1), de$1 = Object.assign(D$2, { features: _$2 });
function Q(B = !0) {
  let L = reactExports.useRef(t$3.slice());
  return m$3(([J], [ne]) => {
    ne === !0 && J === !1 && t$8(() => {
      L.current.splice(0);
    }), ne === !1 && J === !0 && (L.current = t$3.slice());
  }, [B, t$3, L]), o$6(() => {
    var J;
    return (J = L.current.find((ne) => ne != null && ne.isConnected)) != null ? J : null;
  });
}
function Y({ ownerDocument: B }, L) {
  let J = Q(L);
  m$3(() => {
    L || (B == null ? void 0 : B.activeElement) === (B == null ? void 0 : B.body) && y$4(J());
  }, [L]), c$4(() => {
    L && y$4(J());
  });
}
function Z({ ownerDocument: B, container: L, initialFocus: J }, ne) {
  let oe = reactExports.useRef(null), ce = f$6();
  return m$3(() => {
    if (!ne) return;
    let Ce = L.current;
    Ce && t$8(() => {
      if (!ce.current) return;
      let rt = B == null ? void 0 : B.activeElement;
      if (J != null && J.current) {
        if ((J == null ? void 0 : J.current) === rt) {
          oe.current = rt;
          return;
        }
      } else if (Ce.contains(rt)) {
        oe.current = rt;
        return;
      }
      J != null && J.current ? y$4(J.current) : O$2(Ce, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), oe.current = B == null ? void 0 : B.activeElement;
    });
  }, [ne]), oe;
}
function $({ ownerDocument: B, container: L, containers: J, previousActiveElement: ne }, oe) {
  let ce = f$6();
  E$1(B == null ? void 0 : B.defaultView, "focus", (Ce) => {
    if (!oe || !ce.current) return;
    let rt = P(J);
    L.current instanceof HTMLElement && rt.add(L.current);
    let at = ne.current;
    if (!at) return;
    let ht = Ce.target;
    ht && ht instanceof HTMLElement ? S$4(rt, ht) ? (ne.current = ht, y$4(ht)) : (Ce.preventDefault(), Ce.stopPropagation(), y$4(at)) : y$4(ne.current);
  }, !0);
}
function S$4(B, L) {
  for (let J of B) if (J.contains(L)) return !0;
  return !1;
}
let e$1 = reactExports.createContext(!1);
function a$6() {
  return reactExports.useContext(e$1);
}
function l$3(B) {
  return m$4.createElement(e$1.Provider, { value: B.force }, B.children);
}
function F(B) {
  let L = a$6(), J = reactExports.useContext(_$1), ne = n$3(B), [oe, ce] = reactExports.useState(() => {
    if (!L && J !== null || s$b.isServer) return null;
    let Ce = ne == null ? void 0 : ne.getElementById("headlessui-portal-root");
    if (Ce) return Ce;
    if (ne === null) return null;
    let rt = ne.createElement("div");
    return rt.setAttribute("id", "headlessui-portal-root"), ne.body.appendChild(rt);
  });
  return reactExports.useEffect(() => {
    oe !== null && (ne != null && ne.body.contains(oe) || ne == null || ne.body.appendChild(oe));
  }, [oe, ne]), reactExports.useEffect(() => {
    L || J !== null && ce(J.current);
  }, [J, ce, L]), oe;
}
let U$2 = reactExports.Fragment;
function N$1(B, L) {
  let J = B, ne = reactExports.useRef(null), oe = y$2(T((it) => {
    ne.current = it;
  }), L), ce = n$3(ne), Ce = F(ne), [rt] = reactExports.useState(() => {
    var it;
    return s$b.isServer ? null : (it = ce == null ? void 0 : ce.createElement("div")) != null ? it : null;
  }), at = reactExports.useContext(f$5), ht = l$5();
  return l$6(() => {
    !Ce || !rt || Ce.contains(rt) || (rt.setAttribute("data-headlessui-portal", ""), Ce.appendChild(rt));
  }, [Ce, rt]), l$6(() => {
    if (rt && at) return at.register(rt);
  }, [at, rt]), c$4(() => {
    var it;
    !Ce || !rt || (rt instanceof Node && Ce.contains(rt) && Ce.removeChild(rt), Ce.childNodes.length <= 0 && ((it = Ce.parentElement) == null || it.removeChild(Ce)));
  }), ht ? !Ce || !rt ? null : reactDomExports.createPortal(C$2({ ourProps: { ref: oe }, theirProps: J, defaultTag: U$2, name: "Portal" }), rt) : null;
}
let S$3 = reactExports.Fragment, _$1 = reactExports.createContext(null);
function j(B, L) {
  let { target: J, ...ne } = B, oe = { ref: y$2(L) };
  return m$4.createElement(_$1.Provider, { value: J }, C$2({ ourProps: oe, theirProps: ne, defaultTag: S$3, name: "Popover.Group" }));
}
let f$5 = reactExports.createContext(null);
function ee() {
  let B = reactExports.useContext(f$5), L = reactExports.useRef([]), J = o$6((ce) => (L.current.push(ce), B && B.register(ce), () => ne(ce))), ne = o$6((ce) => {
    let Ce = L.current.indexOf(ce);
    Ce !== -1 && L.current.splice(Ce, 1), B && B.unregister(ce);
  }), oe = reactExports.useMemo(() => ({ register: J, unregister: ne, portals: L }), [J, ne, L]);
  return [L, reactExports.useMemo(() => function({ children: ce }) {
    return m$4.createElement(f$5.Provider, { value: oe }, ce);
  }, [oe])];
}
let D$1 = U$3(N$1), I$4 = U$3(j), te = Object.assign(D$1, { Group: I$4 });
function i$3(B, L) {
  return B === L && (B !== 0 || 1 / B === 1 / L) || B !== B && L !== L;
}
const d$3 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$5, useLayoutEffect: f$4, useDebugValue: p$2 } = e$2;
function y$1(B, L, J) {
  const ne = L(), [{ inst: oe }, ce] = u$1({ inst: { value: ne, getSnapshot: L } });
  return f$4(() => {
    oe.value = ne, oe.getSnapshot = L, r$3(oe) && ce({ inst: oe });
  }, [B, ne, L]), h$5(() => (r$3(oe) && ce({ inst: oe }), B(() => {
    r$3(oe) && ce({ inst: oe });
  })), [B]), p$2(ne), ne;
}
function r$3(B) {
  const L = B.getSnapshot, J = B.value;
  try {
    const ne = L();
    return !d$3(J, ne);
  } catch {
    return !0;
  }
}
function t$2(B, L, J) {
  return L();
}
const r$2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$4 = !r$2, c$3 = s$4 ? t$2 : y$1, a$5 = "useSyncExternalStore" in e$2 ? ((B) => B.useSyncExternalStore)(e$2) : c$3;
function S$2(B) {
  return a$5(B.subscribe, B.getSnapshot, B.getSnapshot);
}
function a$4(B, L) {
  let J = B(), ne = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return J;
  }, subscribe(oe) {
    return ne.add(oe), () => ne.delete(oe);
  }, dispatch(oe, ...ce) {
    let Ce = L[oe].call(J, ...ce);
    Ce && (J = Ce, ne.forEach((rt) => rt()));
  } };
}
function c$2() {
  let B;
  return { before({ doc: L }) {
    var J;
    let ne = L.documentElement;
    B = ((J = L.defaultView) != null ? J : window).innerWidth - ne.clientWidth;
  }, after({ doc: L, d: J }) {
    let ne = L.documentElement, oe = ne.clientWidth - ne.offsetWidth, ce = B - oe;
    J.style(ne, "paddingRight", `${ce}px`);
  } };
}
function d$2() {
  return t$7() ? { before({ doc: B, d: L, meta: J }) {
    function ne(oe) {
      return J.containers.flatMap((ce) => ce()).some((ce) => ce.contains(oe));
    }
    L.microTask(() => {
      var oe;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let rt = o$5();
        rt.style(B.documentElement, "scrollBehavior", "auto"), L.add(() => L.microTask(() => rt.dispose()));
      }
      let ce = (oe = window.scrollY) != null ? oe : window.pageYOffset, Ce = null;
      L.addEventListener(B, "click", (rt) => {
        if (rt.target instanceof HTMLElement) try {
          let at = rt.target.closest("a");
          if (!at) return;
          let { hash: ht } = new URL(at.href), it = B.querySelector(ht);
          it && !ne(it) && (Ce = it);
        } catch {
        }
      }, !0), L.addEventListener(B, "touchstart", (rt) => {
        if (rt.target instanceof HTMLElement) if (ne(rt.target)) {
          let at = rt.target;
          for (; at.parentElement && ne(at.parentElement); ) at = at.parentElement;
          L.style(at, "overscrollBehavior", "contain");
        } else L.style(rt.target, "touchAction", "none");
      }), L.addEventListener(B, "touchmove", (rt) => {
        if (rt.target instanceof HTMLElement) if (ne(rt.target)) {
          let at = rt.target;
          for (; at.parentElement && at.dataset.headlessuiPortal !== "" && !(at.scrollHeight > at.clientHeight || at.scrollWidth > at.clientWidth); ) at = at.parentElement;
          at.dataset.headlessuiPortal === "" && rt.preventDefault();
        } else rt.preventDefault();
      }, { passive: !1 }), L.add(() => {
        var rt;
        let at = (rt = window.scrollY) != null ? rt : window.pageYOffset;
        ce !== at && window.scrollTo(0, ce), Ce && Ce.isConnected && (Ce.scrollIntoView({ block: "nearest" }), Ce = null);
      });
    });
  } } : {};
}
function l$2() {
  return { before({ doc: B, d: L }) {
    L.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let L = {};
  for (let J of B) Object.assign(L, J(L));
  return L;
}
let a$3 = a$4(() => /* @__PURE__ */ new Map(), { PUSH(B, L) {
  var J;
  let ne = (J = this.get(B)) != null ? J : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return ne.count++, ne.meta.add(L), this.set(B, ne), this;
}, POP(B, L) {
  let J = this.get(B);
  return J && (J.count--, J.meta.delete(L)), this;
}, SCROLL_PREVENT({ doc: B, d: L, meta: J }) {
  let ne = { doc: B, d: L, meta: m$1(J) }, oe = [d$2(), c$2(), l$2()];
  oe.forEach(({ before: ce }) => ce == null ? void 0 : ce(ne)), oe.forEach(({ after: ce }) => ce == null ? void 0 : ce(ne));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$3.subscribe(() => {
  let B = a$3.getSnapshot(), L = /* @__PURE__ */ new Map();
  for (let [J] of B) L.set(J, J.documentElement.style.overflow);
  for (let J of B.values()) {
    let ne = L.get(J.doc) === "hidden", oe = J.count !== 0;
    (oe && !ne || !oe && ne) && a$3.dispatch(J.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", J), J.count === 0 && a$3.dispatch("TEARDOWN", J);
  }
});
function p$1(B, L, J) {
  let ne = S$2(a$3), oe = B ? ne.get(B) : void 0, ce = oe ? oe.count > 0 : !1;
  return l$6(() => {
    if (!(!B || !L)) return a$3.dispatch("PUSH", B, J), () => a$3.dispatch("POP", B, J);
  }, [L, B]), ce;
}
let u = /* @__PURE__ */ new Map(), t$1 = /* @__PURE__ */ new Map();
function b$4(B, L = !0) {
  l$6(() => {
    var J;
    if (!L) return;
    let ne = typeof B == "function" ? B() : B.current;
    if (!ne) return;
    function oe() {
      var Ce;
      if (!ne) return;
      let rt = (Ce = t$1.get(ne)) != null ? Ce : 1;
      if (rt === 1 ? t$1.delete(ne) : t$1.set(ne, rt - 1), rt !== 1) return;
      let at = u.get(ne);
      at && (at["aria-hidden"] === null ? ne.removeAttribute("aria-hidden") : ne.setAttribute("aria-hidden", at["aria-hidden"]), ne.inert = at.inert, u.delete(ne));
    }
    let ce = (J = t$1.get(ne)) != null ? J : 0;
    return t$1.set(ne, ce + 1), ce !== 0 || (u.set(ne, { "aria-hidden": ne.getAttribute("aria-hidden"), inert: ne.inert }), ne.setAttribute("aria-hidden", "true"), ne.inert = !0), oe;
  }, [B, L]);
}
function N({ defaultContainers: B = [], portals: L, mainTreeNodeRef: J } = {}) {
  var ne;
  let oe = reactExports.useRef((ne = J == null ? void 0 : J.current) != null ? ne : null), ce = n$3(oe), Ce = o$6(() => {
    var rt, at, ht;
    let it = [];
    for (let lt of B) lt !== null && (lt instanceof HTMLElement ? it.push(lt) : "current" in lt && lt.current instanceof HTMLElement && it.push(lt.current));
    if (L != null && L.current) for (let lt of L.current) it.push(lt);
    for (let lt of (rt = ce == null ? void 0 : ce.querySelectorAll("html > *, body > *")) != null ? rt : []) lt !== document.body && lt !== document.head && lt instanceof HTMLElement && lt.id !== "headlessui-portal-root" && (lt.contains(oe.current) || lt.contains((ht = (at = oe.current) == null ? void 0 : at.getRootNode()) == null ? void 0 : ht.host) || it.some((Et) => lt.contains(Et)) || it.push(lt));
    return it;
  });
  return { resolveContainers: Ce, contains: o$6((rt) => Ce().some((at) => at.contains(rt))), mainTreeNodeRef: oe, MainTreeNode: reactExports.useMemo(() => function() {
    return J != null ? null : m$4.createElement(u$4, { features: s$7.Hidden, ref: oe });
  }, [oe, J]) };
}
let a$2 = reactExports.createContext(() => {
});
a$2.displayName = "StackContext";
var s$3 = ((B) => (B[B.Add = 0] = "Add", B[B.Remove = 1] = "Remove", B))(s$3 || {});
function x$1() {
  return reactExports.useContext(a$2);
}
function b$3({ children: B, onUpdate: L, type: J, element: ne, enabled: oe }) {
  let ce = x$1(), Ce = o$6((...rt) => {
    L == null || L(...rt), ce(...rt);
  });
  return l$6(() => {
    let rt = oe === void 0 || oe === !0;
    return rt && Ce(0, J, ne), () => {
      rt && Ce(1, J, ne);
    };
  }, [Ce, J, ne, oe]), m$4.createElement(a$2.Provider, { value: Ce }, B);
}
let d$1 = reactExports.createContext(null);
function f$3() {
  let B = reactExports.useContext(d$1);
  if (B === null) {
    let L = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(L, f$3), L;
  }
  return B;
}
function w$2() {
  let [B, L] = reactExports.useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, reactExports.useMemo(() => function(J) {
    let ne = o$6((ce) => (L((Ce) => [...Ce, ce]), () => L((Ce) => {
      let rt = Ce.slice(), at = rt.indexOf(ce);
      return at !== -1 && rt.splice(at, 1), rt;
    }))), oe = reactExports.useMemo(() => ({ register: ne, slot: J.slot, name: J.name, props: J.props }), [ne, J.slot, J.name, J.props]);
    return m$4.createElement(d$1.Provider, { value: oe }, J.children);
  }, [L])];
}
let I$3 = "p";
function S$1(B, L) {
  let J = I$6(), { id: ne = `headlessui-description-${J}`, ...oe } = B, ce = f$3(), Ce = y$2(L);
  l$6(() => ce.register(ne), [ne, ce.register]);
  let rt = { ref: Ce, ...ce.props, id: ne };
  return C$2({ ourProps: rt, theirProps: oe, slot: ce.slot || {}, defaultTag: I$3, name: ce.name || "Description" });
}
let h$4 = U$3(S$1), G$1 = Object.assign(h$4, {});
var Me$1 = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Me$1 || {}), we = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(we || {});
let He$1 = { 0(B, L) {
  return B.titleId === L.id ? B : { ...B, titleId: L.id };
} }, I$2 = reactExports.createContext(null);
I$2.displayName = "DialogContext";
function b$2(B) {
  let L = reactExports.useContext(I$2);
  if (L === null) {
    let J = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(J, b$2), J;
  }
  return L;
}
function Be(B, L, J = () => [document.body]) {
  p$1(B, L, (ne) => {
    var oe;
    return { containers: [...(oe = ne.containers) != null ? oe : [], J] };
  });
}
function Ge(B, L) {
  return u$7(L.type, He$1, B, L);
}
let Ne$1 = "div", Ue = O$1.RenderStrategy | O$1.Static;
function We(B, L) {
  let J = I$6(), { id: ne = `headlessui-dialog-${J}`, open: oe, onClose: ce, initialFocus: Ce, role: rt = "dialog", __demoMode: at = !1, ...ht } = B, [it, lt] = reactExports.useState(0), Et = reactExports.useRef(!1);
  rt = function() {
    return rt === "dialog" || rt === "alertdialog" ? rt : (Et.current || (Et.current = !0, console.warn(`Invalid role [${rt}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let wt = u$3();
  oe === void 0 && wt !== null && (oe = (wt & d$4.Open) === d$4.Open);
  let Rt = reactExports.useRef(null), Mt = y$2(Rt, L), Lt = n$3(Rt), zt = B.hasOwnProperty("open") || wt !== null, Ot = B.hasOwnProperty("onClose");
  if (!zt && !Ot) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!zt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!Ot) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof oe != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${oe}`);
  if (typeof ce != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${ce}`);
  let It = oe ? 0 : 1, [Ft, Jt] = reactExports.useReducer(Ge, { titleId: null, descriptionId: null, panelRef: reactExports.createRef() }), Vt = o$6(() => ce(!1)), yr = o$6((Xt) => Jt({ type: 0, id: Xt })), jt = l$5() ? at ? !1 : It === 0 : !1, Ut = it > 1, er = reactExports.useContext(I$2) !== null, [Ht, ct] = ee(), dt = { get current() {
    var Xt;
    return (Xt = Ft.panelRef.current) != null ? Xt : Rt.current;
  } }, { resolveContainers: ot, mainTreeNodeRef: ut, MainTreeNode: mt } = N({ portals: Ht, defaultContainers: [dt] }), gt = Ut ? "parent" : "leaf", St = wt !== null ? (wt & d$4.Closing) === d$4.Closing : !1, xt = er || St ? !1 : jt, vt = reactExports.useCallback(() => {
    var Xt, Qt;
    return (Qt = Array.from((Xt = Lt == null ? void 0 : Lt.querySelectorAll("body > *")) != null ? Xt : []).find((br) => br.id === "headlessui-portal-root" ? !1 : br.contains(ut.current) && br instanceof HTMLElement)) != null ? Qt : null;
  }, [ut]);
  b$4(vt, xt);
  let $t = Ut ? !0 : jt, yt = reactExports.useCallback(() => {
    var Xt, Qt;
    return (Qt = Array.from((Xt = Lt == null ? void 0 : Lt.querySelectorAll("[data-headlessui-portal]")) != null ? Xt : []).find((br) => br.contains(ut.current) && br instanceof HTMLElement)) != null ? Qt : null;
  }, [ut]);
  b$4(yt, $t), y$3(ot, (Xt) => {
    Xt.preventDefault(), Vt();
  }, !(!jt || Ut));
  let rr = !(Ut || It !== 0);
  E$1(Lt == null ? void 0 : Lt.defaultView, "keydown", (Xt) => {
    rr && (Xt.defaultPrevented || Xt.key === o$2.Escape && (Xt.preventDefault(), Xt.stopPropagation(), Vt()));
  }), Be(Lt, !(St || It !== 0 || er), ot), reactExports.useEffect(() => {
    if (It !== 0 || !Rt.current) return;
    let Xt = new ResizeObserver((Qt) => {
      for (let br of Qt) {
        let Dr = br.target.getBoundingClientRect();
        Dr.x === 0 && Dr.y === 0 && Dr.width === 0 && Dr.height === 0 && Vt();
      }
    });
    return Xt.observe(Rt.current), () => Xt.disconnect();
  }, [It, Rt, Vt]);
  let [tr, Dt] = w$2(), Wt = reactExports.useMemo(() => [{ dialogState: It, close: Vt, setTitleId: yr }, Ft], [It, Ft, Vt, yr]), or = reactExports.useMemo(() => ({ open: It === 0 }), [It]), _r = { ref: Mt, id: ne, role: rt, "aria-modal": It === 0 ? !0 : void 0, "aria-labelledby": Ft.titleId, "aria-describedby": tr };
  return m$4.createElement(b$3, { type: "Dialog", enabled: It === 0, element: Rt, onUpdate: o$6((Xt, Qt) => {
    Qt === "Dialog" && u$7(Xt, { [s$3.Add]: () => lt((br) => br + 1), [s$3.Remove]: () => lt((br) => br - 1) });
  }) }, m$4.createElement(l$3, { force: !0 }, m$4.createElement(te, null, m$4.createElement(I$2.Provider, { value: Wt }, m$4.createElement(te.Group, { target: Rt }, m$4.createElement(l$3, { force: !1 }, m$4.createElement(Dt, { slot: or, name: "Dialog.Description" }, m$4.createElement(de$1, { initialFocus: Ce, containers: ot, features: jt ? u$7(gt, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, m$4.createElement(ct, null, C$2({ ourProps: _r, theirProps: ht, slot: or, defaultTag: Ne$1, features: Ue, visible: It === 0, name: "Dialog" }))))))))), m$4.createElement(mt, null));
}
let $e = "div";
function Ye(B, L) {
  let J = I$6(), { id: ne = `headlessui-dialog-overlay-${J}`, ...oe } = B, [{ dialogState: ce, close: Ce }] = b$2("Dialog.Overlay"), rt = y$2(L), at = o$6((it) => {
    if (it.target === it.currentTarget) {
      if (r$4(it.currentTarget)) return it.preventDefault();
      it.preventDefault(), it.stopPropagation(), Ce();
    }
  }), ht = reactExports.useMemo(() => ({ open: ce === 0 }), [ce]);
  return C$2({ ourProps: { ref: rt, id: ne, "aria-hidden": !0, onClick: at }, theirProps: oe, slot: ht, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(B, L) {
  let J = I$6(), { id: ne = `headlessui-dialog-backdrop-${J}`, ...oe } = B, [{ dialogState: ce }, Ce] = b$2("Dialog.Backdrop"), rt = y$2(L);
  reactExports.useEffect(() => {
    if (Ce.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [Ce.panelRef]);
  let at = reactExports.useMemo(() => ({ open: ce === 0 }), [ce]);
  return m$4.createElement(l$3, { force: !0 }, m$4.createElement(te, null, C$2({ ourProps: { ref: rt, id: ne, "aria-hidden": !0 }, theirProps: oe, slot: at, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(B, L) {
  let J = I$6(), { id: ne = `headlessui-dialog-panel-${J}`, ...oe } = B, [{ dialogState: ce }, Ce] = b$2("Dialog.Panel"), rt = y$2(L, Ce.panelRef), at = reactExports.useMemo(() => ({ open: ce === 0 }), [ce]), ht = o$6((it) => {
    it.stopPropagation();
  });
  return C$2({ ourProps: { ref: rt, id: ne, onClick: ht }, theirProps: oe, slot: at, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(B, L) {
  let J = I$6(), { id: ne = `headlessui-dialog-title-${J}`, ...oe } = B, [{ dialogState: ce, setTitleId: Ce }] = b$2("Dialog.Title"), rt = y$2(L);
  reactExports.useEffect(() => (Ce(ne), () => Ce(null)), [ne, Ce]);
  let at = reactExports.useMemo(() => ({ open: ce === 0 }), [ce]);
  return C$2({ ourProps: { ref: rt, id: ne }, theirProps: oe, slot: at, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G$1 }), a$1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var L, J;
  let ne = (L = B.innerText) != null ? L : "", oe = B.cloneNode(!0);
  if (!(oe instanceof HTMLElement)) return ne;
  let ce = !1;
  for (let rt of oe.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) rt.remove(), ce = !0;
  let Ce = ce ? (J = oe.innerText) != null ? J : "" : ne;
  return a$1.test(Ce) && (Ce = Ce.replace(a$1, "")), Ce;
}
function g$4(B) {
  let L = B.getAttribute("aria-label");
  if (typeof L == "string") return L.trim();
  let J = B.getAttribute("aria-labelledby");
  if (J) {
    let ne = J.split(" ").map((oe) => {
      let ce = document.getElementById(oe);
      if (ce) {
        let Ce = ce.getAttribute("aria-label");
        return typeof Ce == "string" ? Ce.trim() : o$1(ce).trim();
      }
      return null;
    }).filter(Boolean);
    if (ne.length > 0) return ne.join(", ");
  }
  return o$1(B).trim();
}
function s$2(B) {
  let L = reactExports.useRef(""), J = reactExports.useRef("");
  return o$6(() => {
    let ne = B.current;
    if (!ne) return "";
    let oe = ne.innerText;
    if (L.current === oe) return J.current;
    let ce = g$4(ne).trim().toLowerCase();
    return L.current = oe, J.current = ce, ce;
  });
}
var me = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(me || {}), de = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(de || {}), fe = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B))(fe || {});
function w$1(B, L = (J) => J) {
  let J = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, ne = I$5(L(B.items.slice()), (ce) => ce.dataRef.current.domRef.current), oe = J ? ne.indexOf(J) : null;
  return oe === -1 && (oe = null), { items: ne, activeItemIndex: oe };
}
let Te = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, L) => {
  var J;
  let ne = w$1(B), oe = f$7(L, { resolveItems: () => ne.items, resolveActiveIndex: () => ne.activeItemIndex, resolveId: (ce) => ce.id, resolveDisabled: (ce) => ce.dataRef.current.disabled });
  return { ...B, ...ne, searchQuery: "", activeItemIndex: oe, activationTrigger: (J = L.trigger) != null ? J : 1 };
}, 3: (B, L) => {
  let J = B.searchQuery !== "" ? 0 : 1, ne = B.searchQuery + L.value.toLowerCase(), oe = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + J).concat(B.items.slice(0, B.activeItemIndex + J)) : B.items).find((Ce) => {
    var rt;
    return ((rt = Ce.dataRef.current.textValue) == null ? void 0 : rt.startsWith(ne)) && !Ce.dataRef.current.disabled;
  }), ce = oe ? B.items.indexOf(oe) : -1;
  return ce === -1 || ce === B.activeItemIndex ? { ...B, searchQuery: ne } : { ...B, searchQuery: ne, activeItemIndex: ce, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, L) => {
  let J = w$1(B, (ne) => [...ne, { id: L.id, dataRef: L.dataRef }]);
  return { ...B, ...J };
}, 6: (B, L) => {
  let J = w$1(B, (ne) => {
    let oe = ne.findIndex((ce) => ce.id === L.id);
    return oe !== -1 && ne.splice(oe, 1), ne;
  });
  return { ...B, ...J, activationTrigger: 1 };
} }, U$1 = reactExports.createContext(null);
U$1.displayName = "MenuContext";
function C$1(B) {
  let L = reactExports.useContext(U$1);
  if (L === null) {
    let J = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(J, C$1), J;
  }
  return L;
}
function ye$1(B, L) {
  return u$7(L.type, Te, B, L);
}
let Ie = reactExports.Fragment;
function Me(B, L) {
  let { __demoMode: J = !1, ...ne } = B, oe = reactExports.useReducer(ye$1, { __demoMode: J, menuState: J ? 0 : 1, buttonRef: reactExports.createRef(), itemsRef: reactExports.createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: ce, itemsRef: Ce, buttonRef: rt }, at] = oe, ht = y$2(L);
  y$3([rt, Ce], (wt, Rt) => {
    var Mt;
    at({ type: 1 }), h$6(Rt, T$2.Loose) || (wt.preventDefault(), (Mt = rt.current) == null || Mt.focus());
  }, ce === 0);
  let it = o$6(() => {
    at({ type: 1 });
  }), lt = reactExports.useMemo(() => ({ open: ce === 0, close: it }), [ce, it]), Et = { ref: ht };
  return m$4.createElement(U$1.Provider, { value: oe }, m$4.createElement(s$6, { value: u$7(ce, { 0: d$4.Open, 1: d$4.Closed }) }, C$2({ ourProps: Et, theirProps: ne, slot: lt, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(B, L) {
  var J;
  let ne = I$6(), { id: oe = `headlessui-menu-button-${ne}`, ...ce } = B, [Ce, rt] = C$1("Menu.Button"), at = y$2(Ce.buttonRef, L), ht = p$4(), it = o$6((Mt) => {
    switch (Mt.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        Mt.preventDefault(), Mt.stopPropagation(), rt({ type: 0 }), ht.nextFrame(() => rt({ type: 2, focus: c$5.First }));
        break;
      case o$2.ArrowUp:
        Mt.preventDefault(), Mt.stopPropagation(), rt({ type: 0 }), ht.nextFrame(() => rt({ type: 2, focus: c$5.Last }));
        break;
    }
  }), lt = o$6((Mt) => {
    switch (Mt.key) {
      case o$2.Space:
        Mt.preventDefault();
        break;
    }
  }), Et = o$6((Mt) => {
    if (r$4(Mt.currentTarget)) return Mt.preventDefault();
    B.disabled || (Ce.menuState === 0 ? (rt({ type: 1 }), ht.nextFrame(() => {
      var Lt;
      return (Lt = Ce.buttonRef.current) == null ? void 0 : Lt.focus({ preventScroll: !0 });
    })) : (Mt.preventDefault(), rt({ type: 0 })));
  }), wt = reactExports.useMemo(() => ({ open: Ce.menuState === 0 }), [Ce]), Rt = { ref: at, id: oe, type: T$1(B, Ce.buttonRef), "aria-haspopup": "menu", "aria-controls": (J = Ce.itemsRef.current) == null ? void 0 : J.id, "aria-expanded": Ce.menuState === 0, onKeyDown: it, onKeyUp: lt, onClick: Et };
  return C$2({ ourProps: Rt, theirProps: ce, slot: wt, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O$1.RenderStrategy | O$1.Static;
function Ee(B, L) {
  var J, ne;
  let oe = I$6(), { id: ce = `headlessui-menu-items-${oe}`, ...Ce } = B, [rt, at] = C$1("Menu.Items"), ht = y$2(rt.itemsRef, L), it = n$3(rt.itemsRef), lt = p$4(), Et = u$3(), wt = Et !== null ? (Et & d$4.Open) === d$4.Open : rt.menuState === 0;
  reactExports.useEffect(() => {
    let Ot = rt.itemsRef.current;
    Ot && rt.menuState === 0 && Ot !== (it == null ? void 0 : it.activeElement) && Ot.focus({ preventScroll: !0 });
  }, [rt.menuState, rt.itemsRef, it]), F$2({ container: rt.itemsRef.current, enabled: rt.menuState === 0, accept(Ot) {
    return Ot.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : Ot.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(Ot) {
    Ot.setAttribute("role", "none");
  } });
  let Rt = o$6((Ot) => {
    var It, Ft;
    switch (lt.dispose(), Ot.key) {
      case o$2.Space:
        if (rt.searchQuery !== "") return Ot.preventDefault(), Ot.stopPropagation(), at({ type: 3, value: Ot.key });
      case o$2.Enter:
        if (Ot.preventDefault(), Ot.stopPropagation(), at({ type: 1 }), rt.activeItemIndex !== null) {
          let { dataRef: Jt } = rt.items[rt.activeItemIndex];
          (Ft = (It = Jt.current) == null ? void 0 : It.domRef.current) == null || Ft.click();
        }
        D$3(rt.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return Ot.preventDefault(), Ot.stopPropagation(), at({ type: 2, focus: c$5.Next });
      case o$2.ArrowUp:
        return Ot.preventDefault(), Ot.stopPropagation(), at({ type: 2, focus: c$5.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return Ot.preventDefault(), Ot.stopPropagation(), at({ type: 2, focus: c$5.First });
      case o$2.End:
      case o$2.PageDown:
        return Ot.preventDefault(), Ot.stopPropagation(), at({ type: 2, focus: c$5.Last });
      case o$2.Escape:
        Ot.preventDefault(), Ot.stopPropagation(), at({ type: 1 }), o$5().nextFrame(() => {
          var Jt;
          return (Jt = rt.buttonRef.current) == null ? void 0 : Jt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        Ot.preventDefault(), Ot.stopPropagation(), at({ type: 1 }), o$5().nextFrame(() => {
          _$3(rt.buttonRef.current, Ot.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        Ot.key.length === 1 && (at({ type: 3, value: Ot.key }), lt.setTimeout(() => at({ type: 4 }), 350));
        break;
    }
  }), Mt = o$6((Ot) => {
    switch (Ot.key) {
      case o$2.Space:
        Ot.preventDefault();
        break;
    }
  }), Lt = reactExports.useMemo(() => ({ open: rt.menuState === 0 }), [rt]), zt = { "aria-activedescendant": rt.activeItemIndex === null || (J = rt.items[rt.activeItemIndex]) == null ? void 0 : J.id, "aria-labelledby": (ne = rt.buttonRef.current) == null ? void 0 : ne.id, id: ce, onKeyDown: Rt, onKeyUp: Mt, role: "menu", tabIndex: 0, ref: ht };
  return C$2({ ourProps: zt, theirProps: Ce, slot: Lt, defaultTag: Ae, features: be, visible: wt, name: "Menu.Items" });
}
let Se$1 = reactExports.Fragment;
function xe$1(B, L) {
  let J = I$6(), { id: ne = `headlessui-menu-item-${J}`, disabled: oe = !1, ...ce } = B, [Ce, rt] = C$1("Menu.Item"), at = Ce.activeItemIndex !== null ? Ce.items[Ce.activeItemIndex].id === ne : !1, ht = reactExports.useRef(null), it = y$2(L, ht);
  l$6(() => {
    if (Ce.__demoMode || Ce.menuState !== 0 || !at || Ce.activationTrigger === 0) return;
    let Jt = o$5();
    return Jt.requestAnimationFrame(() => {
      var Vt, yr;
      (yr = (Vt = ht.current) == null ? void 0 : Vt.scrollIntoView) == null || yr.call(Vt, { block: "nearest" });
    }), Jt.dispose;
  }, [Ce.__demoMode, ht, at, Ce.menuState, Ce.activationTrigger, Ce.activeItemIndex]);
  let lt = s$2(ht), Et = reactExports.useRef({ disabled: oe, domRef: ht, get textValue() {
    return lt();
  } });
  l$6(() => {
    Et.current.disabled = oe;
  }, [Et, oe]), l$6(() => (rt({ type: 5, id: ne, dataRef: Et }), () => rt({ type: 6, id: ne })), [Et, ne]);
  let wt = o$6(() => {
    rt({ type: 1 });
  }), Rt = o$6((Jt) => {
    if (oe) return Jt.preventDefault();
    rt({ type: 1 }), D$3(Ce.buttonRef.current);
  }), Mt = o$6(() => {
    if (oe) return rt({ type: 2, focus: c$5.Nothing });
    rt({ type: 2, focus: c$5.Specific, id: ne });
  }), Lt = u$5(), zt = o$6((Jt) => Lt.update(Jt)), Ot = o$6((Jt) => {
    Lt.wasMoved(Jt) && (oe || at || rt({ type: 2, focus: c$5.Specific, id: ne, trigger: 0 }));
  }), It = o$6((Jt) => {
    Lt.wasMoved(Jt) && (oe || at && rt({ type: 2, focus: c$5.Nothing }));
  }), Ft = reactExports.useMemo(() => ({ active: at, disabled: oe, close: wt }), [at, oe, wt]);
  return C$2({ ourProps: { id: ne, ref: it, role: "menuitem", tabIndex: oe === !0 ? void 0 : -1, "aria-disabled": oe === !0 ? !0 : void 0, disabled: void 0, onClick: Rt, onFocus: Mt, onPointerEnter: zt, onMouseEnter: zt, onPointerMove: Ot, onMouseMove: Ot, onPointerLeave: It, onMouseLeave: It }, theirProps: ce, slot: Ft, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c$1(B = 0) {
  let [L, J] = reactExports.useState(B), ne = f$6(), oe = reactExports.useCallback((at) => {
    ne.current && J((ht) => ht | at);
  }, [L, ne]), ce = reactExports.useCallback((at) => !!(L & at), [L]), Ce = reactExports.useCallback((at) => {
    ne.current && J((ht) => ht & ~at);
  }, [J, ne]), rt = reactExports.useCallback((at) => {
    ne.current && J((ht) => ht ^ at);
  }, [J]);
  return { flags: L, addFlag: oe, hasFlag: ce, removeFlag: Ce, toggleFlag: rt };
}
function l$1(B) {
  let L = { called: !1 };
  return (...J) => {
    if (!L.called) return L.called = !0, B(...J);
  };
}
function g$3(B, ...L) {
  B && L.length > 0 && B.classList.add(...L);
}
function v$1(B, ...L) {
  B && L.length > 0 && B.classList.remove(...L);
}
function b$1(B, L) {
  let J = o$5();
  if (!B) return J.dispose;
  let { transitionDuration: ne, transitionDelay: oe } = getComputedStyle(B), [ce, Ce] = [ne, oe].map((at) => {
    let [ht = 0] = at.split(",").filter(Boolean).map((it) => it.includes("ms") ? parseFloat(it) : parseFloat(it) * 1e3).sort((it, lt) => lt - it);
    return ht;
  }), rt = ce + Ce;
  if (rt !== 0) {
    J.group((ht) => {
      ht.setTimeout(() => {
        L(), ht.dispose();
      }, rt), ht.addEventListener(B, "transitionrun", (it) => {
        it.target === it.currentTarget && ht.dispose();
      });
    });
    let at = J.addEventListener(B, "transitionend", (ht) => {
      ht.target === ht.currentTarget && (L(), at());
    });
  } else L();
  return J.add(() => L()), J.dispose;
}
function M$1(B, L, J, ne) {
  let oe = J ? "enter" : "leave", ce = o$5(), Ce = ne !== void 0 ? l$1(ne) : () => {
  };
  oe === "enter" && (B.removeAttribute("hidden"), B.style.display = "");
  let rt = u$7(oe, { enter: () => L.enter, leave: () => L.leave }), at = u$7(oe, { enter: () => L.enterTo, leave: () => L.leaveTo }), ht = u$7(oe, { enter: () => L.enterFrom, leave: () => L.leaveFrom });
  return v$1(B, ...L.base, ...L.enter, ...L.enterTo, ...L.enterFrom, ...L.leave, ...L.leaveFrom, ...L.leaveTo, ...L.entered), g$3(B, ...L.base, ...rt, ...ht), ce.nextFrame(() => {
    v$1(B, ...L.base, ...rt, ...ht), g$3(B, ...L.base, ...rt, ...at), b$1(B, () => (v$1(B, ...L.base, ...rt), g$3(B, ...L.base, ...L.entered), Ce()));
  }), ce.dispose;
}
function D({ immediate: B, container: L, direction: J, classes: ne, onStart: oe, onStop: ce }) {
  let Ce = f$6(), rt = p$4(), at = s$a(J);
  l$6(() => {
    B && (at.current = "enter");
  }, [B]), l$6(() => {
    let ht = o$5();
    rt.add(ht.dispose);
    let it = L.current;
    if (it && at.current !== "idle" && Ce.current) return ht.dispose(), oe.current(at.current), ht.add(M$1(it, ne.current, at.current === "enter", () => {
      ht.dispose(), ce.current(at.current);
    })), ht.dispose;
  }, [J]);
}
function S(B = "") {
  return B.split(/\s+/).filter((L) => L.length > 1);
}
let I$1 = reactExports.createContext(null);
I$1.displayName = "TransitionContext";
var Se = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(Se || {});
function ye() {
  let B = reactExports.useContext(I$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function xe() {
  let B = reactExports.useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = reactExports.createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: L }) => L.current !== null).filter(({ state: L }) => L === "visible").length > 0;
}
function se(B, L) {
  let J = s$a(B), ne = reactExports.useRef([]), oe = f$6(), ce = p$4(), Ce = o$6((wt, Rt = v$2.Hidden) => {
    let Mt = ne.current.findIndex(({ el: Lt }) => Lt === wt);
    Mt !== -1 && (u$7(Rt, { [v$2.Unmount]() {
      ne.current.splice(Mt, 1);
    }, [v$2.Hidden]() {
      ne.current[Mt].state = "hidden";
    } }), ce.microTask(() => {
      var Lt;
      !U(ne) && oe.current && ((Lt = J.current) == null || Lt.call(J));
    }));
  }), rt = o$6((wt) => {
    let Rt = ne.current.find(({ el: Mt }) => Mt === wt);
    return Rt ? Rt.state !== "visible" && (Rt.state = "visible") : ne.current.push({ el: wt, state: "visible" }), () => Ce(wt, v$2.Unmount);
  }), at = reactExports.useRef([]), ht = reactExports.useRef(Promise.resolve()), it = reactExports.useRef({ enter: [], leave: [], idle: [] }), lt = o$6((wt, Rt, Mt) => {
    at.current.splice(0), L && (L.chains.current[Rt] = L.chains.current[Rt].filter(([Lt]) => Lt !== wt)), L == null || L.chains.current[Rt].push([wt, new Promise((Lt) => {
      at.current.push(Lt);
    })]), L == null || L.chains.current[Rt].push([wt, new Promise((Lt) => {
      Promise.all(it.current[Rt].map(([zt, Ot]) => Ot)).then(() => Lt());
    })]), Rt === "enter" ? ht.current = ht.current.then(() => L == null ? void 0 : L.wait.current).then(() => Mt(Rt)) : Mt(Rt);
  }), Et = o$6((wt, Rt, Mt) => {
    Promise.all(it.current[Rt].splice(0).map(([Lt, zt]) => zt)).then(() => {
      var Lt;
      (Lt = at.current.shift()) == null || Lt();
    }).then(() => Mt(Rt));
  });
  return reactExports.useMemo(() => ({ children: ne, register: rt, unregister: Ce, onStart: lt, onStop: Et, wait: ht, chains: it }), [rt, Ce, ne, lt, Et, it, ht]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(B) {
  var L;
  let J = {};
  for (let ne of Pe) J[ne] = (L = B[ne]) != null ? L : Ne;
  return J;
}
function Re(B) {
  let L = reactExports.useRef(ae(B));
  return reactExports.useEffect(() => {
    L.current = ae(B);
  }, [B]), L;
}
let De = "div", le = O$1.RenderStrategy;
function He(B, L) {
  var J, ne;
  let { beforeEnter: oe, afterEnter: ce, beforeLeave: Ce, afterLeave: rt, enter: at, enterFrom: ht, enterTo: it, entered: lt, leave: Et, leaveFrom: wt, leaveTo: Rt, ...Mt } = B, Lt = reactExports.useRef(null), zt = y$2(Lt, L), Ot = (J = Mt.unmount) == null || J ? v$2.Unmount : v$2.Hidden, { show: It, appear: Ft, initial: Jt } = ye(), [Vt, yr] = reactExports.useState(It ? "visible" : "hidden"), jt = xe(), { register: Ut, unregister: er } = jt;
  reactExports.useEffect(() => Ut(Lt), [Ut, Lt]), reactExports.useEffect(() => {
    if (Ot === v$2.Hidden && Lt.current) {
      if (It && Vt !== "visible") {
        yr("visible");
        return;
      }
      return u$7(Vt, { hidden: () => er(Lt), visible: () => Ut(Lt) });
    }
  }, [Vt, Lt, Ut, er, It, Ot]);
  let Ht = s$a({ base: S(Mt.className), enter: S(at), enterFrom: S(ht), enterTo: S(it), entered: S(lt), leave: S(Et), leaveFrom: S(wt), leaveTo: S(Rt) }), ct = Re({ beforeEnter: oe, afterEnter: ce, beforeLeave: Ce, afterLeave: rt }), dt = l$5();
  reactExports.useEffect(() => {
    if (dt && Vt === "visible" && Lt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [Lt, Vt, dt]);
  let ot = Jt && !Ft, ut = Ft && It && Jt, mt = !dt || ot ? "idle" : It ? "enter" : "leave", gt = c$1(0), St = o$6((rr) => u$7(rr, { enter: () => {
    gt.addFlag(d$4.Opening), ct.current.beforeEnter();
  }, leave: () => {
    gt.addFlag(d$4.Closing), ct.current.beforeLeave();
  }, idle: () => {
  } })), xt = o$6((rr) => u$7(rr, { enter: () => {
    gt.removeFlag(d$4.Opening), ct.current.afterEnter();
  }, leave: () => {
    gt.removeFlag(d$4.Closing), ct.current.afterLeave();
  }, idle: () => {
  } })), vt = se(() => {
    yr("hidden"), er(Lt);
  }, jt), $t = reactExports.useRef(!1);
  D({ immediate: ut, container: Lt, classes: Ht, direction: mt, onStart: s$a((rr) => {
    $t.current = !0, vt.onStart(Lt, rr, St);
  }), onStop: s$a((rr) => {
    $t.current = !1, vt.onStop(Lt, rr, xt), rr === "leave" && !U(vt) && (yr("hidden"), er(Lt));
  }) });
  let yt = Mt, Bt = { ref: zt };
  return ut ? yt = { ...yt, className: t$5(Mt.className, ...Ht.current.enter, ...Ht.current.enterFrom) } : $t.current && (yt.className = t$5(Mt.className, (ne = Lt.current) == null ? void 0 : ne.className), yt.className === "" && delete yt.className), m$4.createElement(M.Provider, { value: vt }, m$4.createElement(s$6, { value: u$7(Vt, { visible: d$4.Open, hidden: d$4.Closed }) | gt.flags }, C$2({ ourProps: Bt, theirProps: yt, defaultTag: De, features: le, visible: Vt === "visible", name: "Transition.Child" })));
}
function Fe(B, L) {
  let { show: J, appear: ne = !1, unmount: oe = !0, ...ce } = B, Ce = reactExports.useRef(null), rt = y$2(Ce, L);
  l$5();
  let at = u$3();
  if (J === void 0 && at !== null && (J = (at & d$4.Open) === d$4.Open), ![!0, !1].includes(J)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [ht, it] = reactExports.useState(J ? "visible" : "hidden"), lt = se(() => {
    it("hidden");
  }), [Et, wt] = reactExports.useState(!0), Rt = reactExports.useRef([J]);
  l$6(() => {
    Et !== !1 && Rt.current[Rt.current.length - 1] !== J && (Rt.current.push(J), wt(!1));
  }, [Rt, J]);
  let Mt = reactExports.useMemo(() => ({ show: J, appear: ne, initial: Et }), [J, ne, Et]);
  reactExports.useEffect(() => {
    if (J) it("visible");
    else if (!U(lt)) it("hidden");
    else {
      let It = Ce.current;
      if (!It) return;
      let Ft = It.getBoundingClientRect();
      Ft.x === 0 && Ft.y === 0 && Ft.width === 0 && Ft.height === 0 && it("hidden");
    }
  }, [J, lt]);
  let Lt = { unmount: oe }, zt = o$6(() => {
    var It;
    Et && wt(!1), (It = B.beforeEnter) == null || It.call(B);
  }), Ot = o$6(() => {
    var It;
    Et && wt(!1), (It = B.beforeLeave) == null || It.call(B);
  });
  return m$4.createElement(M.Provider, { value: lt }, m$4.createElement(I$1.Provider, { value: Mt }, C$2({ ourProps: { ...Lt, as: reactExports.Fragment, children: m$4.createElement(ue, { ref: rt, ...Lt, ...ce, beforeEnter: zt, beforeLeave: Ot }) }, theirProps: {}, defaultTag: reactExports.Fragment, features: le, visible: ht === "visible", name: "Transition" })));
}
function _e(B, L) {
  let J = reactExports.useContext(I$1) !== null, ne = u$3() !== null;
  return m$4.createElement(m$4.Fragment, null, !J && ne ? m$4.createElement(q, { ref: L, ...B }) : m$4.createElement(ue, { ref: L, ...B }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.2692%206.04835H10.6729C7.79592%2012.2004%2012.4577%2014.8894%2015.1483%2015.4648L13.9495%2019.3884C12.7348%2018.4467%2010.7795%2018.0282%209.79384%2017.8974C5.55824%2017.662%204.20118%2020.7103%204.03982%2021.9779C3.72015%2024.4889%205.31849%2026.9215%209.07459%2026.9215C12.0795%2026.9215%2014.3758%2025.2998%2015.1483%2024.4889C18.0892%2027%2020.7958%2027.1569%2021.7814%2026.9215C26.7043%2026.5449%2027.5621%2022.004%2027.3756%2019.7807H24.1789C23.4117%2025.8072%2019.0642%2023.338%2016.9864%2021.3501L18.6646%2015.7002C30.0128%2013.1892%2029.9329%204.322%2024.1789%204.00811C19.5757%203.75701%2016.8265%209.39643%2016.0274%2012.2475C12.1914%2011.6198%2013.2569%207.85317%2014.2692%206.04835Z'%20fill='white'/%3e%3cpath%20d='M19.5437%2012.2475C19.9699%2010.6258%2021.7814%206.99461%2023.7793%207.2254C26.4965%207.53927%2022.6605%2011.5413%2019.5437%2012.2475Z'%20fill='%23303746'/%3e%3cpath%20d='M12.8307%2022.2918C11.7918%2021.2716%208.03567%2020.0946%207.31642%2022.2918C7.00817%2023.2334%209.47418%2024.8813%2012.8307%2022.2918Z'%20fill='%23303746'/%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21.403%2011.0761L22.9233%2012.9126C23.0973%2013.1219%2023.2486%2013.2846%2023.3167%2013.3853C23.7705%2013.8503%2024.0277%2014.478%2024.0277%2015.1289C23.9823%2015.8961%2023.4982%2016.423%2023.0444%2016.9887L21.9779%2018.2673L21.4257%2018.9338C21.403%2018.957%2021.3954%2018.988%2021.3879%2019.019C21.3803%2019.05%2021.3879%2019.081%2021.403%2019.1043C21.4181%2019.1353%2021.4332%2019.1585%2021.4635%2019.174C21.4862%2019.1895%2021.5165%2019.1973%2021.5467%2019.1973H27.0986C27.9458%2019.1973%2029.0123%2019.9257%2028.9518%2021.0338C28.9518%2021.5375%2028.7476%2022.018%2028.3996%2022.3744C28.0441%2022.7309%2027.5676%2022.9324%2027.0684%2022.9324H18.3699C17.795%2022.9324%2016.2595%2022.9944%2015.8284%2021.6538C15.7376%2021.3748%2015.7225%2021.0726%2015.7906%2020.7858C15.9192%2020.3596%2016.1158%2019.9567%2016.373%2019.6002C16.8117%2018.9338%2017.2807%2018.2751%2017.7496%2017.6319C18.3547%2016.7872%2018.9674%2015.9736%2019.5801%2015.1134C19.6028%2015.0824%2019.6103%2015.0514%2019.6103%2015.0127C19.6103%2014.9739%2019.5952%2014.9429%2019.5801%2014.9119L17.3714%2012.254C17.3563%2012.2385%2017.3412%2012.223%2017.3185%2012.2075C17.2958%2012.1997%2017.2731%2012.192%2017.2504%2012.192C17.2277%2012.192%2017.205%2012.1997%2017.1823%2012.2075C17.1596%2012.2152%2017.1445%2012.2307%2017.1294%2012.254C16.5394%2013.0599%2013.945%2016.6323%2013.3928%2017.3607C12.8406%2018.0814%2011.4791%2018.1279%2010.7228%2017.3607L7.26605%2013.8581C7.24335%2013.8348%207.2131%2013.8193%207.18284%2013.8116C7.15259%2013.8038%207.12233%2013.8116%207.09208%2013.8193C7.06182%2013.8348%207.03913%2013.8503%207.024%2013.8813C7.00887%2013.9045%206.99374%2013.9355%207.00131%2013.9665V20.7006C7.00887%2021.181%206.87272%2021.646%206.60042%2022.0412C6.32812%2022.4364%205.94993%2022.7309%205.50365%2022.8936C5.21623%2022.9944%204.91367%2023.0254%204.61868%2022.9789C4.32368%2022.9324%204.03626%2022.8239%203.79421%2022.6456C3.5446%2022.4674%203.34794%2022.2349%203.21179%2021.9637C3.07564%2021.6925%203%2021.3903%203%2021.0881V8.97605C3.02269%208.54209%203.17397%208.12364%203.44627%207.77492C3.71857%207.43396%204.08164%207.18598%204.49765%207.06974C4.85316%206.97675%205.23135%206.97675%205.58686%207.06974C5.94236%207.17048%206.26761%207.35646%206.53235%207.62769L11.8498%2012.9979C11.8649%2013.0134%2011.8876%2013.0289%2011.9027%2013.0366C11.9254%2013.0444%2011.9481%2013.0444%2011.9708%2013.0444C11.9935%2013.0444%2012.0162%2013.0366%2012.0313%2013.0211C12.054%2013.0134%2012.0691%2012.9979%2012.0843%2012.9746L15.8586%207.69743C16.0326%207.48045%2016.252%207.30997%2016.5016%207.19373C16.7512%207.07749%2017.0235%207.00775%2017.2958%207.00775H27.1137C27.386%207.00775%2027.6508%207.06974%2027.8928%207.17823C28.1349%207.29447%2028.3542%207.4572%2028.5358%207.65868C28.7097%207.86016%2028.8459%208.10039%2028.9215%208.36386C28.9972%208.62733%2029.0199%208.89856%2028.982%209.16978C28.914%209.63473%2028.6795%2010.0609%2028.324%2010.3632C27.9685%2010.6654%2027.5146%2010.8359%2027.0457%2010.8281H21.5467C21.5165%2010.8281%2021.4938%2010.8359%2021.4711%2010.8514C21.4484%2010.8669%2021.4257%2010.8901%2021.4181%2010.9134C21.403%2010.9366%2021.403%2010.9676%2021.403%2010.9908C21.3803%2011.0218%2021.3879%2011.0528%2021.403%2011.0761Z'%20fill='url(%23paint0_linear_3119_13568)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13568'%20x1='4.08333'%20y1='11'%20x2='29'%20y2='11'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23EF2690'/%3e%3cstop%20offset='1'%20stop-color='%23AB27FE'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11.8444%205H5.48893C5.21893%205%205%205.21883%205%205.48892V11.8444C5%2012.1144%205.21893%2012.3334%205.48893%2012.3334H11.8444C12.1145%2012.3334%2012.3334%2012.1144%2012.3334%2011.8444V5.48892C12.3334%205.21883%2012.1145%205%2011.8444%205ZM19.1807%2012.3336H12.8252C12.5552%2012.3336%2012.3363%2012.5524%2012.3363%2012.8224V19.178C12.3363%2019.448%2012.5552%2019.6669%2012.8252%2019.6669H19.1807C19.4507%2019.6669%2019.6697%2019.448%2019.6697%2019.178V12.8224C19.6697%2012.5524%2019.4507%2012.3336%2019.1807%2012.3336ZM20.1556%205.00001H26.5112C26.7812%205.00001%2027%205.21884%2027%205.48893V11.8444C27%2012.1144%2026.7812%2012.3334%2026.5112%2012.3334H20.1556C19.8856%2012.3334%2019.6666%2012.1144%2019.6666%2011.8444V5.48893C19.6666%205.21884%2019.8856%205.00001%2020.1556%205.00001ZM11.8445%2019.6665H5.48895C5.21895%2019.6665%205.00002%2019.8853%205.00002%2020.1553V26.511C5.00002%2026.781%205.21895%2026.9999%205.48895%2026.9999H11.8445C12.1146%2026.9999%2012.3334%2026.781%2012.3334%2026.511V20.1553C12.3334%2019.8853%2012.1146%2019.6665%2011.8445%2019.6665ZM20.1556%2019.6665H26.5112C26.7812%2019.6665%2027%2019.8853%2027%2020.1553V26.511C27%2026.781%2026.7812%2026.9999%2026.5112%2026.9999H20.1556C19.8856%2026.9999%2019.6666%2026.781%2019.6666%2026.511V20.1553C19.6666%2019.8853%2019.8856%2019.6665%2020.1556%2019.6665Z'%20fill='white'/%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.2892%204.87219L26.2505%2010.3415C26.7579%2010.8061%2027.0077%2011.2762%2026.9998%2011.7498C26.992%2012.2235%2026.7737%2012.6553%2026.3469%2013.047C25.9004%2013.457%2025.4185%2013.6647%2024.9032%2013.6738C24.3879%2013.6811%2023.8766%2013.4515%2023.3691%2012.9869L17.2721%207.39369C16.5798%206.75785%2015.9111%206.30785%2015.268%206.04367C14.6248%205.7795%2013.9482%205.73759%2013.2402%205.91978C12.5302%206.10015%2011.769%206.56473%2010.9528%207.31171C9.82782%208.34472%209.29089%209.31397%209.34596%2010.2195C9.40103%2011.1249%209.9596%2012.065%2011.0197%2013.0361L17.1659%2018.6767C17.6792%2019.1467%2017.931%2019.6168%2017.9231%2020.0832C17.9152%2020.5514%2017.695%2020.9832%2017.2603%2021.3822C16.8276%2021.7794%2016.3497%2021.9871%2015.8305%2022.0035C15.3112%2022.0199%2014.794%2021.7921%2014.2826%2021.3221L8.32127%2015.8528C7.35164%2014.9637%206.65146%2014.122%206.22074%2013.3276C5.79001%2012.5333%205.62874%2011.6351%205.74084%2010.633C5.84115%209.77491%206.13813%208.94413%206.63376%208.13885C7.12743%207.33357%207.83547%206.51008%208.75396%205.66654C9.84749%204.66268%2010.8919%203.89384%2011.887%203.3582C12.8803%202.82256%2013.842%202.52559%2014.7704%202.46365C15.7006%202.4017%2016.6172%202.57296%2017.5239%202.97742C18.4305%203.38188%2019.351%204.01226%2020.2872%204.87219H20.2892Z'%20fill='url(%23paint0_linear_3119_13572)'/%3e%3cpath%20d='M10.9371%2026.9408L4.97771%2021.4714C4.47027%2021.005%204.22049%2020.5368%204.22836%2020.0631C4.23623%2019.5894%204.45454%2019.1576%204.88133%2018.7659C5.32779%2018.356%205.80966%2018.1483%206.32495%2018.1392C6.84025%2018.1319%207.35162%2018.3596%207.85905%2018.826L13.9541%2024.4193C14.6484%2025.0551%2015.3151%2025.5051%2015.9583%2025.7693C16.6014%2026.0335%2017.278%2026.0735%2017.988%2025.8932C18.698%2025.7128%2019.4591%2025.2482%2020.2754%2024.4994C21.4004%2023.4664%2021.9373%2022.4972%2021.8822%2021.5917C21.8272%2020.6862%2021.2686%2019.7461%2020.2085%2018.7732L16.9338%2015.7944C16.4205%2015.3244%2016.1687%2014.8543%2016.1766%2014.3879C16.1845%2013.9197%2016.4047%2013.4879%2016.8394%2013.0889C17.2721%2012.6917%2017.75%2012.484%2018.2692%2012.4676C18.7885%2012.4512%2019.3057%2012.679%2019.8171%2013.149L22.905%2015.9566C23.8746%2016.8457%2024.5748%2017.6874%2025.0055%2018.4817C25.4362%2019.2761%2025.5975%2020.1743%2025.4854%2021.1763C25.3851%2022.0344%2025.0881%2022.8652%2024.5925%2023.6705C24.0988%2024.4757%2023.3908%2025.2992%2022.4723%2026.1428C21.3787%2027.1466%2020.3344%2027.9155%2019.3392%2028.4511C18.344%2028.9868%2017.3822%2029.2856%2016.4519%2029.3475C15.5216%2029.4094%2014.6051%2029.2382%2013.6984%2028.8337C12.7917%2028.4293%2011.8713%2027.7989%2010.9351%2026.9389L10.9371%2026.9408Z'%20fill='url(%23paint1_linear_3119_13572)'/%3e%3cpath%20d='M14.6543%2012.8284C15.8633%2012.8284%2016.8433%2011.9205%2016.8433%2010.8006C16.8433%209.6807%2015.8633%208.77284%2014.6543%208.77284C13.4453%208.77284%2012.4653%209.6807%2012.4653%2010.8006C12.4653%2011.9205%2013.4453%2012.8284%2014.6543%2012.8284Z'%20fill='url(%23paint2_radial_3119_13572)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13572'%20x1='25.27'%20y1='8.05866'%20x2='7.28614'%20y2='16.6864'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_3119_13572'%20x1='6.4668'%20y1='23.9797'%20x2='27.5911'%20y2='17.1926'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_3119_13572'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(14.6543%2010.8024)%20scale(2.18903%202.02777)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M27.0042%2026.6428V22.6649C27.0042%2022.5072%2026.9416%2022.3568%2026.8298%2022.245L9.90453%205.31965C9.79276%205.20788%209.64232%205.14521%209.4846%205.14521H5.50684C5.31046%205.14521%205.15063%205.30503%205.15063%205.50141V9.19714C5.15063%209.35487%205.21331%209.50528%205.32508%209.61706L11.4004%2015.6923C11.5393%2015.8313%2011.5393%2016.0569%2011.4004%2016.1959L5.25509%2022.3411C5.18824%2022.4079%205.15063%2022.4988%205.15063%2022.5929V26.6428C5.15063%2026.839%205.31046%2026.999%205.50684%2026.999H12.1535C12.3499%2026.999%2012.5097%2026.839%2012.5097%2026.6428V24.2569C12.5097%2024.1629%2012.5473%2024.072%2012.6142%2024.0051L15.9108%2020.7084C16.0498%2020.5695%2016.2754%2020.5695%2016.4144%2020.7084L22.5314%2026.8256C22.6432%2026.9373%2022.7936%2027%2022.9513%2027H26.647C26.8434%2027%2027.0032%2026.8401%2027.0032%2026.6438L27.0042%2026.6428Z'%20fill='white'/%3e%3cpath%20d='M18.1379%2010.413H21.467C21.6644%2010.413%2021.8253%2010.5739%2021.8253%2010.7713V14.1003C21.8253%2014.42%2022.2118%2014.5799%2022.4374%2014.3531L27.0043%209.77894C27.0711%209.71207%2027.1088%209.62121%2027.1088%209.52614V5.52017C27.1088%205.32275%2026.9488%205.16188%2026.7504%205.16188L22.6849%205.15666C22.5899%205.15666%2022.4991%205.19426%2022.4311%205.26112L17.8841%209.80087C17.6585%2010.0265%2017.8182%2010.413%2018.1369%2010.413H18.1379Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, L = 4, J = 5) {
  if (B.length <= L + J)
    return B;
  const ne = B.slice(0, L), oe = B.slice(B.length - J);
  return `${ne}...${oe}`;
}
const WALLET_TO_ICON = {
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: L,
  onViewProfile: J,
  onChangeWallet: ne,
  onDisconnectWallet: oe
}) {
  const { wallet: ce } = useWallie();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    qe$1,
    {
      as: "section",
      className: "wallie-relative wallie-inline-block wallie-text-left",
      children: ({ open: Ce }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-identifier-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: WALLET_TO_ICON[ce],
              alt: `${ce} is connected`
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[L] ?? L })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${Ce ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: "ord connect dropdown"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe,
          {
            as: reactExports.Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => J == null ? void 0 : J(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ne == null ? void 0 : ne(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => oe == null ? void 0 : oe(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "logout" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
const WalletIcon = "data:image/svg+xml,%3csvg%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3cpath%20d='M9%206.25C7.61929%206.25%206.5%207.36929%206.5%208.75V21.25C6.5%2022.6308%207.61929%2023.75%209%2023.75H25C26.3808%2023.75%2027.5%2022.6308%2027.5%2021.25V18.75H23.75C21.6789%2018.75%2020%2017.0711%2020%2015C20%2012.9289%2021.6789%2011.25%2023.75%2011.25H27.5V8.75C27.5%207.36929%2026.3808%206.25%2025%206.25H9Z'%20fill='%231C2033'%20/%3e%3cpath%20d='M25%2015C25%2015.6904%2024.4404%2016.25%2023.75%2016.25C23.0596%2016.25%2022.5%2015.6904%2022.5%2015C22.5%2014.3096%2023.0596%2013.75%2023.75%2013.75C24.4404%2013.75%2025%2014.3096%2025%2015Z'%20fill='%231C2033'%20/%3e%3c/svg%3e";
function PreConnectButton({
  openModal: B,
  disabled: L,
  connectButton: J = "Wallet Connect",
  connectButtonComponent: ne
}) {
  return ne ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: B, "aria-label": "Connect Button", type: "button", className: "wallie-w-full", children: ne }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: L,
      className: "wallie-bg-ord-orange wallie-rounded-full wallie-flex wallie-flex-row md:wallie-space-x-2 wallie-items-center wallie-p-1 wallie-pr-2 wallie-px-1 md:wallie-pr-3 md:wallie-px-3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallie-w-6 md:wallie-w-7", src: WalletIcon, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-hidden md:wallie-block wallie-text-ord-blue wallie-mb-1 wallie-pr-2", children: J })
      ]
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='19'%20height='19'%20viewBox='0%200%2019%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.07844%204.07811C4.25659%203.90001%204.49818%203.79996%204.75009%203.79996C5.002%203.79996%205.24359%203.90001%205.42174%204.07811L9.50009%208.15646L13.5784%204.07811C13.6661%203.98738%2013.7709%203.915%2013.8868%203.86521C14.0027%203.81542%2014.1274%203.78922%2014.2535%203.78812C14.3796%203.78703%2014.5047%203.81106%2014.6215%203.85883C14.7382%203.9066%2014.8443%203.97714%2014.9335%204.06633C15.0227%204.15553%2015.0933%204.2616%2015.141%204.37835C15.1888%204.4951%2015.2128%204.6202%2015.2117%204.74634C15.2106%204.87248%2015.1844%204.99714%2015.1346%205.11304C15.0848%205.22895%2015.0125%205.33378%2014.9217%205.42141L10.8434%209.49976L14.9217%2013.5781C15.0948%2013.7573%2015.1905%2013.9973%2015.1884%2014.2463C15.1862%2014.4954%2015.0863%2014.7337%2014.9102%2014.9098C14.734%2015.086%2014.4958%2015.1859%2014.2467%2015.1881C13.9976%2015.1902%2013.7576%2015.0945%2013.5784%2014.9214L9.50009%2010.8431L5.42174%2014.9214C5.24257%2015.0945%205.0026%2015.1902%204.75351%2015.1881C4.50442%2015.1859%204.26615%2015.086%204.09001%2014.9098C3.91387%2014.7337%203.81396%2014.4954%203.8118%2014.2463C3.80964%2013.9973%203.90539%2013.7573%204.07844%2013.5781L8.15679%209.49976L4.07844%205.42141C3.90034%205.24326%203.80029%205.00167%203.80029%204.74976C3.80029%204.49785%203.90034%204.25626%204.07844%204.07811Z'%20fill='%23D9D5D2'/%3e%3c/svg%3e";
var __classPrivateFieldSet = function(B, L, J, ne, oe) {
  if (ne === "m") throw new TypeError("Private method is not writable");
  if (ne === "a" && !oe) throw new TypeError("Private accessor was defined without a setter");
  if (typeof L == "function" ? B !== L || !oe : !L.has(B)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return ne === "a" ? oe.call(B, J) : oe ? oe.value = J : L.set(B, J), J;
}, __classPrivateFieldGet = function(B, L, J, ne) {
  if (J === "a" && !ne) throw new TypeError("Private accessor was defined without a getter");
  if (typeof L == "function" ? B !== L || !ne : !L.has(B)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return J === "m" ? ne : J === "a" ? ne.call(B) : ne ? ne.value : L.get(B);
}, _AppReadyEvent_detail;
let wallets;
const registered = /* @__PURE__ */ new Set(), listeners = {};
function getWallets() {
  if (wallets || (wallets = Object.freeze({ register, get, on }), typeof window > "u"))
    return wallets;
  const B = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: L }) => L(B));
  } catch (L) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, L);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(B));
  } catch (L) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, L);
  }
  return wallets;
}
function register(...B) {
  var L;
  return B = B.filter((J) => !registered.has(J)), B.length ? (B.forEach((J) => registered.add(J)), (L = listeners.register) == null || L.forEach((J) => guard(() => J(...B))), function() {
    var ne;
    B.forEach((oe) => registered.delete(oe)), (ne = listeners.unregister) == null || ne.forEach((oe) => guard(() => oe(...B)));
  }) : () => {
  };
}
function get() {
  return [...registered];
}
function on(B, L) {
  var J;
  return (J = listeners[B]) != null && J.push(L) || (listeners[B] = [L]), function() {
    var oe;
    listeners[B] = (oe = listeners[B]) == null ? void 0 : oe.filter((ce) => L !== ce);
  };
}
function guard(B) {
  try {
    B();
  } catch (L) {
    console.error(L);
  }
}
class AppReadyEvent extends Event {
  constructor(L) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), _AppReadyEvent_detail.set(this, void 0), __classPrivateFieldSet(this, _AppReadyEvent_detail, L, "f");
  }
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();
class BrowserWalletExtractTxFromNonFinalizedPsbtError extends Error {
  constructor(L = "Cannot extract transaction from non-finalized psbt.") {
    super(L), this.name = "BrowserWalletExtractTxFromNonFinalizedPsbtError";
  }
}
class BrowserWalletNetworkMismatchError extends Error {
  constructor(L) {
    super(L), this.name = "BrowserWalletNetworkMismatchError";
  }
}
class BrowserWalletNotInstalledError extends Error {
  constructor(L) {
    super(L), this.name = "BrowserWalletNotInstalledError";
  }
}
class BrowserWalletRequestCancelledByUserError extends Error {
  constructor(L = "Request canceled by user.") {
    super(L), this.name = "BrowserWalletRequestCancelledByUserError";
  }
}
class BrowserWalletSigningError extends Error {
  constructor(L) {
    super(L), this.name = "BrowserWalletSigningError";
  }
}
class OrditSDKError extends Error {
  constructor(L) {
    super(L), this.name = "OrditSDKError";
  }
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var L = B.length;
  if (L % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var J = B.indexOf("=");
  J === -1 && (J = L);
  var ne = J === L ? 0 : 4 - J % 4;
  return [J, ne];
}
function byteLength$1(B) {
  var L = getLens$1(B), J = L[0], ne = L[1];
  return (J + ne) * 3 / 4 - ne;
}
function _byteLength$1(B, L, J) {
  return (L + J) * 3 / 4 - J;
}
function toByteArray$1(B) {
  var L, J = getLens$1(B), ne = J[0], oe = J[1], ce = new Arr$1(_byteLength$1(B, ne, oe)), Ce = 0, rt = oe > 0 ? ne - 4 : ne, at;
  for (at = 0; at < rt; at += 4)
    L = revLookup$1[B.charCodeAt(at)] << 18 | revLookup$1[B.charCodeAt(at + 1)] << 12 | revLookup$1[B.charCodeAt(at + 2)] << 6 | revLookup$1[B.charCodeAt(at + 3)], ce[Ce++] = L >> 16 & 255, ce[Ce++] = L >> 8 & 255, ce[Ce++] = L & 255;
  return oe === 2 && (L = revLookup$1[B.charCodeAt(at)] << 2 | revLookup$1[B.charCodeAt(at + 1)] >> 4, ce[Ce++] = L & 255), oe === 1 && (L = revLookup$1[B.charCodeAt(at)] << 10 | revLookup$1[B.charCodeAt(at + 1)] << 4 | revLookup$1[B.charCodeAt(at + 2)] >> 2, ce[Ce++] = L >> 8 & 255, ce[Ce++] = L & 255), ce;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, L, J) {
  for (var ne, oe = [], ce = L; ce < J; ce += 3)
    ne = (B[ce] << 16 & 16711680) + (B[ce + 1] << 8 & 65280) + (B[ce + 2] & 255), oe.push(tripletToBase64$1(ne));
  return oe.join("");
}
function fromByteArray$1(B) {
  for (var L, J = B.length, ne = J % 3, oe = [], ce = 16383, Ce = 0, rt = J - ne; Ce < rt; Ce += ce)
    oe.push(encodeChunk$1(B, Ce, Ce + ce > rt ? rt : Ce + ce));
  return ne === 1 ? (L = B[J - 1], oe.push(
    lookup$1[L >> 2] + lookup$1[L << 4 & 63] + "=="
  )) : ne === 2 && (L = (B[J - 2] << 8) + B[J - 1], oe.push(
    lookup$1[L >> 10] + lookup$1[L >> 4 & 63] + lookup$1[L << 2 & 63] + "="
  )), oe.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, L, J, ne, oe) {
  var ce, Ce, rt = oe * 8 - ne - 1, at = (1 << rt) - 1, ht = at >> 1, it = -7, lt = J ? oe - 1 : 0, Et = J ? -1 : 1, wt = B[L + lt];
  for (lt += Et, ce = wt & (1 << -it) - 1, wt >>= -it, it += rt; it > 0; ce = ce * 256 + B[L + lt], lt += Et, it -= 8)
    ;
  for (Ce = ce & (1 << -it) - 1, ce >>= -it, it += ne; it > 0; Ce = Ce * 256 + B[L + lt], lt += Et, it -= 8)
    ;
  if (ce === 0)
    ce = 1 - ht;
  else {
    if (ce === at)
      return Ce ? NaN : (wt ? -1 : 1) * (1 / 0);
    Ce = Ce + Math.pow(2, ne), ce = ce - ht;
  }
  return (wt ? -1 : 1) * Ce * Math.pow(2, ce - ne);
};
ieee754.write = function(B, L, J, ne, oe, ce) {
  var Ce, rt, at, ht = ce * 8 - oe - 1, it = (1 << ht) - 1, lt = it >> 1, Et = oe === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, wt = ne ? 0 : ce - 1, Rt = ne ? 1 : -1, Mt = L < 0 || L === 0 && 1 / L < 0 ? 1 : 0;
  for (L = Math.abs(L), isNaN(L) || L === 1 / 0 ? (rt = isNaN(L) ? 1 : 0, Ce = it) : (Ce = Math.floor(Math.log(L) / Math.LN2), L * (at = Math.pow(2, -Ce)) < 1 && (Ce--, at *= 2), Ce + lt >= 1 ? L += Et / at : L += Et * Math.pow(2, 1 - lt), L * at >= 2 && (Ce++, at /= 2), Ce + lt >= it ? (rt = 0, Ce = it) : Ce + lt >= 1 ? (rt = (L * at - 1) * Math.pow(2, oe), Ce = Ce + lt) : (rt = L * Math.pow(2, lt - 1) * Math.pow(2, oe), Ce = 0)); oe >= 8; B[J + wt] = rt & 255, wt += Rt, rt /= 256, oe -= 8)
    ;
  for (Ce = Ce << oe | rt, ht += oe; ht > 0; B[J + wt] = Ce & 255, wt += Rt, Ce /= 256, ht -= 8)
    ;
  B[J + wt - Rt] |= Mt * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const L = base64Js$1, J = ieee754, ne = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = it, B.SlowBuffer = Jt, B.INSPECT_MAX_BYTES = 50;
  const oe = 2147483647;
  B.kMaxLength = oe;
  const { Uint8Array: ce, ArrayBuffer: Ce, SharedArrayBuffer: rt } = globalThis;
  it.TYPED_ARRAY_SUPPORT = at(), !it.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function at() {
    try {
      const Gt = new ce(1), At = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(At, ce.prototype), Object.setPrototypeOf(Gt, At), Gt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(it.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (it.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(it.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (it.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ht(Gt) {
    if (Gt > oe)
      throw new RangeError('The value "' + Gt + '" is invalid for option "size"');
    const At = new ce(Gt);
    return Object.setPrototypeOf(At, it.prototype), At;
  }
  function it(Gt, At, kt) {
    if (typeof Gt == "number") {
      if (typeof At == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Rt(Gt);
    }
    return lt(Gt, At, kt);
  }
  it.poolSize = 8192;
  function lt(Gt, At, kt) {
    if (typeof Gt == "string")
      return Mt(Gt, At);
    if (Ce.isView(Gt))
      return zt(Gt);
    if (Gt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Gt
      );
    if (Pn(Gt, Ce) || Gt && Pn(Gt.buffer, Ce) || typeof rt < "u" && (Pn(Gt, rt) || Gt && Pn(Gt.buffer, rt)))
      return Ot(Gt, At, kt);
    if (typeof Gt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Zt = Gt.valueOf && Gt.valueOf();
    if (Zt != null && Zt !== Gt)
      return it.from(Zt, At, kt);
    const pr = It(Gt);
    if (pr) return pr;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Gt[Symbol.toPrimitive] == "function")
      return it.from(Gt[Symbol.toPrimitive]("string"), At, kt);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Gt
    );
  }
  it.from = function(Gt, At, kt) {
    return lt(Gt, At, kt);
  }, Object.setPrototypeOf(it.prototype, ce.prototype), Object.setPrototypeOf(it, ce);
  function Et(Gt) {
    if (typeof Gt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Gt < 0)
      throw new RangeError('The value "' + Gt + '" is invalid for option "size"');
  }
  function wt(Gt, At, kt) {
    return Et(Gt), Gt <= 0 ? ht(Gt) : At !== void 0 ? typeof kt == "string" ? ht(Gt).fill(At, kt) : ht(Gt).fill(At) : ht(Gt);
  }
  it.alloc = function(Gt, At, kt) {
    return wt(Gt, At, kt);
  };
  function Rt(Gt) {
    return Et(Gt), ht(Gt < 0 ? 0 : Ft(Gt) | 0);
  }
  it.allocUnsafe = function(Gt) {
    return Rt(Gt);
  }, it.allocUnsafeSlow = function(Gt) {
    return Rt(Gt);
  };
  function Mt(Gt, At) {
    if ((typeof At != "string" || At === "") && (At = "utf8"), !it.isEncoding(At))
      throw new TypeError("Unknown encoding: " + At);
    const kt = Vt(Gt, At) | 0;
    let Zt = ht(kt);
    const pr = Zt.write(Gt, At);
    return pr !== kt && (Zt = Zt.slice(0, pr)), Zt;
  }
  function Lt(Gt) {
    const At = Gt.length < 0 ? 0 : Ft(Gt.length) | 0, kt = ht(At);
    for (let Zt = 0; Zt < At; Zt += 1)
      kt[Zt] = Gt[Zt] & 255;
    return kt;
  }
  function zt(Gt) {
    if (Pn(Gt, ce)) {
      const At = new ce(Gt);
      return Ot(At.buffer, At.byteOffset, At.byteLength);
    }
    return Lt(Gt);
  }
  function Ot(Gt, At, kt) {
    if (At < 0 || Gt.byteLength < At)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Gt.byteLength < At + (kt || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Zt;
    return At === void 0 && kt === void 0 ? Zt = new ce(Gt) : kt === void 0 ? Zt = new ce(Gt, At) : Zt = new ce(Gt, At, kt), Object.setPrototypeOf(Zt, it.prototype), Zt;
  }
  function It(Gt) {
    if (it.isBuffer(Gt)) {
      const At = Ft(Gt.length) | 0, kt = ht(At);
      return kt.length === 0 || Gt.copy(kt, 0, 0, At), kt;
    }
    if (Gt.length !== void 0)
      return typeof Gt.length != "number" || ti(Gt.length) ? ht(0) : Lt(Gt);
    if (Gt.type === "Buffer" && Array.isArray(Gt.data))
      return Lt(Gt.data);
  }
  function Ft(Gt) {
    if (Gt >= oe)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + oe.toString(16) + " bytes");
    return Gt | 0;
  }
  function Jt(Gt) {
    return +Gt != Gt && (Gt = 0), it.alloc(+Gt);
  }
  it.isBuffer = function(At) {
    return At != null && At._isBuffer === !0 && At !== it.prototype;
  }, it.compare = function(At, kt) {
    if (Pn(At, ce) && (At = it.from(At, At.offset, At.byteLength)), Pn(kt, ce) && (kt = it.from(kt, kt.offset, kt.byteLength)), !it.isBuffer(At) || !it.isBuffer(kt))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (At === kt) return 0;
    let Zt = At.length, pr = kt.length;
    for (let Sr = 0, Tr = Math.min(Zt, pr); Sr < Tr; ++Sr)
      if (At[Sr] !== kt[Sr]) {
        Zt = At[Sr], pr = kt[Sr];
        break;
      }
    return Zt < pr ? -1 : pr < Zt ? 1 : 0;
  }, it.isEncoding = function(At) {
    switch (String(At).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, it.concat = function(At, kt) {
    if (!Array.isArray(At))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (At.length === 0)
      return it.alloc(0);
    let Zt;
    if (kt === void 0)
      for (kt = 0, Zt = 0; Zt < At.length; ++Zt)
        kt += At[Zt].length;
    const pr = it.allocUnsafe(kt);
    let Sr = 0;
    for (Zt = 0; Zt < At.length; ++Zt) {
      let Tr = At[Zt];
      if (Pn(Tr, ce))
        Sr + Tr.length > pr.length ? (it.isBuffer(Tr) || (Tr = it.from(Tr)), Tr.copy(pr, Sr)) : ce.prototype.set.call(
          pr,
          Tr,
          Sr
        );
      else if (it.isBuffer(Tr))
        Tr.copy(pr, Sr);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Sr += Tr.length;
    }
    return pr;
  };
  function Vt(Gt, At) {
    if (it.isBuffer(Gt))
      return Gt.length;
    if (Ce.isView(Gt) || Pn(Gt, Ce))
      return Gt.byteLength;
    if (typeof Gt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Gt
      );
    const kt = Gt.length, Zt = arguments.length > 2 && arguments[2] === !0;
    if (!Zt && kt === 0) return 0;
    let pr = !1;
    for (; ; )
      switch (At) {
        case "ascii":
        case "latin1":
        case "binary":
          return kt;
        case "utf8":
        case "utf-8":
          return Wn(Gt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return kt * 2;
        case "hex":
          return kt >>> 1;
        case "base64":
          return Gn(Gt).length;
        default:
          if (pr)
            return Zt ? -1 : Wn(Gt).length;
          At = ("" + At).toLowerCase(), pr = !0;
      }
  }
  it.byteLength = Vt;
  function yr(Gt, At, kt) {
    let Zt = !1;
    if ((At === void 0 || At < 0) && (At = 0), At > this.length || ((kt === void 0 || kt > this.length) && (kt = this.length), kt <= 0) || (kt >>>= 0, At >>>= 0, kt <= At))
      return "";
    for (Gt || (Gt = "utf8"); ; )
      switch (Gt) {
        case "hex":
          return yt(this, At, kt);
        case "utf8":
        case "utf-8":
          return gt(this, At, kt);
        case "ascii":
          return vt(this, At, kt);
        case "latin1":
        case "binary":
          return $t(this, At, kt);
        case "base64":
          return mt(this, At, kt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Bt(this, At, kt);
        default:
          if (Zt) throw new TypeError("Unknown encoding: " + Gt);
          Gt = (Gt + "").toLowerCase(), Zt = !0;
      }
  }
  it.prototype._isBuffer = !0;
  function jt(Gt, At, kt) {
    const Zt = Gt[At];
    Gt[At] = Gt[kt], Gt[kt] = Zt;
  }
  it.prototype.swap16 = function() {
    const At = this.length;
    if (At % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let kt = 0; kt < At; kt += 2)
      jt(this, kt, kt + 1);
    return this;
  }, it.prototype.swap32 = function() {
    const At = this.length;
    if (At % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let kt = 0; kt < At; kt += 4)
      jt(this, kt, kt + 3), jt(this, kt + 1, kt + 2);
    return this;
  }, it.prototype.swap64 = function() {
    const At = this.length;
    if (At % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let kt = 0; kt < At; kt += 8)
      jt(this, kt, kt + 7), jt(this, kt + 1, kt + 6), jt(this, kt + 2, kt + 5), jt(this, kt + 3, kt + 4);
    return this;
  }, it.prototype.toString = function() {
    const At = this.length;
    return At === 0 ? "" : arguments.length === 0 ? gt(this, 0, At) : yr.apply(this, arguments);
  }, it.prototype.toLocaleString = it.prototype.toString, it.prototype.equals = function(At) {
    if (!it.isBuffer(At)) throw new TypeError("Argument must be a Buffer");
    return this === At ? !0 : it.compare(this, At) === 0;
  }, it.prototype.inspect = function() {
    let At = "";
    const kt = B.INSPECT_MAX_BYTES;
    return At = this.toString("hex", 0, kt).replace(/(.{2})/g, "$1 ").trim(), this.length > kt && (At += " ... "), "<Buffer " + At + ">";
  }, ne && (it.prototype[ne] = it.prototype.inspect), it.prototype.compare = function(At, kt, Zt, pr, Sr) {
    if (Pn(At, ce) && (At = it.from(At, At.offset, At.byteLength)), !it.isBuffer(At))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof At
      );
    if (kt === void 0 && (kt = 0), Zt === void 0 && (Zt = At ? At.length : 0), pr === void 0 && (pr = 0), Sr === void 0 && (Sr = this.length), kt < 0 || Zt > At.length || pr < 0 || Sr > this.length)
      throw new RangeError("out of range index");
    if (pr >= Sr && kt >= Zt)
      return 0;
    if (pr >= Sr)
      return -1;
    if (kt >= Zt)
      return 1;
    if (kt >>>= 0, Zt >>>= 0, pr >>>= 0, Sr >>>= 0, this === At) return 0;
    let Tr = Sr - pr, fn = Zt - kt;
    const On = Math.min(Tr, fn), tn = this.slice(pr, Sr), In = At.slice(kt, Zt);
    for (let hn = 0; hn < On; ++hn)
      if (tn[hn] !== In[hn]) {
        Tr = tn[hn], fn = In[hn];
        break;
      }
    return Tr < fn ? -1 : fn < Tr ? 1 : 0;
  };
  function Ut(Gt, At, kt, Zt, pr) {
    if (Gt.length === 0) return -1;
    if (typeof kt == "string" ? (Zt = kt, kt = 0) : kt > 2147483647 ? kt = 2147483647 : kt < -2147483648 && (kt = -2147483648), kt = +kt, ti(kt) && (kt = pr ? 0 : Gt.length - 1), kt < 0 && (kt = Gt.length + kt), kt >= Gt.length) {
      if (pr) return -1;
      kt = Gt.length - 1;
    } else if (kt < 0)
      if (pr) kt = 0;
      else return -1;
    if (typeof At == "string" && (At = it.from(At, Zt)), it.isBuffer(At))
      return At.length === 0 ? -1 : er(Gt, At, kt, Zt, pr);
    if (typeof At == "number")
      return At = At & 255, typeof ce.prototype.indexOf == "function" ? pr ? ce.prototype.indexOf.call(Gt, At, kt) : ce.prototype.lastIndexOf.call(Gt, At, kt) : er(Gt, [At], kt, Zt, pr);
    throw new TypeError("val must be string, number or Buffer");
  }
  function er(Gt, At, kt, Zt, pr) {
    let Sr = 1, Tr = Gt.length, fn = At.length;
    if (Zt !== void 0 && (Zt = String(Zt).toLowerCase(), Zt === "ucs2" || Zt === "ucs-2" || Zt === "utf16le" || Zt === "utf-16le")) {
      if (Gt.length < 2 || At.length < 2)
        return -1;
      Sr = 2, Tr /= 2, fn /= 2, kt /= 2;
    }
    function On(In, hn) {
      return Sr === 1 ? In[hn] : In.readUInt16BE(hn * Sr);
    }
    let tn;
    if (pr) {
      let In = -1;
      for (tn = kt; tn < Tr; tn++)
        if (On(Gt, tn) === On(At, In === -1 ? 0 : tn - In)) {
          if (In === -1 && (In = tn), tn - In + 1 === fn) return In * Sr;
        } else
          In !== -1 && (tn -= tn - In), In = -1;
    } else
      for (kt + fn > Tr && (kt = Tr - fn), tn = kt; tn >= 0; tn--) {
        let In = !0;
        for (let hn = 0; hn < fn; hn++)
          if (On(Gt, tn + hn) !== On(At, hn)) {
            In = !1;
            break;
          }
        if (In) return tn;
      }
    return -1;
  }
  it.prototype.includes = function(At, kt, Zt) {
    return this.indexOf(At, kt, Zt) !== -1;
  }, it.prototype.indexOf = function(At, kt, Zt) {
    return Ut(this, At, kt, Zt, !0);
  }, it.prototype.lastIndexOf = function(At, kt, Zt) {
    return Ut(this, At, kt, Zt, !1);
  };
  function Ht(Gt, At, kt, Zt) {
    kt = Number(kt) || 0;
    const pr = Gt.length - kt;
    Zt ? (Zt = Number(Zt), Zt > pr && (Zt = pr)) : Zt = pr;
    const Sr = At.length;
    Zt > Sr / 2 && (Zt = Sr / 2);
    let Tr;
    for (Tr = 0; Tr < Zt; ++Tr) {
      const fn = parseInt(At.substr(Tr * 2, 2), 16);
      if (ti(fn)) return Tr;
      Gt[kt + Tr] = fn;
    }
    return Tr;
  }
  function ct(Gt, At, kt, Zt) {
    return En(Wn(At, Gt.length - kt), Gt, kt, Zt);
  }
  function dt(Gt, At, kt, Zt) {
    return En(xn(At), Gt, kt, Zt);
  }
  function ot(Gt, At, kt, Zt) {
    return En(Gn(At), Gt, kt, Zt);
  }
  function ut(Gt, At, kt, Zt) {
    return En(ni(At, Gt.length - kt), Gt, kt, Zt);
  }
  it.prototype.write = function(At, kt, Zt, pr) {
    if (kt === void 0)
      pr = "utf8", Zt = this.length, kt = 0;
    else if (Zt === void 0 && typeof kt == "string")
      pr = kt, Zt = this.length, kt = 0;
    else if (isFinite(kt))
      kt = kt >>> 0, isFinite(Zt) ? (Zt = Zt >>> 0, pr === void 0 && (pr = "utf8")) : (pr = Zt, Zt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Sr = this.length - kt;
    if ((Zt === void 0 || Zt > Sr) && (Zt = Sr), At.length > 0 && (Zt < 0 || kt < 0) || kt > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    pr || (pr = "utf8");
    let Tr = !1;
    for (; ; )
      switch (pr) {
        case "hex":
          return Ht(this, At, kt, Zt);
        case "utf8":
        case "utf-8":
          return ct(this, At, kt, Zt);
        case "ascii":
        case "latin1":
        case "binary":
          return dt(this, At, kt, Zt);
        case "base64":
          return ot(this, At, kt, Zt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ut(this, At, kt, Zt);
        default:
          if (Tr) throw new TypeError("Unknown encoding: " + pr);
          pr = ("" + pr).toLowerCase(), Tr = !0;
      }
  }, it.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function mt(Gt, At, kt) {
    return At === 0 && kt === Gt.length ? L.fromByteArray(Gt) : L.fromByteArray(Gt.slice(At, kt));
  }
  function gt(Gt, At, kt) {
    kt = Math.min(Gt.length, kt);
    const Zt = [];
    let pr = At;
    for (; pr < kt; ) {
      const Sr = Gt[pr];
      let Tr = null, fn = Sr > 239 ? 4 : Sr > 223 ? 3 : Sr > 191 ? 2 : 1;
      if (pr + fn <= kt) {
        let On, tn, In, hn;
        switch (fn) {
          case 1:
            Sr < 128 && (Tr = Sr);
            break;
          case 2:
            On = Gt[pr + 1], (On & 192) === 128 && (hn = (Sr & 31) << 6 | On & 63, hn > 127 && (Tr = hn));
            break;
          case 3:
            On = Gt[pr + 1], tn = Gt[pr + 2], (On & 192) === 128 && (tn & 192) === 128 && (hn = (Sr & 15) << 12 | (On & 63) << 6 | tn & 63, hn > 2047 && (hn < 55296 || hn > 57343) && (Tr = hn));
            break;
          case 4:
            On = Gt[pr + 1], tn = Gt[pr + 2], In = Gt[pr + 3], (On & 192) === 128 && (tn & 192) === 128 && (In & 192) === 128 && (hn = (Sr & 15) << 18 | (On & 63) << 12 | (tn & 63) << 6 | In & 63, hn > 65535 && hn < 1114112 && (Tr = hn));
        }
      }
      Tr === null ? (Tr = 65533, fn = 1) : Tr > 65535 && (Tr -= 65536, Zt.push(Tr >>> 10 & 1023 | 55296), Tr = 56320 | Tr & 1023), Zt.push(Tr), pr += fn;
    }
    return xt(Zt);
  }
  const St = 4096;
  function xt(Gt) {
    const At = Gt.length;
    if (At <= St)
      return String.fromCharCode.apply(String, Gt);
    let kt = "", Zt = 0;
    for (; Zt < At; )
      kt += String.fromCharCode.apply(
        String,
        Gt.slice(Zt, Zt += St)
      );
    return kt;
  }
  function vt(Gt, At, kt) {
    let Zt = "";
    kt = Math.min(Gt.length, kt);
    for (let pr = At; pr < kt; ++pr)
      Zt += String.fromCharCode(Gt[pr] & 127);
    return Zt;
  }
  function $t(Gt, At, kt) {
    let Zt = "";
    kt = Math.min(Gt.length, kt);
    for (let pr = At; pr < kt; ++pr)
      Zt += String.fromCharCode(Gt[pr]);
    return Zt;
  }
  function yt(Gt, At, kt) {
    const Zt = Gt.length;
    (!At || At < 0) && (At = 0), (!kt || kt < 0 || kt > Zt) && (kt = Zt);
    let pr = "";
    for (let Sr = At; Sr < kt; ++Sr)
      pr += gn[Gt[Sr]];
    return pr;
  }
  function Bt(Gt, At, kt) {
    const Zt = Gt.slice(At, kt);
    let pr = "";
    for (let Sr = 0; Sr < Zt.length - 1; Sr += 2)
      pr += String.fromCharCode(Zt[Sr] + Zt[Sr + 1] * 256);
    return pr;
  }
  it.prototype.slice = function(At, kt) {
    const Zt = this.length;
    At = ~~At, kt = kt === void 0 ? Zt : ~~kt, At < 0 ? (At += Zt, At < 0 && (At = 0)) : At > Zt && (At = Zt), kt < 0 ? (kt += Zt, kt < 0 && (kt = 0)) : kt > Zt && (kt = Zt), kt < At && (kt = At);
    const pr = this.subarray(At, kt);
    return Object.setPrototypeOf(pr, it.prototype), pr;
  };
  function rr(Gt, At, kt) {
    if (Gt % 1 !== 0 || Gt < 0) throw new RangeError("offset is not uint");
    if (Gt + At > kt) throw new RangeError("Trying to access beyond buffer length");
  }
  it.prototype.readUintLE = it.prototype.readUIntLE = function(At, kt, Zt) {
    At = At >>> 0, kt = kt >>> 0, Zt || rr(At, kt, this.length);
    let pr = this[At], Sr = 1, Tr = 0;
    for (; ++Tr < kt && (Sr *= 256); )
      pr += this[At + Tr] * Sr;
    return pr;
  }, it.prototype.readUintBE = it.prototype.readUIntBE = function(At, kt, Zt) {
    At = At >>> 0, kt = kt >>> 0, Zt || rr(At, kt, this.length);
    let pr = this[At + --kt], Sr = 1;
    for (; kt > 0 && (Sr *= 256); )
      pr += this[At + --kt] * Sr;
    return pr;
  }, it.prototype.readUint8 = it.prototype.readUInt8 = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 1, this.length), this[At];
  }, it.prototype.readUint16LE = it.prototype.readUInt16LE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 2, this.length), this[At] | this[At + 1] << 8;
  }, it.prototype.readUint16BE = it.prototype.readUInt16BE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 2, this.length), this[At] << 8 | this[At + 1];
  }, it.prototype.readUint32LE = it.prototype.readUInt32LE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 4, this.length), (this[At] | this[At + 1] << 8 | this[At + 2] << 16) + this[At + 3] * 16777216;
  }, it.prototype.readUint32BE = it.prototype.readUInt32BE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 4, this.length), this[At] * 16777216 + (this[At + 1] << 16 | this[At + 2] << 8 | this[At + 3]);
  }, it.prototype.readBigUInt64LE = Kn(function(At) {
    At = At >>> 0, Zr(At, "offset");
    const kt = this[At], Zt = this[At + 7];
    (kt === void 0 || Zt === void 0) && ln(At, this.length - 8);
    const pr = kt + this[++At] * 2 ** 8 + this[++At] * 2 ** 16 + this[++At] * 2 ** 24, Sr = this[++At] + this[++At] * 2 ** 8 + this[++At] * 2 ** 16 + Zt * 2 ** 24;
    return BigInt(pr) + (BigInt(Sr) << BigInt(32));
  }), it.prototype.readBigUInt64BE = Kn(function(At) {
    At = At >>> 0, Zr(At, "offset");
    const kt = this[At], Zt = this[At + 7];
    (kt === void 0 || Zt === void 0) && ln(At, this.length - 8);
    const pr = kt * 2 ** 24 + this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + this[++At], Sr = this[++At] * 2 ** 24 + this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + Zt;
    return (BigInt(pr) << BigInt(32)) + BigInt(Sr);
  }), it.prototype.readIntLE = function(At, kt, Zt) {
    At = At >>> 0, kt = kt >>> 0, Zt || rr(At, kt, this.length);
    let pr = this[At], Sr = 1, Tr = 0;
    for (; ++Tr < kt && (Sr *= 256); )
      pr += this[At + Tr] * Sr;
    return Sr *= 128, pr >= Sr && (pr -= Math.pow(2, 8 * kt)), pr;
  }, it.prototype.readIntBE = function(At, kt, Zt) {
    At = At >>> 0, kt = kt >>> 0, Zt || rr(At, kt, this.length);
    let pr = kt, Sr = 1, Tr = this[At + --pr];
    for (; pr > 0 && (Sr *= 256); )
      Tr += this[At + --pr] * Sr;
    return Sr *= 128, Tr >= Sr && (Tr -= Math.pow(2, 8 * kt)), Tr;
  }, it.prototype.readInt8 = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 1, this.length), this[At] & 128 ? (255 - this[At] + 1) * -1 : this[At];
  }, it.prototype.readInt16LE = function(At, kt) {
    At = At >>> 0, kt || rr(At, 2, this.length);
    const Zt = this[At] | this[At + 1] << 8;
    return Zt & 32768 ? Zt | 4294901760 : Zt;
  }, it.prototype.readInt16BE = function(At, kt) {
    At = At >>> 0, kt || rr(At, 2, this.length);
    const Zt = this[At + 1] | this[At] << 8;
    return Zt & 32768 ? Zt | 4294901760 : Zt;
  }, it.prototype.readInt32LE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 4, this.length), this[At] | this[At + 1] << 8 | this[At + 2] << 16 | this[At + 3] << 24;
  }, it.prototype.readInt32BE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 4, this.length), this[At] << 24 | this[At + 1] << 16 | this[At + 2] << 8 | this[At + 3];
  }, it.prototype.readBigInt64LE = Kn(function(At) {
    At = At >>> 0, Zr(At, "offset");
    const kt = this[At], Zt = this[At + 7];
    (kt === void 0 || Zt === void 0) && ln(At, this.length - 8);
    const pr = this[At + 4] + this[At + 5] * 2 ** 8 + this[At + 6] * 2 ** 16 + (Zt << 24);
    return (BigInt(pr) << BigInt(32)) + BigInt(kt + this[++At] * 2 ** 8 + this[++At] * 2 ** 16 + this[++At] * 2 ** 24);
  }), it.prototype.readBigInt64BE = Kn(function(At) {
    At = At >>> 0, Zr(At, "offset");
    const kt = this[At], Zt = this[At + 7];
    (kt === void 0 || Zt === void 0) && ln(At, this.length - 8);
    const pr = (kt << 24) + // Overflow
    this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + this[++At];
    return (BigInt(pr) << BigInt(32)) + BigInt(this[++At] * 2 ** 24 + this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + Zt);
  }), it.prototype.readFloatLE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 4, this.length), J.read(this, At, !0, 23, 4);
  }, it.prototype.readFloatBE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 4, this.length), J.read(this, At, !1, 23, 4);
  }, it.prototype.readDoubleLE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 8, this.length), J.read(this, At, !0, 52, 8);
  }, it.prototype.readDoubleBE = function(At, kt) {
    return At = At >>> 0, kt || rr(At, 8, this.length), J.read(this, At, !1, 52, 8);
  };
  function dr(Gt, At, kt, Zt, pr, Sr) {
    if (!it.isBuffer(Gt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (At > pr || At < Sr) throw new RangeError('"value" argument is out of bounds');
    if (kt + Zt > Gt.length) throw new RangeError("Index out of range");
  }
  it.prototype.writeUintLE = it.prototype.writeUIntLE = function(At, kt, Zt, pr) {
    if (At = +At, kt = kt >>> 0, Zt = Zt >>> 0, !pr) {
      const fn = Math.pow(2, 8 * Zt) - 1;
      dr(this, At, kt, Zt, fn, 0);
    }
    let Sr = 1, Tr = 0;
    for (this[kt] = At & 255; ++Tr < Zt && (Sr *= 256); )
      this[kt + Tr] = At / Sr & 255;
    return kt + Zt;
  }, it.prototype.writeUintBE = it.prototype.writeUIntBE = function(At, kt, Zt, pr) {
    if (At = +At, kt = kt >>> 0, Zt = Zt >>> 0, !pr) {
      const fn = Math.pow(2, 8 * Zt) - 1;
      dr(this, At, kt, Zt, fn, 0);
    }
    let Sr = Zt - 1, Tr = 1;
    for (this[kt + Sr] = At & 255; --Sr >= 0 && (Tr *= 256); )
      this[kt + Sr] = At / Tr & 255;
    return kt + Zt;
  }, it.prototype.writeUint8 = it.prototype.writeUInt8 = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 1, 255, 0), this[kt] = At & 255, kt + 1;
  }, it.prototype.writeUint16LE = it.prototype.writeUInt16LE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 2, 65535, 0), this[kt] = At & 255, this[kt + 1] = At >>> 8, kt + 2;
  }, it.prototype.writeUint16BE = it.prototype.writeUInt16BE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 2, 65535, 0), this[kt] = At >>> 8, this[kt + 1] = At & 255, kt + 2;
  }, it.prototype.writeUint32LE = it.prototype.writeUInt32LE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 4, 4294967295, 0), this[kt + 3] = At >>> 24, this[kt + 2] = At >>> 16, this[kt + 1] = At >>> 8, this[kt] = At & 255, kt + 4;
  }, it.prototype.writeUint32BE = it.prototype.writeUInt32BE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 4, 4294967295, 0), this[kt] = At >>> 24, this[kt + 1] = At >>> 16, this[kt + 2] = At >>> 8, this[kt + 3] = At & 255, kt + 4;
  };
  function tr(Gt, At, kt, Zt, pr) {
    Vr(At, Zt, pr, Gt, kt, 7);
    let Sr = Number(At & BigInt(4294967295));
    Gt[kt++] = Sr, Sr = Sr >> 8, Gt[kt++] = Sr, Sr = Sr >> 8, Gt[kt++] = Sr, Sr = Sr >> 8, Gt[kt++] = Sr;
    let Tr = Number(At >> BigInt(32) & BigInt(4294967295));
    return Gt[kt++] = Tr, Tr = Tr >> 8, Gt[kt++] = Tr, Tr = Tr >> 8, Gt[kt++] = Tr, Tr = Tr >> 8, Gt[kt++] = Tr, kt;
  }
  function Dt(Gt, At, kt, Zt, pr) {
    Vr(At, Zt, pr, Gt, kt, 7);
    let Sr = Number(At & BigInt(4294967295));
    Gt[kt + 7] = Sr, Sr = Sr >> 8, Gt[kt + 6] = Sr, Sr = Sr >> 8, Gt[kt + 5] = Sr, Sr = Sr >> 8, Gt[kt + 4] = Sr;
    let Tr = Number(At >> BigInt(32) & BigInt(4294967295));
    return Gt[kt + 3] = Tr, Tr = Tr >> 8, Gt[kt + 2] = Tr, Tr = Tr >> 8, Gt[kt + 1] = Tr, Tr = Tr >> 8, Gt[kt] = Tr, kt + 8;
  }
  it.prototype.writeBigUInt64LE = Kn(function(At, kt = 0) {
    return tr(this, At, kt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), it.prototype.writeBigUInt64BE = Kn(function(At, kt = 0) {
    return Dt(this, At, kt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), it.prototype.writeIntLE = function(At, kt, Zt, pr) {
    if (At = +At, kt = kt >>> 0, !pr) {
      const On = Math.pow(2, 8 * Zt - 1);
      dr(this, At, kt, Zt, On - 1, -On);
    }
    let Sr = 0, Tr = 1, fn = 0;
    for (this[kt] = At & 255; ++Sr < Zt && (Tr *= 256); )
      At < 0 && fn === 0 && this[kt + Sr - 1] !== 0 && (fn = 1), this[kt + Sr] = (At / Tr >> 0) - fn & 255;
    return kt + Zt;
  }, it.prototype.writeIntBE = function(At, kt, Zt, pr) {
    if (At = +At, kt = kt >>> 0, !pr) {
      const On = Math.pow(2, 8 * Zt - 1);
      dr(this, At, kt, Zt, On - 1, -On);
    }
    let Sr = Zt - 1, Tr = 1, fn = 0;
    for (this[kt + Sr] = At & 255; --Sr >= 0 && (Tr *= 256); )
      At < 0 && fn === 0 && this[kt + Sr + 1] !== 0 && (fn = 1), this[kt + Sr] = (At / Tr >> 0) - fn & 255;
    return kt + Zt;
  }, it.prototype.writeInt8 = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 1, 127, -128), At < 0 && (At = 255 + At + 1), this[kt] = At & 255, kt + 1;
  }, it.prototype.writeInt16LE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 2, 32767, -32768), this[kt] = At & 255, this[kt + 1] = At >>> 8, kt + 2;
  }, it.prototype.writeInt16BE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 2, 32767, -32768), this[kt] = At >>> 8, this[kt + 1] = At & 255, kt + 2;
  }, it.prototype.writeInt32LE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 4, 2147483647, -2147483648), this[kt] = At & 255, this[kt + 1] = At >>> 8, this[kt + 2] = At >>> 16, this[kt + 3] = At >>> 24, kt + 4;
  }, it.prototype.writeInt32BE = function(At, kt, Zt) {
    return At = +At, kt = kt >>> 0, Zt || dr(this, At, kt, 4, 2147483647, -2147483648), At < 0 && (At = 4294967295 + At + 1), this[kt] = At >>> 24, this[kt + 1] = At >>> 16, this[kt + 2] = At >>> 8, this[kt + 3] = At & 255, kt + 4;
  }, it.prototype.writeBigInt64LE = Kn(function(At, kt = 0) {
    return tr(this, At, kt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), it.prototype.writeBigInt64BE = Kn(function(At, kt = 0) {
    return Dt(this, At, kt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Wt(Gt, At, kt, Zt, pr, Sr) {
    if (kt + Zt > Gt.length) throw new RangeError("Index out of range");
    if (kt < 0) throw new RangeError("Index out of range");
  }
  function or(Gt, At, kt, Zt, pr) {
    return At = +At, kt = kt >>> 0, pr || Wt(Gt, At, kt, 4), J.write(Gt, At, kt, Zt, 23, 4), kt + 4;
  }
  it.prototype.writeFloatLE = function(At, kt, Zt) {
    return or(this, At, kt, !0, Zt);
  }, it.prototype.writeFloatBE = function(At, kt, Zt) {
    return or(this, At, kt, !1, Zt);
  };
  function _r(Gt, At, kt, Zt, pr) {
    return At = +At, kt = kt >>> 0, pr || Wt(Gt, At, kt, 8), J.write(Gt, At, kt, Zt, 52, 8), kt + 8;
  }
  it.prototype.writeDoubleLE = function(At, kt, Zt) {
    return _r(this, At, kt, !0, Zt);
  }, it.prototype.writeDoubleBE = function(At, kt, Zt) {
    return _r(this, At, kt, !1, Zt);
  }, it.prototype.copy = function(At, kt, Zt, pr) {
    if (!it.isBuffer(At)) throw new TypeError("argument should be a Buffer");
    if (Zt || (Zt = 0), !pr && pr !== 0 && (pr = this.length), kt >= At.length && (kt = At.length), kt || (kt = 0), pr > 0 && pr < Zt && (pr = Zt), pr === Zt || At.length === 0 || this.length === 0) return 0;
    if (kt < 0)
      throw new RangeError("targetStart out of bounds");
    if (Zt < 0 || Zt >= this.length) throw new RangeError("Index out of range");
    if (pr < 0) throw new RangeError("sourceEnd out of bounds");
    pr > this.length && (pr = this.length), At.length - kt < pr - Zt && (pr = At.length - kt + Zt);
    const Sr = pr - Zt;
    return this === At && typeof ce.prototype.copyWithin == "function" ? this.copyWithin(kt, Zt, pr) : ce.prototype.set.call(
      At,
      this.subarray(Zt, pr),
      kt
    ), Sr;
  }, it.prototype.fill = function(At, kt, Zt, pr) {
    if (typeof At == "string") {
      if (typeof kt == "string" ? (pr = kt, kt = 0, Zt = this.length) : typeof Zt == "string" && (pr = Zt, Zt = this.length), pr !== void 0 && typeof pr != "string")
        throw new TypeError("encoding must be a string");
      if (typeof pr == "string" && !it.isEncoding(pr))
        throw new TypeError("Unknown encoding: " + pr);
      if (At.length === 1) {
        const Tr = At.charCodeAt(0);
        (pr === "utf8" && Tr < 128 || pr === "latin1") && (At = Tr);
      }
    } else typeof At == "number" ? At = At & 255 : typeof At == "boolean" && (At = Number(At));
    if (kt < 0 || this.length < kt || this.length < Zt)
      throw new RangeError("Out of range index");
    if (Zt <= kt)
      return this;
    kt = kt >>> 0, Zt = Zt === void 0 ? this.length : Zt >>> 0, At || (At = 0);
    let Sr;
    if (typeof At == "number")
      for (Sr = kt; Sr < Zt; ++Sr)
        this[Sr] = At;
    else {
      const Tr = it.isBuffer(At) ? At : it.from(At, pr), fn = Tr.length;
      if (fn === 0)
        throw new TypeError('The value "' + At + '" is invalid for argument "value"');
      for (Sr = 0; Sr < Zt - kt; ++Sr)
        this[Sr + kt] = Tr[Sr % fn];
    }
    return this;
  };
  const Xt = {};
  function Qt(Gt, At, kt) {
    Xt[Gt] = class extends kt {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: At.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Gt}]`, this.stack, delete this.name;
      }
      get code() {
        return Gt;
      }
      set code(pr) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: pr,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Gt}]: ${this.message}`;
      }
    };
  }
  Qt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Gt) {
      return Gt ? `${Gt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Qt(
    "ERR_INVALID_ARG_TYPE",
    function(Gt, At) {
      return `The "${Gt}" argument must be of type number. Received type ${typeof At}`;
    },
    TypeError
  ), Qt(
    "ERR_OUT_OF_RANGE",
    function(Gt, At, kt) {
      let Zt = `The value of "${Gt}" is out of range.`, pr = kt;
      return Number.isInteger(kt) && Math.abs(kt) > 2 ** 32 ? pr = br(String(kt)) : typeof kt == "bigint" && (pr = String(kt), (kt > BigInt(2) ** BigInt(32) || kt < -(BigInt(2) ** BigInt(32))) && (pr = br(pr)), pr += "n"), Zt += ` It must be ${At}. Received ${pr}`, Zt;
    },
    RangeError
  );
  function br(Gt) {
    let At = "", kt = Gt.length;
    const Zt = Gt[0] === "-" ? 1 : 0;
    for (; kt >= Zt + 4; kt -= 3)
      At = `_${Gt.slice(kt - 3, kt)}${At}`;
    return `${Gt.slice(0, kt)}${At}`;
  }
  function Dr(Gt, At, kt) {
    Zr(At, "offset"), (Gt[At] === void 0 || Gt[At + kt] === void 0) && ln(At, Gt.length - (kt + 1));
  }
  function Vr(Gt, At, kt, Zt, pr, Sr) {
    if (Gt > kt || Gt < At) {
      const Tr = typeof At == "bigint" ? "n" : "";
      let fn;
      throw At === 0 || At === BigInt(0) ? fn = `>= 0${Tr} and < 2${Tr} ** ${(Sr + 1) * 8}${Tr}` : fn = `>= -(2${Tr} ** ${(Sr + 1) * 8 - 1}${Tr}) and < 2 ** ${(Sr + 1) * 8 - 1}${Tr}`, new Xt.ERR_OUT_OF_RANGE("value", fn, Gt);
    }
    Dr(Zt, pr, Sr);
  }
  function Zr(Gt, At) {
    if (typeof Gt != "number")
      throw new Xt.ERR_INVALID_ARG_TYPE(At, "number", Gt);
  }
  function ln(Gt, At, kt) {
    throw Math.floor(Gt) !== Gt ? (Zr(Gt, kt), new Xt.ERR_OUT_OF_RANGE("offset", "an integer", Gt)) : At < 0 ? new Xt.ERR_BUFFER_OUT_OF_BOUNDS() : new Xt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${At}`,
      Gt
    );
  }
  const _n = /[^+/0-9A-Za-z-_]/g;
  function Mr(Gt) {
    if (Gt = Gt.split("=")[0], Gt = Gt.trim().replace(_n, ""), Gt.length < 2) return "";
    for (; Gt.length % 4 !== 0; )
      Gt = Gt + "=";
    return Gt;
  }
  function Wn(Gt, At) {
    At = At || 1 / 0;
    let kt;
    const Zt = Gt.length;
    let pr = null;
    const Sr = [];
    for (let Tr = 0; Tr < Zt; ++Tr) {
      if (kt = Gt.charCodeAt(Tr), kt > 55295 && kt < 57344) {
        if (!pr) {
          if (kt > 56319) {
            (At -= 3) > -1 && Sr.push(239, 191, 189);
            continue;
          } else if (Tr + 1 === Zt) {
            (At -= 3) > -1 && Sr.push(239, 191, 189);
            continue;
          }
          pr = kt;
          continue;
        }
        if (kt < 56320) {
          (At -= 3) > -1 && Sr.push(239, 191, 189), pr = kt;
          continue;
        }
        kt = (pr - 55296 << 10 | kt - 56320) + 65536;
      } else pr && (At -= 3) > -1 && Sr.push(239, 191, 189);
      if (pr = null, kt < 128) {
        if ((At -= 1) < 0) break;
        Sr.push(kt);
      } else if (kt < 2048) {
        if ((At -= 2) < 0) break;
        Sr.push(
          kt >> 6 | 192,
          kt & 63 | 128
        );
      } else if (kt < 65536) {
        if ((At -= 3) < 0) break;
        Sr.push(
          kt >> 12 | 224,
          kt >> 6 & 63 | 128,
          kt & 63 | 128
        );
      } else if (kt < 1114112) {
        if ((At -= 4) < 0) break;
        Sr.push(
          kt >> 18 | 240,
          kt >> 12 & 63 | 128,
          kt >> 6 & 63 | 128,
          kt & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Sr;
  }
  function xn(Gt) {
    const At = [];
    for (let kt = 0; kt < Gt.length; ++kt)
      At.push(Gt.charCodeAt(kt) & 255);
    return At;
  }
  function ni(Gt, At) {
    let kt, Zt, pr;
    const Sr = [];
    for (let Tr = 0; Tr < Gt.length && !((At -= 2) < 0); ++Tr)
      kt = Gt.charCodeAt(Tr), Zt = kt >> 8, pr = kt % 256, Sr.push(pr), Sr.push(Zt);
    return Sr;
  }
  function Gn(Gt) {
    return L.toByteArray(Mr(Gt));
  }
  function En(Gt, At, kt, Zt) {
    let pr;
    for (pr = 0; pr < Zt && !(pr + kt >= At.length || pr >= Gt.length); ++pr)
      At[pr + kt] = Gt[pr];
    return pr;
  }
  function Pn(Gt, At) {
    return Gt instanceof At || Gt != null && Gt.constructor != null && Gt.constructor.name != null && Gt.constructor.name === At.name;
  }
  function ti(Gt) {
    return Gt !== Gt;
  }
  const gn = function() {
    const Gt = "0123456789abcdef", At = new Array(256);
    for (let kt = 0; kt < 16; ++kt) {
      const Zt = kt * 16;
      for (let pr = 0; pr < 16; ++pr)
        At[Zt + pr] = Gt[kt] + Gt[pr];
    }
    return At;
  }();
  function Kn(Gt) {
    return typeof BigInt > "u" ? gi : Gt;
  }
  function gi() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$D = buffer$1.Buffer, Blob$1 = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$D,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var src$4 = {}, address = {}, networks$2 = {};
Object.defineProperty(networks$2, "__esModule", { value: !0 });
networks$2.testnet = networks$2.regtest = networks$2.bitcoin = void 0;
networks$2.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks$2.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks$2.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const L = B[3];
  if (L === 0 || 5 + L >= B.length || B[4 + L] !== 2) return !1;
  const J = B[5 + L];
  return !(J === 0 || 6 + L + J !== B.length || B[4] & 128 || L > 1 && B[4] === 0 && !(B[5] & 128) || B[L + 6] & 128 || J > 1 && B[L + 6] === 0 && !(B[L + 7] & 128));
}
bip66.check = check$d;
function decode$k(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const L = B[3];
  if (L === 0) throw new Error("R length is zero");
  if (5 + L >= B.length) throw new Error("R length is too long");
  if (B[4 + L] !== 2) throw new Error("Expected DER integer (2)");
  const J = B[5 + L];
  if (J === 0) throw new Error("S length is zero");
  if (6 + L + J !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (L > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[L + 6] & 128) throw new Error("S value is negative");
  if (J > 1 && B[L + 6] === 0 && !(B[L + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + L),
    s: B.slice(6 + L)
  };
}
bip66.decode = decode$k;
function encode$k(B, L) {
  const J = B.length, ne = L.length;
  if (J === 0) throw new Error("R length is zero");
  if (ne === 0) throw new Error("S length is zero");
  if (J > 33) throw new Error("R length is too long");
  if (ne > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (L[0] & 128) throw new Error("S value is negative");
  if (J > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (ne > 1 && L[0] === 0 && !(L[1] & 128))
    throw new Error("S value excessively padded");
  const oe = Buffer$D.allocUnsafe(6 + J + ne);
  return oe[0] = 48, oe[1] = oe.length - 2, oe[2] = 2, oe[3] = B.length, B.copy(oe, 4), oe[4 + J] = 2, oe[5 + J] = L.length, L.copy(oe, 6 + J), oe;
}
bip66.encode = encode$k;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const L = OPS$7[B];
  REVERSE_OPS[L] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$j(B, L, J) {
  const ne = encodingLength$2(L);
  return ne === 1 ? B.writeUInt8(L, J) : ne === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, J), B.writeUInt8(L, J + 1)) : ne === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, J), B.writeUInt16LE(L, J + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, J), B.writeUInt32LE(L, J + 1)), ne;
}
push_data.encode = encode$j;
function decode$j(B, L) {
  const J = B.readUInt8(L);
  let ne, oe;
  if (J < ops_1.OPS.OP_PUSHDATA1)
    ne = J, oe = 1;
  else if (J === ops_1.OPS.OP_PUSHDATA1) {
    if (L + 2 > B.length) return null;
    ne = B.readUInt8(L + 1), oe = 2;
  } else if (J === ops_1.OPS.OP_PUSHDATA2) {
    if (L + 3 > B.length) return null;
    ne = B.readUInt16LE(L + 1), oe = 3;
  } else {
    if (L + 5 > B.length) return null;
    if (J !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    ne = B.readUInt32LE(L + 1), oe = 5;
  }
  return {
    opcode: J,
    number: ne,
    size: oe
  };
}
push_data.decode = decode$j;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$i(B, L, J) {
  L = L || 4, J = J === void 0 ? !0 : J;
  const ne = B.length;
  if (ne === 0) return 0;
  if (ne > L) throw new TypeError("Script number overflow");
  if (J && !(B[ne - 1] & 127) && (ne <= 1 || !(B[ne - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (ne === 5) {
    const ce = B.readUInt32LE(0), Ce = B.readUInt8(4);
    return Ce & 128 ? -((Ce & -129) * 4294967296 + ce) : Ce * 4294967296 + ce;
  }
  let oe = 0;
  for (let ce = 0; ce < ne; ++ce)
    oe |= B[ce] << 8 * ce;
  return B[ne - 1] & 128 ? -(oe & ~(128 << 8 * (ne - 1))) : oe;
}
script_number.decode = decode$i;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$i(B) {
  let L = Math.abs(B);
  const J = scriptNumSize(L), ne = Buffer$D.allocUnsafe(J), oe = B < 0;
  for (let ce = 0; ce < J; ++ce)
    ne.writeUInt8(L & 255, ce), L >>= 8;
  return ne[J - 1] & 128 ? ne.writeUInt8(oe ? 128 : 0, J - 1) : oe && (ne[J - 1] |= 128), ne;
}
script_number.encode = encode$i;
var script_signature = {}, types$7 = {};
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist$2);
var types$6 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$6.Null = types$6.Nil;
for (var typeName$1 in types$6)
  types$6[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$6, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue$1(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, L) {
  Error.captureStackTrace && Error.captureStackTrace(B, L);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, L, J) {
  var ne = getValue$1(L);
  return "Expected " + tfJSON$1(B) + ", got" + (J !== "" ? " " + J : "") + (ne !== "" ? " " + ne : "");
}
function TfTypeError$1(B, L, J) {
  J = J || getValueTypeName$1(L), this.message = tfErrorString(B, L, J), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = L, this.__valueTypeName = J;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, L, J, ne, oe) {
  var ce = '" of type ';
  return L === "key" && (ce = '" with key type '), tfErrorString('property "' + tfJSON$1(J) + ce + tfJSON$1(B), ne, oe);
}
function TfPropertyTypeError$1(B, L, J, ne, oe) {
  B ? (oe = oe || getValueTypeName$1(ne), this.message = tfPropertyErrorString(B, J, L, ne, oe)) : this.message = 'Unexpected property "' + L + '"', captureStackTrace(this, TfTypeError$1), this.__label = J, this.__property = L, this.__type = B, this.__value = ne, this.__valueTypeName = oe;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, L) {
  return new TfTypeError$1(B, {}, L);
}
function tfSubError$1(B, L, J) {
  return B instanceof TfPropertyTypeError$1 ? (L = L + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    L,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    L,
    J,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors$1 = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, L = errors$1;
  function J(Vt) {
    return Buffer$D.isBuffer(Vt);
  }
  function ne(Vt) {
    return typeof Vt == "string" && /^([0-9a-f]{2})+$/i.test(Vt);
  }
  function oe(Vt, yr) {
    var jt = Vt.toJSON();
    function Ut(er) {
      if (!Vt(er)) return !1;
      if (er.length === yr) return !0;
      throw L.tfCustomError(jt + "(Length: " + yr + ")", jt + "(Length: " + er.length + ")");
    }
    return Ut.toJSON = function() {
      return jt;
    }, Ut;
  }
  var ce = oe.bind(null, B.Array), Ce = oe.bind(null, J), rt = oe.bind(null, ne), at = oe.bind(null, B.String);
  function ht(Vt, yr, jt) {
    jt = jt || B.Number;
    function Ut(er, Ht) {
      return jt(er, Ht) && er > Vt && er < yr;
    }
    return Ut.toJSON = function() {
      return `${jt.toJSON()} between [${Vt}, ${yr}]`;
    }, Ut;
  }
  var it = Math.pow(2, 53) - 1;
  function lt(Vt) {
    return typeof Vt == "number" && isFinite(Vt);
  }
  function Et(Vt) {
    return Vt << 24 >> 24 === Vt;
  }
  function wt(Vt) {
    return Vt << 16 >> 16 === Vt;
  }
  function Rt(Vt) {
    return (Vt | 0) === Vt;
  }
  function Mt(Vt) {
    return typeof Vt == "number" && Vt >= -it && Vt <= it && Math.floor(Vt) === Vt;
  }
  function Lt(Vt) {
    return (Vt & 255) === Vt;
  }
  function zt(Vt) {
    return (Vt & 65535) === Vt;
  }
  function Ot(Vt) {
    return Vt >>> 0 === Vt;
  }
  function It(Vt) {
    return typeof Vt == "number" && Vt >= 0 && Vt <= it && Math.floor(Vt) === Vt;
  }
  var Ft = {
    ArrayN: ce,
    Buffer: J,
    BufferN: Ce,
    Finite: lt,
    Hex: ne,
    HexN: rt,
    Int8: Et,
    Int16: wt,
    Int32: Rt,
    Int53: Mt,
    Range: ht,
    StringN: at,
    UInt8: Lt,
    UInt16: zt,
    UInt32: Ot,
    UInt53: It
  };
  for (var Jt in Ft)
    Ft[Jt].toJSON = (function(Vt) {
      return Vt;
    }).bind(null, Jt);
  return extra = Ft, extra;
}
var ERRORS = errors$1, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function(L, J) {
    L = compile(L), J = J || {};
    function ne(oe, ce) {
      return !NATIVE.Array(oe) || NATIVE.Nil(oe) || J.minLength !== void 0 && oe.length < J.minLength || J.maxLength !== void 0 && oe.length > J.maxLength || J.length !== void 0 && oe.length !== J.length ? !1 : oe.every(function(Ce, rt) {
        try {
          return typeforce$4(L, Ce, ce);
        } catch (at) {
          throw tfSubError(at, rt);
        }
      });
    }
    return ne.toJSON = function() {
      var oe = "[" + tfJSON(L) + "]";
      return J.length !== void 0 ? oe += "{" + J.length + "}" : (J.minLength !== void 0 || J.maxLength !== void 0) && (oe += "{" + (J.minLength === void 0 ? 0 : J.minLength) + "," + (J.maxLength === void 0 ? 1 / 0 : J.maxLength) + "}"), oe;
    }, ne;
  },
  maybe: function B(L) {
    L = compile(L);
    function J(ne, oe) {
      return NATIVE.Nil(ne) || L(ne, oe, B);
    }
    return J.toJSON = function() {
      return "?" + tfJSON(L);
    }, J;
  },
  map: function(L, J) {
    L = compile(L), J && (J = compile(J));
    function ne(oe, ce) {
      if (!NATIVE.Object(oe) || NATIVE.Nil(oe)) return !1;
      for (var Ce in oe) {
        try {
          J && typeforce$4(J, Ce, ce);
        } catch (at) {
          throw tfSubError(at, Ce, "key");
        }
        try {
          var rt = oe[Ce];
          typeforce$4(L, rt, ce);
        } catch (at) {
          throw tfSubError(at, Ce);
        }
      }
      return !0;
    }
    return J ? ne.toJSON = function() {
      return "{" + tfJSON(J) + ": " + tfJSON(L) + "}";
    } : ne.toJSON = function() {
      return "{" + tfJSON(L) + "}";
    }, ne;
  },
  object: function(L) {
    var J = {};
    for (var ne in L)
      J[ne] = compile(L[ne]);
    function oe(ce, Ce) {
      if (!NATIVE.Object(ce) || NATIVE.Nil(ce)) return !1;
      var rt;
      try {
        for (rt in J) {
          var at = J[rt], ht = ce[rt];
          typeforce$4(at, ht, Ce);
        }
      } catch (it) {
        throw tfSubError(it, rt);
      }
      if (Ce) {
        for (rt in ce)
          if (!J[rt])
            throw new TfPropertyTypeError(void 0, rt);
      }
      return !0;
    }
    return oe.toJSON = function() {
      return tfJSON(J);
    }, oe;
  },
  anyOf: function() {
    var L = [].slice.call(arguments).map(compile);
    function J(ne, oe) {
      return L.some(function(ce) {
        try {
          return typeforce$4(ce, ne, oe);
        } catch {
          return !1;
        }
      });
    }
    return J.toJSON = function() {
      return L.map(tfJSON).join("|");
    }, J;
  },
  allOf: function() {
    var L = [].slice.call(arguments).map(compile);
    function J(ne, oe) {
      return L.every(function(ce) {
        try {
          return typeforce$4(ce, ne, oe);
        } catch {
          return !1;
        }
      });
    }
    return J.toJSON = function() {
      return L.map(tfJSON).join(" & ");
    }, J;
  },
  quacksLike: function(L) {
    function J(ne) {
      return L === getValueTypeName(ne);
    }
    return J.toJSON = function() {
      return L;
    }, J;
  },
  tuple: function() {
    var L = [].slice.call(arguments).map(compile);
    function J(ne, oe) {
      return NATIVE.Nil(ne) || NATIVE.Nil(ne.length) || oe && ne.length !== L.length ? !1 : L.every(function(ce, Ce) {
        try {
          return typeforce$4(ce, ne[Ce], oe);
        } catch (rt) {
          throw tfSubError(rt, Ce);
        }
      });
    }
    return J.toJSON = function() {
      return "(" + L.map(tfJSON).join(", ") + ")";
    }, J;
  },
  value: function(L) {
    function J(ne) {
      return ne === L;
    }
    return J.toJSON = function() {
      return L;
    }, J;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$4(B, L, J, ne) {
  if (NATIVE.Function(B)) {
    if (B(L, J)) return !0;
    throw new TfTypeError(ne || B, L);
  }
  return typeforce$4(compile(B), L, J);
}
for (var typeName in NATIVE)
  typeforce$4[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$4[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$4[typeName] = EXTRA[typeName];
typeforce$4.compile = compile;
typeforce$4.TfTypeError = TfTypeError;
typeforce$4.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$4;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const L = require$$1$2;
  B.typeforce = typeforce_1;
  const J = L.Buffer.alloc(32, 0), ne = L.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function oe(it, lt) {
    return it.length !== lt.length ? !1 : it.every((Et, wt) => Et.equals(lt[wt]));
  }
  B.stacksEqual = oe;
  function ce(it) {
    if (!L.Buffer.isBuffer(it) || it.length < 33) return !1;
    const lt = it[0], Et = it.slice(1, 33);
    if (Et.compare(J) === 0 || Et.compare(ne) >= 0) return !1;
    if ((lt === 2 || lt === 3) && it.length === 33)
      return !0;
    const wt = it.slice(33);
    return wt.compare(J) === 0 || wt.compare(ne) >= 0 ? !1 : lt === 4 && it.length === 65;
  }
  B.isPoint = ce;
  const Ce = 21 * 1e14;
  function rt(it) {
    return B.typeforce.UInt53(it) && it <= Ce;
  }
  B.Satoshi = rt, B.TAPLEAF_VERSION_MASK = 254;
  function at(it) {
    return !it || !("output" in it) || !L.Buffer.isBuffer(it.output) ? !1 : it.version !== void 0 ? (it.version & B.TAPLEAF_VERSION_MASK) === it.version : !0;
  }
  B.isTapleaf = at;
  function ht(it) {
    return (0, B.Array)(it) ? it.length !== 2 ? !1 : it.every((lt) => ht(lt)) : at(it);
  }
  B.isTaptree = ht, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$7);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, L = requireScript(), J = types$7, { typeforce: ne } = J, oe = Buffer$D.alloc(1, 0);
  function ce(ht) {
    let it = 0;
    for (; ht[it] === 0; ) ++it;
    return it === ht.length ? oe : (ht = ht.slice(it), ht[0] & 128 ? Buffer$D.concat([oe, ht], 1 + ht.length) : ht);
  }
  function Ce(ht) {
    ht[0] === 0 && (ht = ht.slice(1));
    const it = Buffer$D.alloc(32, 0), lt = Math.max(0, 32 - ht.length);
    return ht.copy(it, lt), it;
  }
  function rt(ht) {
    const it = ht.readUInt8(ht.length - 1);
    if (!(0, L.isDefinedHashType)(it))
      throw new Error("Invalid hashType " + it);
    const lt = B.decode(ht.slice(0, -1)), Et = Ce(lt.r), wt = Ce(lt.s);
    return { signature: Buffer$D.concat([Et, wt], 64), hashType: it };
  }
  script_signature.decode = rt;
  function at(ht, it) {
    if (ne(
      {
        signature: J.BufferN(64),
        hashType: J.UInt8
      },
      { signature: ht, hashType: it }
    ), !(0, L.isDefinedHashType)(it))
      throw new Error("Invalid hashType " + it);
    const lt = Buffer$D.allocUnsafe(1);
    lt.writeUInt8(it, 0);
    const Et = ce(ht.slice(0, 32)), wt = ce(ht.slice(32, 64));
    return Buffer$D.concat([B.encode(Et, wt), lt]);
  }
  return script_signature.encode = at, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const L = bip66, J = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return J.OPS;
      }
    });
    const ne = push_data, oe = script_number, ce = requireScript_signature(), Ce = types$7, { typeforce: rt } = Ce, at = J.OPS.OP_RESERVED;
    function ht(Ut) {
      return Ce.Number(Ut) && (Ut === J.OPS.OP_0 || Ut >= J.OPS.OP_1 && Ut <= J.OPS.OP_16 || Ut === J.OPS.OP_1NEGATE);
    }
    function it(Ut) {
      return Ce.Buffer(Ut) || ht(Ut);
    }
    function lt(Ut) {
      return Ce.Array(Ut) && Ut.every(it);
    }
    B.isPushOnly = lt;
    function Et(Ut) {
      return Ut.length - Ut.filter(it).length;
    }
    B.countNonPushOnlyOPs = Et;
    function wt(Ut) {
      if (Ut.length === 0) return J.OPS.OP_0;
      if (Ut.length === 1) {
        if (Ut[0] >= 1 && Ut[0] <= 16) return at + Ut[0];
        if (Ut[0] === 129) return J.OPS.OP_1NEGATE;
      }
    }
    function Rt(Ut) {
      return Buffer$D.isBuffer(Ut);
    }
    function Mt(Ut) {
      return Ce.Array(Ut);
    }
    function Lt(Ut) {
      return Buffer$D.isBuffer(Ut);
    }
    function zt(Ut) {
      if (Rt(Ut)) return Ut;
      rt(Ce.Array, Ut);
      const er = Ut.reduce((dt, ot) => Lt(ot) ? ot.length === 1 && wt(ot) !== void 0 ? dt + 1 : dt + ne.encodingLength(ot.length) + ot.length : dt + 1, 0), Ht = Buffer$D.allocUnsafe(er);
      let ct = 0;
      if (Ut.forEach((dt) => {
        if (Lt(dt)) {
          const ot = wt(dt);
          if (ot !== void 0) {
            Ht.writeUInt8(ot, ct), ct += 1;
            return;
          }
          ct += ne.encode(Ht, dt.length, ct), dt.copy(Ht, ct), ct += dt.length;
        } else
          Ht.writeUInt8(dt, ct), ct += 1;
      }), ct !== Ht.length) throw new Error("Could not decode chunks");
      return Ht;
    }
    B.compile = zt;
    function Ot(Ut) {
      if (Mt(Ut)) return Ut;
      rt(Ce.Buffer, Ut);
      const er = [];
      let Ht = 0;
      for (; Ht < Ut.length; ) {
        const ct = Ut[Ht];
        if (ct > J.OPS.OP_0 && ct <= J.OPS.OP_PUSHDATA4) {
          const dt = ne.decode(Ut, Ht);
          if (dt === null || (Ht += dt.size, Ht + dt.number > Ut.length)) return null;
          const ot = Ut.slice(Ht, Ht + dt.number);
          Ht += dt.number;
          const ut = wt(ot);
          ut !== void 0 ? er.push(ut) : er.push(ot);
        } else
          er.push(ct), Ht += 1;
      }
      return er;
    }
    B.decompile = Ot;
    function It(Ut) {
      if (Rt(Ut) && (Ut = Ot(Ut)), !Ut)
        throw new Error("Could not convert invalid chunks to ASM");
      return Ut.map((er) => {
        if (Lt(er)) {
          const Ht = wt(er);
          if (Ht === void 0) return er.toString("hex");
          er = Ht;
        }
        return J.REVERSE_OPS[er];
      }).join(" ");
    }
    B.toASM = It;
    function Ft(Ut) {
      return rt(Ce.String, Ut), zt(
        Ut.split(" ").map((er) => J.OPS[er] !== void 0 ? J.OPS[er] : (rt(Ce.Hex, er), Buffer$D.from(er, "hex")))
      );
    }
    B.fromASM = Ft;
    function Jt(Ut) {
      return Ut = Ot(Ut), rt(lt, Ut), Ut.map((er) => Lt(er) ? er : er === J.OPS.OP_0 ? Buffer$D.allocUnsafe(0) : oe.encode(er - at));
    }
    B.toStack = Jt;
    function Vt(Ut) {
      return Ce.isPoint(Ut);
    }
    B.isCanonicalPubKey = Vt;
    function yr(Ut) {
      const er = Ut & -129;
      return er > 0 && er < 4;
    }
    B.isDefinedHashType = yr;
    function jt(Ut) {
      return !Buffer$D.isBuffer(Ut) || !yr(Ut[Ut.length - 1]) ? !1 : L.check(Ut.slice(0, -1));
    }
    B.isCanonicalScriptSignature = jt, B.number = oe, B.signature = ce;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, L, J) {
  Object.defineProperty(B, L, {
    configurable: !0,
    enumerable: !0,
    get() {
      const ne = J.call(this);
      return this[L] = ne, ne;
    },
    set(ne) {
      Object.defineProperty(this, L, {
        configurable: !0,
        enumerable: !0,
        value: ne,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let L;
  return () => (L !== void 0 || (L = B()), L);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks$2, bscript$9 = requireScript(), types_1$7 = types$7, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, L) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const ne = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(ne, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(ne, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), L.validate && B.output) {
    const oe = bscript$9.decompile(B.output);
    if (oe[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!oe.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, ne.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(ne, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks$2, bscript$8 = requireScript(), types_1$6 = types$7, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, L) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {});
  function J(at) {
    return bscript$8.isCanonicalScriptSignature(at) || (L.allowIncomplete && at === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(J)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const oe = { network: B.network || networks_1$6.bitcoin };
  let ce = [], Ce = !1;
  function rt(at) {
    Ce || (Ce = !0, ce = bscript$8.decompile(at), oe.m = ce[0] - OP_INT_BASE, oe.n = ce[ce.length - 2] - OP_INT_BASE, oe.pubkeys = ce.slice(1, -2));
  }
  if (lazy$5.prop(oe, "output", () => {
    if (B.m && oe.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + oe.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(oe, "m", () => {
    if (oe.output)
      return rt(oe.output), oe.m;
  }), lazy$5.prop(oe, "n", () => {
    if (oe.pubkeys)
      return oe.pubkeys.length;
  }), lazy$5.prop(oe, "pubkeys", () => {
    if (B.output)
      return rt(B.output), oe.pubkeys;
  }), lazy$5.prop(oe, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(oe, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(oe, "witness", () => {
    if (oe.input)
      return [];
  }), lazy$5.prop(oe, "name", () => {
    if (!(!oe.m || !oe.n))
      return `p2ms(${oe.m} of ${oe.n})`;
  }), L.validate) {
    if (B.output) {
      if (rt(B.output), !types_1$6.typeforce.Number(ce[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(ce[ce.length - 2]))
        throw new TypeError("Output is invalid");
      if (ce[ce.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (oe.m <= 0 || oe.n > 16 || oe.m > oe.n || oe.n !== ce.length - 3)
        throw new TypeError("Output is invalid");
      if (!oe.pubkeys.every((at) => (0, types_1$6.isPoint)(at)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== oe.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== oe.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, oe.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (oe.n = B.pubkeys.length, oe.n < oe.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < oe.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > oe.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (oe.signatures.length === 0 || !oe.signatures.every(J))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, oe.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(oe, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks$2, bscript$7 = requireScript(), types_1$5 = types$7, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, L) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const J = lazy$4.value(() => bscript$7.decompile(B.input)), oe = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(oe, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(oe, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(oe, "signature", () => {
    if (B.input)
      return J()[0];
  }), lazy$4.prop(oe, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(oe, "witness", () => {
    if (oe.input)
      return [];
  }), L.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(oe.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(oe.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(oe.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (J().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(oe.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(oe, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$6 = {}, ripemd160$1 = {}, _md = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = _assert.isBytes = void 0;
function number$1(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error(`positive integer expected, not ${B}`);
}
_assert.number = number$1;
function bool(B) {
  if (typeof B != "boolean")
    throw new Error(`boolean expected, not ${B}`);
}
_assert.bool = bool;
function isBytes(B) {
  return B instanceof Uint8Array || B != null && typeof B == "object" && B.constructor.name === "Uint8Array";
}
_assert.isBytes = isBytes;
function bytes(B, ...L) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (L.length > 0 && !L.includes(B.length))
    throw new Error(`Uint8Array expected of length ${L}, not of length=${B.length}`);
}
_assert.bytes = bytes;
function hash$4(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(B.outputLen), number$1(B.blockLen);
}
_assert.hash = hash$4;
function exists(B, L = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (L && B.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(B, L) {
  bytes(B);
  const J = L.outputLen;
  if (B.length < J)
    throw new Error(`digestInto() expects output buffer of length at least ${J}`);
}
_assert.output = output;
const assert$m = { number: number$1, bool, bytes, hash: hash$4, exists, output };
_assert.default = assert$m;
var utils$p = {}, crypto$5 = {};
Object.defineProperty(crypto$5, "__esModule", { value: !0 });
crypto$5.crypto = void 0;
crypto$5.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.randomBytes = B.wrapXOFConstructorWithOpts = B.wrapConstructorWithOpts = B.wrapConstructor = B.checkOpts = B.Hash = B.concatBytes = B.toBytes = B.utf8ToBytes = B.asyncLoop = B.nextTick = B.hexToBytes = B.bytesToHex = B.byteSwap32 = B.byteSwapIfBE = B.byteSwap = B.isLE = B.rotl = B.rotr = B.createView = B.u32 = B.u8 = B.isBytes = void 0;
  const L = crypto$5, J = _assert;
  function ne(ct) {
    return ct instanceof Uint8Array || ct != null && typeof ct == "object" && ct.constructor.name === "Uint8Array";
  }
  B.isBytes = ne;
  const oe = (ct) => new Uint8Array(ct.buffer, ct.byteOffset, ct.byteLength);
  B.u8 = oe;
  const ce = (ct) => new Uint32Array(ct.buffer, ct.byteOffset, Math.floor(ct.byteLength / 4));
  B.u32 = ce;
  const Ce = (ct) => new DataView(ct.buffer, ct.byteOffset, ct.byteLength);
  B.createView = Ce;
  const rt = (ct, dt) => ct << 32 - dt | ct >>> dt;
  B.rotr = rt;
  const at = (ct, dt) => ct << dt | ct >>> 32 - dt >>> 0;
  B.rotl = at, B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const ht = (ct) => ct << 24 & 4278190080 | ct << 8 & 16711680 | ct >>> 8 & 65280 | ct >>> 24 & 255;
  B.byteSwap = ht, B.byteSwapIfBE = B.isLE ? (ct) => ct : (ct) => (0, B.byteSwap)(ct);
  function it(ct) {
    for (let dt = 0; dt < ct.length; dt++)
      ct[dt] = (0, B.byteSwap)(ct[dt]);
  }
  B.byteSwap32 = it;
  const lt = /* @__PURE__ */ Array.from({ length: 256 }, (ct, dt) => dt.toString(16).padStart(2, "0"));
  function Et(ct) {
    (0, J.bytes)(ct);
    let dt = "";
    for (let ot = 0; ot < ct.length; ot++)
      dt += lt[ct[ot]];
    return dt;
  }
  B.bytesToHex = Et;
  const wt = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function Rt(ct) {
    if (ct >= wt._0 && ct <= wt._9)
      return ct - wt._0;
    if (ct >= wt._A && ct <= wt._F)
      return ct - (wt._A - 10);
    if (ct >= wt._a && ct <= wt._f)
      return ct - (wt._a - 10);
  }
  function Mt(ct) {
    if (typeof ct != "string")
      throw new Error("hex string expected, got " + typeof ct);
    const dt = ct.length, ot = dt / 2;
    if (dt % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + dt);
    const ut = new Uint8Array(ot);
    for (let mt = 0, gt = 0; mt < ot; mt++, gt += 2) {
      const St = Rt(ct.charCodeAt(gt)), xt = Rt(ct.charCodeAt(gt + 1));
      if (St === void 0 || xt === void 0) {
        const vt = ct[gt] + ct[gt + 1];
        throw new Error('hex string expected, got non-hex character "' + vt + '" at index ' + gt);
      }
      ut[mt] = St * 16 + xt;
    }
    return ut;
  }
  B.hexToBytes = Mt;
  const Lt = async () => {
  };
  B.nextTick = Lt;
  async function zt(ct, dt, ot) {
    let ut = Date.now();
    for (let mt = 0; mt < ct; mt++) {
      ot(mt);
      const gt = Date.now() - ut;
      gt >= 0 && gt < dt || (await (0, B.nextTick)(), ut += gt);
    }
  }
  B.asyncLoop = zt;
  function Ot(ct) {
    if (typeof ct != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof ct}`);
    return new Uint8Array(new TextEncoder().encode(ct));
  }
  B.utf8ToBytes = Ot;
  function It(ct) {
    return typeof ct == "string" && (ct = Ot(ct)), (0, J.bytes)(ct), ct;
  }
  B.toBytes = It;
  function Ft(...ct) {
    let dt = 0;
    for (let ut = 0; ut < ct.length; ut++) {
      const mt = ct[ut];
      (0, J.bytes)(mt), dt += mt.length;
    }
    const ot = new Uint8Array(dt);
    for (let ut = 0, mt = 0; ut < ct.length; ut++) {
      const gt = ct[ut];
      ot.set(gt, mt), mt += gt.length;
    }
    return ot;
  }
  B.concatBytes = Ft;
  class Jt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = Jt;
  const Vt = {}.toString;
  function yr(ct, dt) {
    if (dt !== void 0 && Vt.call(dt) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(ct, dt);
  }
  B.checkOpts = yr;
  function jt(ct) {
    const dt = (ut) => ct().update(It(ut)).digest(), ot = ct();
    return dt.outputLen = ot.outputLen, dt.blockLen = ot.blockLen, dt.create = () => ct(), dt;
  }
  B.wrapConstructor = jt;
  function Ut(ct) {
    const dt = (ut, mt) => ct(mt).update(It(ut)).digest(), ot = ct({});
    return dt.outputLen = ot.outputLen, dt.blockLen = ot.blockLen, dt.create = (ut) => ct(ut), dt;
  }
  B.wrapConstructorWithOpts = Ut;
  function er(ct) {
    const dt = (ut, mt) => ct(mt).update(It(ut)).digest(), ot = ct({});
    return dt.outputLen = ot.outputLen, dt.blockLen = ot.blockLen, dt.create = (ut) => ct(ut), dt;
  }
  B.wrapXOFConstructorWithOpts = er;
  function Ht(ct = 32) {
    if (L.crypto && typeof L.crypto.getRandomValues == "function")
      return L.crypto.getRandomValues(new Uint8Array(ct));
    throw new Error("crypto.getRandomValues must be defined");
  }
  B.randomBytes = Ht;
})(utils$p);
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = _md.Maj = _md.Chi = void 0;
const _assert_js_1 = _assert, utils_js_1$4 = utils$p;
function setBigUint64(B, L, J, ne) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(L, J, ne);
  const oe = BigInt(32), ce = BigInt(4294967295), Ce = Number(J >> oe & ce), rt = Number(J & ce), at = ne ? 4 : 0, ht = ne ? 0 : 4;
  B.setUint32(L + at, Ce, ne), B.setUint32(L + ht, rt, ne);
}
const Chi = (B, L, J) => B & L ^ ~B & J;
_md.Chi = Chi;
const Maj = (B, L, J) => B & L ^ B & J ^ L & J;
_md.Maj = Maj;
class HashMD extends utils_js_1$4.Hash {
  constructor(L, J, ne, oe) {
    super(), this.blockLen = L, this.outputLen = J, this.padOffset = ne, this.isLE = oe, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(L), this.view = (0, utils_js_1$4.createView)(this.buffer);
  }
  update(L) {
    (0, _assert_js_1.exists)(this);
    const { view: J, buffer: ne, blockLen: oe } = this;
    L = (0, utils_js_1$4.toBytes)(L);
    const ce = L.length;
    for (let Ce = 0; Ce < ce; ) {
      const rt = Math.min(oe - this.pos, ce - Ce);
      if (rt === oe) {
        const at = (0, utils_js_1$4.createView)(L);
        for (; oe <= ce - Ce; Ce += oe)
          this.process(at, Ce);
        continue;
      }
      ne.set(L.subarray(Ce, Ce + rt), this.pos), this.pos += rt, Ce += rt, this.pos === oe && (this.process(J, 0), this.pos = 0);
    }
    return this.length += L.length, this.roundClean(), this;
  }
  digestInto(L) {
    (0, _assert_js_1.exists)(this), (0, _assert_js_1.output)(L, this), this.finished = !0;
    const { buffer: J, view: ne, blockLen: oe, isLE: ce } = this;
    let { pos: Ce } = this;
    J[Ce++] = 128, this.buffer.subarray(Ce).fill(0), this.padOffset > oe - Ce && (this.process(ne, 0), Ce = 0);
    for (let lt = Ce; lt < oe; lt++)
      J[lt] = 0;
    setBigUint64(ne, oe - 8, BigInt(this.length * 8), ce), this.process(ne, 0);
    const rt = (0, utils_js_1$4.createView)(L), at = this.outputLen;
    if (at % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ht = at / 4, it = this.get();
    if (ht > it.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let lt = 0; lt < ht; lt++)
      rt.setUint32(4 * lt, it[lt], ce);
  }
  digest() {
    const { buffer: L, outputLen: J } = this;
    this.digestInto(L);
    const ne = L.slice(0, J);
    return this.destroy(), ne;
  }
  _cloneInto(L) {
    L || (L = new this.constructor()), L.set(...this.get());
    const { blockLen: J, buffer: ne, length: oe, finished: ce, destroyed: Ce, pos: rt } = this;
    return L.length = oe, L.pos = rt, L.finished = ce, L.destroyed = Ce, oe % J && L.buffer.set(ne), L;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(ripemd160$1, "__esModule", { value: !0 });
ripemd160$1.ripemd160 = ripemd160$1.RIPEMD160 = void 0;
const _md_js_1$3 = _md, utils_js_1$3 = utils$p, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, L) => L)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let L of [idxL, idxR])
    L.push(L[B].map((J) => Rho[J]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, L) => B.map((J) => shifts[L][J])), shiftsR = /* @__PURE__ */ idxR.map((B, L) => B.map((J) => shifts[L][J])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f$2(B, L, J, ne) {
  return B === 0 ? L ^ J ^ ne : B === 1 ? L & J | ~L & ne : B === 2 ? (L | ~J) ^ ne : B === 3 ? L & ne | J & ~ne : L ^ (J | ~ne);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
let RIPEMD160$5 = class extends _md_js_1$3.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: L, h1: J, h2: ne, h3: oe, h4: ce } = this;
    return [L, J, ne, oe, ce];
  }
  set(L, J, ne, oe, ce) {
    this.h0 = L | 0, this.h1 = J | 0, this.h2 = ne | 0, this.h3 = oe | 0, this.h4 = ce | 0;
  }
  process(L, J) {
    for (let wt = 0; wt < 16; wt++, J += 4)
      R_BUF[wt] = L.getUint32(J, !0);
    let ne = this.h0 | 0, oe = ne, ce = this.h1 | 0, Ce = ce, rt = this.h2 | 0, at = rt, ht = this.h3 | 0, it = ht, lt = this.h4 | 0, Et = lt;
    for (let wt = 0; wt < 5; wt++) {
      const Rt = 4 - wt, Mt = Kl[wt], Lt = Kr[wt], zt = idxL[wt], Ot = idxR[wt], It = shiftsL[wt], Ft = shiftsR[wt];
      for (let Jt = 0; Jt < 16; Jt++) {
        const Vt = (0, utils_js_1$3.rotl)(ne + f$2(wt, ce, rt, ht) + R_BUF[zt[Jt]] + Mt, It[Jt]) + lt | 0;
        ne = lt, lt = ht, ht = (0, utils_js_1$3.rotl)(rt, 10) | 0, rt = ce, ce = Vt;
      }
      for (let Jt = 0; Jt < 16; Jt++) {
        const Vt = (0, utils_js_1$3.rotl)(oe + f$2(Rt, Ce, at, it) + R_BUF[Ot[Jt]] + Lt, Ft[Jt]) + Et | 0;
        oe = Et, Et = it, it = (0, utils_js_1$3.rotl)(at, 10) | 0, at = Ce, Ce = Vt;
      }
    }
    this.set(this.h1 + rt + it | 0, this.h2 + ht + Et | 0, this.h3 + lt + oe | 0, this.h4 + ne + Ce | 0, this.h0 + ce + at | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
ripemd160$1.RIPEMD160 = RIPEMD160$5;
ripemd160$1.ripemd160 = (0, utils_js_1$3.wrapConstructor)(() => new RIPEMD160$5());
var sha1$1 = {};
Object.defineProperty(sha1$1, "__esModule", { value: !0 });
sha1$1.sha1 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$p, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
let SHA1$1 = class extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: L, B: J, C: ne, D: oe, E: ce } = this;
    return [L, J, ne, oe, ce];
  }
  set(L, J, ne, oe, ce) {
    this.A = L | 0, this.B = J | 0, this.C = ne | 0, this.D = oe | 0, this.E = ce | 0;
  }
  process(L, J) {
    for (let at = 0; at < 16; at++, J += 4)
      SHA1_W[at] = L.getUint32(J, !1);
    for (let at = 16; at < 80; at++)
      SHA1_W[at] = (0, utils_js_1$2.rotl)(SHA1_W[at - 3] ^ SHA1_W[at - 8] ^ SHA1_W[at - 14] ^ SHA1_W[at - 16], 1);
    let { A: ne, B: oe, C: ce, D: Ce, E: rt } = this;
    for (let at = 0; at < 80; at++) {
      let ht, it;
      at < 20 ? (ht = (0, _md_js_1$2.Chi)(oe, ce, Ce), it = 1518500249) : at < 40 ? (ht = oe ^ ce ^ Ce, it = 1859775393) : at < 60 ? (ht = (0, _md_js_1$2.Maj)(oe, ce, Ce), it = 2400959708) : (ht = oe ^ ce ^ Ce, it = 3395469782);
      const lt = (0, utils_js_1$2.rotl)(ne, 5) + ht + rt + it + SHA1_W[at] | 0;
      rt = Ce, Ce = ce, ce = (0, utils_js_1$2.rotl)(oe, 30), oe = ne, ne = lt;
    }
    ne = ne + this.A | 0, oe = oe + this.B | 0, ce = ce + this.C | 0, Ce = Ce + this.D | 0, rt = rt + this.E | 0, this.set(ne, oe, ce, Ce, rt);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
sha1$1.sha1 = (0, utils_js_1$2.wrapConstructor)(() => new SHA1$1());
var sha256$5 = {};
Object.defineProperty(sha256$5, "__esModule", { value: !0 });
sha256$5.sha224 = sha256$5.sha256 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$p, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
let SHA256$2 = class extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: L, B: J, C: ne, D: oe, E: ce, F: Ce, G: rt, H: at } = this;
    return [L, J, ne, oe, ce, Ce, rt, at];
  }
  // prettier-ignore
  set(L, J, ne, oe, ce, Ce, rt, at) {
    this.A = L | 0, this.B = J | 0, this.C = ne | 0, this.D = oe | 0, this.E = ce | 0, this.F = Ce | 0, this.G = rt | 0, this.H = at | 0;
  }
  process(L, J) {
    for (let lt = 0; lt < 16; lt++, J += 4)
      SHA256_W[lt] = L.getUint32(J, !1);
    for (let lt = 16; lt < 64; lt++) {
      const Et = SHA256_W[lt - 15], wt = SHA256_W[lt - 2], Rt = (0, utils_js_1$1.rotr)(Et, 7) ^ (0, utils_js_1$1.rotr)(Et, 18) ^ Et >>> 3, Mt = (0, utils_js_1$1.rotr)(wt, 17) ^ (0, utils_js_1$1.rotr)(wt, 19) ^ wt >>> 10;
      SHA256_W[lt] = Mt + SHA256_W[lt - 7] + Rt + SHA256_W[lt - 16] | 0;
    }
    let { A: ne, B: oe, C: ce, D: Ce, E: rt, F: at, G: ht, H: it } = this;
    for (let lt = 0; lt < 64; lt++) {
      const Et = (0, utils_js_1$1.rotr)(rt, 6) ^ (0, utils_js_1$1.rotr)(rt, 11) ^ (0, utils_js_1$1.rotr)(rt, 25), wt = it + Et + (0, _md_js_1$1.Chi)(rt, at, ht) + SHA256_K[lt] + SHA256_W[lt] | 0, Mt = ((0, utils_js_1$1.rotr)(ne, 2) ^ (0, utils_js_1$1.rotr)(ne, 13) ^ (0, utils_js_1$1.rotr)(ne, 22)) + (0, _md_js_1$1.Maj)(ne, oe, ce) | 0;
      it = ht, ht = at, at = rt, rt = Ce + wt | 0, Ce = ce, ce = oe, oe = ne, ne = wt + Mt | 0;
    }
    ne = ne + this.A | 0, oe = oe + this.B | 0, ce = ce + this.C | 0, Ce = Ce + this.D | 0, rt = rt + this.E | 0, at = at + this.F | 0, ht = ht + this.G | 0, it = it + this.H | 0, this.set(ne, oe, ce, Ce, rt, at, ht, it);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
sha256$5.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256$2());
sha256$5.sha224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA224$1());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const L = ripemd160$1, J = sha1$1, ne = sha256$5;
  function oe(it) {
    return Buffer$D.from((0, L.ripemd160)(Uint8Array.from(it)));
  }
  B.ripemd160 = oe;
  function ce(it) {
    return Buffer$D.from((0, J.sha1)(Uint8Array.from(it)));
  }
  B.sha1 = ce;
  function Ce(it) {
    return Buffer$D.from((0, ne.sha256)(Uint8Array.from(it)));
  }
  B.sha256 = Ce;
  function rt(it) {
    return Buffer$D.from(
      (0, L.ripemd160)((0, ne.sha256)(Uint8Array.from(it)))
    );
  }
  B.hash160 = rt;
  function at(it) {
    return Buffer$D.from(
      (0, ne.sha256)((0, ne.sha256)(Uint8Array.from(it)))
    );
  }
  B.hash256 = at, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$D.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$D.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$D.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$D.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$D.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$D.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$D.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$D.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$D.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function ht(it, lt) {
    return Ce(Buffer$D.concat([B.TAGGED_HASH_PREFIXES[it], lt]));
  }
  B.taggedHash = ht;
})(crypto$6);
function base$5(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var L = new Uint8Array(256), J = 0; J < L.length; J++)
    L[J] = 255;
  for (var ne = 0; ne < B.length; ne++) {
    var oe = B.charAt(ne), ce = oe.charCodeAt(0);
    if (L[ce] !== 255)
      throw new TypeError(oe + " is ambiguous");
    L[ce] = ne;
  }
  var Ce = B.length, rt = B.charAt(0), at = Math.log(Ce) / Math.log(256), ht = Math.log(256) / Math.log(Ce);
  function it(wt) {
    if (wt instanceof Uint8Array || (ArrayBuffer.isView(wt) ? wt = new Uint8Array(wt.buffer, wt.byteOffset, wt.byteLength) : Array.isArray(wt) && (wt = Uint8Array.from(wt))), !(wt instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (wt.length === 0)
      return "";
    for (var Rt = 0, Mt = 0, Lt = 0, zt = wt.length; Lt !== zt && wt[Lt] === 0; )
      Lt++, Rt++;
    for (var Ot = (zt - Lt) * ht + 1 >>> 0, It = new Uint8Array(Ot); Lt !== zt; ) {
      for (var Ft = wt[Lt], Jt = 0, Vt = Ot - 1; (Ft !== 0 || Jt < Mt) && Vt !== -1; Vt--, Jt++)
        Ft += 256 * It[Vt] >>> 0, It[Vt] = Ft % Ce >>> 0, Ft = Ft / Ce >>> 0;
      if (Ft !== 0)
        throw new Error("Non-zero carry");
      Mt = Jt, Lt++;
    }
    for (var yr = Ot - Mt; yr !== Ot && It[yr] === 0; )
      yr++;
    for (var jt = rt.repeat(Rt); yr < Ot; ++yr)
      jt += B.charAt(It[yr]);
    return jt;
  }
  function lt(wt) {
    if (typeof wt != "string")
      throw new TypeError("Expected String");
    if (wt.length === 0)
      return new Uint8Array();
    for (var Rt = 0, Mt = 0, Lt = 0; wt[Rt] === rt; )
      Mt++, Rt++;
    for (var zt = (wt.length - Rt) * at + 1 >>> 0, Ot = new Uint8Array(zt); wt[Rt]; ) {
      var It = L[wt.charCodeAt(Rt)];
      if (It === 255)
        return;
      for (var Ft = 0, Jt = zt - 1; (It !== 0 || Ft < Lt) && Jt !== -1; Jt--, Ft++)
        It += Ce * Ot[Jt] >>> 0, Ot[Jt] = It % 256 >>> 0, It = It / 256 >>> 0;
      if (It !== 0)
        throw new Error("Non-zero carry");
      Lt = Ft, Rt++;
    }
    for (var Vt = zt - Lt; Vt !== zt && Ot[Vt] === 0; )
      Vt++;
    for (var yr = new Uint8Array(Mt + (zt - Vt)), jt = Mt; Vt !== zt; )
      yr[jt++] = Ot[Vt++];
    return yr;
  }
  function Et(wt) {
    var Rt = lt(wt);
    if (Rt)
      return Rt;
    throw new Error("Non-base" + Ce + " character");
  }
  return {
    encode: it,
    decodeUnsafe: lt,
    decode: Et
  };
}
var src$3 = base$5;
const basex$1 = src$3, ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$1 = basex$1(ALPHABET$2), base58$1 = bs58$1, base$4 = function(B) {
  function L(ce) {
    var Ce = Uint8Array.from(ce), rt = B(Ce), at = Ce.length + 4, ht = new Uint8Array(at);
    return ht.set(Ce, 0), ht.set(rt.subarray(0, 4), Ce.length), base58$1.encode(ht, at);
  }
  function J(ce) {
    var Ce = ce.slice(0, -4), rt = ce.slice(-4), at = B(Ce);
    if (!(rt[0] ^ at[0] | rt[1] ^ at[1] | rt[2] ^ at[2] | rt[3] ^ at[3]))
      return Ce;
  }
  function ne(ce) {
    var Ce = base58$1.decodeUnsafe(ce);
    if (Ce)
      return J(Ce);
  }
  function oe(ce) {
    var Ce = base58$1.decode(ce), rt = J(Ce);
    if (!rt) throw new Error("Invalid checksum");
    return rt;
  }
  return {
    encode: L,
    decode: oe,
    decodeUnsafe: ne
  };
}, { sha256: sha256$4 } = sha256$5, bs58checkBase$1 = base$4;
function sha256x2$1(B) {
  return sha256$4(sha256$4(B));
}
var bs58check$5 = bs58checkBase$1(sha256x2$1);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$6, networks_1$4 = networks$2, bscript$6 = requireScript(), types_1$4 = types$7, lazy$3 = lazy$7, bs58check$4 = bs58check$5, OPS$3 = bscript$6.OPS;
function p2pkh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const J = lazy$3.value(() => {
    const Ce = Buffer$D.from(bs58check$4.decode(B.address)), rt = Ce.readUInt8(0), at = Ce.slice(1);
    return { version: rt, hash: at };
  }), ne = lazy$3.value(() => bscript$6.decompile(B.input)), oe = B.network || networks_1$4.bitcoin, ce = { name: "p2pkh", network: oe };
  if (lazy$3.prop(ce, "address", () => {
    if (!ce.hash) return;
    const Ce = Buffer$D.allocUnsafe(21);
    return Ce.writeUInt8(oe.pubKeyHash, 0), ce.hash.copy(Ce, 1), bs58check$4.encode(Ce);
  }), lazy$3.prop(ce, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return J().hash;
    if (B.pubkey || ce.pubkey) return bcrypto$5.hash160(B.pubkey || ce.pubkey);
  }), lazy$3.prop(ce, "output", () => {
    if (ce.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        ce.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(ce, "pubkey", () => {
    if (B.input)
      return ne()[1];
  }), lazy$3.prop(ce, "signature", () => {
    if (B.input)
      return ne()[0];
  }), lazy$3.prop(ce, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(ce, "witness", () => {
    if (ce.input)
      return [];
  }), L.validate) {
    let Ce = Buffer$D.from([]);
    if (B.address) {
      if (J().version !== oe.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (J().hash.length !== 20) throw new TypeError("Invalid address");
      Ce = J().hash;
    }
    if (B.hash) {
      if (Ce.length > 0 && !Ce.equals(B.hash))
        throw new TypeError("Hash mismatch");
      Ce = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const rt = B.output.slice(3, 23);
      if (Ce.length > 0 && !Ce.equals(rt))
        throw new TypeError("Hash mismatch");
      Ce = rt;
    }
    if (B.pubkey) {
      const rt = bcrypto$5.hash160(B.pubkey);
      if (Ce.length > 0 && !Ce.equals(rt))
        throw new TypeError("Hash mismatch");
      Ce = rt;
    }
    if (B.input) {
      const rt = ne();
      if (rt.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(rt[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(rt[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(rt[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(rt[1]))
        throw new TypeError("Pubkey mismatch");
      const at = bcrypto$5.hash160(rt[1]);
      if (Ce.length > 0 && !Ce.equals(at))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ce, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$6, networks_1$3 = networks$2, bscript$5 = requireScript(), types_1$3 = types$7, lazy$2 = lazy$7, bs58check$3 = bs58check$5, OPS$2 = bscript$5.OPS;
function p2sh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let J = B.network;
  J || (J = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const ne = { network: J }, oe = lazy$2.value(() => {
    const rt = Buffer$D.from(bs58check$3.decode(B.address)), at = rt.readUInt8(0), ht = rt.slice(1);
    return { version: at, hash: ht };
  }), ce = lazy$2.value(() => bscript$5.decompile(B.input)), Ce = lazy$2.value(() => {
    const rt = ce(), at = rt[rt.length - 1];
    return {
      network: J,
      output: at === OPS$2.OP_FALSE ? Buffer$D.from([]) : at,
      input: bscript$5.compile(rt.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(ne, "address", () => {
    if (!ne.hash) return;
    const rt = Buffer$D.allocUnsafe(21);
    return rt.writeUInt8(ne.network.scriptHash, 0), ne.hash.copy(rt, 1), bs58check$3.encode(rt);
  }), lazy$2.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return oe().hash;
    if (ne.redeem && ne.redeem.output) return bcrypto$4.hash160(ne.redeem.output);
  }), lazy$2.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, ne.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(ne, "redeem", () => {
    if (B.input)
      return Ce();
  }), lazy$2.prop(ne, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(ne, "witness", () => {
    if (ne.redeem && ne.redeem.witness) return ne.redeem.witness;
    if (ne.input) return [];
  }), lazy$2.prop(ne, "name", () => {
    const rt = ["p2sh"];
    return ne.redeem !== void 0 && ne.redeem.name !== void 0 && rt.push(ne.redeem.name), rt.join("-");
  }), L.validate) {
    let rt = Buffer$D.from([]);
    if (B.address) {
      if (oe().version !== J.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (oe().hash.length !== 20) throw new TypeError("Invalid address");
      rt = oe().hash;
    }
    if (B.hash) {
      if (rt.length > 0 && !rt.equals(B.hash))
        throw new TypeError("Hash mismatch");
      rt = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const ht = B.output.slice(2, 22);
      if (rt.length > 0 && !rt.equals(ht))
        throw new TypeError("Hash mismatch");
      rt = ht;
    }
    const at = (ht) => {
      if (ht.output) {
        const it = bscript$5.decompile(ht.output);
        if (!it || it.length < 1)
          throw new TypeError("Redeem.output too short");
        if (ht.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(it) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const lt = bcrypto$4.hash160(ht.output);
        if (rt.length > 0 && !rt.equals(lt))
          throw new TypeError("Hash mismatch");
        rt = lt;
      }
      if (ht.input) {
        const it = ht.input.length > 0, lt = ht.witness && ht.witness.length > 0;
        if (!it && !lt) throw new TypeError("Empty input");
        if (it && lt)
          throw new TypeError("Input and witness provided");
        if (it) {
          const Et = bscript$5.decompile(ht.input);
          if (!bscript$5.isPushOnly(Et))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const ht = ce();
      if (!ht || ht.length < 1) throw new TypeError("Input too short");
      if (!Buffer$D.isBuffer(Ce().output))
        throw new TypeError("Input is invalid");
      at(Ce());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== J)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const ht = Ce();
        if (B.redeem.output && !B.redeem.output.equals(ht.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(ht.input))
          throw new TypeError("Redeem.input mismatch");
      }
      at(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(ne, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: !0 });
dist$1.bech32m = dist$1.bech32 = void 0;
const ALPHABET$1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET$1.length; B++) {
  const L = ALPHABET$1.charAt(B);
  ALPHABET_MAP[L] = B;
}
function polymodStep(B) {
  const L = B >> 25;
  return (B & 33554431) << 5 ^ -(L >> 0 & 1) & 996825010 ^ -(L >> 1 & 1) & 642813549 ^ -(L >> 2 & 1) & 513874426 ^ -(L >> 3 & 1) & 1027748829 ^ -(L >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let L = 1;
  for (let J = 0; J < B.length; ++J) {
    const ne = B.charCodeAt(J);
    if (ne < 33 || ne > 126)
      return "Invalid prefix (" + B + ")";
    L = polymodStep(L) ^ ne >> 5;
  }
  L = polymodStep(L);
  for (let J = 0; J < B.length; ++J) {
    const ne = B.charCodeAt(J);
    L = polymodStep(L) ^ ne & 31;
  }
  return L;
}
function convert$2(B, L, J, ne) {
  let oe = 0, ce = 0;
  const Ce = (1 << J) - 1, rt = [];
  for (let at = 0; at < B.length; ++at)
    for (oe = oe << L | B[at], ce += L; ce >= J; )
      ce -= J, rt.push(oe >> ce & Ce);
  if (ne)
    ce > 0 && rt.push(oe << J - ce & Ce);
  else {
    if (ce >= L)
      return "Excess padding";
    if (oe << J - ce & Ce)
      return "Non-zero padding";
  }
  return rt;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const L = convert$2(B, 5, 8, !1);
  if (Array.isArray(L))
    return L;
}
function fromWords(B) {
  const L = convert$2(B, 5, 8, !1);
  if (Array.isArray(L))
    return L;
  throw new Error(L);
}
function getLibraryFromEncoding(B) {
  let L;
  B === "bech32" ? L = 1 : L = 734539939;
  function J(Ce, rt, at) {
    if (at = at || 90, Ce.length + 7 + rt.length > at)
      throw new TypeError("Exceeds length limit");
    Ce = Ce.toLowerCase();
    let ht = prefixChk(Ce);
    if (typeof ht == "string")
      throw new Error(ht);
    let it = Ce + "1";
    for (let lt = 0; lt < rt.length; ++lt) {
      const Et = rt[lt];
      if (Et >> 5)
        throw new Error("Non 5-bit word");
      ht = polymodStep(ht) ^ Et, it += ALPHABET$1.charAt(Et);
    }
    for (let lt = 0; lt < 6; ++lt)
      ht = polymodStep(ht);
    ht ^= L;
    for (let lt = 0; lt < 6; ++lt) {
      const Et = ht >> (5 - lt) * 5 & 31;
      it += ALPHABET$1.charAt(Et);
    }
    return it;
  }
  function ne(Ce, rt) {
    if (rt = rt || 90, Ce.length < 8)
      return Ce + " too short";
    if (Ce.length > rt)
      return "Exceeds length limit";
    const at = Ce.toLowerCase(), ht = Ce.toUpperCase();
    if (Ce !== at && Ce !== ht)
      return "Mixed-case string " + Ce;
    Ce = at;
    const it = Ce.lastIndexOf("1");
    if (it === -1)
      return "No separator character for " + Ce;
    if (it === 0)
      return "Missing prefix for " + Ce;
    const lt = Ce.slice(0, it), Et = Ce.slice(it + 1);
    if (Et.length < 6)
      return "Data too short";
    let wt = prefixChk(lt);
    if (typeof wt == "string")
      return wt;
    const Rt = [];
    for (let Mt = 0; Mt < Et.length; ++Mt) {
      const Lt = Et.charAt(Mt), zt = ALPHABET_MAP[Lt];
      if (zt === void 0)
        return "Unknown character " + Lt;
      wt = polymodStep(wt) ^ zt, !(Mt + 6 >= Et.length) && Rt.push(zt);
    }
    return wt !== L ? "Invalid checksum for " + Ce : { prefix: lt, words: Rt };
  }
  function oe(Ce, rt) {
    const at = ne(Ce, rt);
    if (typeof at == "object")
      return at;
  }
  function ce(Ce, rt) {
    const at = ne(Ce, rt);
    if (typeof at == "object")
      return at;
    throw new Error(at);
  }
  return {
    decodeUnsafe: oe,
    decode: ce,
    encode: J,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist$1.bech32 = getLibraryFromEncoding("bech32");
dist$1.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$6, networks_1$2 = networks$2, bscript$4 = requireScript(), types_1$2 = types$7, lazy$1 = lazy$7, bech32_1$1 = dist$1, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$D.alloc(0);
function p2wpkh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const J = lazy$1.value(() => {
    const ce = bech32_1$1.bech32.decode(B.address), Ce = ce.words.shift(), rt = bech32_1$1.bech32.fromWords(ce.words);
    return {
      version: Ce,
      prefix: ce.prefix,
      data: Buffer$D.from(rt)
    };
  }), ne = B.network || networks_1$2.bitcoin, oe = { name: "p2wpkh", network: ne };
  if (lazy$1.prop(oe, "address", () => {
    if (!oe.hash) return;
    const ce = bech32_1$1.bech32.toWords(oe.hash);
    return ce.unshift(0), bech32_1$1.bech32.encode(ne.bech32, ce);
  }), lazy$1.prop(oe, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return J().data;
    if (B.pubkey || oe.pubkey) return bcrypto$3.hash160(B.pubkey || oe.pubkey);
  }), lazy$1.prop(oe, "output", () => {
    if (oe.hash)
      return bscript$4.compile([OPS$1.OP_0, oe.hash]);
  }), lazy$1.prop(oe, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(oe, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(oe, "input", () => {
    if (oe.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(oe, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), L.validate) {
    let ce = Buffer$D.from([]);
    if (B.address) {
      if (ne && ne.bech32 !== J().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (J().version !== 0)
        throw new TypeError("Invalid address version");
      if (J().data.length !== 20)
        throw new TypeError("Invalid address data");
      ce = J().data;
    }
    if (B.hash) {
      if (ce.length > 0 && !ce.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ce = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (ce.length > 0 && !ce.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      ce = B.output.slice(2);
    }
    if (B.pubkey) {
      const Ce = bcrypto$3.hash160(B.pubkey);
      if (ce.length > 0 && !ce.equals(Ce))
        throw new TypeError("Hash mismatch");
      if (ce = Ce, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const Ce = bcrypto$3.hash160(B.witness[1]);
      if (ce.length > 0 && !ce.equals(Ce))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(oe, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$6, networks_1$1 = networks$2, bscript$3 = requireScript(), types_1$1 = types$7, lazy = lazy$7, bech32_1 = dist$1, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$D.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$D.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, L) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const J = lazy.value(() => {
    const Ce = bech32_1.bech32.decode(B.address), rt = Ce.words.shift(), at = bech32_1.bech32.fromWords(Ce.words);
    return {
      version: rt,
      prefix: Ce.prefix,
      data: Buffer$D.from(at)
    };
  }), ne = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let oe = B.network;
  oe || (oe = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const ce = { network: oe };
  if (lazy.prop(ce, "address", () => {
    if (!ce.hash) return;
    const Ce = bech32_1.bech32.toWords(ce.hash);
    return Ce.unshift(0), bech32_1.bech32.encode(oe.bech32, Ce);
  }), lazy.prop(ce, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return J().data;
    if (ce.redeem && ce.redeem.output) return bcrypto$2.sha256(ce.redeem.output);
  }), lazy.prop(ce, "output", () => {
    if (ce.hash)
      return bscript$3.compile([OPS.OP_0, ce.hash]);
  }), lazy.prop(ce, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(ce, "input", () => {
    if (ce.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(ce, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const Ce = bscript$3.toStack(ne());
      return ce.redeem = Object.assign({ witness: Ce }, B.redeem), ce.redeem.input = EMPTY_BUFFER$1, [].concat(Ce, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(ce, "name", () => {
    const Ce = ["p2wsh"];
    return ce.redeem !== void 0 && ce.redeem.name !== void 0 && Ce.push(ce.redeem.name), Ce.join("-");
  }), L.validate) {
    let Ce = Buffer$D.from([]);
    if (B.address) {
      if (J().prefix !== oe.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (J().version !== 0)
        throw new TypeError("Invalid address version");
      if (J().data.length !== 32)
        throw new TypeError("Invalid address data");
      Ce = J().data;
    }
    if (B.hash) {
      if (Ce.length > 0 && !Ce.equals(B.hash))
        throw new TypeError("Hash mismatch");
      Ce = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const rt = B.output.slice(2);
      if (Ce.length > 0 && !Ce.equals(rt))
        throw new TypeError("Hash mismatch");
      Ce = rt;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== oe)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const rt = bscript$3.decompile(B.redeem.output);
        if (!rt || rt.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(rt) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const at = bcrypto$2.sha256(B.redeem.output);
        if (Ce.length > 0 && !Ce.equals(at))
          throw new TypeError("Hash mismatch");
        Ce = at;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(ne()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && ne().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const rt = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(rt))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(rt) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(ce, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h$3 = (B) => Buffer$D.from(B, "hex");
function verifyEcc(B) {
  assert$l(typeof B.isXOnlyPoint == "function"), assert$l(
    B.isXOnlyPoint(
      h$3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert$l(
    B.isXOnlyPoint(
      h$3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert$l(
    B.isXOnlyPoint(
      h$3("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert$l(
    B.isXOnlyPoint(
      h$3("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert$l(
    !B.isXOnlyPoint(
      h$3("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert$l(
    !B.isXOnlyPoint(
      h$3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert$l(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((L) => {
    const J = B.xOnlyPointAddTweak(h$3(L.pubkey), h$3(L.tweak));
    L.result === null ? assert$l(J === null) : (assert$l(J !== null), assert$l(J.parity === L.parity), assert$l(Buffer$D.from(J.xOnlyPubkey).equals(h$3(L.result))));
  });
}
function assert$l(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, L) {
  var J = require$$1$2, ne = J.Buffer;
  function oe(Ce, rt) {
    for (var at in Ce)
      rt[at] = Ce[at];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = J : (oe(J, L), L.Buffer = ce);
  function ce(Ce, rt, at) {
    return ne(Ce, rt, at);
  }
  ce.prototype = Object.create(ne.prototype), oe(ne, ce), ce.from = function(Ce, rt, at) {
    if (typeof Ce == "number")
      throw new TypeError("Argument must not be a number");
    return ne(Ce, rt, at);
  }, ce.alloc = function(Ce, rt, at) {
    if (typeof Ce != "number")
      throw new TypeError("Argument must be a number");
    var ht = ne(Ce);
    return rt !== void 0 ? typeof at == "string" ? ht.fill(rt, at) : ht.fill(rt) : ht.fill(0), ht;
  }, ce.allocUnsafe = function(Ce) {
    if (typeof Ce != "number")
      throw new TypeError("Argument must be a number");
    return ne(Ce);
  }, ce.allocUnsafeSlow = function(Ce) {
    if (typeof Ce != "number")
      throw new TypeError("Argument must be a number");
    return J.SlowBuffer(Ce);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, Buffer$C = safeBufferExports$1.Buffer, MAX_SAFE_INTEGER$2 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$2 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$h(B, L, J) {
  if (checkUInt53$1(B), L || (L = Buffer$C.allocUnsafe(encodingLength$1(B))), !Buffer$C.isBuffer(L)) throw new TypeError("buffer must be a Buffer instance");
  return J || (J = 0), B < 253 ? (L.writeUInt8(B, J), encode$h.bytes = 1) : B <= 65535 ? (L.writeUInt8(253, J), L.writeUInt16LE(B, J + 1), encode$h.bytes = 3) : B <= 4294967295 ? (L.writeUInt8(254, J), L.writeUInt32LE(B, J + 1), encode$h.bytes = 5) : (L.writeUInt8(255, J), L.writeUInt32LE(B >>> 0, J + 1), L.writeUInt32LE(B / 4294967296 | 0, J + 5), encode$h.bytes = 9), L;
}
function decode$h(B, L) {
  if (!Buffer$C.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  L || (L = 0);
  var J = B.readUInt8(L);
  if (J < 253)
    return decode$h.bytes = 1, J;
  if (J === 253)
    return decode$h.bytes = 3, B.readUInt16LE(L + 1);
  if (J === 254)
    return decode$h.bytes = 5, B.readUInt32LE(L + 1);
  decode$h.bytes = 9;
  var ne = B.readUInt32LE(L + 1), oe = B.readUInt32LE(L + 5), ce = oe * 4294967296 + ne;
  return checkUInt53$1(ce), ce;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$h, decode: decode$h, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$5 = types$7, { typeforce: typeforce$3 } = types$5, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, L) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > L) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, L) {
  const J = B.readUInt32LE(L);
  let ne = B.readUInt32LE(L + 4);
  return ne *= 4294967296, verifuint$1(ne + J, 9007199254740991), ne + J;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, L, J) {
  return verifuint$1(L, 9007199254740991), B.writeInt32LE(L & -1, J), B.writeUInt32LE(Math.floor(L / 4294967296), J + 4), J + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$2(B) {
  if (B.length < 1) return B;
  let L = B.length - 1, J = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    J = B[ne], B[ne] = B[L], B[L] = J, L--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$2;
function cloneBuffer(B) {
  const L = Buffer$D.allocUnsafe(B.length);
  return B.copy(L), L;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(L) {
    return new BufferWriter(Buffer$D.alloc(L));
  }
  constructor(L, J = 0) {
    this.buffer = L, this.offset = J, typeforce$3(types$5.tuple(types$5.Buffer, types$5.UInt32), [L, J]);
  }
  writeUInt8(L) {
    this.offset = this.buffer.writeUInt8(L, this.offset);
  }
  writeInt32(L) {
    this.offset = this.buffer.writeInt32LE(L, this.offset);
  }
  writeUInt32(L) {
    this.offset = this.buffer.writeUInt32LE(L, this.offset);
  }
  writeUInt64(L) {
    this.offset = writeUInt64LE$1(this.buffer, L, this.offset);
  }
  writeVarInt(L) {
    varuint$7.encode(L, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(L) {
    if (this.buffer.length < this.offset + L.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += L.copy(this.buffer, this.offset);
  }
  writeVarSlice(L) {
    this.writeVarInt(L.length), this.writeSlice(L);
  }
  writeVector(L) {
    this.writeVarInt(L.length), L.forEach((J) => this.writeVarSlice(J));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(L, J = 0) {
    this.buffer = L, this.offset = J, typeforce$3(types$5.tuple(types$5.Buffer, types$5.UInt32), [L, J]);
  }
  readUInt8() {
    const L = this.buffer.readUInt8(this.offset);
    return this.offset++, L;
  }
  readInt32() {
    const L = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, L;
  }
  readUInt32() {
    const L = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, L;
  }
  readUInt64() {
    const L = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, L;
  }
  readVarInt() {
    const L = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, L;
  }
  readSlice(L) {
    if (this.buffer.length < this.offset + L)
      throw new Error("Cannot read slice out of bounds");
    const J = this.buffer.slice(this.offset, this.offset + L);
    return this.offset += L, J;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const L = this.readVarInt(), J = [];
    for (let ne = 0; ne < L; ne++) J.push(this.readVarSlice());
    return J;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const L = require$$1$2, J = ecc_lib, ne = crypto$6, oe = bufferutils, ce = types$7;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const Ce = (Mt) => "left" in Mt && "right" in Mt;
  function rt(Mt, Lt) {
    if (Mt.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${Mt.length}, expected min 33.`
      );
    const zt = (Mt.length - 33) / 32;
    let Ot = Lt;
    for (let It = 0; It < zt; It++) {
      const Ft = Mt.slice(33 + 32 * It, 65 + 32 * It);
      Ot.compare(Ft) < 0 ? Ot = wt(Ot, Ft) : Ot = wt(Ft, Ot);
    }
    return Ot;
  }
  B.rootHashFromPath = rt;
  function at(Mt) {
    if ((0, ce.isTapleaf)(Mt))
      return { hash: it(Mt) };
    const Lt = [at(Mt[0]), at(Mt[1])];
    Lt.sort((It, Ft) => It.hash.compare(Ft.hash));
    const [zt, Ot] = Lt;
    return {
      hash: wt(zt.hash, Ot.hash),
      left: zt,
      right: Ot
    };
  }
  B.toHashTree = at;
  function ht(Mt, Lt) {
    if (Ce(Mt)) {
      const zt = ht(Mt.left, Lt);
      if (zt !== void 0) return [...zt, Mt.right.hash];
      const Ot = ht(Mt.right, Lt);
      if (Ot !== void 0) return [...Ot, Mt.left.hash];
    } else if (Mt.hash.equals(Lt))
      return [];
  }
  B.findScriptPath = ht;
  function it(Mt) {
    const Lt = Mt.version || B.LEAF_VERSION_TAPSCRIPT;
    return ne.taggedHash(
      "TapLeaf",
      L.Buffer.concat([
        L.Buffer.from([Lt]),
        Rt(Mt.output)
      ])
    );
  }
  B.tapleafHash = it;
  function lt(Mt, Lt) {
    return ne.taggedHash(
      "TapTweak",
      L.Buffer.concat(Lt ? [Mt, Lt] : [Mt])
    );
  }
  B.tapTweakHash = lt;
  function Et(Mt, Lt) {
    if (!L.Buffer.isBuffer(Mt) || Mt.length !== 32 || Lt && Lt.length !== 32) return null;
    const zt = lt(Mt, Lt), Ot = (0, J.getEccLib)().xOnlyPointAddTweak(Mt, zt);
    return !Ot || Ot.xOnlyPubkey === null ? null : {
      parity: Ot.parity,
      x: L.Buffer.from(Ot.xOnlyPubkey)
    };
  }
  B.tweakKey = Et;
  function wt(Mt, Lt) {
    return ne.taggedHash("TapBranch", L.Buffer.concat([Mt, Lt]));
  }
  function Rt(Mt) {
    const Lt = oe.varuint.encodingLength(Mt.length), zt = L.Buffer.allocUnsafe(Lt);
    return oe.varuint.encode(Mt.length, zt), L.Buffer.concat([zt, Mt]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = require$$1$2, L = networks$2, J = requireScript(), ne = types$7, oe = ecc_lib, ce = bip341, Ce = lazy$7, rt = dist$1, at = requireAddress(), ht = J.OPS, it = 1, lt = 80;
  function Et(wt, Rt) {
    if (!wt.address && !wt.output && !wt.pubkey && !wt.internalPubkey && !(wt.witness && wt.witness.length > 1))
      throw new TypeError("Not enough data");
    Rt = Object.assign({ validate: !0 }, Rt || {}), (0, ne.typeforce)(
      {
        address: ne.typeforce.maybe(ne.typeforce.String),
        input: ne.typeforce.maybe(ne.typeforce.BufferN(0)),
        network: ne.typeforce.maybe(ne.typeforce.Object),
        output: ne.typeforce.maybe(ne.typeforce.BufferN(34)),
        internalPubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        hash: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        pubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        signature: ne.typeforce.maybe(
          ne.typeforce.anyOf(
            ne.typeforce.BufferN(64),
            ne.typeforce.BufferN(65)
          )
        ),
        witness: ne.typeforce.maybe(
          ne.typeforce.arrayOf(ne.typeforce.Buffer)
        ),
        scriptTree: ne.typeforce.maybe(ne.isTaptree),
        redeem: ne.typeforce.maybe({
          output: ne.typeforce.maybe(ne.typeforce.Buffer),
          redeemVersion: ne.typeforce.maybe(ne.typeforce.Number),
          witness: ne.typeforce.maybe(
            ne.typeforce.arrayOf(ne.typeforce.Buffer)
          )
        }),
        redeemVersion: ne.typeforce.maybe(ne.typeforce.Number)
      },
      wt
    );
    const Mt = Ce.value(() => (0, at.fromBech32)(wt.address)), Lt = Ce.value(() => {
      if (!(!wt.witness || !wt.witness.length))
        return wt.witness.length >= 2 && wt.witness[wt.witness.length - 1][0] === lt ? wt.witness.slice(0, -1) : wt.witness.slice();
    }), zt = Ce.value(() => {
      if (wt.scriptTree) return (0, ce.toHashTree)(wt.scriptTree);
      if (wt.hash) return { hash: wt.hash };
    }), Ot = wt.network || L.bitcoin, It = { name: "p2tr", network: Ot };
    if (Ce.prop(It, "address", () => {
      if (!It.pubkey) return;
      const Ft = rt.bech32m.toWords(It.pubkey);
      return Ft.unshift(it), rt.bech32m.encode(Ot.bech32, Ft);
    }), Ce.prop(It, "hash", () => {
      const Ft = zt();
      if (Ft) return Ft.hash;
      const Jt = Lt();
      if (Jt && Jt.length > 1) {
        const Vt = Jt[Jt.length - 1], yr = Vt[0] & ne.TAPLEAF_VERSION_MASK, jt = Jt[Jt.length - 2], Ut = (0, ce.tapleafHash)({
          output: jt,
          version: yr
        });
        return (0, ce.rootHashFromPath)(Vt, Ut);
      }
      return null;
    }), Ce.prop(It, "output", () => {
      if (It.pubkey)
        return J.compile([ht.OP_1, It.pubkey]);
    }), Ce.prop(It, "redeemVersion", () => wt.redeemVersion ? wt.redeemVersion : wt.redeem && wt.redeem.redeemVersion !== void 0 && wt.redeem.redeemVersion !== null ? wt.redeem.redeemVersion : ce.LEAF_VERSION_TAPSCRIPT), Ce.prop(It, "redeem", () => {
      const Ft = Lt();
      if (!(!Ft || Ft.length < 2))
        return {
          output: Ft[Ft.length - 2],
          witness: Ft.slice(0, -2),
          redeemVersion: Ft[Ft.length - 1][0] & ne.TAPLEAF_VERSION_MASK
        };
    }), Ce.prop(It, "pubkey", () => {
      if (wt.pubkey) return wt.pubkey;
      if (wt.output) return wt.output.slice(2);
      if (wt.address) return Mt().data;
      if (It.internalPubkey) {
        const Ft = (0, ce.tweakKey)(It.internalPubkey, It.hash);
        if (Ft) return Ft.x;
      }
    }), Ce.prop(It, "internalPubkey", () => {
      if (wt.internalPubkey) return wt.internalPubkey;
      const Ft = Lt();
      if (Ft && Ft.length > 1)
        return Ft[Ft.length - 1].slice(1, 33);
    }), Ce.prop(It, "signature", () => {
      if (wt.signature) return wt.signature;
      const Ft = Lt();
      if (!(!Ft || Ft.length !== 1))
        return Ft[0];
    }), Ce.prop(It, "witness", () => {
      if (wt.witness) return wt.witness;
      const Ft = zt();
      if (Ft && wt.redeem && wt.redeem.output && wt.internalPubkey) {
        const Jt = (0, ce.tapleafHash)({
          output: wt.redeem.output,
          version: It.redeemVersion
        }), Vt = (0, ce.findScriptPath)(Ft, Jt);
        if (!Vt) return;
        const yr = (0, ce.tweakKey)(wt.internalPubkey, Ft.hash);
        if (!yr) return;
        const jt = B.Buffer.concat(
          [
            B.Buffer.from([It.redeemVersion | yr.parity]),
            wt.internalPubkey
          ].concat(Vt)
        );
        return [wt.redeem.output, jt];
      }
      if (wt.signature) return [wt.signature];
    }), Rt.validate) {
      let Ft = B.Buffer.from([]);
      if (wt.address) {
        if (Ot && Ot.bech32 !== Mt().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (Mt().version !== it)
          throw new TypeError("Invalid address version");
        if (Mt().data.length !== 32)
          throw new TypeError("Invalid address data");
        Ft = Mt().data;
      }
      if (wt.pubkey) {
        if (Ft.length > 0 && !Ft.equals(wt.pubkey))
          throw new TypeError("Pubkey mismatch");
        Ft = wt.pubkey;
      }
      if (wt.output) {
        if (wt.output.length !== 34 || wt.output[0] !== ht.OP_1 || wt.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (Ft.length > 0 && !Ft.equals(wt.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        Ft = wt.output.slice(2);
      }
      if (wt.internalPubkey) {
        const yr = (0, ce.tweakKey)(wt.internalPubkey, It.hash);
        if (Ft.length > 0 && !Ft.equals(yr.x))
          throw new TypeError("Pubkey mismatch");
        Ft = yr.x;
      }
      if (Ft && Ft.length && !(0, oe.getEccLib)().isXOnlyPoint(Ft))
        throw new TypeError("Invalid pubkey for p2tr");
      const Jt = zt();
      if (wt.hash && Jt && !wt.hash.equals(Jt.hash))
        throw new TypeError("Hash mismatch");
      if (wt.redeem && wt.redeem.output && Jt) {
        const yr = (0, ce.tapleafHash)({
          output: wt.redeem.output,
          version: It.redeemVersion
        });
        if (!(0, ce.findScriptPath)(Jt, yr))
          throw new TypeError("Redeem script not in tree");
      }
      const Vt = Lt();
      if (wt.redeem && It.redeem) {
        if (wt.redeem.redeemVersion && wt.redeem.redeemVersion !== It.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (wt.redeem.output) {
          if (J.decompile(wt.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (It.redeem.output && !wt.redeem.output.equals(It.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (wt.redeem.witness && It.redeem.witness && !(0, ne.stacksEqual)(wt.redeem.witness, It.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Vt && Vt.length)
        if (Vt.length === 1) {
          if (wt.signature && !wt.signature.equals(Vt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const yr = Vt[Vt.length - 1];
          if (yr.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${yr.length}, expected min 33.`
            );
          if ((yr.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${yr.length} is incorrect!`
            );
          const jt = (yr.length - 33) / 32;
          if (jt > 128)
            throw new TypeError(
              `The script path is too long. Got ${jt}, expected max 128.`
            );
          const Ut = yr.slice(1, 33);
          if (wt.internalPubkey && !wt.internalPubkey.equals(Ut))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, oe.getEccLib)().isXOnlyPoint(Ut))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const er = yr[0] & ne.TAPLEAF_VERSION_MASK, Ht = Vt[Vt.length - 2], ct = (0, ce.tapleafHash)({
            output: Ht,
            version: er
          }), dt = (0, ce.rootHashFromPath)(yr, ct), ot = (0, ce.tweakKey)(Ut, dt);
          if (!ot)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (Ft.length && !Ft.equals(ot.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (ot.parity !== (yr[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(It, wt);
  }
  return p2tr.p2tr = Et, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const L = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return L.p2data;
      }
    });
    const J = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return J.p2ms;
      }
    });
    const ne = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return ne.p2pk;
      }
    });
    const oe = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return oe.p2pkh;
      }
    });
    const ce = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return ce.p2sh;
      }
    });
    const Ce = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return Ce.p2wpkh;
      }
    });
    const rt = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return rt.p2wsh;
      }
    });
    const at = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return at.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks$2, L = requirePayments(), J = requireScript(), ne = types$7, oe = dist$1, ce = bs58check$5, Ce = 40, rt = 2, at = 16, ht = 2, it = 80, lt = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Et(It, Ft) {
    const Jt = It.slice(2);
    if (Jt.length < rt || Jt.length > Ce)
      throw new TypeError("Invalid program length for segwit address");
    const Vt = It[0] - it;
    if (Vt < ht || Vt > at)
      throw new TypeError("Invalid version for segwit address");
    if (It[1] !== Jt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(lt), Lt(Jt, Vt, Ft.bech32);
  }
  function wt(It) {
    const Ft = Buffer$D.from(ce.decode(It));
    if (Ft.length < 21) throw new TypeError(It + " is too short");
    if (Ft.length > 21) throw new TypeError(It + " is too long");
    const Jt = Ft.readUInt8(0), Vt = Ft.slice(1);
    return { version: Jt, hash: Vt };
  }
  address.fromBase58Check = wt;
  function Rt(It) {
    let Ft, Jt;
    try {
      Ft = oe.bech32.decode(It);
    } catch {
    }
    if (Ft) {
      if (Jt = Ft.words[0], Jt !== 0) throw new TypeError(It + " uses wrong encoding");
    } else if (Ft = oe.bech32m.decode(It), Jt = Ft.words[0], Jt === 0) throw new TypeError(It + " uses wrong encoding");
    const Vt = oe.bech32.fromWords(Ft.words.slice(1));
    return {
      version: Jt,
      prefix: Ft.prefix,
      data: Buffer$D.from(Vt)
    };
  }
  address.fromBech32 = Rt;
  function Mt(It, Ft) {
    (0, ne.typeforce)(
      (0, ne.tuple)(ne.Hash160bit, ne.UInt8),
      arguments
    );
    const Jt = Buffer$D.allocUnsafe(21);
    return Jt.writeUInt8(Ft, 0), It.copy(Jt, 1), ce.encode(Jt);
  }
  address.toBase58Check = Mt;
  function Lt(It, Ft, Jt) {
    const Vt = oe.bech32.toWords(It);
    return Vt.unshift(Ft), Ft === 0 ? oe.bech32.encode(Jt, Vt) : oe.bech32m.encode(Jt, Vt);
  }
  address.toBech32 = Lt;
  function zt(It, Ft) {
    Ft = Ft || B.bitcoin;
    try {
      return L.p2pkh({ output: It, network: Ft }).address;
    } catch {
    }
    try {
      return L.p2sh({ output: It, network: Ft }).address;
    } catch {
    }
    try {
      return L.p2wpkh({ output: It, network: Ft }).address;
    } catch {
    }
    try {
      return L.p2wsh({ output: It, network: Ft }).address;
    } catch {
    }
    try {
      return L.p2tr({ output: It, network: Ft }).address;
    } catch {
    }
    try {
      return Et(It, Ft);
    } catch {
    }
    throw new Error(J.toASM(It) + " has no matching Address");
  }
  address.fromOutputScript = zt;
  function Ot(It, Ft) {
    Ft = Ft || B.bitcoin;
    let Jt, Vt;
    try {
      Jt = wt(It);
    } catch {
    }
    if (Jt) {
      if (Jt.version === Ft.pubKeyHash)
        return L.p2pkh({ hash: Jt.hash }).output;
      if (Jt.version === Ft.scriptHash)
        return L.p2sh({ hash: Jt.hash }).output;
    } else {
      try {
        Vt = Rt(It);
      } catch {
      }
      if (Vt) {
        if (Vt.prefix !== Ft.bech32)
          throw new Error(It + " has an invalid prefix");
        if (Vt.version === 0) {
          if (Vt.data.length === 20)
            return L.p2wpkh({ hash: Vt.data }).output;
          if (Vt.data.length === 32)
            return L.p2wsh({ hash: Vt.data }).output;
        } else if (Vt.version === 1) {
          if (Vt.data.length === 32)
            return L.p2tr({ pubkey: Vt.data }).output;
        } else if (Vt.version >= ht && Vt.version <= at && Vt.data.length >= rt && Vt.data.length <= Ce)
          return console.warn(lt), J.compile([
            Vt.version + it,
            Vt.data
          ]);
      }
    }
    throw new Error(It + " has no matching Script");
  }
  return address.toOutputScript = Ot, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, L) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof L != "function")
    throw TypeError("Expected digest Function");
  let J = B.length;
  const ne = B.concat();
  for (; J > 1; ) {
    let oe = 0;
    for (let ce = 0; ce < J; ce += 2, ++oe) {
      const Ce = ne[ce], rt = ce + 1 === J ? Ce : ne[ce + 1], at = Buffer$D.concat([Ce, rt]);
      ne[oe] = L(at);
    }
    J = oe;
  }
  return ne[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$6, bscript$2 = requireScript(), script_1 = requireScript(), types$4 = types$7, { typeforce: typeforce$2 } = types$4;
function varSliceSize(B) {
  const L = B.length;
  return bufferutils_1$2.varuint.encodingLength(L) + L;
}
function vectorSize(B) {
  const L = B.length;
  return bufferutils_1$2.varuint.encodingLength(L) + B.reduce((J, ne) => J + varSliceSize(ne), 0);
}
const EMPTY_BUFFER = Buffer$D.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$D.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(L, J) {
    const ne = new bufferutils_1$2.BufferReader(L), oe = new Transaction();
    oe.version = ne.readInt32();
    const ce = ne.readUInt8(), Ce = ne.readUInt8();
    let rt = !1;
    ce === Transaction.ADVANCED_TRANSACTION_MARKER && Ce === Transaction.ADVANCED_TRANSACTION_FLAG ? rt = !0 : ne.offset -= 2;
    const at = ne.readVarInt();
    for (let it = 0; it < at; ++it)
      oe.ins.push({
        hash: ne.readSlice(32),
        index: ne.readUInt32(),
        script: ne.readVarSlice(),
        sequence: ne.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const ht = ne.readVarInt();
    for (let it = 0; it < ht; ++it)
      oe.outs.push({
        value: ne.readUInt64(),
        script: ne.readVarSlice()
      });
    if (rt) {
      for (let it = 0; it < at; ++it)
        oe.ins[it].witness = ne.readVector();
      if (!oe.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (oe.locktime = ne.readUInt32(), J) return oe;
    if (ne.offset !== L.length)
      throw new Error("Transaction has unexpected data");
    return oe;
  }
  static fromHex(L) {
    return Transaction.fromBuffer(Buffer$D.from(L, "hex"), !1);
  }
  static isCoinbaseHash(L) {
    typeforce$2(types$4.Hash256bit, L);
    for (let J = 0; J < 32; ++J)
      if (L[J] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(L, J, ne, oe) {
    return typeforce$2(
      types$4.tuple(
        types$4.Hash256bit,
        types$4.UInt32,
        types$4.maybe(types$4.UInt32),
        types$4.maybe(types$4.Buffer)
      ),
      arguments
    ), types$4.Null(ne) && (ne = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: L,
      index: J,
      script: oe || EMPTY_BUFFER,
      sequence: ne,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(L, J) {
    return typeforce$2(types$4.tuple(types$4.Buffer, types$4.Satoshi), arguments), this.outs.push({
      script: L,
      value: J
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((L) => L.witness.length !== 0);
  }
  weight() {
    const L = this.byteLength(!1), J = this.byteLength(!0);
    return L * 3 + J;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(L = !0) {
    const J = L && this.hasWitnesses();
    return (J ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((ne, oe) => ne + 40 + varSliceSize(oe.script), 0) + this.outs.reduce((ne, oe) => ne + 8 + varSliceSize(oe.script), 0) + (J ? this.ins.reduce((ne, oe) => ne + vectorSize(oe.witness), 0) : 0);
  }
  clone() {
    const L = new Transaction();
    return L.version = this.version, L.locktime = this.locktime, L.ins = this.ins.map((J) => ({
      hash: J.hash,
      index: J.index,
      script: J.script,
      sequence: J.sequence,
      witness: J.witness
    })), L.outs = this.outs.map((J) => ({
      script: J.script,
      value: J.value
    })), L;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(L, J, ne) {
    if (typeforce$2(
      types$4.tuple(
        types$4.UInt32,
        types$4.Buffer,
        /* types.UInt8 */
        types$4.Number
      ),
      arguments
    ), L >= this.ins.length) return ONE;
    const oe = bscript$2.compile(
      bscript$2.decompile(J).filter((rt) => rt !== script_1.OPS.OP_CODESEPARATOR)
    ), ce = this.clone();
    if ((ne & 31) === Transaction.SIGHASH_NONE)
      ce.outs = [], ce.ins.forEach((rt, at) => {
        at !== L && (rt.sequence = 0);
      });
    else if ((ne & 31) === Transaction.SIGHASH_SINGLE) {
      if (L >= this.outs.length) return ONE;
      ce.outs.length = L + 1;
      for (let rt = 0; rt < L; rt++)
        ce.outs[rt] = BLANK_OUTPUT;
      ce.ins.forEach((rt, at) => {
        at !== L && (rt.sequence = 0);
      });
    }
    ne & Transaction.SIGHASH_ANYONECANPAY ? (ce.ins = [ce.ins[L]], ce.ins[0].script = oe) : (ce.ins.forEach((rt) => {
      rt.script = EMPTY_BUFFER;
    }), ce.ins[L].script = oe);
    const Ce = Buffer$D.allocUnsafe(ce.byteLength(!1) + 4);
    return Ce.writeInt32LE(ne, Ce.length - 4), ce.__toBuffer(Ce, 0, !1), bcrypto$1.hash256(Ce);
  }
  hashForWitnessV1(L, J, ne, oe, ce, Ce) {
    if (typeforce$2(
      types$4.tuple(
        types$4.UInt32,
        typeforce$2.arrayOf(types$4.Buffer),
        typeforce$2.arrayOf(types$4.Satoshi),
        types$4.UInt32
      ),
      arguments
    ), ne.length !== this.ins.length || J.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const rt = oe === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : oe & Transaction.SIGHASH_OUTPUT_MASK, ht = (oe & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, it = rt === Transaction.SIGHASH_NONE, lt = rt === Transaction.SIGHASH_SINGLE;
    let Et = EMPTY_BUFFER, wt = EMPTY_BUFFER, Rt = EMPTY_BUFFER, Mt = EMPTY_BUFFER, Lt = EMPTY_BUFFER;
    if (!ht) {
      let Ft = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Jt) => {
        Ft.writeSlice(Jt.hash), Ft.writeUInt32(Jt.index);
      }), Et = bcrypto$1.sha256(Ft.end()), Ft = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), ne.forEach((Jt) => Ft.writeUInt64(Jt)), wt = bcrypto$1.sha256(Ft.end()), Ft = bufferutils_1$2.BufferWriter.withCapacity(
        J.map(varSliceSize).reduce((Jt, Vt) => Jt + Vt)
      ), J.forEach(
        (Jt) => Ft.writeVarSlice(Jt)
      ), Rt = bcrypto$1.sha256(Ft.end()), Ft = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Jt) => Ft.writeUInt32(Jt.sequence)), Mt = bcrypto$1.sha256(Ft.end());
    }
    if (it || lt) {
      if (lt && L < this.outs.length) {
        const Ft = this.outs[L], Jt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(Ft.script)
        );
        Jt.writeUInt64(Ft.value), Jt.writeVarSlice(Ft.script), Lt = bcrypto$1.sha256(Jt.end());
      }
    } else {
      const Ft = this.outs.map((Vt) => 8 + varSliceSize(Vt.script)).reduce((Vt, yr) => Vt + yr), Jt = bufferutils_1$2.BufferWriter.withCapacity(Ft);
      this.outs.forEach((Vt) => {
        Jt.writeUInt64(Vt.value), Jt.writeVarSlice(Vt.script);
      }), Lt = bcrypto$1.sha256(Jt.end());
    }
    const zt = (ce ? 2 : 0) + (Ce ? 1 : 0), Ot = 174 - (ht ? 49 : 0) - (it ? 32 : 0) + (Ce ? 32 : 0) + (ce ? 37 : 0), It = bufferutils_1$2.BufferWriter.withCapacity(Ot);
    if (It.writeUInt8(oe), It.writeInt32(this.version), It.writeUInt32(this.locktime), It.writeSlice(Et), It.writeSlice(wt), It.writeSlice(Rt), It.writeSlice(Mt), it || lt || It.writeSlice(Lt), It.writeUInt8(zt), ht) {
      const Ft = this.ins[L];
      It.writeSlice(Ft.hash), It.writeUInt32(Ft.index), It.writeUInt64(ne[L]), It.writeVarSlice(J[L]), It.writeUInt32(Ft.sequence);
    } else
      It.writeUInt32(L);
    if (Ce) {
      const Ft = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(Ce)
      );
      Ft.writeVarSlice(Ce), It.writeSlice(bcrypto$1.sha256(Ft.end()));
    }
    return lt && It.writeSlice(Lt), ce && (It.writeSlice(ce), It.writeUInt8(0), It.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$D.concat([Buffer$D.from([0]), It.end()])
    );
  }
  hashForWitnessV0(L, J, ne, oe) {
    typeforce$2(
      types$4.tuple(types$4.UInt32, types$4.Buffer, types$4.Satoshi, types$4.UInt32),
      arguments
    );
    let ce = Buffer$D.from([]), Ce, rt = ZERO, at = ZERO, ht = ZERO;
    if (oe & Transaction.SIGHASH_ANYONECANPAY || (ce = Buffer$D.allocUnsafe(36 * this.ins.length), Ce = new bufferutils_1$2.BufferWriter(ce, 0), this.ins.forEach((lt) => {
      Ce.writeSlice(lt.hash), Ce.writeUInt32(lt.index);
    }), at = bcrypto$1.hash256(ce)), !(oe & Transaction.SIGHASH_ANYONECANPAY) && (oe & 31) !== Transaction.SIGHASH_SINGLE && (oe & 31) !== Transaction.SIGHASH_NONE && (ce = Buffer$D.allocUnsafe(4 * this.ins.length), Ce = new bufferutils_1$2.BufferWriter(ce, 0), this.ins.forEach((lt) => {
      Ce.writeUInt32(lt.sequence);
    }), ht = bcrypto$1.hash256(ce)), (oe & 31) !== Transaction.SIGHASH_SINGLE && (oe & 31) !== Transaction.SIGHASH_NONE) {
      const lt = this.outs.reduce((Et, wt) => Et + 8 + varSliceSize(wt.script), 0);
      ce = Buffer$D.allocUnsafe(lt), Ce = new bufferutils_1$2.BufferWriter(ce, 0), this.outs.forEach((Et) => {
        Ce.writeUInt64(Et.value), Ce.writeVarSlice(Et.script);
      }), rt = bcrypto$1.hash256(ce);
    } else if ((oe & 31) === Transaction.SIGHASH_SINGLE && L < this.outs.length) {
      const lt = this.outs[L];
      ce = Buffer$D.allocUnsafe(8 + varSliceSize(lt.script)), Ce = new bufferutils_1$2.BufferWriter(ce, 0), Ce.writeUInt64(lt.value), Ce.writeVarSlice(lt.script), rt = bcrypto$1.hash256(ce);
    }
    ce = Buffer$D.allocUnsafe(156 + varSliceSize(J)), Ce = new bufferutils_1$2.BufferWriter(ce, 0);
    const it = this.ins[L];
    return Ce.writeInt32(this.version), Ce.writeSlice(at), Ce.writeSlice(ht), Ce.writeSlice(it.hash), Ce.writeUInt32(it.index), Ce.writeVarSlice(J), Ce.writeUInt64(ne), Ce.writeUInt32(it.sequence), Ce.writeSlice(rt), Ce.writeUInt32(this.locktime), Ce.writeUInt32(oe), bcrypto$1.hash256(ce);
  }
  getHash(L) {
    return L && this.isCoinbase() ? Buffer$D.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, L));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(L, J) {
    return this.__toBuffer(L, J, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(L, J) {
    typeforce$2(types$4.tuple(types$4.Number, types$4.Buffer), arguments), this.ins[L].script = J;
  }
  setWitness(L, J) {
    typeforce$2(types$4.tuple(types$4.Number, [types$4.Buffer]), arguments), this.ins[L].witness = J;
  }
  __toBuffer(L, J, ne = !1) {
    L || (L = Buffer$D.allocUnsafe(this.byteLength(ne)));
    const oe = new bufferutils_1$2.BufferWriter(
      L,
      J || 0
    );
    oe.writeInt32(this.version);
    const ce = ne && this.hasWitnesses();
    return ce && (oe.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), oe.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), oe.writeVarInt(this.ins.length), this.ins.forEach((Ce) => {
      oe.writeSlice(Ce.hash), oe.writeUInt32(Ce.index), oe.writeVarSlice(Ce.script), oe.writeUInt32(Ce.sequence);
    }), oe.writeVarInt(this.outs.length), this.outs.forEach((Ce) => {
      isOutput(Ce) ? oe.writeUInt64(Ce.value) : oe.writeSlice(Ce.valueBuffer), oe.writeVarSlice(Ce.script);
    }), ce && this.ins.forEach((Ce) => {
      oe.writeVector(Ce.witness);
    }), oe.writeUInt32(this.locktime), J !== void 0 ? L.slice(J, oe.offset) : L;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$6, merkle_1 = merkle, transaction_1$3 = transaction, types$3 = types$7, { typeforce: typeforce$1 } = types$3, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(L) {
    if (L.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const J = new bufferutils_1$1.BufferReader(L), ne = new Block();
    if (ne.version = J.readInt32(), ne.prevHash = J.readSlice(32), ne.merkleRoot = J.readSlice(32), ne.timestamp = J.readUInt32(), ne.bits = J.readUInt32(), ne.nonce = J.readUInt32(), L.length === 80) return ne;
    const oe = () => {
      const rt = transaction_1$3.Transaction.fromBuffer(
        J.buffer.slice(J.offset),
        !0
      );
      return J.offset += rt.byteLength(), rt;
    }, ce = J.readVarInt();
    ne.transactions = [];
    for (let rt = 0; rt < ce; ++rt) {
      const at = oe();
      ne.transactions.push(at);
    }
    const Ce = ne.getWitnessCommit();
    return Ce && (ne.witnessCommit = Ce), ne;
  }
  static fromHex(L) {
    return Block.fromBuffer(Buffer$D.from(L, "hex"));
  }
  static calculateTarget(L) {
    const J = ((L & 4278190080) >> 24) - 3, ne = L & 8388607, oe = Buffer$D.alloc(32, 0);
    return oe.writeUIntBE(ne, 29 - J, 3), oe;
  }
  static calculateMerkleRoot(L, J) {
    if (typeforce$1([{ getHash: types$3.Function }], L), L.length === 0) throw errorMerkleNoTxes;
    if (J && !txesHaveWitnessCommit(L))
      throw errorWitnessNotSegwit;
    const ne = L.map(
      (ce) => ce.getHash(J)
    ), oe = (0, merkle_1.fastMerkleRoot)(ne, bcrypto.hash256);
    return J ? bcrypto.hash256(
      Buffer$D.concat([oe, L[0].ins[0].witness[0]])
    ) : oe;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const L = this.transactions[0].outs.filter(
      (ne) => ne.script.slice(0, 6).equals(Buffer$D.from("6a24aa21a9ed", "hex"))
    ).map((ne) => ne.script.slice(6, 38));
    if (L.length === 0) return null;
    const J = L[L.length - 1];
    return J instanceof Buffer$D && J.length === 32 ? J : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$D && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const L = this.byteLength(!1, !1), J = this.byteLength(!1, !0);
    return L * 3 + J;
  }
  byteLength(L, J = !0) {
    return L || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((ne, oe) => ne + oe.byteLength(J), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const L = /* @__PURE__ */ new Date(0);
    return L.setUTCSeconds(this.timestamp), L;
  }
  // TODO: buffer, offset compatibility
  toBuffer(L) {
    const J = Buffer$D.allocUnsafe(this.byteLength(L)), ne = new bufferutils_1$1.BufferWriter(J);
    return ne.writeInt32(this.version), ne.writeSlice(this.prevHash), ne.writeSlice(this.merkleRoot), ne.writeUInt32(this.timestamp), ne.writeUInt32(this.bits), ne.writeUInt32(this.nonce), L || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      J,
      ne.offset
    ), ne.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((oe) => {
      const ce = oe.byteLength();
      oe.toBuffer(J, ne.offset), ne.offset += ce;
    })), J;
  }
  toHex(L) {
    return this.toBuffer(L).toString("hex");
  }
  checkTxRoots() {
    const L = this.hasWitnessCommit();
    return !L && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (L ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const L = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), J = Block.calculateTarget(this.bits);
    return L.compare(J) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const L = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(L) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const L = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(L) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (L) => typeof L == "object" && L.ins instanceof Array && L.ins.some(
      (J) => typeof J == "object" && J.witness instanceof Array && J.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(L) {
    L[L.UNSIGNED_TX = 0] = "UNSIGNED_TX", L[L.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(L) {
    L[L.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", L[L.WITNESS_UTXO = 1] = "WITNESS_UTXO", L[L.PARTIAL_SIG = 2] = "PARTIAL_SIG", L[L.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", L[L.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", L[L.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", L[L.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", L[L.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", L[L.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", L[L.POR_COMMITMENT = 9] = "POR_COMMITMENT", L[L.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", L[L.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", L[L.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", L[L.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", L[L.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", L[L.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(L) {
    L[L.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", L[L.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", L[L.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", L[L.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", L[L.TAP_TREE = 6] = "TAP_TREE", L[L.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$3 = (B) => [...Array(B).keys()];
function decode$g(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const L = B.key.slice(1), J = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: L,
    path: "m"
  };
  for (const ne of range$3(B.value.length / 4 - 1)) {
    const oe = B.value.readUInt32LE(ne * 4 + 4), ce = !!(oe & 2147483648), Ce = oe & 2147483647;
    J.path += "/" + Ce.toString(10) + (ce ? "'" : "");
  }
  return J;
}
globalXpub$1.decode = decode$g;
function encode$g(B) {
  const L = Buffer$D.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), J = Buffer$D.concat([L, B.extendedPubkey]), ne = B.path.split("/"), oe = Buffer$D.allocUnsafe(ne.length * 4);
  B.masterFingerprint.copy(oe, 0);
  let ce = 4;
  return ne.slice(1).forEach((Ce) => {
    const rt = Ce.slice(-1) === "'";
    let at = 2147483647 & parseInt(rt ? Ce.slice(0, -1) : Ce, 10);
    rt && (at += 2147483648), oe.writeUInt32LE(at, ce), ce += 4;
  }), {
    key: J,
    value: oe
  };
}
globalXpub$1.encode = encode$g;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const L = B.extendedPubkey, J = B.masterFingerprint, ne = B.path;
  return Buffer$D.isBuffer(L) && L.length === 78 && [2, 3].indexOf(L[45]) > -1 && Buffer$D.isBuffer(J) && J.length === 4 && typeof ne == "string" && !!ne.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, L, J) {
  const ne = L.extendedPubkey.toString("hex");
  return J.has(ne) ? !1 : (J.add(ne), B.filter((oe) => oe.extendedPubkey.equals(L.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$f(B) {
  return {
    key: Buffer$D.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$f;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$f(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$f;
function encode$e(B) {
  return {
    key: Buffer$D.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$e;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$D.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, L) {
  return !!B && !!L && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$e(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$e;
function encode$d(B) {
  return {
    key: Buffer$D.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$d;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$D.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, L) {
  return !!B && !!L && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$d(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$d;
function encode$c(B) {
  return {
    key: Buffer$D.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$c;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$D.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, L) {
  return !!B && !!L && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$c;
function encode$b(B) {
  const L = Buffer$D.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$D.concat([L, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$b;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$D.isBuffer(B.pubkey) && Buffer$D.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$D.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const L = B[3];
  if (L > 33 || L < 1 || B[3 + L + 1] !== 2) return !1;
  const J = B[3 + L + 2];
  return !(J > 33 || J < 1 || B.length !== 3 + L + 2 + J + 2);
}
function canAddToArray$2(B, L, J) {
  const ne = L.pubkey.toString("hex");
  return J.has(ne) ? !1 : (J.add(ne), B.filter((oe) => oe.pubkey.equals(L.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$b;
function encode$a(B) {
  return {
    key: Buffer$D.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$D.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$a;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, L) {
  return !!B && !!L && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$a;
function encode$9(B) {
  const L = Buffer$D.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), J = Buffer$D.allocUnsafe(4);
  return J.writeUInt32LE(B, 0), {
    key: L,
    value: J
  };
}
sighashType$1.encode = encode$9;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, L) {
  return !!B && !!L && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$9;
function encode$8(B) {
  return { key: Buffer$D.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$8;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$D.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, L) {
  return !!B && !!L && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const L = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== L)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const J = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: J, leafVersion: L };
}
tapLeafScript$1.decode = decode$8;
function encode$7(B) {
  const L = Buffer$D.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), J = Buffer$D.from([B.leafVersion]);
  return {
    key: Buffer$D.concat([L, B.controlBlock]),
    value: Buffer$D.concat([B.script, J])
  };
}
tapLeafScript$1.encode = encode$7;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$D.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$D.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, L, J) {
  const ne = L.controlBlock.toString("hex");
  return J.has(ne) ? !1 : (J.add(ne), B.filter((oe) => oe.controlBlock.equals(L.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$7;
function encode$6(B) {
  return { key: Buffer$D.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$6;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$D.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, L) {
  return !!B && !!L && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const L = B.key.slice(1, 33), J = B.key.slice(33);
  return {
    pubkey: L,
    leafHash: J,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$6;
function encode$5(B) {
  const L = Buffer$D.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$D.concat([L, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$5;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$D.isBuffer(B.pubkey) && Buffer$D.isBuffer(B.leafHash) && Buffer$D.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, L, J) {
  const ne = L.pubkey.toString("hex") + L.leafHash.toString("hex");
  return J.has(ne) ? !1 : (J.add(ne), B.filter(
    (oe) => oe.pubkey.equals(L.pubkey) && oe.leafHash.equals(L.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$4(B, L, J) {
  if (checkUInt53(B), L || (L = Buffer$D.allocUnsafe(encodingLength(B))), !Buffer$D.isBuffer(L))
    throw new TypeError("buffer must be a Buffer instance");
  return J || (J = 0), B < 253 ? (L.writeUInt8(B, J), Object.assign(encode$4, { bytes: 1 })) : B <= 65535 ? (L.writeUInt8(253, J), L.writeUInt16LE(B, J + 1), Object.assign(encode$4, { bytes: 3 })) : B <= 4294967295 ? (L.writeUInt8(254, J), L.writeUInt32LE(B, J + 1), Object.assign(encode$4, { bytes: 5 })) : (L.writeUInt8(255, J), L.writeUInt32LE(B >>> 0, J + 1), L.writeUInt32LE(B / 4294967296 | 0, J + 5), Object.assign(encode$4, { bytes: 9 })), L;
}
varint.encode = encode$4;
function decode$5(B, L) {
  if (!Buffer$D.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  L || (L = 0);
  const J = B.readUInt8(L);
  if (J < 253)
    return Object.assign(decode$5, { bytes: 1 }), J;
  if (J === 253)
    return Object.assign(decode$5, { bytes: 3 }), B.readUInt16LE(L + 1);
  if (J === 254)
    return Object.assign(decode$5, { bytes: 5 }), B.readUInt32LE(L + 1);
  {
    Object.assign(decode$5, { bytes: 9 });
    const ne = B.readUInt32LE(L + 1), ce = B.readUInt32LE(L + 5) * 4294967296 + ne;
    return checkUInt53(ce), ce;
  }
}
varint.decode = decode$5;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let L = B.length - 1, J = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    J = B[ne], B[ne] = B[L], B[L] = J, L--;
  return B;
}
tools.reverseBuffer = reverseBuffer$1;
function keyValsToBuffer(B) {
  const L = B.map(keyValToBuffer);
  return L.push(Buffer$D.from([0])), Buffer$D.concat(L);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const L = B.key.length, J = B.value.length, ne = varuint$6.encodingLength(L), oe = varuint$6.encodingLength(J), ce = Buffer$D.allocUnsafe(
    ne + L + oe + J
  );
  return varuint$6.encode(L, ce, 0), B.key.copy(ce, ne), varuint$6.encode(J, ce, ne + L), B.value.copy(ce, ne + L + oe), ce;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, L) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > L) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, L) {
  const J = B.readUInt32LE(L);
  let ne = B.readUInt32LE(L + 4);
  return ne *= 4294967296, verifuint(ne + J, 9007199254740991), ne + J;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, L, J) {
  return verifuint(L, 9007199254740991), B.writeInt32LE(L & -1, J), B.writeUInt32LE(Math.floor(L / 4294967296), J + 4), J + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const L = tools_1$2.readUInt64LE(B.value, 0);
  let J = 8;
  const ne = varuint$5.decode(B.value, J);
  J += varuint$5.encodingLength(ne);
  const oe = B.value.slice(J);
  if (oe.length !== ne)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: oe,
    value: L
  };
}
witnessUtxo$1.decode = decode$4;
function encode$3(B) {
  const { script: L, value: J } = B, ne = varuint$5.encodingLength(L.length), oe = Buffer$D.allocUnsafe(8 + ne + L.length);
  return tools_1$2.writeUInt64LE(oe, J, 0), varuint$5.encode(L.length, oe, 8), L.copy(oe, 8 + ne), {
    key: Buffer$D.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: oe
  };
}
witnessUtxo$1.encode = encode$3;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$D.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, L) {
  return !!B && !!L && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let L = 0;
  const J = [];
  for (; L < B.value.length; ) {
    const ne = B.value[L++], oe = B.value[L++], ce = varuint$4.decode(B.value, L);
    L += varuint$4.encodingLength(ce), J.push({
      depth: ne,
      leafVersion: oe,
      script: B.value.slice(L, L + ce)
    }), L += ce;
  }
  return { leaves: J };
}
tapTree$1.decode = decode$3;
function encode$2(B) {
  const L = Buffer$D.from([typeFields_1$3.OutputTypes.TAP_TREE]), J = [].concat(
    ...B.leaves.map((ne) => [
      Buffer$D.of(ne.depth, ne.leafVersion),
      varuint$4.encode(ne.script.length),
      ne.script
    ])
  );
  return {
    key: L,
    value: Buffer$D.concat(J)
  };
}
tapTree$1.encode = encode$2;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (L) => L.depth >= 0 && L.depth <= 128 && (L.leafVersion & 254) === L.leafVersion && Buffer$D.isBuffer(L.script)
  );
}
tapTree$1.check = check;
function canAdd(B, L) {
  return !!B && !!L && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$2 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, L = isValidDERKey) {
  function J(rt) {
    if (rt.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + rt.key.toString("hex")
      );
    const at = rt.key.slice(1);
    if (!L(at))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + rt.key.toString("hex")
      );
    if (rt.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const ht = {
      masterFingerprint: rt.value.slice(0, 4),
      pubkey: at,
      path: "m"
    };
    for (const it of range$2(rt.value.length / 4 - 1)) {
      const lt = rt.value.readUInt32LE(it * 4 + 4), Et = !!(lt & 2147483648), wt = lt & 2147483647;
      ht.path += "/" + wt.toString(10) + (Et ? "'" : "");
    }
    return ht;
  }
  function ne(rt) {
    const at = Buffer$D.from([B]), ht = Buffer$D.concat([at, rt.pubkey]), it = rt.path.split("/"), lt = Buffer$D.allocUnsafe(it.length * 4);
    rt.masterFingerprint.copy(lt, 0);
    let Et = 4;
    return it.slice(1).forEach((wt) => {
      const Rt = wt.slice(-1) === "'";
      let Mt = 2147483647 & parseInt(Rt ? wt.slice(0, -1) : wt, 10);
      Rt && (Mt += 2147483648), lt.writeUInt32LE(Mt, Et), Et += 4;
    }), {
      key: ht,
      value: lt
    };
  }
  const oe = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function ce(rt) {
    return Buffer$D.isBuffer(rt.pubkey) && Buffer$D.isBuffer(rt.masterFingerprint) && typeof rt.path == "string" && L(rt.pubkey) && rt.masterFingerprint.length === 4;
  }
  function Ce(rt, at, ht) {
    const it = at.pubkey.toString("hex");
    return ht.has(it) ? !1 : (ht.add(it), rt.filter((lt) => lt.pubkey.equals(at.pubkey)).length === 0);
  }
  return {
    decode: J,
    encode: ne,
    check: ce,
    expected: oe,
    canAddToArray: Ce
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return L;
  function L(J) {
    let ne;
    if (B.includes(J.key[0]) && (ne = J.key.slice(1), !(ne.length === 33 || ne.length === 65) || ![2, 3, 4].includes(ne[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + J.key.toString("hex")
      );
    return ne;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function L(Ce) {
    if (Ce.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + Ce.key.toString("hex")
      );
    return Ce.value;
  }
  function J(Ce) {
    return {
      key: Buffer$D.from([B]),
      value: Ce
    };
  }
  const ne = "Buffer";
  function oe(Ce) {
    return Buffer$D.isBuffer(Ce);
  }
  function ce(Ce, rt) {
    return !!Ce && !!rt && Ce.redeemScript === void 0;
  }
  return {
    decode: L,
    encode: J,
    check: oe,
    expected: ne,
    canAdd: ce
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const L = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function J(Ce) {
    const rt = varuint$3.decode(Ce.value), at = varuint$3.encodingLength(rt), ht = L.decode({
      key: Ce.key,
      value: Ce.value.slice(at + rt * 32)
    }), it = new Array(rt);
    for (let lt = 0, Et = at; lt < rt; lt++, Et += 32)
      it[lt] = Ce.value.slice(Et, Et + 32);
    return Object.assign({}, ht, { leafHashes: it });
  }
  function ne(Ce) {
    const rt = L.encode(Ce), at = varuint$3.encodingLength(Ce.leafHashes.length), ht = Buffer$D.allocUnsafe(at);
    varuint$3.encode(Ce.leafHashes.length, ht);
    const it = Buffer$D.concat([ht, ...Ce.leafHashes, rt.value]);
    return Object.assign({}, rt, { value: it });
  }
  const oe = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function ce(Ce) {
    return Array.isArray(Ce.leafHashes) && Ce.leafHashes.every(
      (rt) => Buffer$D.isBuffer(rt) && rt.length === 32
    ) && L.check(Ce);
  }
  return {
    decode: J,
    encode: ne,
    check: ce,
    expected: oe,
    canAddToArray: L.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function L(Ce) {
    if (Ce.key[0] !== B || Ce.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + Ce.key.toString("hex")
      );
    if (Ce.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return Ce.value;
  }
  function J(Ce) {
    return { key: Buffer$D.from([B]), value: Ce };
  }
  const ne = "Buffer";
  function oe(Ce) {
    return Buffer$D.isBuffer(Ce) && Ce.length === 32;
  }
  function ce(Ce, rt) {
    return !!Ce && !!rt && Ce.tapInternalKey === void 0;
  }
  return {
    decode: L,
    encode: J,
    check: oe,
    expected: ne,
    canAdd: ce
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function L(Ce) {
    if (Ce.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + Ce.key.toString("hex")
      );
    return Ce.value;
  }
  function J(Ce) {
    return {
      key: Buffer$D.from([B]),
      value: Ce
    };
  }
  const ne = "Buffer";
  function oe(Ce) {
    return Buffer$D.isBuffer(Ce);
  }
  function ce(Ce, rt) {
    return !!Ce && !!rt && Ce.witnessScript === void 0;
  }
  return {
    decode: L,
    encode: J,
    check: oe,
    expected: ne,
    canAdd: ce
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, L) {
  let J = 0;
  function ne() {
    const Lt = varuint$2.decode(B, J);
    J += varuint$2.encodingLength(Lt);
    const zt = B.slice(J, J + Lt);
    return J += Lt, zt;
  }
  function oe() {
    const Lt = B.readUInt32BE(J);
    return J += 4, Lt;
  }
  function ce() {
    const Lt = B.readUInt8(J);
    return J += 1, Lt;
  }
  function Ce() {
    const Lt = ne(), zt = ne();
    return {
      key: Lt,
      value: zt
    };
  }
  function rt() {
    if (J >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const Lt = B.readUInt8(J) === 0;
    return Lt && J++, Lt;
  }
  if (oe() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (ce() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const at = [], ht = {};
  for (; !rt(); ) {
    const Lt = Ce(), zt = Lt.key.toString("hex");
    if (ht[zt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + zt
      );
    ht[zt] = 1, at.push(Lt);
  }
  const it = at.filter(
    (Lt) => Lt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (it.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const lt = L(it[0].value), { inputCount: Et, outputCount: wt } = lt.getInputOutputCounts(), Rt = [], Mt = [];
  for (const Lt of tools_1$1.range(Et)) {
    const zt = {}, Ot = [];
    for (; !rt(); ) {
      const It = Ce(), Ft = It.key.toString("hex");
      if (zt[Ft])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + Lt + " key " + Ft
        );
      zt[Ft] = 1, Ot.push(It);
    }
    Rt.push(Ot);
  }
  for (const Lt of tools_1$1.range(wt)) {
    const zt = {}, Ot = [];
    for (; !rt(); ) {
      const It = Ce(), Ft = It.key.toString("hex");
      if (zt[Ft])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + Lt + " key " + Ft
        );
      zt[Ft] = 1, Ot.push(It);
    }
    Mt.push(Ot);
  }
  return psbtFromKeyVals(lt, {
    globalMapKeyVals: at,
    inputKeyVals: Rt,
    outputKeyVals: Mt
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, L, J) {
  if (!L.equals(Buffer$D.from([J])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${L.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: L, inputKeyVals: J, outputKeyVals: ne }) {
  const oe = {
    unsignedTx: B
  };
  let ce = 0;
  for (const it of L)
    switch (it.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          it.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), ce > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        ce++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        oe.globalXpub === void 0 && (oe.globalXpub = []), oe.globalXpub.push(convert$1.globals.globalXpub.decode(it));
        break;
      default:
        oe.unknownKeyVals || (oe.unknownKeyVals = []), oe.unknownKeyVals.push(it);
    }
  const Ce = J.length, rt = ne.length, at = [], ht = [];
  for (const it of tools_1$1.range(Ce)) {
    const lt = {};
    for (const Et of J[it])
      switch (convert$1.inputs.checkPubkey(Et), Et.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), lt.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          lt.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Et);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), lt.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          lt.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Et);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          lt.partialSig === void 0 && (lt.partialSig = []), lt.partialSig.push(convert$1.inputs.partialSig.decode(Et));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), lt.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          lt.sighashType = convert$1.inputs.sighashType.decode(Et);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), lt.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          lt.redeemScript = convert$1.inputs.redeemScript.decode(Et);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), lt.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          lt.witnessScript = convert$1.inputs.witnessScript.decode(Et);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          lt.bip32Derivation === void 0 && (lt.bip32Derivation = []), lt.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Et)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), lt.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Et);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), lt.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Et
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), lt.porCommitment = convert$1.inputs.porCommitment.decode(Et);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), lt.tapKeySig = convert$1.inputs.tapKeySig.decode(Et);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          lt.tapScriptSig === void 0 && (lt.tapScriptSig = []), lt.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Et));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          lt.tapLeafScript === void 0 && (lt.tapLeafScript = []), lt.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Et));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          lt.tapBip32Derivation === void 0 && (lt.tapBip32Derivation = []), lt.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Et)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), lt.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Et);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Et.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), lt.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Et);
          break;
        default:
          lt.unknownKeyVals || (lt.unknownKeyVals = []), lt.unknownKeyVals.push(Et);
      }
    at.push(lt);
  }
  for (const it of tools_1$1.range(rt)) {
    const lt = {};
    for (const Et of ne[it])
      switch (convert$1.outputs.checkPubkey(Et), Et.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Et.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), lt.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          lt.redeemScript = convert$1.outputs.redeemScript.decode(Et);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Et.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), lt.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          lt.witnessScript = convert$1.outputs.witnessScript.decode(Et);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          lt.bip32Derivation === void 0 && (lt.bip32Derivation = []), lt.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Et)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Et.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), lt.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Et);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Et.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), lt.tapTree = convert$1.outputs.tapTree.decode(Et);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          lt.tapBip32Derivation === void 0 && (lt.tapBip32Derivation = []), lt.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Et)
          );
          break;
        default:
          lt.unknownKeyVals || (lt.unknownKeyVals = []), lt.unknownKeyVals.push(Et);
      }
    ht.push(lt);
  }
  return { globalMap: oe, inputs: at, outputs: ht };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer$3 = {};
Object.defineProperty(toBuffer$3, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: L, outputs: J }) {
  const { globalKeyVals: ne, inputKeyVals: oe, outputKeyVals: ce } = psbtToKeyVals({
    globalMap: B,
    inputs: L,
    outputs: J
  }), Ce = tools_1.keyValsToBuffer(ne), rt = (lt) => lt.length === 0 ? [Buffer$D.from([0])] : lt.map(tools_1.keyValsToBuffer), at = rt(oe), ht = rt(ce), it = Buffer$D.allocUnsafe(5);
  return it.writeUIntBE(482972169471, 0, 5), Buffer$D.concat(
    [it, Ce].concat(at, ht)
  );
}
toBuffer$3.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, L) => B.key.compare(L.key);
function keyValsFromMap(B, L) {
  const J = /* @__PURE__ */ new Set(), ne = Object.entries(B).reduce((ce, [Ce, rt]) => {
    if (Ce === "unknownKeyVals") return ce;
    const at = L[Ce];
    if (at === void 0) return ce;
    const ht = (Array.isArray(rt) ? rt : [rt]).map(
      at.encode
    );
    return ht.map((lt) => lt.key.toString("hex")).forEach((lt) => {
      if (J.has(lt))
        throw new Error("Serialize Error: Duplicate key: " + lt);
      J.add(lt);
    }), ce.concat(ht);
  }, []), oe = B.unknownKeyVals ? B.unknownKeyVals.filter((ce) => !J.has(ce.key.toString("hex"))) : [];
  return ne.concat(oe).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: L, outputs: J }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: L.map((ne) => keyValsFromMap(ne, convert.inputs)),
    outputKeyVals: J.map((ne) => keyValsFromMap(ne, convert.outputs))
  };
}
toBuffer$3.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function L(J) {
    for (var ne in J) B.hasOwnProperty(ne) || (B[ne] = J[ne]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), L(fromBuffer), L(toBuffer$3);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const L = B[0], J = parser_1$1.psbtToKeyVals(L), ne = B.slice(1);
  if (ne.length === 0) throw new Error("Combine: Nothing to combine");
  const oe = getTx(L);
  if (oe === void 0)
    throw new Error("Combine: Self missing transaction");
  const ce = getKeySet(J.globalKeyVals), Ce = J.inputKeyVals.map(getKeySet), rt = J.outputKeyVals.map(getKeySet);
  for (const at of ne) {
    const ht = getTx(at);
    if (ht === void 0 || !ht.toBuffer().equals(oe.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const it = parser_1$1.psbtToKeyVals(at);
    getKeySet(it.globalKeyVals).forEach(
      keyPusher(
        ce,
        J.globalKeyVals,
        it.globalKeyVals
      )
    ), it.inputKeyVals.map(getKeySet).forEach(
      (Rt, Mt) => Rt.forEach(
        keyPusher(
          Ce[Mt],
          J.inputKeyVals[Mt],
          it.inputKeyVals[Mt]
        )
      )
    ), it.outputKeyVals.map(getKeySet).forEach(
      (Rt, Mt) => Rt.forEach(
        keyPusher(
          rt[Mt],
          J.outputKeyVals[Mt],
          it.outputKeyVals[Mt]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(oe, {
    globalMapKeyVals: J.globalKeyVals,
    inputKeyVals: J.inputKeyVals,
    outputKeyVals: J.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, L, J) {
  return (ne) => {
    if (B.has(ne)) return;
    const oe = J.filter((ce) => ce.key.toString("hex") === ne)[0];
    L.push(oe), B.add(ne);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const L = /* @__PURE__ */ new Set();
  return B.forEach((J) => {
    const ne = J.key.toString("hex");
    if (L.has(ne))
      throw new Error("Combine: KeyValue Map keys should be unique");
    L.add(ne);
  }), L;
}
var utils$o = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const L = converter;
  function J(wt, Rt) {
    const Mt = wt[Rt];
    if (Mt === void 0) throw new Error(`No input #${Rt}`);
    return Mt;
  }
  B.checkForInput = J;
  function ne(wt, Rt) {
    const Mt = wt[Rt];
    if (Mt === void 0) throw new Error(`No output #${Rt}`);
    return Mt;
  }
  B.checkForOutput = ne;
  function oe(wt, Rt, Mt) {
    if (wt.key[0] < Mt)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (Rt && Rt.filter((Lt) => Lt.key.equals(wt.key)).length !== 0)
      throw new Error(`Duplicate Key: ${wt.key.toString("hex")}`);
  }
  B.checkHasKey = oe;
  function ce(wt) {
    let Rt = 0;
    return Object.keys(wt).forEach((Mt) => {
      Number(isNaN(Number(Mt))) && Rt++;
    }), Rt;
  }
  B.getEnumLength = ce;
  function Ce(wt, Rt) {
    let Mt = !1;
    if (Rt.nonWitnessUtxo || Rt.witnessUtxo) {
      const Lt = !!Rt.redeemScript, zt = !!Rt.witnessScript, Ot = !Lt || !!Rt.finalScriptSig, It = !zt || !!Rt.finalScriptWitness, Ft = !!Rt.finalScriptSig || !!Rt.finalScriptWitness;
      Mt = Ot && It && Ft;
    }
    if (Mt === !1)
      throw new Error(
        `Input #${wt} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = Ce;
  function rt(wt, Rt, Mt, Lt) {
    throw new Error(
      `Data for ${wt} key ${Rt} is incorrect: Expected ${Mt} and got ${JSON.stringify(Lt)}`
    );
  }
  function at(wt) {
    return (Rt, Mt) => {
      for (const Lt of Object.keys(Rt)) {
        const zt = Rt[Lt], { canAdd: Ot, canAddToArray: It, check: Ft, expected: Jt } = (
          // @ts-ignore
          L[wt + "s"][Lt] || {}
        ), Vt = !!It;
        if (Ft)
          if (Vt) {
            if (!Array.isArray(zt) || // @ts-ignore
            Mt[Lt] && !Array.isArray(Mt[Lt]))
              throw new Error(`Key type ${Lt} must be an array`);
            zt.every(Ft) || rt(wt, Lt, Jt, zt);
            const yr = Mt[Lt] || [], jt = /* @__PURE__ */ new Set();
            if (!zt.every((Ut) => It(yr, Ut, jt)))
              throw new Error("Can not add duplicate data to array");
            Mt[Lt] = yr.concat(zt);
          } else {
            if (Ft(zt) || rt(wt, Lt, Jt, zt), !Ot(Mt, zt))
              throw new Error(`Can not add duplicate data to ${wt}`);
            Mt[Lt] = zt;
          }
      }
    };
  }
  B.updateGlobal = at("global"), B.updateInput = at("input"), B.updateOutput = at("output");
  function ht(wt, Rt) {
    const Mt = wt.length - 1, Lt = J(wt, Mt);
    B.updateInput(Rt, Lt);
  }
  B.addInputAttributes = ht;
  function it(wt, Rt) {
    const Mt = wt.length - 1, Lt = ne(wt, Mt);
    B.updateOutput(Rt, Lt);
  }
  B.addOutputAttributes = it;
  function lt(wt, Rt) {
    if (!Buffer$D.isBuffer(Rt) || Rt.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return Rt.writeUInt32LE(wt, 0), Rt;
  }
  B.defaultVersionSetter = lt;
  function Et(wt, Rt) {
    if (!Buffer$D.isBuffer(Rt) || Rt.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return Rt.writeUInt32LE(wt, Rt.length - 4), Rt;
  }
  B.defaultLocktimeSetter = Et;
})(utils$o);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$2 = utils$o;
let Psbt$1 = class {
  constructor(L) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: L
    };
  }
  static fromBase64(L, J) {
    const ne = Buffer$D.from(L, "base64");
    return this.fromBuffer(ne, J);
  }
  static fromHex(L, J) {
    const ne = Buffer$D.from(L, "hex");
    return this.fromBuffer(ne, J);
  }
  static fromBuffer(L, J) {
    const ne = parser_1.psbtFromBuffer(L, J), oe = new this(ne.globalMap.unsignedTx);
    return Object.assign(oe, ne), oe;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(L) {
    return utils_1$2.updateGlobal(L, this.globalMap), this;
  }
  updateInput(L, J) {
    const ne = utils_1$2.checkForInput(this.inputs, L);
    return utils_1$2.updateInput(J, ne), this;
  }
  updateOutput(L, J) {
    const ne = utils_1$2.checkForOutput(this.outputs, L);
    return utils_1$2.updateOutput(J, ne), this;
  }
  addUnknownKeyValToGlobal(L) {
    return utils_1$2.checkHasKey(
      L,
      this.globalMap.unknownKeyVals,
      utils_1$2.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToInput(L, J) {
    const ne = utils_1$2.checkForInput(this.inputs, L);
    return utils_1$2.checkHasKey(
      J,
      ne.unknownKeyVals,
      utils_1$2.getEnumLength(typeFields_1.InputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(J), this;
  }
  addUnknownKeyValToOutput(L, J) {
    const ne = utils_1$2.checkForOutput(this.outputs, L);
    return utils_1$2.checkHasKey(
      J,
      ne.unknownKeyVals,
      utils_1$2.getEnumLength(typeFields_1.OutputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(J), this;
  }
  addInput(L) {
    this.globalMap.unsignedTx.addInput(L), this.inputs.push({
      unknownKeyVals: []
    });
    const J = L.unknownKeyVals || [], ne = this.inputs.length - 1;
    if (!Array.isArray(J))
      throw new Error("unknownKeyVals must be an Array");
    return J.forEach(
      (oe) => this.addUnknownKeyValToInput(ne, oe)
    ), utils_1$2.addInputAttributes(this.inputs, L), this;
  }
  addOutput(L) {
    this.globalMap.unsignedTx.addOutput(L), this.outputs.push({
      unknownKeyVals: []
    });
    const J = L.unknownKeyVals || [], ne = this.outputs.length - 1;
    if (!Array.isArray(J))
      throw new Error("unknownKeyVals must be an Array");
    return J.forEach(
      (oe) => this.addUnknownKeyValToOutput(ne, oe)
    ), utils_1$2.addOutputAttributes(this.outputs, L), this;
  }
  clearFinalizedInput(L) {
    const J = utils_1$2.checkForInput(this.inputs, L);
    utils_1$2.inputCheckUncleanFinalized(L, J);
    for (const ne of Object.keys(J))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(ne) || delete J[ne];
    return this;
  }
  combine(...L) {
    const J = combiner_1.combine([this].concat(L));
    return Object.assign(this, J), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$6, payments$1 = requirePayments();
function isPaymentFactory$1(B) {
  return (L) => {
    try {
      return B({ output: L }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory$1(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory$1(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory$1(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory$1(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory$1(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory$1(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory$1(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let L = Buffer$D.allocUnsafe(0);
  function J(Ce) {
    L = Buffer$D.concat([L, Buffer$D.from(Ce)]);
  }
  function ne(Ce) {
    const rt = L.length, at = varuint$1.encodingLength(Ce);
    L = Buffer$D.concat([L, Buffer$D.allocUnsafe(at)]), varuint$1.encode(Ce, L, rt);
  }
  function oe(Ce) {
    ne(Ce.length), J(Ce);
  }
  function ce(Ce) {
    ne(Ce.length), Ce.forEach(oe);
  }
  return ce(B), L;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, L) {
  const J = (0, crypto_1.hash160)(B), ne = B.slice(1, 33), oe = bscript$1.decompile(L);
  if (oe === null) throw new Error("Unknown script error");
  return oe.findIndex((ce) => typeof ce == "number" ? !1 : ce.equals(B) || ce.equals(J) || ce.equals(ne));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, L) {
  return pubkeyPositionInScript(B, L) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, L) {
  return extractPartialSigs(B).some(
    (ne) => signatureBlocksAction(ne, bscript$1.signature.decode, L)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, L, J) {
  const { hashType: ne } = L(B), oe = [];
  switch (ne & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && oe.push("addInput"), ne & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      oe.push("addOutput"), oe.push("setInputSequence");
      break;
  }
  return oe.indexOf(J) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let L = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    L = getPsigsFromInputFinalScripts(B);
  } else
    L = B.partialSig;
  return L.map((J) => J.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const L = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], J = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return L.concat(J).filter((ne) => Buffer$D.isBuffer(ne) && bscript$1.isCanonicalScriptSignature(ne)).map((ne) => ({ signature: ne }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$7, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly$2 = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly$2;
function tapScriptFinalizer(B, L, J) {
  const ne = findTapLeafToFinalize(
    L,
    B,
    J
  );
  try {
    const ce = sortSignatures(L, ne).concat(ne.script).concat(ne.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(ce)
    };
  } catch (oe) {
    throw new Error(`Can not finalize taproot input #${B}: ${oe}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, L) {
  const J = L ? Buffer$D.from([L]) : Buffer$D.from([]);
  return Buffer$D.concat([B, J]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, L) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || L && (0, psbtutils_1$1.isP2TR)(L));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, L, J) {
  checkMixedTaprootAndNonTaprootInputFields(B, L, J), checkIfTapLeafInTree(B, L, J);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, L, J) {
  checkMixedTaprootAndNonTaprootOutputFields(B, L, J), checkTaprootScriptPubkey(B, L);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, L) {
  if (!L.tapTree && !L.tapInternalKey) return;
  const J = L.tapInternalKey || B.tapInternalKey, ne = L.tapTree || B.tapTree;
  if (J) {
    const { script: oe } = B, ce = getTaprootScripPubkey(J, ne);
    if (oe && !oe.equals(ce))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, L) {
  const J = L && tapTreeFromList(L.leaves), { output: ne } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: J
  });
  return ne;
}
function tweakInternalPubKey(B, L) {
  const J = L.tapInternalKey, ne = J && (0, bip341_1$1.tweakKey)(J, L.tapMerkleRoot);
  if (!ne)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${J && J.toString("hex")}`
    );
  return ne.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, L) {
  return extractTaprootSigs(B).some(
    (ne) => (0, psbtutils_2.signatureBlocksAction)(ne, decodeSchnorrSignature, L)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const L = [];
  if (B.tapKeySig && L.push(B.tapKeySig), B.tapScriptSig && L.push(...B.tapScriptSig.map((J) => J.signature)), !L.length) {
    const J = getTapKeySigFromWithness(B.finalScriptWitness);
    J && L.push(J);
  }
  return L;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const L = B.slice(2);
  if (L.length === 64 || L.length === 65) return L;
}
function _tapTreeToList(B, L = [], J = 0) {
  if (J > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (L.push({
    depth: J,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), L) : (B[0] && _tapTreeToList(B[0], L, J + 1), B[1] && _tapTreeToList(B[1], L, J + 1), L) : [];
}
function instertLeavesInTree(B) {
  let L;
  for (const J of B)
    if (L = instertLeafInTree(J, L), !L) throw new Error("No room left to insert tapleaf in tree");
  return L;
}
function instertLeafInTree(B, L, J = 0) {
  if (J > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === J)
    return L ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(L)) return;
  const ne = instertLeafInTree(B, L && L[0], J + 1);
  if (ne) return [ne, L && L[1]];
  const oe = instertLeafInTree(B, L && L[1], J + 1);
  if (oe) return [L && L[0], oe];
}
function checkMixedTaprootAndNonTaprootInputFields(B, L, J) {
  const ne = isTaprootInput(B) && hasNonTaprootFields(L), oe = hasNonTaprootFields(B) && isTaprootInput(L), ce = B === L && isTaprootInput(L) && hasNonTaprootFields(L);
  if (ne || oe || ce)
    throw new Error(
      `Invalid arguments for Psbt.${J}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, L, J) {
  const ne = isTaprootOutput(B) && hasNonTaprootFields(L), oe = hasNonTaprootFields(B) && isTaprootOutput(L), ce = B === L && isTaprootOutput(L) && hasNonTaprootFields(L);
  if (ne || oe || ce)
    throw new Error(
      `Invalid arguments for Psbt.${J}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, L, J) {
  if (L.tapMerkleRoot) {
    const ne = (L.tapLeafScript || []).every(
      (ce) => isTapLeafInTree(ce, L.tapMerkleRoot)
    ), oe = (B.tapLeafScript || []).every(
      (ce) => isTapLeafInTree(ce, L.tapMerkleRoot)
    );
    if (!ne || !oe)
      throw new Error(
        `Invalid arguments for Psbt.${J}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(L.tapLeafScript || []).every(
    (oe) => isTapLeafInTree(oe, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${J}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, L) {
  if (!L) return !0;
  const J = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    J
  ).equals(L);
}
function sortSignatures(B, L) {
  const J = (0, bip341_1$1.tapleafHash)({
    output: L.script,
    version: L.leafVersion
  });
  return (B.tapScriptSig || []).filter((ne) => ne.leafHash.equals(J)).map((ne) => addPubkeyPositionInScript(L.script, ne)).sort((ne, oe) => oe.positionInScript - ne.positionInScript).map((ne) => ne.signature);
}
function addPubkeyPositionInScript(B, L) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        L.pubkey,
        B
      )
    },
    L
  );
}
function findTapLeafToFinalize(B, L, J) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${L}. No tapleaf script signature provided.`
    );
  const ne = (B.tapLeafScript || []).sort((oe, ce) => oe.controlBlock.length - ce.controlBlock.length).find(
    (oe) => canFinalizeLeaf(oe, B.tapScriptSig, J)
  );
  if (!ne)
    throw new Error(
      `Can not finalize taproot input #${L}. Signature for tapleaf script not found.`
    );
  return ne;
}
function canFinalizeLeaf(B, L, J) {
  const ne = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!J || J.equals(ne)) && L.find((ce) => ce.leafHash.equals(ne)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1$1 = utils$o, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks$2, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(L, J = {}) {
    const ne = Buffer$D.from(L, "base64");
    return this.fromBuffer(ne, J);
  }
  static fromHex(L, J = {}) {
    const ne = Buffer$D.from(L, "hex");
    return this.fromBuffer(ne, J);
  }
  static fromBuffer(L, J = {}) {
    const ne = bip174_1.Psbt.fromBuffer(L, transactionFromBuffer), oe = new Psbt(J, ne);
    return checkTxForDupeIns(oe.__CACHE.__TX, oe.__CACHE), oe;
  }
  constructor(L = {}, J = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = J, this.opts = Object.assign({}, DEFAULT_OPTS, L), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const ne = (oe, ce, Ce, rt) => Object.defineProperty(oe, ce, {
      enumerable: Ce,
      writable: rt
    });
    ne(this, "__CACHE", !1, !0), ne(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(L) {
    this.setVersion(L);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(L) {
    this.setLocktime(L);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((L) => ({
      hash: (0, bufferutils_1.cloneBuffer)(L.hash),
      index: L.index,
      sequence: L.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((L) => {
      let J;
      try {
        J = (0, address_1.fromOutputScript)(
          L.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(L.script),
        value: L.value,
        address: J
      };
    });
  }
  combine(...L) {
    return this.data.combine(...L.map((J) => J.data)), this;
  }
  clone() {
    const L = Psbt.fromBuffer(this.data.toBuffer());
    return L.opts = JSON.parse(JSON.stringify(this.opts)), L;
  }
  setMaximumFeeRate(L) {
    check32Bit(L), this.opts.maximumFeeRate = L;
  }
  setVersion(L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const J = this.__CACHE;
    return J.__TX.version = L, J.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const J = this.__CACHE;
    return J.__TX.locktime = L, J.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(L, J) {
    check32Bit(J), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const ne = this.__CACHE;
    if (ne.__TX.ins.length <= L)
      throw new Error("Input index too high");
    return ne.__TX.ins[L].sequence = J, ne.__EXTRACTED_TX = void 0, this;
  }
  addInputs(L) {
    return L.forEach((J) => this.addInput(J)), this;
  }
  addInput(L) {
    if (arguments.length > 1 || !L || L.hash === void 0 || L.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(L, L, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), L.witnessScript && checkInvalidP2WSH(L.witnessScript);
    const J = this.__CACHE;
    this.data.addInput(L);
    const ne = J.__TX.ins[J.__TX.ins.length - 1];
    checkTxInputCache(J, ne);
    const oe = this.data.inputs.length - 1, ce = this.data.inputs[oe];
    return ce.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, ce, oe), J.__FEE = void 0, J.__FEE_RATE = void 0, J.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(L) {
    return L.forEach((J) => this.addOutput(J)), this;
  }
  addOutput(L) {
    if (arguments.length > 1 || !L || L.value === void 0 || L.address === void 0 && L.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: J } = L;
    if (typeof J == "string") {
      const { network: oe } = this.opts, ce = (0, address_1.toOutputScript)(J, oe);
      L = Object.assign({}, L, { script: ce });
    }
    (0, bip371_1.checkTaprootOutputFields)(L, L, "addOutput");
    const ne = this.__CACHE;
    return this.data.addOutput(L), ne.__FEE = void 0, ne.__FEE_RATE = void 0, ne.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(L) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const J = this.__CACHE;
    if (L || checkFees(this, J, this.opts), J.__EXTRACTED_TX) return J.__EXTRACTED_TX;
    const ne = J.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, ne, J, !0), ne;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1$1.checkForInput)(this.data.inputs, 0), range$1(this.data.inputs.length).forEach((L) => this.finalizeInput(L)), this;
  }
  finalizeInput(L, J) {
    const ne = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return (0, bip371_1.isTaprootInput)(ne) ? this._finalizeTaprootInput(
      L,
      ne,
      void 0,
      J
    ) : this._finalizeInput(L, ne, J);
  }
  finalizeTaprootInput(L, J, ne = bip371_1.tapScriptFinalizer) {
    const oe = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    if ((0, bip371_1.isTaprootInput)(oe))
      return this._finalizeTaprootInput(
        L,
        oe,
        J,
        ne
      );
    throw new Error(`Cannot finalize input #${L}. Not Taproot.`);
  }
  _finalizeInput(L, J, ne = getFinalScripts) {
    const { script: oe, isP2SH: ce, isP2WSH: Ce, isSegwit: rt } = getScriptFromInput(
      L,
      J,
      this.__CACHE
    );
    if (!oe) throw new Error(`No script found for input #${L}`);
    checkPartialSigSighashes(J);
    const { finalScriptSig: at, finalScriptWitness: ht } = ne(
      L,
      J,
      oe,
      rt,
      ce,
      Ce
    );
    if (at && this.data.updateInput(L, { finalScriptSig: at }), ht && this.data.updateInput(L, { finalScriptWitness: ht }), !at && !ht)
      throw new Error(`Unknown error finalizing input #${L}`);
    return this.data.clearFinalizedInput(L), this;
  }
  _finalizeTaprootInput(L, J, ne, oe = bip371_1.tapScriptFinalizer) {
    if (!J.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${L}. Missing withness utxo.`
      );
    if (J.tapKeySig) {
      const ce = payments.p2tr({
        output: J.witnessUtxo.script,
        signature: J.tapKeySig
      }), Ce = (0, psbtutils_1.witnessStackToScriptWitness)(
        ce.witness
      );
      this.data.updateInput(L, { finalScriptWitness: Ce });
    } else {
      const { finalScriptWitness: ce } = oe(
        L,
        J,
        ne
      );
      this.data.updateInput(L, { finalScriptWitness: ce });
    }
    return this.data.clearFinalizedInput(L), this;
  }
  getInputType(L) {
    const J = (0, utils_1$1.checkForInput)(this.data.inputs, L), ne = getScriptFromUtxo(L, J, this.__CACHE), oe = getMeaningfulScript(
      ne,
      L,
      "input",
      J.redeemScript || redeemFromFinalScriptSig(J.finalScriptSig),
      J.witnessScript || redeemFromFinalWitnessScript(J.finalScriptWitness)
    ), ce = oe.type === "raw" ? "" : oe.type + "-", Ce = classifyScript(oe.meaningfulScript);
    return ce + Ce;
  }
  inputHasPubkey(L, J) {
    const ne = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return pubkeyInInput(J, ne, L, this.__CACHE);
  }
  inputHasHDKey(L, J) {
    const ne = (0, utils_1$1.checkForInput)(this.data.inputs, L), oe = bip32DerivationIsMine(J);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(oe);
  }
  outputHasPubkey(L, J) {
    const ne = (0, utils_1$1.checkForOutput)(this.data.outputs, L);
    return pubkeyInOutput(J, ne, L, this.__CACHE);
  }
  outputHasHDKey(L, J) {
    const ne = (0, utils_1$1.checkForOutput)(this.data.outputs, L), oe = bip32DerivationIsMine(J);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(oe);
  }
  validateSignaturesOfAllInputs(L) {
    return (0, utils_1$1.checkForInput)(this.data.inputs, 0), range$1(this.data.inputs.length).map(
      (ne) => this.validateSignaturesOfInput(ne, L)
    ).reduce((ne, oe) => oe === !0 && ne, !0);
  }
  validateSignaturesOfInput(L, J, ne) {
    const oe = this.data.inputs[L];
    return (0, bip371_1.isTaprootInput)(oe) ? this.validateSignaturesOfTaprootInput(
      L,
      J,
      ne
    ) : this._validateSignaturesOfInput(L, J, ne);
  }
  _validateSignaturesOfInput(L, J, ne) {
    const oe = this.data.inputs[L], ce = (oe || {}).partialSig;
    if (!oe || !ce || ce.length < 1)
      throw new Error("No signatures to validate");
    if (typeof J != "function")
      throw new Error("Need validator function to validate signatures");
    const Ce = ne ? ce.filter((lt) => lt.pubkey.equals(ne)) : ce;
    if (Ce.length < 1) throw new Error("No signatures for this pubkey");
    const rt = [];
    let at, ht, it;
    for (const lt of Ce) {
      const Et = bscript.signature.decode(lt.signature), { hash: wt, script: Rt } = it !== Et.hashType ? getHashForSig(
        L,
        Object.assign({}, oe, { sighashType: Et.hashType }),
        this.__CACHE,
        !0
      ) : { hash: at, script: ht };
      it = Et.hashType, at = wt, ht = Rt, checkScriptForPubkey(lt.pubkey, Rt, "verify"), rt.push(J(lt.pubkey, wt, Et.signature));
    }
    return rt.every((lt) => lt === !0);
  }
  validateSignaturesOfTaprootInput(L, J, ne) {
    const oe = this.data.inputs[L], ce = (oe || {}).tapKeySig, Ce = (oe || {}).tapScriptSig;
    if (!oe && !ce && !(Ce && !Ce.length))
      throw new Error("No signatures to validate");
    if (typeof J != "function")
      throw new Error("Need validator function to validate signatures");
    ne = ne && (0, bip371_1.toXOnly)(ne);
    const rt = ne ? getTaprootHashesForSig(
      L,
      oe,
      this.data.inputs,
      ne,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      L,
      oe,
      this.data.inputs,
      this.__CACHE
    );
    if (!rt.length) throw new Error("No signatures for this pubkey");
    const at = rt.find((it) => !it.leafHash);
    let ht = 0;
    if (ce && at) {
      if (!J(
        at.pubkey,
        at.hash,
        trimTaprootSig(ce)
      )) return !1;
      ht++;
    }
    if (Ce)
      for (const it of Ce) {
        const lt = rt.find((Et) => it.pubkey.equals(Et.pubkey));
        if (lt) {
          if (!J(
            it.pubkey,
            lt.hash,
            trimTaprootSig(it.signature)
          )) return !1;
          ht++;
        }
      }
    return ht > 0;
  }
  signAllInputsHD(L, J = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const ne = [];
    for (const oe of range$1(this.data.inputs.length))
      try {
        this.signInputHD(oe, L, J), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((oe) => oe === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(L, J = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ne, oe) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return oe(new Error("Need HDSigner to sign input"));
      const ce = [], Ce = [];
      for (const rt of range$1(this.data.inputs.length))
        Ce.push(
          this.signInputHDAsync(rt, L, J).then(
            () => {
              ce.push(!0);
            },
            () => {
              ce.push(!1);
            }
          )
        );
      return Promise.all(Ce).then(() => {
        if (ce.every((rt) => rt === !1))
          return oe(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInputHD(L, J, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!J || !J.publicKey || !J.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(L, this.data.inputs, J).forEach((ce) => this.signInput(L, ce, ne)), this;
  }
  signInputHDAsync(L, J, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((oe, ce) => {
      if (!J || !J.publicKey || !J.fingerprint)
        return ce(new Error("Need HDSigner to sign input"));
      const rt = getSignersFromHD(L, this.data.inputs, J).map(
        (at) => this.signInputAsync(L, at, ne)
      );
      return Promise.all(rt).then(() => {
        oe();
      }).catch(ce);
    });
  }
  signAllInputs(L, J) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const ne = [];
    for (const oe of range$1(this.data.inputs.length))
      try {
        this.signInput(oe, L, J), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((oe) => oe === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(L, J) {
    return new Promise((ne, oe) => {
      if (!L || !L.publicKey)
        return oe(new Error("Need Signer to sign input"));
      const ce = [], Ce = [];
      for (const [rt] of this.data.inputs.entries())
        Ce.push(
          this.signInputAsync(rt, L, J).then(
            () => {
              ce.push(!0);
            },
            () => {
              ce.push(!1);
            }
          )
        );
      return Promise.all(Ce).then(() => {
        if (ce.every((rt) => rt === !1))
          return oe(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInput(L, J, ne) {
    if (!J || !J.publicKey)
      throw new Error("Need Signer to sign input");
    const oe = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return (0, bip371_1.isTaprootInput)(oe) ? this._signTaprootInput(
      L,
      oe,
      J,
      void 0,
      ne
    ) : this._signInput(L, J, ne);
  }
  signTaprootInput(L, J, ne, oe) {
    if (!J || !J.publicKey)
      throw new Error("Need Signer to sign input");
    const ce = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    if ((0, bip371_1.isTaprootInput)(ce))
      return this._signTaprootInput(
        L,
        ce,
        J,
        ne,
        oe
      );
    throw new Error(`Input #${L} is not of type Taproot.`);
  }
  _signInput(L, J, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: oe, sighashType: ce } = getHashAndSighashType(
      this.data.inputs,
      L,
      J.publicKey,
      this.__CACHE,
      ne
    ), Ce = [
      {
        pubkey: J.publicKey,
        signature: bscript.signature.encode(J.sign(oe), ce)
      }
    ];
    return this.data.updateInput(L, { partialSig: Ce }), this;
  }
  _signTaprootInput(L, J, ne, oe, ce = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const Ce = this.checkTaprootHashesForSig(
      L,
      J,
      ne,
      oe,
      ce
    ), rt = Ce.filter((ht) => !ht.leafHash).map(
      (ht) => (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(ht.hash),
        J.sighashType
      )
    )[0], at = Ce.filter((ht) => !!ht.leafHash).map((ht) => ({
      pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(ht.hash),
        J.sighashType
      ),
      leafHash: ht.leafHash
    }));
    return rt && this.data.updateInput(L, { tapKeySig: rt }), at.length && this.data.updateInput(L, { tapScriptSig: at }), this;
  }
  signInputAsync(L, J, ne) {
    return Promise.resolve().then(() => {
      if (!J || !J.publicKey)
        throw new Error("Need Signer to sign input");
      const oe = (0, utils_1$1.checkForInput)(this.data.inputs, L);
      return (0, bip371_1.isTaprootInput)(oe) ? this._signTaprootInputAsync(
        L,
        oe,
        J,
        void 0,
        ne
      ) : this._signInputAsync(L, J, ne);
    });
  }
  signTaprootInputAsync(L, J, ne, oe) {
    return Promise.resolve().then(() => {
      if (!J || !J.publicKey)
        throw new Error("Need Signer to sign input");
      const ce = (0, utils_1$1.checkForInput)(this.data.inputs, L);
      if ((0, bip371_1.isTaprootInput)(ce))
        return this._signTaprootInputAsync(
          L,
          ce,
          J,
          ne,
          oe
        );
      throw new Error(`Input #${L} is not of type Taproot.`);
    });
  }
  _signInputAsync(L, J, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: oe, sighashType: ce } = getHashAndSighashType(
      this.data.inputs,
      L,
      J.publicKey,
      this.__CACHE,
      ne
    );
    return Promise.resolve(J.sign(oe)).then((Ce) => {
      const rt = [
        {
          pubkey: J.publicKey,
          signature: bscript.signature.encode(Ce, ce)
        }
      ];
      this.data.updateInput(L, { partialSig: rt });
    });
  }
  async _signTaprootInputAsync(L, J, ne, oe, ce = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const Ce = this.checkTaprootHashesForSig(
      L,
      J,
      ne,
      oe,
      ce
    ), rt = [], at = Ce.filter((it) => !it.leafHash)[0];
    if (at) {
      const it = Promise.resolve(
        ne.signSchnorr(at.hash)
      ).then((lt) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          lt,
          J.sighashType
        )
      }));
      rt.push(it);
    }
    const ht = Ce.filter((it) => !!it.leafHash);
    if (ht.length) {
      const it = ht.map((lt) => Promise.resolve(ne.signSchnorr(lt.hash)).then(
        (Et) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Et,
              J.sighashType
            ),
            leafHash: lt.leafHash
          }
        ] })
      ));
      rt.push(...it);
    }
    return Promise.all(rt).then((it) => {
      it.forEach((lt) => this.data.updateInput(L, lt));
    });
  }
  checkTaprootHashesForSig(L, J, ne, oe, ce) {
    if (typeof ne.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${L}.`
      );
    const Ce = getTaprootHashesForSig(
      L,
      J,
      this.data.inputs,
      ne.publicKey,
      this.__CACHE,
      oe,
      ce
    );
    if (!Ce || !Ce.length)
      throw new Error(
        `Can not sign for input #${L} with the key ${ne.publicKey.toString(
          "hex"
        )}`
      );
    return Ce;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(L) {
    return this.data.updateGlobal(L), this;
  }
  updateInput(L, J) {
    return J.witnessScript && checkInvalidP2WSH(J.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[L],
      J,
      "updateInput"
    ), this.data.updateInput(L, J), J.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[L],
      L
    ), this;
  }
  updateOutput(L, J) {
    const ne = this.data.outputs[L];
    return (0, bip371_1.checkTaprootOutputFields)(
      ne,
      J,
      "updateOutput"
    ), this.data.updateOutput(L, J), this;
  }
  addUnknownKeyValToGlobal(L) {
    return this.data.addUnknownKeyValToGlobal(L), this;
  }
  addUnknownKeyValToInput(L, J) {
    return this.data.addUnknownKeyValToInput(L, J), this;
  }
  addUnknownKeyValToOutput(L, J) {
    return this.data.addUnknownKeyValToOutput(L, J), this;
  }
  clearFinalizedInput(L) {
    return this.data.clearFinalizedInput(L), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(L = Buffer$D.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(L), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(L) {
    if (L.hash === void 0 || L.index === void 0 || !Buffer$D.isBuffer(L.hash) && typeof L.hash != "string" || typeof L.index != "number")
      throw new Error("Error adding input.");
    const J = typeof L.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$D.from(L.hash, "hex")) : L.hash;
    this.tx.addInput(J, L.index, L.sequence);
  }
  addOutput(L) {
    if (L.script === void 0 || L.value === void 0 || !Buffer$D.isBuffer(L.script) || typeof L.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(L.script, L.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, L, J) {
  switch (J) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const ne = payments.p2ms({ output: L });
      return hasSigs(ne.m, B.partialSig, ne.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, L, J) {
  if (!L) return !1;
  let ne;
  if (J ? ne = J.map((oe) => {
    const ce = compressPubkey(oe);
    return L.find((Ce) => Ce.pubkey.equals(ce));
  }).filter((oe) => !!oe) : ne = L, ne.length > B) throw new Error("Too many signatures");
  return ne.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (L) => !(!L.masterFingerprint.equals(B.fingerprint) || !B.derivePath(L.path).publicKey.equals(L.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, L, J) {
  const ne = L.__FEE_RATE || B.getFeeRate(), oe = L.__EXTRACTED_TX.virtualSize(), ce = ne * oe;
  if (ne >= J.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(ce / 1e8).toFixed(8)} in fees, which is ${ne} satoshi per byte for a transaction with a VSize of ${oe} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, L) {
  B.forEach((J) => {
    if ((0, bip371_1.isTaprootInput)(J) ? (0, bip371_1.checkTaprootInputForSigs)(J, L) : (0, psbtutils_1.checkInputForSig)(J, L))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: L, sighashType: J } = B;
  L.forEach((ne) => {
    const { hashType: oe } = bscript.signature.decode(ne.signature);
    if (J !== oe)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, L, J) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, L))
    throw new Error(
      `Can not ${J} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (J) => J.script && J.script.length === 0 && J.witness && J.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, L) {
  B.ins.forEach((J) => {
    checkTxInputCache(L, J);
  });
}
function checkTxInputCache(B, L) {
  const J = (0, bufferutils_1.reverseBuffer)(Buffer$D.from(L.hash)).toString("hex") + ":" + L.index;
  if (B.__TX_IN_CACHE[J]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[J] = 1;
}
function scriptCheckerFactory(B, L) {
  return (J, ne, oe, ce) => {
    const Ce = B({
      redeem: { output: oe }
    }).output;
    if (!ne.equals(Ce))
      throw new Error(
        `${L} for ${ce} #${J} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, L, J, ne) {
  if (!J.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${L}`);
  if (B === "__FEE_RATE" && ne.__FEE_RATE) return ne.__FEE_RATE;
  if (B === "__FEE" && ne.__FEE) return ne.__FEE;
  let oe, ce = !0;
  if (ne.__EXTRACTED_TX ? (oe = ne.__EXTRACTED_TX, ce = !1) : oe = ne.__TX.clone(), inputFinalizeGetAmts(J, oe, ne, ce), B === "__FEE_RATE") return ne.__FEE_RATE;
  if (B === "__FEE") return ne.__FEE;
}
function getFinalScripts(B, L, J, ne, oe, ce) {
  const Ce = classifyScript(J);
  if (!canFinalize(L, J, Ce))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    J,
    Ce,
    L.partialSig,
    ne,
    oe,
    ce
  );
}
function prepareFinalScripts(B, L, J, ne, oe, ce) {
  let Ce, rt;
  const at = getPayment(B, L, J), ht = ce ? payments.p2wsh({ redeem: at }) : null, it = oe ? payments.p2sh({ redeem: ht || at }) : null;
  return ne ? (ht ? rt = (0, psbtutils_1.witnessStackToScriptWitness)(
    ht.witness
  ) : rt = (0, psbtutils_1.witnessStackToScriptWitness)(
    at.witness
  ), it && (Ce = it.input)) : it ? Ce = it.input : Ce = at.input, {
    finalScriptSig: Ce,
    finalScriptWitness: rt
  };
}
function getHashAndSighashType(B, L, J, ne, oe) {
  const ce = (0, utils_1$1.checkForInput)(B, L), { hash: Ce, sighashType: rt, script: at } = getHashForSig(
    L,
    ce,
    ne,
    !1,
    oe
  );
  return checkScriptForPubkey(J, at, "sign"), {
    hash: Ce,
    sighashType: rt
  };
}
function getHashForSig(B, L, J, ne, oe) {
  const ce = J.__TX, Ce = L.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(Ce, oe);
  let rt, at;
  if (L.nonWitnessUtxo) {
    const lt = nonWitnessUtxoTxFromCache(
      J,
      L,
      B
    ), Et = ce.ins[B].hash, wt = lt.getHash();
    if (!Et.equals(wt))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const Rt = ce.ins[B].index;
    at = lt.outs[Rt];
  } else if (L.witnessUtxo)
    at = L.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: ht, type: it } = getMeaningfulScript(
    at.script,
    B,
    "input",
    L.redeemScript,
    L.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(it) >= 0)
    rt = ce.hashForWitnessV0(
      B,
      ht,
      at.value,
      Ce
    );
  else if ((0, psbtutils_1.isP2WPKH)(ht)) {
    const lt = payments.p2pkh({
      hash: ht.slice(2)
    }).output;
    rt = ce.hashForWitnessV0(
      B,
      lt,
      at.value,
      Ce
    );
  } else {
    if (L.nonWitnessUtxo === void 0 && J.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${ht.toString("hex")}`
      );
    !ne && J.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), rt = ce.hashForSignature(
      B,
      ht,
      Ce
    );
  }
  return {
    script: ht,
    sighashType: Ce,
    hash: rt
  };
}
function getAllTaprootHashesForSig(B, L, J, ne) {
  const oe = [];
  if (L.tapInternalKey) {
    const Ce = getPrevoutTaprootKey(B, L, ne);
    Ce && oe.push(Ce);
  }
  if (L.tapScriptSig) {
    const Ce = L.tapScriptSig.map((rt) => rt.pubkey);
    oe.push(...Ce);
  }
  return oe.map(
    (Ce) => getTaprootHashesForSig(B, L, J, Ce, ne)
  ).flat();
}
function getPrevoutTaprootKey(B, L, J) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, L, J);
  return (0, psbtutils_1.isP2TR)(ne) ? ne.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, L, J, ne, oe, ce, Ce) {
  const rt = oe.__TX, at = L.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(at, Ce);
  const ht = J.map(
    (Rt, Mt) => getScriptAndAmountFromUtxo(Mt, Rt, oe)
  ), it = ht.map((Rt) => Rt.script), lt = ht.map((Rt) => Rt.value), Et = [];
  if (L.tapInternalKey && !ce) {
    const Rt = getPrevoutTaprootKey(B, L, oe) || Buffer$D.from([]);
    if ((0, bip371_1.toXOnly)(ne).equals(Rt)) {
      const Mt = rt.hashForWitnessV1(
        B,
        it,
        lt,
        at
      );
      Et.push({ pubkey: ne, hash: Mt });
    }
  }
  const wt = (L.tapLeafScript || []).filter((Rt) => (0, psbtutils_1.pubkeyInScript)(ne, Rt.script)).map((Rt) => {
    const Mt = (0, bip341_1.tapleafHash)({
      output: Rt.script,
      version: Rt.leafVersion
    });
    return Object.assign({ hash: Mt }, Rt);
  }).filter(
    (Rt) => !ce || ce.equals(Rt.hash)
  ).map((Rt) => {
    const Mt = rt.hashForWitnessV1(
      B,
      it,
      lt,
      at,
      Rt.hash
    );
    return {
      pubkey: ne,
      hash: Mt,
      leafHash: Rt.hash
    };
  });
  return Et.concat(wt);
}
function checkSighashTypeAllowed(B, L) {
  if (L && L.indexOf(B) < 0) {
    const J = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${J}`
    );
  }
}
function getPayment(B, L, J) {
  let ne;
  switch (L) {
    case "multisig":
      const oe = getSortedSigs(B, J);
      ne = payments.p2ms({
        output: B,
        signatures: oe
      });
      break;
    case "pubkey":
      ne = payments.p2pk({
        output: B,
        signature: J[0].signature
      });
      break;
    case "pubkeyhash":
      ne = payments.p2pkh({
        output: B,
        pubkey: J[0].pubkey,
        signature: J[0].signature
      });
      break;
    case "witnesspubkeyhash":
      ne = payments.p2wpkh({
        output: B,
        pubkey: J[0].pubkey,
        signature: J[0].signature
      });
      break;
  }
  return ne;
}
function getScriptFromInput(B, L, J) {
  const ne = J.__TX, oe = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (oe.isP2SH = !!L.redeemScript, oe.isP2WSH = !!L.witnessScript, L.witnessScript)
    oe.script = L.witnessScript;
  else if (L.redeemScript)
    oe.script = L.redeemScript;
  else if (L.nonWitnessUtxo) {
    const ce = nonWitnessUtxoTxFromCache(
      J,
      L,
      B
    ), Ce = ne.ins[B].index;
    oe.script = ce.outs[Ce].script;
  } else L.witnessUtxo && (oe.script = L.witnessUtxo.script);
  return (L.witnessScript || (0, psbtutils_1.isP2WPKH)(oe.script)) && (oe.isSegwit = !0), oe;
}
function getSignersFromHD(B, L, J) {
  const ne = (0, utils_1$1.checkForInput)(L, B);
  if (!ne.bip32Derivation || ne.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const oe = ne.bip32Derivation.map((Ce) => {
    if (Ce.masterFingerprint.equals(J.fingerprint))
      return Ce;
  }).filter((Ce) => !!Ce);
  if (oe.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return oe.map((Ce) => {
    const rt = J.derivePath(Ce.path);
    if (!Ce.pubkey.equals(rt.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return rt;
  });
}
function getSortedSigs(B, L) {
  return payments.p2ms({ output: B }).pubkeys.map((ne) => (L.filter((oe) => oe.pubkey.equals(ne))[0] || {}).signature).filter((ne) => !!ne);
}
function scriptWitnessToWitnessStack(B) {
  let L = 0;
  function J(Ce) {
    return L += Ce, B.slice(L - Ce, L);
  }
  function ne() {
    const Ce = varuint.decode(B, L);
    return L += varuint.decode.bytes, Ce;
  }
  function oe() {
    return J(ne());
  }
  function ce() {
    const Ce = ne(), rt = [];
    for (let at = 0; at < Ce; at++) rt.push(oe());
    return rt;
  }
  return ce();
}
function sighashTypeToString(B) {
  let L = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      L += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      L += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      L += "SIGHASH_NONE";
      break;
  }
  return L;
}
function addNonWitnessTxCache(B, L, J) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[J] = L.nonWitnessUtxo;
  const ne = transaction_1.Transaction.fromBuffer(L.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[J] = ne;
  const oe = B, ce = J;
  delete L.nonWitnessUtxo, Object.defineProperty(L, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const Ce = oe.__NON_WITNESS_UTXO_BUF_CACHE[ce], rt = oe.__NON_WITNESS_UTXO_TX_CACHE[ce];
      if (Ce !== void 0)
        return Ce;
      {
        const at = rt.toBuffer();
        return oe.__NON_WITNESS_UTXO_BUF_CACHE[ce] = at, at;
      }
    },
    set(Ce) {
      oe.__NON_WITNESS_UTXO_BUF_CACHE[ce] = Ce;
    }
  });
}
function inputFinalizeGetAmts(B, L, J, ne) {
  let oe = 0;
  B.forEach((at, ht) => {
    if (ne && at.finalScriptSig && (L.ins[ht].script = at.finalScriptSig), ne && at.finalScriptWitness && (L.ins[ht].witness = scriptWitnessToWitnessStack(
      at.finalScriptWitness
    )), at.witnessUtxo)
      oe += at.witnessUtxo.value;
    else if (at.nonWitnessUtxo) {
      const it = nonWitnessUtxoTxFromCache(J, at, ht), lt = L.ins[ht].index, Et = it.outs[lt];
      oe += Et.value;
    }
  });
  const ce = L.outs.reduce((at, ht) => at + ht.value, 0), Ce = oe - ce;
  if (Ce < 0)
    throw new Error("Outputs are spending more than Inputs");
  const rt = L.virtualSize();
  J.__FEE = Ce, J.__EXTRACTED_TX = L, J.__FEE_RATE = Math.floor(Ce / rt);
}
function nonWitnessUtxoTxFromCache(B, L, J) {
  const ne = B.__NON_WITNESS_UTXO_TX_CACHE;
  return ne[J] || addNonWitnessTxCache(B, L, J), ne[J];
}
function getScriptFromUtxo(B, L, J) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, L, J);
  return ne;
}
function getScriptAndAmountFromUtxo(B, L, J) {
  if (L.witnessUtxo !== void 0)
    return {
      script: L.witnessUtxo.script,
      value: L.witnessUtxo.value
    };
  if (L.nonWitnessUtxo !== void 0) {
    const oe = nonWitnessUtxoTxFromCache(
      J,
      L,
      B
    ).outs[J.__TX.ins[B].index];
    return { script: oe.script, value: oe.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, L, J, ne) {
  const oe = getScriptFromUtxo(J, L, ne), { meaningfulScript: ce } = getMeaningfulScript(
    oe,
    J,
    "input",
    L.redeemScript,
    L.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ce);
}
function pubkeyInOutput(B, L, J, ne) {
  const oe = ne.__TX.outs[J].script, { meaningfulScript: ce } = getMeaningfulScript(
    oe,
    J,
    "output",
    L.redeemScript,
    L.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ce);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const L = bscript.decompile(B);
  if (!L) return;
  const J = L[L.length - 1];
  if (!(!Buffer$D.isBuffer(J) || isPubkeyLike(J) || isSigLike(J) || !bscript.decompile(J)))
    return J;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const L = scriptWitnessToWitnessStack(B), J = L[L.length - 1];
  if (!(isPubkeyLike(J) || !bscript.decompile(J)))
    return J;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const L = B[64] & 1, J = B.slice(0, 33);
    return J[0] = 2 | L, J;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, L, J, ne, oe) {
  const ce = (0, psbtutils_1.isP2SHScript)(B), Ce = ce && ne && (0, psbtutils_1.isP2WSHScript)(ne), rt = (0, psbtutils_1.isP2WSHScript)(B);
  if (ce && ne === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((rt || Ce) && oe === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let at;
  return Ce ? (at = oe, checkRedeemScript(L, B, ne, J), checkWitnessScript(L, ne, oe, J), checkInvalidP2WSH(at)) : rt ? (at = oe, checkWitnessScript(L, B, oe, J), checkInvalidP2WSH(at)) : ce ? (at = ne, checkRedeemScript(L, B, ne, J)) : at = B, {
    meaningfulScript: at,
    type: Ce ? "p2sh-p2wsh" : ce ? "p2sh" : rt ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range$1(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const L = requireAddress();
  B.address = L;
  const J = crypto$6;
  B.crypto = J;
  const ne = networks$2;
  B.networks = ne;
  const oe = requirePayments();
  B.payments = oe;
  const ce = requireScript();
  B.script = ce;
  var Ce = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return Ce.Block;
    }
  });
  var rt = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return rt.Psbt;
    }
  });
  var at = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return at.OPS;
    }
  });
  var ht = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return ht.Transaction;
    }
  });
  var it = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return it.initEccLib;
    }
  });
})(src$4);
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, L) {
  var J;
  return (J = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : J.get(L);
}
function _stringify(B) {
  var J, ne;
  let L = typeof B;
  return L === "object" && (L = (B && ((ne = (J = Object.getPrototypeOf(B)) == null ? void 0 : J.constructor) == null ? void 0 : ne.name)) ?? "null"), L === "string" ? `"${B}"` : L === "number" || L === "bigint" || L === "boolean" ? `${B}` : L;
}
function _addIssue(B, L, J, ne, oe) {
  const ce = oe && "input" in oe ? oe.input : J.value, Ce = (oe == null ? void 0 : oe.expected) ?? B.expects ?? null, rt = (oe == null ? void 0 : oe.received) ?? _stringify(ce), at = {
    kind: B.kind,
    type: B.type,
    input: ce,
    expected: Ce,
    received: rt,
    message: `Invalid ${L}: ${Ce ? `Expected ${Ce} but r` : "R"}eceived ${rt}`,
    // @ts-expect-error
    requirement: B.requirement,
    path: oe == null ? void 0 : oe.path,
    issues: oe == null ? void 0 : oe.issues,
    lang: ne.lang,
    abortEarly: ne.abortEarly,
    abortPipeEarly: ne.abortPipeEarly
  }, ht = B.kind === "schema", it = (oe == null ? void 0 : oe.message) ?? // @ts-expect-error
  B.message ?? getSpecificMessage(B.reference, at.lang) ?? (ht ? getSchemaMessage(at.lang) : null) ?? ne.message ?? getGlobalMessage(at.lang);
  it && (at.message = typeof it == "function" ? it(at) : it), ht && (J.typed = !1), J.issues ? J.issues.push(at) : J.issues = [at];
}
function _isValidObjectKey(B, L) {
  return Object.hasOwn(B, L) && L !== "__proto__" && L !== "prototype" && L !== "constructor";
}
function getDefault(B, L, J) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(L, J)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function array(B, L) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: L,
    _run(J, ne) {
      var ce;
      const oe = J.value;
      if (Array.isArray(oe)) {
        J.typed = !0, J.value = [];
        for (let Ce = 0; Ce < oe.length; Ce++) {
          const rt = oe[Ce], at = this.item._run({ typed: !1, value: rt }, ne);
          if (at.issues) {
            const ht = {
              type: "array",
              origin: "value",
              input: oe,
              key: Ce,
              value: rt
            };
            for (const it of at.issues)
              it.path ? it.path.unshift(ht) : it.path = [ht], (ce = J.issues) == null || ce.push(it);
            if (J.issues || (J.issues = at.issues), ne.abortEarly) {
              J.typed = !1;
              break;
            }
          }
          at.typed || (J.typed = !1), J.value.push(at.value);
        }
      } else
        _addIssue(this, "type", J, ne);
      return J;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(L, J) {
      return typeof L.value == "boolean" ? L.typed = !0 : _addIssue(this, "type", L, J), L;
    }
  };
}
function enum_(B, L) {
  const J = Object.entries(B).filter(([ne]) => isNaN(+ne)).map(([, ne]) => ne);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: J.map(_stringify).join(" | ") || "never",
    async: !1,
    enum: B,
    options: J,
    message: L,
    _run(ne, oe) {
      return this.options.includes(ne.value) ? ne.typed = !0 : _addIssue(this, "type", ne, oe), ne;
    }
  };
}
function literal(B, L) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: L,
    _run(J, ne) {
      return J.value === this.literal ? J.typed = !0 : _addIssue(this, "type", J, ne), J;
    }
  };
}
function looseObject(B, L) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: L,
    _run(J, ne) {
      var ce;
      const oe = J.value;
      if (oe && typeof oe == "object") {
        J.typed = !0, J.value = {};
        for (const Ce in this.entries) {
          const rt = oe[Ce], at = this.entries[Ce]._run(
            { typed: !1, value: rt },
            ne
          );
          if (at.issues) {
            const ht = {
              type: "object",
              origin: "value",
              input: oe,
              key: Ce,
              value: rt
            };
            for (const it of at.issues)
              it.path ? it.path.unshift(ht) : it.path = [ht], (ce = J.issues) == null || ce.push(it);
            if (J.issues || (J.issues = at.issues), ne.abortEarly) {
              J.typed = !1;
              break;
            }
          }
          at.typed || (J.typed = !1), (at.value !== void 0 || Ce in oe) && (J.value[Ce] = at.value);
        }
        if (!J.issues || !ne.abortEarly)
          for (const Ce in oe)
            _isValidObjectKey(oe, Ce) && !(Ce in this.entries) && (J.value[Ce] = oe[Ce]);
      } else
        _addIssue(this, "type", J, ne);
      return J;
    }
  };
}
function nonOptional(B, L) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: L,
    _run(J, ne) {
      return J.value === void 0 ? (_addIssue(this, "type", J, ne), J) : this.wrapped._run(J, ne);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(L, J) {
      return L.value === null ? L.typed = !0 : _addIssue(this, "type", L, J), L;
    }
  };
}
function nullish(B, ...L) {
  const J = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${B.expects} | null | undefined`,
    async: !1,
    wrapped: B,
    _run(ne, oe) {
      return (ne.value === null || ne.value === void 0) && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        oe
      )), ne.value === null || ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, oe);
    }
  };
  return 0 in L && (J.default = L[0]), J;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(L, J) {
      return typeof L.value == "number" && !isNaN(L.value) ? L.typed = !0 : _addIssue(this, "type", L, J), L;
    }
  };
}
function object(B, L) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: L,
    _run(J, ne) {
      var ce;
      const oe = J.value;
      if (oe && typeof oe == "object") {
        J.typed = !0, J.value = {};
        for (const Ce in this.entries) {
          const rt = oe[Ce], at = this.entries[Ce]._run(
            { typed: !1, value: rt },
            ne
          );
          if (at.issues) {
            const ht = {
              type: "object",
              origin: "value",
              input: oe,
              key: Ce,
              value: rt
            };
            for (const it of at.issues)
              it.path ? it.path.unshift(ht) : it.path = [ht], (ce = J.issues) == null || ce.push(it);
            if (J.issues || (J.issues = at.issues), ne.abortEarly) {
              J.typed = !1;
              break;
            }
          }
          at.typed || (J.typed = !1), (at.value !== void 0 || Ce in oe) && (J.value[Ce] = at.value);
        }
      } else
        _addIssue(this, "type", J, ne);
      return J;
    }
  };
}
function optional(B, ...L) {
  const J = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${B.expects} | undefined`,
    async: !1,
    wrapped: B,
    _run(ne, oe) {
      return ne.value === void 0 && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        oe
      )), ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, oe);
    }
  };
  return 0 in L && (J.default = L[0]), J;
}
function picklist(B, L) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: B.map(_stringify).join(" | ") || "never",
    async: !1,
    options: B,
    message: L,
    _run(J, ne) {
      return this.options.includes(J.value) ? J.typed = !0 : _addIssue(this, "type", J, ne), J;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(L, J) {
      return typeof L.value == "string" ? L.typed = !0 : _addIssue(this, "type", L, J), L;
    }
  };
}
function undefined_(B) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: !1,
    message: B,
    _run(L, J) {
      return L.value === void 0 ? L.typed = !0 : _addIssue(this, "type", L, J), L;
    }
  };
}
function _subIssues(B) {
  let L;
  if (B)
    for (const J of B)
      L ? L.push(...J.issues) : L = J.issues;
  return L;
}
function union(B, L) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(B.map((J) => J.expects))].join(" | ") || "never",
    async: !1,
    options: B,
    message: L,
    _run(J, ne) {
      let oe, ce, Ce;
      for (const rt of this.options) {
        const at = rt._run(
          { typed: !1, value: J.value },
          ne
        );
        if (at.typed)
          if (at.issues)
            ce ? ce.push(at) : ce = [at];
          else {
            oe = at;
            break;
          }
        else
          Ce ? Ce.push(at) : Ce = [at];
      }
      if (oe)
        return oe;
      if (ce) {
        if (ce.length === 1)
          return ce[0];
        _addIssue(this, "type", J, ne, {
          issues: _subIssues(ce)
        }), J.typed = !0;
      } else {
        if ((Ce == null ? void 0 : Ce.length) === 1)
          return Ce[0];
        _addIssue(this, "type", J, ne, {
          issues: _subIssues(Ce)
        });
      }
      return J;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
function getValue(B, L) {
  return B == null ? void 0 : B[L];
}
function isHostObject(B) {
  var L = !1;
  if (B != null && typeof B.toString != "function")
    try {
      L = !!(B + "");
    } catch {
    }
  return L;
}
var funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var B = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return B ? "Symbol(src)_1." + B : "";
}(), funcToString = funcProto.toString, hasOwnProperty$1 = objectProto.hasOwnProperty, objectToString$1 = objectProto.toString, reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), Symbol$1 = root.Symbol;
Symbol$1 && Symbol$1.isConcatSpreadable;
getNative(root, "Map");
getNative(Object, "create");
function baseIsNative(B) {
  if (!isObject$2(B) || isMasked(B))
    return !1;
  var L = isFunction$1(B) || isHostObject(B) ? reIsNative : reIsHostCtor;
  return L.test(toSource(B));
}
function getNative(B, L) {
  var J = getValue(B, L);
  return baseIsNative(J) ? J : void 0;
}
function isMasked(B) {
  return !!maskSrcKey && maskSrcKey in B;
}
function toSource(B) {
  if (B != null) {
    try {
      return funcToString.call(B);
    } catch {
    }
    try {
      return B + "";
    } catch {
    }
  }
  return "";
}
function isFunction$1(B) {
  var L = isObject$2(B) ? objectToString$1.call(B) : "";
  return L == funcTag || L == genTag;
}
function isObject$2(B) {
  var L = typeof B;
  return !!B && (L == "object" || L == "function");
}
var lib$2 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var L = B.length;
  if (L % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var J = B.indexOf("=");
  J === -1 && (J = L);
  var ne = J === L ? 0 : 4 - J % 4;
  return [J, ne];
}
function byteLength(B) {
  var L = getLens(B), J = L[0], ne = L[1];
  return (J + ne) * 3 / 4 - ne;
}
function _byteLength(B, L, J) {
  return (L + J) * 3 / 4 - J;
}
function toByteArray(B) {
  var L, J = getLens(B), ne = J[0], oe = J[1], ce = new Arr(_byteLength(B, ne, oe)), Ce = 0, rt = oe > 0 ? ne - 4 : ne, at;
  for (at = 0; at < rt; at += 4)
    L = revLookup[B.charCodeAt(at)] << 18 | revLookup[B.charCodeAt(at + 1)] << 12 | revLookup[B.charCodeAt(at + 2)] << 6 | revLookup[B.charCodeAt(at + 3)], ce[Ce++] = L >> 16 & 255, ce[Ce++] = L >> 8 & 255, ce[Ce++] = L & 255;
  return oe === 2 && (L = revLookup[B.charCodeAt(at)] << 2 | revLookup[B.charCodeAt(at + 1)] >> 4, ce[Ce++] = L & 255), oe === 1 && (L = revLookup[B.charCodeAt(at)] << 10 | revLookup[B.charCodeAt(at + 1)] << 4 | revLookup[B.charCodeAt(at + 2)] >> 2, ce[Ce++] = L >> 8 & 255, ce[Ce++] = L & 255), ce;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, L, J) {
  for (var ne, oe = [], ce = L; ce < J; ce += 3)
    ne = (B[ce] << 16 & 16711680) + (B[ce + 1] << 8 & 65280) + (B[ce + 2] & 255), oe.push(tripletToBase64(ne));
  return oe.join("");
}
function fromByteArray(B) {
  for (var L, J = B.length, ne = J % 3, oe = [], ce = 16383, Ce = 0, rt = J - ne; Ce < rt; Ce += ce)
    oe.push(encodeChunk(B, Ce, Ce + ce > rt ? rt : Ce + ce));
  return ne === 1 ? (L = B[J - 1], oe.push(
    lookup[L >> 2] + lookup[L << 4 & 63] + "=="
  )) : ne === 2 && (L = (B[J - 2] << 8) + B[J - 1], oe.push(
    lookup[L >> 10] + lookup[L >> 4 & 63] + lookup[L << 2 & 63] + "="
  )), oe.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$1(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode$1;
function decode$2(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$2;
var cryptoClients = {}, secp256k1$1 = {}, hmac$2 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const L = _assert, J = utils$p;
  class ne extends J.Hash {
    constructor(Ce, rt) {
      super(), this.finished = !1, this.destroyed = !1, (0, L.hash)(Ce);
      const at = (0, J.toBytes)(rt);
      if (this.iHash = Ce.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ht = this.blockLen, it = new Uint8Array(ht);
      it.set(at.length > ht ? Ce.create().update(at).digest() : at);
      for (let lt = 0; lt < it.length; lt++)
        it[lt] ^= 54;
      this.iHash.update(it), this.oHash = Ce.create();
      for (let lt = 0; lt < it.length; lt++)
        it[lt] ^= 106;
      this.oHash.update(it), it.fill(0);
    }
    update(Ce) {
      return (0, L.exists)(this), this.iHash.update(Ce), this;
    }
    digestInto(Ce) {
      (0, L.exists)(this), (0, L.bytes)(Ce, this.outputLen), this.finished = !0, this.iHash.digestInto(Ce), this.oHash.update(Ce), this.oHash.digestInto(Ce), this.destroy();
    }
    digest() {
      const Ce = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(Ce), Ce;
    }
    _cloneInto(Ce) {
      Ce || (Ce = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: rt, iHash: at, finished: ht, destroyed: it, blockLen: lt, outputLen: Et } = this;
      return Ce = Ce, Ce.finished = ht, Ce.destroyed = it, Ce.blockLen = lt, Ce.outputLen = Et, Ce.oHash = rt._cloneInto(Ce.oHash), Ce.iHash = at._cloneInto(Ce.iHash), Ce;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = ne;
  const oe = (ce, Ce, rt) => new ne(ce, Ce).update(rt).digest();
  B.hmac = oe, B.hmac.create = (ce, Ce) => new ne(ce, Ce);
})(hmac$2);
var lib$1 = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$B = safeBufferExports$1.Buffer, crypto$4 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$4 && crypto$4.getRandomValues ? browser$b.exports = randomBytes$3 : browser$b.exports = oldBrowser$1;
function randomBytes$3(B, L) {
  if (B > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var J = Buffer$B.allocUnsafe(B);
  if (B > 0)
    if (B > MAX_BYTES)
      for (var ne = 0; ne < B; ne += MAX_BYTES)
        crypto$4.getRandomValues(J.slice(ne, ne + MAX_BYTES));
    else
      crypto$4.getRandomValues(J);
  return typeof L == "function" ? process$1.nextTick(function() {
    L(null, J);
  }) : J;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(L, J) {
  J && (L.super_ = J, L.prototype = Object.create(J.prototype, {
    constructor: {
      value: L,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(L, J) {
  if (J) {
    L.super_ = J;
    var ne = function() {
    };
    ne.prototype = J.prototype, L.prototype = new ne(), L.prototype.constructor = L;
  }
};
var inherits_browserExports = inherits_browser.exports, readableBrowser$1 = { exports: {} }, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(L, J, ne) {
  return Function.prototype.apply.call(L, J, ne);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(L) {
  return Object.getOwnPropertyNames(L).concat(Object.getOwnPropertySymbols(L));
} : ReflectOwnKeys = function(L) {
  return Object.getOwnPropertyNames(L);
};
function ProcessEmitWarning(B) {
  console && console.warn && console.warn(B);
}
var NumberIsNaN = Number.isNaN || function(L) {
  return L !== L;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(B) {
  if (typeof B != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof B);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(B) {
    if (typeof B != "number" || B < 0 || NumberIsNaN(B))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + B + ".");
    defaultMaxListeners = B;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(L) {
  if (typeof L != "number" || L < 0 || NumberIsNaN(L))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + L + ".");
  return this._maxListeners = L, this;
};
function _getMaxListeners(B) {
  return B._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : B._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(L) {
  for (var J = [], ne = 1; ne < arguments.length; ne++) J.push(arguments[ne]);
  var oe = L === "error", ce = this._events;
  if (ce !== void 0)
    oe = oe && ce.error === void 0;
  else if (!oe)
    return !1;
  if (oe) {
    var Ce;
    if (J.length > 0 && (Ce = J[0]), Ce instanceof Error)
      throw Ce;
    var rt = new Error("Unhandled error." + (Ce ? " (" + Ce.message + ")" : ""));
    throw rt.context = Ce, rt;
  }
  var at = ce[L];
  if (at === void 0)
    return !1;
  if (typeof at == "function")
    ReflectApply(at, this, J);
  else
    for (var ht = at.length, it = arrayClone(at, ht), ne = 0; ne < ht; ++ne)
      ReflectApply(it[ne], this, J);
  return !0;
};
function _addListener(B, L, J, ne) {
  var oe, ce, Ce;
  if (checkListener(J), ce = B._events, ce === void 0 ? (ce = B._events = /* @__PURE__ */ Object.create(null), B._eventsCount = 0) : (ce.newListener !== void 0 && (B.emit(
    "newListener",
    L,
    J.listener ? J.listener : J
  ), ce = B._events), Ce = ce[L]), Ce === void 0)
    Ce = ce[L] = J, ++B._eventsCount;
  else if (typeof Ce == "function" ? Ce = ce[L] = ne ? [J, Ce] : [Ce, J] : ne ? Ce.unshift(J) : Ce.push(J), oe = _getMaxListeners(B), oe > 0 && Ce.length > oe && !Ce.warned) {
    Ce.warned = !0;
    var rt = new Error("Possible EventEmitter memory leak detected. " + Ce.length + " " + String(L) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    rt.name = "MaxListenersExceededWarning", rt.emitter = B, rt.type = L, rt.count = Ce.length, ProcessEmitWarning(rt);
  }
  return B;
}
EventEmitter.prototype.addListener = function(L, J) {
  return _addListener(this, L, J, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(L, J) {
  return _addListener(this, L, J, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(B, L, J) {
  var ne = { fired: !1, wrapFn: void 0, target: B, type: L, listener: J }, oe = onceWrapper.bind(ne);
  return oe.listener = J, ne.wrapFn = oe, oe;
}
EventEmitter.prototype.once = function(L, J) {
  return checkListener(J), this.on(L, _onceWrap(this, L, J)), this;
};
EventEmitter.prototype.prependOnceListener = function(L, J) {
  return checkListener(J), this.prependListener(L, _onceWrap(this, L, J)), this;
};
EventEmitter.prototype.removeListener = function(L, J) {
  var ne, oe, ce, Ce, rt;
  if (checkListener(J), oe = this._events, oe === void 0)
    return this;
  if (ne = oe[L], ne === void 0)
    return this;
  if (ne === J || ne.listener === J)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete oe[L], oe.removeListener && this.emit("removeListener", L, ne.listener || J));
  else if (typeof ne != "function") {
    for (ce = -1, Ce = ne.length - 1; Ce >= 0; Ce--)
      if (ne[Ce] === J || ne[Ce].listener === J) {
        rt = ne[Ce].listener, ce = Ce;
        break;
      }
    if (ce < 0)
      return this;
    ce === 0 ? ne.shift() : spliceOne(ne, ce), ne.length === 1 && (oe[L] = ne[0]), oe.removeListener !== void 0 && this.emit("removeListener", L, rt || J);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(L) {
  var J, ne, oe;
  if (ne = this._events, ne === void 0)
    return this;
  if (ne.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ne[L] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ne[L]), this;
  if (arguments.length === 0) {
    var ce = Object.keys(ne), Ce;
    for (oe = 0; oe < ce.length; ++oe)
      Ce = ce[oe], Ce !== "removeListener" && this.removeAllListeners(Ce);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (J = ne[L], typeof J == "function")
    this.removeListener(L, J);
  else if (J !== void 0)
    for (oe = J.length - 1; oe >= 0; oe--)
      this.removeListener(L, J[oe]);
  return this;
};
function _listeners(B, L, J) {
  var ne = B._events;
  if (ne === void 0)
    return [];
  var oe = ne[L];
  return oe === void 0 ? [] : typeof oe == "function" ? J ? [oe.listener || oe] : [oe] : J ? unwrapListeners(oe) : arrayClone(oe, oe.length);
}
EventEmitter.prototype.listeners = function(L) {
  return _listeners(this, L, !0);
};
EventEmitter.prototype.rawListeners = function(L) {
  return _listeners(this, L, !1);
};
EventEmitter.listenerCount = function(B, L) {
  return typeof B.listenerCount == "function" ? B.listenerCount(L) : listenerCount.call(B, L);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(B) {
  var L = this._events;
  if (L !== void 0) {
    var J = L[B];
    if (typeof J == "function")
      return 1;
    if (J !== void 0)
      return J.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(B, L) {
  for (var J = new Array(L), ne = 0; ne < L; ++ne)
    J[ne] = B[ne];
  return J;
}
function spliceOne(B, L) {
  for (; L + 1 < B.length; L++)
    B[L] = B[L + 1];
  B.pop();
}
function unwrapListeners(B) {
  for (var L = new Array(B.length), J = 0; J < L.length; ++J)
    L[J] = B[J].listener || B[J];
  return L;
}
function once$2(B, L) {
  return new Promise(function(J, ne) {
    function oe(Ce) {
      B.removeListener(L, ce), ne(Ce);
    }
    function ce() {
      typeof B.removeListener == "function" && B.removeListener("error", oe), J([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(B, L, ce, { once: !0 }), L !== "error" && addErrorHandlerIfEventEmitter(B, oe, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(B, L, J) {
  typeof B.on == "function" && eventTargetAgnosticAddListener(B, "error", L, J);
}
function eventTargetAgnosticAddListener(B, L, J, ne) {
  if (typeof B.on == "function")
    ne.once ? B.once(L, J) : B.on(L, J);
  else if (typeof B.addEventListener == "function")
    B.addEventListener(L, function oe(ce) {
      ne.once && B.removeEventListener(L, oe), J(ce);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof B);
}
var eventsExports = events.exports, streamBrowser$1 = eventsExports.EventEmitter, util$3 = {}, types$2 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var L = {}, J = Symbol("test"), ne = Object(J);
  if (typeof J == "string" || Object.prototype.toString.call(J) !== "[object Symbol]" || Object.prototype.toString.call(ne) !== "[object Symbol]")
    return !1;
  var oe = 42;
  L[J] = oe;
  for (J in L)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(L).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(L).length !== 0)
    return !1;
  var ce = Object.getOwnPropertySymbols(L);
  if (ce.length !== 1 || ce[0] !== J || !Object.prototype.propertyIsEnumerable.call(L, J))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var Ce = Object.getOwnPropertyDescriptor(L, J);
    if (Ce.value !== oe || Ce.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(L, J) {
  for (var ne = [], oe = 0; oe < L.length; oe += 1)
    ne[oe] = L[oe];
  for (var ce = 0; ce < J.length; ce += 1)
    ne[ce + L.length] = J[ce];
  return ne;
}, slicy = function(L, J) {
  for (var ne = [], oe = J, ce = 0; oe < L.length; oe += 1, ce += 1)
    ne[ce] = L[oe];
  return ne;
}, joiny = function(B, L) {
  for (var J = "", ne = 0; ne < B.length; ne += 1)
    J += B[ne], ne + 1 < B.length && (J += L);
  return J;
}, implementation$1 = function(L) {
  var J = this;
  if (typeof J != "function" || toStr$3.apply(J) !== funcType)
    throw new TypeError(ERROR_MESSAGE + J);
  for (var ne = slicy(arguments, 1), oe, ce = function() {
    if (this instanceof oe) {
      var it = J.apply(
        this,
        concatty(ne, arguments)
      );
      return Object(it) === it ? it : this;
    }
    return J.apply(
      L,
      concatty(ne, arguments)
    );
  }, Ce = max(0, J.length - ne.length), rt = [], at = 0; at < Ce; at++)
    rt[at] = "$" + at;
  if (oe = Function("binder", "return function (" + joiny(rt, ",") + "){ return binder.apply(this,arguments); }")(ce), J.prototype) {
    var ht = function() {
    };
    ht.prototype = J.prototype, oe.prototype = new ht(), ht.prototype = null;
  }
  return oe;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$1 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call$1, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(B) {
  try {
    return $Function('"use strict"; return (' + B + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(B) {
  return B.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (B) {
    var errorProto = getProto$1(getProto$1(B));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function B(L) {
  var J;
  if (L === "%AsyncFunction%")
    J = getEvalledConstructor("async function () {}");
  else if (L === "%GeneratorFunction%")
    J = getEvalledConstructor("function* () {}");
  else if (L === "%AsyncGeneratorFunction%")
    J = getEvalledConstructor("async function* () {}");
  else if (L === "%AsyncGenerator%") {
    var ne = B("%AsyncGeneratorFunction%");
    ne && (J = ne.prototype);
  } else if (L === "%AsyncIteratorPrototype%") {
    var oe = B("%AsyncGenerator%");
    oe && getProto$1 && (J = getProto$1(oe.prototype));
  }
  return INTRINSICS[L] = J, J;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn = hasown, $concat = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(L) {
  var J = $strSlice(L, 0, 1), ne = $strSlice(L, -1);
  if (J === "%" && ne !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (ne === "%" && J !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var oe = [];
  return $replace(L, rePropName, function(ce, Ce, rt, at) {
    oe[oe.length] = rt ? $replace(at, reEscapeChar, "$1") : Ce || ce;
  }), oe;
}, getBaseIntrinsic = function(L, J) {
  var ne = L, oe;
  if (hasOwn(LEGACY_ALIASES, ne) && (oe = LEGACY_ALIASES[ne], ne = "%" + oe[0] + "%"), hasOwn(INTRINSICS, ne)) {
    var ce = INTRINSICS[ne];
    if (ce === needsEval && (ce = doEval(ne)), typeof ce > "u" && !J)
      throw new $TypeError$2("intrinsic " + L + " exists, but is not available. Please file an issue!");
    return {
      alias: oe,
      name: ne,
      value: ce
    };
  }
  throw new $SyntaxError$1("intrinsic " + L + " does not exist!");
}, getIntrinsic = function(L, J) {
  if (typeof L != "string" || L.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof J != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, L) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var ne = stringToPath(L), oe = ne.length > 0 ? ne[0] : "", ce = getBaseIntrinsic("%" + oe + "%", J), Ce = ce.name, rt = ce.value, at = !1, ht = ce.alias;
  ht && (oe = ht[0], $spliceApply(ne, $concat([0, 1], ht)));
  for (var it = 1, lt = !0; it < ne.length; it += 1) {
    var Et = ne[it], wt = $strSlice(Et, 0, 1), Rt = $strSlice(Et, -1);
    if ((wt === '"' || wt === "'" || wt === "`" || Rt === '"' || Rt === "'" || Rt === "`") && wt !== Rt)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((Et === "constructor" || !lt) && (at = !0), oe += "." + Et, Ce = "%" + oe + "%", hasOwn(INTRINSICS, Ce))
      rt = INTRINSICS[Ce];
    else if (rt != null) {
      if (!(Et in rt)) {
        if (!J)
          throw new $TypeError$2("base intrinsic for " + L + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && it + 1 >= ne.length) {
        var Mt = $gOPD$1(rt, Et);
        lt = !!Mt, lt && "get" in Mt && !("originalValue" in Mt.get) ? rt = Mt.get : rt = rt[Et];
      } else
        lt = hasOwn(rt, Et), rt = rt[Et];
      lt && !at && (INTRINSICS[Ce] = rt);
    }
  }
  return rt;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var B = getIntrinsic, L = B("%Object.defineProperty%", !0) || !1;
  if (L)
    try {
      L({}, "a", { value: 1 });
    } catch {
      L = !1;
    }
  return esDefineProperty = L, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(L, J, ne) {
  if (!L || typeof L != "object" && typeof L != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof J != "string" && typeof J != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var oe = arguments.length > 3 ? arguments[3] : null, ce = arguments.length > 4 ? arguments[4] : null, Ce = arguments.length > 5 ? arguments[5] : null, rt = arguments.length > 6 ? arguments[6] : !1, at = !!gopd && gopd(L, J);
  if ($defineProperty$1)
    $defineProperty$1(L, J, {
      configurable: Ce === null && at ? at.configurable : !Ce,
      enumerable: oe === null && at ? at.enumerable : !oe,
      value: ne,
      writable: ce === null && at ? at.writable : !ce
    });
  else if (rt || !oe && !ce && !Ce)
    L[J] = ne;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function(L, J) {
  if (typeof L != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof J != "number" || J < 0 || J > 4294967295 || $floor(J) !== J)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var ne = arguments.length > 2 && !!arguments[2], oe = !0, ce = !0;
  if ("length" in L && gOPD$1) {
    var Ce = gOPD$1(L, "length");
    Ce && !Ce.configurable && (oe = !1), Ce && !Ce.writable && (ce = !1);
  }
  return (oe || ce || !ne) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    L,
    "length",
    J,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    L,
    "length",
    J
  )), L;
};
(function(B) {
  var L = functionBind, J = getIntrinsic, ne = setFunctionLength, oe = type, ce = J("%Function.prototype.apply%"), Ce = J("%Function.prototype.call%"), rt = J("%Reflect.apply%", !0) || L.call(Ce, ce), at = requireEsDefineProperty(), ht = J("%Math.max%");
  B.exports = function(Et) {
    if (typeof Et != "function")
      throw new oe("a function is required");
    var wt = rt(L, Ce, arguments);
    return ne(
      wt,
      1 + ht(0, Et.length - (arguments.length - 1)),
      !0
    );
  };
  var it = function() {
    return rt(L, ce, arguments);
  };
  at ? at(B.exports, "apply", { value: it }) : B.exports.apply = it;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function(L, J) {
  var ne = GetIntrinsic(L, !!J);
  return typeof ne == "function" && $indexOf$1(L, ".prototype.") > -1 ? callBind$1(ne) : ne;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function(L) {
  return hasToStringTag$3 && L && typeof L == "object" && Symbol.toStringTag in L ? !1 : $toString$1(L) === "[object Arguments]";
}, isLegacyArguments = function(L) {
  return isStandardArguments(L) ? !0 : L !== null && typeof L == "object" && typeof L.length == "number" && L.length >= 0 && $toString$1(L) !== "[object Array]" && $toString$1(L.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(L) {
  if (typeof L != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(L)))
    return !0;
  if (!hasToStringTag$2) {
    var J = toStr$2.call(L);
    return J === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var ne = getGeneratorFunc();
    GeneratorFunction = ne ? getProto(ne) : !1;
  }
  return getProto(L) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (B) {
    B !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(L) {
  try {
    var J = fnToStr.call(L);
    return constructorRegex.test(J);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(L) {
  try {
    return isES6ClassFn(L) ? !1 : (fnToStr.call(L), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(L) {
    if ((isIE68 || !L) && (typeof L > "u" || typeof L == "object"))
      try {
        var J = toStr$1.call(L);
        return (J === ddaClass || J === ddaClass2 || J === ddaClass3 || J === objectClass) && L("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(L) {
  if (isDDA(L))
    return !0;
  if (!L || typeof L != "function" && typeof L != "object")
    return !1;
  try {
    reflectApply(L, null, badArrayLike);
  } catch (J) {
    if (J !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(L) && tryFunctionObject(L);
} : function(L) {
  if (isDDA(L))
    return !0;
  if (!L || typeof L != "function" && typeof L != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(L);
  if (isES6ClassFn(L))
    return !1;
  var J = toStr$1.call(L);
  return J !== fnClass && J !== genClass && !/^\[object HTML/.test(J) ? !1 : tryFunctionObject(L);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(L, J, ne) {
  for (var oe = 0, ce = L.length; oe < ce; oe++)
    hasOwnProperty.call(L, oe) && (ne == null ? J(L[oe], oe, L) : J.call(ne, L[oe], oe, L));
}, forEachString = function(L, J, ne) {
  for (var oe = 0, ce = L.length; oe < ce; oe++)
    ne == null ? J(L.charAt(oe), oe, L) : J.call(ne, L.charAt(oe), oe, L);
}, forEachObject = function(L, J, ne) {
  for (var oe in L)
    hasOwnProperty.call(L, oe) && (ne == null ? J(L[oe], oe, L) : J.call(ne, L[oe], oe, L));
}, forEach$1 = function(L, J, ne) {
  if (!isCallable(J))
    throw new TypeError("iterator must be a function");
  var oe;
  arguments.length >= 3 && (oe = ne), toStr.call(L) === "[object Array]" ? forEachArray(L, J, oe) : typeof L == "string" ? forEachString(L, J, oe) : forEachObject(L, J, oe);
}, forEach_1 = forEach$1, possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$2 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var L = [], J = 0; J < possibleNames.length; J++)
    typeof g$2[possibleNames[J]] == "function" && (L[L.length] = possibleNames[J]);
  return L;
}, forEach = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function(L, J) {
  for (var ne = 0; ne < L.length; ne += 1)
    if (L[ne] === J)
      return ne;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(B) {
  var L = new g$1[B]();
  if (Symbol.toStringTag in L) {
    var J = getPrototypeOf(L), ne = gOPD(J, Symbol.toStringTag);
    if (!ne) {
      var oe = getPrototypeOf(J);
      ne = gOPD(oe, Symbol.toStringTag);
    }
    cache["$" + B] = callBind(ne.get);
  }
}) : forEach(typedArrays, function(B) {
  var L = new g$1[B](), J = L.slice || L.set;
  J && (cache["$" + B] = callBind(J));
});
var tryTypedArrays = function(L) {
  var J = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(ne, oe) {
      if (!J)
        try {
          "$" + ne(L) === oe && (J = $slice(oe, 1));
        } catch {
        }
    }
  ), J;
}, trySlices = function(L) {
  var J = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(ne, oe) {
      if (!J)
        try {
          ne(L), J = $slice(oe, 1);
        } catch {
        }
    }
  ), J;
}, whichTypedArray$1 = function(L) {
  if (!L || typeof L != "object")
    return !1;
  if (!hasToStringTag) {
    var J = $slice($toString(L), 8, -1);
    return $indexOf(typedArrays, J) > -1 ? J : J !== "Object" ? !1 : trySlices(L);
  }
  return gOPD ? tryTypedArrays(L) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(L) {
  return !!whichTypedArray(L);
};
(function(B) {
  var L = isArguments, J = isGeneratorFunction, ne = whichTypedArray$1, oe = isTypedArray;
  function ce(Mr) {
    return Mr.call.bind(Mr);
  }
  var Ce = typeof BigInt < "u", rt = typeof Symbol < "u", at = ce(Object.prototype.toString), ht = ce(Number.prototype.valueOf), it = ce(String.prototype.valueOf), lt = ce(Boolean.prototype.valueOf);
  if (Ce)
    var Et = ce(BigInt.prototype.valueOf);
  if (rt)
    var wt = ce(Symbol.prototype.valueOf);
  function Rt(Mr, Wn) {
    if (typeof Mr != "object")
      return !1;
    try {
      return Wn(Mr), !0;
    } catch {
      return !1;
    }
  }
  B.isArgumentsObject = L, B.isGeneratorFunction = J, B.isTypedArray = oe;
  function Mt(Mr) {
    return typeof Promise < "u" && Mr instanceof Promise || Mr !== null && typeof Mr == "object" && typeof Mr.then == "function" && typeof Mr.catch == "function";
  }
  B.isPromise = Mt;
  function Lt(Mr) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Mr) : oe(Mr) || Bt(Mr);
  }
  B.isArrayBufferView = Lt;
  function zt(Mr) {
    return ne(Mr) === "Uint8Array";
  }
  B.isUint8Array = zt;
  function Ot(Mr) {
    return ne(Mr) === "Uint8ClampedArray";
  }
  B.isUint8ClampedArray = Ot;
  function It(Mr) {
    return ne(Mr) === "Uint16Array";
  }
  B.isUint16Array = It;
  function Ft(Mr) {
    return ne(Mr) === "Uint32Array";
  }
  B.isUint32Array = Ft;
  function Jt(Mr) {
    return ne(Mr) === "Int8Array";
  }
  B.isInt8Array = Jt;
  function Vt(Mr) {
    return ne(Mr) === "Int16Array";
  }
  B.isInt16Array = Vt;
  function yr(Mr) {
    return ne(Mr) === "Int32Array";
  }
  B.isInt32Array = yr;
  function jt(Mr) {
    return ne(Mr) === "Float32Array";
  }
  B.isFloat32Array = jt;
  function Ut(Mr) {
    return ne(Mr) === "Float64Array";
  }
  B.isFloat64Array = Ut;
  function er(Mr) {
    return ne(Mr) === "BigInt64Array";
  }
  B.isBigInt64Array = er;
  function Ht(Mr) {
    return ne(Mr) === "BigUint64Array";
  }
  B.isBigUint64Array = Ht;
  function ct(Mr) {
    return at(Mr) === "[object Map]";
  }
  ct.working = typeof Map < "u" && ct(/* @__PURE__ */ new Map());
  function dt(Mr) {
    return typeof Map > "u" ? !1 : ct.working ? ct(Mr) : Mr instanceof Map;
  }
  B.isMap = dt;
  function ot(Mr) {
    return at(Mr) === "[object Set]";
  }
  ot.working = typeof Set < "u" && ot(/* @__PURE__ */ new Set());
  function ut(Mr) {
    return typeof Set > "u" ? !1 : ot.working ? ot(Mr) : Mr instanceof Set;
  }
  B.isSet = ut;
  function mt(Mr) {
    return at(Mr) === "[object WeakMap]";
  }
  mt.working = typeof WeakMap < "u" && mt(/* @__PURE__ */ new WeakMap());
  function gt(Mr) {
    return typeof WeakMap > "u" ? !1 : mt.working ? mt(Mr) : Mr instanceof WeakMap;
  }
  B.isWeakMap = gt;
  function St(Mr) {
    return at(Mr) === "[object WeakSet]";
  }
  St.working = typeof WeakSet < "u" && St(/* @__PURE__ */ new WeakSet());
  function xt(Mr) {
    return St(Mr);
  }
  B.isWeakSet = xt;
  function vt(Mr) {
    return at(Mr) === "[object ArrayBuffer]";
  }
  vt.working = typeof ArrayBuffer < "u" && vt(new ArrayBuffer());
  function $t(Mr) {
    return typeof ArrayBuffer > "u" ? !1 : vt.working ? vt(Mr) : Mr instanceof ArrayBuffer;
  }
  B.isArrayBuffer = $t;
  function yt(Mr) {
    return at(Mr) === "[object DataView]";
  }
  yt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && yt(new DataView(new ArrayBuffer(1), 0, 1));
  function Bt(Mr) {
    return typeof DataView > "u" ? !1 : yt.working ? yt(Mr) : Mr instanceof DataView;
  }
  B.isDataView = Bt;
  var rr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function dr(Mr) {
    return at(Mr) === "[object SharedArrayBuffer]";
  }
  function tr(Mr) {
    return typeof rr > "u" ? !1 : (typeof dr.working > "u" && (dr.working = dr(new rr())), dr.working ? dr(Mr) : Mr instanceof rr);
  }
  B.isSharedArrayBuffer = tr;
  function Dt(Mr) {
    return at(Mr) === "[object AsyncFunction]";
  }
  B.isAsyncFunction = Dt;
  function Wt(Mr) {
    return at(Mr) === "[object Map Iterator]";
  }
  B.isMapIterator = Wt;
  function or(Mr) {
    return at(Mr) === "[object Set Iterator]";
  }
  B.isSetIterator = or;
  function _r(Mr) {
    return at(Mr) === "[object Generator]";
  }
  B.isGeneratorObject = _r;
  function Xt(Mr) {
    return at(Mr) === "[object WebAssembly.Module]";
  }
  B.isWebAssemblyCompiledModule = Xt;
  function Qt(Mr) {
    return Rt(Mr, ht);
  }
  B.isNumberObject = Qt;
  function br(Mr) {
    return Rt(Mr, it);
  }
  B.isStringObject = br;
  function Dr(Mr) {
    return Rt(Mr, lt);
  }
  B.isBooleanObject = Dr;
  function Vr(Mr) {
    return Ce && Rt(Mr, Et);
  }
  B.isBigIntObject = Vr;
  function Zr(Mr) {
    return rt && Rt(Mr, wt);
  }
  B.isSymbolObject = Zr;
  function ln(Mr) {
    return Qt(Mr) || br(Mr) || Dr(Mr) || Vr(Mr) || Zr(Mr);
  }
  B.isBoxedPrimitive = ln;
  function _n(Mr) {
    return typeof Uint8Array < "u" && ($t(Mr) || tr(Mr));
  }
  B.isAnyArrayBuffer = _n, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Mr) {
    Object.defineProperty(B, Mr, {
      enumerable: !1,
      value: function() {
        throw new Error(Mr + " is not supported in userland");
      }
    });
  });
})(types$2);
var isBufferBrowser = function(L) {
  return L && typeof L == "object" && typeof L.copy == "function" && typeof L.fill == "function" && typeof L.readUInt8 == "function";
};
(function(B) {
  var L = Object.getOwnPropertyDescriptors || function(Bt) {
    for (var rr = Object.keys(Bt), dr = {}, tr = 0; tr < rr.length; tr++)
      dr[rr[tr]] = Object.getOwnPropertyDescriptor(Bt, rr[tr]);
    return dr;
  }, J = /%[sdj%]/g;
  B.format = function(yt) {
    if (!Jt(yt)) {
      for (var Bt = [], rr = 0; rr < arguments.length; rr++)
        Bt.push(Ce(arguments[rr]));
      return Bt.join(" ");
    }
    for (var rr = 1, dr = arguments, tr = dr.length, Dt = String(yt).replace(J, function(or) {
      if (or === "%%") return "%";
      if (rr >= tr) return or;
      switch (or) {
        case "%s":
          return String(dr[rr++]);
        case "%d":
          return Number(dr[rr++]);
        case "%j":
          try {
            return JSON.stringify(dr[rr++]);
          } catch {
            return "[Circular]";
          }
        default:
          return or;
      }
    }), Wt = dr[rr]; rr < tr; Wt = dr[++rr])
      Ot(Wt) || !Ut(Wt) ? Dt += " " + Wt : Dt += " " + Ce(Wt);
    return Dt;
  }, B.deprecate = function(yt, Bt) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return yt;
    if (typeof process$1 > "u")
      return function() {
        return B.deprecate(yt, Bt).apply(this, arguments);
      };
    var rr = !1;
    function dr() {
      if (!rr) {
        if (process$1.throwDeprecation)
          throw new Error(Bt);
        process$1.traceDeprecation ? console.trace(Bt) : console.error(Bt), rr = !0;
      }
      return yt.apply(this, arguments);
    }
    return dr;
  };
  var ne = {}, oe = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var ce = process$1.env.NODE_DEBUG;
    ce = ce.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), oe = new RegExp("^" + ce + "$", "i");
  }
  B.debuglog = function(yt) {
    if (yt = yt.toUpperCase(), !ne[yt])
      if (oe.test(yt)) {
        var Bt = process$1.pid;
        ne[yt] = function() {
          var rr = B.format.apply(B, arguments);
          console.error("%s %d: %s", yt, Bt, rr);
        };
      } else
        ne[yt] = function() {
        };
    return ne[yt];
  };
  function Ce(yt, Bt) {
    var rr = {
      seen: [],
      stylize: at
    };
    return arguments.length >= 3 && (rr.depth = arguments[2]), arguments.length >= 4 && (rr.colors = arguments[3]), zt(Bt) ? rr.showHidden = Bt : Bt && B._extend(rr, Bt), yr(rr.showHidden) && (rr.showHidden = !1), yr(rr.depth) && (rr.depth = 2), yr(rr.colors) && (rr.colors = !1), yr(rr.customInspect) && (rr.customInspect = !0), rr.colors && (rr.stylize = rt), it(rr, yt, rr.depth);
  }
  B.inspect = Ce, Ce.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, Ce.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function rt(yt, Bt) {
    var rr = Ce.styles[Bt];
    return rr ? "\x1B[" + Ce.colors[rr][0] + "m" + yt + "\x1B[" + Ce.colors[rr][1] + "m" : yt;
  }
  function at(yt, Bt) {
    return yt;
  }
  function ht(yt) {
    var Bt = {};
    return yt.forEach(function(rr, dr) {
      Bt[rr] = !0;
    }), Bt;
  }
  function it(yt, Bt, rr) {
    if (yt.customInspect && Bt && ct(Bt.inspect) && // Filter out the util module, it's inspect function is special
    Bt.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
    !(Bt.constructor && Bt.constructor.prototype === Bt)) {
      var dr = Bt.inspect(rr, yt);
      return Jt(dr) || (dr = it(yt, dr, rr)), dr;
    }
    var tr = lt(yt, Bt);
    if (tr)
      return tr;
    var Dt = Object.keys(Bt), Wt = ht(Dt);
    if (yt.showHidden && (Dt = Object.getOwnPropertyNames(Bt)), Ht(Bt) && (Dt.indexOf("message") >= 0 || Dt.indexOf("description") >= 0))
      return Et(Bt);
    if (Dt.length === 0) {
      if (ct(Bt)) {
        var or = Bt.name ? ": " + Bt.name : "";
        return yt.stylize("[Function" + or + "]", "special");
      }
      if (jt(Bt))
        return yt.stylize(RegExp.prototype.toString.call(Bt), "regexp");
      if (er(Bt))
        return yt.stylize(Date.prototype.toString.call(Bt), "date");
      if (Ht(Bt))
        return Et(Bt);
    }
    var _r = "", Xt = !1, Qt = ["{", "}"];
    if (Lt(Bt) && (Xt = !0, Qt = ["[", "]"]), ct(Bt)) {
      var br = Bt.name ? ": " + Bt.name : "";
      _r = " [Function" + br + "]";
    }
    if (jt(Bt) && (_r = " " + RegExp.prototype.toString.call(Bt)), er(Bt) && (_r = " " + Date.prototype.toUTCString.call(Bt)), Ht(Bt) && (_r = " " + Et(Bt)), Dt.length === 0 && (!Xt || Bt.length == 0))
      return Qt[0] + _r + Qt[1];
    if (rr < 0)
      return jt(Bt) ? yt.stylize(RegExp.prototype.toString.call(Bt), "regexp") : yt.stylize("[Object]", "special");
    yt.seen.push(Bt);
    var Dr;
    return Xt ? Dr = wt(yt, Bt, rr, Wt, Dt) : Dr = Dt.map(function(Vr) {
      return Rt(yt, Bt, rr, Wt, Vr, Xt);
    }), yt.seen.pop(), Mt(Dr, _r, Qt);
  }
  function lt(yt, Bt) {
    if (yr(Bt))
      return yt.stylize("undefined", "undefined");
    if (Jt(Bt)) {
      var rr = "'" + JSON.stringify(Bt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return yt.stylize(rr, "string");
    }
    if (Ft(Bt))
      return yt.stylize("" + Bt, "number");
    if (zt(Bt))
      return yt.stylize("" + Bt, "boolean");
    if (Ot(Bt))
      return yt.stylize("null", "null");
  }
  function Et(yt) {
    return "[" + Error.prototype.toString.call(yt) + "]";
  }
  function wt(yt, Bt, rr, dr, tr) {
    for (var Dt = [], Wt = 0, or = Bt.length; Wt < or; ++Wt)
      St(Bt, String(Wt)) ? Dt.push(Rt(
        yt,
        Bt,
        rr,
        dr,
        String(Wt),
        !0
      )) : Dt.push("");
    return tr.forEach(function(_r) {
      _r.match(/^\d+$/) || Dt.push(Rt(
        yt,
        Bt,
        rr,
        dr,
        _r,
        !0
      ));
    }), Dt;
  }
  function Rt(yt, Bt, rr, dr, tr, Dt) {
    var Wt, or, _r;
    if (_r = Object.getOwnPropertyDescriptor(Bt, tr) || { value: Bt[tr] }, _r.get ? _r.set ? or = yt.stylize("[Getter/Setter]", "special") : or = yt.stylize("[Getter]", "special") : _r.set && (or = yt.stylize("[Setter]", "special")), St(dr, tr) || (Wt = "[" + tr + "]"), or || (yt.seen.indexOf(_r.value) < 0 ? (Ot(rr) ? or = it(yt, _r.value, null) : or = it(yt, _r.value, rr - 1), or.indexOf(`
`) > -1 && (Dt ? or = or.split(`
`).map(function(Xt) {
      return "  " + Xt;
    }).join(`
`).slice(2) : or = `
` + or.split(`
`).map(function(Xt) {
      return "   " + Xt;
    }).join(`
`))) : or = yt.stylize("[Circular]", "special")), yr(Wt)) {
      if (Dt && tr.match(/^\d+$/))
        return or;
      Wt = JSON.stringify("" + tr), Wt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Wt = Wt.slice(1, -1), Wt = yt.stylize(Wt, "name")) : (Wt = Wt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Wt = yt.stylize(Wt, "string"));
    }
    return Wt + ": " + or;
  }
  function Mt(yt, Bt, rr) {
    var dr = yt.reduce(function(tr, Dt) {
      return Dt.indexOf(`
`) >= 0, tr + Dt.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return dr > 60 ? rr[0] + (Bt === "" ? "" : Bt + `
 `) + " " + yt.join(`,
  `) + " " + rr[1] : rr[0] + Bt + " " + yt.join(", ") + " " + rr[1];
  }
  B.types = types$2;
  function Lt(yt) {
    return Array.isArray(yt);
  }
  B.isArray = Lt;
  function zt(yt) {
    return typeof yt == "boolean";
  }
  B.isBoolean = zt;
  function Ot(yt) {
    return yt === null;
  }
  B.isNull = Ot;
  function It(yt) {
    return yt == null;
  }
  B.isNullOrUndefined = It;
  function Ft(yt) {
    return typeof yt == "number";
  }
  B.isNumber = Ft;
  function Jt(yt) {
    return typeof yt == "string";
  }
  B.isString = Jt;
  function Vt(yt) {
    return typeof yt == "symbol";
  }
  B.isSymbol = Vt;
  function yr(yt) {
    return yt === void 0;
  }
  B.isUndefined = yr;
  function jt(yt) {
    return Ut(yt) && ot(yt) === "[object RegExp]";
  }
  B.isRegExp = jt, B.types.isRegExp = jt;
  function Ut(yt) {
    return typeof yt == "object" && yt !== null;
  }
  B.isObject = Ut;
  function er(yt) {
    return Ut(yt) && ot(yt) === "[object Date]";
  }
  B.isDate = er, B.types.isDate = er;
  function Ht(yt) {
    return Ut(yt) && (ot(yt) === "[object Error]" || yt instanceof Error);
  }
  B.isError = Ht, B.types.isNativeError = Ht;
  function ct(yt) {
    return typeof yt == "function";
  }
  B.isFunction = ct;
  function dt(yt) {
    return yt === null || typeof yt == "boolean" || typeof yt == "number" || typeof yt == "string" || typeof yt == "symbol" || // ES6 symbol
    typeof yt > "u";
  }
  B.isPrimitive = dt, B.isBuffer = isBufferBrowser;
  function ot(yt) {
    return Object.prototype.toString.call(yt);
  }
  function ut(yt) {
    return yt < 10 ? "0" + yt.toString(10) : yt.toString(10);
  }
  var mt = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function gt() {
    var yt = /* @__PURE__ */ new Date(), Bt = [
      ut(yt.getHours()),
      ut(yt.getMinutes()),
      ut(yt.getSeconds())
    ].join(":");
    return [yt.getDate(), mt[yt.getMonth()], Bt].join(" ");
  }
  B.log = function() {
    console.log("%s - %s", gt(), B.format.apply(B, arguments));
  }, B.inherits = inherits_browserExports, B._extend = function(yt, Bt) {
    if (!Bt || !Ut(Bt)) return yt;
    for (var rr = Object.keys(Bt), dr = rr.length; dr--; )
      yt[rr[dr]] = Bt[rr[dr]];
    return yt;
  };
  function St(yt, Bt) {
    return Object.prototype.hasOwnProperty.call(yt, Bt);
  }
  var xt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  B.promisify = function(Bt) {
    if (typeof Bt != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (xt && Bt[xt]) {
      var rr = Bt[xt];
      if (typeof rr != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(rr, xt, {
        value: rr,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), rr;
    }
    function rr() {
      for (var dr, tr, Dt = new Promise(function(_r, Xt) {
        dr = _r, tr = Xt;
      }), Wt = [], or = 0; or < arguments.length; or++)
        Wt.push(arguments[or]);
      Wt.push(function(_r, Xt) {
        _r ? tr(_r) : dr(Xt);
      });
      try {
        Bt.apply(this, Wt);
      } catch (_r) {
        tr(_r);
      }
      return Dt;
    }
    return Object.setPrototypeOf(rr, Object.getPrototypeOf(Bt)), xt && Object.defineProperty(rr, xt, {
      value: rr,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      rr,
      L(Bt)
    );
  }, B.promisify.custom = xt;
  function vt(yt, Bt) {
    if (!yt) {
      var rr = new Error("Promise was rejected with a falsy value");
      rr.reason = yt, yt = rr;
    }
    return Bt(yt);
  }
  function $t(yt) {
    if (typeof yt != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Bt() {
      for (var rr = [], dr = 0; dr < arguments.length; dr++)
        rr.push(arguments[dr]);
      var tr = rr.pop();
      if (typeof tr != "function")
        throw new TypeError("The last argument must be of type Function");
      var Dt = this, Wt = function() {
        return tr.apply(Dt, arguments);
      };
      yt.apply(this, rr).then(
        function(or) {
          process$1.nextTick(Wt.bind(null, null, or));
        },
        function(or) {
          process$1.nextTick(vt.bind(null, or, Wt));
        }
      );
    }
    return Object.setPrototypeOf(Bt, Object.getPrototypeOf(yt)), Object.defineProperties(
      Bt,
      L(yt)
    ), Bt;
  }
  B.callbackify = $t;
})(util$3);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B(Rt, Mt) {
    var Lt = Object.keys(Rt);
    if (Object.getOwnPropertySymbols) {
      var zt = Object.getOwnPropertySymbols(Rt);
      Mt && (zt = zt.filter(function(Ot) {
        return Object.getOwnPropertyDescriptor(Rt, Ot).enumerable;
      })), Lt.push.apply(Lt, zt);
    }
    return Lt;
  }
  function L(Rt) {
    for (var Mt = 1; Mt < arguments.length; Mt++) {
      var Lt = arguments[Mt] != null ? arguments[Mt] : {};
      Mt % 2 ? B(Object(Lt), !0).forEach(function(zt) {
        J(Rt, zt, Lt[zt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Rt, Object.getOwnPropertyDescriptors(Lt)) : B(Object(Lt)).forEach(function(zt) {
        Object.defineProperty(Rt, zt, Object.getOwnPropertyDescriptor(Lt, zt));
      });
    }
    return Rt;
  }
  function J(Rt, Mt, Lt) {
    return Mt = Ce(Mt), Mt in Rt ? Object.defineProperty(Rt, Mt, { value: Lt, enumerable: !0, configurable: !0, writable: !0 }) : Rt[Mt] = Lt, Rt;
  }
  function ne(Rt, Mt) {
    if (!(Rt instanceof Mt))
      throw new TypeError("Cannot call a class as a function");
  }
  function oe(Rt, Mt) {
    for (var Lt = 0; Lt < Mt.length; Lt++) {
      var zt = Mt[Lt];
      zt.enumerable = zt.enumerable || !1, zt.configurable = !0, "value" in zt && (zt.writable = !0), Object.defineProperty(Rt, Ce(zt.key), zt);
    }
  }
  function ce(Rt, Mt, Lt) {
    return Mt && oe(Rt.prototype, Mt), Object.defineProperty(Rt, "prototype", { writable: !1 }), Rt;
  }
  function Ce(Rt) {
    var Mt = rt(Rt, "string");
    return typeof Mt == "symbol" ? Mt : String(Mt);
  }
  function rt(Rt, Mt) {
    if (typeof Rt != "object" || Rt === null) return Rt;
    var Lt = Rt[Symbol.toPrimitive];
    if (Lt !== void 0) {
      var zt = Lt.call(Rt, Mt || "default");
      if (typeof zt != "object") return zt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Mt === "string" ? String : Number)(Rt);
  }
  var at = require$$1$2, ht = at.Buffer, it = util$3, lt = it.inspect, Et = lt && lt.custom || "inspect";
  function wt(Rt, Mt, Lt) {
    ht.prototype.copy.call(Rt, Mt, Lt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function Rt() {
      ne(this, Rt), this.head = null, this.tail = null, this.length = 0;
    }
    return ce(Rt, [{
      key: "push",
      value: function(Lt) {
        var zt = {
          data: Lt,
          next: null
        };
        this.length > 0 ? this.tail.next = zt : this.head = zt, this.tail = zt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Lt) {
        var zt = {
          data: Lt,
          next: this.head
        };
        this.length === 0 && (this.tail = zt), this.head = zt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Lt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Lt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Lt) {
        if (this.length === 0) return "";
        for (var zt = this.head, Ot = "" + zt.data; zt = zt.next; ) Ot += Lt + zt.data;
        return Ot;
      }
    }, {
      key: "concat",
      value: function(Lt) {
        if (this.length === 0) return ht.alloc(0);
        for (var zt = ht.allocUnsafe(Lt >>> 0), Ot = this.head, It = 0; Ot; )
          wt(Ot.data, zt, It), It += Ot.data.length, Ot = Ot.next;
        return zt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Lt, zt) {
        var Ot;
        return Lt < this.head.data.length ? (Ot = this.head.data.slice(0, Lt), this.head.data = this.head.data.slice(Lt)) : Lt === this.head.data.length ? Ot = this.shift() : Ot = zt ? this._getString(Lt) : this._getBuffer(Lt), Ot;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Lt) {
        var zt = this.head, Ot = 1, It = zt.data;
        for (Lt -= It.length; zt = zt.next; ) {
          var Ft = zt.data, Jt = Lt > Ft.length ? Ft.length : Lt;
          if (Jt === Ft.length ? It += Ft : It += Ft.slice(0, Lt), Lt -= Jt, Lt === 0) {
            Jt === Ft.length ? (++Ot, zt.next ? this.head = zt.next : this.head = this.tail = null) : (this.head = zt, zt.data = Ft.slice(Jt));
            break;
          }
          ++Ot;
        }
        return this.length -= Ot, It;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Lt) {
        var zt = ht.allocUnsafe(Lt), Ot = this.head, It = 1;
        for (Ot.data.copy(zt), Lt -= Ot.data.length; Ot = Ot.next; ) {
          var Ft = Ot.data, Jt = Lt > Ft.length ? Ft.length : Lt;
          if (Ft.copy(zt, zt.length - Lt, 0, Jt), Lt -= Jt, Lt === 0) {
            Jt === Ft.length ? (++It, Ot.next ? this.head = Ot.next : this.head = this.tail = null) : (this.head = Ot, Ot.data = Ft.slice(Jt));
            break;
          }
          ++It;
        }
        return this.length -= It, zt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Et,
      value: function(Lt, zt) {
        return lt(this, L(L({}, zt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Rt;
  }(), buffer_list;
}
function destroy$1(B, L) {
  var J = this, ne = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
  return ne || oe ? (L ? L(B) : B && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT$1, this, B)) : process$1.nextTick(emitErrorNT$1, this, B)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(B || null, function(ce) {
    !L && ce ? J._writableState ? J._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, J) : (J._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, J, ce)) : process$1.nextTick(emitErrorAndCloseNT, J, ce) : L ? (process$1.nextTick(emitCloseNT, J), L(ce)) : process$1.nextTick(emitCloseNT, J);
  }), this);
}
function emitErrorAndCloseNT(B, L) {
  emitErrorNT$1(B, L), emitCloseNT(B);
}
function emitCloseNT(B) {
  B._writableState && !B._writableState.emitClose || B._readableState && !B._readableState.emitClose || B.emit("close");
}
function undestroy$1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT$1(B, L) {
  B.emit("error", L);
}
function errorOrDestroy(B, L) {
  var J = B._readableState, ne = B._writableState;
  J && J.autoDestroy || ne && ne.autoDestroy ? B.destroy(L) : B.emit("error", L);
}
var destroy_1$1 = {
  destroy: destroy$1,
  undestroy: undestroy$1,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose(B, L) {
  B.prototype = Object.create(L.prototype), B.prototype.constructor = B, B.__proto__ = L;
}
var codes = {};
function createErrorType(B, L, J) {
  J || (J = Error);
  function ne(ce, Ce, rt) {
    return typeof L == "string" ? L : L(ce, Ce, rt);
  }
  var oe = /* @__PURE__ */ function(ce) {
    _inheritsLoose(Ce, ce);
    function Ce(rt, at, ht) {
      return ce.call(this, ne(rt, at, ht)) || this;
    }
    return Ce;
  }(J);
  oe.prototype.name = J.name, oe.prototype.code = B, codes[B] = oe;
}
function oneOf(B, L) {
  if (Array.isArray(B)) {
    var J = B.length;
    return B = B.map(function(ne) {
      return String(ne);
    }), J > 2 ? "one of ".concat(L, " ").concat(B.slice(0, J - 1).join(", "), ", or ") + B[J - 1] : J === 2 ? "one of ".concat(L, " ").concat(B[0], " or ").concat(B[1]) : "of ".concat(L, " ").concat(B[0]);
  } else
    return "of ".concat(L, " ").concat(String(B));
}
function startsWith(B, L, J) {
  return B.substr(0, L.length) === L;
}
function endsWith(B, L, J) {
  return (J === void 0 || J > B.length) && (J = B.length), B.substring(J - L.length, J) === L;
}
function includes(B, L, J) {
  return typeof J != "number" && (J = 0), J + L.length > B.length ? !1 : B.indexOf(L, J) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(B, L) {
  return 'The value "' + L + '" is invalid for option "' + B + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(B, L, J) {
  var ne;
  typeof L == "string" && startsWith(L, "not ") ? (ne = "must not be", L = L.replace(/^not /, "")) : ne = "must be";
  var oe;
  if (endsWith(B, " argument"))
    oe = "The ".concat(B, " ").concat(ne, " ").concat(oneOf(L, "type"));
  else {
    var ce = includes(B, ".") ? "property" : "argument";
    oe = 'The "'.concat(B, '" ').concat(ce, " ").concat(ne, " ").concat(oneOf(L, "type"));
  }
  return oe += ". Received type ".concat(typeof J), oe;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(B) {
  return "The " + B + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(B) {
  return "Cannot call " + B + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(B) {
  return "Unknown encoding: " + B;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(B, L, J) {
  return B.highWaterMark != null ? B.highWaterMark : L ? B[J] : null;
}
function getHighWaterMark(B, L, J, ne) {
  var oe = highWaterMarkFrom(L, ne, J);
  if (oe != null) {
    if (!(isFinite(oe) && Math.floor(oe) === oe) || oe < 0) {
      var ce = ne ? J : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(ce, oe);
    }
    return Math.floor(oe);
  }
  return B.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
}, browser$a = deprecate;
function deprecate(B, L) {
  if (config("noDeprecation"))
    return B;
  var J = !1;
  function ne() {
    if (!J) {
      if (config("throwDeprecation"))
        throw new Error(L);
      config("traceDeprecation") ? console.trace(L) : console.warn(L), J = !0;
    }
    return B.apply(this, arguments);
  }
  return ne;
}
function config(B) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var L = commonjsGlobal.localStorage[B];
  return L == null ? !1 : String(L).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = jt;
  function B(tr) {
    var Dt = this;
    this.next = null, this.entry = null, this.finish = function() {
      dr(Dt, tr);
    };
  }
  var L;
  jt.WritableState = Vt;
  var J = {
    deprecate: browser$a
  }, ne = streamBrowser$1, oe = require$$1$2.Buffer, ce = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Ce(tr) {
    return oe.from(tr);
  }
  function rt(tr) {
    return oe.isBuffer(tr) || tr instanceof ce;
  }
  var at = destroy_1$1, ht = state, it = ht.getHighWaterMark, lt = errorsBrowser.codes, Et = lt.ERR_INVALID_ARG_TYPE, wt = lt.ERR_METHOD_NOT_IMPLEMENTED, Rt = lt.ERR_MULTIPLE_CALLBACK, Mt = lt.ERR_STREAM_CANNOT_PIPE, Lt = lt.ERR_STREAM_DESTROYED, zt = lt.ERR_STREAM_NULL_VALUES, Ot = lt.ERR_STREAM_WRITE_AFTER_END, It = lt.ERR_UNKNOWN_ENCODING, Ft = at.errorOrDestroy;
  inherits_browserExports(jt, ne);
  function Jt() {
  }
  function Vt(tr, Dt, Wt) {
    L = L || require_stream_duplex$1(), tr = tr || {}, typeof Wt != "boolean" && (Wt = Dt instanceof L), this.objectMode = !!tr.objectMode, Wt && (this.objectMode = this.objectMode || !!tr.writableObjectMode), this.highWaterMark = it(this, tr, "writableHighWaterMark", Wt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var or = tr.decodeStrings === !1;
    this.decodeStrings = !or, this.defaultEncoding = tr.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(_r) {
      mt(Dt, _r);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = tr.emitClose !== !1, this.autoDestroy = !!tr.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Vt.prototype.getBuffer = function() {
    for (var Dt = this.bufferedRequest, Wt = []; Dt; )
      Wt.push(Dt), Dt = Dt.next;
    return Wt;
  }, function() {
    try {
      Object.defineProperty(Vt.prototype, "buffer", {
        get: J.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var yr;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (yr = Function.prototype[Symbol.hasInstance], Object.defineProperty(jt, Symbol.hasInstance, {
    value: function(Dt) {
      return yr.call(this, Dt) ? !0 : this !== jt ? !1 : Dt && Dt._writableState instanceof Vt;
    }
  })) : yr = function(Dt) {
    return Dt instanceof this;
  };
  function jt(tr) {
    L = L || require_stream_duplex$1();
    var Dt = this instanceof L;
    if (!Dt && !yr.call(jt, this)) return new jt(tr);
    this._writableState = new Vt(tr, this, Dt), this.writable = !0, tr && (typeof tr.write == "function" && (this._write = tr.write), typeof tr.writev == "function" && (this._writev = tr.writev), typeof tr.destroy == "function" && (this._destroy = tr.destroy), typeof tr.final == "function" && (this._final = tr.final)), ne.call(this);
  }
  jt.prototype.pipe = function() {
    Ft(this, new Mt());
  };
  function Ut(tr, Dt) {
    var Wt = new Ot();
    Ft(tr, Wt), process$1.nextTick(Dt, Wt);
  }
  function er(tr, Dt, Wt, or) {
    var _r;
    return Wt === null ? _r = new zt() : typeof Wt != "string" && !Dt.objectMode && (_r = new Et("chunk", ["string", "Buffer"], Wt)), _r ? (Ft(tr, _r), process$1.nextTick(or, _r), !1) : !0;
  }
  jt.prototype.write = function(tr, Dt, Wt) {
    var or = this._writableState, _r = !1, Xt = !or.objectMode && rt(tr);
    return Xt && !oe.isBuffer(tr) && (tr = Ce(tr)), typeof Dt == "function" && (Wt = Dt, Dt = null), Xt ? Dt = "buffer" : Dt || (Dt = or.defaultEncoding), typeof Wt != "function" && (Wt = Jt), or.ending ? Ut(this, Wt) : (Xt || er(this, or, tr, Wt)) && (or.pendingcb++, _r = ct(this, or, Xt, tr, Dt, Wt)), _r;
  }, jt.prototype.cork = function() {
    this._writableState.corked++;
  }, jt.prototype.uncork = function() {
    var tr = this._writableState;
    tr.corked && (tr.corked--, !tr.writing && !tr.corked && !tr.bufferProcessing && tr.bufferedRequest && xt(this, tr));
  }, jt.prototype.setDefaultEncoding = function(Dt) {
    if (typeof Dt == "string" && (Dt = Dt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Dt + "").toLowerCase()) > -1)) throw new It(Dt);
    return this._writableState.defaultEncoding = Dt, this;
  }, Object.defineProperty(jt.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Ht(tr, Dt, Wt) {
    return !tr.objectMode && tr.decodeStrings !== !1 && typeof Dt == "string" && (Dt = oe.from(Dt, Wt)), Dt;
  }
  Object.defineProperty(jt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ct(tr, Dt, Wt, or, _r, Xt) {
    if (!Wt) {
      var Qt = Ht(Dt, or, _r);
      or !== Qt && (Wt = !0, _r = "buffer", or = Qt);
    }
    var br = Dt.objectMode ? 1 : or.length;
    Dt.length += br;
    var Dr = Dt.length < Dt.highWaterMark;
    if (Dr || (Dt.needDrain = !0), Dt.writing || Dt.corked) {
      var Vr = Dt.lastBufferedRequest;
      Dt.lastBufferedRequest = {
        chunk: or,
        encoding: _r,
        isBuf: Wt,
        callback: Xt,
        next: null
      }, Vr ? Vr.next = Dt.lastBufferedRequest : Dt.bufferedRequest = Dt.lastBufferedRequest, Dt.bufferedRequestCount += 1;
    } else
      dt(tr, Dt, !1, br, or, _r, Xt);
    return Dr;
  }
  function dt(tr, Dt, Wt, or, _r, Xt, Qt) {
    Dt.writelen = or, Dt.writecb = Qt, Dt.writing = !0, Dt.sync = !0, Dt.destroyed ? Dt.onwrite(new Lt("write")) : Wt ? tr._writev(_r, Dt.onwrite) : tr._write(_r, Xt, Dt.onwrite), Dt.sync = !1;
  }
  function ot(tr, Dt, Wt, or, _r) {
    --Dt.pendingcb, Wt ? (process$1.nextTick(_r, or), process$1.nextTick(Bt, tr, Dt), tr._writableState.errorEmitted = !0, Ft(tr, or)) : (_r(or), tr._writableState.errorEmitted = !0, Ft(tr, or), Bt(tr, Dt));
  }
  function ut(tr) {
    tr.writing = !1, tr.writecb = null, tr.length -= tr.writelen, tr.writelen = 0;
  }
  function mt(tr, Dt) {
    var Wt = tr._writableState, or = Wt.sync, _r = Wt.writecb;
    if (typeof _r != "function") throw new Rt();
    if (ut(Wt), Dt) ot(tr, Wt, or, Dt, _r);
    else {
      var Xt = vt(Wt) || tr.destroyed;
      !Xt && !Wt.corked && !Wt.bufferProcessing && Wt.bufferedRequest && xt(tr, Wt), or ? process$1.nextTick(gt, tr, Wt, Xt, _r) : gt(tr, Wt, Xt, _r);
    }
  }
  function gt(tr, Dt, Wt, or) {
    Wt || St(tr, Dt), Dt.pendingcb--, or(), Bt(tr, Dt);
  }
  function St(tr, Dt) {
    Dt.length === 0 && Dt.needDrain && (Dt.needDrain = !1, tr.emit("drain"));
  }
  function xt(tr, Dt) {
    Dt.bufferProcessing = !0;
    var Wt = Dt.bufferedRequest;
    if (tr._writev && Wt && Wt.next) {
      var or = Dt.bufferedRequestCount, _r = new Array(or), Xt = Dt.corkedRequestsFree;
      Xt.entry = Wt;
      for (var Qt = 0, br = !0; Wt; )
        _r[Qt] = Wt, Wt.isBuf || (br = !1), Wt = Wt.next, Qt += 1;
      _r.allBuffers = br, dt(tr, Dt, !0, Dt.length, _r, "", Xt.finish), Dt.pendingcb++, Dt.lastBufferedRequest = null, Xt.next ? (Dt.corkedRequestsFree = Xt.next, Xt.next = null) : Dt.corkedRequestsFree = new B(Dt), Dt.bufferedRequestCount = 0;
    } else {
      for (; Wt; ) {
        var Dr = Wt.chunk, Vr = Wt.encoding, Zr = Wt.callback, ln = Dt.objectMode ? 1 : Dr.length;
        if (dt(tr, Dt, !1, ln, Dr, Vr, Zr), Wt = Wt.next, Dt.bufferedRequestCount--, Dt.writing)
          break;
      }
      Wt === null && (Dt.lastBufferedRequest = null);
    }
    Dt.bufferedRequest = Wt, Dt.bufferProcessing = !1;
  }
  jt.prototype._write = function(tr, Dt, Wt) {
    Wt(new wt("_write()"));
  }, jt.prototype._writev = null, jt.prototype.end = function(tr, Dt, Wt) {
    var or = this._writableState;
    return typeof tr == "function" ? (Wt = tr, tr = null, Dt = null) : typeof Dt == "function" && (Wt = Dt, Dt = null), tr != null && this.write(tr, Dt), or.corked && (or.corked = 1, this.uncork()), or.ending || rr(this, or, Wt), this;
  }, Object.defineProperty(jt.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function vt(tr) {
    return tr.ending && tr.length === 0 && tr.bufferedRequest === null && !tr.finished && !tr.writing;
  }
  function $t(tr, Dt) {
    tr._final(function(Wt) {
      Dt.pendingcb--, Wt && Ft(tr, Wt), Dt.prefinished = !0, tr.emit("prefinish"), Bt(tr, Dt);
    });
  }
  function yt(tr, Dt) {
    !Dt.prefinished && !Dt.finalCalled && (typeof tr._final == "function" && !Dt.destroyed ? (Dt.pendingcb++, Dt.finalCalled = !0, process$1.nextTick($t, tr, Dt)) : (Dt.prefinished = !0, tr.emit("prefinish")));
  }
  function Bt(tr, Dt) {
    var Wt = vt(Dt);
    if (Wt && (yt(tr, Dt), Dt.pendingcb === 0 && (Dt.finished = !0, tr.emit("finish"), Dt.autoDestroy))) {
      var or = tr._readableState;
      (!or || or.autoDestroy && or.endEmitted) && tr.destroy();
    }
    return Wt;
  }
  function rr(tr, Dt, Wt) {
    Dt.ending = !0, Bt(tr, Dt), Wt && (Dt.finished ? process$1.nextTick(Wt) : tr.once("finish", Wt)), Dt.ended = !0, tr.writable = !1;
  }
  function dr(tr, Dt, Wt) {
    var or = tr.entry;
    for (tr.entry = null; or; ) {
      var _r = or.callback;
      Dt.pendingcb--, _r(Wt), or = or.next;
    }
    Dt.corkedRequestsFree.next = tr;
  }
  return Object.defineProperty(jt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Dt) {
      this._writableState && (this._writableState.destroyed = Dt);
    }
  }), jt.prototype.destroy = at.destroy, jt.prototype._undestroy = at.undestroy, jt.prototype._destroy = function(tr, Dt) {
    Dt(tr);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(ht) {
    var it = [];
    for (var lt in ht) it.push(lt);
    return it;
  };
  _stream_duplex$1 = Ce;
  var L = require_stream_readable$1(), J = require_stream_writable$1();
  inherits_browserExports(Ce, L);
  for (var ne = B(J.prototype), oe = 0; oe < ne.length; oe++) {
    var ce = ne[oe];
    Ce.prototype[ce] || (Ce.prototype[ce] = J.prototype[ce]);
  }
  function Ce(ht) {
    if (!(this instanceof Ce)) return new Ce(ht);
    L.call(this, ht), J.call(this, ht), this.allowHalfOpen = !0, ht && (ht.readable === !1 && (this.readable = !1), ht.writable === !1 && (this.writable = !1), ht.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", rt)));
  }
  Object.defineProperty(Ce.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(Ce.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(Ce.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function rt() {
    this._writableState.ended || process$1.nextTick(at, this);
  }
  function at(ht) {
    ht.end();
  }
  return Object.defineProperty(Ce.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(it) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = it, this._writableState.destroyed = it);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, Buffer$A = safeBufferExports$1.Buffer, isEncoding = Buffer$A.isEncoding || function(B) {
  switch (B = "" + B, B && B.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(B) {
  if (!B) return "utf8";
  for (var L; ; )
    switch (B) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return B;
      default:
        if (L) return;
        B = ("" + B).toLowerCase(), L = !0;
    }
}
function normalizeEncoding(B) {
  var L = _normalizeEncoding(B);
  if (typeof L != "string" && (Buffer$A.isEncoding === isEncoding || !isEncoding(B))) throw new Error("Unknown encoding: " + B);
  return L || B;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(B) {
  this.encoding = normalizeEncoding(B);
  var L;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, L = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, L = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, L = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$A.allocUnsafe(L);
}
StringDecoder$1.prototype.write = function(B) {
  if (B.length === 0) return "";
  var L, J;
  if (this.lastNeed) {
    if (L = this.fillLast(B), L === void 0) return "";
    J = this.lastNeed, this.lastNeed = 0;
  } else
    J = 0;
  return J < B.length ? L ? L + this.text(B, J) : this.text(B, J) : L || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(B) {
  if (this.lastNeed <= B.length)
    return B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, B.length), this.lastNeed -= B.length;
};
function utf8CheckByte(B) {
  return B <= 127 ? 0 : B >> 5 === 6 ? 2 : B >> 4 === 14 ? 3 : B >> 3 === 30 ? 4 : B >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(B, L, J) {
  var ne = L.length - 1;
  if (ne < J) return 0;
  var oe = utf8CheckByte(L[ne]);
  return oe >= 0 ? (oe > 0 && (B.lastNeed = oe - 1), oe) : --ne < J || oe === -2 ? 0 : (oe = utf8CheckByte(L[ne]), oe >= 0 ? (oe > 0 && (B.lastNeed = oe - 2), oe) : --ne < J || oe === -2 ? 0 : (oe = utf8CheckByte(L[ne]), oe >= 0 ? (oe > 0 && (oe === 2 ? oe = 0 : B.lastNeed = oe - 3), oe) : 0));
}
function utf8CheckExtraBytes(B, L, J) {
  if ((L[0] & 192) !== 128)
    return B.lastNeed = 0, "";
  if (B.lastNeed > 1 && L.length > 1) {
    if ((L[1] & 192) !== 128)
      return B.lastNeed = 1, "";
    if (B.lastNeed > 2 && L.length > 2 && (L[2] & 192) !== 128)
      return B.lastNeed = 2, "";
  }
}
function utf8FillLast(B) {
  var L = this.lastTotal - this.lastNeed, J = utf8CheckExtraBytes(this, B);
  if (J !== void 0) return J;
  if (this.lastNeed <= B.length)
    return B.copy(this.lastChar, L, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  B.copy(this.lastChar, L, 0, B.length), this.lastNeed -= B.length;
}
function utf8Text(B, L) {
  var J = utf8CheckIncomplete(this, B, L);
  if (!this.lastNeed) return B.toString("utf8", L);
  this.lastTotal = J;
  var ne = B.length - (J - this.lastNeed);
  return B.copy(this.lastChar, 0, ne), B.toString("utf8", L, ne);
}
function utf8End(B) {
  var L = B && B.length ? this.write(B) : "";
  return this.lastNeed ? L + "" : L;
}
function utf16Text(B, L) {
  if ((B.length - L) % 2 === 0) {
    var J = B.toString("utf16le", L);
    if (J) {
      var ne = J.charCodeAt(J.length - 1);
      if (ne >= 55296 && ne <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1], J.slice(0, -1);
    }
    return J;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = B[B.length - 1], B.toString("utf16le", L, B.length - 1);
}
function utf16End(B) {
  var L = B && B.length ? this.write(B) : "";
  if (this.lastNeed) {
    var J = this.lastTotal - this.lastNeed;
    return L + this.lastChar.toString("utf16le", 0, J);
  }
  return L;
}
function base64Text(B, L) {
  var J = (B.length - L) % 3;
  return J === 0 ? B.toString("base64", L) : (this.lastNeed = 3 - J, this.lastTotal = 3, J === 1 ? this.lastChar[0] = B[B.length - 1] : (this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1]), B.toString("base64", L, B.length - J));
}
function base64End(B) {
  var L = B && B.length ? this.write(B) : "";
  return this.lastNeed ? L + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : L;
}
function simpleWrite(B) {
  return B.toString(this.encoding);
}
function simpleEnd(B) {
  return B && B.length ? this.write(B) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(B) {
  var L = !1;
  return function() {
    if (!L) {
      L = !0;
      for (var J = arguments.length, ne = new Array(J), oe = 0; oe < J; oe++)
        ne[oe] = arguments[oe];
      B.apply(this, ne);
    }
  };
}
function noop$1() {
}
function isRequest$1(B) {
  return B.setHeader && typeof B.abort == "function";
}
function eos$1(B, L, J) {
  if (typeof L == "function") return eos$1(B, null, L);
  L || (L = {}), J = once$1(J || noop$1);
  var ne = L.readable || L.readable !== !1 && B.readable, oe = L.writable || L.writable !== !1 && B.writable, ce = function() {
    B.writable || rt();
  }, Ce = B._writableState && B._writableState.finished, rt = function() {
    oe = !1, Ce = !0, ne || J.call(B);
  }, at = B._readableState && B._readableState.endEmitted, ht = function() {
    ne = !1, at = !0, oe || J.call(B);
  }, it = function(Rt) {
    J.call(B, Rt);
  }, lt = function() {
    var Rt;
    if (ne && !at)
      return (!B._readableState || !B._readableState.ended) && (Rt = new ERR_STREAM_PREMATURE_CLOSE()), J.call(B, Rt);
    if (oe && !Ce)
      return (!B._writableState || !B._writableState.ended) && (Rt = new ERR_STREAM_PREMATURE_CLOSE()), J.call(B, Rt);
  }, Et = function() {
    B.req.on("finish", rt);
  };
  return isRequest$1(B) ? (B.on("complete", rt), B.on("abort", lt), B.req ? Et() : B.on("request", Et)) : oe && !B._writableState && (B.on("end", ce), B.on("close", ce)), B.on("end", ht), B.on("finish", rt), L.error !== !1 && B.on("error", it), B.on("close", lt), function() {
    B.removeListener("complete", rt), B.removeListener("abort", lt), B.removeListener("request", Et), B.req && B.req.removeListener("finish", rt), B.removeListener("end", ce), B.removeListener("close", ce), B.removeListener("finish", rt), B.removeListener("end", ht), B.removeListener("error", it), B.removeListener("close", lt);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function L(It, Ft, Jt) {
    return Ft = J(Ft), Ft in It ? Object.defineProperty(It, Ft, { value: Jt, enumerable: !0, configurable: !0, writable: !0 }) : It[Ft] = Jt, It;
  }
  function J(It) {
    var Ft = ne(It, "string");
    return typeof Ft == "symbol" ? Ft : String(Ft);
  }
  function ne(It, Ft) {
    if (typeof It != "object" || It === null) return It;
    var Jt = It[Symbol.toPrimitive];
    if (Jt !== void 0) {
      var Vt = Jt.call(It, Ft || "default");
      if (typeof Vt != "object") return Vt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ft === "string" ? String : Number)(It);
  }
  var oe = endOfStream, ce = Symbol("lastResolve"), Ce = Symbol("lastReject"), rt = Symbol("error"), at = Symbol("ended"), ht = Symbol("lastPromise"), it = Symbol("handlePromise"), lt = Symbol("stream");
  function Et(It, Ft) {
    return {
      value: It,
      done: Ft
    };
  }
  function wt(It) {
    var Ft = It[ce];
    if (Ft !== null) {
      var Jt = It[lt].read();
      Jt !== null && (It[ht] = null, It[ce] = null, It[Ce] = null, Ft(Et(Jt, !1)));
    }
  }
  function Rt(It) {
    process$1.nextTick(wt, It);
  }
  function Mt(It, Ft) {
    return function(Jt, Vt) {
      It.then(function() {
        if (Ft[at]) {
          Jt(Et(void 0, !0));
          return;
        }
        Ft[it](Jt, Vt);
      }, Vt);
    };
  }
  var Lt = Object.getPrototypeOf(function() {
  }), zt = Object.setPrototypeOf((B = {
    get stream() {
      return this[lt];
    },
    next: function() {
      var Ft = this, Jt = this[rt];
      if (Jt !== null)
        return Promise.reject(Jt);
      if (this[at])
        return Promise.resolve(Et(void 0, !0));
      if (this[lt].destroyed)
        return new Promise(function(Ut, er) {
          process$1.nextTick(function() {
            Ft[rt] ? er(Ft[rt]) : Ut(Et(void 0, !0));
          });
        });
      var Vt = this[ht], yr;
      if (Vt)
        yr = new Promise(Mt(Vt, this));
      else {
        var jt = this[lt].read();
        if (jt !== null)
          return Promise.resolve(Et(jt, !1));
        yr = new Promise(this[it]);
      }
      return this[ht] = yr, yr;
    }
  }, L(B, Symbol.asyncIterator, function() {
    return this;
  }), L(B, "return", function() {
    var Ft = this;
    return new Promise(function(Jt, Vt) {
      Ft[lt].destroy(null, function(yr) {
        if (yr) {
          Vt(yr);
          return;
        }
        Jt(Et(void 0, !0));
      });
    });
  }), B), Lt), Ot = function(Ft) {
    var Jt, Vt = Object.create(zt, (Jt = {}, L(Jt, lt, {
      value: Ft,
      writable: !0
    }), L(Jt, ce, {
      value: null,
      writable: !0
    }), L(Jt, Ce, {
      value: null,
      writable: !0
    }), L(Jt, rt, {
      value: null,
      writable: !0
    }), L(Jt, at, {
      value: Ft._readableState.endEmitted,
      writable: !0
    }), L(Jt, it, {
      value: function(jt, Ut) {
        var er = Vt[lt].read();
        er ? (Vt[ht] = null, Vt[ce] = null, Vt[Ce] = null, jt(Et(er, !1))) : (Vt[ce] = jt, Vt[Ce] = Ut);
      },
      writable: !0
    }), Jt));
    return Vt[ht] = null, oe(Ft, function(yr) {
      if (yr && yr.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var jt = Vt[Ce];
        jt !== null && (Vt[ht] = null, Vt[ce] = null, Vt[Ce] = null, jt(yr)), Vt[rt] = yr;
        return;
      }
      var Ut = Vt[ce];
      Ut !== null && (Vt[ht] = null, Vt[ce] = null, Vt[Ce] = null, Ut(Et(void 0, !0))), Vt[at] = !0;
    }), Ft.on("readable", Rt.bind(null, Vt)), Vt;
  };
  return async_iterator = Ot, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Ut;
  var B;
  Ut.ReadableState = jt, eventsExports.EventEmitter;
  var L = function(Qt, br) {
    return Qt.listeners(br).length;
  }, J = streamBrowser$1, ne = require$$1$2.Buffer, oe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ce(Xt) {
    return ne.from(Xt);
  }
  function Ce(Xt) {
    return ne.isBuffer(Xt) || Xt instanceof oe;
  }
  var rt = util$3, at;
  rt && rt.debuglog ? at = rt.debuglog("stream") : at = function() {
  };
  var ht = requireBuffer_list(), it = destroy_1$1, lt = state, Et = lt.getHighWaterMark, wt = errorsBrowser.codes, Rt = wt.ERR_INVALID_ARG_TYPE, Mt = wt.ERR_STREAM_PUSH_AFTER_EOF, Lt = wt.ERR_METHOD_NOT_IMPLEMENTED, zt = wt.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ot, It, Ft;
  inherits_browserExports(Ut, J);
  var Jt = it.errorOrDestroy, Vt = ["error", "close", "destroy", "pause", "resume"];
  function yr(Xt, Qt, br) {
    if (typeof Xt.prependListener == "function") return Xt.prependListener(Qt, br);
    !Xt._events || !Xt._events[Qt] ? Xt.on(Qt, br) : Array.isArray(Xt._events[Qt]) ? Xt._events[Qt].unshift(br) : Xt._events[Qt] = [br, Xt._events[Qt]];
  }
  function jt(Xt, Qt, br) {
    B = B || require_stream_duplex$1(), Xt = Xt || {}, typeof br != "boolean" && (br = Qt instanceof B), this.objectMode = !!Xt.objectMode, br && (this.objectMode = this.objectMode || !!Xt.readableObjectMode), this.highWaterMark = Et(this, Xt, "readableHighWaterMark", br), this.buffer = new ht(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Xt.emitClose !== !1, this.autoDestroy = !!Xt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Xt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Xt.encoding && (Ot || (Ot = string_decoder.StringDecoder), this.decoder = new Ot(Xt.encoding), this.encoding = Xt.encoding);
  }
  function Ut(Xt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof Ut)) return new Ut(Xt);
    var Qt = this instanceof B;
    this._readableState = new jt(Xt, this, Qt), this.readable = !0, Xt && (typeof Xt.read == "function" && (this._read = Xt.read), typeof Xt.destroy == "function" && (this._destroy = Xt.destroy)), J.call(this);
  }
  Object.defineProperty(Ut.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Qt) {
      this._readableState && (this._readableState.destroyed = Qt);
    }
  }), Ut.prototype.destroy = it.destroy, Ut.prototype._undestroy = it.undestroy, Ut.prototype._destroy = function(Xt, Qt) {
    Qt(Xt);
  }, Ut.prototype.push = function(Xt, Qt) {
    var br = this._readableState, Dr;
    return br.objectMode ? Dr = !0 : typeof Xt == "string" && (Qt = Qt || br.defaultEncoding, Qt !== br.encoding && (Xt = ne.from(Xt, Qt), Qt = ""), Dr = !0), er(this, Xt, Qt, !1, Dr);
  }, Ut.prototype.unshift = function(Xt) {
    return er(this, Xt, null, !0, !1);
  };
  function er(Xt, Qt, br, Dr, Vr) {
    at("readableAddChunk", Qt);
    var Zr = Xt._readableState;
    if (Qt === null)
      Zr.reading = !1, mt(Xt, Zr);
    else {
      var ln;
      if (Vr || (ln = ct(Zr, Qt)), ln)
        Jt(Xt, ln);
      else if (Zr.objectMode || Qt && Qt.length > 0)
        if (typeof Qt != "string" && !Zr.objectMode && Object.getPrototypeOf(Qt) !== ne.prototype && (Qt = ce(Qt)), Dr)
          Zr.endEmitted ? Jt(Xt, new zt()) : Ht(Xt, Zr, Qt, !0);
        else if (Zr.ended)
          Jt(Xt, new Mt());
        else {
          if (Zr.destroyed)
            return !1;
          Zr.reading = !1, Zr.decoder && !br ? (Qt = Zr.decoder.write(Qt), Zr.objectMode || Qt.length !== 0 ? Ht(Xt, Zr, Qt, !1) : xt(Xt, Zr)) : Ht(Xt, Zr, Qt, !1);
        }
      else Dr || (Zr.reading = !1, xt(Xt, Zr));
    }
    return !Zr.ended && (Zr.length < Zr.highWaterMark || Zr.length === 0);
  }
  function Ht(Xt, Qt, br, Dr) {
    Qt.flowing && Qt.length === 0 && !Qt.sync ? (Qt.awaitDrain = 0, Xt.emit("data", br)) : (Qt.length += Qt.objectMode ? 1 : br.length, Dr ? Qt.buffer.unshift(br) : Qt.buffer.push(br), Qt.needReadable && gt(Xt)), xt(Xt, Qt);
  }
  function ct(Xt, Qt) {
    var br;
    return !Ce(Qt) && typeof Qt != "string" && Qt !== void 0 && !Xt.objectMode && (br = new Rt("chunk", ["string", "Buffer", "Uint8Array"], Qt)), br;
  }
  Ut.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ut.prototype.setEncoding = function(Xt) {
    Ot || (Ot = string_decoder.StringDecoder);
    var Qt = new Ot(Xt);
    this._readableState.decoder = Qt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var br = this._readableState.buffer.head, Dr = ""; br !== null; )
      Dr += Qt.write(br.data), br = br.next;
    return this._readableState.buffer.clear(), Dr !== "" && this._readableState.buffer.push(Dr), this._readableState.length = Dr.length, this;
  };
  var dt = 1073741824;
  function ot(Xt) {
    return Xt >= dt ? Xt = dt : (Xt--, Xt |= Xt >>> 1, Xt |= Xt >>> 2, Xt |= Xt >>> 4, Xt |= Xt >>> 8, Xt |= Xt >>> 16, Xt++), Xt;
  }
  function ut(Xt, Qt) {
    return Xt <= 0 || Qt.length === 0 && Qt.ended ? 0 : Qt.objectMode ? 1 : Xt !== Xt ? Qt.flowing && Qt.length ? Qt.buffer.head.data.length : Qt.length : (Xt > Qt.highWaterMark && (Qt.highWaterMark = ot(Xt)), Xt <= Qt.length ? Xt : Qt.ended ? Qt.length : (Qt.needReadable = !0, 0));
  }
  Ut.prototype.read = function(Xt) {
    at("read", Xt), Xt = parseInt(Xt, 10);
    var Qt = this._readableState, br = Xt;
    if (Xt !== 0 && (Qt.emittedReadable = !1), Xt === 0 && Qt.needReadable && ((Qt.highWaterMark !== 0 ? Qt.length >= Qt.highWaterMark : Qt.length > 0) || Qt.ended))
      return at("read: emitReadable", Qt.length, Qt.ended), Qt.length === 0 && Qt.ended ? Wt(this) : gt(this), null;
    if (Xt = ut(Xt, Qt), Xt === 0 && Qt.ended)
      return Qt.length === 0 && Wt(this), null;
    var Dr = Qt.needReadable;
    at("need readable", Dr), (Qt.length === 0 || Qt.length - Xt < Qt.highWaterMark) && (Dr = !0, at("length less than watermark", Dr)), Qt.ended || Qt.reading ? (Dr = !1, at("reading or ended", Dr)) : Dr && (at("do read"), Qt.reading = !0, Qt.sync = !0, Qt.length === 0 && (Qt.needReadable = !0), this._read(Qt.highWaterMark), Qt.sync = !1, Qt.reading || (Xt = ut(br, Qt)));
    var Vr;
    return Xt > 0 ? Vr = Dt(Xt, Qt) : Vr = null, Vr === null ? (Qt.needReadable = Qt.length <= Qt.highWaterMark, Xt = 0) : (Qt.length -= Xt, Qt.awaitDrain = 0), Qt.length === 0 && (Qt.ended || (Qt.needReadable = !0), br !== Xt && Qt.ended && Wt(this)), Vr !== null && this.emit("data", Vr), Vr;
  };
  function mt(Xt, Qt) {
    if (at("onEofChunk"), !Qt.ended) {
      if (Qt.decoder) {
        var br = Qt.decoder.end();
        br && br.length && (Qt.buffer.push(br), Qt.length += Qt.objectMode ? 1 : br.length);
      }
      Qt.ended = !0, Qt.sync ? gt(Xt) : (Qt.needReadable = !1, Qt.emittedReadable || (Qt.emittedReadable = !0, St(Xt)));
    }
  }
  function gt(Xt) {
    var Qt = Xt._readableState;
    at("emitReadable", Qt.needReadable, Qt.emittedReadable), Qt.needReadable = !1, Qt.emittedReadable || (at("emitReadable", Qt.flowing), Qt.emittedReadable = !0, process$1.nextTick(St, Xt));
  }
  function St(Xt) {
    var Qt = Xt._readableState;
    at("emitReadable_", Qt.destroyed, Qt.length, Qt.ended), !Qt.destroyed && (Qt.length || Qt.ended) && (Xt.emit("readable"), Qt.emittedReadable = !1), Qt.needReadable = !Qt.flowing && !Qt.ended && Qt.length <= Qt.highWaterMark, tr(Xt);
  }
  function xt(Xt, Qt) {
    Qt.readingMore || (Qt.readingMore = !0, process$1.nextTick(vt, Xt, Qt));
  }
  function vt(Xt, Qt) {
    for (; !Qt.reading && !Qt.ended && (Qt.length < Qt.highWaterMark || Qt.flowing && Qt.length === 0); ) {
      var br = Qt.length;
      if (at("maybeReadMore read 0"), Xt.read(0), br === Qt.length)
        break;
    }
    Qt.readingMore = !1;
  }
  Ut.prototype._read = function(Xt) {
    Jt(this, new Lt("_read()"));
  }, Ut.prototype.pipe = function(Xt, Qt) {
    var br = this, Dr = this._readableState;
    switch (Dr.pipesCount) {
      case 0:
        Dr.pipes = Xt;
        break;
      case 1:
        Dr.pipes = [Dr.pipes, Xt];
        break;
      default:
        Dr.pipes.push(Xt);
        break;
    }
    Dr.pipesCount += 1, at("pipe count=%d opts=%j", Dr.pipesCount, Qt);
    var Vr = (!Qt || Qt.end !== !1) && Xt !== process$1.stdout && Xt !== process$1.stderr, Zr = Vr ? _n : ti;
    Dr.endEmitted ? process$1.nextTick(Zr) : br.once("end", Zr), Xt.on("unpipe", ln);
    function ln(gn, Kn) {
      at("onunpipe"), gn === br && Kn && Kn.hasUnpiped === !1 && (Kn.hasUnpiped = !0, xn());
    }
    function _n() {
      at("onend"), Xt.end();
    }
    var Mr = $t(br);
    Xt.on("drain", Mr);
    var Wn = !1;
    function xn() {
      at("cleanup"), Xt.removeListener("close", En), Xt.removeListener("finish", Pn), Xt.removeListener("drain", Mr), Xt.removeListener("error", Gn), Xt.removeListener("unpipe", ln), br.removeListener("end", _n), br.removeListener("end", ti), br.removeListener("data", ni), Wn = !0, Dr.awaitDrain && (!Xt._writableState || Xt._writableState.needDrain) && Mr();
    }
    br.on("data", ni);
    function ni(gn) {
      at("ondata");
      var Kn = Xt.write(gn);
      at("dest.write", Kn), Kn === !1 && ((Dr.pipesCount === 1 && Dr.pipes === Xt || Dr.pipesCount > 1 && _r(Dr.pipes, Xt) !== -1) && !Wn && (at("false write response, pause", Dr.awaitDrain), Dr.awaitDrain++), br.pause());
    }
    function Gn(gn) {
      at("onerror", gn), ti(), Xt.removeListener("error", Gn), L(Xt, "error") === 0 && Jt(Xt, gn);
    }
    yr(Xt, "error", Gn);
    function En() {
      Xt.removeListener("finish", Pn), ti();
    }
    Xt.once("close", En);
    function Pn() {
      at("onfinish"), Xt.removeListener("close", En), ti();
    }
    Xt.once("finish", Pn);
    function ti() {
      at("unpipe"), br.unpipe(Xt);
    }
    return Xt.emit("pipe", br), Dr.flowing || (at("pipe resume"), br.resume()), Xt;
  };
  function $t(Xt) {
    return function() {
      var br = Xt._readableState;
      at("pipeOnDrain", br.awaitDrain), br.awaitDrain && br.awaitDrain--, br.awaitDrain === 0 && L(Xt, "data") && (br.flowing = !0, tr(Xt));
    };
  }
  Ut.prototype.unpipe = function(Xt) {
    var Qt = this._readableState, br = {
      hasUnpiped: !1
    };
    if (Qt.pipesCount === 0) return this;
    if (Qt.pipesCount === 1)
      return Xt && Xt !== Qt.pipes ? this : (Xt || (Xt = Qt.pipes), Qt.pipes = null, Qt.pipesCount = 0, Qt.flowing = !1, Xt && Xt.emit("unpipe", this, br), this);
    if (!Xt) {
      var Dr = Qt.pipes, Vr = Qt.pipesCount;
      Qt.pipes = null, Qt.pipesCount = 0, Qt.flowing = !1;
      for (var Zr = 0; Zr < Vr; Zr++) Dr[Zr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ln = _r(Qt.pipes, Xt);
    return ln === -1 ? this : (Qt.pipes.splice(ln, 1), Qt.pipesCount -= 1, Qt.pipesCount === 1 && (Qt.pipes = Qt.pipes[0]), Xt.emit("unpipe", this, br), this);
  }, Ut.prototype.on = function(Xt, Qt) {
    var br = J.prototype.on.call(this, Xt, Qt), Dr = this._readableState;
    return Xt === "data" ? (Dr.readableListening = this.listenerCount("readable") > 0, Dr.flowing !== !1 && this.resume()) : Xt === "readable" && !Dr.endEmitted && !Dr.readableListening && (Dr.readableListening = Dr.needReadable = !0, Dr.flowing = !1, Dr.emittedReadable = !1, at("on readable", Dr.length, Dr.reading), Dr.length ? gt(this) : Dr.reading || process$1.nextTick(Bt, this)), br;
  }, Ut.prototype.addListener = Ut.prototype.on, Ut.prototype.removeListener = function(Xt, Qt) {
    var br = J.prototype.removeListener.call(this, Xt, Qt);
    return Xt === "readable" && process$1.nextTick(yt, this), br;
  }, Ut.prototype.removeAllListeners = function(Xt) {
    var Qt = J.prototype.removeAllListeners.apply(this, arguments);
    return (Xt === "readable" || Xt === void 0) && process$1.nextTick(yt, this), Qt;
  };
  function yt(Xt) {
    var Qt = Xt._readableState;
    Qt.readableListening = Xt.listenerCount("readable") > 0, Qt.resumeScheduled && !Qt.paused ? Qt.flowing = !0 : Xt.listenerCount("data") > 0 && Xt.resume();
  }
  function Bt(Xt) {
    at("readable nexttick read 0"), Xt.read(0);
  }
  Ut.prototype.resume = function() {
    var Xt = this._readableState;
    return Xt.flowing || (at("resume"), Xt.flowing = !Xt.readableListening, rr(this, Xt)), Xt.paused = !1, this;
  };
  function rr(Xt, Qt) {
    Qt.resumeScheduled || (Qt.resumeScheduled = !0, process$1.nextTick(dr, Xt, Qt));
  }
  function dr(Xt, Qt) {
    at("resume", Qt.reading), Qt.reading || Xt.read(0), Qt.resumeScheduled = !1, Xt.emit("resume"), tr(Xt), Qt.flowing && !Qt.reading && Xt.read(0);
  }
  Ut.prototype.pause = function() {
    return at("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (at("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function tr(Xt) {
    var Qt = Xt._readableState;
    for (at("flow", Qt.flowing); Qt.flowing && Xt.read() !== null; ) ;
  }
  Ut.prototype.wrap = function(Xt) {
    var Qt = this, br = this._readableState, Dr = !1;
    Xt.on("end", function() {
      if (at("wrapped end"), br.decoder && !br.ended) {
        var ln = br.decoder.end();
        ln && ln.length && Qt.push(ln);
      }
      Qt.push(null);
    }), Xt.on("data", function(ln) {
      if (at("wrapped data"), br.decoder && (ln = br.decoder.write(ln)), !(br.objectMode && ln == null) && !(!br.objectMode && (!ln || !ln.length))) {
        var _n = Qt.push(ln);
        _n || (Dr = !0, Xt.pause());
      }
    });
    for (var Vr in Xt)
      this[Vr] === void 0 && typeof Xt[Vr] == "function" && (this[Vr] = /* @__PURE__ */ function(_n) {
        return function() {
          return Xt[_n].apply(Xt, arguments);
        };
      }(Vr));
    for (var Zr = 0; Zr < Vt.length; Zr++)
      Xt.on(Vt[Zr], this.emit.bind(this, Vt[Zr]));
    return this._read = function(ln) {
      at("wrapped _read", ln), Dr && (Dr = !1, Xt.resume());
    }, this;
  }, typeof Symbol == "function" && (Ut.prototype[Symbol.asyncIterator] = function() {
    return It === void 0 && (It = requireAsync_iterator()), It(this);
  }), Object.defineProperty(Ut.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Ut.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Ut.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Qt) {
      this._readableState && (this._readableState.flowing = Qt);
    }
  }), Ut._fromList = Dt, Object.defineProperty(Ut.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Dt(Xt, Qt) {
    if (Qt.length === 0) return null;
    var br;
    return Qt.objectMode ? br = Qt.buffer.shift() : !Xt || Xt >= Qt.length ? (Qt.decoder ? br = Qt.buffer.join("") : Qt.buffer.length === 1 ? br = Qt.buffer.first() : br = Qt.buffer.concat(Qt.length), Qt.buffer.clear()) : br = Qt.buffer.consume(Xt, Qt.decoder), br;
  }
  function Wt(Xt) {
    var Qt = Xt._readableState;
    at("endReadable", Qt.endEmitted), Qt.endEmitted || (Qt.ended = !0, process$1.nextTick(or, Qt, Xt));
  }
  function or(Xt, Qt) {
    if (at("endReadableNT", Xt.endEmitted, Xt.length), !Xt.endEmitted && Xt.length === 0 && (Xt.endEmitted = !0, Qt.readable = !1, Qt.emit("end"), Xt.autoDestroy)) {
      var br = Qt._writableState;
      (!br || br.autoDestroy && br.finished) && Qt.destroy();
    }
  }
  typeof Symbol == "function" && (Ut.from = function(Xt, Qt) {
    return Ft === void 0 && (Ft = requireFromBrowser()), Ft(Ut, Xt, Qt);
  });
  function _r(Xt, Qt) {
    for (var br = 0, Dr = Xt.length; br < Dr; br++)
      if (Xt[br] === Qt) return br;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1 = Transform$9, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex$1 = require_stream_duplex$1();
inherits_browserExports(Transform$9, Duplex$1);
function afterTransform$1(B, L) {
  var J = this._transformState;
  J.transforming = !1;
  var ne = J.writecb;
  if (ne === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  J.writechunk = null, J.writecb = null, L != null && this.push(L), ne(B);
  var oe = this._readableState;
  oe.reading = !1, (oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
}
function Transform$9(B) {
  if (!(this instanceof Transform$9)) return new Transform$9(B);
  Duplex$1.call(this, B), this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var B = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(L, J) {
    done$1(B, L, J);
  }) : done$1(this, null, null);
}
Transform$9.prototype.push = function(B, L) {
  return this._transformState.needTransform = !1, Duplex$1.prototype.push.call(this, B, L);
};
Transform$9.prototype._transform = function(B, L, J) {
  J(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$9.prototype._write = function(B, L, J) {
  var ne = this._transformState;
  if (ne.writecb = J, ne.writechunk = B, ne.writeencoding = L, !ne.transforming) {
    var oe = this._readableState;
    (ne.needTransform || oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
  }
};
Transform$9.prototype._read = function(B) {
  var L = this._transformState;
  L.writechunk !== null && !L.transforming ? (L.transforming = !0, this._transform(L.writechunk, L.writeencoding, L.afterTransform)) : L.needTransform = !0;
};
Transform$9.prototype._destroy = function(B, L) {
  Duplex$1.prototype._destroy.call(this, B, function(J) {
    L(J);
  });
};
function done$1(B, L, J) {
  if (L) return B.emit("error", L);
  if (J != null && B.push(J), B._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (B._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return B.push(null);
}
var _stream_passthrough$1 = PassThrough$1, Transform$8 = _stream_transform$1;
inherits_browserExports(PassThrough$1, Transform$8);
function PassThrough$1(B) {
  if (!(this instanceof PassThrough$1)) return new PassThrough$1(B);
  Transform$8.call(this, B);
}
PassThrough$1.prototype._transform = function(B, L, J) {
  J(null, B);
};
var eos;
function once(B) {
  var L = !1;
  return function() {
    L || (L = !0, B.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(B) {
  if (B) throw B;
}
function isRequest(B) {
  return B.setHeader && typeof B.abort == "function";
}
function destroyer(B, L, J, ne) {
  ne = once(ne);
  var oe = !1;
  B.on("close", function() {
    oe = !0;
  }), eos === void 0 && (eos = endOfStream), eos(B, {
    readable: L,
    writable: J
  }, function(Ce) {
    if (Ce) return ne(Ce);
    oe = !0, ne();
  });
  var ce = !1;
  return function(Ce) {
    if (!oe && !ce) {
      if (ce = !0, isRequest(B)) return B.abort();
      if (typeof B.destroy == "function") return B.destroy();
      ne(Ce || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(B) {
  B();
}
function pipe(B, L) {
  return B.pipe(L);
}
function popCallback(B) {
  return !B.length || typeof B[B.length - 1] != "function" ? noop : B.pop();
}
function pipeline() {
  for (var B = arguments.length, L = new Array(B), J = 0; J < B; J++)
    L[J] = arguments[J];
  var ne = popCallback(L);
  if (Array.isArray(L[0]) && (L = L[0]), L.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var oe, ce = L.map(function(Ce, rt) {
    var at = rt < L.length - 1, ht = rt > 0;
    return destroyer(Ce, at, ht, function(it) {
      oe || (oe = it), it && ce.forEach(call), !at && (ce.forEach(call), ne(oe));
    });
  });
  return L.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(B, L) {
  L = B.exports = require_stream_readable$1(), L.Stream = L, L.Readable = L, L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = _stream_transform$1, L.PassThrough = _stream_passthrough$1, L.finished = endOfStream, L.pipeline = pipeline_1;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$z = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$q = inherits_browserExports;
function throwIfNotStringOrBuffer(B, L) {
  if (!Buffer$z.isBuffer(B) && typeof B != "string")
    throw new TypeError(L + " must be a string or a buffer");
}
function HashBase$2(B) {
  Transform$7.call(this), this._block = Buffer$z.allocUnsafe(B), this._blockSize = B, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$q(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(B, L, J) {
  var ne = null;
  try {
    this.update(B, L);
  } catch (oe) {
    ne = oe;
  }
  J(ne);
};
HashBase$2.prototype._flush = function(B) {
  var L = null;
  try {
    this.push(this.digest());
  } catch (J) {
    L = J;
  }
  B(L);
};
HashBase$2.prototype.update = function(B, L) {
  if (throwIfNotStringOrBuffer(B, "Data"), this._finalized) throw new Error("Digest already called");
  Buffer$z.isBuffer(B) || (B = Buffer$z.from(B, L));
  for (var J = this._block, ne = 0; this._blockOffset + B.length - ne >= this._blockSize; ) {
    for (var oe = this._blockOffset; oe < this._blockSize; ) J[oe++] = B[ne++];
    this._update(), this._blockOffset = 0;
  }
  for (; ne < B.length; ) J[this._blockOffset++] = B[ne++];
  for (var ce = 0, Ce = B.length * 8; Ce > 0; ++ce)
    this._length[ce] += Ce, Ce = this._length[ce] / 4294967296 | 0, Ce > 0 && (this._length[ce] -= 4294967296 * Ce);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(B) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var L = this._digest();
  B !== void 0 && (L = L.toString(B)), this._block.fill(0), this._blockOffset = 0;
  for (var J = 0; J < 4; ++J) this._length[J] = 0;
  return L;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$p = inherits_browserExports, HashBase$1 = hashBase, Buffer$y = safeBufferExports$1.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$p(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var B = ARRAY16$1, L = 0; L < 16; ++L) B[L] = this._block.readInt32LE(L * 4);
  var J = this._a, ne = this._b, oe = this._c, ce = this._d;
  J = fnF(J, ne, oe, ce, B[0], 3614090360, 7), ce = fnF(ce, J, ne, oe, B[1], 3905402710, 12), oe = fnF(oe, ce, J, ne, B[2], 606105819, 17), ne = fnF(ne, oe, ce, J, B[3], 3250441966, 22), J = fnF(J, ne, oe, ce, B[4], 4118548399, 7), ce = fnF(ce, J, ne, oe, B[5], 1200080426, 12), oe = fnF(oe, ce, J, ne, B[6], 2821735955, 17), ne = fnF(ne, oe, ce, J, B[7], 4249261313, 22), J = fnF(J, ne, oe, ce, B[8], 1770035416, 7), ce = fnF(ce, J, ne, oe, B[9], 2336552879, 12), oe = fnF(oe, ce, J, ne, B[10], 4294925233, 17), ne = fnF(ne, oe, ce, J, B[11], 2304563134, 22), J = fnF(J, ne, oe, ce, B[12], 1804603682, 7), ce = fnF(ce, J, ne, oe, B[13], 4254626195, 12), oe = fnF(oe, ce, J, ne, B[14], 2792965006, 17), ne = fnF(ne, oe, ce, J, B[15], 1236535329, 22), J = fnG(J, ne, oe, ce, B[1], 4129170786, 5), ce = fnG(ce, J, ne, oe, B[6], 3225465664, 9), oe = fnG(oe, ce, J, ne, B[11], 643717713, 14), ne = fnG(ne, oe, ce, J, B[0], 3921069994, 20), J = fnG(J, ne, oe, ce, B[5], 3593408605, 5), ce = fnG(ce, J, ne, oe, B[10], 38016083, 9), oe = fnG(oe, ce, J, ne, B[15], 3634488961, 14), ne = fnG(ne, oe, ce, J, B[4], 3889429448, 20), J = fnG(J, ne, oe, ce, B[9], 568446438, 5), ce = fnG(ce, J, ne, oe, B[14], 3275163606, 9), oe = fnG(oe, ce, J, ne, B[3], 4107603335, 14), ne = fnG(ne, oe, ce, J, B[8], 1163531501, 20), J = fnG(J, ne, oe, ce, B[13], 2850285829, 5), ce = fnG(ce, J, ne, oe, B[2], 4243563512, 9), oe = fnG(oe, ce, J, ne, B[7], 1735328473, 14), ne = fnG(ne, oe, ce, J, B[12], 2368359562, 20), J = fnH(J, ne, oe, ce, B[5], 4294588738, 4), ce = fnH(ce, J, ne, oe, B[8], 2272392833, 11), oe = fnH(oe, ce, J, ne, B[11], 1839030562, 16), ne = fnH(ne, oe, ce, J, B[14], 4259657740, 23), J = fnH(J, ne, oe, ce, B[1], 2763975236, 4), ce = fnH(ce, J, ne, oe, B[4], 1272893353, 11), oe = fnH(oe, ce, J, ne, B[7], 4139469664, 16), ne = fnH(ne, oe, ce, J, B[10], 3200236656, 23), J = fnH(J, ne, oe, ce, B[13], 681279174, 4), ce = fnH(ce, J, ne, oe, B[0], 3936430074, 11), oe = fnH(oe, ce, J, ne, B[3], 3572445317, 16), ne = fnH(ne, oe, ce, J, B[6], 76029189, 23), J = fnH(J, ne, oe, ce, B[9], 3654602809, 4), ce = fnH(ce, J, ne, oe, B[12], 3873151461, 11), oe = fnH(oe, ce, J, ne, B[15], 530742520, 16), ne = fnH(ne, oe, ce, J, B[2], 3299628645, 23), J = fnI(J, ne, oe, ce, B[0], 4096336452, 6), ce = fnI(ce, J, ne, oe, B[7], 1126891415, 10), oe = fnI(oe, ce, J, ne, B[14], 2878612391, 15), ne = fnI(ne, oe, ce, J, B[5], 4237533241, 21), J = fnI(J, ne, oe, ce, B[12], 1700485571, 6), ce = fnI(ce, J, ne, oe, B[3], 2399980690, 10), oe = fnI(oe, ce, J, ne, B[10], 4293915773, 15), ne = fnI(ne, oe, ce, J, B[1], 2240044497, 21), J = fnI(J, ne, oe, ce, B[8], 1873313359, 6), ce = fnI(ce, J, ne, oe, B[15], 4264355552, 10), oe = fnI(oe, ce, J, ne, B[6], 2734768916, 15), ne = fnI(ne, oe, ce, J, B[13], 1309151649, 21), J = fnI(J, ne, oe, ce, B[4], 4149444226, 6), ce = fnI(ce, J, ne, oe, B[11], 3174756917, 10), oe = fnI(oe, ce, J, ne, B[2], 718787259, 15), ne = fnI(ne, oe, ce, J, B[9], 3951481745, 21), this._a = this._a + J | 0, this._b = this._b + ne | 0, this._c = this._c + oe | 0, this._d = this._d + ce | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var B = Buffer$y.allocUnsafe(16);
  return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B;
};
function rotl$1(B, L) {
  return B << L | B >>> 32 - L;
}
function fnF(B, L, J, ne, oe, ce, Ce) {
  return rotl$1(B + (L & J | ~L & ne) + oe + ce | 0, Ce) + L | 0;
}
function fnG(B, L, J, ne, oe, ce, Ce) {
  return rotl$1(B + (L & ne | J & ~ne) + oe + ce | 0, Ce) + L | 0;
}
function fnH(B, L, J, ne, oe, ce, Ce) {
  return rotl$1(B + (L ^ J ^ ne) + oe + ce | 0, Ce) + L | 0;
}
function fnI(B, L, J, ne, oe, ce, Ce) {
  return rotl$1(B + (J ^ (L | ~ne)) + oe + ce | 0, Ce) + L | 0;
}
var md5_js = MD5$3, Buffer$x = require$$1$2.Buffer, inherits$o = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$o(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var B = ARRAY16, L = 0; L < 16; ++L) B[L] = this._block.readInt32LE(L * 4);
  for (var J = this._a | 0, ne = this._b | 0, oe = this._c | 0, ce = this._d | 0, Ce = this._e | 0, rt = this._a | 0, at = this._b | 0, ht = this._c | 0, it = this._d | 0, lt = this._e | 0, Et = 0; Et < 80; Et += 1) {
    var wt, Rt;
    Et < 16 ? (wt = fn1(J, ne, oe, ce, Ce, B[zl[Et]], hl[0], sl[Et]), Rt = fn5(rt, at, ht, it, lt, B[zr[Et]], hr[0], sr[Et])) : Et < 32 ? (wt = fn2(J, ne, oe, ce, Ce, B[zl[Et]], hl[1], sl[Et]), Rt = fn4(rt, at, ht, it, lt, B[zr[Et]], hr[1], sr[Et])) : Et < 48 ? (wt = fn3(J, ne, oe, ce, Ce, B[zl[Et]], hl[2], sl[Et]), Rt = fn3(rt, at, ht, it, lt, B[zr[Et]], hr[2], sr[Et])) : Et < 64 ? (wt = fn4(J, ne, oe, ce, Ce, B[zl[Et]], hl[3], sl[Et]), Rt = fn2(rt, at, ht, it, lt, B[zr[Et]], hr[3], sr[Et])) : (wt = fn5(J, ne, oe, ce, Ce, B[zl[Et]], hl[4], sl[Et]), Rt = fn1(rt, at, ht, it, lt, B[zr[Et]], hr[4], sr[Et])), J = Ce, Ce = ce, ce = rotl(oe, 10), oe = ne, ne = wt, rt = lt, lt = it, it = rotl(ht, 10), ht = at, at = Rt;
  }
  var Mt = this._b + oe + it | 0;
  this._b = this._c + ce + lt | 0, this._c = this._d + Ce + rt | 0, this._d = this._e + J + at | 0, this._e = this._a + ne + ht | 0, this._a = Mt;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var B = Buffer$x.alloc ? Buffer$x.alloc(20) : new Buffer$x(20);
  return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B.writeInt32LE(this._e, 16), B;
};
function rotl(B, L) {
  return B << L | B >>> 32 - L;
}
function fn1(B, L, J, ne, oe, ce, Ce, rt) {
  return rotl(B + (L ^ J ^ ne) + ce + Ce | 0, rt) + oe | 0;
}
function fn2(B, L, J, ne, oe, ce, Ce, rt) {
  return rotl(B + (L & J | ~L & ne) + ce + Ce | 0, rt) + oe | 0;
}
function fn3(B, L, J, ne, oe, ce, Ce, rt) {
  return rotl(B + ((L | ~J) ^ ne) + ce + Ce | 0, rt) + oe | 0;
}
function fn4(B, L, J, ne, oe, ce, Ce, rt) {
  return rotl(B + (L & ne | J & ~ne) + ce + Ce | 0, rt) + oe | 0;
}
function fn5(B, L, J, ne, oe, ce, Ce, rt) {
  return rotl(B + (L ^ (J | ~ne)) + ce + Ce | 0, rt) + oe | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$w = safeBufferExports$1.Buffer;
function Hash$7(B, L) {
  this._block = Buffer$w.alloc(B), this._finalSize = L, this._blockSize = B, this._len = 0;
}
Hash$7.prototype.update = function(B, L) {
  typeof B == "string" && (L = L || "utf8", B = Buffer$w.from(B, L));
  for (var J = this._block, ne = this._blockSize, oe = B.length, ce = this._len, Ce = 0; Ce < oe; ) {
    for (var rt = ce % ne, at = Math.min(oe - Ce, ne - rt), ht = 0; ht < at; ht++)
      J[rt + ht] = B[Ce + ht];
    ce += at, Ce += at, ce % ne === 0 && this._update(J);
  }
  return this._len += oe, this;
};
Hash$7.prototype.digest = function(B) {
  var L = this._len % this._blockSize;
  this._block[L] = 128, this._block.fill(0, L + 1), L >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var J = this._len * 8;
  if (J <= 4294967295)
    this._block.writeUInt32BE(J, this._blockSize - 4);
  else {
    var ne = (J & 4294967295) >>> 0, oe = (J - ne) / 4294967296;
    this._block.writeUInt32BE(oe, this._blockSize - 8), this._block.writeUInt32BE(ne, this._blockSize - 4);
  }
  this._update(this._block);
  var ce = this._hash();
  return B ? ce.toString(B) : ce;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$n = inherits_browserExports, Hash$6 = hash$3, Buffer$v = safeBufferExports$1.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$n(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(B) {
  return B << 5 | B >>> 27;
}
function rotl30$1(B) {
  return B << 30 | B >>> 2;
}
function ft$1(B, L, J, ne) {
  return B === 0 ? L & J | ~L & ne : B === 2 ? L & J | L & ne | J & ne : L ^ J ^ ne;
}
Sha.prototype._update = function(B) {
  for (var L = this._w, J = this._a | 0, ne = this._b | 0, oe = this._c | 0, ce = this._d | 0, Ce = this._e | 0, rt = 0; rt < 16; ++rt) L[rt] = B.readInt32BE(rt * 4);
  for (; rt < 80; ++rt) L[rt] = L[rt - 3] ^ L[rt - 8] ^ L[rt - 14] ^ L[rt - 16];
  for (var at = 0; at < 80; ++at) {
    var ht = ~~(at / 20), it = rotl5$1(J) + ft$1(ht, ne, oe, ce) + Ce + L[at] + K$4[ht] | 0;
    Ce = ce, ce = oe, oe = rotl30$1(ne), ne = J, J = it;
  }
  this._a = J + this._a | 0, this._b = ne + this._b | 0, this._c = oe + this._c | 0, this._d = ce + this._d | 0, this._e = Ce + this._e | 0;
};
Sha.prototype._hash = function() {
  var B = Buffer$v.allocUnsafe(20);
  return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
};
var sha$4 = Sha, inherits$m = inherits_browserExports, Hash$5 = hash$3, Buffer$u = safeBufferExports$1.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$m(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(B) {
  return B << 1 | B >>> 31;
}
function rotl5(B) {
  return B << 5 | B >>> 27;
}
function rotl30(B) {
  return B << 30 | B >>> 2;
}
function ft(B, L, J, ne) {
  return B === 0 ? L & J | ~L & ne : B === 2 ? L & J | L & ne | J & ne : L ^ J ^ ne;
}
Sha1.prototype._update = function(B) {
  for (var L = this._w, J = this._a | 0, ne = this._b | 0, oe = this._c | 0, ce = this._d | 0, Ce = this._e | 0, rt = 0; rt < 16; ++rt) L[rt] = B.readInt32BE(rt * 4);
  for (; rt < 80; ++rt) L[rt] = rotl1(L[rt - 3] ^ L[rt - 8] ^ L[rt - 14] ^ L[rt - 16]);
  for (var at = 0; at < 80; ++at) {
    var ht = ~~(at / 20), it = rotl5(J) + ft(ht, ne, oe, ce) + Ce + L[at] + K$3[ht] | 0;
    Ce = ce, ce = oe, oe = rotl30(ne), ne = J, J = it;
  }
  this._a = J + this._a | 0, this._b = ne + this._b | 0, this._c = oe + this._c | 0, this._d = ce + this._d | 0, this._e = Ce + this._e | 0;
};
Sha1.prototype._hash = function() {
  var B = Buffer$u.allocUnsafe(20);
  return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
};
var sha1 = Sha1, inherits$l = inherits_browserExports, Hash$4 = hash$3, Buffer$t = safeBufferExports$1.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$l(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(B, L, J) {
  return J ^ B & (L ^ J);
}
function maj$1(B, L, J) {
  return B & L | J & (B | L);
}
function sigma0$1(B) {
  return (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10);
}
function sigma1$1(B) {
  return (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7);
}
function gamma0(B) {
  return (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3;
}
function gamma1(B) {
  return (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
}
Sha256$1.prototype._update = function(B) {
  for (var L = this._w, J = this._a | 0, ne = this._b | 0, oe = this._c | 0, ce = this._d | 0, Ce = this._e | 0, rt = this._f | 0, at = this._g | 0, ht = this._h | 0, it = 0; it < 16; ++it) L[it] = B.readInt32BE(it * 4);
  for (; it < 64; ++it) L[it] = gamma1(L[it - 2]) + L[it - 7] + gamma0(L[it - 15]) + L[it - 16] | 0;
  for (var lt = 0; lt < 64; ++lt) {
    var Et = ht + sigma1$1(Ce) + ch(Ce, rt, at) + K$2[lt] + L[lt] | 0, wt = sigma0$1(J) + maj$1(J, ne, oe) | 0;
    ht = at, at = rt, rt = Ce, Ce = ce + Et | 0, ce = oe, oe = ne, ne = J, J = Et + wt | 0;
  }
  this._a = J + this._a | 0, this._b = ne + this._b | 0, this._c = oe + this._c | 0, this._d = ce + this._d | 0, this._e = Ce + this._e | 0, this._f = rt + this._f | 0, this._g = at + this._g | 0, this._h = ht + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var B = Buffer$t.allocUnsafe(32);
  return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B.writeInt32BE(this._h, 28), B;
};
var sha256$3 = Sha256$1, inherits$k = inherits_browserExports, Sha256 = sha256$3, Hash$3 = hash$3, Buffer$s = safeBufferExports$1.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$k(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var B = Buffer$s.allocUnsafe(28);
  return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B;
};
var sha224$1 = Sha224, inherits$j = inherits_browserExports, Hash$2 = hash$3, Buffer$r = safeBufferExports$1.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$j(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(B, L, J) {
  return J ^ B & (L ^ J);
}
function maj(B, L, J) {
  return B & L | J & (B | L);
}
function sigma0(B, L) {
  return (B >>> 28 | L << 4) ^ (L >>> 2 | B << 30) ^ (L >>> 7 | B << 25);
}
function sigma1(B, L) {
  return (B >>> 14 | L << 18) ^ (B >>> 18 | L << 14) ^ (L >>> 9 | B << 23);
}
function Gamma0(B, L) {
  return (B >>> 1 | L << 31) ^ (B >>> 8 | L << 24) ^ B >>> 7;
}
function Gamma0l(B, L) {
  return (B >>> 1 | L << 31) ^ (B >>> 8 | L << 24) ^ (B >>> 7 | L << 25);
}
function Gamma1(B, L) {
  return (B >>> 19 | L << 13) ^ (L >>> 29 | B << 3) ^ B >>> 6;
}
function Gamma1l(B, L) {
  return (B >>> 19 | L << 13) ^ (L >>> 29 | B << 3) ^ (B >>> 6 | L << 26);
}
function getCarry(B, L) {
  return B >>> 0 < L >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(B) {
  for (var L = this._w, J = this._ah | 0, ne = this._bh | 0, oe = this._ch | 0, ce = this._dh | 0, Ce = this._eh | 0, rt = this._fh | 0, at = this._gh | 0, ht = this._hh | 0, it = this._al | 0, lt = this._bl | 0, Et = this._cl | 0, wt = this._dl | 0, Rt = this._el | 0, Mt = this._fl | 0, Lt = this._gl | 0, zt = this._hl | 0, Ot = 0; Ot < 32; Ot += 2)
    L[Ot] = B.readInt32BE(Ot * 4), L[Ot + 1] = B.readInt32BE(Ot * 4 + 4);
  for (; Ot < 160; Ot += 2) {
    var It = L[Ot - 30], Ft = L[Ot - 15 * 2 + 1], Jt = Gamma0(It, Ft), Vt = Gamma0l(Ft, It);
    It = L[Ot - 2 * 2], Ft = L[Ot - 2 * 2 + 1];
    var yr = Gamma1(It, Ft), jt = Gamma1l(Ft, It), Ut = L[Ot - 7 * 2], er = L[Ot - 7 * 2 + 1], Ht = L[Ot - 16 * 2], ct = L[Ot - 16 * 2 + 1], dt = Vt + er | 0, ot = Jt + Ut + getCarry(dt, Vt) | 0;
    dt = dt + jt | 0, ot = ot + yr + getCarry(dt, jt) | 0, dt = dt + ct | 0, ot = ot + Ht + getCarry(dt, ct) | 0, L[Ot] = ot, L[Ot + 1] = dt;
  }
  for (var ut = 0; ut < 160; ut += 2) {
    ot = L[ut], dt = L[ut + 1];
    var mt = maj(J, ne, oe), gt = maj(it, lt, Et), St = sigma0(J, it), xt = sigma0(it, J), vt = sigma1(Ce, Rt), $t = sigma1(Rt, Ce), yt = K$1[ut], Bt = K$1[ut + 1], rr = Ch(Ce, rt, at), dr = Ch(Rt, Mt, Lt), tr = zt + $t | 0, Dt = ht + vt + getCarry(tr, zt) | 0;
    tr = tr + dr | 0, Dt = Dt + rr + getCarry(tr, dr) | 0, tr = tr + Bt | 0, Dt = Dt + yt + getCarry(tr, Bt) | 0, tr = tr + dt | 0, Dt = Dt + ot + getCarry(tr, dt) | 0;
    var Wt = xt + gt | 0, or = St + mt + getCarry(Wt, xt) | 0;
    ht = at, zt = Lt, at = rt, Lt = Mt, rt = Ce, Mt = Rt, Rt = wt + tr | 0, Ce = ce + Dt + getCarry(Rt, wt) | 0, ce = oe, wt = Et, oe = ne, Et = lt, ne = J, lt = it, it = tr + Wt | 0, J = Dt + or + getCarry(it, tr) | 0;
  }
  this._al = this._al + it | 0, this._bl = this._bl + lt | 0, this._cl = this._cl + Et | 0, this._dl = this._dl + wt | 0, this._el = this._el + Rt | 0, this._fl = this._fl + Mt | 0, this._gl = this._gl + Lt | 0, this._hl = this._hl + zt | 0, this._ah = this._ah + J + getCarry(this._al, it) | 0, this._bh = this._bh + ne + getCarry(this._bl, lt) | 0, this._ch = this._ch + oe + getCarry(this._cl, Et) | 0, this._dh = this._dh + ce + getCarry(this._dl, wt) | 0, this._eh = this._eh + Ce + getCarry(this._el, Rt) | 0, this._fh = this._fh + rt + getCarry(this._fl, Mt) | 0, this._gh = this._gh + at + getCarry(this._gl, Lt) | 0, this._hh = this._hh + ht + getCarry(this._hl, zt) | 0;
};
Sha512.prototype._hash = function() {
  var B = Buffer$r.allocUnsafe(64);
  function L(J, ne, oe) {
    B.writeInt32BE(J, oe), B.writeInt32BE(ne, oe + 4);
  }
  return L(this._ah, this._al, 0), L(this._bh, this._bl, 8), L(this._ch, this._cl, 16), L(this._dh, this._dl, 24), L(this._eh, this._el, 32), L(this._fh, this._fl, 40), L(this._gh, this._gl, 48), L(this._hh, this._hl, 56), B;
};
var sha512$2 = Sha512, inherits$i = inherits_browserExports, SHA512$3 = sha512$2, Hash$1 = hash$3, Buffer$q = safeBufferExports$1.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$i(Sha384, SHA512$3);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var B = Buffer$q.allocUnsafe(48);
  function L(J, ne, oe) {
    B.writeInt32BE(J, oe), B.writeInt32BE(ne, oe + 4);
  }
  return L(this._ah, this._al, 0), L(this._bh, this._bl, 8), L(this._ch, this._cl, 16), L(this._dh, this._dl, 24), L(this._eh, this._el, 32), L(this._fh, this._fl, 40), B;
};
var sha384$1 = Sha384, exports = sha_js.exports = function(L) {
  L = L.toLowerCase();
  var J = exports[L];
  if (!J) throw new Error(L + " is not supported (we accept pull requests)");
  return new J();
};
exports.sha = sha$4;
exports.sha1 = sha1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$3;
exports.sha384 = sha384$1;
exports.sha512 = sha512$2;
var sha_jsExports = sha_js.exports, streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$h = inherits_browserExports;
inherits$h(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = _stream_transform$1;
Stream.PassThrough = _stream_passthrough$1;
Stream.finished = endOfStream;
Stream.pipeline = pipeline_1;
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(B, L) {
  var J = this;
  function ne(it) {
    B.writable && B.write(it) === !1 && J.pause && J.pause();
  }
  J.on("data", ne);
  function oe() {
    J.readable && J.resume && J.resume();
  }
  B.on("drain", oe), !B._isStdio && (!L || L.end !== !1) && (J.on("end", Ce), J.on("close", rt));
  var ce = !1;
  function Ce() {
    ce || (ce = !0, B.end());
  }
  function rt() {
    ce || (ce = !0, typeof B.destroy == "function" && B.destroy());
  }
  function at(it) {
    if (ht(), EE.listenerCount(this, "error") === 0)
      throw it;
  }
  J.on("error", at), B.on("error", at);
  function ht() {
    J.removeListener("data", ne), B.removeListener("drain", oe), J.removeListener("end", Ce), J.removeListener("close", rt), J.removeListener("error", at), B.removeListener("error", at), J.removeListener("end", ht), J.removeListener("close", ht), B.removeListener("close", ht);
  }
  return J.on("end", ht), J.on("close", ht), B.on("close", ht), B.emit("pipe", J), B;
};
var Buffer$p = safeBufferExports$1.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports;
function CipherBase$1(B) {
  Transform$6.call(this), this.hashMode = typeof B == "string", this.hashMode ? this[B] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(B, L, J) {
  typeof B == "string" && (B = Buffer$p.from(B, L));
  var ne = this._update(B);
  return this.hashMode ? this : (J && (ne = this._toString(ne, J)), ne);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(B, L, J) {
  var ne;
  try {
    this.hashMode ? this._update(B) : this.push(this._update(B));
  } catch (oe) {
    ne = oe;
  } finally {
    J(ne);
  }
};
CipherBase$1.prototype._flush = function(B) {
  var L;
  try {
    this.push(this.__final());
  } catch (J) {
    L = J;
  }
  B(L);
};
CipherBase$1.prototype._finalOrDigest = function(B) {
  var L = this.__final() || Buffer$p.alloc(0);
  return B && (L = this._toString(L, B, !0)), L;
};
CipherBase$1.prototype._toString = function(B, L, J) {
  if (this._decoder || (this._decoder = new StringDecoder(L), this._encoding = L), this._encoding !== L) throw new Error("can't switch encodings");
  var ne = this._decoder.write(B);
  return J && (ne += this._decoder.end()), ne;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(B) {
  Base$5.call(this, "digest"), this._hash = B;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(B) {
  this._hash.update(B);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(L) {
  return L = L.toLowerCase(), L === "md5" ? new MD5$2() : L === "rmd160" || L === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(L));
}, inherits$e = inherits_browserExports, Buffer$o = safeBufferExports$1.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$o.alloc(128), blocksize = 64;
function Hmac$3(B, L) {
  Base$4.call(this, "digest"), typeof L == "string" && (L = Buffer$o.from(L)), this._alg = B, this._key = L, L.length > blocksize ? L = B(L) : L.length < blocksize && (L = Buffer$o.concat([L, ZEROS$2], blocksize));
  for (var J = this._ipad = Buffer$o.allocUnsafe(blocksize), ne = this._opad = Buffer$o.allocUnsafe(blocksize), oe = 0; oe < blocksize; oe++)
    J[oe] = L[oe] ^ 54, ne[oe] = L[oe] ^ 92;
  this._hash = [J];
}
inherits$e(Hmac$3, Base$4);
Hmac$3.prototype._update = function(B) {
  this._hash.push(B);
};
Hmac$3.prototype._final = function() {
  var B = this._alg(Buffer$o.concat(this._hash));
  return this._alg(Buffer$o.concat([this._opad, B]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(B) {
  return new MD5$1().update(B).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$n = safeBufferExports$1.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$n.alloc(128);
function Hmac$2(B, L) {
  Base$3.call(this, "digest"), typeof L == "string" && (L = Buffer$n.from(L));
  var J = B === "sha512" || B === "sha384" ? 128 : 64;
  if (this._alg = B, this._key = L, L.length > J) {
    var ne = B === "rmd160" ? new RIPEMD160$2() : sha$2(B);
    L = ne.update(L).digest();
  } else L.length < J && (L = Buffer$n.concat([L, ZEROS$1], J));
  for (var oe = this._ipad = Buffer$n.allocUnsafe(J), ce = this._opad = Buffer$n.allocUnsafe(J), Ce = 0; Ce < J; Ce++)
    oe[Ce] = L[Ce] ^ 54, ce[Ce] = L[Ce] ^ 92;
  this._hash = B === "rmd160" ? new RIPEMD160$2() : sha$2(B), this._hash.update(oe);
}
inherits$d(Hmac$2, Base$3);
Hmac$2.prototype._update = function(B) {
  this._hash.update(B);
};
Hmac$2.prototype._final = function() {
  var B = this._hash.digest(), L = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return L.update(this._opad).update(B).digest();
};
var browser$8 = function(L, J) {
  return L = L.toLowerCase(), L === "rmd160" || L === "ripemd160" ? new Hmac$2("rmd160", J) : L === "md5" ? new Legacy(md5$1, J) : new Hmac$2(L, J);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$1 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512: sha512$1,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(B, L) {
  if (typeof B != "number")
    throw new TypeError("Iterations not a number");
  if (B < 0)
    throw new TypeError("Bad iterations");
  if (typeof L != "number")
    throw new TypeError("Key length not a number");
  if (L < 0 || L > MAX_ALLOC || L !== L)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$m = safeBufferExports$1.Buffer, toBuffer$2 = function(B, L, J) {
  if (Buffer$m.isBuffer(B))
    return B;
  if (typeof B == "string")
    return Buffer$m.from(B, L);
  if (ArrayBuffer.isView(B))
    return Buffer$m.from(B.buffer);
  throw new TypeError(J + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$l = safeBufferExports$1.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$l.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(B, L, J) {
  var ne = getDigest(B), oe = B === "sha512" || B === "sha384" ? 128 : 64;
  L.length > oe ? L = ne(L) : L.length < oe && (L = Buffer$l.concat([L, ZEROS], oe));
  for (var ce = Buffer$l.allocUnsafe(oe + sizes[B]), Ce = Buffer$l.allocUnsafe(oe + sizes[B]), rt = 0; rt < oe; rt++)
    ce[rt] = L[rt] ^ 54, Ce[rt] = L[rt] ^ 92;
  var at = Buffer$l.allocUnsafe(oe + J + 4);
  ce.copy(at, 0, 0, oe), this.ipad1 = at, this.ipad2 = ce, this.opad = Ce, this.alg = B, this.blocksize = oe, this.hash = ne, this.size = sizes[B];
}
Hmac$1.prototype.run = function(B, L) {
  B.copy(L, this.blocksize);
  var J = this.hash(L);
  return J.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(B) {
  function L(ne) {
    return sha$1(B).update(ne).digest();
  }
  function J(ne) {
    return new RIPEMD160$1().update(ne).digest();
  }
  return B === "rmd160" || B === "ripemd160" ? J : B === "md5" ? md5 : L;
}
function pbkdf2(B, L, J, ne, oe) {
  checkParameters$1(J, ne), B = toBuffer$1(B, defaultEncoding$1, "Password"), L = toBuffer$1(L, defaultEncoding$1, "Salt"), oe = oe || "sha1";
  var ce = new Hmac$1(oe, B, L.length), Ce = Buffer$l.allocUnsafe(ne), rt = Buffer$l.allocUnsafe(L.length + 4);
  L.copy(rt, 0, 0, L.length);
  for (var at = 0, ht = sizes[oe], it = Math.ceil(ne / ht), lt = 1; lt <= it; lt++) {
    rt.writeUInt32BE(lt, L.length);
    for (var Et = ce.run(rt, ce.ipad1), wt = Et, Rt = 1; Rt < J; Rt++) {
      wt = ce.run(wt, ce.ipad2);
      for (var Mt = 0; Mt < ht; Mt++) Et[Mt] ^= wt[Mt];
    }
    Et.copy(Ce, at), at += ht;
  }
  return Ce;
}
var syncBrowser = pbkdf2, Buffer$k = safeBufferExports$1.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(B) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[B] !== void 0)
    return checks[B];
  ZERO_BUF = ZERO_BUF || Buffer$k.alloc(8);
  var L = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, B).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[B] = L, L;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(B, L, J, ne, oe) {
  return subtle.importKey(
    "raw",
    B,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(ce) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: L,
      iterations: J,
      hash: {
        name: oe
      }
    }, ce, ne << 3);
  }).then(function(ce) {
    return Buffer$k.from(ce);
  });
}
function resolvePromise(B, L) {
  B.then(function(J) {
    getNextTick()(function() {
      L(null, J);
    });
  }, function(J) {
    getNextTick()(function() {
      L(J);
    });
  });
}
var async = function(B, L, J, ne, oe, ce) {
  typeof oe == "function" && (ce = oe, oe = void 0), oe = oe || "sha1";
  var Ce = toBrowser[oe.toLowerCase()];
  if (!Ce || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var rt;
      try {
        rt = sync(B, L, J, ne, oe);
      } catch (at) {
        return ce(at);
      }
      ce(null, rt);
    });
    return;
  }
  if (checkParameters(J, ne), B = toBuffer(B, defaultEncoding, "Password"), L = toBuffer(L, defaultEncoding, "Salt"), typeof ce != "function") throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(Ce).then(function(rt) {
    return rt ? browserPbkdf2(B, L, J, ne, Ce) : sync(B, L, J, ne, oe);
  }), ce);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$n = {};
utils$n.readUInt32BE = function(L, J) {
  var ne = L[0 + J] << 24 | L[1 + J] << 16 | L[2 + J] << 8 | L[3 + J];
  return ne >>> 0;
};
utils$n.writeUInt32BE = function(L, J, ne) {
  L[0 + ne] = J >>> 24, L[1 + ne] = J >>> 16 & 255, L[2 + ne] = J >>> 8 & 255, L[3 + ne] = J & 255;
};
utils$n.ip = function(L, J, ne, oe) {
  for (var ce = 0, Ce = 0, rt = 6; rt >= 0; rt -= 2) {
    for (var at = 0; at <= 24; at += 8)
      ce <<= 1, ce |= J >>> at + rt & 1;
    for (var at = 0; at <= 24; at += 8)
      ce <<= 1, ce |= L >>> at + rt & 1;
  }
  for (var rt = 6; rt >= 0; rt -= 2) {
    for (var at = 1; at <= 25; at += 8)
      Ce <<= 1, Ce |= J >>> at + rt & 1;
    for (var at = 1; at <= 25; at += 8)
      Ce <<= 1, Ce |= L >>> at + rt & 1;
  }
  ne[oe + 0] = ce >>> 0, ne[oe + 1] = Ce >>> 0;
};
utils$n.rip = function(L, J, ne, oe) {
  for (var ce = 0, Ce = 0, rt = 0; rt < 4; rt++)
    for (var at = 24; at >= 0; at -= 8)
      ce <<= 1, ce |= J >>> at + rt & 1, ce <<= 1, ce |= L >>> at + rt & 1;
  for (var rt = 4; rt < 8; rt++)
    for (var at = 24; at >= 0; at -= 8)
      Ce <<= 1, Ce |= J >>> at + rt & 1, Ce <<= 1, Ce |= L >>> at + rt & 1;
  ne[oe + 0] = ce >>> 0, ne[oe + 1] = Ce >>> 0;
};
utils$n.pc1 = function(L, J, ne, oe) {
  for (var ce = 0, Ce = 0, rt = 7; rt >= 5; rt--) {
    for (var at = 0; at <= 24; at += 8)
      ce <<= 1, ce |= J >> at + rt & 1;
    for (var at = 0; at <= 24; at += 8)
      ce <<= 1, ce |= L >> at + rt & 1;
  }
  for (var at = 0; at <= 24; at += 8)
    ce <<= 1, ce |= J >> at + rt & 1;
  for (var rt = 1; rt <= 3; rt++) {
    for (var at = 0; at <= 24; at += 8)
      Ce <<= 1, Ce |= J >> at + rt & 1;
    for (var at = 0; at <= 24; at += 8)
      Ce <<= 1, Ce |= L >> at + rt & 1;
  }
  for (var at = 0; at <= 24; at += 8)
    Ce <<= 1, Ce |= L >> at + rt & 1;
  ne[oe + 0] = ce >>> 0, ne[oe + 1] = Ce >>> 0;
};
utils$n.r28shl = function(L, J) {
  return L << J & 268435455 | L >>> 28 - J;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$n.pc2 = function(L, J, ne, oe) {
  for (var ce = 0, Ce = 0, rt = pc2table.length >>> 1, at = 0; at < rt; at++)
    ce <<= 1, ce |= L >>> pc2table[at] & 1;
  for (var at = rt; at < pc2table.length; at++)
    Ce <<= 1, Ce |= J >>> pc2table[at] & 1;
  ne[oe + 0] = ce >>> 0, ne[oe + 1] = Ce >>> 0;
};
utils$n.expand = function(L, J, ne) {
  var oe = 0, ce = 0;
  oe = (L & 1) << 5 | L >>> 27;
  for (var Ce = 23; Ce >= 15; Ce -= 4)
    oe <<= 6, oe |= L >>> Ce & 63;
  for (var Ce = 11; Ce >= 3; Ce -= 4)
    ce |= L >>> Ce & 63, ce <<= 6;
  ce |= (L & 31) << 1 | L >>> 31, J[ne + 0] = oe >>> 0, J[ne + 1] = ce >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$n.substitute = function(L, J) {
  for (var ne = 0, oe = 0; oe < 4; oe++) {
    var ce = L >>> 18 - oe * 6 & 63, Ce = sTable[oe * 64 + ce];
    ne <<= 4, ne |= Ce;
  }
  for (var oe = 0; oe < 4; oe++) {
    var ce = J >>> 18 - oe * 6 & 63, Ce = sTable[4 * 64 + oe * 64 + ce];
    ne <<= 4, ne |= Ce;
  }
  return ne >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$n.permute = function(L) {
  for (var J = 0, ne = 0; ne < permuteTable.length; ne++)
    J <<= 1, J |= L >>> permuteTable[ne] & 1;
  return J >>> 0;
};
utils$n.padSplit = function(L, J, ne) {
  for (var oe = L.toString(2); oe.length < J; )
    oe = "0" + oe;
  for (var ce = [], Ce = 0; Ce < J; Ce += ne)
    ce.push(oe.slice(Ce, Ce + ne));
  return ce.join(" ");
};
var minimalisticAssert = assert$k;
function assert$k(B, L) {
  if (!B)
    throw new Error(L || "Assertion failed");
}
assert$k.equal = function(L, J, ne) {
  if (L != J)
    throw new Error(ne || "Assertion failed: " + L + " != " + J);
};
var assert$j = minimalisticAssert;
function Cipher$3(B) {
  this.options = B, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = B.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(L) {
  return L.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(L) : this._updateEncrypt(L);
};
Cipher$3.prototype._buffer = function(L, J) {
  for (var ne = Math.min(this.buffer.length - this.bufferOff, L.length - J), oe = 0; oe < ne; oe++)
    this.buffer[this.bufferOff + oe] = L[J + oe];
  return this.bufferOff += ne, ne;
};
Cipher$3.prototype._flushBuffer = function(L, J) {
  return this._update(this.buffer, 0, L, J), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(L) {
  var J = 0, ne = 0, oe = (this.bufferOff + L.length) / this.blockSize | 0, ce = new Array(oe * this.blockSize);
  this.bufferOff !== 0 && (J += this._buffer(L, J), this.bufferOff === this.buffer.length && (ne += this._flushBuffer(ce, ne)));
  for (var Ce = L.length - (L.length - J) % this.blockSize; J < Ce; J += this.blockSize)
    this._update(L, J, ce, ne), ne += this.blockSize;
  for (; J < L.length; J++, this.bufferOff++)
    this.buffer[this.bufferOff] = L[J];
  return ce;
};
Cipher$3.prototype._updateDecrypt = function(L) {
  for (var J = 0, ne = 0, oe = Math.ceil((this.bufferOff + L.length) / this.blockSize) - 1, ce = new Array(oe * this.blockSize); oe > 0; oe--)
    J += this._buffer(L, J), ne += this._flushBuffer(ce, ne);
  return J += this._buffer(L, J), ce;
};
Cipher$3.prototype.final = function(L) {
  var J;
  L && (J = this.update(L));
  var ne;
  return this.type === "encrypt" ? ne = this._finalEncrypt() : ne = this._finalDecrypt(), J ? J.concat(ne) : ne;
};
Cipher$3.prototype._pad = function(L, J) {
  if (J === 0)
    return !1;
  for (; J < L.length; )
    L[J++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var L = new Array(this.blockSize);
  return this._update(this.buffer, 0, L, 0), L;
};
Cipher$3.prototype._unpad = function(L) {
  return L;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$j.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var L = new Array(this.blockSize);
  return this._flushBuffer(L, 0), this._unpad(L);
};
var assert$i = minimalisticAssert, inherits$c = inherits_browserExports, utils$m = utils$n, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(B) {
  Cipher$2.call(this, B);
  var L = new DESState();
  this._desState = L, this.deriveKeys(L, B.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(L) {
  return new DES$3(L);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(L, J) {
  L.keys = new Array(16 * 2), assert$i.equal(J.length, this.blockSize, "Invalid key length");
  var ne = utils$m.readUInt32BE(J, 0), oe = utils$m.readUInt32BE(J, 4);
  utils$m.pc1(ne, oe, L.tmp, 0), ne = L.tmp[0], oe = L.tmp[1];
  for (var ce = 0; ce < L.keys.length; ce += 2) {
    var Ce = shiftTable[ce >>> 1];
    ne = utils$m.r28shl(ne, Ce), oe = utils$m.r28shl(oe, Ce), utils$m.pc2(ne, oe, L.keys, ce);
  }
};
DES$3.prototype._update = function(L, J, ne, oe) {
  var ce = this._desState, Ce = utils$m.readUInt32BE(L, J), rt = utils$m.readUInt32BE(L, J + 4);
  utils$m.ip(Ce, rt, ce.tmp, 0), Ce = ce.tmp[0], rt = ce.tmp[1], this.type === "encrypt" ? this._encrypt(ce, Ce, rt, ce.tmp, 0) : this._decrypt(ce, Ce, rt, ce.tmp, 0), Ce = ce.tmp[0], rt = ce.tmp[1], utils$m.writeUInt32BE(ne, Ce, oe), utils$m.writeUInt32BE(ne, rt, oe + 4);
};
DES$3.prototype._pad = function(L, J) {
  if (this.padding === !1)
    return !1;
  for (var ne = L.length - J, oe = J; oe < L.length; oe++)
    L[oe] = ne;
  return !0;
};
DES$3.prototype._unpad = function(L) {
  if (this.padding === !1)
    return L;
  for (var J = L[L.length - 1], ne = L.length - J; ne < L.length; ne++)
    assert$i.equal(L[ne], J);
  return L.slice(0, L.length - J);
};
DES$3.prototype._encrypt = function(L, J, ne, oe, ce) {
  for (var Ce = J, rt = ne, at = 0; at < L.keys.length; at += 2) {
    var ht = L.keys[at], it = L.keys[at + 1];
    utils$m.expand(rt, L.tmp, 0), ht ^= L.tmp[0], it ^= L.tmp[1];
    var lt = utils$m.substitute(ht, it), Et = utils$m.permute(lt), wt = rt;
    rt = (Ce ^ Et) >>> 0, Ce = wt;
  }
  utils$m.rip(rt, Ce, oe, ce);
};
DES$3.prototype._decrypt = function(L, J, ne, oe, ce) {
  for (var Ce = ne, rt = J, at = L.keys.length - 2; at >= 0; at -= 2) {
    var ht = L.keys[at], it = L.keys[at + 1];
    utils$m.expand(Ce, L.tmp, 0), ht ^= L.tmp[0], it ^= L.tmp[1];
    var lt = utils$m.substitute(ht, it), Et = utils$m.permute(lt), wt = Ce;
    Ce = (rt ^ Et) >>> 0, rt = wt;
  }
  utils$m.rip(Ce, rt, oe, ce);
};
var cbc$1 = {}, assert$h = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(B) {
  assert$h.equal(B.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var L = 0; L < this.iv.length; L++)
    this.iv[L] = B[L];
}
function instantiate(B) {
  function L(ce) {
    B.call(this, ce), this._cbcInit();
  }
  inherits$b(L, B);
  for (var J = Object.keys(proto), ne = 0; ne < J.length; ne++) {
    var oe = J[ne];
    L.prototype[oe] = proto[oe];
  }
  return L.create = function(Ce) {
    return new L(Ce);
  }, L;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var L = new CBCState(this.options.iv);
  this._cbcState = L;
};
proto._update = function(L, J, ne, oe) {
  var ce = this._cbcState, Ce = this.constructor.super_.prototype, rt = ce.iv;
  if (this.type === "encrypt") {
    for (var at = 0; at < this.blockSize; at++)
      rt[at] ^= L[J + at];
    Ce._update.call(this, rt, 0, ne, oe);
    for (var at = 0; at < this.blockSize; at++)
      rt[at] = ne[oe + at];
  } else {
    Ce._update.call(this, L, J, ne, oe);
    for (var at = 0; at < this.blockSize; at++)
      ne[oe + at] ^= rt[at];
    for (var at = 0; at < this.blockSize; at++)
      rt[at] = L[J + at];
  }
};
var assert$g = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(B, L) {
  assert$g.equal(L.length, 24, "Invalid key length");
  var J = L.slice(0, 8), ne = L.slice(8, 16), oe = L.slice(16, 24);
  B === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: J }),
    DES$2.create({ type: "decrypt", key: ne }),
    DES$2.create({ type: "encrypt", key: oe })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: oe }),
    DES$2.create({ type: "encrypt", key: ne }),
    DES$2.create({ type: "decrypt", key: J })
  ];
}
function EDE(B) {
  Cipher$1.call(this, B);
  var L = new EDEState(this.type, this.options.key);
  this._edeState = L;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(L) {
  return new EDE(L);
};
EDE.prototype._update = function(L, J, ne, oe) {
  var ce = this._edeState;
  ce.ciphers[0]._update(L, J, ne, oe), ce.ciphers[1]._update(ne, oe, ne, oe), ce.ciphers[2]._update(ne, oe, ne, oe);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$n;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$j = safeBufferExports$1.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(B) {
  CipherBase.call(this);
  var L = B.mode.toLowerCase(), J = modes$3[L], ne;
  B.decrypt ? ne = "decrypt" : ne = "encrypt";
  var oe = B.key;
  Buffer$j.isBuffer(oe) || (oe = Buffer$j.from(oe)), (L === "des-ede" || L === "des-ede-cbc") && (oe = Buffer$j.concat([oe, oe.slice(0, 8)]));
  var ce = B.iv;
  Buffer$j.isBuffer(ce) || (ce = Buffer$j.from(ce)), this._des = J.create({
    key: oe,
    iv: ce,
    type: ne
  });
}
DES$1.prototype._update = function(B) {
  return Buffer$j.from(this._des.update(B));
};
DES$1.prototype._final = function() {
  return Buffer$j.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(B, L) {
  return B._cipher.encryptBlock(L);
};
ecb.decrypt = function(B, L) {
  return B._cipher.decryptBlock(L);
};
var cbc = {}, bufferXor = function(L, J) {
  for (var ne = Math.min(L.length, J.length), oe = new Buffer$D(ne), ce = 0; ce < ne; ++ce)
    oe[ce] = L[ce] ^ J[ce];
  return oe;
}, xor$7 = bufferXor;
cbc.encrypt = function(B, L) {
  var J = xor$7(L, B._prev);
  return B._prev = B._cipher.encryptBlock(J), B._prev;
};
cbc.decrypt = function(B, L) {
  var J = B._prev;
  B._prev = L;
  var ne = B._cipher.decryptBlock(L);
  return xor$7(ne, J);
};
var cfb = {}, Buffer$i = safeBufferExports$1.Buffer, xor$6 = bufferXor;
function encryptStart(B, L, J) {
  var ne = L.length, oe = xor$6(L, B._cache);
  return B._cache = B._cache.slice(ne), B._prev = Buffer$i.concat([B._prev, J ? L : oe]), oe;
}
cfb.encrypt = function(B, L, J) {
  for (var ne = Buffer$i.allocUnsafe(0), oe; L.length; )
    if (B._cache.length === 0 && (B._cache = B._cipher.encryptBlock(B._prev), B._prev = Buffer$i.allocUnsafe(0)), B._cache.length <= L.length)
      oe = B._cache.length, ne = Buffer$i.concat([ne, encryptStart(B, L.slice(0, oe), J)]), L = L.slice(oe);
    else {
      ne = Buffer$i.concat([ne, encryptStart(B, L, J)]);
      break;
    }
  return ne;
};
var cfb8 = {}, Buffer$h = safeBufferExports$1.Buffer;
function encryptByte$1(B, L, J) {
  var ne = B._cipher.encryptBlock(B._prev), oe = ne[0] ^ L;
  return B._prev = Buffer$h.concat([
    B._prev.slice(1),
    Buffer$h.from([J ? L : oe])
  ]), oe;
}
cfb8.encrypt = function(B, L, J) {
  for (var ne = L.length, oe = Buffer$h.allocUnsafe(ne), ce = -1; ++ce < ne; )
    oe[ce] = encryptByte$1(B, L[ce], J);
  return oe;
};
var cfb1 = {}, Buffer$g = safeBufferExports$1.Buffer;
function encryptByte(B, L, J) {
  for (var ne, oe = -1, ce = 8, Ce = 0, rt, at; ++oe < ce; )
    ne = B._cipher.encryptBlock(B._prev), rt = L & 1 << 7 - oe ? 128 : 0, at = ne[0] ^ rt, Ce += (at & 128) >> oe % 8, B._prev = shiftIn(B._prev, J ? rt : at);
  return Ce;
}
function shiftIn(B, L) {
  var J = B.length, ne = -1, oe = Buffer$g.allocUnsafe(B.length);
  for (B = Buffer$g.concat([B, Buffer$g.from([L])]); ++ne < J; )
    oe[ne] = B[ne] << 1 | B[ne + 1] >> 7;
  return oe;
}
cfb1.encrypt = function(B, L, J) {
  for (var ne = L.length, oe = Buffer$g.allocUnsafe(ne), ce = -1; ++ce < ne; )
    oe[ce] = encryptByte(B, L[ce], J);
  return oe;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(B) {
  return B._prev = B._cipher.encryptBlock(B._prev), B._prev;
}
ofb.encrypt = function(B, L) {
  for (; B._cache.length < L.length; )
    B._cache = Buffer$D.concat([B._cache, getBlock$1(B)]);
  var J = B._cache.slice(0, L.length);
  return B._cache = B._cache.slice(L.length), xor$5(L, J);
};
var ctr = {};
function incr32$2(B) {
  for (var L = B.length, J; L--; )
    if (J = B.readUInt8(L), J === 255)
      B.writeUInt8(0, L);
    else {
      J++, B.writeUInt8(J, L);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$f = safeBufferExports$1.Buffer, incr32$1 = incr32_1;
function getBlock(B) {
  var L = B._cipher.encryptBlockRaw(B._prev);
  return incr32$1(B._prev), L;
}
var blockSize = 16;
ctr.encrypt = function(B, L) {
  var J = Math.ceil(L.length / blockSize), ne = B._cache.length;
  B._cache = Buffer$f.concat([
    B._cache,
    Buffer$f.allocUnsafe(J * blockSize)
  ]);
  for (var oe = 0; oe < J; oe++) {
    var ce = getBlock(B), Ce = ne + oe * blockSize;
    B._cache.writeUInt32BE(ce[0], Ce + 0), B._cache.writeUInt32BE(ce[1], Ce + 4), B._cache.writeUInt32BE(ce[2], Ce + 8), B._cache.writeUInt32BE(ce[3], Ce + 12);
  }
  var rt = B._cache.slice(0, L.length);
  return B._cache = B._cache.slice(L.length), xor$4(L, rt);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$e = safeBufferExports$1.Buffer;
function asUInt32Array(B) {
  Buffer$e.isBuffer(B) || (B = Buffer$e.from(B));
  for (var L = B.length / 4 | 0, J = new Array(L), ne = 0; ne < L; ne++)
    J[ne] = B.readUInt32BE(ne * 4);
  return J;
}
function scrubVec(B) {
  for (var L = 0; L < B.length; B++)
    B[L] = 0;
}
function cryptBlock(B, L, J, ne, oe) {
  for (var ce = J[0], Ce = J[1], rt = J[2], at = J[3], ht = B[0] ^ L[0], it = B[1] ^ L[1], lt = B[2] ^ L[2], Et = B[3] ^ L[3], wt, Rt, Mt, Lt, zt = 4, Ot = 1; Ot < oe; Ot++)
    wt = ce[ht >>> 24] ^ Ce[it >>> 16 & 255] ^ rt[lt >>> 8 & 255] ^ at[Et & 255] ^ L[zt++], Rt = ce[it >>> 24] ^ Ce[lt >>> 16 & 255] ^ rt[Et >>> 8 & 255] ^ at[ht & 255] ^ L[zt++], Mt = ce[lt >>> 24] ^ Ce[Et >>> 16 & 255] ^ rt[ht >>> 8 & 255] ^ at[it & 255] ^ L[zt++], Lt = ce[Et >>> 24] ^ Ce[ht >>> 16 & 255] ^ rt[it >>> 8 & 255] ^ at[lt & 255] ^ L[zt++], ht = wt, it = Rt, lt = Mt, Et = Lt;
  return wt = (ne[ht >>> 24] << 24 | ne[it >>> 16 & 255] << 16 | ne[lt >>> 8 & 255] << 8 | ne[Et & 255]) ^ L[zt++], Rt = (ne[it >>> 24] << 24 | ne[lt >>> 16 & 255] << 16 | ne[Et >>> 8 & 255] << 8 | ne[ht & 255]) ^ L[zt++], Mt = (ne[lt >>> 24] << 24 | ne[Et >>> 16 & 255] << 16 | ne[ht >>> 8 & 255] << 8 | ne[it & 255]) ^ L[zt++], Lt = (ne[Et >>> 24] << 24 | ne[ht >>> 16 & 255] << 16 | ne[it >>> 8 & 255] << 8 | ne[lt & 255]) ^ L[zt++], wt = wt >>> 0, Rt = Rt >>> 0, Mt = Mt >>> 0, Lt = Lt >>> 0, [wt, Rt, Mt, Lt];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var B = new Array(256), L = 0; L < 256; L++)
    L < 128 ? B[L] = L << 1 : B[L] = L << 1 ^ 283;
  for (var J = [], ne = [], oe = [[], [], [], []], ce = [[], [], [], []], Ce = 0, rt = 0, at = 0; at < 256; ++at) {
    var ht = rt ^ rt << 1 ^ rt << 2 ^ rt << 3 ^ rt << 4;
    ht = ht >>> 8 ^ ht & 255 ^ 99, J[Ce] = ht, ne[ht] = Ce;
    var it = B[Ce], lt = B[it], Et = B[lt], wt = B[ht] * 257 ^ ht * 16843008;
    oe[0][Ce] = wt << 24 | wt >>> 8, oe[1][Ce] = wt << 16 | wt >>> 16, oe[2][Ce] = wt << 8 | wt >>> 24, oe[3][Ce] = wt, wt = Et * 16843009 ^ lt * 65537 ^ it * 257 ^ Ce * 16843008, ce[0][ht] = wt << 24 | wt >>> 8, ce[1][ht] = wt << 16 | wt >>> 16, ce[2][ht] = wt << 8 | wt >>> 24, ce[3][ht] = wt, Ce === 0 ? Ce = rt = 1 : (Ce = it ^ B[B[B[Et ^ it]]], rt ^= B[B[rt]]);
  }
  return {
    SBOX: J,
    INV_SBOX: ne,
    SUB_MIX: oe,
    INV_SUB_MIX: ce
  };
}();
function AES(B) {
  this._key = asUInt32Array(B), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var B = this._key, L = B.length, J = L + 6, ne = (J + 1) * 4, oe = [], ce = 0; ce < L; ce++)
    oe[ce] = B[ce];
  for (ce = L; ce < ne; ce++) {
    var Ce = oe[ce - 1];
    ce % L === 0 ? (Ce = Ce << 8 | Ce >>> 24, Ce = G.SBOX[Ce >>> 24] << 24 | G.SBOX[Ce >>> 16 & 255] << 16 | G.SBOX[Ce >>> 8 & 255] << 8 | G.SBOX[Ce & 255], Ce ^= RCON[ce / L | 0] << 24) : L > 6 && ce % L === 4 && (Ce = G.SBOX[Ce >>> 24] << 24 | G.SBOX[Ce >>> 16 & 255] << 16 | G.SBOX[Ce >>> 8 & 255] << 8 | G.SBOX[Ce & 255]), oe[ce] = oe[ce - L] ^ Ce;
  }
  for (var rt = [], at = 0; at < ne; at++) {
    var ht = ne - at, it = oe[ht - (at % 4 ? 0 : 4)];
    at < 4 || ht <= 4 ? rt[at] = it : rt[at] = G.INV_SUB_MIX[0][G.SBOX[it >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[it >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[it >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[it & 255]];
  }
  this._nRounds = J, this._keySchedule = oe, this._invKeySchedule = rt;
};
AES.prototype.encryptBlockRaw = function(B) {
  return B = asUInt32Array(B), cryptBlock(B, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(B) {
  var L = this.encryptBlockRaw(B), J = Buffer$e.allocUnsafe(16);
  return J.writeUInt32BE(L[0], 0), J.writeUInt32BE(L[1], 4), J.writeUInt32BE(L[2], 8), J.writeUInt32BE(L[3], 12), J;
};
AES.prototype.decryptBlock = function(B) {
  B = asUInt32Array(B);
  var L = B[1];
  B[1] = B[3], B[3] = L;
  var J = cryptBlock(B, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), ne = Buffer$e.allocUnsafe(16);
  return ne.writeUInt32BE(J[0], 0), ne.writeUInt32BE(J[3], 4), ne.writeUInt32BE(J[2], 8), ne.writeUInt32BE(J[1], 12), ne;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$d = safeBufferExports$1.Buffer, ZEROES = Buffer$d.alloc(16, 0);
function toArray$1(B) {
  return [
    B.readUInt32BE(0),
    B.readUInt32BE(4),
    B.readUInt32BE(8),
    B.readUInt32BE(12)
  ];
}
function fromArray(B) {
  var L = Buffer$d.allocUnsafe(16);
  return L.writeUInt32BE(B[0] >>> 0, 0), L.writeUInt32BE(B[1] >>> 0, 4), L.writeUInt32BE(B[2] >>> 0, 8), L.writeUInt32BE(B[3] >>> 0, 12), L;
}
function GHASH$1(B) {
  this.h = B, this.state = Buffer$d.alloc(16, 0), this.cache = Buffer$d.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(B) {
  for (var L = -1; ++L < B.length; )
    this.state[L] ^= B[L];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var B = toArray$1(this.h), L = [0, 0, 0, 0], J, ne, oe, ce = -1; ++ce < 128; ) {
    for (ne = (this.state[~~(ce / 8)] & 1 << 7 - ce % 8) !== 0, ne && (L[0] ^= B[0], L[1] ^= B[1], L[2] ^= B[2], L[3] ^= B[3]), oe = (B[3] & 1) !== 0, J = 3; J > 0; J--)
      B[J] = B[J] >>> 1 | (B[J - 1] & 1) << 31;
    B[0] = B[0] >>> 1, oe && (B[0] = B[0] ^ 225 << 24);
  }
  this.state = fromArray(L);
};
GHASH$1.prototype.update = function(B) {
  this.cache = Buffer$d.concat([this.cache, B]);
  for (var L; this.cache.length >= 16; )
    L = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(L);
};
GHASH$1.prototype.final = function(B, L) {
  return this.cache.length && this.ghash(Buffer$d.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, B, 0, L])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$c = safeBufferExports$1.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(B, L) {
  var J = 0;
  B.length !== L.length && J++;
  for (var ne = Math.min(B.length, L.length), oe = 0; oe < ne; ++oe)
    J += B[oe] ^ L[oe];
  return J;
}
function calcIv(B, L, J) {
  if (L.length === 12)
    return B._finID = Buffer$c.concat([L, Buffer$c.from([0, 0, 0, 1])]), Buffer$c.concat([L, Buffer$c.from([0, 0, 0, 2])]);
  var ne = new GHASH(J), oe = L.length, ce = oe % 16;
  ne.update(L), ce && (ce = 16 - ce, ne.update(Buffer$c.alloc(ce, 0))), ne.update(Buffer$c.alloc(8, 0));
  var Ce = oe * 8, rt = Buffer$c.alloc(8);
  rt.writeUIntBE(Ce, 0, 8), ne.update(rt), B._finID = ne.state;
  var at = Buffer$c.from(B._finID);
  return incr32(at), at;
}
function StreamCipher$3(B, L, J, ne) {
  Transform$5.call(this);
  var oe = Buffer$c.alloc(4, 0);
  this._cipher = new aes$4.AES(L);
  var ce = this._cipher.encryptBlock(oe);
  this._ghash = new GHASH(ce), J = calcIv(this, J, ce), this._prev = Buffer$c.from(J), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = ne, this._alen = 0, this._len = 0, this._mode = B, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(B) {
  if (!this._called && this._alen) {
    var L = 16 - this._alen % 16;
    L < 16 && (L = Buffer$c.alloc(L, 0), this._ghash.update(L));
  }
  this._called = !0;
  var J = this._mode.encrypt(this, B);
  return this._decrypt ? this._ghash.update(B) : this._ghash.update(J), this._len += B.length, J;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var B = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(B, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = B, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$c.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(L) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = L;
};
StreamCipher$3.prototype.setAAD = function(L) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(L), this._alen += L.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$b = safeBufferExports$1.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(B, L, J, ne) {
  Transform$4.call(this), this._cipher = new aes$3.AES(L), this._prev = Buffer$b.from(J), this._cache = Buffer$b.allocUnsafe(0), this._secCache = Buffer$b.allocUnsafe(0), this._decrypt = ne, this._mode = B;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(B) {
  return this._mode.encrypt(this, B, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$a = safeBufferExports$1.Buffer, MD5 = md5_js;
function EVP_BytesToKey(B, L, J, ne) {
  if (Buffer$a.isBuffer(B) || (B = Buffer$a.from(B, "binary")), L && (Buffer$a.isBuffer(L) || (L = Buffer$a.from(L, "binary")), L.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var oe = J / 8, ce = Buffer$a.alloc(oe), Ce = Buffer$a.alloc(ne || 0), rt = Buffer$a.alloc(0); oe > 0 || ne > 0; ) {
    var at = new MD5();
    at.update(rt), at.update(B), L && at.update(L), rt = at.digest();
    var ht = 0;
    if (oe > 0) {
      var it = ce.length - oe;
      ht = Math.min(oe, rt.length), rt.copy(ce, it, 0, ht), oe -= ht;
    }
    if (ht < rt.length && ne > 0) {
      var lt = Ce.length - ne, Et = Math.min(ne, rt.length - ht);
      rt.copy(Ce, lt, ht, ht + Et), ne -= Et;
    }
  }
  return rt.fill(0), { key: ce, iv: Ce };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$9 = safeBufferExports$1.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(B, L, J) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(L), this._prev = Buffer$9.from(J), this._mode = B, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(B) {
  this._cache.add(B);
  for (var L, J, ne = []; L = this._cache.get(); )
    J = this._mode.encrypt(this, L), ne.push(J);
  return Buffer$9.concat(ne);
};
var PADDING = Buffer$9.alloc(16, 16);
Cipher.prototype._final = function() {
  var B = this._cache.flush();
  if (this._autopadding)
    return B = this._mode.encrypt(this, B), this._cipher.scrub(), B;
  if (!B.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(B) {
  return this._autopadding = !!B, this;
};
function Splitter$1() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter$1.prototype.add = function(B) {
  this.cache = Buffer$9.concat([this.cache, B]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var B = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), B;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var B = 16 - this.cache.length, L = Buffer$9.allocUnsafe(B), J = -1; ++J < B; )
    L.writeUInt8(B, J);
  return Buffer$9.concat([this.cache, L]);
};
function createCipheriv$1(B, L, J) {
  var ne = MODES$1[B.toLowerCase()];
  if (!ne) throw new TypeError("invalid suite type");
  if (typeof L == "string" && (L = Buffer$9.from(L)), L.length !== ne.key / 8) throw new TypeError("invalid key length " + L.length);
  if (typeof J == "string" && (J = Buffer$9.from(J)), ne.mode !== "GCM" && J.length !== ne.iv) throw new TypeError("invalid iv length " + J.length);
  return ne.type === "stream" ? new StreamCipher$1(ne.module, L, J) : ne.type === "auth" ? new AuthCipher$1(ne.module, L, J) : new Cipher(ne.module, L, J);
}
function createCipher$1(B, L) {
  var J = MODES$1[B.toLowerCase()];
  if (!J) throw new TypeError("invalid suite type");
  var ne = ebtk$2(L, !1, J.key, J.iv);
  return createCipheriv$1(B, ne.key, ne.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$8 = safeBufferExports$1.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(B, L, J) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(L), this._prev = Buffer$8.from(J), this._mode = B, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(B) {
  this._cache.add(B);
  for (var L, J, ne = []; L = this._cache.get(this._autopadding); )
    J = this._mode.decrypt(this, L), ne.push(J);
  return Buffer$8.concat(ne);
};
Decipher.prototype._final = function() {
  var B = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, B));
  if (B)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(B) {
  return this._autopadding = !!B, this;
};
function Splitter() {
  this.cache = Buffer$8.allocUnsafe(0);
}
Splitter.prototype.add = function(B) {
  this.cache = Buffer$8.concat([this.cache, B]);
};
Splitter.prototype.get = function(B) {
  var L;
  if (B) {
    if (this.cache.length > 16)
      return L = this.cache.slice(0, 16), this.cache = this.cache.slice(16), L;
  } else if (this.cache.length >= 16)
    return L = this.cache.slice(0, 16), this.cache = this.cache.slice(16), L;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(B) {
  var L = B[15];
  if (L < 1 || L > 16)
    throw new Error("unable to decrypt data");
  for (var J = -1; ++J < L; )
    if (B[J + (16 - L)] !== L)
      throw new Error("unable to decrypt data");
  if (L !== 16)
    return B.slice(0, 16 - L);
}
function createDecipheriv$1(B, L, J) {
  var ne = MODES[B.toLowerCase()];
  if (!ne) throw new TypeError("invalid suite type");
  if (typeof J == "string" && (J = Buffer$8.from(J)), ne.mode !== "GCM" && J.length !== ne.iv) throw new TypeError("invalid iv length " + J.length);
  if (typeof L == "string" && (L = Buffer$8.from(L)), L.length !== ne.key / 8) throw new TypeError("invalid key length " + L.length);
  return ne.type === "stream" ? new StreamCipher(ne.module, L, J, !0) : ne.type === "auth" ? new AuthCipher(ne.module, L, J, !0) : new Decipher(ne.module, L, J);
}
function createDecipher$1(B, L) {
  var J = MODES[B.toLowerCase()];
  if (!J) throw new TypeError("invalid suite type");
  var ne = ebtk$1(L, !1, J.key, J.iv);
  return createDecipheriv$1(B, ne.key, ne.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(B) {
  B["des-ecb"] = {
    key: 8,
    iv: 0
  }, B["des-cbc"] = B.des = {
    key: 8,
    iv: 8
  }, B["des-ede3-cbc"] = B.des3 = {
    key: 24,
    iv: 8
  }, B["des-ede3"] = {
    key: 24,
    iv: 0
  }, B["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, B["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(B, L) {
  B = B.toLowerCase();
  var J, ne;
  if (aesModes[B])
    J = aesModes[B].key, ne = aesModes[B].iv;
  else if (desModes[B])
    J = desModes[B].key * 8, ne = desModes[B].iv;
  else
    throw new TypeError("invalid suite type");
  var oe = ebtk(L, !1, J, ne);
  return createCipheriv(B, oe.key, oe.iv);
}
function createDecipher(B, L) {
  B = B.toLowerCase();
  var J, ne;
  if (aesModes[B])
    J = aesModes[B].key, ne = aesModes[B].iv;
  else if (desModes[B])
    J = desModes[B].key * 8, ne = desModes[B].iv;
  else
    throw new TypeError("invalid suite type");
  var oe = ebtk(L, !1, J, ne);
  return createDecipheriv(B, oe.key, oe.iv);
}
function createCipheriv(B, L, J) {
  if (B = B.toLowerCase(), aesModes[B]) return aes.createCipheriv(B, L, J);
  if (desModes[B]) return new DES({ key: L, iv: J, mode: B });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(B, L, J) {
  if (B = B.toLowerCase(), aesModes[B]) return aes.createDecipheriv(B, L, J);
  if (desModes[B]) return new DES({ key: L, iv: J, mode: B, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
(function(B) {
  (function(L, J) {
    function ne(Ht, ct) {
      if (!Ht) throw new Error(ct || "Assertion failed");
    }
    function oe(Ht, ct) {
      Ht.super_ = ct;
      var dt = function() {
      };
      dt.prototype = ct.prototype, Ht.prototype = new dt(), Ht.prototype.constructor = Ht;
    }
    function ce(Ht, ct, dt) {
      if (ce.isBN(Ht))
        return Ht;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Ht !== null && ((ct === "le" || ct === "be") && (dt = ct, ct = 10), this._init(Ht || 0, ct || 10, dt || "be"));
    }
    typeof L == "object" ? L.exports = ce : J.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var Ce;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Ce = window.Buffer : Ce = require$$1$2.Buffer;
    } catch {
    }
    ce.isBN = function(ct) {
      return ct instanceof ce ? !0 : ct !== null && typeof ct == "object" && ct.constructor.wordSize === ce.wordSize && Array.isArray(ct.words);
    }, ce.max = function(ct, dt) {
      return ct.cmp(dt) > 0 ? ct : dt;
    }, ce.min = function(ct, dt) {
      return ct.cmp(dt) < 0 ? ct : dt;
    }, ce.prototype._init = function(ct, dt, ot) {
      if (typeof ct == "number")
        return this._initNumber(ct, dt, ot);
      if (typeof ct == "object")
        return this._initArray(ct, dt, ot);
      dt === "hex" && (dt = 16), ne(dt === (dt | 0) && dt >= 2 && dt <= 36), ct = ct.toString().replace(/\s+/g, "");
      var ut = 0;
      ct[0] === "-" && (ut++, this.negative = 1), ut < ct.length && (dt === 16 ? this._parseHex(ct, ut, ot) : (this._parseBase(ct, dt, ut), ot === "le" && this._initArray(this.toArray(), dt, ot)));
    }, ce.prototype._initNumber = function(ct, dt, ot) {
      ct < 0 && (this.negative = 1, ct = -ct), ct < 67108864 ? (this.words = [ct & 67108863], this.length = 1) : ct < 4503599627370496 ? (this.words = [
        ct & 67108863,
        ct / 67108864 & 67108863
      ], this.length = 2) : (ne(ct < 9007199254740992), this.words = [
        ct & 67108863,
        ct / 67108864 & 67108863,
        1
      ], this.length = 3), ot === "le" && this._initArray(this.toArray(), dt, ot);
    }, ce.prototype._initArray = function(ct, dt, ot) {
      if (ne(typeof ct.length == "number"), ct.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ct.length / 3), this.words = new Array(this.length);
      for (var ut = 0; ut < this.length; ut++)
        this.words[ut] = 0;
      var mt, gt, St = 0;
      if (ot === "be")
        for (ut = ct.length - 1, mt = 0; ut >= 0; ut -= 3)
          gt = ct[ut] | ct[ut - 1] << 8 | ct[ut - 2] << 16, this.words[mt] |= gt << St & 67108863, this.words[mt + 1] = gt >>> 26 - St & 67108863, St += 24, St >= 26 && (St -= 26, mt++);
      else if (ot === "le")
        for (ut = 0, mt = 0; ut < ct.length; ut += 3)
          gt = ct[ut] | ct[ut + 1] << 8 | ct[ut + 2] << 16, this.words[mt] |= gt << St & 67108863, this.words[mt + 1] = gt >>> 26 - St & 67108863, St += 24, St >= 26 && (St -= 26, mt++);
      return this.strip();
    };
    function rt(Ht, ct) {
      var dt = Ht.charCodeAt(ct);
      return dt >= 65 && dt <= 70 ? dt - 55 : dt >= 97 && dt <= 102 ? dt - 87 : dt - 48 & 15;
    }
    function at(Ht, ct, dt) {
      var ot = rt(Ht, dt);
      return dt - 1 >= ct && (ot |= rt(Ht, dt - 1) << 4), ot;
    }
    ce.prototype._parseHex = function(ct, dt, ot) {
      this.length = Math.ceil((ct.length - dt) / 6), this.words = new Array(this.length);
      for (var ut = 0; ut < this.length; ut++)
        this.words[ut] = 0;
      var mt = 0, gt = 0, St;
      if (ot === "be")
        for (ut = ct.length - 1; ut >= dt; ut -= 2)
          St = at(ct, dt, ut) << mt, this.words[gt] |= St & 67108863, mt >= 18 ? (mt -= 18, gt += 1, this.words[gt] |= St >>> 26) : mt += 8;
      else {
        var xt = ct.length - dt;
        for (ut = xt % 2 === 0 ? dt + 1 : dt; ut < ct.length; ut += 2)
          St = at(ct, dt, ut) << mt, this.words[gt] |= St & 67108863, mt >= 18 ? (mt -= 18, gt += 1, this.words[gt] |= St >>> 26) : mt += 8;
      }
      this.strip();
    };
    function ht(Ht, ct, dt, ot) {
      for (var ut = 0, mt = Math.min(Ht.length, dt), gt = ct; gt < mt; gt++) {
        var St = Ht.charCodeAt(gt) - 48;
        ut *= ot, St >= 49 ? ut += St - 49 + 10 : St >= 17 ? ut += St - 17 + 10 : ut += St;
      }
      return ut;
    }
    ce.prototype._parseBase = function(ct, dt, ot) {
      this.words = [0], this.length = 1;
      for (var ut = 0, mt = 1; mt <= 67108863; mt *= dt)
        ut++;
      ut--, mt = mt / dt | 0;
      for (var gt = ct.length - ot, St = gt % ut, xt = Math.min(gt, gt - St) + ot, vt = 0, $t = ot; $t < xt; $t += ut)
        vt = ht(ct, $t, $t + ut, dt), this.imuln(mt), this.words[0] + vt < 67108864 ? this.words[0] += vt : this._iaddn(vt);
      if (St !== 0) {
        var yt = 1;
        for (vt = ht(ct, $t, ct.length, dt), $t = 0; $t < St; $t++)
          yt *= dt;
        this.imuln(yt), this.words[0] + vt < 67108864 ? this.words[0] += vt : this._iaddn(vt);
      }
      this.strip();
    }, ce.prototype.copy = function(ct) {
      ct.words = new Array(this.length);
      for (var dt = 0; dt < this.length; dt++)
        ct.words[dt] = this.words[dt];
      ct.length = this.length, ct.negative = this.negative, ct.red = this.red;
    }, ce.prototype.clone = function() {
      var ct = new ce(null);
      return this.copy(ct), ct;
    }, ce.prototype._expand = function(ct) {
      for (; this.length < ct; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, ce.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var it = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], lt = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Et = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(ct, dt) {
      ct = ct || 10, dt = dt | 0 || 1;
      var ot;
      if (ct === 16 || ct === "hex") {
        ot = "";
        for (var ut = 0, mt = 0, gt = 0; gt < this.length; gt++) {
          var St = this.words[gt], xt = ((St << ut | mt) & 16777215).toString(16);
          mt = St >>> 24 - ut & 16777215, mt !== 0 || gt !== this.length - 1 ? ot = it[6 - xt.length] + xt + ot : ot = xt + ot, ut += 2, ut >= 26 && (ut -= 26, gt--);
        }
        for (mt !== 0 && (ot = mt.toString(16) + ot); ot.length % dt !== 0; )
          ot = "0" + ot;
        return this.negative !== 0 && (ot = "-" + ot), ot;
      }
      if (ct === (ct | 0) && ct >= 2 && ct <= 36) {
        var vt = lt[ct], $t = Et[ct];
        ot = "";
        var yt = this.clone();
        for (yt.negative = 0; !yt.isZero(); ) {
          var Bt = yt.modn($t).toString(ct);
          yt = yt.idivn($t), yt.isZero() ? ot = Bt + ot : ot = it[vt - Bt.length] + Bt + ot;
        }
        for (this.isZero() && (ot = "0" + ot); ot.length % dt !== 0; )
          ot = "0" + ot;
        return this.negative !== 0 && (ot = "-" + ot), ot;
      }
      ne(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var ct = this.words[0];
      return this.length === 2 ? ct += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ct += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ct : ct;
    }, ce.prototype.toJSON = function() {
      return this.toString(16);
    }, ce.prototype.toBuffer = function(ct, dt) {
      return ne(typeof Ce < "u"), this.toArrayLike(Ce, ct, dt);
    }, ce.prototype.toArray = function(ct, dt) {
      return this.toArrayLike(Array, ct, dt);
    }, ce.prototype.toArrayLike = function(ct, dt, ot) {
      var ut = this.byteLength(), mt = ot || Math.max(1, ut);
      ne(ut <= mt, "byte array longer than desired length"), ne(mt > 0, "Requested array length <= 0"), this.strip();
      var gt = dt === "le", St = new ct(mt), xt, vt, $t = this.clone();
      if (gt) {
        for (vt = 0; !$t.isZero(); vt++)
          xt = $t.andln(255), $t.iushrn(8), St[vt] = xt;
        for (; vt < mt; vt++)
          St[vt] = 0;
      } else {
        for (vt = 0; vt < mt - ut; vt++)
          St[vt] = 0;
        for (vt = 0; !$t.isZero(); vt++)
          xt = $t.andln(255), $t.iushrn(8), St[mt - vt - 1] = xt;
      }
      return St;
    }, Math.clz32 ? ce.prototype._countBits = function(ct) {
      return 32 - Math.clz32(ct);
    } : ce.prototype._countBits = function(ct) {
      var dt = ct, ot = 0;
      return dt >= 4096 && (ot += 13, dt >>>= 13), dt >= 64 && (ot += 7, dt >>>= 7), dt >= 8 && (ot += 4, dt >>>= 4), dt >= 2 && (ot += 2, dt >>>= 2), ot + dt;
    }, ce.prototype._zeroBits = function(ct) {
      if (ct === 0) return 26;
      var dt = ct, ot = 0;
      return dt & 8191 || (ot += 13, dt >>>= 13), dt & 127 || (ot += 7, dt >>>= 7), dt & 15 || (ot += 4, dt >>>= 4), dt & 3 || (ot += 2, dt >>>= 2), dt & 1 || ot++, ot;
    }, ce.prototype.bitLength = function() {
      var ct = this.words[this.length - 1], dt = this._countBits(ct);
      return (this.length - 1) * 26 + dt;
    };
    function wt(Ht) {
      for (var ct = new Array(Ht.bitLength()), dt = 0; dt < ct.length; dt++) {
        var ot = dt / 26 | 0, ut = dt % 26;
        ct[dt] = (Ht.words[ot] & 1 << ut) >>> ut;
      }
      return ct;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ct = 0, dt = 0; dt < this.length; dt++) {
        var ot = this._zeroBits(this.words[dt]);
        if (ct += ot, ot !== 26) break;
      }
      return ct;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(ct) {
      return this.negative !== 0 ? this.abs().inotn(ct).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(ct) {
      return this.testn(ct - 1) ? this.notn(ct).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(ct) {
      for (; this.length < ct.length; )
        this.words[this.length++] = 0;
      for (var dt = 0; dt < ct.length; dt++)
        this.words[dt] = this.words[dt] | ct.words[dt];
      return this.strip();
    }, ce.prototype.ior = function(ct) {
      return ne((this.negative | ct.negative) === 0), this.iuor(ct);
    }, ce.prototype.or = function(ct) {
      return this.length > ct.length ? this.clone().ior(ct) : ct.clone().ior(this);
    }, ce.prototype.uor = function(ct) {
      return this.length > ct.length ? this.clone().iuor(ct) : ct.clone().iuor(this);
    }, ce.prototype.iuand = function(ct) {
      var dt;
      this.length > ct.length ? dt = ct : dt = this;
      for (var ot = 0; ot < dt.length; ot++)
        this.words[ot] = this.words[ot] & ct.words[ot];
      return this.length = dt.length, this.strip();
    }, ce.prototype.iand = function(ct) {
      return ne((this.negative | ct.negative) === 0), this.iuand(ct);
    }, ce.prototype.and = function(ct) {
      return this.length > ct.length ? this.clone().iand(ct) : ct.clone().iand(this);
    }, ce.prototype.uand = function(ct) {
      return this.length > ct.length ? this.clone().iuand(ct) : ct.clone().iuand(this);
    }, ce.prototype.iuxor = function(ct) {
      var dt, ot;
      this.length > ct.length ? (dt = this, ot = ct) : (dt = ct, ot = this);
      for (var ut = 0; ut < ot.length; ut++)
        this.words[ut] = dt.words[ut] ^ ot.words[ut];
      if (this !== dt)
        for (; ut < dt.length; ut++)
          this.words[ut] = dt.words[ut];
      return this.length = dt.length, this.strip();
    }, ce.prototype.ixor = function(ct) {
      return ne((this.negative | ct.negative) === 0), this.iuxor(ct);
    }, ce.prototype.xor = function(ct) {
      return this.length > ct.length ? this.clone().ixor(ct) : ct.clone().ixor(this);
    }, ce.prototype.uxor = function(ct) {
      return this.length > ct.length ? this.clone().iuxor(ct) : ct.clone().iuxor(this);
    }, ce.prototype.inotn = function(ct) {
      ne(typeof ct == "number" && ct >= 0);
      var dt = Math.ceil(ct / 26) | 0, ot = ct % 26;
      this._expand(dt), ot > 0 && dt--;
      for (var ut = 0; ut < dt; ut++)
        this.words[ut] = ~this.words[ut] & 67108863;
      return ot > 0 && (this.words[ut] = ~this.words[ut] & 67108863 >> 26 - ot), this.strip();
    }, ce.prototype.notn = function(ct) {
      return this.clone().inotn(ct);
    }, ce.prototype.setn = function(ct, dt) {
      ne(typeof ct == "number" && ct >= 0);
      var ot = ct / 26 | 0, ut = ct % 26;
      return this._expand(ot + 1), dt ? this.words[ot] = this.words[ot] | 1 << ut : this.words[ot] = this.words[ot] & ~(1 << ut), this.strip();
    }, ce.prototype.iadd = function(ct) {
      var dt;
      if (this.negative !== 0 && ct.negative === 0)
        return this.negative = 0, dt = this.isub(ct), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ct.negative !== 0)
        return ct.negative = 0, dt = this.isub(ct), ct.negative = 1, dt._normSign();
      var ot, ut;
      this.length > ct.length ? (ot = this, ut = ct) : (ot = ct, ut = this);
      for (var mt = 0, gt = 0; gt < ut.length; gt++)
        dt = (ot.words[gt] | 0) + (ut.words[gt] | 0) + mt, this.words[gt] = dt & 67108863, mt = dt >>> 26;
      for (; mt !== 0 && gt < ot.length; gt++)
        dt = (ot.words[gt] | 0) + mt, this.words[gt] = dt & 67108863, mt = dt >>> 26;
      if (this.length = ot.length, mt !== 0)
        this.words[this.length] = mt, this.length++;
      else if (ot !== this)
        for (; gt < ot.length; gt++)
          this.words[gt] = ot.words[gt];
      return this;
    }, ce.prototype.add = function(ct) {
      var dt;
      return ct.negative !== 0 && this.negative === 0 ? (ct.negative = 0, dt = this.sub(ct), ct.negative ^= 1, dt) : ct.negative === 0 && this.negative !== 0 ? (this.negative = 0, dt = ct.sub(this), this.negative = 1, dt) : this.length > ct.length ? this.clone().iadd(ct) : ct.clone().iadd(this);
    }, ce.prototype.isub = function(ct) {
      if (ct.negative !== 0) {
        ct.negative = 0;
        var dt = this.iadd(ct);
        return ct.negative = 1, dt._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ct), this.negative = 1, this._normSign();
      var ot = this.cmp(ct);
      if (ot === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ut, mt;
      ot > 0 ? (ut = this, mt = ct) : (ut = ct, mt = this);
      for (var gt = 0, St = 0; St < mt.length; St++)
        dt = (ut.words[St] | 0) - (mt.words[St] | 0) + gt, gt = dt >> 26, this.words[St] = dt & 67108863;
      for (; gt !== 0 && St < ut.length; St++)
        dt = (ut.words[St] | 0) + gt, gt = dt >> 26, this.words[St] = dt & 67108863;
      if (gt === 0 && St < ut.length && ut !== this)
        for (; St < ut.length; St++)
          this.words[St] = ut.words[St];
      return this.length = Math.max(this.length, St), ut !== this && (this.negative = 1), this.strip();
    }, ce.prototype.sub = function(ct) {
      return this.clone().isub(ct);
    };
    function Rt(Ht, ct, dt) {
      dt.negative = ct.negative ^ Ht.negative;
      var ot = Ht.length + ct.length | 0;
      dt.length = ot, ot = ot - 1 | 0;
      var ut = Ht.words[0] | 0, mt = ct.words[0] | 0, gt = ut * mt, St = gt & 67108863, xt = gt / 67108864 | 0;
      dt.words[0] = St;
      for (var vt = 1; vt < ot; vt++) {
        for (var $t = xt >>> 26, yt = xt & 67108863, Bt = Math.min(vt, ct.length - 1), rr = Math.max(0, vt - Ht.length + 1); rr <= Bt; rr++) {
          var dr = vt - rr | 0;
          ut = Ht.words[dr] | 0, mt = ct.words[rr] | 0, gt = ut * mt + yt, $t += gt / 67108864 | 0, yt = gt & 67108863;
        }
        dt.words[vt] = yt | 0, xt = $t | 0;
      }
      return xt !== 0 ? dt.words[vt] = xt | 0 : dt.length--, dt.strip();
    }
    var Mt = function(ct, dt, ot) {
      var ut = ct.words, mt = dt.words, gt = ot.words, St = 0, xt, vt, $t, yt = ut[0] | 0, Bt = yt & 8191, rr = yt >>> 13, dr = ut[1] | 0, tr = dr & 8191, Dt = dr >>> 13, Wt = ut[2] | 0, or = Wt & 8191, _r = Wt >>> 13, Xt = ut[3] | 0, Qt = Xt & 8191, br = Xt >>> 13, Dr = ut[4] | 0, Vr = Dr & 8191, Zr = Dr >>> 13, ln = ut[5] | 0, _n = ln & 8191, Mr = ln >>> 13, Wn = ut[6] | 0, xn = Wn & 8191, ni = Wn >>> 13, Gn = ut[7] | 0, En = Gn & 8191, Pn = Gn >>> 13, ti = ut[8] | 0, gn = ti & 8191, Kn = ti >>> 13, gi = ut[9] | 0, Gt = gi & 8191, At = gi >>> 13, kt = mt[0] | 0, Zt = kt & 8191, pr = kt >>> 13, Sr = mt[1] | 0, Tr = Sr & 8191, fn = Sr >>> 13, On = mt[2] | 0, tn = On & 8191, In = On >>> 13, hn = mt[3] | 0, cn = hn & 8191, ci = hn >>> 13, pi = mt[4] | 0, ur = pi & 8191, ir = pi >>> 13, lr = mt[5] | 0, gr = lr & 8191, Ar = lr >>> 13, Fr = mt[6] | 0, jr = Fr & 8191, Xr = Fr >>> 13, pn = mt[7] | 0, Yr = pn & 8191, vn = pn >>> 13, Cn = mt[8] | 0, dn = Cn & 8191, fr = Cn >>> 13, Nr = mt[9] | 0, Ir = Nr & 8191, sn = Nr >>> 13;
      ot.negative = ct.negative ^ dt.negative, ot.length = 19, xt = Math.imul(Bt, Zt), vt = Math.imul(Bt, pr), vt = vt + Math.imul(rr, Zt) | 0, $t = Math.imul(rr, pr);
      var Tn = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Tn >>> 26) | 0, Tn &= 67108863, xt = Math.imul(tr, Zt), vt = Math.imul(tr, pr), vt = vt + Math.imul(Dt, Zt) | 0, $t = Math.imul(Dt, pr), xt = xt + Math.imul(Bt, Tr) | 0, vt = vt + Math.imul(Bt, fn) | 0, vt = vt + Math.imul(rr, Tr) | 0, $t = $t + Math.imul(rr, fn) | 0;
      var kn = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, xt = Math.imul(or, Zt), vt = Math.imul(or, pr), vt = vt + Math.imul(_r, Zt) | 0, $t = Math.imul(_r, pr), xt = xt + Math.imul(tr, Tr) | 0, vt = vt + Math.imul(tr, fn) | 0, vt = vt + Math.imul(Dt, Tr) | 0, $t = $t + Math.imul(Dt, fn) | 0, xt = xt + Math.imul(Bt, tn) | 0, vt = vt + Math.imul(Bt, In) | 0, vt = vt + Math.imul(rr, tn) | 0, $t = $t + Math.imul(rr, In) | 0;
      var Dn = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, xt = Math.imul(Qt, Zt), vt = Math.imul(Qt, pr), vt = vt + Math.imul(br, Zt) | 0, $t = Math.imul(br, pr), xt = xt + Math.imul(or, Tr) | 0, vt = vt + Math.imul(or, fn) | 0, vt = vt + Math.imul(_r, Tr) | 0, $t = $t + Math.imul(_r, fn) | 0, xt = xt + Math.imul(tr, tn) | 0, vt = vt + Math.imul(tr, In) | 0, vt = vt + Math.imul(Dt, tn) | 0, $t = $t + Math.imul(Dt, In) | 0, xt = xt + Math.imul(Bt, cn) | 0, vt = vt + Math.imul(Bt, ci) | 0, vt = vt + Math.imul(rr, cn) | 0, $t = $t + Math.imul(rr, ci) | 0;
      var Jn = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Jn >>> 26) | 0, Jn &= 67108863, xt = Math.imul(Vr, Zt), vt = Math.imul(Vr, pr), vt = vt + Math.imul(Zr, Zt) | 0, $t = Math.imul(Zr, pr), xt = xt + Math.imul(Qt, Tr) | 0, vt = vt + Math.imul(Qt, fn) | 0, vt = vt + Math.imul(br, Tr) | 0, $t = $t + Math.imul(br, fn) | 0, xt = xt + Math.imul(or, tn) | 0, vt = vt + Math.imul(or, In) | 0, vt = vt + Math.imul(_r, tn) | 0, $t = $t + Math.imul(_r, In) | 0, xt = xt + Math.imul(tr, cn) | 0, vt = vt + Math.imul(tr, ci) | 0, vt = vt + Math.imul(Dt, cn) | 0, $t = $t + Math.imul(Dt, ci) | 0, xt = xt + Math.imul(Bt, ur) | 0, vt = vt + Math.imul(Bt, ir) | 0, vt = vt + Math.imul(rr, ur) | 0, $t = $t + Math.imul(rr, ir) | 0;
      var Ti = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Ti >>> 26) | 0, Ti &= 67108863, xt = Math.imul(_n, Zt), vt = Math.imul(_n, pr), vt = vt + Math.imul(Mr, Zt) | 0, $t = Math.imul(Mr, pr), xt = xt + Math.imul(Vr, Tr) | 0, vt = vt + Math.imul(Vr, fn) | 0, vt = vt + Math.imul(Zr, Tr) | 0, $t = $t + Math.imul(Zr, fn) | 0, xt = xt + Math.imul(Qt, tn) | 0, vt = vt + Math.imul(Qt, In) | 0, vt = vt + Math.imul(br, tn) | 0, $t = $t + Math.imul(br, In) | 0, xt = xt + Math.imul(or, cn) | 0, vt = vt + Math.imul(or, ci) | 0, vt = vt + Math.imul(_r, cn) | 0, $t = $t + Math.imul(_r, ci) | 0, xt = xt + Math.imul(tr, ur) | 0, vt = vt + Math.imul(tr, ir) | 0, vt = vt + Math.imul(Dt, ur) | 0, $t = $t + Math.imul(Dt, ir) | 0, xt = xt + Math.imul(Bt, gr) | 0, vt = vt + Math.imul(Bt, Ar) | 0, vt = vt + Math.imul(rr, gr) | 0, $t = $t + Math.imul(rr, Ar) | 0;
      var _i = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (_i >>> 26) | 0, _i &= 67108863, xt = Math.imul(xn, Zt), vt = Math.imul(xn, pr), vt = vt + Math.imul(ni, Zt) | 0, $t = Math.imul(ni, pr), xt = xt + Math.imul(_n, Tr) | 0, vt = vt + Math.imul(_n, fn) | 0, vt = vt + Math.imul(Mr, Tr) | 0, $t = $t + Math.imul(Mr, fn) | 0, xt = xt + Math.imul(Vr, tn) | 0, vt = vt + Math.imul(Vr, In) | 0, vt = vt + Math.imul(Zr, tn) | 0, $t = $t + Math.imul(Zr, In) | 0, xt = xt + Math.imul(Qt, cn) | 0, vt = vt + Math.imul(Qt, ci) | 0, vt = vt + Math.imul(br, cn) | 0, $t = $t + Math.imul(br, ci) | 0, xt = xt + Math.imul(or, ur) | 0, vt = vt + Math.imul(or, ir) | 0, vt = vt + Math.imul(_r, ur) | 0, $t = $t + Math.imul(_r, ir) | 0, xt = xt + Math.imul(tr, gr) | 0, vt = vt + Math.imul(tr, Ar) | 0, vt = vt + Math.imul(Dt, gr) | 0, $t = $t + Math.imul(Dt, Ar) | 0, xt = xt + Math.imul(Bt, jr) | 0, vt = vt + Math.imul(Bt, Xr) | 0, vt = vt + Math.imul(rr, jr) | 0, $t = $t + Math.imul(rr, Xr) | 0;
      var Ri = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Ri >>> 26) | 0, Ri &= 67108863, xt = Math.imul(En, Zt), vt = Math.imul(En, pr), vt = vt + Math.imul(Pn, Zt) | 0, $t = Math.imul(Pn, pr), xt = xt + Math.imul(xn, Tr) | 0, vt = vt + Math.imul(xn, fn) | 0, vt = vt + Math.imul(ni, Tr) | 0, $t = $t + Math.imul(ni, fn) | 0, xt = xt + Math.imul(_n, tn) | 0, vt = vt + Math.imul(_n, In) | 0, vt = vt + Math.imul(Mr, tn) | 0, $t = $t + Math.imul(Mr, In) | 0, xt = xt + Math.imul(Vr, cn) | 0, vt = vt + Math.imul(Vr, ci) | 0, vt = vt + Math.imul(Zr, cn) | 0, $t = $t + Math.imul(Zr, ci) | 0, xt = xt + Math.imul(Qt, ur) | 0, vt = vt + Math.imul(Qt, ir) | 0, vt = vt + Math.imul(br, ur) | 0, $t = $t + Math.imul(br, ir) | 0, xt = xt + Math.imul(or, gr) | 0, vt = vt + Math.imul(or, Ar) | 0, vt = vt + Math.imul(_r, gr) | 0, $t = $t + Math.imul(_r, Ar) | 0, xt = xt + Math.imul(tr, jr) | 0, vt = vt + Math.imul(tr, Xr) | 0, vt = vt + Math.imul(Dt, jr) | 0, $t = $t + Math.imul(Dt, Xr) | 0, xt = xt + Math.imul(Bt, Yr) | 0, vt = vt + Math.imul(Bt, vn) | 0, vt = vt + Math.imul(rr, Yr) | 0, $t = $t + Math.imul(rr, vn) | 0;
      var Qi = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, xt = Math.imul(gn, Zt), vt = Math.imul(gn, pr), vt = vt + Math.imul(Kn, Zt) | 0, $t = Math.imul(Kn, pr), xt = xt + Math.imul(En, Tr) | 0, vt = vt + Math.imul(En, fn) | 0, vt = vt + Math.imul(Pn, Tr) | 0, $t = $t + Math.imul(Pn, fn) | 0, xt = xt + Math.imul(xn, tn) | 0, vt = vt + Math.imul(xn, In) | 0, vt = vt + Math.imul(ni, tn) | 0, $t = $t + Math.imul(ni, In) | 0, xt = xt + Math.imul(_n, cn) | 0, vt = vt + Math.imul(_n, ci) | 0, vt = vt + Math.imul(Mr, cn) | 0, $t = $t + Math.imul(Mr, ci) | 0, xt = xt + Math.imul(Vr, ur) | 0, vt = vt + Math.imul(Vr, ir) | 0, vt = vt + Math.imul(Zr, ur) | 0, $t = $t + Math.imul(Zr, ir) | 0, xt = xt + Math.imul(Qt, gr) | 0, vt = vt + Math.imul(Qt, Ar) | 0, vt = vt + Math.imul(br, gr) | 0, $t = $t + Math.imul(br, Ar) | 0, xt = xt + Math.imul(or, jr) | 0, vt = vt + Math.imul(or, Xr) | 0, vt = vt + Math.imul(_r, jr) | 0, $t = $t + Math.imul(_r, Xr) | 0, xt = xt + Math.imul(tr, Yr) | 0, vt = vt + Math.imul(tr, vn) | 0, vt = vt + Math.imul(Dt, Yr) | 0, $t = $t + Math.imul(Dt, vn) | 0, xt = xt + Math.imul(Bt, dn) | 0, vt = vt + Math.imul(Bt, fr) | 0, vt = vt + Math.imul(rr, dn) | 0, $t = $t + Math.imul(rr, fr) | 0;
      var Ca = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Ca >>> 26) | 0, Ca &= 67108863, xt = Math.imul(Gt, Zt), vt = Math.imul(Gt, pr), vt = vt + Math.imul(At, Zt) | 0, $t = Math.imul(At, pr), xt = xt + Math.imul(gn, Tr) | 0, vt = vt + Math.imul(gn, fn) | 0, vt = vt + Math.imul(Kn, Tr) | 0, $t = $t + Math.imul(Kn, fn) | 0, xt = xt + Math.imul(En, tn) | 0, vt = vt + Math.imul(En, In) | 0, vt = vt + Math.imul(Pn, tn) | 0, $t = $t + Math.imul(Pn, In) | 0, xt = xt + Math.imul(xn, cn) | 0, vt = vt + Math.imul(xn, ci) | 0, vt = vt + Math.imul(ni, cn) | 0, $t = $t + Math.imul(ni, ci) | 0, xt = xt + Math.imul(_n, ur) | 0, vt = vt + Math.imul(_n, ir) | 0, vt = vt + Math.imul(Mr, ur) | 0, $t = $t + Math.imul(Mr, ir) | 0, xt = xt + Math.imul(Vr, gr) | 0, vt = vt + Math.imul(Vr, Ar) | 0, vt = vt + Math.imul(Zr, gr) | 0, $t = $t + Math.imul(Zr, Ar) | 0, xt = xt + Math.imul(Qt, jr) | 0, vt = vt + Math.imul(Qt, Xr) | 0, vt = vt + Math.imul(br, jr) | 0, $t = $t + Math.imul(br, Xr) | 0, xt = xt + Math.imul(or, Yr) | 0, vt = vt + Math.imul(or, vn) | 0, vt = vt + Math.imul(_r, Yr) | 0, $t = $t + Math.imul(_r, vn) | 0, xt = xt + Math.imul(tr, dn) | 0, vt = vt + Math.imul(tr, fr) | 0, vt = vt + Math.imul(Dt, dn) | 0, $t = $t + Math.imul(Dt, fr) | 0, xt = xt + Math.imul(Bt, Ir) | 0, vt = vt + Math.imul(Bt, sn) | 0, vt = vt + Math.imul(rr, Ir) | 0, $t = $t + Math.imul(rr, sn) | 0;
      var vi = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, xt = Math.imul(Gt, Tr), vt = Math.imul(Gt, fn), vt = vt + Math.imul(At, Tr) | 0, $t = Math.imul(At, fn), xt = xt + Math.imul(gn, tn) | 0, vt = vt + Math.imul(gn, In) | 0, vt = vt + Math.imul(Kn, tn) | 0, $t = $t + Math.imul(Kn, In) | 0, xt = xt + Math.imul(En, cn) | 0, vt = vt + Math.imul(En, ci) | 0, vt = vt + Math.imul(Pn, cn) | 0, $t = $t + Math.imul(Pn, ci) | 0, xt = xt + Math.imul(xn, ur) | 0, vt = vt + Math.imul(xn, ir) | 0, vt = vt + Math.imul(ni, ur) | 0, $t = $t + Math.imul(ni, ir) | 0, xt = xt + Math.imul(_n, gr) | 0, vt = vt + Math.imul(_n, Ar) | 0, vt = vt + Math.imul(Mr, gr) | 0, $t = $t + Math.imul(Mr, Ar) | 0, xt = xt + Math.imul(Vr, jr) | 0, vt = vt + Math.imul(Vr, Xr) | 0, vt = vt + Math.imul(Zr, jr) | 0, $t = $t + Math.imul(Zr, Xr) | 0, xt = xt + Math.imul(Qt, Yr) | 0, vt = vt + Math.imul(Qt, vn) | 0, vt = vt + Math.imul(br, Yr) | 0, $t = $t + Math.imul(br, vn) | 0, xt = xt + Math.imul(or, dn) | 0, vt = vt + Math.imul(or, fr) | 0, vt = vt + Math.imul(_r, dn) | 0, $t = $t + Math.imul(_r, fr) | 0, xt = xt + Math.imul(tr, Ir) | 0, vt = vt + Math.imul(tr, sn) | 0, vt = vt + Math.imul(Dt, Ir) | 0, $t = $t + Math.imul(Dt, sn) | 0;
      var Wi = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Wi >>> 26) | 0, Wi &= 67108863, xt = Math.imul(Gt, tn), vt = Math.imul(Gt, In), vt = vt + Math.imul(At, tn) | 0, $t = Math.imul(At, In), xt = xt + Math.imul(gn, cn) | 0, vt = vt + Math.imul(gn, ci) | 0, vt = vt + Math.imul(Kn, cn) | 0, $t = $t + Math.imul(Kn, ci) | 0, xt = xt + Math.imul(En, ur) | 0, vt = vt + Math.imul(En, ir) | 0, vt = vt + Math.imul(Pn, ur) | 0, $t = $t + Math.imul(Pn, ir) | 0, xt = xt + Math.imul(xn, gr) | 0, vt = vt + Math.imul(xn, Ar) | 0, vt = vt + Math.imul(ni, gr) | 0, $t = $t + Math.imul(ni, Ar) | 0, xt = xt + Math.imul(_n, jr) | 0, vt = vt + Math.imul(_n, Xr) | 0, vt = vt + Math.imul(Mr, jr) | 0, $t = $t + Math.imul(Mr, Xr) | 0, xt = xt + Math.imul(Vr, Yr) | 0, vt = vt + Math.imul(Vr, vn) | 0, vt = vt + Math.imul(Zr, Yr) | 0, $t = $t + Math.imul(Zr, vn) | 0, xt = xt + Math.imul(Qt, dn) | 0, vt = vt + Math.imul(Qt, fr) | 0, vt = vt + Math.imul(br, dn) | 0, $t = $t + Math.imul(br, fr) | 0, xt = xt + Math.imul(or, Ir) | 0, vt = vt + Math.imul(or, sn) | 0, vt = vt + Math.imul(_r, Ir) | 0, $t = $t + Math.imul(_r, sn) | 0;
      var ra = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (ra >>> 26) | 0, ra &= 67108863, xt = Math.imul(Gt, cn), vt = Math.imul(Gt, ci), vt = vt + Math.imul(At, cn) | 0, $t = Math.imul(At, ci), xt = xt + Math.imul(gn, ur) | 0, vt = vt + Math.imul(gn, ir) | 0, vt = vt + Math.imul(Kn, ur) | 0, $t = $t + Math.imul(Kn, ir) | 0, xt = xt + Math.imul(En, gr) | 0, vt = vt + Math.imul(En, Ar) | 0, vt = vt + Math.imul(Pn, gr) | 0, $t = $t + Math.imul(Pn, Ar) | 0, xt = xt + Math.imul(xn, jr) | 0, vt = vt + Math.imul(xn, Xr) | 0, vt = vt + Math.imul(ni, jr) | 0, $t = $t + Math.imul(ni, Xr) | 0, xt = xt + Math.imul(_n, Yr) | 0, vt = vt + Math.imul(_n, vn) | 0, vt = vt + Math.imul(Mr, Yr) | 0, $t = $t + Math.imul(Mr, vn) | 0, xt = xt + Math.imul(Vr, dn) | 0, vt = vt + Math.imul(Vr, fr) | 0, vt = vt + Math.imul(Zr, dn) | 0, $t = $t + Math.imul(Zr, fr) | 0, xt = xt + Math.imul(Qt, Ir) | 0, vt = vt + Math.imul(Qt, sn) | 0, vt = vt + Math.imul(br, Ir) | 0, $t = $t + Math.imul(br, sn) | 0;
      var ii = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (ii >>> 26) | 0, ii &= 67108863, xt = Math.imul(Gt, ur), vt = Math.imul(Gt, ir), vt = vt + Math.imul(At, ur) | 0, $t = Math.imul(At, ir), xt = xt + Math.imul(gn, gr) | 0, vt = vt + Math.imul(gn, Ar) | 0, vt = vt + Math.imul(Kn, gr) | 0, $t = $t + Math.imul(Kn, Ar) | 0, xt = xt + Math.imul(En, jr) | 0, vt = vt + Math.imul(En, Xr) | 0, vt = vt + Math.imul(Pn, jr) | 0, $t = $t + Math.imul(Pn, Xr) | 0, xt = xt + Math.imul(xn, Yr) | 0, vt = vt + Math.imul(xn, vn) | 0, vt = vt + Math.imul(ni, Yr) | 0, $t = $t + Math.imul(ni, vn) | 0, xt = xt + Math.imul(_n, dn) | 0, vt = vt + Math.imul(_n, fr) | 0, vt = vt + Math.imul(Mr, dn) | 0, $t = $t + Math.imul(Mr, fr) | 0, xt = xt + Math.imul(Vr, Ir) | 0, vt = vt + Math.imul(Vr, sn) | 0, vt = vt + Math.imul(Zr, Ir) | 0, $t = $t + Math.imul(Zr, sn) | 0;
      var ma = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (ma >>> 26) | 0, ma &= 67108863, xt = Math.imul(Gt, gr), vt = Math.imul(Gt, Ar), vt = vt + Math.imul(At, gr) | 0, $t = Math.imul(At, Ar), xt = xt + Math.imul(gn, jr) | 0, vt = vt + Math.imul(gn, Xr) | 0, vt = vt + Math.imul(Kn, jr) | 0, $t = $t + Math.imul(Kn, Xr) | 0, xt = xt + Math.imul(En, Yr) | 0, vt = vt + Math.imul(En, vn) | 0, vt = vt + Math.imul(Pn, Yr) | 0, $t = $t + Math.imul(Pn, vn) | 0, xt = xt + Math.imul(xn, dn) | 0, vt = vt + Math.imul(xn, fr) | 0, vt = vt + Math.imul(ni, dn) | 0, $t = $t + Math.imul(ni, fr) | 0, xt = xt + Math.imul(_n, Ir) | 0, vt = vt + Math.imul(_n, sn) | 0, vt = vt + Math.imul(Mr, Ir) | 0, $t = $t + Math.imul(Mr, sn) | 0;
      var Ga = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Ga >>> 26) | 0, Ga &= 67108863, xt = Math.imul(Gt, jr), vt = Math.imul(Gt, Xr), vt = vt + Math.imul(At, jr) | 0, $t = Math.imul(At, Xr), xt = xt + Math.imul(gn, Yr) | 0, vt = vt + Math.imul(gn, vn) | 0, vt = vt + Math.imul(Kn, Yr) | 0, $t = $t + Math.imul(Kn, vn) | 0, xt = xt + Math.imul(En, dn) | 0, vt = vt + Math.imul(En, fr) | 0, vt = vt + Math.imul(Pn, dn) | 0, $t = $t + Math.imul(Pn, fr) | 0, xt = xt + Math.imul(xn, Ir) | 0, vt = vt + Math.imul(xn, sn) | 0, vt = vt + Math.imul(ni, Ir) | 0, $t = $t + Math.imul(ni, sn) | 0;
      var po = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (po >>> 26) | 0, po &= 67108863, xt = Math.imul(Gt, Yr), vt = Math.imul(Gt, vn), vt = vt + Math.imul(At, Yr) | 0, $t = Math.imul(At, vn), xt = xt + Math.imul(gn, dn) | 0, vt = vt + Math.imul(gn, fr) | 0, vt = vt + Math.imul(Kn, dn) | 0, $t = $t + Math.imul(Kn, fr) | 0, xt = xt + Math.imul(En, Ir) | 0, vt = vt + Math.imul(En, sn) | 0, vt = vt + Math.imul(Pn, Ir) | 0, $t = $t + Math.imul(Pn, sn) | 0;
      var Xa = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, xt = Math.imul(Gt, dn), vt = Math.imul(Gt, fr), vt = vt + Math.imul(At, dn) | 0, $t = Math.imul(At, fr), xt = xt + Math.imul(gn, Ir) | 0, vt = vt + Math.imul(gn, sn) | 0, vt = vt + Math.imul(Kn, Ir) | 0, $t = $t + Math.imul(Kn, sn) | 0;
      var sa = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      St = ($t + (vt >>> 13) | 0) + (sa >>> 26) | 0, sa &= 67108863, xt = Math.imul(Gt, Ir), vt = Math.imul(Gt, sn), vt = vt + Math.imul(At, Ir) | 0, $t = Math.imul(At, sn);
      var Oo = (St + xt | 0) + ((vt & 8191) << 13) | 0;
      return St = ($t + (vt >>> 13) | 0) + (Oo >>> 26) | 0, Oo &= 67108863, gt[0] = Tn, gt[1] = kn, gt[2] = Dn, gt[3] = Jn, gt[4] = Ti, gt[5] = _i, gt[6] = Ri, gt[7] = Qi, gt[8] = Ca, gt[9] = vi, gt[10] = Wi, gt[11] = ra, gt[12] = ii, gt[13] = ma, gt[14] = Ga, gt[15] = po, gt[16] = Xa, gt[17] = sa, gt[18] = Oo, St !== 0 && (gt[19] = St, ot.length++), ot;
    };
    Math.imul || (Mt = Rt);
    function Lt(Ht, ct, dt) {
      dt.negative = ct.negative ^ Ht.negative, dt.length = Ht.length + ct.length;
      for (var ot = 0, ut = 0, mt = 0; mt < dt.length - 1; mt++) {
        var gt = ut;
        ut = 0;
        for (var St = ot & 67108863, xt = Math.min(mt, ct.length - 1), vt = Math.max(0, mt - Ht.length + 1); vt <= xt; vt++) {
          var $t = mt - vt, yt = Ht.words[$t] | 0, Bt = ct.words[vt] | 0, rr = yt * Bt, dr = rr & 67108863;
          gt = gt + (rr / 67108864 | 0) | 0, dr = dr + St | 0, St = dr & 67108863, gt = gt + (dr >>> 26) | 0, ut += gt >>> 26, gt &= 67108863;
        }
        dt.words[mt] = St, ot = gt, gt = ut;
      }
      return ot !== 0 ? dt.words[mt] = ot : dt.length--, dt.strip();
    }
    function zt(Ht, ct, dt) {
      var ot = new Ot();
      return ot.mulp(Ht, ct, dt);
    }
    ce.prototype.mulTo = function(ct, dt) {
      var ot, ut = this.length + ct.length;
      return this.length === 10 && ct.length === 10 ? ot = Mt(this, ct, dt) : ut < 63 ? ot = Rt(this, ct, dt) : ut < 1024 ? ot = Lt(this, ct, dt) : ot = zt(this, ct, dt), ot;
    };
    function Ot(Ht, ct) {
      this.x = Ht, this.y = ct;
    }
    Ot.prototype.makeRBT = function(ct) {
      for (var dt = new Array(ct), ot = ce.prototype._countBits(ct) - 1, ut = 0; ut < ct; ut++)
        dt[ut] = this.revBin(ut, ot, ct);
      return dt;
    }, Ot.prototype.revBin = function(ct, dt, ot) {
      if (ct === 0 || ct === ot - 1) return ct;
      for (var ut = 0, mt = 0; mt < dt; mt++)
        ut |= (ct & 1) << dt - mt - 1, ct >>= 1;
      return ut;
    }, Ot.prototype.permute = function(ct, dt, ot, ut, mt, gt) {
      for (var St = 0; St < gt; St++)
        ut[St] = dt[ct[St]], mt[St] = ot[ct[St]];
    }, Ot.prototype.transform = function(ct, dt, ot, ut, mt, gt) {
      this.permute(gt, ct, dt, ot, ut, mt);
      for (var St = 1; St < mt; St <<= 1)
        for (var xt = St << 1, vt = Math.cos(2 * Math.PI / xt), $t = Math.sin(2 * Math.PI / xt), yt = 0; yt < mt; yt += xt)
          for (var Bt = vt, rr = $t, dr = 0; dr < St; dr++) {
            var tr = ot[yt + dr], Dt = ut[yt + dr], Wt = ot[yt + dr + St], or = ut[yt + dr + St], _r = Bt * Wt - rr * or;
            or = Bt * or + rr * Wt, Wt = _r, ot[yt + dr] = tr + Wt, ut[yt + dr] = Dt + or, ot[yt + dr + St] = tr - Wt, ut[yt + dr + St] = Dt - or, dr !== xt && (_r = vt * Bt - $t * rr, rr = vt * rr + $t * Bt, Bt = _r);
          }
    }, Ot.prototype.guessLen13b = function(ct, dt) {
      var ot = Math.max(dt, ct) | 1, ut = ot & 1, mt = 0;
      for (ot = ot / 2 | 0; ot; ot = ot >>> 1)
        mt++;
      return 1 << mt + 1 + ut;
    }, Ot.prototype.conjugate = function(ct, dt, ot) {
      if (!(ot <= 1))
        for (var ut = 0; ut < ot / 2; ut++) {
          var mt = ct[ut];
          ct[ut] = ct[ot - ut - 1], ct[ot - ut - 1] = mt, mt = dt[ut], dt[ut] = -dt[ot - ut - 1], dt[ot - ut - 1] = -mt;
        }
    }, Ot.prototype.normalize13b = function(ct, dt) {
      for (var ot = 0, ut = 0; ut < dt / 2; ut++) {
        var mt = Math.round(ct[2 * ut + 1] / dt) * 8192 + Math.round(ct[2 * ut] / dt) + ot;
        ct[ut] = mt & 67108863, mt < 67108864 ? ot = 0 : ot = mt / 67108864 | 0;
      }
      return ct;
    }, Ot.prototype.convert13b = function(ct, dt, ot, ut) {
      for (var mt = 0, gt = 0; gt < dt; gt++)
        mt = mt + (ct[gt] | 0), ot[2 * gt] = mt & 8191, mt = mt >>> 13, ot[2 * gt + 1] = mt & 8191, mt = mt >>> 13;
      for (gt = 2 * dt; gt < ut; ++gt)
        ot[gt] = 0;
      ne(mt === 0), ne((mt & -8192) === 0);
    }, Ot.prototype.stub = function(ct) {
      for (var dt = new Array(ct), ot = 0; ot < ct; ot++)
        dt[ot] = 0;
      return dt;
    }, Ot.prototype.mulp = function(ct, dt, ot) {
      var ut = 2 * this.guessLen13b(ct.length, dt.length), mt = this.makeRBT(ut), gt = this.stub(ut), St = new Array(ut), xt = new Array(ut), vt = new Array(ut), $t = new Array(ut), yt = new Array(ut), Bt = new Array(ut), rr = ot.words;
      rr.length = ut, this.convert13b(ct.words, ct.length, St, ut), this.convert13b(dt.words, dt.length, $t, ut), this.transform(St, gt, xt, vt, ut, mt), this.transform($t, gt, yt, Bt, ut, mt);
      for (var dr = 0; dr < ut; dr++) {
        var tr = xt[dr] * yt[dr] - vt[dr] * Bt[dr];
        vt[dr] = xt[dr] * Bt[dr] + vt[dr] * yt[dr], xt[dr] = tr;
      }
      return this.conjugate(xt, vt, ut), this.transform(xt, vt, rr, gt, ut, mt), this.conjugate(rr, gt, ut), this.normalize13b(rr, ut), ot.negative = ct.negative ^ dt.negative, ot.length = ct.length + dt.length, ot.strip();
    }, ce.prototype.mul = function(ct) {
      var dt = new ce(null);
      return dt.words = new Array(this.length + ct.length), this.mulTo(ct, dt);
    }, ce.prototype.mulf = function(ct) {
      var dt = new ce(null);
      return dt.words = new Array(this.length + ct.length), zt(this, ct, dt);
    }, ce.prototype.imul = function(ct) {
      return this.clone().mulTo(ct, this);
    }, ce.prototype.imuln = function(ct) {
      ne(typeof ct == "number"), ne(ct < 67108864);
      for (var dt = 0, ot = 0; ot < this.length; ot++) {
        var ut = (this.words[ot] | 0) * ct, mt = (ut & 67108863) + (dt & 67108863);
        dt >>= 26, dt += ut / 67108864 | 0, dt += mt >>> 26, this.words[ot] = mt & 67108863;
      }
      return dt !== 0 && (this.words[ot] = dt, this.length++), this;
    }, ce.prototype.muln = function(ct) {
      return this.clone().imuln(ct);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(ct) {
      var dt = wt(ct);
      if (dt.length === 0) return new ce(1);
      for (var ot = this, ut = 0; ut < dt.length && dt[ut] === 0; ut++, ot = ot.sqr())
        ;
      if (++ut < dt.length)
        for (var mt = ot.sqr(); ut < dt.length; ut++, mt = mt.sqr())
          dt[ut] !== 0 && (ot = ot.mul(mt));
      return ot;
    }, ce.prototype.iushln = function(ct) {
      ne(typeof ct == "number" && ct >= 0);
      var dt = ct % 26, ot = (ct - dt) / 26, ut = 67108863 >>> 26 - dt << 26 - dt, mt;
      if (dt !== 0) {
        var gt = 0;
        for (mt = 0; mt < this.length; mt++) {
          var St = this.words[mt] & ut, xt = (this.words[mt] | 0) - St << dt;
          this.words[mt] = xt | gt, gt = St >>> 26 - dt;
        }
        gt && (this.words[mt] = gt, this.length++);
      }
      if (ot !== 0) {
        for (mt = this.length - 1; mt >= 0; mt--)
          this.words[mt + ot] = this.words[mt];
        for (mt = 0; mt < ot; mt++)
          this.words[mt] = 0;
        this.length += ot;
      }
      return this.strip();
    }, ce.prototype.ishln = function(ct) {
      return ne(this.negative === 0), this.iushln(ct);
    }, ce.prototype.iushrn = function(ct, dt, ot) {
      ne(typeof ct == "number" && ct >= 0);
      var ut;
      dt ? ut = (dt - dt % 26) / 26 : ut = 0;
      var mt = ct % 26, gt = Math.min((ct - mt) / 26, this.length), St = 67108863 ^ 67108863 >>> mt << mt, xt = ot;
      if (ut -= gt, ut = Math.max(0, ut), xt) {
        for (var vt = 0; vt < gt; vt++)
          xt.words[vt] = this.words[vt];
        xt.length = gt;
      }
      if (gt !== 0) if (this.length > gt)
        for (this.length -= gt, vt = 0; vt < this.length; vt++)
          this.words[vt] = this.words[vt + gt];
      else
        this.words[0] = 0, this.length = 1;
      var $t = 0;
      for (vt = this.length - 1; vt >= 0 && ($t !== 0 || vt >= ut); vt--) {
        var yt = this.words[vt] | 0;
        this.words[vt] = $t << 26 - mt | yt >>> mt, $t = yt & St;
      }
      return xt && $t !== 0 && (xt.words[xt.length++] = $t), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, ce.prototype.ishrn = function(ct, dt, ot) {
      return ne(this.negative === 0), this.iushrn(ct, dt, ot);
    }, ce.prototype.shln = function(ct) {
      return this.clone().ishln(ct);
    }, ce.prototype.ushln = function(ct) {
      return this.clone().iushln(ct);
    }, ce.prototype.shrn = function(ct) {
      return this.clone().ishrn(ct);
    }, ce.prototype.ushrn = function(ct) {
      return this.clone().iushrn(ct);
    }, ce.prototype.testn = function(ct) {
      ne(typeof ct == "number" && ct >= 0);
      var dt = ct % 26, ot = (ct - dt) / 26, ut = 1 << dt;
      if (this.length <= ot) return !1;
      var mt = this.words[ot];
      return !!(mt & ut);
    }, ce.prototype.imaskn = function(ct) {
      ne(typeof ct == "number" && ct >= 0);
      var dt = ct % 26, ot = (ct - dt) / 26;
      if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ot)
        return this;
      if (dt !== 0 && ot++, this.length = Math.min(ot, this.length), dt !== 0) {
        var ut = 67108863 ^ 67108863 >>> dt << dt;
        this.words[this.length - 1] &= ut;
      }
      return this.strip();
    }, ce.prototype.maskn = function(ct) {
      return this.clone().imaskn(ct);
    }, ce.prototype.iaddn = function(ct) {
      return ne(typeof ct == "number"), ne(ct < 67108864), ct < 0 ? this.isubn(-ct) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < ct ? (this.words[0] = ct - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ct), this.negative = 1, this) : this._iaddn(ct);
    }, ce.prototype._iaddn = function(ct) {
      this.words[0] += ct;
      for (var dt = 0; dt < this.length && this.words[dt] >= 67108864; dt++)
        this.words[dt] -= 67108864, dt === this.length - 1 ? this.words[dt + 1] = 1 : this.words[dt + 1]++;
      return this.length = Math.max(this.length, dt + 1), this;
    }, ce.prototype.isubn = function(ct) {
      if (ne(typeof ct == "number"), ne(ct < 67108864), ct < 0) return this.iaddn(-ct);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ct), this.negative = 1, this;
      if (this.words[0] -= ct, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var dt = 0; dt < this.length && this.words[dt] < 0; dt++)
          this.words[dt] += 67108864, this.words[dt + 1] -= 1;
      return this.strip();
    }, ce.prototype.addn = function(ct) {
      return this.clone().iaddn(ct);
    }, ce.prototype.subn = function(ct) {
      return this.clone().isubn(ct);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(ct, dt, ot) {
      var ut = ct.length + ot, mt;
      this._expand(ut);
      var gt, St = 0;
      for (mt = 0; mt < ct.length; mt++) {
        gt = (this.words[mt + ot] | 0) + St;
        var xt = (ct.words[mt] | 0) * dt;
        gt -= xt & 67108863, St = (gt >> 26) - (xt / 67108864 | 0), this.words[mt + ot] = gt & 67108863;
      }
      for (; mt < this.length - ot; mt++)
        gt = (this.words[mt + ot] | 0) + St, St = gt >> 26, this.words[mt + ot] = gt & 67108863;
      if (St === 0) return this.strip();
      for (ne(St === -1), St = 0, mt = 0; mt < this.length; mt++)
        gt = -(this.words[mt] | 0) + St, St = gt >> 26, this.words[mt] = gt & 67108863;
      return this.negative = 1, this.strip();
    }, ce.prototype._wordDiv = function(ct, dt) {
      var ot = this.length - ct.length, ut = this.clone(), mt = ct, gt = mt.words[mt.length - 1] | 0, St = this._countBits(gt);
      ot = 26 - St, ot !== 0 && (mt = mt.ushln(ot), ut.iushln(ot), gt = mt.words[mt.length - 1] | 0);
      var xt = ut.length - mt.length, vt;
      if (dt !== "mod") {
        vt = new ce(null), vt.length = xt + 1, vt.words = new Array(vt.length);
        for (var $t = 0; $t < vt.length; $t++)
          vt.words[$t] = 0;
      }
      var yt = ut.clone()._ishlnsubmul(mt, 1, xt);
      yt.negative === 0 && (ut = yt, vt && (vt.words[xt] = 1));
      for (var Bt = xt - 1; Bt >= 0; Bt--) {
        var rr = (ut.words[mt.length + Bt] | 0) * 67108864 + (ut.words[mt.length + Bt - 1] | 0);
        for (rr = Math.min(rr / gt | 0, 67108863), ut._ishlnsubmul(mt, rr, Bt); ut.negative !== 0; )
          rr--, ut.negative = 0, ut._ishlnsubmul(mt, 1, Bt), ut.isZero() || (ut.negative ^= 1);
        vt && (vt.words[Bt] = rr);
      }
      return vt && vt.strip(), ut.strip(), dt !== "div" && ot !== 0 && ut.iushrn(ot), {
        div: vt || null,
        mod: ut
      };
    }, ce.prototype.divmod = function(ct, dt, ot) {
      if (ne(!ct.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var ut, mt, gt;
      return this.negative !== 0 && ct.negative === 0 ? (gt = this.neg().divmod(ct, dt), dt !== "mod" && (ut = gt.div.neg()), dt !== "div" && (mt = gt.mod.neg(), ot && mt.negative !== 0 && mt.iadd(ct)), {
        div: ut,
        mod: mt
      }) : this.negative === 0 && ct.negative !== 0 ? (gt = this.divmod(ct.neg(), dt), dt !== "mod" && (ut = gt.div.neg()), {
        div: ut,
        mod: gt.mod
      }) : this.negative & ct.negative ? (gt = this.neg().divmod(ct.neg(), dt), dt !== "div" && (mt = gt.mod.neg(), ot && mt.negative !== 0 && mt.isub(ct)), {
        div: gt.div,
        mod: mt
      }) : ct.length > this.length || this.cmp(ct) < 0 ? {
        div: new ce(0),
        mod: this
      } : ct.length === 1 ? dt === "div" ? {
        div: this.divn(ct.words[0]),
        mod: null
      } : dt === "mod" ? {
        div: null,
        mod: new ce(this.modn(ct.words[0]))
      } : {
        div: this.divn(ct.words[0]),
        mod: new ce(this.modn(ct.words[0]))
      } : this._wordDiv(ct, dt);
    }, ce.prototype.div = function(ct) {
      return this.divmod(ct, "div", !1).div;
    }, ce.prototype.mod = function(ct) {
      return this.divmod(ct, "mod", !1).mod;
    }, ce.prototype.umod = function(ct) {
      return this.divmod(ct, "mod", !0).mod;
    }, ce.prototype.divRound = function(ct) {
      var dt = this.divmod(ct);
      if (dt.mod.isZero()) return dt.div;
      var ot = dt.div.negative !== 0 ? dt.mod.isub(ct) : dt.mod, ut = ct.ushrn(1), mt = ct.andln(1), gt = ot.cmp(ut);
      return gt < 0 || mt === 1 && gt === 0 ? dt.div : dt.div.negative !== 0 ? dt.div.isubn(1) : dt.div.iaddn(1);
    }, ce.prototype.modn = function(ct) {
      ne(ct <= 67108863);
      for (var dt = (1 << 26) % ct, ot = 0, ut = this.length - 1; ut >= 0; ut--)
        ot = (dt * ot + (this.words[ut] | 0)) % ct;
      return ot;
    }, ce.prototype.idivn = function(ct) {
      ne(ct <= 67108863);
      for (var dt = 0, ot = this.length - 1; ot >= 0; ot--) {
        var ut = (this.words[ot] | 0) + dt * 67108864;
        this.words[ot] = ut / ct | 0, dt = ut % ct;
      }
      return this.strip();
    }, ce.prototype.divn = function(ct) {
      return this.clone().idivn(ct);
    }, ce.prototype.egcd = function(ct) {
      ne(ct.negative === 0), ne(!ct.isZero());
      var dt = this, ot = ct.clone();
      dt.negative !== 0 ? dt = dt.umod(ct) : dt = dt.clone();
      for (var ut = new ce(1), mt = new ce(0), gt = new ce(0), St = new ce(1), xt = 0; dt.isEven() && ot.isEven(); )
        dt.iushrn(1), ot.iushrn(1), ++xt;
      for (var vt = ot.clone(), $t = dt.clone(); !dt.isZero(); ) {
        for (var yt = 0, Bt = 1; !(dt.words[0] & Bt) && yt < 26; ++yt, Bt <<= 1) ;
        if (yt > 0)
          for (dt.iushrn(yt); yt-- > 0; )
            (ut.isOdd() || mt.isOdd()) && (ut.iadd(vt), mt.isub($t)), ut.iushrn(1), mt.iushrn(1);
        for (var rr = 0, dr = 1; !(ot.words[0] & dr) && rr < 26; ++rr, dr <<= 1) ;
        if (rr > 0)
          for (ot.iushrn(rr); rr-- > 0; )
            (gt.isOdd() || St.isOdd()) && (gt.iadd(vt), St.isub($t)), gt.iushrn(1), St.iushrn(1);
        dt.cmp(ot) >= 0 ? (dt.isub(ot), ut.isub(gt), mt.isub(St)) : (ot.isub(dt), gt.isub(ut), St.isub(mt));
      }
      return {
        a: gt,
        b: St,
        gcd: ot.iushln(xt)
      };
    }, ce.prototype._invmp = function(ct) {
      ne(ct.negative === 0), ne(!ct.isZero());
      var dt = this, ot = ct.clone();
      dt.negative !== 0 ? dt = dt.umod(ct) : dt = dt.clone();
      for (var ut = new ce(1), mt = new ce(0), gt = ot.clone(); dt.cmpn(1) > 0 && ot.cmpn(1) > 0; ) {
        for (var St = 0, xt = 1; !(dt.words[0] & xt) && St < 26; ++St, xt <<= 1) ;
        if (St > 0)
          for (dt.iushrn(St); St-- > 0; )
            ut.isOdd() && ut.iadd(gt), ut.iushrn(1);
        for (var vt = 0, $t = 1; !(ot.words[0] & $t) && vt < 26; ++vt, $t <<= 1) ;
        if (vt > 0)
          for (ot.iushrn(vt); vt-- > 0; )
            mt.isOdd() && mt.iadd(gt), mt.iushrn(1);
        dt.cmp(ot) >= 0 ? (dt.isub(ot), ut.isub(mt)) : (ot.isub(dt), mt.isub(ut));
      }
      var yt;
      return dt.cmpn(1) === 0 ? yt = ut : yt = mt, yt.cmpn(0) < 0 && yt.iadd(ct), yt;
    }, ce.prototype.gcd = function(ct) {
      if (this.isZero()) return ct.abs();
      if (ct.isZero()) return this.abs();
      var dt = this.clone(), ot = ct.clone();
      dt.negative = 0, ot.negative = 0;
      for (var ut = 0; dt.isEven() && ot.isEven(); ut++)
        dt.iushrn(1), ot.iushrn(1);
      do {
        for (; dt.isEven(); )
          dt.iushrn(1);
        for (; ot.isEven(); )
          ot.iushrn(1);
        var mt = dt.cmp(ot);
        if (mt < 0) {
          var gt = dt;
          dt = ot, ot = gt;
        } else if (mt === 0 || ot.cmpn(1) === 0)
          break;
        dt.isub(ot);
      } while (!0);
      return ot.iushln(ut);
    }, ce.prototype.invm = function(ct) {
      return this.egcd(ct).a.umod(ct);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(ct) {
      return this.words[0] & ct;
    }, ce.prototype.bincn = function(ct) {
      ne(typeof ct == "number");
      var dt = ct % 26, ot = (ct - dt) / 26, ut = 1 << dt;
      if (this.length <= ot)
        return this._expand(ot + 1), this.words[ot] |= ut, this;
      for (var mt = ut, gt = ot; mt !== 0 && gt < this.length; gt++) {
        var St = this.words[gt] | 0;
        St += mt, mt = St >>> 26, St &= 67108863, this.words[gt] = St;
      }
      return mt !== 0 && (this.words[gt] = mt, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(ct) {
      var dt = ct < 0;
      if (this.negative !== 0 && !dt) return -1;
      if (this.negative === 0 && dt) return 1;
      this.strip();
      var ot;
      if (this.length > 1)
        ot = 1;
      else {
        dt && (ct = -ct), ne(ct <= 67108863, "Number is too big");
        var ut = this.words[0] | 0;
        ot = ut === ct ? 0 : ut < ct ? -1 : 1;
      }
      return this.negative !== 0 ? -ot | 0 : ot;
    }, ce.prototype.cmp = function(ct) {
      if (this.negative !== 0 && ct.negative === 0) return -1;
      if (this.negative === 0 && ct.negative !== 0) return 1;
      var dt = this.ucmp(ct);
      return this.negative !== 0 ? -dt | 0 : dt;
    }, ce.prototype.ucmp = function(ct) {
      if (this.length > ct.length) return 1;
      if (this.length < ct.length) return -1;
      for (var dt = 0, ot = this.length - 1; ot >= 0; ot--) {
        var ut = this.words[ot] | 0, mt = ct.words[ot] | 0;
        if (ut !== mt) {
          ut < mt ? dt = -1 : ut > mt && (dt = 1);
          break;
        }
      }
      return dt;
    }, ce.prototype.gtn = function(ct) {
      return this.cmpn(ct) === 1;
    }, ce.prototype.gt = function(ct) {
      return this.cmp(ct) === 1;
    }, ce.prototype.gten = function(ct) {
      return this.cmpn(ct) >= 0;
    }, ce.prototype.gte = function(ct) {
      return this.cmp(ct) >= 0;
    }, ce.prototype.ltn = function(ct) {
      return this.cmpn(ct) === -1;
    }, ce.prototype.lt = function(ct) {
      return this.cmp(ct) === -1;
    }, ce.prototype.lten = function(ct) {
      return this.cmpn(ct) <= 0;
    }, ce.prototype.lte = function(ct) {
      return this.cmp(ct) <= 0;
    }, ce.prototype.eqn = function(ct) {
      return this.cmpn(ct) === 0;
    }, ce.prototype.eq = function(ct) {
      return this.cmp(ct) === 0;
    }, ce.red = function(ct) {
      return new Ut(ct);
    }, ce.prototype.toRed = function(ct) {
      return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), ct.convertTo(this)._forceRed(ct);
    }, ce.prototype.fromRed = function() {
      return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(ct) {
      return this.red = ct, this;
    }, ce.prototype.forceRed = function(ct) {
      return ne(!this.red, "Already a number in reduction context"), this._forceRed(ct);
    }, ce.prototype.redAdd = function(ct) {
      return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, ct);
    }, ce.prototype.redIAdd = function(ct) {
      return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ct);
    }, ce.prototype.redSub = function(ct) {
      return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, ct);
    }, ce.prototype.redISub = function(ct) {
      return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, ct);
    }, ce.prototype.redShl = function(ct) {
      return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, ct);
    }, ce.prototype.redMul = function(ct) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ct), this.red.mul(this, ct);
    }, ce.prototype.redIMul = function(ct) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ct), this.red.imul(this, ct);
    }, ce.prototype.redSqr = function() {
      return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(ct) {
      return ne(this.red && !ct.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ct);
    };
    var It = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ft(Ht, ct) {
      this.name = Ht, this.p = new ce(ct, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ft.prototype._tmp = function() {
      var ct = new ce(null);
      return ct.words = new Array(Math.ceil(this.n / 13)), ct;
    }, Ft.prototype.ireduce = function(ct) {
      var dt = ct, ot;
      do
        this.split(dt, this.tmp), dt = this.imulK(dt), dt = dt.iadd(this.tmp), ot = dt.bitLength();
      while (ot > this.n);
      var ut = ot < this.n ? -1 : dt.ucmp(this.p);
      return ut === 0 ? (dt.words[0] = 0, dt.length = 1) : ut > 0 ? dt.isub(this.p) : dt.strip !== void 0 ? dt.strip() : dt._strip(), dt;
    }, Ft.prototype.split = function(ct, dt) {
      ct.iushrn(this.n, 0, dt);
    }, Ft.prototype.imulK = function(ct) {
      return ct.imul(this.k);
    };
    function Jt() {
      Ft.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    oe(Jt, Ft), Jt.prototype.split = function(ct, dt) {
      for (var ot = 4194303, ut = Math.min(ct.length, 9), mt = 0; mt < ut; mt++)
        dt.words[mt] = ct.words[mt];
      if (dt.length = ut, ct.length <= 9) {
        ct.words[0] = 0, ct.length = 1;
        return;
      }
      var gt = ct.words[9];
      for (dt.words[dt.length++] = gt & ot, mt = 10; mt < ct.length; mt++) {
        var St = ct.words[mt] | 0;
        ct.words[mt - 10] = (St & ot) << 4 | gt >>> 22, gt = St;
      }
      gt >>>= 22, ct.words[mt - 10] = gt, gt === 0 && ct.length > 10 ? ct.length -= 10 : ct.length -= 9;
    }, Jt.prototype.imulK = function(ct) {
      ct.words[ct.length] = 0, ct.words[ct.length + 1] = 0, ct.length += 2;
      for (var dt = 0, ot = 0; ot < ct.length; ot++) {
        var ut = ct.words[ot] | 0;
        dt += ut * 977, ct.words[ot] = dt & 67108863, dt = ut * 64 + (dt / 67108864 | 0);
      }
      return ct.words[ct.length - 1] === 0 && (ct.length--, ct.words[ct.length - 1] === 0 && ct.length--), ct;
    };
    function Vt() {
      Ft.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    oe(Vt, Ft);
    function yr() {
      Ft.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    oe(yr, Ft);
    function jt() {
      Ft.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    oe(jt, Ft), jt.prototype.imulK = function(ct) {
      for (var dt = 0, ot = 0; ot < ct.length; ot++) {
        var ut = (ct.words[ot] | 0) * 19 + dt, mt = ut & 67108863;
        ut >>>= 26, ct.words[ot] = mt, dt = ut;
      }
      return dt !== 0 && (ct.words[ct.length++] = dt), ct;
    }, ce._prime = function(ct) {
      if (It[ct]) return It[ct];
      var dt;
      if (ct === "k256")
        dt = new Jt();
      else if (ct === "p224")
        dt = new Vt();
      else if (ct === "p192")
        dt = new yr();
      else if (ct === "p25519")
        dt = new jt();
      else
        throw new Error("Unknown prime " + ct);
      return It[ct] = dt, dt;
    };
    function Ut(Ht) {
      if (typeof Ht == "string") {
        var ct = ce._prime(Ht);
        this.m = ct.p, this.prime = ct;
      } else
        ne(Ht.gtn(1), "modulus must be greater than 1"), this.m = Ht, this.prime = null;
    }
    Ut.prototype._verify1 = function(ct) {
      ne(ct.negative === 0, "red works only with positives"), ne(ct.red, "red works only with red numbers");
    }, Ut.prototype._verify2 = function(ct, dt) {
      ne((ct.negative | dt.negative) === 0, "red works only with positives"), ne(
        ct.red && ct.red === dt.red,
        "red works only with red numbers"
      );
    }, Ut.prototype.imod = function(ct) {
      return this.prime ? this.prime.ireduce(ct)._forceRed(this) : ct.umod(this.m)._forceRed(this);
    }, Ut.prototype.neg = function(ct) {
      return ct.isZero() ? ct.clone() : this.m.sub(ct)._forceRed(this);
    }, Ut.prototype.add = function(ct, dt) {
      this._verify2(ct, dt);
      var ot = ct.add(dt);
      return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot._forceRed(this);
    }, Ut.prototype.iadd = function(ct, dt) {
      this._verify2(ct, dt);
      var ot = ct.iadd(dt);
      return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot;
    }, Ut.prototype.sub = function(ct, dt) {
      this._verify2(ct, dt);
      var ot = ct.sub(dt);
      return ot.cmpn(0) < 0 && ot.iadd(this.m), ot._forceRed(this);
    }, Ut.prototype.isub = function(ct, dt) {
      this._verify2(ct, dt);
      var ot = ct.isub(dt);
      return ot.cmpn(0) < 0 && ot.iadd(this.m), ot;
    }, Ut.prototype.shl = function(ct, dt) {
      return this._verify1(ct), this.imod(ct.ushln(dt));
    }, Ut.prototype.imul = function(ct, dt) {
      return this._verify2(ct, dt), this.imod(ct.imul(dt));
    }, Ut.prototype.mul = function(ct, dt) {
      return this._verify2(ct, dt), this.imod(ct.mul(dt));
    }, Ut.prototype.isqr = function(ct) {
      return this.imul(ct, ct.clone());
    }, Ut.prototype.sqr = function(ct) {
      return this.mul(ct, ct);
    }, Ut.prototype.sqrt = function(ct) {
      if (ct.isZero()) return ct.clone();
      var dt = this.m.andln(3);
      if (ne(dt % 2 === 1), dt === 3) {
        var ot = this.m.add(new ce(1)).iushrn(2);
        return this.pow(ct, ot);
      }
      for (var ut = this.m.subn(1), mt = 0; !ut.isZero() && ut.andln(1) === 0; )
        mt++, ut.iushrn(1);
      ne(!ut.isZero());
      var gt = new ce(1).toRed(this), St = gt.redNeg(), xt = this.m.subn(1).iushrn(1), vt = this.m.bitLength();
      for (vt = new ce(2 * vt * vt).toRed(this); this.pow(vt, xt).cmp(St) !== 0; )
        vt.redIAdd(St);
      for (var $t = this.pow(vt, ut), yt = this.pow(ct, ut.addn(1).iushrn(1)), Bt = this.pow(ct, ut), rr = mt; Bt.cmp(gt) !== 0; ) {
        for (var dr = Bt, tr = 0; dr.cmp(gt) !== 0; tr++)
          dr = dr.redSqr();
        ne(tr < rr);
        var Dt = this.pow($t, new ce(1).iushln(rr - tr - 1));
        yt = yt.redMul(Dt), $t = Dt.redSqr(), Bt = Bt.redMul($t), rr = tr;
      }
      return yt;
    }, Ut.prototype.invm = function(ct) {
      var dt = ct._invmp(this.m);
      return dt.negative !== 0 ? (dt.negative = 0, this.imod(dt).redNeg()) : this.imod(dt);
    }, Ut.prototype.pow = function(ct, dt) {
      if (dt.isZero()) return new ce(1).toRed(this);
      if (dt.cmpn(1) === 0) return ct.clone();
      var ot = 4, ut = new Array(1 << ot);
      ut[0] = new ce(1).toRed(this), ut[1] = ct;
      for (var mt = 2; mt < ut.length; mt++)
        ut[mt] = this.mul(ut[mt - 1], ct);
      var gt = ut[0], St = 0, xt = 0, vt = dt.bitLength() % 26;
      for (vt === 0 && (vt = 26), mt = dt.length - 1; mt >= 0; mt--) {
        for (var $t = dt.words[mt], yt = vt - 1; yt >= 0; yt--) {
          var Bt = $t >> yt & 1;
          if (gt !== ut[0] && (gt = this.sqr(gt)), Bt === 0 && St === 0) {
            xt = 0;
            continue;
          }
          St <<= 1, St |= Bt, xt++, !(xt !== ot && (mt !== 0 || yt !== 0)) && (gt = this.mul(gt, ut[St]), xt = 0, St = 0);
        }
        vt = 26;
      }
      return gt;
    }, Ut.prototype.convertTo = function(ct) {
      var dt = ct.umod(this.m);
      return dt === ct ? dt.clone() : dt;
    }, Ut.prototype.convertFrom = function(ct) {
      var dt = ct.clone();
      return dt.red = null, dt;
    }, ce.mont = function(ct) {
      return new er(ct);
    };
    function er(Ht) {
      Ut.call(this, Ht), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    oe(er, Ut), er.prototype.convertTo = function(ct) {
      return this.imod(ct.ushln(this.shift));
    }, er.prototype.convertFrom = function(ct) {
      var dt = this.imod(ct.mul(this.rinv));
      return dt.red = null, dt;
    }, er.prototype.imul = function(ct, dt) {
      if (ct.isZero() || dt.isZero())
        return ct.words[0] = 0, ct.length = 1, ct;
      var ot = ct.imul(dt), ut = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), mt = ot.isub(ut).iushrn(this.shift), gt = mt;
      return mt.cmp(this.m) >= 0 ? gt = mt.isub(this.m) : mt.cmpn(0) < 0 && (gt = mt.iadd(this.m)), gt._forceRed(this);
    }, er.prototype.mul = function(ct, dt) {
      if (ct.isZero() || dt.isZero()) return new ce(0)._forceRed(this);
      var ot = ct.mul(dt), ut = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), mt = ot.isub(ut).iushrn(this.shift), gt = mt;
      return mt.cmp(this.m) >= 0 ? gt = mt.isub(this.m) : mt.cmpn(0) < 0 && (gt = mt.iadd(this.m)), gt._forceRed(this);
    }, er.prototype.invm = function(ct) {
      var dt = this.imod(ct._invmp(this.m).mul(this.r2));
      return dt._forceRed(this);
    };
  })(B, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(oe) {
    return B || (B = new L(null)), B.generate(oe);
  };
  function L(ne) {
    this.rand = ne;
  }
  if (brorand.exports.Rand = L, L.prototype.generate = function(oe) {
    return this._rand(oe);
  }, L.prototype._rand = function(oe) {
    if (this.rand.getBytes)
      return this.rand.getBytes(oe);
    for (var ce = new Uint8Array(oe), Ce = 0; Ce < ce.length; Ce++)
      ce[Ce] = this.rand.getByte();
    return ce;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? L.prototype._rand = function(oe) {
      var ce = new Uint8Array(oe);
      return self.crypto.getRandomValues(ce), ce;
    } : self.msCrypto && self.msCrypto.getRandomValues ? L.prototype._rand = function(oe) {
      var ce = new Uint8Array(oe);
      return self.msCrypto.getRandomValues(ce), ce;
    } : typeof window == "object" && (L.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var J = requireCryptoBrowserify();
      if (typeof J.randomBytes != "function")
        throw new Error("Not supported");
      L.prototype._rand = function(oe) {
        return J.randomBytes(oe);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = bnExports$1, L = requireBrorand();
  function J(ne) {
    this.rand = ne || new L.Rand();
  }
  return mr = J, J.create = function(oe) {
    return new J(oe);
  }, J.prototype._randbelow = function(oe) {
    var ce = oe.bitLength(), Ce = Math.ceil(ce / 8);
    do
      var rt = new B(this.rand.generate(Ce));
    while (rt.cmp(oe) >= 0);
    return rt;
  }, J.prototype._randrange = function(oe, ce) {
    var Ce = ce.sub(oe);
    return oe.add(this._randbelow(Ce));
  }, J.prototype.test = function(oe, ce, Ce) {
    var rt = oe.bitLength(), at = B.mont(oe), ht = new B(1).toRed(at);
    ce || (ce = Math.max(1, rt / 48 | 0));
    for (var it = oe.subn(1), lt = 0; !it.testn(lt); lt++)
      ;
    for (var Et = oe.shrn(lt), wt = it.toRed(at), Rt = !0; ce > 0; ce--) {
      var Mt = this._randrange(new B(2), it);
      Ce && Ce(Mt);
      var Lt = Mt.toRed(at).redPow(Et);
      if (!(Lt.cmp(ht) === 0 || Lt.cmp(wt) === 0)) {
        for (var zt = 1; zt < lt; zt++) {
          if (Lt = Lt.redSqr(), Lt.cmp(ht) === 0)
            return !1;
          if (Lt.cmp(wt) === 0)
            break;
        }
        if (zt === lt)
          return !1;
      }
    }
    return Rt;
  }, J.prototype.getDivisor = function(oe, ce) {
    var Ce = oe.bitLength(), rt = B.mont(oe), at = new B(1).toRed(rt);
    ce || (ce = Math.max(1, Ce / 48 | 0));
    for (var ht = oe.subn(1), it = 0; !ht.testn(it); it++)
      ;
    for (var lt = oe.shrn(it), Et = ht.toRed(rt); ce > 0; ce--) {
      var wt = this._randrange(new B(2), ht), Rt = oe.gcd(wt);
      if (Rt.cmpn(1) !== 0)
        return Rt;
      var Mt = wt.toRed(rt).redPow(lt);
      if (!(Mt.cmp(at) === 0 || Mt.cmp(Et) === 0)) {
        for (var Lt = 1; Lt < it; Lt++) {
          if (Mt = Mt.redSqr(), Mt.cmp(at) === 0)
            return Mt.fromRed().subn(1).gcd(oe);
          if (Mt.cmp(Et) === 0)
            break;
        }
        if (Lt === it)
          return Mt = Mt.redSqr(), Mt.fromRed().subn(1).gcd(oe);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = browserExports;
  generatePrime = Lt, Lt.simpleSieve = Rt, Lt.fermatTest = Mt;
  var L = bnExports$1, J = new L(24), ne = requireMr(), oe = new ne(), ce = new L(1), Ce = new L(2), rt = new L(5);
  new L(16), new L(8);
  var at = new L(10), ht = new L(3);
  new L(7);
  var it = new L(11), lt = new L(4);
  new L(12);
  var Et = null;
  function wt() {
    if (Et !== null)
      return Et;
    var zt = 1048576, Ot = [];
    Ot[0] = 2;
    for (var It = 1, Ft = 3; Ft < zt; Ft += 2) {
      for (var Jt = Math.ceil(Math.sqrt(Ft)), Vt = 0; Vt < It && Ot[Vt] <= Jt && Ft % Ot[Vt] !== 0; Vt++)
        ;
      It !== Vt && Ot[Vt] <= Jt || (Ot[It++] = Ft);
    }
    return Et = Ot, Ot;
  }
  function Rt(zt) {
    for (var Ot = wt(), It = 0; It < Ot.length; It++)
      if (zt.modn(Ot[It]) === 0)
        return zt.cmpn(Ot[It]) === 0;
    return !0;
  }
  function Mt(zt) {
    var Ot = L.mont(zt);
    return Ce.toRed(Ot).redPow(zt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Lt(zt, Ot) {
    if (zt < 16)
      return Ot === 2 || Ot === 5 ? new L([140, 123]) : new L([140, 39]);
    Ot = new L(Ot);
    for (var It, Ft; ; ) {
      for (It = new L(B(Math.ceil(zt / 8))); It.bitLength() > zt; )
        It.ishrn(1);
      if (It.isEven() && It.iadd(ce), It.testn(1) || It.iadd(Ce), Ot.cmp(Ce)) {
        if (!Ot.cmp(rt))
          for (; It.mod(at).cmp(ht); )
            It.iadd(lt);
      } else for (; It.mod(J).cmp(it); )
        It.iadd(lt);
      if (Ft = It.shrn(1), Rt(Ft) && Rt(It) && Mt(Ft) && Mt(It) && oe.test(Ft) && oe.test(It))
        return It;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = bnExports$1, L = requireMr(), J = new L(), ne = new B(24), oe = new B(11), ce = new B(10), Ce = new B(3), rt = new B(7), at = requireGeneratePrime(), ht = browserExports;
  dh = Rt;
  function it(Lt, zt) {
    return zt = zt || "utf8", Buffer$D.isBuffer(Lt) || (Lt = new Buffer$D(Lt, zt)), this._pub = new B(Lt), this;
  }
  function lt(Lt, zt) {
    return zt = zt || "utf8", Buffer$D.isBuffer(Lt) || (Lt = new Buffer$D(Lt, zt)), this._priv = new B(Lt), this;
  }
  var Et = {};
  function wt(Lt, zt) {
    var Ot = zt.toString("hex"), It = [Ot, Lt.toString(16)].join("_");
    if (It in Et)
      return Et[It];
    var Ft = 0;
    if (Lt.isEven() || !at.simpleSieve || !at.fermatTest(Lt) || !J.test(Lt))
      return Ft += 1, Ot === "02" || Ot === "05" ? Ft += 8 : Ft += 4, Et[It] = Ft, Ft;
    J.test(Lt.shrn(1)) || (Ft += 2);
    var Jt;
    switch (Ot) {
      case "02":
        Lt.mod(ne).cmp(oe) && (Ft += 8);
        break;
      case "05":
        Jt = Lt.mod(ce), Jt.cmp(Ce) && Jt.cmp(rt) && (Ft += 8);
        break;
      default:
        Ft += 4;
    }
    return Et[It] = Ft, Ft;
  }
  function Rt(Lt, zt, Ot) {
    this.setGenerator(zt), this.__prime = new B(Lt), this._prime = B.mont(this.__prime), this._primeLen = Lt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Ot ? (this.setPublicKey = it, this.setPrivateKey = lt) : this._primeCode = 8;
  }
  Object.defineProperty(Rt.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = wt(this.__prime, this.__gen)), this._primeCode;
    }
  }), Rt.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(ht(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Rt.prototype.computeSecret = function(Lt) {
    Lt = new B(Lt), Lt = Lt.toRed(this._prime);
    var zt = Lt.redPow(this._priv).fromRed(), Ot = new Buffer$D(zt.toArray()), It = this.getPrime();
    if (Ot.length < It.length) {
      var Ft = new Buffer$D(It.length - Ot.length);
      Ft.fill(0), Ot = Buffer$D.concat([Ft, Ot]);
    }
    return Ot;
  }, Rt.prototype.getPublicKey = function(zt) {
    return Mt(this._pub, zt);
  }, Rt.prototype.getPrivateKey = function(zt) {
    return Mt(this._priv, zt);
  }, Rt.prototype.getPrime = function(Lt) {
    return Mt(this.__prime, Lt);
  }, Rt.prototype.getGenerator = function(Lt) {
    return Mt(this._gen, Lt);
  }, Rt.prototype.setGenerator = function(Lt, zt) {
    return zt = zt || "utf8", Buffer$D.isBuffer(Lt) || (Lt = new Buffer$D(Lt, zt)), this.__gen = Lt, this._gen = new B(Lt), this;
  };
  function Mt(Lt, zt) {
    var Ot = new Buffer$D(Lt.toArray());
    return zt ? Ot.toString(zt) : Ot;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var B = requireGeneratePrime(), L = require$$1$1, J = requireDh();
  function ne(Ce) {
    var rt = new Buffer$D(L[Ce].prime, "hex"), at = new Buffer$D(L[Ce].gen, "hex");
    return new J(rt, at);
  }
  var oe = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function ce(Ce, rt, at, ht) {
    return Buffer$D.isBuffer(rt) || oe[rt] === void 0 ? ce(Ce, "binary", rt, at) : (rt = rt || "binary", ht = ht || "binary", at = at || new Buffer$D([2]), Buffer$D.isBuffer(at) || (at = new Buffer$D(at, ht)), typeof Ce == "number" ? new J(B(Ce, at), at, !0) : (Buffer$D.isBuffer(Ce) || (Ce = new Buffer$D(Ce, rt)), new J(Ce, at, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ne, browser$4.createDiffieHellman = browser$4.DiffieHellman = ce, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1;
function nextTick(B, L, J, ne) {
  if (typeof B != "function")
    throw new TypeError('"callback" argument must be a function');
  var oe = arguments.length, ce, Ce;
  switch (oe) {
    case 0:
    case 1:
      return process$1.nextTick(B);
    case 2:
      return process$1.nextTick(function() {
        B.call(null, L);
      });
    case 3:
      return process$1.nextTick(function() {
        B.call(null, L, J);
      });
    case 4:
      return process$1.nextTick(function() {
        B.call(null, L, J, ne);
      });
    default:
      for (ce = new Array(oe - 1), Ce = 0; Ce < ce.length; )
        ce[Ce++] = arguments[Ce];
      return process$1.nextTick(function() {
        B.apply(null, ce);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(B) {
  return toString.call(B) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, safeBuffer$1 = { exports: {} };
(function(B, L) {
  var J = require$$1$2, ne = J.Buffer;
  function oe(Ce, rt) {
    for (var at in Ce)
      rt[at] = Ce[at];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = J : (oe(J, L), L.Buffer = ce);
  function ce(Ce, rt, at) {
    return ne(Ce, rt, at);
  }
  oe(ne, ce), ce.from = function(Ce, rt, at) {
    if (typeof Ce == "number")
      throw new TypeError("Argument must not be a number");
    return ne(Ce, rt, at);
  }, ce.alloc = function(Ce, rt, at) {
    if (typeof Ce != "number")
      throw new TypeError("Argument must be a number");
    var ht = ne(Ce);
    return rt !== void 0 ? typeof at == "string" ? ht.fill(rt, at) : ht.fill(rt) : ht.fill(0), ht;
  }, ce.allocUnsafe = function(Ce) {
    if (typeof Ce != "number")
      throw new TypeError("Argument must be a number");
    return ne(Ce);
  }, ce.allocUnsafeSlow = function(Ce) {
    if (typeof Ce != "number")
      throw new TypeError("Argument must be a number");
    return J.SlowBuffer(Ce);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, util$2 = {};
function isArray(B) {
  return Array.isArray ? Array.isArray(B) : objectToString(B) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(B) {
  return typeof B == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(B) {
  return B === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(B) {
  return B == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber$1(B) {
  return typeof B == "number";
}
util$2.isNumber = isNumber$1;
function isString$2(B) {
  return typeof B == "string";
}
util$2.isString = isString$2;
function isSymbol(B) {
  return typeof B == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(B) {
  return B === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(B) {
  return objectToString(B) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject$1(B) {
  return typeof B == "object" && B !== null;
}
util$2.isObject = isObject$1;
function isDate(B) {
  return objectToString(B) === "[object Date]";
}
util$2.isDate = isDate;
function isError(B) {
  return objectToString(B) === "[object Error]" || B instanceof Error;
}
util$2.isError = isError;
function isFunction(B) {
  return typeof B == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(B) {
  return B === null || typeof B == "boolean" || typeof B == "number" || typeof B == "string" || typeof B == "symbol" || // ES6 symbol
  typeof B > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = require$$1$2.Buffer.isBuffer;
function objectToString(B) {
  return Object.prototype.toString.call(B);
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function L(ce, Ce) {
      if (!(ce instanceof Ce))
        throw new TypeError("Cannot call a class as a function");
    }
    var J = safeBufferExports.Buffer, ne = util$3;
    function oe(ce, Ce, rt) {
      ce.copy(Ce, rt);
    }
    B.exports = function() {
      function ce() {
        L(this, ce), this.head = null, this.tail = null, this.length = 0;
      }
      return ce.prototype.push = function(rt) {
        var at = { data: rt, next: null };
        this.length > 0 ? this.tail.next = at : this.head = at, this.tail = at, ++this.length;
      }, ce.prototype.unshift = function(rt) {
        var at = { data: rt, next: this.head };
        this.length === 0 && (this.tail = at), this.head = at, ++this.length;
      }, ce.prototype.shift = function() {
        if (this.length !== 0) {
          var rt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, rt;
        }
      }, ce.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, ce.prototype.join = function(rt) {
        if (this.length === 0) return "";
        for (var at = this.head, ht = "" + at.data; at = at.next; )
          ht += rt + at.data;
        return ht;
      }, ce.prototype.concat = function(rt) {
        if (this.length === 0) return J.alloc(0);
        for (var at = J.allocUnsafe(rt >>> 0), ht = this.head, it = 0; ht; )
          oe(ht.data, at, it), it += ht.data.length, ht = ht.next;
        return at;
      }, ce;
    }(), ne && ne.inspect && ne.inspect.custom && (B.exports.prototype[ne.inspect.custom] = function() {
      var ce = ne.inspect({ length: this.length });
      return this.constructor.name + " " + ce;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(B, L) {
  var J = this, ne = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
  return ne || oe ? (L ? L(B) : B && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, B)) : pna.nextTick(emitErrorNT, this, B)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(B || null, function(ce) {
    !L && ce ? J._writableState ? J._writableState.errorEmitted || (J._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, J, ce)) : pna.nextTick(emitErrorNT, J, ce) : L && L(ce);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(B, L) {
  B.emit("error", L);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = processNextickArgsExports;
  _stream_writable = Mt;
  function L(gt) {
    var St = this;
    this.next = null, this.entry = null, this.finish = function() {
      mt(St, gt);
    };
  }
  var J = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, ne;
  Mt.WritableState = wt;
  var oe = Object.create(util$2);
  oe.inherits = inherits_browserExports;
  var ce = {
    deprecate: browser$a
  }, Ce = streamBrowser, rt = safeBufferExports.Buffer, at = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ht(gt) {
    return rt.from(gt);
  }
  function it(gt) {
    return rt.isBuffer(gt) || gt instanceof at;
  }
  var lt = destroy_1;
  oe.inherits(Mt, Ce);
  function Et() {
  }
  function wt(gt, St) {
    ne = ne || require_stream_duplex(), gt = gt || {};
    var xt = St instanceof ne;
    this.objectMode = !!gt.objectMode, xt && (this.objectMode = this.objectMode || !!gt.writableObjectMode);
    var vt = gt.highWaterMark, $t = gt.writableHighWaterMark, yt = this.objectMode ? 16 : 16 * 1024;
    vt || vt === 0 ? this.highWaterMark = vt : xt && ($t || $t === 0) ? this.highWaterMark = $t : this.highWaterMark = yt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Bt = gt.decodeStrings === !1;
    this.decodeStrings = !Bt, this.defaultEncoding = gt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(rr) {
      yr(St, rr);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new L(this);
  }
  wt.prototype.getBuffer = function() {
    for (var St = this.bufferedRequest, xt = []; St; )
      xt.push(St), St = St.next;
    return xt;
  }, function() {
    try {
      Object.defineProperty(wt.prototype, "buffer", {
        get: ce.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Rt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Rt = Function.prototype[Symbol.hasInstance], Object.defineProperty(Mt, Symbol.hasInstance, {
    value: function(gt) {
      return Rt.call(this, gt) ? !0 : this !== Mt ? !1 : gt && gt._writableState instanceof wt;
    }
  })) : Rt = function(gt) {
    return gt instanceof this;
  };
  function Mt(gt) {
    if (ne = ne || require_stream_duplex(), !Rt.call(Mt, this) && !(this instanceof ne))
      return new Mt(gt);
    this._writableState = new wt(gt, this), this.writable = !0, gt && (typeof gt.write == "function" && (this._write = gt.write), typeof gt.writev == "function" && (this._writev = gt.writev), typeof gt.destroy == "function" && (this._destroy = gt.destroy), typeof gt.final == "function" && (this._final = gt.final)), Ce.call(this);
  }
  Mt.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Lt(gt, St) {
    var xt = new Error("write after end");
    gt.emit("error", xt), B.nextTick(St, xt);
  }
  function zt(gt, St, xt, vt) {
    var $t = !0, yt = !1;
    return xt === null ? yt = new TypeError("May not write null values to stream") : typeof xt != "string" && xt !== void 0 && !St.objectMode && (yt = new TypeError("Invalid non-string/buffer chunk")), yt && (gt.emit("error", yt), B.nextTick(vt, yt), $t = !1), $t;
  }
  Mt.prototype.write = function(gt, St, xt) {
    var vt = this._writableState, $t = !1, yt = !vt.objectMode && it(gt);
    return yt && !rt.isBuffer(gt) && (gt = ht(gt)), typeof St == "function" && (xt = St, St = null), yt ? St = "buffer" : St || (St = vt.defaultEncoding), typeof xt != "function" && (xt = Et), vt.ended ? Lt(this, xt) : (yt || zt(this, vt, gt, xt)) && (vt.pendingcb++, $t = It(this, vt, yt, gt, St, xt)), $t;
  }, Mt.prototype.cork = function() {
    var gt = this._writableState;
    gt.corked++;
  }, Mt.prototype.uncork = function() {
    var gt = this._writableState;
    gt.corked && (gt.corked--, !gt.writing && !gt.corked && !gt.bufferProcessing && gt.bufferedRequest && er(this, gt));
  }, Mt.prototype.setDefaultEncoding = function(St) {
    if (typeof St == "string" && (St = St.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((St + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + St);
    return this._writableState.defaultEncoding = St, this;
  };
  function Ot(gt, St, xt) {
    return !gt.objectMode && gt.decodeStrings !== !1 && typeof St == "string" && (St = rt.from(St, xt)), St;
  }
  Object.defineProperty(Mt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function It(gt, St, xt, vt, $t, yt) {
    if (!xt) {
      var Bt = Ot(St, vt, $t);
      vt !== Bt && (xt = !0, $t = "buffer", vt = Bt);
    }
    var rr = St.objectMode ? 1 : vt.length;
    St.length += rr;
    var dr = St.length < St.highWaterMark;
    if (dr || (St.needDrain = !0), St.writing || St.corked) {
      var tr = St.lastBufferedRequest;
      St.lastBufferedRequest = {
        chunk: vt,
        encoding: $t,
        isBuf: xt,
        callback: yt,
        next: null
      }, tr ? tr.next = St.lastBufferedRequest : St.bufferedRequest = St.lastBufferedRequest, St.bufferedRequestCount += 1;
    } else
      Ft(gt, St, !1, rr, vt, $t, yt);
    return dr;
  }
  function Ft(gt, St, xt, vt, $t, yt, Bt) {
    St.writelen = vt, St.writecb = Bt, St.writing = !0, St.sync = !0, xt ? gt._writev($t, St.onwrite) : gt._write($t, yt, St.onwrite), St.sync = !1;
  }
  function Jt(gt, St, xt, vt, $t) {
    --St.pendingcb, xt ? (B.nextTick($t, vt), B.nextTick(ot, gt, St), gt._writableState.errorEmitted = !0, gt.emit("error", vt)) : ($t(vt), gt._writableState.errorEmitted = !0, gt.emit("error", vt), ot(gt, St));
  }
  function Vt(gt) {
    gt.writing = !1, gt.writecb = null, gt.length -= gt.writelen, gt.writelen = 0;
  }
  function yr(gt, St) {
    var xt = gt._writableState, vt = xt.sync, $t = xt.writecb;
    if (Vt(xt), St) Jt(gt, xt, vt, St, $t);
    else {
      var yt = Ht(xt);
      !yt && !xt.corked && !xt.bufferProcessing && xt.bufferedRequest && er(gt, xt), vt ? J(jt, gt, xt, yt, $t) : jt(gt, xt, yt, $t);
    }
  }
  function jt(gt, St, xt, vt) {
    xt || Ut(gt, St), St.pendingcb--, vt(), ot(gt, St);
  }
  function Ut(gt, St) {
    St.length === 0 && St.needDrain && (St.needDrain = !1, gt.emit("drain"));
  }
  function er(gt, St) {
    St.bufferProcessing = !0;
    var xt = St.bufferedRequest;
    if (gt._writev && xt && xt.next) {
      var vt = St.bufferedRequestCount, $t = new Array(vt), yt = St.corkedRequestsFree;
      yt.entry = xt;
      for (var Bt = 0, rr = !0; xt; )
        $t[Bt] = xt, xt.isBuf || (rr = !1), xt = xt.next, Bt += 1;
      $t.allBuffers = rr, Ft(gt, St, !0, St.length, $t, "", yt.finish), St.pendingcb++, St.lastBufferedRequest = null, yt.next ? (St.corkedRequestsFree = yt.next, yt.next = null) : St.corkedRequestsFree = new L(St), St.bufferedRequestCount = 0;
    } else {
      for (; xt; ) {
        var dr = xt.chunk, tr = xt.encoding, Dt = xt.callback, Wt = St.objectMode ? 1 : dr.length;
        if (Ft(gt, St, !1, Wt, dr, tr, Dt), xt = xt.next, St.bufferedRequestCount--, St.writing)
          break;
      }
      xt === null && (St.lastBufferedRequest = null);
    }
    St.bufferedRequest = xt, St.bufferProcessing = !1;
  }
  Mt.prototype._write = function(gt, St, xt) {
    xt(new Error("_write() is not implemented"));
  }, Mt.prototype._writev = null, Mt.prototype.end = function(gt, St, xt) {
    var vt = this._writableState;
    typeof gt == "function" ? (xt = gt, gt = null, St = null) : typeof St == "function" && (xt = St, St = null), gt != null && this.write(gt, St), vt.corked && (vt.corked = 1, this.uncork()), vt.ending || ut(this, vt, xt);
  };
  function Ht(gt) {
    return gt.ending && gt.length === 0 && gt.bufferedRequest === null && !gt.finished && !gt.writing;
  }
  function ct(gt, St) {
    gt._final(function(xt) {
      St.pendingcb--, xt && gt.emit("error", xt), St.prefinished = !0, gt.emit("prefinish"), ot(gt, St);
    });
  }
  function dt(gt, St) {
    !St.prefinished && !St.finalCalled && (typeof gt._final == "function" ? (St.pendingcb++, St.finalCalled = !0, B.nextTick(ct, gt, St)) : (St.prefinished = !0, gt.emit("prefinish")));
  }
  function ot(gt, St) {
    var xt = Ht(St);
    return xt && (dt(gt, St), St.pendingcb === 0 && (St.finished = !0, gt.emit("finish"))), xt;
  }
  function ut(gt, St, xt) {
    St.ending = !0, ot(gt, St), xt && (St.finished ? B.nextTick(xt) : gt.once("finish", xt)), St.ended = !0, gt.writable = !1;
  }
  function mt(gt, St, xt) {
    var vt = gt.entry;
    for (gt.entry = null; vt; ) {
      var $t = vt.callback;
      St.pendingcb--, $t(xt), vt = vt.next;
    }
    St.corkedRequestsFree.next = gt;
  }
  return Object.defineProperty(Mt.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(gt) {
      this._writableState && (this._writableState.destroyed = gt);
    }
  }), Mt.prototype.destroy = lt.destroy, Mt.prototype._undestroy = lt.undestroy, Mt.prototype._destroy = function(gt, St) {
    this.end(), St(gt);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = processNextickArgsExports, L = Object.keys || function(lt) {
    var Et = [];
    for (var wt in lt)
      Et.push(wt);
    return Et;
  };
  _stream_duplex = at;
  var J = Object.create(util$2);
  J.inherits = inherits_browserExports;
  var ne = require_stream_readable(), oe = require_stream_writable();
  J.inherits(at, ne);
  for (var ce = L(oe.prototype), Ce = 0; Ce < ce.length; Ce++) {
    var rt = ce[Ce];
    at.prototype[rt] || (at.prototype[rt] = oe.prototype[rt]);
  }
  function at(lt) {
    if (!(this instanceof at)) return new at(lt);
    ne.call(this, lt), oe.call(this, lt), lt && lt.readable === !1 && (this.readable = !1), lt && lt.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, lt && lt.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ht);
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ht() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(it, this);
  }
  function it(lt) {
    lt.end();
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(lt) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = lt, this._writableState.destroyed = lt);
    }
  }), at.prototype._destroy = function(lt, Et) {
    this.push(null), this.end(), B.nextTick(Et, lt);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = processNextickArgsExports;
  _stream_readable = Ot;
  var L = isarray, J;
  Ot.ReadableState = zt, eventsExports.EventEmitter;
  var ne = function(Dt, Wt) {
    return Dt.listeners(Wt).length;
  }, oe = streamBrowser, ce = safeBufferExports.Buffer, Ce = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function rt(Dt) {
    return ce.from(Dt);
  }
  function at(Dt) {
    return ce.isBuffer(Dt) || Dt instanceof Ce;
  }
  var ht = Object.create(util$2);
  ht.inherits = inherits_browserExports;
  var it = util$3, lt = void 0;
  it && it.debuglog ? lt = it.debuglog("stream") : lt = function() {
  };
  var Et = requireBufferList(), wt = destroy_1, Rt;
  ht.inherits(Ot, oe);
  var Mt = ["error", "close", "destroy", "pause", "resume"];
  function Lt(Dt, Wt, or) {
    if (typeof Dt.prependListener == "function") return Dt.prependListener(Wt, or);
    !Dt._events || !Dt._events[Wt] ? Dt.on(Wt, or) : L(Dt._events[Wt]) ? Dt._events[Wt].unshift(or) : Dt._events[Wt] = [or, Dt._events[Wt]];
  }
  function zt(Dt, Wt) {
    J = J || require_stream_duplex(), Dt = Dt || {};
    var or = Wt instanceof J;
    this.objectMode = !!Dt.objectMode, or && (this.objectMode = this.objectMode || !!Dt.readableObjectMode);
    var _r = Dt.highWaterMark, Xt = Dt.readableHighWaterMark, Qt = this.objectMode ? 16 : 16 * 1024;
    _r || _r === 0 ? this.highWaterMark = _r : or && (Xt || Xt === 0) ? this.highWaterMark = Xt : this.highWaterMark = Qt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Et(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Dt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Dt.encoding && (Rt || (Rt = string_decoder.StringDecoder), this.decoder = new Rt(Dt.encoding), this.encoding = Dt.encoding);
  }
  function Ot(Dt) {
    if (J = J || require_stream_duplex(), !(this instanceof Ot)) return new Ot(Dt);
    this._readableState = new zt(Dt, this), this.readable = !0, Dt && (typeof Dt.read == "function" && (this._read = Dt.read), typeof Dt.destroy == "function" && (this._destroy = Dt.destroy)), oe.call(this);
  }
  Object.defineProperty(Ot.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Dt) {
      this._readableState && (this._readableState.destroyed = Dt);
    }
  }), Ot.prototype.destroy = wt.destroy, Ot.prototype._undestroy = wt.undestroy, Ot.prototype._destroy = function(Dt, Wt) {
    this.push(null), Wt(Dt);
  }, Ot.prototype.push = function(Dt, Wt) {
    var or = this._readableState, _r;
    return or.objectMode ? _r = !0 : typeof Dt == "string" && (Wt = Wt || or.defaultEncoding, Wt !== or.encoding && (Dt = ce.from(Dt, Wt), Wt = ""), _r = !0), It(this, Dt, Wt, !1, _r);
  }, Ot.prototype.unshift = function(Dt) {
    return It(this, Dt, null, !0, !1);
  };
  function It(Dt, Wt, or, _r, Xt) {
    var Qt = Dt._readableState;
    if (Wt === null)
      Qt.reading = !1, er(Dt, Qt);
    else {
      var br;
      Xt || (br = Jt(Qt, Wt)), br ? Dt.emit("error", br) : Qt.objectMode || Wt && Wt.length > 0 ? (typeof Wt != "string" && !Qt.objectMode && Object.getPrototypeOf(Wt) !== ce.prototype && (Wt = rt(Wt)), _r ? Qt.endEmitted ? Dt.emit("error", new Error("stream.unshift() after end event")) : Ft(Dt, Qt, Wt, !0) : Qt.ended ? Dt.emit("error", new Error("stream.push() after EOF")) : (Qt.reading = !1, Qt.decoder && !or ? (Wt = Qt.decoder.write(Wt), Qt.objectMode || Wt.length !== 0 ? Ft(Dt, Qt, Wt, !1) : dt(Dt, Qt)) : Ft(Dt, Qt, Wt, !1))) : _r || (Qt.reading = !1);
    }
    return Vt(Qt);
  }
  function Ft(Dt, Wt, or, _r) {
    Wt.flowing && Wt.length === 0 && !Wt.sync ? (Dt.emit("data", or), Dt.read(0)) : (Wt.length += Wt.objectMode ? 1 : or.length, _r ? Wt.buffer.unshift(or) : Wt.buffer.push(or), Wt.needReadable && Ht(Dt)), dt(Dt, Wt);
  }
  function Jt(Dt, Wt) {
    var or;
    return !at(Wt) && typeof Wt != "string" && Wt !== void 0 && !Dt.objectMode && (or = new TypeError("Invalid non-string/buffer chunk")), or;
  }
  function Vt(Dt) {
    return !Dt.ended && (Dt.needReadable || Dt.length < Dt.highWaterMark || Dt.length === 0);
  }
  Ot.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ot.prototype.setEncoding = function(Dt) {
    return Rt || (Rt = string_decoder.StringDecoder), this._readableState.decoder = new Rt(Dt), this._readableState.encoding = Dt, this;
  };
  var yr = 8388608;
  function jt(Dt) {
    return Dt >= yr ? Dt = yr : (Dt--, Dt |= Dt >>> 1, Dt |= Dt >>> 2, Dt |= Dt >>> 4, Dt |= Dt >>> 8, Dt |= Dt >>> 16, Dt++), Dt;
  }
  function Ut(Dt, Wt) {
    return Dt <= 0 || Wt.length === 0 && Wt.ended ? 0 : Wt.objectMode ? 1 : Dt !== Dt ? Wt.flowing && Wt.length ? Wt.buffer.head.data.length : Wt.length : (Dt > Wt.highWaterMark && (Wt.highWaterMark = jt(Dt)), Dt <= Wt.length ? Dt : Wt.ended ? Wt.length : (Wt.needReadable = !0, 0));
  }
  Ot.prototype.read = function(Dt) {
    lt("read", Dt), Dt = parseInt(Dt, 10);
    var Wt = this._readableState, or = Dt;
    if (Dt !== 0 && (Wt.emittedReadable = !1), Dt === 0 && Wt.needReadable && (Wt.length >= Wt.highWaterMark || Wt.ended))
      return lt("read: emitReadable", Wt.length, Wt.ended), Wt.length === 0 && Wt.ended ? rr(this) : Ht(this), null;
    if (Dt = Ut(Dt, Wt), Dt === 0 && Wt.ended)
      return Wt.length === 0 && rr(this), null;
    var _r = Wt.needReadable;
    lt("need readable", _r), (Wt.length === 0 || Wt.length - Dt < Wt.highWaterMark) && (_r = !0, lt("length less than watermark", _r)), Wt.ended || Wt.reading ? (_r = !1, lt("reading or ended", _r)) : _r && (lt("do read"), Wt.reading = !0, Wt.sync = !0, Wt.length === 0 && (Wt.needReadable = !0), this._read(Wt.highWaterMark), Wt.sync = !1, Wt.reading || (Dt = Ut(or, Wt)));
    var Xt;
    return Dt > 0 ? Xt = vt(Dt, Wt) : Xt = null, Xt === null ? (Wt.needReadable = !0, Dt = 0) : Wt.length -= Dt, Wt.length === 0 && (Wt.ended || (Wt.needReadable = !0), or !== Dt && Wt.ended && rr(this)), Xt !== null && this.emit("data", Xt), Xt;
  };
  function er(Dt, Wt) {
    if (!Wt.ended) {
      if (Wt.decoder) {
        var or = Wt.decoder.end();
        or && or.length && (Wt.buffer.push(or), Wt.length += Wt.objectMode ? 1 : or.length);
      }
      Wt.ended = !0, Ht(Dt);
    }
  }
  function Ht(Dt) {
    var Wt = Dt._readableState;
    Wt.needReadable = !1, Wt.emittedReadable || (lt("emitReadable", Wt.flowing), Wt.emittedReadable = !0, Wt.sync ? B.nextTick(ct, Dt) : ct(Dt));
  }
  function ct(Dt) {
    lt("emit readable"), Dt.emit("readable"), xt(Dt);
  }
  function dt(Dt, Wt) {
    Wt.readingMore || (Wt.readingMore = !0, B.nextTick(ot, Dt, Wt));
  }
  function ot(Dt, Wt) {
    for (var or = Wt.length; !Wt.reading && !Wt.flowing && !Wt.ended && Wt.length < Wt.highWaterMark && (lt("maybeReadMore read 0"), Dt.read(0), or !== Wt.length); )
      or = Wt.length;
    Wt.readingMore = !1;
  }
  Ot.prototype._read = function(Dt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, Ot.prototype.pipe = function(Dt, Wt) {
    var or = this, _r = this._readableState;
    switch (_r.pipesCount) {
      case 0:
        _r.pipes = Dt;
        break;
      case 1:
        _r.pipes = [_r.pipes, Dt];
        break;
      default:
        _r.pipes.push(Dt);
        break;
    }
    _r.pipesCount += 1, lt("pipe count=%d opts=%j", _r.pipesCount, Wt);
    var Xt = (!Wt || Wt.end !== !1) && Dt !== process$1.stdout && Dt !== process$1.stderr, Qt = Xt ? Dr : Gn;
    _r.endEmitted ? B.nextTick(Qt) : or.once("end", Qt), Dt.on("unpipe", br);
    function br(En, Pn) {
      lt("onunpipe"), En === or && Pn && Pn.hasUnpiped === !1 && (Pn.hasUnpiped = !0, ln());
    }
    function Dr() {
      lt("onend"), Dt.end();
    }
    var Vr = ut(or);
    Dt.on("drain", Vr);
    var Zr = !1;
    function ln() {
      lt("cleanup"), Dt.removeListener("close", xn), Dt.removeListener("finish", ni), Dt.removeListener("drain", Vr), Dt.removeListener("error", Wn), Dt.removeListener("unpipe", br), or.removeListener("end", Dr), or.removeListener("end", Gn), or.removeListener("data", Mr), Zr = !0, _r.awaitDrain && (!Dt._writableState || Dt._writableState.needDrain) && Vr();
    }
    var _n = !1;
    or.on("data", Mr);
    function Mr(En) {
      lt("ondata"), _n = !1;
      var Pn = Dt.write(En);
      Pn === !1 && !_n && ((_r.pipesCount === 1 && _r.pipes === Dt || _r.pipesCount > 1 && tr(_r.pipes, Dt) !== -1) && !Zr && (lt("false write response, pause", _r.awaitDrain), _r.awaitDrain++, _n = !0), or.pause());
    }
    function Wn(En) {
      lt("onerror", En), Gn(), Dt.removeListener("error", Wn), ne(Dt, "error") === 0 && Dt.emit("error", En);
    }
    Lt(Dt, "error", Wn);
    function xn() {
      Dt.removeListener("finish", ni), Gn();
    }
    Dt.once("close", xn);
    function ni() {
      lt("onfinish"), Dt.removeListener("close", xn), Gn();
    }
    Dt.once("finish", ni);
    function Gn() {
      lt("unpipe"), or.unpipe(Dt);
    }
    return Dt.emit("pipe", or), _r.flowing || (lt("pipe resume"), or.resume()), Dt;
  };
  function ut(Dt) {
    return function() {
      var Wt = Dt._readableState;
      lt("pipeOnDrain", Wt.awaitDrain), Wt.awaitDrain && Wt.awaitDrain--, Wt.awaitDrain === 0 && ne(Dt, "data") && (Wt.flowing = !0, xt(Dt));
    };
  }
  Ot.prototype.unpipe = function(Dt) {
    var Wt = this._readableState, or = { hasUnpiped: !1 };
    if (Wt.pipesCount === 0) return this;
    if (Wt.pipesCount === 1)
      return Dt && Dt !== Wt.pipes ? this : (Dt || (Dt = Wt.pipes), Wt.pipes = null, Wt.pipesCount = 0, Wt.flowing = !1, Dt && Dt.emit("unpipe", this, or), this);
    if (!Dt) {
      var _r = Wt.pipes, Xt = Wt.pipesCount;
      Wt.pipes = null, Wt.pipesCount = 0, Wt.flowing = !1;
      for (var Qt = 0; Qt < Xt; Qt++)
        _r[Qt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var br = tr(Wt.pipes, Dt);
    return br === -1 ? this : (Wt.pipes.splice(br, 1), Wt.pipesCount -= 1, Wt.pipesCount === 1 && (Wt.pipes = Wt.pipes[0]), Dt.emit("unpipe", this, or), this);
  }, Ot.prototype.on = function(Dt, Wt) {
    var or = oe.prototype.on.call(this, Dt, Wt);
    if (Dt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Dt === "readable") {
      var _r = this._readableState;
      !_r.endEmitted && !_r.readableListening && (_r.readableListening = _r.needReadable = !0, _r.emittedReadable = !1, _r.reading ? _r.length && Ht(this) : B.nextTick(mt, this));
    }
    return or;
  }, Ot.prototype.addListener = Ot.prototype.on;
  function mt(Dt) {
    lt("readable nexttick read 0"), Dt.read(0);
  }
  Ot.prototype.resume = function() {
    var Dt = this._readableState;
    return Dt.flowing || (lt("resume"), Dt.flowing = !0, gt(this, Dt)), this;
  };
  function gt(Dt, Wt) {
    Wt.resumeScheduled || (Wt.resumeScheduled = !0, B.nextTick(St, Dt, Wt));
  }
  function St(Dt, Wt) {
    Wt.reading || (lt("resume read 0"), Dt.read(0)), Wt.resumeScheduled = !1, Wt.awaitDrain = 0, Dt.emit("resume"), xt(Dt), Wt.flowing && !Wt.reading && Dt.read(0);
  }
  Ot.prototype.pause = function() {
    return lt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (lt("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function xt(Dt) {
    var Wt = Dt._readableState;
    for (lt("flow", Wt.flowing); Wt.flowing && Dt.read() !== null; )
      ;
  }
  Ot.prototype.wrap = function(Dt) {
    var Wt = this, or = this._readableState, _r = !1;
    Dt.on("end", function() {
      if (lt("wrapped end"), or.decoder && !or.ended) {
        var br = or.decoder.end();
        br && br.length && Wt.push(br);
      }
      Wt.push(null);
    }), Dt.on("data", function(br) {
      if (lt("wrapped data"), or.decoder && (br = or.decoder.write(br)), !(or.objectMode && br == null) && !(!or.objectMode && (!br || !br.length))) {
        var Dr = Wt.push(br);
        Dr || (_r = !0, Dt.pause());
      }
    });
    for (var Xt in Dt)
      this[Xt] === void 0 && typeof Dt[Xt] == "function" && (this[Xt] = /* @__PURE__ */ function(br) {
        return function() {
          return Dt[br].apply(Dt, arguments);
        };
      }(Xt));
    for (var Qt = 0; Qt < Mt.length; Qt++)
      Dt.on(Mt[Qt], this.emit.bind(this, Mt[Qt]));
    return this._read = function(br) {
      lt("wrapped _read", br), _r && (_r = !1, Dt.resume());
    }, this;
  }, Object.defineProperty(Ot.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Ot._fromList = vt;
  function vt(Dt, Wt) {
    if (Wt.length === 0) return null;
    var or;
    return Wt.objectMode ? or = Wt.buffer.shift() : !Dt || Dt >= Wt.length ? (Wt.decoder ? or = Wt.buffer.join("") : Wt.buffer.length === 1 ? or = Wt.buffer.head.data : or = Wt.buffer.concat(Wt.length), Wt.buffer.clear()) : or = $t(Dt, Wt.buffer, Wt.decoder), or;
  }
  function $t(Dt, Wt, or) {
    var _r;
    return Dt < Wt.head.data.length ? (_r = Wt.head.data.slice(0, Dt), Wt.head.data = Wt.head.data.slice(Dt)) : Dt === Wt.head.data.length ? _r = Wt.shift() : _r = or ? yt(Dt, Wt) : Bt(Dt, Wt), _r;
  }
  function yt(Dt, Wt) {
    var or = Wt.head, _r = 1, Xt = or.data;
    for (Dt -= Xt.length; or = or.next; ) {
      var Qt = or.data, br = Dt > Qt.length ? Qt.length : Dt;
      if (br === Qt.length ? Xt += Qt : Xt += Qt.slice(0, Dt), Dt -= br, Dt === 0) {
        br === Qt.length ? (++_r, or.next ? Wt.head = or.next : Wt.head = Wt.tail = null) : (Wt.head = or, or.data = Qt.slice(br));
        break;
      }
      ++_r;
    }
    return Wt.length -= _r, Xt;
  }
  function Bt(Dt, Wt) {
    var or = ce.allocUnsafe(Dt), _r = Wt.head, Xt = 1;
    for (_r.data.copy(or), Dt -= _r.data.length; _r = _r.next; ) {
      var Qt = _r.data, br = Dt > Qt.length ? Qt.length : Dt;
      if (Qt.copy(or, or.length - Dt, 0, br), Dt -= br, Dt === 0) {
        br === Qt.length ? (++Xt, _r.next ? Wt.head = _r.next : Wt.head = Wt.tail = null) : (Wt.head = _r, _r.data = Qt.slice(br));
        break;
      }
      ++Xt;
    }
    return Wt.length -= Xt, or;
  }
  function rr(Dt) {
    var Wt = Dt._readableState;
    if (Wt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Wt.endEmitted || (Wt.ended = !0, B.nextTick(dr, Wt, Dt));
  }
  function dr(Dt, Wt) {
    !Dt.endEmitted && Dt.length === 0 && (Dt.endEmitted = !0, Wt.readable = !1, Wt.emit("end"));
  }
  function tr(Dt, Wt) {
    for (var or = 0, _r = Dt.length; or < _r; or++)
      if (Dt[or] === Wt) return or;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(B, L) {
  var J = this._transformState;
  J.transforming = !1;
  var ne = J.writecb;
  if (!ne)
    return this.emit("error", new Error("write callback called multiple times"));
  J.writechunk = null, J.writecb = null, L != null && this.push(L), ne(B);
  var oe = this._readableState;
  oe.reading = !1, (oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
}
function Transform$1(B) {
  if (!(this instanceof Transform$1)) return new Transform$1(B);
  Duplex.call(this, B), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var B = this;
  typeof this._flush == "function" ? this._flush(function(L, J) {
    done(B, L, J);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(B, L) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, B, L);
};
Transform$1.prototype._transform = function(B, L, J) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(B, L, J) {
  var ne = this._transformState;
  if (ne.writecb = J, ne.writechunk = B, ne.writeencoding = L, !ne.transforming) {
    var oe = this._readableState;
    (ne.needTransform || oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
  }
};
Transform$1.prototype._read = function(B) {
  var L = this._transformState;
  L.writechunk !== null && L.writecb && !L.transforming ? (L.transforming = !0, this._transform(L.writechunk, L.writeencoding, L.afterTransform)) : L.needTransform = !0;
};
Transform$1.prototype._destroy = function(B, L) {
  var J = this;
  Duplex.prototype._destroy.call(this, B, function(ne) {
    L(ne), J.emit("close");
  });
};
function done(B, L, J) {
  if (L) return B.emit("error", L);
  if (J != null && B.push(J), B._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (B._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return B.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(B) {
  if (!(this instanceof PassThrough)) return new PassThrough(B);
  Transform.call(this, B);
}
PassThrough.prototype._transform = function(B, L, J) {
  J(null, B);
};
(function(B, L) {
  L = B.exports = require_stream_readable(), L.Stream = L, L.Readable = L, L.Writable = require_stream_writable(), L.Duplex = require_stream_duplex(), L.Transform = _stream_transform, L.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign$1 = { exports: {} }, bn = { exports: {} };
bn.exports;
(function(B) {
  (function(L, J) {
    function ne(dt, ot) {
      if (!dt) throw new Error(ot || "Assertion failed");
    }
    function oe(dt, ot) {
      dt.super_ = ot;
      var ut = function() {
      };
      ut.prototype = ot.prototype, dt.prototype = new ut(), dt.prototype.constructor = dt;
    }
    function ce(dt, ot, ut) {
      if (ce.isBN(dt))
        return dt;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, dt !== null && ((ot === "le" || ot === "be") && (ut = ot, ot = 10), this._init(dt || 0, ot || 10, ut || "be"));
    }
    typeof L == "object" ? L.exports = ce : J.BN = ce, ce.BN = ce, ce.wordSize = 26;
    var Ce;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Ce = window.Buffer : Ce = require$$1$2.Buffer;
    } catch {
    }
    ce.isBN = function(ot) {
      return ot instanceof ce ? !0 : ot !== null && typeof ot == "object" && ot.constructor.wordSize === ce.wordSize && Array.isArray(ot.words);
    }, ce.max = function(ot, ut) {
      return ot.cmp(ut) > 0 ? ot : ut;
    }, ce.min = function(ot, ut) {
      return ot.cmp(ut) < 0 ? ot : ut;
    }, ce.prototype._init = function(ot, ut, mt) {
      if (typeof ot == "number")
        return this._initNumber(ot, ut, mt);
      if (typeof ot == "object")
        return this._initArray(ot, ut, mt);
      ut === "hex" && (ut = 16), ne(ut === (ut | 0) && ut >= 2 && ut <= 36), ot = ot.toString().replace(/\s+/g, "");
      var gt = 0;
      ot[0] === "-" && (gt++, this.negative = 1), gt < ot.length && (ut === 16 ? this._parseHex(ot, gt, mt) : (this._parseBase(ot, ut, gt), mt === "le" && this._initArray(this.toArray(), ut, mt)));
    }, ce.prototype._initNumber = function(ot, ut, mt) {
      ot < 0 && (this.negative = 1, ot = -ot), ot < 67108864 ? (this.words = [ot & 67108863], this.length = 1) : ot < 4503599627370496 ? (this.words = [
        ot & 67108863,
        ot / 67108864 & 67108863
      ], this.length = 2) : (ne(ot < 9007199254740992), this.words = [
        ot & 67108863,
        ot / 67108864 & 67108863,
        1
      ], this.length = 3), mt === "le" && this._initArray(this.toArray(), ut, mt);
    }, ce.prototype._initArray = function(ot, ut, mt) {
      if (ne(typeof ot.length == "number"), ot.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ot.length / 3), this.words = new Array(this.length);
      for (var gt = 0; gt < this.length; gt++)
        this.words[gt] = 0;
      var St, xt, vt = 0;
      if (mt === "be")
        for (gt = ot.length - 1, St = 0; gt >= 0; gt -= 3)
          xt = ot[gt] | ot[gt - 1] << 8 | ot[gt - 2] << 16, this.words[St] |= xt << vt & 67108863, this.words[St + 1] = xt >>> 26 - vt & 67108863, vt += 24, vt >= 26 && (vt -= 26, St++);
      else if (mt === "le")
        for (gt = 0, St = 0; gt < ot.length; gt += 3)
          xt = ot[gt] | ot[gt + 1] << 8 | ot[gt + 2] << 16, this.words[St] |= xt << vt & 67108863, this.words[St + 1] = xt >>> 26 - vt & 67108863, vt += 24, vt >= 26 && (vt -= 26, St++);
      return this._strip();
    };
    function rt(dt, ot) {
      var ut = dt.charCodeAt(ot);
      if (ut >= 48 && ut <= 57)
        return ut - 48;
      if (ut >= 65 && ut <= 70)
        return ut - 55;
      if (ut >= 97 && ut <= 102)
        return ut - 87;
      ne(!1, "Invalid character in " + dt);
    }
    function at(dt, ot, ut) {
      var mt = rt(dt, ut);
      return ut - 1 >= ot && (mt |= rt(dt, ut - 1) << 4), mt;
    }
    ce.prototype._parseHex = function(ot, ut, mt) {
      this.length = Math.ceil((ot.length - ut) / 6), this.words = new Array(this.length);
      for (var gt = 0; gt < this.length; gt++)
        this.words[gt] = 0;
      var St = 0, xt = 0, vt;
      if (mt === "be")
        for (gt = ot.length - 1; gt >= ut; gt -= 2)
          vt = at(ot, ut, gt) << St, this.words[xt] |= vt & 67108863, St >= 18 ? (St -= 18, xt += 1, this.words[xt] |= vt >>> 26) : St += 8;
      else {
        var $t = ot.length - ut;
        for (gt = $t % 2 === 0 ? ut + 1 : ut; gt < ot.length; gt += 2)
          vt = at(ot, ut, gt) << St, this.words[xt] |= vt & 67108863, St >= 18 ? (St -= 18, xt += 1, this.words[xt] |= vt >>> 26) : St += 8;
      }
      this._strip();
    };
    function ht(dt, ot, ut, mt) {
      for (var gt = 0, St = 0, xt = Math.min(dt.length, ut), vt = ot; vt < xt; vt++) {
        var $t = dt.charCodeAt(vt) - 48;
        gt *= mt, $t >= 49 ? St = $t - 49 + 10 : $t >= 17 ? St = $t - 17 + 10 : St = $t, ne($t >= 0 && St < mt, "Invalid character"), gt += St;
      }
      return gt;
    }
    ce.prototype._parseBase = function(ot, ut, mt) {
      this.words = [0], this.length = 1;
      for (var gt = 0, St = 1; St <= 67108863; St *= ut)
        gt++;
      gt--, St = St / ut | 0;
      for (var xt = ot.length - mt, vt = xt % gt, $t = Math.min(xt, xt - vt) + mt, yt = 0, Bt = mt; Bt < $t; Bt += gt)
        yt = ht(ot, Bt, Bt + gt, ut), this.imuln(St), this.words[0] + yt < 67108864 ? this.words[0] += yt : this._iaddn(yt);
      if (vt !== 0) {
        var rr = 1;
        for (yt = ht(ot, Bt, ot.length, ut), Bt = 0; Bt < vt; Bt++)
          rr *= ut;
        this.imuln(rr), this.words[0] + yt < 67108864 ? this.words[0] += yt : this._iaddn(yt);
      }
      this._strip();
    }, ce.prototype.copy = function(ot) {
      ot.words = new Array(this.length);
      for (var ut = 0; ut < this.length; ut++)
        ot.words[ut] = this.words[ut];
      ot.length = this.length, ot.negative = this.negative, ot.red = this.red;
    };
    function it(dt, ot) {
      dt.words = ot.words, dt.length = ot.length, dt.negative = ot.negative, dt.red = ot.red;
    }
    if (ce.prototype._move = function(ot) {
      it(ot, this);
    }, ce.prototype.clone = function() {
      var ot = new ce(null);
      return this.copy(ot), ot;
    }, ce.prototype._expand = function(ot) {
      for (; this.length < ot; )
        this.words[this.length++] = 0;
      return this;
    }, ce.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ce.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        ce.prototype[Symbol.for("nodejs.util.inspect.custom")] = lt;
      } catch {
        ce.prototype.inspect = lt;
      }
    else
      ce.prototype.inspect = lt;
    function lt() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Et = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], wt = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Rt = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ce.prototype.toString = function(ot, ut) {
      ot = ot || 10, ut = ut | 0 || 1;
      var mt;
      if (ot === 16 || ot === "hex") {
        mt = "";
        for (var gt = 0, St = 0, xt = 0; xt < this.length; xt++) {
          var vt = this.words[xt], $t = ((vt << gt | St) & 16777215).toString(16);
          St = vt >>> 24 - gt & 16777215, gt += 2, gt >= 26 && (gt -= 26, xt--), St !== 0 || xt !== this.length - 1 ? mt = Et[6 - $t.length] + $t + mt : mt = $t + mt;
        }
        for (St !== 0 && (mt = St.toString(16) + mt); mt.length % ut !== 0; )
          mt = "0" + mt;
        return this.negative !== 0 && (mt = "-" + mt), mt;
      }
      if (ot === (ot | 0) && ot >= 2 && ot <= 36) {
        var yt = wt[ot], Bt = Rt[ot];
        mt = "";
        var rr = this.clone();
        for (rr.negative = 0; !rr.isZero(); ) {
          var dr = rr.modrn(Bt).toString(ot);
          rr = rr.idivn(Bt), rr.isZero() ? mt = dr + mt : mt = Et[yt - dr.length] + dr + mt;
        }
        for (this.isZero() && (mt = "0" + mt); mt.length % ut !== 0; )
          mt = "0" + mt;
        return this.negative !== 0 && (mt = "-" + mt), mt;
      }
      ne(!1, "Base should be between 2 and 36");
    }, ce.prototype.toNumber = function() {
      var ot = this.words[0];
      return this.length === 2 ? ot += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ot += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ot : ot;
    }, ce.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, Ce && (ce.prototype.toBuffer = function(ot, ut) {
      return this.toArrayLike(Ce, ot, ut);
    }), ce.prototype.toArray = function(ot, ut) {
      return this.toArrayLike(Array, ot, ut);
    };
    var Mt = function(ot, ut) {
      return ot.allocUnsafe ? ot.allocUnsafe(ut) : new ot(ut);
    };
    ce.prototype.toArrayLike = function(ot, ut, mt) {
      this._strip();
      var gt = this.byteLength(), St = mt || Math.max(1, gt);
      ne(gt <= St, "byte array longer than desired length"), ne(St > 0, "Requested array length <= 0");
      var xt = Mt(ot, St), vt = ut === "le" ? "LE" : "BE";
      return this["_toArrayLike" + vt](xt, gt), xt;
    }, ce.prototype._toArrayLikeLE = function(ot, ut) {
      for (var mt = 0, gt = 0, St = 0, xt = 0; St < this.length; St++) {
        var vt = this.words[St] << xt | gt;
        ot[mt++] = vt & 255, mt < ot.length && (ot[mt++] = vt >> 8 & 255), mt < ot.length && (ot[mt++] = vt >> 16 & 255), xt === 6 ? (mt < ot.length && (ot[mt++] = vt >> 24 & 255), gt = 0, xt = 0) : (gt = vt >>> 24, xt += 2);
      }
      if (mt < ot.length)
        for (ot[mt++] = gt; mt < ot.length; )
          ot[mt++] = 0;
    }, ce.prototype._toArrayLikeBE = function(ot, ut) {
      for (var mt = ot.length - 1, gt = 0, St = 0, xt = 0; St < this.length; St++) {
        var vt = this.words[St] << xt | gt;
        ot[mt--] = vt & 255, mt >= 0 && (ot[mt--] = vt >> 8 & 255), mt >= 0 && (ot[mt--] = vt >> 16 & 255), xt === 6 ? (mt >= 0 && (ot[mt--] = vt >> 24 & 255), gt = 0, xt = 0) : (gt = vt >>> 24, xt += 2);
      }
      if (mt >= 0)
        for (ot[mt--] = gt; mt >= 0; )
          ot[mt--] = 0;
    }, Math.clz32 ? ce.prototype._countBits = function(ot) {
      return 32 - Math.clz32(ot);
    } : ce.prototype._countBits = function(ot) {
      var ut = ot, mt = 0;
      return ut >= 4096 && (mt += 13, ut >>>= 13), ut >= 64 && (mt += 7, ut >>>= 7), ut >= 8 && (mt += 4, ut >>>= 4), ut >= 2 && (mt += 2, ut >>>= 2), mt + ut;
    }, ce.prototype._zeroBits = function(ot) {
      if (ot === 0) return 26;
      var ut = ot, mt = 0;
      return ut & 8191 || (mt += 13, ut >>>= 13), ut & 127 || (mt += 7, ut >>>= 7), ut & 15 || (mt += 4, ut >>>= 4), ut & 3 || (mt += 2, ut >>>= 2), ut & 1 || mt++, mt;
    }, ce.prototype.bitLength = function() {
      var ot = this.words[this.length - 1], ut = this._countBits(ot);
      return (this.length - 1) * 26 + ut;
    };
    function Lt(dt) {
      for (var ot = new Array(dt.bitLength()), ut = 0; ut < ot.length; ut++) {
        var mt = ut / 26 | 0, gt = ut % 26;
        ot[ut] = dt.words[mt] >>> gt & 1;
      }
      return ot;
    }
    ce.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ot = 0, ut = 0; ut < this.length; ut++) {
        var mt = this._zeroBits(this.words[ut]);
        if (ot += mt, mt !== 26) break;
      }
      return ot;
    }, ce.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ce.prototype.toTwos = function(ot) {
      return this.negative !== 0 ? this.abs().inotn(ot).iaddn(1) : this.clone();
    }, ce.prototype.fromTwos = function(ot) {
      return this.testn(ot - 1) ? this.notn(ot).iaddn(1).ineg() : this.clone();
    }, ce.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ce.prototype.neg = function() {
      return this.clone().ineg();
    }, ce.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ce.prototype.iuor = function(ot) {
      for (; this.length < ot.length; )
        this.words[this.length++] = 0;
      for (var ut = 0; ut < ot.length; ut++)
        this.words[ut] = this.words[ut] | ot.words[ut];
      return this._strip();
    }, ce.prototype.ior = function(ot) {
      return ne((this.negative | ot.negative) === 0), this.iuor(ot);
    }, ce.prototype.or = function(ot) {
      return this.length > ot.length ? this.clone().ior(ot) : ot.clone().ior(this);
    }, ce.prototype.uor = function(ot) {
      return this.length > ot.length ? this.clone().iuor(ot) : ot.clone().iuor(this);
    }, ce.prototype.iuand = function(ot) {
      var ut;
      this.length > ot.length ? ut = ot : ut = this;
      for (var mt = 0; mt < ut.length; mt++)
        this.words[mt] = this.words[mt] & ot.words[mt];
      return this.length = ut.length, this._strip();
    }, ce.prototype.iand = function(ot) {
      return ne((this.negative | ot.negative) === 0), this.iuand(ot);
    }, ce.prototype.and = function(ot) {
      return this.length > ot.length ? this.clone().iand(ot) : ot.clone().iand(this);
    }, ce.prototype.uand = function(ot) {
      return this.length > ot.length ? this.clone().iuand(ot) : ot.clone().iuand(this);
    }, ce.prototype.iuxor = function(ot) {
      var ut, mt;
      this.length > ot.length ? (ut = this, mt = ot) : (ut = ot, mt = this);
      for (var gt = 0; gt < mt.length; gt++)
        this.words[gt] = ut.words[gt] ^ mt.words[gt];
      if (this !== ut)
        for (; gt < ut.length; gt++)
          this.words[gt] = ut.words[gt];
      return this.length = ut.length, this._strip();
    }, ce.prototype.ixor = function(ot) {
      return ne((this.negative | ot.negative) === 0), this.iuxor(ot);
    }, ce.prototype.xor = function(ot) {
      return this.length > ot.length ? this.clone().ixor(ot) : ot.clone().ixor(this);
    }, ce.prototype.uxor = function(ot) {
      return this.length > ot.length ? this.clone().iuxor(ot) : ot.clone().iuxor(this);
    }, ce.prototype.inotn = function(ot) {
      ne(typeof ot == "number" && ot >= 0);
      var ut = Math.ceil(ot / 26) | 0, mt = ot % 26;
      this._expand(ut), mt > 0 && ut--;
      for (var gt = 0; gt < ut; gt++)
        this.words[gt] = ~this.words[gt] & 67108863;
      return mt > 0 && (this.words[gt] = ~this.words[gt] & 67108863 >> 26 - mt), this._strip();
    }, ce.prototype.notn = function(ot) {
      return this.clone().inotn(ot);
    }, ce.prototype.setn = function(ot, ut) {
      ne(typeof ot == "number" && ot >= 0);
      var mt = ot / 26 | 0, gt = ot % 26;
      return this._expand(mt + 1), ut ? this.words[mt] = this.words[mt] | 1 << gt : this.words[mt] = this.words[mt] & ~(1 << gt), this._strip();
    }, ce.prototype.iadd = function(ot) {
      var ut;
      if (this.negative !== 0 && ot.negative === 0)
        return this.negative = 0, ut = this.isub(ot), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ot.negative !== 0)
        return ot.negative = 0, ut = this.isub(ot), ot.negative = 1, ut._normSign();
      var mt, gt;
      this.length > ot.length ? (mt = this, gt = ot) : (mt = ot, gt = this);
      for (var St = 0, xt = 0; xt < gt.length; xt++)
        ut = (mt.words[xt] | 0) + (gt.words[xt] | 0) + St, this.words[xt] = ut & 67108863, St = ut >>> 26;
      for (; St !== 0 && xt < mt.length; xt++)
        ut = (mt.words[xt] | 0) + St, this.words[xt] = ut & 67108863, St = ut >>> 26;
      if (this.length = mt.length, St !== 0)
        this.words[this.length] = St, this.length++;
      else if (mt !== this)
        for (; xt < mt.length; xt++)
          this.words[xt] = mt.words[xt];
      return this;
    }, ce.prototype.add = function(ot) {
      var ut;
      return ot.negative !== 0 && this.negative === 0 ? (ot.negative = 0, ut = this.sub(ot), ot.negative ^= 1, ut) : ot.negative === 0 && this.negative !== 0 ? (this.negative = 0, ut = ot.sub(this), this.negative = 1, ut) : this.length > ot.length ? this.clone().iadd(ot) : ot.clone().iadd(this);
    }, ce.prototype.isub = function(ot) {
      if (ot.negative !== 0) {
        ot.negative = 0;
        var ut = this.iadd(ot);
        return ot.negative = 1, ut._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ot), this.negative = 1, this._normSign();
      var mt = this.cmp(ot);
      if (mt === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var gt, St;
      mt > 0 ? (gt = this, St = ot) : (gt = ot, St = this);
      for (var xt = 0, vt = 0; vt < St.length; vt++)
        ut = (gt.words[vt] | 0) - (St.words[vt] | 0) + xt, xt = ut >> 26, this.words[vt] = ut & 67108863;
      for (; xt !== 0 && vt < gt.length; vt++)
        ut = (gt.words[vt] | 0) + xt, xt = ut >> 26, this.words[vt] = ut & 67108863;
      if (xt === 0 && vt < gt.length && gt !== this)
        for (; vt < gt.length; vt++)
          this.words[vt] = gt.words[vt];
      return this.length = Math.max(this.length, vt), gt !== this && (this.negative = 1), this._strip();
    }, ce.prototype.sub = function(ot) {
      return this.clone().isub(ot);
    };
    function zt(dt, ot, ut) {
      ut.negative = ot.negative ^ dt.negative;
      var mt = dt.length + ot.length | 0;
      ut.length = mt, mt = mt - 1 | 0;
      var gt = dt.words[0] | 0, St = ot.words[0] | 0, xt = gt * St, vt = xt & 67108863, $t = xt / 67108864 | 0;
      ut.words[0] = vt;
      for (var yt = 1; yt < mt; yt++) {
        for (var Bt = $t >>> 26, rr = $t & 67108863, dr = Math.min(yt, ot.length - 1), tr = Math.max(0, yt - dt.length + 1); tr <= dr; tr++) {
          var Dt = yt - tr | 0;
          gt = dt.words[Dt] | 0, St = ot.words[tr] | 0, xt = gt * St + rr, Bt += xt / 67108864 | 0, rr = xt & 67108863;
        }
        ut.words[yt] = rr | 0, $t = Bt | 0;
      }
      return $t !== 0 ? ut.words[yt] = $t | 0 : ut.length--, ut._strip();
    }
    var Ot = function(ot, ut, mt) {
      var gt = ot.words, St = ut.words, xt = mt.words, vt = 0, $t, yt, Bt, rr = gt[0] | 0, dr = rr & 8191, tr = rr >>> 13, Dt = gt[1] | 0, Wt = Dt & 8191, or = Dt >>> 13, _r = gt[2] | 0, Xt = _r & 8191, Qt = _r >>> 13, br = gt[3] | 0, Dr = br & 8191, Vr = br >>> 13, Zr = gt[4] | 0, ln = Zr & 8191, _n = Zr >>> 13, Mr = gt[5] | 0, Wn = Mr & 8191, xn = Mr >>> 13, ni = gt[6] | 0, Gn = ni & 8191, En = ni >>> 13, Pn = gt[7] | 0, ti = Pn & 8191, gn = Pn >>> 13, Kn = gt[8] | 0, gi = Kn & 8191, Gt = Kn >>> 13, At = gt[9] | 0, kt = At & 8191, Zt = At >>> 13, pr = St[0] | 0, Sr = pr & 8191, Tr = pr >>> 13, fn = St[1] | 0, On = fn & 8191, tn = fn >>> 13, In = St[2] | 0, hn = In & 8191, cn = In >>> 13, ci = St[3] | 0, pi = ci & 8191, ur = ci >>> 13, ir = St[4] | 0, lr = ir & 8191, gr = ir >>> 13, Ar = St[5] | 0, Fr = Ar & 8191, jr = Ar >>> 13, Xr = St[6] | 0, pn = Xr & 8191, Yr = Xr >>> 13, vn = St[7] | 0, Cn = vn & 8191, dn = vn >>> 13, fr = St[8] | 0, Nr = fr & 8191, Ir = fr >>> 13, sn = St[9] | 0, Tn = sn & 8191, kn = sn >>> 13;
      mt.negative = ot.negative ^ ut.negative, mt.length = 19, $t = Math.imul(dr, Sr), yt = Math.imul(dr, Tr), yt = yt + Math.imul(tr, Sr) | 0, Bt = Math.imul(tr, Tr);
      var Dn = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, $t = Math.imul(Wt, Sr), yt = Math.imul(Wt, Tr), yt = yt + Math.imul(or, Sr) | 0, Bt = Math.imul(or, Tr), $t = $t + Math.imul(dr, On) | 0, yt = yt + Math.imul(dr, tn) | 0, yt = yt + Math.imul(tr, On) | 0, Bt = Bt + Math.imul(tr, tn) | 0;
      var Jn = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Jn >>> 26) | 0, Jn &= 67108863, $t = Math.imul(Xt, Sr), yt = Math.imul(Xt, Tr), yt = yt + Math.imul(Qt, Sr) | 0, Bt = Math.imul(Qt, Tr), $t = $t + Math.imul(Wt, On) | 0, yt = yt + Math.imul(Wt, tn) | 0, yt = yt + Math.imul(or, On) | 0, Bt = Bt + Math.imul(or, tn) | 0, $t = $t + Math.imul(dr, hn) | 0, yt = yt + Math.imul(dr, cn) | 0, yt = yt + Math.imul(tr, hn) | 0, Bt = Bt + Math.imul(tr, cn) | 0;
      var Ti = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Ti >>> 26) | 0, Ti &= 67108863, $t = Math.imul(Dr, Sr), yt = Math.imul(Dr, Tr), yt = yt + Math.imul(Vr, Sr) | 0, Bt = Math.imul(Vr, Tr), $t = $t + Math.imul(Xt, On) | 0, yt = yt + Math.imul(Xt, tn) | 0, yt = yt + Math.imul(Qt, On) | 0, Bt = Bt + Math.imul(Qt, tn) | 0, $t = $t + Math.imul(Wt, hn) | 0, yt = yt + Math.imul(Wt, cn) | 0, yt = yt + Math.imul(or, hn) | 0, Bt = Bt + Math.imul(or, cn) | 0, $t = $t + Math.imul(dr, pi) | 0, yt = yt + Math.imul(dr, ur) | 0, yt = yt + Math.imul(tr, pi) | 0, Bt = Bt + Math.imul(tr, ur) | 0;
      var _i = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (_i >>> 26) | 0, _i &= 67108863, $t = Math.imul(ln, Sr), yt = Math.imul(ln, Tr), yt = yt + Math.imul(_n, Sr) | 0, Bt = Math.imul(_n, Tr), $t = $t + Math.imul(Dr, On) | 0, yt = yt + Math.imul(Dr, tn) | 0, yt = yt + Math.imul(Vr, On) | 0, Bt = Bt + Math.imul(Vr, tn) | 0, $t = $t + Math.imul(Xt, hn) | 0, yt = yt + Math.imul(Xt, cn) | 0, yt = yt + Math.imul(Qt, hn) | 0, Bt = Bt + Math.imul(Qt, cn) | 0, $t = $t + Math.imul(Wt, pi) | 0, yt = yt + Math.imul(Wt, ur) | 0, yt = yt + Math.imul(or, pi) | 0, Bt = Bt + Math.imul(or, ur) | 0, $t = $t + Math.imul(dr, lr) | 0, yt = yt + Math.imul(dr, gr) | 0, yt = yt + Math.imul(tr, lr) | 0, Bt = Bt + Math.imul(tr, gr) | 0;
      var Ri = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Ri >>> 26) | 0, Ri &= 67108863, $t = Math.imul(Wn, Sr), yt = Math.imul(Wn, Tr), yt = yt + Math.imul(xn, Sr) | 0, Bt = Math.imul(xn, Tr), $t = $t + Math.imul(ln, On) | 0, yt = yt + Math.imul(ln, tn) | 0, yt = yt + Math.imul(_n, On) | 0, Bt = Bt + Math.imul(_n, tn) | 0, $t = $t + Math.imul(Dr, hn) | 0, yt = yt + Math.imul(Dr, cn) | 0, yt = yt + Math.imul(Vr, hn) | 0, Bt = Bt + Math.imul(Vr, cn) | 0, $t = $t + Math.imul(Xt, pi) | 0, yt = yt + Math.imul(Xt, ur) | 0, yt = yt + Math.imul(Qt, pi) | 0, Bt = Bt + Math.imul(Qt, ur) | 0, $t = $t + Math.imul(Wt, lr) | 0, yt = yt + Math.imul(Wt, gr) | 0, yt = yt + Math.imul(or, lr) | 0, Bt = Bt + Math.imul(or, gr) | 0, $t = $t + Math.imul(dr, Fr) | 0, yt = yt + Math.imul(dr, jr) | 0, yt = yt + Math.imul(tr, Fr) | 0, Bt = Bt + Math.imul(tr, jr) | 0;
      var Qi = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, $t = Math.imul(Gn, Sr), yt = Math.imul(Gn, Tr), yt = yt + Math.imul(En, Sr) | 0, Bt = Math.imul(En, Tr), $t = $t + Math.imul(Wn, On) | 0, yt = yt + Math.imul(Wn, tn) | 0, yt = yt + Math.imul(xn, On) | 0, Bt = Bt + Math.imul(xn, tn) | 0, $t = $t + Math.imul(ln, hn) | 0, yt = yt + Math.imul(ln, cn) | 0, yt = yt + Math.imul(_n, hn) | 0, Bt = Bt + Math.imul(_n, cn) | 0, $t = $t + Math.imul(Dr, pi) | 0, yt = yt + Math.imul(Dr, ur) | 0, yt = yt + Math.imul(Vr, pi) | 0, Bt = Bt + Math.imul(Vr, ur) | 0, $t = $t + Math.imul(Xt, lr) | 0, yt = yt + Math.imul(Xt, gr) | 0, yt = yt + Math.imul(Qt, lr) | 0, Bt = Bt + Math.imul(Qt, gr) | 0, $t = $t + Math.imul(Wt, Fr) | 0, yt = yt + Math.imul(Wt, jr) | 0, yt = yt + Math.imul(or, Fr) | 0, Bt = Bt + Math.imul(or, jr) | 0, $t = $t + Math.imul(dr, pn) | 0, yt = yt + Math.imul(dr, Yr) | 0, yt = yt + Math.imul(tr, pn) | 0, Bt = Bt + Math.imul(tr, Yr) | 0;
      var Ca = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Ca >>> 26) | 0, Ca &= 67108863, $t = Math.imul(ti, Sr), yt = Math.imul(ti, Tr), yt = yt + Math.imul(gn, Sr) | 0, Bt = Math.imul(gn, Tr), $t = $t + Math.imul(Gn, On) | 0, yt = yt + Math.imul(Gn, tn) | 0, yt = yt + Math.imul(En, On) | 0, Bt = Bt + Math.imul(En, tn) | 0, $t = $t + Math.imul(Wn, hn) | 0, yt = yt + Math.imul(Wn, cn) | 0, yt = yt + Math.imul(xn, hn) | 0, Bt = Bt + Math.imul(xn, cn) | 0, $t = $t + Math.imul(ln, pi) | 0, yt = yt + Math.imul(ln, ur) | 0, yt = yt + Math.imul(_n, pi) | 0, Bt = Bt + Math.imul(_n, ur) | 0, $t = $t + Math.imul(Dr, lr) | 0, yt = yt + Math.imul(Dr, gr) | 0, yt = yt + Math.imul(Vr, lr) | 0, Bt = Bt + Math.imul(Vr, gr) | 0, $t = $t + Math.imul(Xt, Fr) | 0, yt = yt + Math.imul(Xt, jr) | 0, yt = yt + Math.imul(Qt, Fr) | 0, Bt = Bt + Math.imul(Qt, jr) | 0, $t = $t + Math.imul(Wt, pn) | 0, yt = yt + Math.imul(Wt, Yr) | 0, yt = yt + Math.imul(or, pn) | 0, Bt = Bt + Math.imul(or, Yr) | 0, $t = $t + Math.imul(dr, Cn) | 0, yt = yt + Math.imul(dr, dn) | 0, yt = yt + Math.imul(tr, Cn) | 0, Bt = Bt + Math.imul(tr, dn) | 0;
      var vi = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, $t = Math.imul(gi, Sr), yt = Math.imul(gi, Tr), yt = yt + Math.imul(Gt, Sr) | 0, Bt = Math.imul(Gt, Tr), $t = $t + Math.imul(ti, On) | 0, yt = yt + Math.imul(ti, tn) | 0, yt = yt + Math.imul(gn, On) | 0, Bt = Bt + Math.imul(gn, tn) | 0, $t = $t + Math.imul(Gn, hn) | 0, yt = yt + Math.imul(Gn, cn) | 0, yt = yt + Math.imul(En, hn) | 0, Bt = Bt + Math.imul(En, cn) | 0, $t = $t + Math.imul(Wn, pi) | 0, yt = yt + Math.imul(Wn, ur) | 0, yt = yt + Math.imul(xn, pi) | 0, Bt = Bt + Math.imul(xn, ur) | 0, $t = $t + Math.imul(ln, lr) | 0, yt = yt + Math.imul(ln, gr) | 0, yt = yt + Math.imul(_n, lr) | 0, Bt = Bt + Math.imul(_n, gr) | 0, $t = $t + Math.imul(Dr, Fr) | 0, yt = yt + Math.imul(Dr, jr) | 0, yt = yt + Math.imul(Vr, Fr) | 0, Bt = Bt + Math.imul(Vr, jr) | 0, $t = $t + Math.imul(Xt, pn) | 0, yt = yt + Math.imul(Xt, Yr) | 0, yt = yt + Math.imul(Qt, pn) | 0, Bt = Bt + Math.imul(Qt, Yr) | 0, $t = $t + Math.imul(Wt, Cn) | 0, yt = yt + Math.imul(Wt, dn) | 0, yt = yt + Math.imul(or, Cn) | 0, Bt = Bt + Math.imul(or, dn) | 0, $t = $t + Math.imul(dr, Nr) | 0, yt = yt + Math.imul(dr, Ir) | 0, yt = yt + Math.imul(tr, Nr) | 0, Bt = Bt + Math.imul(tr, Ir) | 0;
      var Wi = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Wi >>> 26) | 0, Wi &= 67108863, $t = Math.imul(kt, Sr), yt = Math.imul(kt, Tr), yt = yt + Math.imul(Zt, Sr) | 0, Bt = Math.imul(Zt, Tr), $t = $t + Math.imul(gi, On) | 0, yt = yt + Math.imul(gi, tn) | 0, yt = yt + Math.imul(Gt, On) | 0, Bt = Bt + Math.imul(Gt, tn) | 0, $t = $t + Math.imul(ti, hn) | 0, yt = yt + Math.imul(ti, cn) | 0, yt = yt + Math.imul(gn, hn) | 0, Bt = Bt + Math.imul(gn, cn) | 0, $t = $t + Math.imul(Gn, pi) | 0, yt = yt + Math.imul(Gn, ur) | 0, yt = yt + Math.imul(En, pi) | 0, Bt = Bt + Math.imul(En, ur) | 0, $t = $t + Math.imul(Wn, lr) | 0, yt = yt + Math.imul(Wn, gr) | 0, yt = yt + Math.imul(xn, lr) | 0, Bt = Bt + Math.imul(xn, gr) | 0, $t = $t + Math.imul(ln, Fr) | 0, yt = yt + Math.imul(ln, jr) | 0, yt = yt + Math.imul(_n, Fr) | 0, Bt = Bt + Math.imul(_n, jr) | 0, $t = $t + Math.imul(Dr, pn) | 0, yt = yt + Math.imul(Dr, Yr) | 0, yt = yt + Math.imul(Vr, pn) | 0, Bt = Bt + Math.imul(Vr, Yr) | 0, $t = $t + Math.imul(Xt, Cn) | 0, yt = yt + Math.imul(Xt, dn) | 0, yt = yt + Math.imul(Qt, Cn) | 0, Bt = Bt + Math.imul(Qt, dn) | 0, $t = $t + Math.imul(Wt, Nr) | 0, yt = yt + Math.imul(Wt, Ir) | 0, yt = yt + Math.imul(or, Nr) | 0, Bt = Bt + Math.imul(or, Ir) | 0, $t = $t + Math.imul(dr, Tn) | 0, yt = yt + Math.imul(dr, kn) | 0, yt = yt + Math.imul(tr, Tn) | 0, Bt = Bt + Math.imul(tr, kn) | 0;
      var ra = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (ra >>> 26) | 0, ra &= 67108863, $t = Math.imul(kt, On), yt = Math.imul(kt, tn), yt = yt + Math.imul(Zt, On) | 0, Bt = Math.imul(Zt, tn), $t = $t + Math.imul(gi, hn) | 0, yt = yt + Math.imul(gi, cn) | 0, yt = yt + Math.imul(Gt, hn) | 0, Bt = Bt + Math.imul(Gt, cn) | 0, $t = $t + Math.imul(ti, pi) | 0, yt = yt + Math.imul(ti, ur) | 0, yt = yt + Math.imul(gn, pi) | 0, Bt = Bt + Math.imul(gn, ur) | 0, $t = $t + Math.imul(Gn, lr) | 0, yt = yt + Math.imul(Gn, gr) | 0, yt = yt + Math.imul(En, lr) | 0, Bt = Bt + Math.imul(En, gr) | 0, $t = $t + Math.imul(Wn, Fr) | 0, yt = yt + Math.imul(Wn, jr) | 0, yt = yt + Math.imul(xn, Fr) | 0, Bt = Bt + Math.imul(xn, jr) | 0, $t = $t + Math.imul(ln, pn) | 0, yt = yt + Math.imul(ln, Yr) | 0, yt = yt + Math.imul(_n, pn) | 0, Bt = Bt + Math.imul(_n, Yr) | 0, $t = $t + Math.imul(Dr, Cn) | 0, yt = yt + Math.imul(Dr, dn) | 0, yt = yt + Math.imul(Vr, Cn) | 0, Bt = Bt + Math.imul(Vr, dn) | 0, $t = $t + Math.imul(Xt, Nr) | 0, yt = yt + Math.imul(Xt, Ir) | 0, yt = yt + Math.imul(Qt, Nr) | 0, Bt = Bt + Math.imul(Qt, Ir) | 0, $t = $t + Math.imul(Wt, Tn) | 0, yt = yt + Math.imul(Wt, kn) | 0, yt = yt + Math.imul(or, Tn) | 0, Bt = Bt + Math.imul(or, kn) | 0;
      var ii = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (ii >>> 26) | 0, ii &= 67108863, $t = Math.imul(kt, hn), yt = Math.imul(kt, cn), yt = yt + Math.imul(Zt, hn) | 0, Bt = Math.imul(Zt, cn), $t = $t + Math.imul(gi, pi) | 0, yt = yt + Math.imul(gi, ur) | 0, yt = yt + Math.imul(Gt, pi) | 0, Bt = Bt + Math.imul(Gt, ur) | 0, $t = $t + Math.imul(ti, lr) | 0, yt = yt + Math.imul(ti, gr) | 0, yt = yt + Math.imul(gn, lr) | 0, Bt = Bt + Math.imul(gn, gr) | 0, $t = $t + Math.imul(Gn, Fr) | 0, yt = yt + Math.imul(Gn, jr) | 0, yt = yt + Math.imul(En, Fr) | 0, Bt = Bt + Math.imul(En, jr) | 0, $t = $t + Math.imul(Wn, pn) | 0, yt = yt + Math.imul(Wn, Yr) | 0, yt = yt + Math.imul(xn, pn) | 0, Bt = Bt + Math.imul(xn, Yr) | 0, $t = $t + Math.imul(ln, Cn) | 0, yt = yt + Math.imul(ln, dn) | 0, yt = yt + Math.imul(_n, Cn) | 0, Bt = Bt + Math.imul(_n, dn) | 0, $t = $t + Math.imul(Dr, Nr) | 0, yt = yt + Math.imul(Dr, Ir) | 0, yt = yt + Math.imul(Vr, Nr) | 0, Bt = Bt + Math.imul(Vr, Ir) | 0, $t = $t + Math.imul(Xt, Tn) | 0, yt = yt + Math.imul(Xt, kn) | 0, yt = yt + Math.imul(Qt, Tn) | 0, Bt = Bt + Math.imul(Qt, kn) | 0;
      var ma = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (ma >>> 26) | 0, ma &= 67108863, $t = Math.imul(kt, pi), yt = Math.imul(kt, ur), yt = yt + Math.imul(Zt, pi) | 0, Bt = Math.imul(Zt, ur), $t = $t + Math.imul(gi, lr) | 0, yt = yt + Math.imul(gi, gr) | 0, yt = yt + Math.imul(Gt, lr) | 0, Bt = Bt + Math.imul(Gt, gr) | 0, $t = $t + Math.imul(ti, Fr) | 0, yt = yt + Math.imul(ti, jr) | 0, yt = yt + Math.imul(gn, Fr) | 0, Bt = Bt + Math.imul(gn, jr) | 0, $t = $t + Math.imul(Gn, pn) | 0, yt = yt + Math.imul(Gn, Yr) | 0, yt = yt + Math.imul(En, pn) | 0, Bt = Bt + Math.imul(En, Yr) | 0, $t = $t + Math.imul(Wn, Cn) | 0, yt = yt + Math.imul(Wn, dn) | 0, yt = yt + Math.imul(xn, Cn) | 0, Bt = Bt + Math.imul(xn, dn) | 0, $t = $t + Math.imul(ln, Nr) | 0, yt = yt + Math.imul(ln, Ir) | 0, yt = yt + Math.imul(_n, Nr) | 0, Bt = Bt + Math.imul(_n, Ir) | 0, $t = $t + Math.imul(Dr, Tn) | 0, yt = yt + Math.imul(Dr, kn) | 0, yt = yt + Math.imul(Vr, Tn) | 0, Bt = Bt + Math.imul(Vr, kn) | 0;
      var Ga = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Ga >>> 26) | 0, Ga &= 67108863, $t = Math.imul(kt, lr), yt = Math.imul(kt, gr), yt = yt + Math.imul(Zt, lr) | 0, Bt = Math.imul(Zt, gr), $t = $t + Math.imul(gi, Fr) | 0, yt = yt + Math.imul(gi, jr) | 0, yt = yt + Math.imul(Gt, Fr) | 0, Bt = Bt + Math.imul(Gt, jr) | 0, $t = $t + Math.imul(ti, pn) | 0, yt = yt + Math.imul(ti, Yr) | 0, yt = yt + Math.imul(gn, pn) | 0, Bt = Bt + Math.imul(gn, Yr) | 0, $t = $t + Math.imul(Gn, Cn) | 0, yt = yt + Math.imul(Gn, dn) | 0, yt = yt + Math.imul(En, Cn) | 0, Bt = Bt + Math.imul(En, dn) | 0, $t = $t + Math.imul(Wn, Nr) | 0, yt = yt + Math.imul(Wn, Ir) | 0, yt = yt + Math.imul(xn, Nr) | 0, Bt = Bt + Math.imul(xn, Ir) | 0, $t = $t + Math.imul(ln, Tn) | 0, yt = yt + Math.imul(ln, kn) | 0, yt = yt + Math.imul(_n, Tn) | 0, Bt = Bt + Math.imul(_n, kn) | 0;
      var po = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (po >>> 26) | 0, po &= 67108863, $t = Math.imul(kt, Fr), yt = Math.imul(kt, jr), yt = yt + Math.imul(Zt, Fr) | 0, Bt = Math.imul(Zt, jr), $t = $t + Math.imul(gi, pn) | 0, yt = yt + Math.imul(gi, Yr) | 0, yt = yt + Math.imul(Gt, pn) | 0, Bt = Bt + Math.imul(Gt, Yr) | 0, $t = $t + Math.imul(ti, Cn) | 0, yt = yt + Math.imul(ti, dn) | 0, yt = yt + Math.imul(gn, Cn) | 0, Bt = Bt + Math.imul(gn, dn) | 0, $t = $t + Math.imul(Gn, Nr) | 0, yt = yt + Math.imul(Gn, Ir) | 0, yt = yt + Math.imul(En, Nr) | 0, Bt = Bt + Math.imul(En, Ir) | 0, $t = $t + Math.imul(Wn, Tn) | 0, yt = yt + Math.imul(Wn, kn) | 0, yt = yt + Math.imul(xn, Tn) | 0, Bt = Bt + Math.imul(xn, kn) | 0;
      var Xa = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, $t = Math.imul(kt, pn), yt = Math.imul(kt, Yr), yt = yt + Math.imul(Zt, pn) | 0, Bt = Math.imul(Zt, Yr), $t = $t + Math.imul(gi, Cn) | 0, yt = yt + Math.imul(gi, dn) | 0, yt = yt + Math.imul(Gt, Cn) | 0, Bt = Bt + Math.imul(Gt, dn) | 0, $t = $t + Math.imul(ti, Nr) | 0, yt = yt + Math.imul(ti, Ir) | 0, yt = yt + Math.imul(gn, Nr) | 0, Bt = Bt + Math.imul(gn, Ir) | 0, $t = $t + Math.imul(Gn, Tn) | 0, yt = yt + Math.imul(Gn, kn) | 0, yt = yt + Math.imul(En, Tn) | 0, Bt = Bt + Math.imul(En, kn) | 0;
      var sa = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (sa >>> 26) | 0, sa &= 67108863, $t = Math.imul(kt, Cn), yt = Math.imul(kt, dn), yt = yt + Math.imul(Zt, Cn) | 0, Bt = Math.imul(Zt, dn), $t = $t + Math.imul(gi, Nr) | 0, yt = yt + Math.imul(gi, Ir) | 0, yt = yt + Math.imul(Gt, Nr) | 0, Bt = Bt + Math.imul(Gt, Ir) | 0, $t = $t + Math.imul(ti, Tn) | 0, yt = yt + Math.imul(ti, kn) | 0, yt = yt + Math.imul(gn, Tn) | 0, Bt = Bt + Math.imul(gn, kn) | 0;
      var Oo = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Oo >>> 26) | 0, Oo &= 67108863, $t = Math.imul(kt, Nr), yt = Math.imul(kt, Ir), yt = yt + Math.imul(Zt, Nr) | 0, Bt = Math.imul(Zt, Ir), $t = $t + Math.imul(gi, Tn) | 0, yt = yt + Math.imul(gi, kn) | 0, yt = yt + Math.imul(Gt, Tn) | 0, Bt = Bt + Math.imul(Gt, kn) | 0;
      var Sa = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      vt = (Bt + (yt >>> 13) | 0) + (Sa >>> 26) | 0, Sa &= 67108863, $t = Math.imul(kt, Tn), yt = Math.imul(kt, kn), yt = yt + Math.imul(Zt, Tn) | 0, Bt = Math.imul(Zt, kn);
      var Ls = (vt + $t | 0) + ((yt & 8191) << 13) | 0;
      return vt = (Bt + (yt >>> 13) | 0) + (Ls >>> 26) | 0, Ls &= 67108863, xt[0] = Dn, xt[1] = Jn, xt[2] = Ti, xt[3] = _i, xt[4] = Ri, xt[5] = Qi, xt[6] = Ca, xt[7] = vi, xt[8] = Wi, xt[9] = ra, xt[10] = ii, xt[11] = ma, xt[12] = Ga, xt[13] = po, xt[14] = Xa, xt[15] = sa, xt[16] = Oo, xt[17] = Sa, xt[18] = Ls, vt !== 0 && (xt[19] = vt, mt.length++), mt;
    };
    Math.imul || (Ot = zt);
    function It(dt, ot, ut) {
      ut.negative = ot.negative ^ dt.negative, ut.length = dt.length + ot.length;
      for (var mt = 0, gt = 0, St = 0; St < ut.length - 1; St++) {
        var xt = gt;
        gt = 0;
        for (var vt = mt & 67108863, $t = Math.min(St, ot.length - 1), yt = Math.max(0, St - dt.length + 1); yt <= $t; yt++) {
          var Bt = St - yt, rr = dt.words[Bt] | 0, dr = ot.words[yt] | 0, tr = rr * dr, Dt = tr & 67108863;
          xt = xt + (tr / 67108864 | 0) | 0, Dt = Dt + vt | 0, vt = Dt & 67108863, xt = xt + (Dt >>> 26) | 0, gt += xt >>> 26, xt &= 67108863;
        }
        ut.words[St] = vt, mt = xt, xt = gt;
      }
      return mt !== 0 ? ut.words[St] = mt : ut.length--, ut._strip();
    }
    function Ft(dt, ot, ut) {
      return It(dt, ot, ut);
    }
    ce.prototype.mulTo = function(ot, ut) {
      var mt, gt = this.length + ot.length;
      return this.length === 10 && ot.length === 10 ? mt = Ot(this, ot, ut) : gt < 63 ? mt = zt(this, ot, ut) : gt < 1024 ? mt = It(this, ot, ut) : mt = Ft(this, ot, ut), mt;
    }, ce.prototype.mul = function(ot) {
      var ut = new ce(null);
      return ut.words = new Array(this.length + ot.length), this.mulTo(ot, ut);
    }, ce.prototype.mulf = function(ot) {
      var ut = new ce(null);
      return ut.words = new Array(this.length + ot.length), Ft(this, ot, ut);
    }, ce.prototype.imul = function(ot) {
      return this.clone().mulTo(ot, this);
    }, ce.prototype.imuln = function(ot) {
      var ut = ot < 0;
      ut && (ot = -ot), ne(typeof ot == "number"), ne(ot < 67108864);
      for (var mt = 0, gt = 0; gt < this.length; gt++) {
        var St = (this.words[gt] | 0) * ot, xt = (St & 67108863) + (mt & 67108863);
        mt >>= 26, mt += St / 67108864 | 0, mt += xt >>> 26, this.words[gt] = xt & 67108863;
      }
      return mt !== 0 && (this.words[gt] = mt, this.length++), ut ? this.ineg() : this;
    }, ce.prototype.muln = function(ot) {
      return this.clone().imuln(ot);
    }, ce.prototype.sqr = function() {
      return this.mul(this);
    }, ce.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ce.prototype.pow = function(ot) {
      var ut = Lt(ot);
      if (ut.length === 0) return new ce(1);
      for (var mt = this, gt = 0; gt < ut.length && ut[gt] === 0; gt++, mt = mt.sqr())
        ;
      if (++gt < ut.length)
        for (var St = mt.sqr(); gt < ut.length; gt++, St = St.sqr())
          ut[gt] !== 0 && (mt = mt.mul(St));
      return mt;
    }, ce.prototype.iushln = function(ot) {
      ne(typeof ot == "number" && ot >= 0);
      var ut = ot % 26, mt = (ot - ut) / 26, gt = 67108863 >>> 26 - ut << 26 - ut, St;
      if (ut !== 0) {
        var xt = 0;
        for (St = 0; St < this.length; St++) {
          var vt = this.words[St] & gt, $t = (this.words[St] | 0) - vt << ut;
          this.words[St] = $t | xt, xt = vt >>> 26 - ut;
        }
        xt && (this.words[St] = xt, this.length++);
      }
      if (mt !== 0) {
        for (St = this.length - 1; St >= 0; St--)
          this.words[St + mt] = this.words[St];
        for (St = 0; St < mt; St++)
          this.words[St] = 0;
        this.length += mt;
      }
      return this._strip();
    }, ce.prototype.ishln = function(ot) {
      return ne(this.negative === 0), this.iushln(ot);
    }, ce.prototype.iushrn = function(ot, ut, mt) {
      ne(typeof ot == "number" && ot >= 0);
      var gt;
      ut ? gt = (ut - ut % 26) / 26 : gt = 0;
      var St = ot % 26, xt = Math.min((ot - St) / 26, this.length), vt = 67108863 ^ 67108863 >>> St << St, $t = mt;
      if (gt -= xt, gt = Math.max(0, gt), $t) {
        for (var yt = 0; yt < xt; yt++)
          $t.words[yt] = this.words[yt];
        $t.length = xt;
      }
      if (xt !== 0) if (this.length > xt)
        for (this.length -= xt, yt = 0; yt < this.length; yt++)
          this.words[yt] = this.words[yt + xt];
      else
        this.words[0] = 0, this.length = 1;
      var Bt = 0;
      for (yt = this.length - 1; yt >= 0 && (Bt !== 0 || yt >= gt); yt--) {
        var rr = this.words[yt] | 0;
        this.words[yt] = Bt << 26 - St | rr >>> St, Bt = rr & vt;
      }
      return $t && Bt !== 0 && ($t.words[$t.length++] = Bt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, ce.prototype.ishrn = function(ot, ut, mt) {
      return ne(this.negative === 0), this.iushrn(ot, ut, mt);
    }, ce.prototype.shln = function(ot) {
      return this.clone().ishln(ot);
    }, ce.prototype.ushln = function(ot) {
      return this.clone().iushln(ot);
    }, ce.prototype.shrn = function(ot) {
      return this.clone().ishrn(ot);
    }, ce.prototype.ushrn = function(ot) {
      return this.clone().iushrn(ot);
    }, ce.prototype.testn = function(ot) {
      ne(typeof ot == "number" && ot >= 0);
      var ut = ot % 26, mt = (ot - ut) / 26, gt = 1 << ut;
      if (this.length <= mt) return !1;
      var St = this.words[mt];
      return !!(St & gt);
    }, ce.prototype.imaskn = function(ot) {
      ne(typeof ot == "number" && ot >= 0);
      var ut = ot % 26, mt = (ot - ut) / 26;
      if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= mt)
        return this;
      if (ut !== 0 && mt++, this.length = Math.min(mt, this.length), ut !== 0) {
        var gt = 67108863 ^ 67108863 >>> ut << ut;
        this.words[this.length - 1] &= gt;
      }
      return this._strip();
    }, ce.prototype.maskn = function(ot) {
      return this.clone().imaskn(ot);
    }, ce.prototype.iaddn = function(ot) {
      return ne(typeof ot == "number"), ne(ot < 67108864), ot < 0 ? this.isubn(-ot) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ot ? (this.words[0] = ot - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ot), this.negative = 1, this) : this._iaddn(ot);
    }, ce.prototype._iaddn = function(ot) {
      this.words[0] += ot;
      for (var ut = 0; ut < this.length && this.words[ut] >= 67108864; ut++)
        this.words[ut] -= 67108864, ut === this.length - 1 ? this.words[ut + 1] = 1 : this.words[ut + 1]++;
      return this.length = Math.max(this.length, ut + 1), this;
    }, ce.prototype.isubn = function(ot) {
      if (ne(typeof ot == "number"), ne(ot < 67108864), ot < 0) return this.iaddn(-ot);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ot), this.negative = 1, this;
      if (this.words[0] -= ot, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var ut = 0; ut < this.length && this.words[ut] < 0; ut++)
          this.words[ut] += 67108864, this.words[ut + 1] -= 1;
      return this._strip();
    }, ce.prototype.addn = function(ot) {
      return this.clone().iaddn(ot);
    }, ce.prototype.subn = function(ot) {
      return this.clone().isubn(ot);
    }, ce.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ce.prototype.abs = function() {
      return this.clone().iabs();
    }, ce.prototype._ishlnsubmul = function(ot, ut, mt) {
      var gt = ot.length + mt, St;
      this._expand(gt);
      var xt, vt = 0;
      for (St = 0; St < ot.length; St++) {
        xt = (this.words[St + mt] | 0) + vt;
        var $t = (ot.words[St] | 0) * ut;
        xt -= $t & 67108863, vt = (xt >> 26) - ($t / 67108864 | 0), this.words[St + mt] = xt & 67108863;
      }
      for (; St < this.length - mt; St++)
        xt = (this.words[St + mt] | 0) + vt, vt = xt >> 26, this.words[St + mt] = xt & 67108863;
      if (vt === 0) return this._strip();
      for (ne(vt === -1), vt = 0, St = 0; St < this.length; St++)
        xt = -(this.words[St] | 0) + vt, vt = xt >> 26, this.words[St] = xt & 67108863;
      return this.negative = 1, this._strip();
    }, ce.prototype._wordDiv = function(ot, ut) {
      var mt = this.length - ot.length, gt = this.clone(), St = ot, xt = St.words[St.length - 1] | 0, vt = this._countBits(xt);
      mt = 26 - vt, mt !== 0 && (St = St.ushln(mt), gt.iushln(mt), xt = St.words[St.length - 1] | 0);
      var $t = gt.length - St.length, yt;
      if (ut !== "mod") {
        yt = new ce(null), yt.length = $t + 1, yt.words = new Array(yt.length);
        for (var Bt = 0; Bt < yt.length; Bt++)
          yt.words[Bt] = 0;
      }
      var rr = gt.clone()._ishlnsubmul(St, 1, $t);
      rr.negative === 0 && (gt = rr, yt && (yt.words[$t] = 1));
      for (var dr = $t - 1; dr >= 0; dr--) {
        var tr = (gt.words[St.length + dr] | 0) * 67108864 + (gt.words[St.length + dr - 1] | 0);
        for (tr = Math.min(tr / xt | 0, 67108863), gt._ishlnsubmul(St, tr, dr); gt.negative !== 0; )
          tr--, gt.negative = 0, gt._ishlnsubmul(St, 1, dr), gt.isZero() || (gt.negative ^= 1);
        yt && (yt.words[dr] = tr);
      }
      return yt && yt._strip(), gt._strip(), ut !== "div" && mt !== 0 && gt.iushrn(mt), {
        div: yt || null,
        mod: gt
      };
    }, ce.prototype.divmod = function(ot, ut, mt) {
      if (ne(!ot.isZero()), this.isZero())
        return {
          div: new ce(0),
          mod: new ce(0)
        };
      var gt, St, xt;
      return this.negative !== 0 && ot.negative === 0 ? (xt = this.neg().divmod(ot, ut), ut !== "mod" && (gt = xt.div.neg()), ut !== "div" && (St = xt.mod.neg(), mt && St.negative !== 0 && St.iadd(ot)), {
        div: gt,
        mod: St
      }) : this.negative === 0 && ot.negative !== 0 ? (xt = this.divmod(ot.neg(), ut), ut !== "mod" && (gt = xt.div.neg()), {
        div: gt,
        mod: xt.mod
      }) : this.negative & ot.negative ? (xt = this.neg().divmod(ot.neg(), ut), ut !== "div" && (St = xt.mod.neg(), mt && St.negative !== 0 && St.isub(ot)), {
        div: xt.div,
        mod: St
      }) : ot.length > this.length || this.cmp(ot) < 0 ? {
        div: new ce(0),
        mod: this
      } : ot.length === 1 ? ut === "div" ? {
        div: this.divn(ot.words[0]),
        mod: null
      } : ut === "mod" ? {
        div: null,
        mod: new ce(this.modrn(ot.words[0]))
      } : {
        div: this.divn(ot.words[0]),
        mod: new ce(this.modrn(ot.words[0]))
      } : this._wordDiv(ot, ut);
    }, ce.prototype.div = function(ot) {
      return this.divmod(ot, "div", !1).div;
    }, ce.prototype.mod = function(ot) {
      return this.divmod(ot, "mod", !1).mod;
    }, ce.prototype.umod = function(ot) {
      return this.divmod(ot, "mod", !0).mod;
    }, ce.prototype.divRound = function(ot) {
      var ut = this.divmod(ot);
      if (ut.mod.isZero()) return ut.div;
      var mt = ut.div.negative !== 0 ? ut.mod.isub(ot) : ut.mod, gt = ot.ushrn(1), St = ot.andln(1), xt = mt.cmp(gt);
      return xt < 0 || St === 1 && xt === 0 ? ut.div : ut.div.negative !== 0 ? ut.div.isubn(1) : ut.div.iaddn(1);
    }, ce.prototype.modrn = function(ot) {
      var ut = ot < 0;
      ut && (ot = -ot), ne(ot <= 67108863);
      for (var mt = (1 << 26) % ot, gt = 0, St = this.length - 1; St >= 0; St--)
        gt = (mt * gt + (this.words[St] | 0)) % ot;
      return ut ? -gt : gt;
    }, ce.prototype.modn = function(ot) {
      return this.modrn(ot);
    }, ce.prototype.idivn = function(ot) {
      var ut = ot < 0;
      ut && (ot = -ot), ne(ot <= 67108863);
      for (var mt = 0, gt = this.length - 1; gt >= 0; gt--) {
        var St = (this.words[gt] | 0) + mt * 67108864;
        this.words[gt] = St / ot | 0, mt = St % ot;
      }
      return this._strip(), ut ? this.ineg() : this;
    }, ce.prototype.divn = function(ot) {
      return this.clone().idivn(ot);
    }, ce.prototype.egcd = function(ot) {
      ne(ot.negative === 0), ne(!ot.isZero());
      var ut = this, mt = ot.clone();
      ut.negative !== 0 ? ut = ut.umod(ot) : ut = ut.clone();
      for (var gt = new ce(1), St = new ce(0), xt = new ce(0), vt = new ce(1), $t = 0; ut.isEven() && mt.isEven(); )
        ut.iushrn(1), mt.iushrn(1), ++$t;
      for (var yt = mt.clone(), Bt = ut.clone(); !ut.isZero(); ) {
        for (var rr = 0, dr = 1; !(ut.words[0] & dr) && rr < 26; ++rr, dr <<= 1) ;
        if (rr > 0)
          for (ut.iushrn(rr); rr-- > 0; )
            (gt.isOdd() || St.isOdd()) && (gt.iadd(yt), St.isub(Bt)), gt.iushrn(1), St.iushrn(1);
        for (var tr = 0, Dt = 1; !(mt.words[0] & Dt) && tr < 26; ++tr, Dt <<= 1) ;
        if (tr > 0)
          for (mt.iushrn(tr); tr-- > 0; )
            (xt.isOdd() || vt.isOdd()) && (xt.iadd(yt), vt.isub(Bt)), xt.iushrn(1), vt.iushrn(1);
        ut.cmp(mt) >= 0 ? (ut.isub(mt), gt.isub(xt), St.isub(vt)) : (mt.isub(ut), xt.isub(gt), vt.isub(St));
      }
      return {
        a: xt,
        b: vt,
        gcd: mt.iushln($t)
      };
    }, ce.prototype._invmp = function(ot) {
      ne(ot.negative === 0), ne(!ot.isZero());
      var ut = this, mt = ot.clone();
      ut.negative !== 0 ? ut = ut.umod(ot) : ut = ut.clone();
      for (var gt = new ce(1), St = new ce(0), xt = mt.clone(); ut.cmpn(1) > 0 && mt.cmpn(1) > 0; ) {
        for (var vt = 0, $t = 1; !(ut.words[0] & $t) && vt < 26; ++vt, $t <<= 1) ;
        if (vt > 0)
          for (ut.iushrn(vt); vt-- > 0; )
            gt.isOdd() && gt.iadd(xt), gt.iushrn(1);
        for (var yt = 0, Bt = 1; !(mt.words[0] & Bt) && yt < 26; ++yt, Bt <<= 1) ;
        if (yt > 0)
          for (mt.iushrn(yt); yt-- > 0; )
            St.isOdd() && St.iadd(xt), St.iushrn(1);
        ut.cmp(mt) >= 0 ? (ut.isub(mt), gt.isub(St)) : (mt.isub(ut), St.isub(gt));
      }
      var rr;
      return ut.cmpn(1) === 0 ? rr = gt : rr = St, rr.cmpn(0) < 0 && rr.iadd(ot), rr;
    }, ce.prototype.gcd = function(ot) {
      if (this.isZero()) return ot.abs();
      if (ot.isZero()) return this.abs();
      var ut = this.clone(), mt = ot.clone();
      ut.negative = 0, mt.negative = 0;
      for (var gt = 0; ut.isEven() && mt.isEven(); gt++)
        ut.iushrn(1), mt.iushrn(1);
      do {
        for (; ut.isEven(); )
          ut.iushrn(1);
        for (; mt.isEven(); )
          mt.iushrn(1);
        var St = ut.cmp(mt);
        if (St < 0) {
          var xt = ut;
          ut = mt, mt = xt;
        } else if (St === 0 || mt.cmpn(1) === 0)
          break;
        ut.isub(mt);
      } while (!0);
      return mt.iushln(gt);
    }, ce.prototype.invm = function(ot) {
      return this.egcd(ot).a.umod(ot);
    }, ce.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ce.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ce.prototype.andln = function(ot) {
      return this.words[0] & ot;
    }, ce.prototype.bincn = function(ot) {
      ne(typeof ot == "number");
      var ut = ot % 26, mt = (ot - ut) / 26, gt = 1 << ut;
      if (this.length <= mt)
        return this._expand(mt + 1), this.words[mt] |= gt, this;
      for (var St = gt, xt = mt; St !== 0 && xt < this.length; xt++) {
        var vt = this.words[xt] | 0;
        vt += St, St = vt >>> 26, vt &= 67108863, this.words[xt] = vt;
      }
      return St !== 0 && (this.words[xt] = St, this.length++), this;
    }, ce.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ce.prototype.cmpn = function(ot) {
      var ut = ot < 0;
      if (this.negative !== 0 && !ut) return -1;
      if (this.negative === 0 && ut) return 1;
      this._strip();
      var mt;
      if (this.length > 1)
        mt = 1;
      else {
        ut && (ot = -ot), ne(ot <= 67108863, "Number is too big");
        var gt = this.words[0] | 0;
        mt = gt === ot ? 0 : gt < ot ? -1 : 1;
      }
      return this.negative !== 0 ? -mt | 0 : mt;
    }, ce.prototype.cmp = function(ot) {
      if (this.negative !== 0 && ot.negative === 0) return -1;
      if (this.negative === 0 && ot.negative !== 0) return 1;
      var ut = this.ucmp(ot);
      return this.negative !== 0 ? -ut | 0 : ut;
    }, ce.prototype.ucmp = function(ot) {
      if (this.length > ot.length) return 1;
      if (this.length < ot.length) return -1;
      for (var ut = 0, mt = this.length - 1; mt >= 0; mt--) {
        var gt = this.words[mt] | 0, St = ot.words[mt] | 0;
        if (gt !== St) {
          gt < St ? ut = -1 : gt > St && (ut = 1);
          break;
        }
      }
      return ut;
    }, ce.prototype.gtn = function(ot) {
      return this.cmpn(ot) === 1;
    }, ce.prototype.gt = function(ot) {
      return this.cmp(ot) === 1;
    }, ce.prototype.gten = function(ot) {
      return this.cmpn(ot) >= 0;
    }, ce.prototype.gte = function(ot) {
      return this.cmp(ot) >= 0;
    }, ce.prototype.ltn = function(ot) {
      return this.cmpn(ot) === -1;
    }, ce.prototype.lt = function(ot) {
      return this.cmp(ot) === -1;
    }, ce.prototype.lten = function(ot) {
      return this.cmpn(ot) <= 0;
    }, ce.prototype.lte = function(ot) {
      return this.cmp(ot) <= 0;
    }, ce.prototype.eqn = function(ot) {
      return this.cmpn(ot) === 0;
    }, ce.prototype.eq = function(ot) {
      return this.cmp(ot) === 0;
    }, ce.red = function(ot) {
      return new Ht(ot);
    }, ce.prototype.toRed = function(ot) {
      return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), ot.convertTo(this)._forceRed(ot);
    }, ce.prototype.fromRed = function() {
      return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ce.prototype._forceRed = function(ot) {
      return this.red = ot, this;
    }, ce.prototype.forceRed = function(ot) {
      return ne(!this.red, "Already a number in reduction context"), this._forceRed(ot);
    }, ce.prototype.redAdd = function(ot) {
      return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, ot);
    }, ce.prototype.redIAdd = function(ot) {
      return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ot);
    }, ce.prototype.redSub = function(ot) {
      return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, ot);
    }, ce.prototype.redISub = function(ot) {
      return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, ot);
    }, ce.prototype.redShl = function(ot) {
      return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, ot);
    }, ce.prototype.redMul = function(ot) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ot), this.red.mul(this, ot);
    }, ce.prototype.redIMul = function(ot) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ot), this.red.imul(this, ot);
    }, ce.prototype.redSqr = function() {
      return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ce.prototype.redISqr = function() {
      return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ce.prototype.redSqrt = function() {
      return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ce.prototype.redInvm = function() {
      return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ce.prototype.redNeg = function() {
      return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ce.prototype.redPow = function(ot) {
      return ne(this.red && !ot.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ot);
    };
    var Jt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Vt(dt, ot) {
      this.name = dt, this.p = new ce(ot, 16), this.n = this.p.bitLength(), this.k = new ce(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Vt.prototype._tmp = function() {
      var ot = new ce(null);
      return ot.words = new Array(Math.ceil(this.n / 13)), ot;
    }, Vt.prototype.ireduce = function(ot) {
      var ut = ot, mt;
      do
        this.split(ut, this.tmp), ut = this.imulK(ut), ut = ut.iadd(this.tmp), mt = ut.bitLength();
      while (mt > this.n);
      var gt = mt < this.n ? -1 : ut.ucmp(this.p);
      return gt === 0 ? (ut.words[0] = 0, ut.length = 1) : gt > 0 ? ut.isub(this.p) : ut.strip !== void 0 ? ut.strip() : ut._strip(), ut;
    }, Vt.prototype.split = function(ot, ut) {
      ot.iushrn(this.n, 0, ut);
    }, Vt.prototype.imulK = function(ot) {
      return ot.imul(this.k);
    };
    function yr() {
      Vt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    oe(yr, Vt), yr.prototype.split = function(ot, ut) {
      for (var mt = 4194303, gt = Math.min(ot.length, 9), St = 0; St < gt; St++)
        ut.words[St] = ot.words[St];
      if (ut.length = gt, ot.length <= 9) {
        ot.words[0] = 0, ot.length = 1;
        return;
      }
      var xt = ot.words[9];
      for (ut.words[ut.length++] = xt & mt, St = 10; St < ot.length; St++) {
        var vt = ot.words[St] | 0;
        ot.words[St - 10] = (vt & mt) << 4 | xt >>> 22, xt = vt;
      }
      xt >>>= 22, ot.words[St - 10] = xt, xt === 0 && ot.length > 10 ? ot.length -= 10 : ot.length -= 9;
    }, yr.prototype.imulK = function(ot) {
      ot.words[ot.length] = 0, ot.words[ot.length + 1] = 0, ot.length += 2;
      for (var ut = 0, mt = 0; mt < ot.length; mt++) {
        var gt = ot.words[mt] | 0;
        ut += gt * 977, ot.words[mt] = ut & 67108863, ut = gt * 64 + (ut / 67108864 | 0);
      }
      return ot.words[ot.length - 1] === 0 && (ot.length--, ot.words[ot.length - 1] === 0 && ot.length--), ot;
    };
    function jt() {
      Vt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    oe(jt, Vt);
    function Ut() {
      Vt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    oe(Ut, Vt);
    function er() {
      Vt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    oe(er, Vt), er.prototype.imulK = function(ot) {
      for (var ut = 0, mt = 0; mt < ot.length; mt++) {
        var gt = (ot.words[mt] | 0) * 19 + ut, St = gt & 67108863;
        gt >>>= 26, ot.words[mt] = St, ut = gt;
      }
      return ut !== 0 && (ot.words[ot.length++] = ut), ot;
    }, ce._prime = function(ot) {
      if (Jt[ot]) return Jt[ot];
      var ut;
      if (ot === "k256")
        ut = new yr();
      else if (ot === "p224")
        ut = new jt();
      else if (ot === "p192")
        ut = new Ut();
      else if (ot === "p25519")
        ut = new er();
      else
        throw new Error("Unknown prime " + ot);
      return Jt[ot] = ut, ut;
    };
    function Ht(dt) {
      if (typeof dt == "string") {
        var ot = ce._prime(dt);
        this.m = ot.p, this.prime = ot;
      } else
        ne(dt.gtn(1), "modulus must be greater than 1"), this.m = dt, this.prime = null;
    }
    Ht.prototype._verify1 = function(ot) {
      ne(ot.negative === 0, "red works only with positives"), ne(ot.red, "red works only with red numbers");
    }, Ht.prototype._verify2 = function(ot, ut) {
      ne((ot.negative | ut.negative) === 0, "red works only with positives"), ne(
        ot.red && ot.red === ut.red,
        "red works only with red numbers"
      );
    }, Ht.prototype.imod = function(ot) {
      return this.prime ? this.prime.ireduce(ot)._forceRed(this) : (it(ot, ot.umod(this.m)._forceRed(this)), ot);
    }, Ht.prototype.neg = function(ot) {
      return ot.isZero() ? ot.clone() : this.m.sub(ot)._forceRed(this);
    }, Ht.prototype.add = function(ot, ut) {
      this._verify2(ot, ut);
      var mt = ot.add(ut);
      return mt.cmp(this.m) >= 0 && mt.isub(this.m), mt._forceRed(this);
    }, Ht.prototype.iadd = function(ot, ut) {
      this._verify2(ot, ut);
      var mt = ot.iadd(ut);
      return mt.cmp(this.m) >= 0 && mt.isub(this.m), mt;
    }, Ht.prototype.sub = function(ot, ut) {
      this._verify2(ot, ut);
      var mt = ot.sub(ut);
      return mt.cmpn(0) < 0 && mt.iadd(this.m), mt._forceRed(this);
    }, Ht.prototype.isub = function(ot, ut) {
      this._verify2(ot, ut);
      var mt = ot.isub(ut);
      return mt.cmpn(0) < 0 && mt.iadd(this.m), mt;
    }, Ht.prototype.shl = function(ot, ut) {
      return this._verify1(ot), this.imod(ot.ushln(ut));
    }, Ht.prototype.imul = function(ot, ut) {
      return this._verify2(ot, ut), this.imod(ot.imul(ut));
    }, Ht.prototype.mul = function(ot, ut) {
      return this._verify2(ot, ut), this.imod(ot.mul(ut));
    }, Ht.prototype.isqr = function(ot) {
      return this.imul(ot, ot.clone());
    }, Ht.prototype.sqr = function(ot) {
      return this.mul(ot, ot);
    }, Ht.prototype.sqrt = function(ot) {
      if (ot.isZero()) return ot.clone();
      var ut = this.m.andln(3);
      if (ne(ut % 2 === 1), ut === 3) {
        var mt = this.m.add(new ce(1)).iushrn(2);
        return this.pow(ot, mt);
      }
      for (var gt = this.m.subn(1), St = 0; !gt.isZero() && gt.andln(1) === 0; )
        St++, gt.iushrn(1);
      ne(!gt.isZero());
      var xt = new ce(1).toRed(this), vt = xt.redNeg(), $t = this.m.subn(1).iushrn(1), yt = this.m.bitLength();
      for (yt = new ce(2 * yt * yt).toRed(this); this.pow(yt, $t).cmp(vt) !== 0; )
        yt.redIAdd(vt);
      for (var Bt = this.pow(yt, gt), rr = this.pow(ot, gt.addn(1).iushrn(1)), dr = this.pow(ot, gt), tr = St; dr.cmp(xt) !== 0; ) {
        for (var Dt = dr, Wt = 0; Dt.cmp(xt) !== 0; Wt++)
          Dt = Dt.redSqr();
        ne(Wt < tr);
        var or = this.pow(Bt, new ce(1).iushln(tr - Wt - 1));
        rr = rr.redMul(or), Bt = or.redSqr(), dr = dr.redMul(Bt), tr = Wt;
      }
      return rr;
    }, Ht.prototype.invm = function(ot) {
      var ut = ot._invmp(this.m);
      return ut.negative !== 0 ? (ut.negative = 0, this.imod(ut).redNeg()) : this.imod(ut);
    }, Ht.prototype.pow = function(ot, ut) {
      if (ut.isZero()) return new ce(1).toRed(this);
      if (ut.cmpn(1) === 0) return ot.clone();
      var mt = 4, gt = new Array(1 << mt);
      gt[0] = new ce(1).toRed(this), gt[1] = ot;
      for (var St = 2; St < gt.length; St++)
        gt[St] = this.mul(gt[St - 1], ot);
      var xt = gt[0], vt = 0, $t = 0, yt = ut.bitLength() % 26;
      for (yt === 0 && (yt = 26), St = ut.length - 1; St >= 0; St--) {
        for (var Bt = ut.words[St], rr = yt - 1; rr >= 0; rr--) {
          var dr = Bt >> rr & 1;
          if (xt !== gt[0] && (xt = this.sqr(xt)), dr === 0 && vt === 0) {
            $t = 0;
            continue;
          }
          vt <<= 1, vt |= dr, $t++, !($t !== mt && (St !== 0 || rr !== 0)) && (xt = this.mul(xt, gt[vt]), $t = 0, vt = 0);
        }
        yt = 26;
      }
      return xt;
    }, Ht.prototype.convertTo = function(ot) {
      var ut = ot.umod(this.m);
      return ut === ot ? ut.clone() : ut;
    }, Ht.prototype.convertFrom = function(ot) {
      var ut = ot.clone();
      return ut.red = null, ut;
    }, ce.mont = function(ot) {
      return new ct(ot);
    };
    function ct(dt) {
      Ht.call(this, dt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ce(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    oe(ct, Ht), ct.prototype.convertTo = function(ot) {
      return this.imod(ot.ushln(this.shift));
    }, ct.prototype.convertFrom = function(ot) {
      var ut = this.imod(ot.mul(this.rinv));
      return ut.red = null, ut;
    }, ct.prototype.imul = function(ot, ut) {
      if (ot.isZero() || ut.isZero())
        return ot.words[0] = 0, ot.length = 1, ot;
      var mt = ot.imul(ut), gt = mt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), St = mt.isub(gt).iushrn(this.shift), xt = St;
      return St.cmp(this.m) >= 0 ? xt = St.isub(this.m) : St.cmpn(0) < 0 && (xt = St.iadd(this.m)), xt._forceRed(this);
    }, ct.prototype.mul = function(ot, ut) {
      if (ot.isZero() || ut.isZero()) return new ce(0)._forceRed(this);
      var mt = ot.mul(ut), gt = mt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), St = mt.isub(gt).iushrn(this.shift), xt = St;
      return St.cmp(this.m) >= 0 ? xt = St.isub(this.m) : St.cmpn(0) < 0 && (xt = St.iadd(this.m)), xt._forceRed(this);
    }, ct.prototype.invm = function(ot) {
      var ut = this.imod(ot._invmp(this.m).mul(this.r2));
      return ut._forceRed(this);
    };
  })(B, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$a = bnExports, randomBytes$2 = browserExports;
function blind(B) {
  var L = getr(B), J = L.toRed(BN$a.mont(B.modulus)).redPow(new BN$a(B.publicExponent)).fromRed();
  return { blinder: J, unblinder: L.invm(B.modulus) };
}
function getr(B) {
  var L = B.modulus.byteLength(), J;
  do
    J = new BN$a(randomBytes$2(L));
  while (J.cmp(B.modulus) >= 0 || !J.umod(B.prime1) || !J.umod(B.prime2));
  return J;
}
function crt$2(B, L) {
  var J = blind(L), ne = L.modulus.byteLength(), oe = new BN$a(B).mul(J.blinder).umod(L.modulus), ce = oe.toRed(BN$a.mont(L.prime1)), Ce = oe.toRed(BN$a.mont(L.prime2)), rt = L.coefficient, at = L.prime1, ht = L.prime2, it = ce.redPow(L.exponent1).fromRed(), lt = Ce.redPow(L.exponent2).fromRed(), Et = it.isub(lt).imul(rt).umod(at).imul(ht);
  return lt.iadd(Et).imul(J.unblinder).umod(L.modulus).toArrayLike(Buffer$D, "be", ne);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name = "elliptic", version = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$l = {}, utils$k = {};
(function(B) {
  var L = B;
  function J(ce, Ce) {
    if (Array.isArray(ce))
      return ce.slice();
    if (!ce)
      return [];
    var rt = [];
    if (typeof ce != "string") {
      for (var at = 0; at < ce.length; at++)
        rt[at] = ce[at] | 0;
      return rt;
    }
    if (Ce === "hex") {
      ce = ce.replace(/[^a-z0-9]+/ig, ""), ce.length % 2 !== 0 && (ce = "0" + ce);
      for (var at = 0; at < ce.length; at += 2)
        rt.push(parseInt(ce[at] + ce[at + 1], 16));
    } else
      for (var at = 0; at < ce.length; at++) {
        var ht = ce.charCodeAt(at), it = ht >> 8, lt = ht & 255;
        it ? rt.push(it, lt) : rt.push(lt);
      }
    return rt;
  }
  L.toArray = J;
  function ne(ce) {
    return ce.length === 1 ? "0" + ce : ce;
  }
  L.zero2 = ne;
  function oe(ce) {
    for (var Ce = "", rt = 0; rt < ce.length; rt++)
      Ce += ne(ce[rt].toString(16));
    return Ce;
  }
  L.toHex = oe, L.encode = function(Ce, rt) {
    return rt === "hex" ? oe(Ce) : Ce;
  };
})(utils$k);
(function(B) {
  var L = B, J = bnExports$1, ne = minimalisticAssert, oe = utils$k;
  L.assert = ne, L.toArray = oe.toArray, L.zero2 = oe.zero2, L.toHex = oe.toHex, L.encode = oe.encode;
  function ce(it, lt, Et) {
    var wt = new Array(Math.max(it.bitLength(), Et) + 1), Rt;
    for (Rt = 0; Rt < wt.length; Rt += 1)
      wt[Rt] = 0;
    var Mt = 1 << lt + 1, Lt = it.clone();
    for (Rt = 0; Rt < wt.length; Rt++) {
      var zt, Ot = Lt.andln(Mt - 1);
      Lt.isOdd() ? (Ot > (Mt >> 1) - 1 ? zt = (Mt >> 1) - Ot : zt = Ot, Lt.isubn(zt)) : zt = 0, wt[Rt] = zt, Lt.iushrn(1);
    }
    return wt;
  }
  L.getNAF = ce;
  function Ce(it, lt) {
    var Et = [
      [],
      []
    ];
    it = it.clone(), lt = lt.clone();
    for (var wt = 0, Rt = 0, Mt; it.cmpn(-wt) > 0 || lt.cmpn(-Rt) > 0; ) {
      var Lt = it.andln(3) + wt & 3, zt = lt.andln(3) + Rt & 3;
      Lt === 3 && (Lt = -1), zt === 3 && (zt = -1);
      var Ot;
      Lt & 1 ? (Mt = it.andln(7) + wt & 7, (Mt === 3 || Mt === 5) && zt === 2 ? Ot = -Lt : Ot = Lt) : Ot = 0, Et[0].push(Ot);
      var It;
      zt & 1 ? (Mt = lt.andln(7) + Rt & 7, (Mt === 3 || Mt === 5) && Lt === 2 ? It = -zt : It = zt) : It = 0, Et[1].push(It), 2 * wt === Ot + 1 && (wt = 1 - wt), 2 * Rt === It + 1 && (Rt = 1 - Rt), it.iushrn(1), lt.iushrn(1);
    }
    return Et;
  }
  L.getJSF = Ce;
  function rt(it, lt, Et) {
    var wt = "_" + lt;
    it.prototype[lt] = function() {
      return this[wt] !== void 0 ? this[wt] : this[wt] = Et.call(this);
    };
  }
  L.cachedProperty = rt;
  function at(it) {
    return typeof it == "string" ? L.toArray(it, "hex") : it;
  }
  L.parseBytes = at;
  function ht(it) {
    return new J(it, "hex", "le");
  }
  L.intFromLE = ht;
})(utils$l);
var curve = {}, BN$9 = bnExports$1, utils$j = utils$l, getNAF = utils$j.getNAF, getJSF = utils$j.getJSF, assert$f = utils$j.assert;
function BaseCurve(B, L) {
  this.type = B, this.p = new BN$9(L.p, 16), this.red = L.prime ? BN$9.red(L.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = L.n && new BN$9(L.n, 16), this.g = L.g && this.pointFromJSON(L.g, L.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var J = this.n && this.p.div(this.n);
  !J || J.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$3 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(L, J) {
  assert$f(L.precomputed);
  var ne = L._getDoubles(), oe = getNAF(J, 1, this._bitLength), ce = (1 << ne.step + 1) - (ne.step % 2 === 0 ? 2 : 1);
  ce /= 3;
  var Ce = [], rt, at;
  for (rt = 0; rt < oe.length; rt += ne.step) {
    at = 0;
    for (var ht = rt + ne.step - 1; ht >= rt; ht--)
      at = (at << 1) + oe[ht];
    Ce.push(at);
  }
  for (var it = this.jpoint(null, null, null), lt = this.jpoint(null, null, null), Et = ce; Et > 0; Et--) {
    for (rt = 0; rt < Ce.length; rt++)
      at = Ce[rt], at === Et ? lt = lt.mixedAdd(ne.points[rt]) : at === -Et && (lt = lt.mixedAdd(ne.points[rt].neg()));
    it = it.add(lt);
  }
  return it.toP();
};
BaseCurve.prototype._wnafMul = function(L, J) {
  var ne = 4, oe = L._getNAFPoints(ne);
  ne = oe.wnd;
  for (var ce = oe.points, Ce = getNAF(J, ne, this._bitLength), rt = this.jpoint(null, null, null), at = Ce.length - 1; at >= 0; at--) {
    for (var ht = 0; at >= 0 && Ce[at] === 0; at--)
      ht++;
    if (at >= 0 && ht++, rt = rt.dblp(ht), at < 0)
      break;
    var it = Ce[at];
    assert$f(it !== 0), L.type === "affine" ? it > 0 ? rt = rt.mixedAdd(ce[it - 1 >> 1]) : rt = rt.mixedAdd(ce[-it - 1 >> 1].neg()) : it > 0 ? rt = rt.add(ce[it - 1 >> 1]) : rt = rt.add(ce[-it - 1 >> 1].neg());
  }
  return L.type === "affine" ? rt.toP() : rt;
};
BaseCurve.prototype._wnafMulAdd = function(L, J, ne, oe, ce) {
  var Ce = this._wnafT1, rt = this._wnafT2, at = this._wnafT3, ht = 0, it, lt, Et;
  for (it = 0; it < oe; it++) {
    Et = J[it];
    var wt = Et._getNAFPoints(L);
    Ce[it] = wt.wnd, rt[it] = wt.points;
  }
  for (it = oe - 1; it >= 1; it -= 2) {
    var Rt = it - 1, Mt = it;
    if (Ce[Rt] !== 1 || Ce[Mt] !== 1) {
      at[Rt] = getNAF(ne[Rt], Ce[Rt], this._bitLength), at[Mt] = getNAF(ne[Mt], Ce[Mt], this._bitLength), ht = Math.max(at[Rt].length, ht), ht = Math.max(at[Mt].length, ht);
      continue;
    }
    var Lt = [
      J[Rt],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      J[Mt]
      /* 7 */
    ];
    J[Rt].y.cmp(J[Mt].y) === 0 ? (Lt[1] = J[Rt].add(J[Mt]), Lt[2] = J[Rt].toJ().mixedAdd(J[Mt].neg())) : J[Rt].y.cmp(J[Mt].y.redNeg()) === 0 ? (Lt[1] = J[Rt].toJ().mixedAdd(J[Mt]), Lt[2] = J[Rt].add(J[Mt].neg())) : (Lt[1] = J[Rt].toJ().mixedAdd(J[Mt]), Lt[2] = J[Rt].toJ().mixedAdd(J[Mt].neg()));
    var zt = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Ot = getJSF(ne[Rt], ne[Mt]);
    for (ht = Math.max(Ot[0].length, ht), at[Rt] = new Array(ht), at[Mt] = new Array(ht), lt = 0; lt < ht; lt++) {
      var It = Ot[0][lt] | 0, Ft = Ot[1][lt] | 0;
      at[Rt][lt] = zt[(It + 1) * 3 + (Ft + 1)], at[Mt][lt] = 0, rt[Rt] = Lt;
    }
  }
  var Jt = this.jpoint(null, null, null), Vt = this._wnafT4;
  for (it = ht; it >= 0; it--) {
    for (var yr = 0; it >= 0; ) {
      var jt = !0;
      for (lt = 0; lt < oe; lt++)
        Vt[lt] = at[lt][it] | 0, Vt[lt] !== 0 && (jt = !1);
      if (!jt)
        break;
      yr++, it--;
    }
    if (it >= 0 && yr++, Jt = Jt.dblp(yr), it < 0)
      break;
    for (lt = 0; lt < oe; lt++) {
      var Ut = Vt[lt];
      Ut !== 0 && (Ut > 0 ? Et = rt[lt][Ut - 1 >> 1] : Ut < 0 && (Et = rt[lt][-Ut - 1 >> 1].neg()), Et.type === "affine" ? Jt = Jt.mixedAdd(Et) : Jt = Jt.add(Et));
    }
  }
  for (it = 0; it < oe; it++)
    rt[it] = null;
  return ce ? Jt : Jt.toP();
};
function BasePoint(B, L) {
  this.curve = B, this.type = L, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(L, J) {
  L = utils$j.toArray(L, J);
  var ne = this.p.byteLength();
  if ((L[0] === 4 || L[0] === 6 || L[0] === 7) && L.length - 1 === 2 * ne) {
    L[0] === 6 ? assert$f(L[L.length - 1] % 2 === 0) : L[0] === 7 && assert$f(L[L.length - 1] % 2 === 1);
    var oe = this.point(
      L.slice(1, 1 + ne),
      L.slice(1 + ne, 1 + 2 * ne)
    );
    return oe;
  } else if ((L[0] === 2 || L[0] === 3) && L.length - 1 === ne)
    return this.pointFromX(L.slice(1, 1 + ne), L[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(L) {
  return this.encode(L, !0);
};
BasePoint.prototype._encode = function(L) {
  var J = this.curve.p.byteLength(), ne = this.getX().toArray("be", J);
  return L ? [this.getY().isEven() ? 2 : 3].concat(ne) : [4].concat(ne, this.getY().toArray("be", J));
};
BasePoint.prototype.encode = function(L, J) {
  return utils$j.encode(this._encode(J), L);
};
BasePoint.prototype.precompute = function(L) {
  if (this.precomputed)
    return this;
  var J = {
    doubles: null,
    naf: null,
    beta: null
  };
  return J.naf = this._getNAFPoints(8), J.doubles = this._getDoubles(4, L), J.beta = this._getBeta(), this.precomputed = J, this;
};
BasePoint.prototype._hasDoubles = function(L) {
  if (!this.precomputed)
    return !1;
  var J = this.precomputed.doubles;
  return J ? J.points.length >= Math.ceil((L.bitLength() + 1) / J.step) : !1;
};
BasePoint.prototype._getDoubles = function(L, J) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var ne = [this], oe = this, ce = 0; ce < J; ce += L) {
    for (var Ce = 0; Ce < L; Ce++)
      oe = oe.dbl();
    ne.push(oe);
  }
  return {
    step: L,
    points: ne
  };
};
BasePoint.prototype._getNAFPoints = function(L) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var J = [this], ne = (1 << L) - 1, oe = ne === 1 ? null : this.dbl(), ce = 1; ce < ne; ce++)
    J[ce] = J[ce - 1].add(oe);
  return {
    wnd: L,
    points: J
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(L) {
  for (var J = this, ne = 0; ne < L; ne++)
    J = J.dbl();
  return J;
};
var utils$i = utils$l, BN$8 = bnExports$1, inherits$4 = inherits_browserExports, Base$2 = base$3, assert$e = utils$i.assert;
function ShortCurve(B) {
  Base$2.call(this, "short", B), this.a = new BN$8(B.a, 16).toRed(this.red), this.b = new BN$8(B.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(B), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(L) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var J, ne;
    if (L.beta)
      J = new BN$8(L.beta, 16).toRed(this.red);
    else {
      var oe = this._getEndoRoots(this.p);
      J = oe[0].cmp(oe[1]) < 0 ? oe[0] : oe[1], J = J.toRed(this.red);
    }
    if (L.lambda)
      ne = new BN$8(L.lambda, 16);
    else {
      var ce = this._getEndoRoots(this.n);
      this.g.mul(ce[0]).x.cmp(this.g.x.redMul(J)) === 0 ? ne = ce[0] : (ne = ce[1], assert$e(this.g.mul(ne).x.cmp(this.g.x.redMul(J)) === 0));
    }
    var Ce;
    return L.basis ? Ce = L.basis.map(function(rt) {
      return {
        a: new BN$8(rt.a, 16),
        b: new BN$8(rt.b, 16)
      };
    }) : Ce = this._getEndoBasis(ne), {
      beta: J,
      lambda: ne,
      basis: Ce
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(L) {
  var J = L === this.p ? this.red : BN$8.mont(L), ne = new BN$8(2).toRed(J).redInvm(), oe = ne.redNeg(), ce = new BN$8(3).toRed(J).redNeg().redSqrt().redMul(ne), Ce = oe.redAdd(ce).fromRed(), rt = oe.redSub(ce).fromRed();
  return [Ce, rt];
};
ShortCurve.prototype._getEndoBasis = function(L) {
  for (var J = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ne = L, oe = this.n.clone(), ce = new BN$8(1), Ce = new BN$8(0), rt = new BN$8(0), at = new BN$8(1), ht, it, lt, Et, wt, Rt, Mt, Lt = 0, zt, Ot; ne.cmpn(0) !== 0; ) {
    var It = oe.div(ne);
    zt = oe.sub(It.mul(ne)), Ot = rt.sub(It.mul(ce));
    var Ft = at.sub(It.mul(Ce));
    if (!lt && zt.cmp(J) < 0)
      ht = Mt.neg(), it = ce, lt = zt.neg(), Et = Ot;
    else if (lt && ++Lt === 2)
      break;
    Mt = zt, oe = ne, ne = zt, rt = ce, ce = Ot, at = Ce, Ce = Ft;
  }
  wt = zt.neg(), Rt = Ot;
  var Jt = lt.sqr().add(Et.sqr()), Vt = wt.sqr().add(Rt.sqr());
  return Vt.cmp(Jt) >= 0 && (wt = ht, Rt = it), lt.negative && (lt = lt.neg(), Et = Et.neg()), wt.negative && (wt = wt.neg(), Rt = Rt.neg()), [
    { a: lt, b: Et },
    { a: wt, b: Rt }
  ];
};
ShortCurve.prototype._endoSplit = function(L) {
  var J = this.endo.basis, ne = J[0], oe = J[1], ce = oe.b.mul(L).divRound(this.n), Ce = ne.b.neg().mul(L).divRound(this.n), rt = ce.mul(ne.a), at = Ce.mul(oe.a), ht = ce.mul(ne.b), it = Ce.mul(oe.b), lt = L.sub(rt).sub(at), Et = ht.add(it).neg();
  return { k1: lt, k2: Et };
};
ShortCurve.prototype.pointFromX = function(L, J) {
  L = new BN$8(L, 16), L.red || (L = L.toRed(this.red));
  var ne = L.redSqr().redMul(L).redIAdd(L.redMul(this.a)).redIAdd(this.b), oe = ne.redSqrt();
  if (oe.redSqr().redSub(ne).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ce = oe.fromRed().isOdd();
  return (J && !ce || !J && ce) && (oe = oe.redNeg()), this.point(L, oe);
};
ShortCurve.prototype.validate = function(L) {
  if (L.inf)
    return !0;
  var J = L.x, ne = L.y, oe = this.a.redMul(J), ce = J.redSqr().redMul(J).redIAdd(oe).redIAdd(this.b);
  return ne.redSqr().redISub(ce).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(L, J, ne) {
  for (var oe = this._endoWnafT1, ce = this._endoWnafT2, Ce = 0; Ce < L.length; Ce++) {
    var rt = this._endoSplit(J[Ce]), at = L[Ce], ht = at._getBeta();
    rt.k1.negative && (rt.k1.ineg(), at = at.neg(!0)), rt.k2.negative && (rt.k2.ineg(), ht = ht.neg(!0)), oe[Ce * 2] = at, oe[Ce * 2 + 1] = ht, ce[Ce * 2] = rt.k1, ce[Ce * 2 + 1] = rt.k2;
  }
  for (var it = this._wnafMulAdd(1, oe, ce, Ce * 2, ne), lt = 0; lt < Ce * 2; lt++)
    oe[lt] = null, ce[lt] = null;
  return it;
};
function Point$2(B, L, J, ne) {
  Base$2.BasePoint.call(this, B, "affine"), L === null && J === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(L, 16), this.y = new BN$8(J, 16), ne && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(L, J, ne) {
  return new Point$2(this, L, J, ne);
};
ShortCurve.prototype.pointFromJSON = function(L, J) {
  return Point$2.fromJSON(this, L, J);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var L = this.precomputed;
    if (L && L.beta)
      return L.beta;
    var J = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (L) {
      var ne = this.curve, oe = function(ce) {
        return ne.point(ce.x.redMul(ne.endo.beta), ce.y);
      };
      L.beta = J, J.precomputed = {
        beta: null,
        naf: L.naf && {
          wnd: L.naf.wnd,
          points: L.naf.points.map(oe)
        },
        doubles: L.doubles && {
          step: L.doubles.step,
          points: L.doubles.points.map(oe)
        }
      };
    }
    return J;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(L, J, ne) {
  typeof J == "string" && (J = JSON.parse(J));
  var oe = L.point(J[0], J[1], ne);
  if (!J[2])
    return oe;
  function ce(rt) {
    return L.point(rt[0], rt[1], ne);
  }
  var Ce = J[2];
  return oe.precomputed = {
    beta: null,
    doubles: Ce.doubles && {
      step: Ce.doubles.step,
      points: [oe].concat(Ce.doubles.points.map(ce))
    },
    naf: Ce.naf && {
      wnd: Ce.naf.wnd,
      points: [oe].concat(Ce.naf.points.map(ce))
    }
  }, oe;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(L) {
  if (this.inf)
    return L;
  if (L.inf)
    return this;
  if (this.eq(L))
    return this.dbl();
  if (this.neg().eq(L))
    return this.curve.point(null, null);
  if (this.x.cmp(L.x) === 0)
    return this.curve.point(null, null);
  var J = this.y.redSub(L.y);
  J.cmpn(0) !== 0 && (J = J.redMul(this.x.redSub(L.x).redInvm()));
  var ne = J.redSqr().redISub(this.x).redISub(L.x), oe = J.redMul(this.x.redSub(ne)).redISub(this.y);
  return this.curve.point(ne, oe);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var L = this.y.redAdd(this.y);
  if (L.cmpn(0) === 0)
    return this.curve.point(null, null);
  var J = this.curve.a, ne = this.x.redSqr(), oe = L.redInvm(), ce = ne.redAdd(ne).redIAdd(ne).redIAdd(J).redMul(oe), Ce = ce.redSqr().redISub(this.x.redAdd(this.x)), rt = ce.redMul(this.x.redSub(Ce)).redISub(this.y);
  return this.curve.point(Ce, rt);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(L) {
  return L = new BN$8(L, 16), this.isInfinity() ? this : this._hasDoubles(L) ? this.curve._fixedNafMul(this, L) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [L]) : this.curve._wnafMul(this, L);
};
Point$2.prototype.mulAdd = function(L, J, ne) {
  var oe = [this, J], ce = [L, ne];
  return this.curve.endo ? this.curve._endoWnafMulAdd(oe, ce) : this.curve._wnafMulAdd(1, oe, ce, 2);
};
Point$2.prototype.jmulAdd = function(L, J, ne) {
  var oe = [this, J], ce = [L, ne];
  return this.curve.endo ? this.curve._endoWnafMulAdd(oe, ce, !0) : this.curve._wnafMulAdd(1, oe, ce, 2, !0);
};
Point$2.prototype.eq = function(L) {
  return this === L || this.inf === L.inf && (this.inf || this.x.cmp(L.x) === 0 && this.y.cmp(L.y) === 0);
};
Point$2.prototype.neg = function(L) {
  if (this.inf)
    return this;
  var J = this.curve.point(this.x, this.y.redNeg());
  if (L && this.precomputed) {
    var ne = this.precomputed, oe = function(ce) {
      return ce.neg();
    };
    J.precomputed = {
      naf: ne.naf && {
        wnd: ne.naf.wnd,
        points: ne.naf.points.map(oe)
      },
      doubles: ne.doubles && {
        step: ne.doubles.step,
        points: ne.doubles.points.map(oe)
      }
    };
  }
  return J;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var L = this.curve.jpoint(this.x, this.y, this.curve.one);
  return L;
};
function JPoint(B, L, J, ne) {
  Base$2.BasePoint.call(this, B, "jacobian"), L === null && J === null && ne === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(L, 16), this.y = new BN$8(J, 16), this.z = new BN$8(ne, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(L, J, ne) {
  return new JPoint(this, L, J, ne);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var L = this.z.redInvm(), J = L.redSqr(), ne = this.x.redMul(J), oe = this.y.redMul(J).redMul(L);
  return this.curve.point(ne, oe);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(L) {
  if (this.isInfinity())
    return L;
  if (L.isInfinity())
    return this;
  var J = L.z.redSqr(), ne = this.z.redSqr(), oe = this.x.redMul(J), ce = L.x.redMul(ne), Ce = this.y.redMul(J.redMul(L.z)), rt = L.y.redMul(ne.redMul(this.z)), at = oe.redSub(ce), ht = Ce.redSub(rt);
  if (at.cmpn(0) === 0)
    return ht.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var it = at.redSqr(), lt = it.redMul(at), Et = oe.redMul(it), wt = ht.redSqr().redIAdd(lt).redISub(Et).redISub(Et), Rt = ht.redMul(Et.redISub(wt)).redISub(Ce.redMul(lt)), Mt = this.z.redMul(L.z).redMul(at);
  return this.curve.jpoint(wt, Rt, Mt);
};
JPoint.prototype.mixedAdd = function(L) {
  if (this.isInfinity())
    return L.toJ();
  if (L.isInfinity())
    return this;
  var J = this.z.redSqr(), ne = this.x, oe = L.x.redMul(J), ce = this.y, Ce = L.y.redMul(J).redMul(this.z), rt = ne.redSub(oe), at = ce.redSub(Ce);
  if (rt.cmpn(0) === 0)
    return at.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var ht = rt.redSqr(), it = ht.redMul(rt), lt = ne.redMul(ht), Et = at.redSqr().redIAdd(it).redISub(lt).redISub(lt), wt = at.redMul(lt.redISub(Et)).redISub(ce.redMul(it)), Rt = this.z.redMul(rt);
  return this.curve.jpoint(Et, wt, Rt);
};
JPoint.prototype.dblp = function(L) {
  if (L === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!L)
    return this.dbl();
  var J;
  if (this.curve.zeroA || this.curve.threeA) {
    var ne = this;
    for (J = 0; J < L; J++)
      ne = ne.dbl();
    return ne;
  }
  var oe = this.curve.a, ce = this.curve.tinv, Ce = this.x, rt = this.y, at = this.z, ht = at.redSqr().redSqr(), it = rt.redAdd(rt);
  for (J = 0; J < L; J++) {
    var lt = Ce.redSqr(), Et = it.redSqr(), wt = Et.redSqr(), Rt = lt.redAdd(lt).redIAdd(lt).redIAdd(oe.redMul(ht)), Mt = Ce.redMul(Et), Lt = Rt.redSqr().redISub(Mt.redAdd(Mt)), zt = Mt.redISub(Lt), Ot = Rt.redMul(zt);
    Ot = Ot.redIAdd(Ot).redISub(wt);
    var It = it.redMul(at);
    J + 1 < L && (ht = ht.redMul(wt)), Ce = Lt, at = It, it = Ot;
  }
  return this.curve.jpoint(Ce, it.redMul(ce), at);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var L, J, ne;
  if (this.zOne) {
    var oe = this.x.redSqr(), ce = this.y.redSqr(), Ce = ce.redSqr(), rt = this.x.redAdd(ce).redSqr().redISub(oe).redISub(Ce);
    rt = rt.redIAdd(rt);
    var at = oe.redAdd(oe).redIAdd(oe), ht = at.redSqr().redISub(rt).redISub(rt), it = Ce.redIAdd(Ce);
    it = it.redIAdd(it), it = it.redIAdd(it), L = ht, J = at.redMul(rt.redISub(ht)).redISub(it), ne = this.y.redAdd(this.y);
  } else {
    var lt = this.x.redSqr(), Et = this.y.redSqr(), wt = Et.redSqr(), Rt = this.x.redAdd(Et).redSqr().redISub(lt).redISub(wt);
    Rt = Rt.redIAdd(Rt);
    var Mt = lt.redAdd(lt).redIAdd(lt), Lt = Mt.redSqr(), zt = wt.redIAdd(wt);
    zt = zt.redIAdd(zt), zt = zt.redIAdd(zt), L = Lt.redISub(Rt).redISub(Rt), J = Mt.redMul(Rt.redISub(L)).redISub(zt), ne = this.y.redMul(this.z), ne = ne.redIAdd(ne);
  }
  return this.curve.jpoint(L, J, ne);
};
JPoint.prototype._threeDbl = function() {
  var L, J, ne;
  if (this.zOne) {
    var oe = this.x.redSqr(), ce = this.y.redSqr(), Ce = ce.redSqr(), rt = this.x.redAdd(ce).redSqr().redISub(oe).redISub(Ce);
    rt = rt.redIAdd(rt);
    var at = oe.redAdd(oe).redIAdd(oe).redIAdd(this.curve.a), ht = at.redSqr().redISub(rt).redISub(rt);
    L = ht;
    var it = Ce.redIAdd(Ce);
    it = it.redIAdd(it), it = it.redIAdd(it), J = at.redMul(rt.redISub(ht)).redISub(it), ne = this.y.redAdd(this.y);
  } else {
    var lt = this.z.redSqr(), Et = this.y.redSqr(), wt = this.x.redMul(Et), Rt = this.x.redSub(lt).redMul(this.x.redAdd(lt));
    Rt = Rt.redAdd(Rt).redIAdd(Rt);
    var Mt = wt.redIAdd(wt);
    Mt = Mt.redIAdd(Mt);
    var Lt = Mt.redAdd(Mt);
    L = Rt.redSqr().redISub(Lt), ne = this.y.redAdd(this.z).redSqr().redISub(Et).redISub(lt);
    var zt = Et.redSqr();
    zt = zt.redIAdd(zt), zt = zt.redIAdd(zt), zt = zt.redIAdd(zt), J = Rt.redMul(Mt.redISub(L)).redISub(zt);
  }
  return this.curve.jpoint(L, J, ne);
};
JPoint.prototype._dbl = function() {
  var L = this.curve.a, J = this.x, ne = this.y, oe = this.z, ce = oe.redSqr().redSqr(), Ce = J.redSqr(), rt = ne.redSqr(), at = Ce.redAdd(Ce).redIAdd(Ce).redIAdd(L.redMul(ce)), ht = J.redAdd(J);
  ht = ht.redIAdd(ht);
  var it = ht.redMul(rt), lt = at.redSqr().redISub(it.redAdd(it)), Et = it.redISub(lt), wt = rt.redSqr();
  wt = wt.redIAdd(wt), wt = wt.redIAdd(wt), wt = wt.redIAdd(wt);
  var Rt = at.redMul(Et).redISub(wt), Mt = ne.redAdd(ne).redMul(oe);
  return this.curve.jpoint(lt, Rt, Mt);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var L = this.x.redSqr(), J = this.y.redSqr(), ne = this.z.redSqr(), oe = J.redSqr(), ce = L.redAdd(L).redIAdd(L), Ce = ce.redSqr(), rt = this.x.redAdd(J).redSqr().redISub(L).redISub(oe);
  rt = rt.redIAdd(rt), rt = rt.redAdd(rt).redIAdd(rt), rt = rt.redISub(Ce);
  var at = rt.redSqr(), ht = oe.redIAdd(oe);
  ht = ht.redIAdd(ht), ht = ht.redIAdd(ht), ht = ht.redIAdd(ht);
  var it = ce.redIAdd(rt).redSqr().redISub(Ce).redISub(at).redISub(ht), lt = J.redMul(it);
  lt = lt.redIAdd(lt), lt = lt.redIAdd(lt);
  var Et = this.x.redMul(at).redISub(lt);
  Et = Et.redIAdd(Et), Et = Et.redIAdd(Et);
  var wt = this.y.redMul(it.redMul(ht.redISub(it)).redISub(rt.redMul(at)));
  wt = wt.redIAdd(wt), wt = wt.redIAdd(wt), wt = wt.redIAdd(wt);
  var Rt = this.z.redAdd(rt).redSqr().redISub(ne).redISub(at);
  return this.curve.jpoint(Et, wt, Rt);
};
JPoint.prototype.mul = function(L, J) {
  return L = new BN$8(L, J), this.curve._wnafMul(this, L);
};
JPoint.prototype.eq = function(L) {
  if (L.type === "affine")
    return this.eq(L.toJ());
  if (this === L)
    return !0;
  var J = this.z.redSqr(), ne = L.z.redSqr();
  if (this.x.redMul(ne).redISub(L.x.redMul(J)).cmpn(0) !== 0)
    return !1;
  var oe = J.redMul(this.z), ce = ne.redMul(L.z);
  return this.y.redMul(ce).redISub(L.y.redMul(oe)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(L) {
  var J = this.z.redSqr(), ne = L.toRed(this.curve.red).redMul(J);
  if (this.x.cmp(ne) === 0)
    return !0;
  for (var oe = L.clone(), ce = this.curve.redN.redMul(J); ; ) {
    if (oe.iadd(this.curve.n), oe.cmp(this.curve.p) >= 0)
      return !1;
    if (ne.redIAdd(ce), this.x.cmp(ne) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$1, inherits$3 = inherits_browserExports, Base$1 = base$3, utils$h = utils$l;
function MontCurve(B) {
  Base$1.call(this, "mont", B), this.a = new BN$7(B.a, 16).toRed(this.red), this.b = new BN$7(B.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(L) {
  var J = L.normalize().x, ne = J.redSqr(), oe = ne.redMul(J).redAdd(ne.redMul(this.a)).redAdd(J), ce = oe.redSqrt();
  return ce.redSqr().cmp(oe) === 0;
};
function Point$1(B, L, J) {
  Base$1.BasePoint.call(this, B, "projective"), L === null && J === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(L, 16), this.z = new BN$7(J, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(L, J) {
  return this.point(utils$h.toArray(L, J), 1);
};
MontCurve.prototype.point = function(L, J) {
  return new Point$1(this, L, J);
};
MontCurve.prototype.pointFromJSON = function(L) {
  return Point$1.fromJSON(this, L);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(L, J) {
  return new Point$1(L, J[0], J[1] || L.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var L = this.x.redAdd(this.z), J = L.redSqr(), ne = this.x.redSub(this.z), oe = ne.redSqr(), ce = J.redSub(oe), Ce = J.redMul(oe), rt = ce.redMul(oe.redAdd(this.curve.a24.redMul(ce)));
  return this.curve.point(Ce, rt);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(L, J) {
  var ne = this.x.redAdd(this.z), oe = this.x.redSub(this.z), ce = L.x.redAdd(L.z), Ce = L.x.redSub(L.z), rt = Ce.redMul(ne), at = ce.redMul(oe), ht = J.z.redMul(rt.redAdd(at).redSqr()), it = J.x.redMul(rt.redISub(at).redSqr());
  return this.curve.point(ht, it);
};
Point$1.prototype.mul = function(L) {
  for (var J = L.clone(), ne = this, oe = this.curve.point(null, null), ce = this, Ce = []; J.cmpn(0) !== 0; J.iushrn(1))
    Ce.push(J.andln(1));
  for (var rt = Ce.length - 1; rt >= 0; rt--)
    Ce[rt] === 0 ? (ne = ne.diffAdd(oe, ce), oe = oe.dbl()) : (oe = ne.diffAdd(oe, ce), ne = ne.dbl());
  return oe;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(L) {
  return this.getX().cmp(L.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$g = utils$l, BN$6 = bnExports$1, inherits$2 = inherits_browserExports, Base = base$3, assert$d = utils$g.assert;
function EdwardsCurve(B) {
  this.twisted = (B.a | 0) !== 1, this.mOneA = this.twisted && (B.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", B), this.a = new BN$6(B.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(B.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(B.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$d(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (B.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(L) {
  return this.mOneA ? L.redNeg() : this.a.redMul(L);
};
EdwardsCurve.prototype._mulC = function(L) {
  return this.oneC ? L : this.c.redMul(L);
};
EdwardsCurve.prototype.jpoint = function(L, J, ne, oe) {
  return this.point(L, J, ne, oe);
};
EdwardsCurve.prototype.pointFromX = function(L, J) {
  L = new BN$6(L, 16), L.red || (L = L.toRed(this.red));
  var ne = L.redSqr(), oe = this.c2.redSub(this.a.redMul(ne)), ce = this.one.redSub(this.c2.redMul(this.d).redMul(ne)), Ce = oe.redMul(ce.redInvm()), rt = Ce.redSqrt();
  if (rt.redSqr().redSub(Ce).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var at = rt.fromRed().isOdd();
  return (J && !at || !J && at) && (rt = rt.redNeg()), this.point(L, rt);
};
EdwardsCurve.prototype.pointFromY = function(L, J) {
  L = new BN$6(L, 16), L.red || (L = L.toRed(this.red));
  var ne = L.redSqr(), oe = ne.redSub(this.c2), ce = ne.redMul(this.d).redMul(this.c2).redSub(this.a), Ce = oe.redMul(ce.redInvm());
  if (Ce.cmp(this.zero) === 0) {
    if (J)
      throw new Error("invalid point");
    return this.point(this.zero, L);
  }
  var rt = Ce.redSqrt();
  if (rt.redSqr().redSub(Ce).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return rt.fromRed().isOdd() !== J && (rt = rt.redNeg()), this.point(rt, L);
};
EdwardsCurve.prototype.validate = function(L) {
  if (L.isInfinity())
    return !0;
  L.normalize();
  var J = L.x.redSqr(), ne = L.y.redSqr(), oe = J.redMul(this.a).redAdd(ne), ce = this.c2.redMul(this.one.redAdd(this.d.redMul(J).redMul(ne)));
  return oe.cmp(ce) === 0;
};
function Point(B, L, J, ne, oe) {
  Base.BasePoint.call(this, B, "projective"), L === null && J === null && ne === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(L, 16), this.y = new BN$6(J, 16), this.z = ne ? new BN$6(ne, 16) : this.curve.one, this.t = oe && new BN$6(oe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(L) {
  return Point.fromJSON(this, L);
};
EdwardsCurve.prototype.point = function(L, J, ne, oe) {
  return new Point(this, L, J, ne, oe);
};
Point.fromJSON = function(L, J) {
  return new Point(L, J[0], J[1], J[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var L = this.x.redSqr(), J = this.y.redSqr(), ne = this.z.redSqr();
  ne = ne.redIAdd(ne);
  var oe = this.curve._mulA(L), ce = this.x.redAdd(this.y).redSqr().redISub(L).redISub(J), Ce = oe.redAdd(J), rt = Ce.redSub(ne), at = oe.redSub(J), ht = ce.redMul(rt), it = Ce.redMul(at), lt = ce.redMul(at), Et = rt.redMul(Ce);
  return this.curve.point(ht, it, Et, lt);
};
Point.prototype._projDbl = function() {
  var L = this.x.redAdd(this.y).redSqr(), J = this.x.redSqr(), ne = this.y.redSqr(), oe, ce, Ce, rt, at, ht;
  if (this.curve.twisted) {
    rt = this.curve._mulA(J);
    var it = rt.redAdd(ne);
    this.zOne ? (oe = L.redSub(J).redSub(ne).redMul(it.redSub(this.curve.two)), ce = it.redMul(rt.redSub(ne)), Ce = it.redSqr().redSub(it).redSub(it)) : (at = this.z.redSqr(), ht = it.redSub(at).redISub(at), oe = L.redSub(J).redISub(ne).redMul(ht), ce = it.redMul(rt.redSub(ne)), Ce = it.redMul(ht));
  } else
    rt = J.redAdd(ne), at = this.curve._mulC(this.z).redSqr(), ht = rt.redSub(at).redSub(at), oe = this.curve._mulC(L.redISub(rt)).redMul(ht), ce = this.curve._mulC(rt).redMul(J.redISub(ne)), Ce = rt.redMul(ht);
  return this.curve.point(oe, ce, Ce);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(L) {
  var J = this.y.redSub(this.x).redMul(L.y.redSub(L.x)), ne = this.y.redAdd(this.x).redMul(L.y.redAdd(L.x)), oe = this.t.redMul(this.curve.dd).redMul(L.t), ce = this.z.redMul(L.z.redAdd(L.z)), Ce = ne.redSub(J), rt = ce.redSub(oe), at = ce.redAdd(oe), ht = ne.redAdd(J), it = Ce.redMul(rt), lt = at.redMul(ht), Et = Ce.redMul(ht), wt = rt.redMul(at);
  return this.curve.point(it, lt, wt, Et);
};
Point.prototype._projAdd = function(L) {
  var J = this.z.redMul(L.z), ne = J.redSqr(), oe = this.x.redMul(L.x), ce = this.y.redMul(L.y), Ce = this.curve.d.redMul(oe).redMul(ce), rt = ne.redSub(Ce), at = ne.redAdd(Ce), ht = this.x.redAdd(this.y).redMul(L.x.redAdd(L.y)).redISub(oe).redISub(ce), it = J.redMul(rt).redMul(ht), lt, Et;
  return this.curve.twisted ? (lt = J.redMul(at).redMul(ce.redSub(this.curve._mulA(oe))), Et = rt.redMul(at)) : (lt = J.redMul(at).redMul(ce.redSub(oe)), Et = this.curve._mulC(rt).redMul(at)), this.curve.point(it, lt, Et);
};
Point.prototype.add = function(L) {
  return this.isInfinity() ? L : L.isInfinity() ? this : this.curve.extended ? this._extAdd(L) : this._projAdd(L);
};
Point.prototype.mul = function(L) {
  return this._hasDoubles(L) ? this.curve._fixedNafMul(this, L) : this.curve._wnafMul(this, L);
};
Point.prototype.mulAdd = function(L, J, ne) {
  return this.curve._wnafMulAdd(1, [this, J], [L, ne], 2, !1);
};
Point.prototype.jmulAdd = function(L, J, ne) {
  return this.curve._wnafMulAdd(1, [this, J], [L, ne], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var L = this.z.redInvm();
  return this.x = this.x.redMul(L), this.y = this.y.redMul(L), this.t && (this.t = this.t.redMul(L)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(L) {
  return this === L || this.getX().cmp(L.getX()) === 0 && this.getY().cmp(L.getY()) === 0;
};
Point.prototype.eqXToP = function(L) {
  var J = L.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(J) === 0)
    return !0;
  for (var ne = L.clone(), oe = this.curve.redN.redMul(this.z); ; ) {
    if (ne.iadd(this.curve.n), ne.cmp(this.curve.p) >= 0)
      return !1;
    if (J.redIAdd(oe), this.x.cmp(J) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(B) {
  var L = B;
  L.base = base$3, L.short = short, L.mont = mont, L.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$f = {}, assert$c = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$f.inherits = inherits$1;
function isSurrogatePair(B, L) {
  return (B.charCodeAt(L) & 64512) !== 55296 || L < 0 || L + 1 >= B.length ? !1 : (B.charCodeAt(L + 1) & 64512) === 56320;
}
function toArray(B, L) {
  if (Array.isArray(B))
    return B.slice();
  if (!B)
    return [];
  var J = [];
  if (typeof B == "string")
    if (L) {
      if (L === "hex")
        for (B = B.replace(/[^a-z0-9]+/ig, ""), B.length % 2 !== 0 && (B = "0" + B), oe = 0; oe < B.length; oe += 2)
          J.push(parseInt(B[oe] + B[oe + 1], 16));
    } else for (var ne = 0, oe = 0; oe < B.length; oe++) {
      var ce = B.charCodeAt(oe);
      ce < 128 ? J[ne++] = ce : ce < 2048 ? (J[ne++] = ce >> 6 | 192, J[ne++] = ce & 63 | 128) : isSurrogatePair(B, oe) ? (ce = 65536 + ((ce & 1023) << 10) + (B.charCodeAt(++oe) & 1023), J[ne++] = ce >> 18 | 240, J[ne++] = ce >> 12 & 63 | 128, J[ne++] = ce >> 6 & 63 | 128, J[ne++] = ce & 63 | 128) : (J[ne++] = ce >> 12 | 224, J[ne++] = ce >> 6 & 63 | 128, J[ne++] = ce & 63 | 128);
    }
  else
    for (oe = 0; oe < B.length; oe++)
      J[oe] = B[oe] | 0;
  return J;
}
utils$f.toArray = toArray;
function toHex(B) {
  for (var L = "", J = 0; J < B.length; J++)
    L += zero2(B[J].toString(16));
  return L;
}
utils$f.toHex = toHex;
function htonl(B) {
  var L = B >>> 24 | B >>> 8 & 65280 | B << 8 & 16711680 | (B & 255) << 24;
  return L >>> 0;
}
utils$f.htonl = htonl;
function toHex32(B, L) {
  for (var J = "", ne = 0; ne < B.length; ne++) {
    var oe = B[ne];
    L === "little" && (oe = htonl(oe)), J += zero8(oe.toString(16));
  }
  return J;
}
utils$f.toHex32 = toHex32;
function zero2(B) {
  return B.length === 1 ? "0" + B : B;
}
utils$f.zero2 = zero2;
function zero8(B) {
  return B.length === 7 ? "0" + B : B.length === 6 ? "00" + B : B.length === 5 ? "000" + B : B.length === 4 ? "0000" + B : B.length === 3 ? "00000" + B : B.length === 2 ? "000000" + B : B.length === 1 ? "0000000" + B : B;
}
utils$f.zero8 = zero8;
function join32(B, L, J, ne) {
  var oe = J - L;
  assert$c(oe % 4 === 0);
  for (var ce = new Array(oe / 4), Ce = 0, rt = L; Ce < ce.length; Ce++, rt += 4) {
    var at;
    ne === "big" ? at = B[rt] << 24 | B[rt + 1] << 16 | B[rt + 2] << 8 | B[rt + 3] : at = B[rt + 3] << 24 | B[rt + 2] << 16 | B[rt + 1] << 8 | B[rt], ce[Ce] = at >>> 0;
  }
  return ce;
}
utils$f.join32 = join32;
function split32(B, L) {
  for (var J = new Array(B.length * 4), ne = 0, oe = 0; ne < B.length; ne++, oe += 4) {
    var ce = B[ne];
    L === "big" ? (J[oe] = ce >>> 24, J[oe + 1] = ce >>> 16 & 255, J[oe + 2] = ce >>> 8 & 255, J[oe + 3] = ce & 255) : (J[oe + 3] = ce >>> 24, J[oe + 2] = ce >>> 16 & 255, J[oe + 1] = ce >>> 8 & 255, J[oe] = ce & 255);
  }
  return J;
}
utils$f.split32 = split32;
function rotr32$1(B, L) {
  return B >>> L | B << 32 - L;
}
utils$f.rotr32 = rotr32$1;
function rotl32$2(B, L) {
  return B << L | B >>> 32 - L;
}
utils$f.rotl32 = rotl32$2;
function sum32$3(B, L) {
  return B + L >>> 0;
}
utils$f.sum32 = sum32$3;
function sum32_3$1(B, L, J) {
  return B + L + J >>> 0;
}
utils$f.sum32_3 = sum32_3$1;
function sum32_4$2(B, L, J, ne) {
  return B + L + J + ne >>> 0;
}
utils$f.sum32_4 = sum32_4$2;
function sum32_5$2(B, L, J, ne, oe) {
  return B + L + J + ne + oe >>> 0;
}
utils$f.sum32_5 = sum32_5$2;
function sum64$1(B, L, J, ne) {
  var oe = B[L], ce = B[L + 1], Ce = ne + ce >>> 0, rt = (Ce < ne ? 1 : 0) + J + oe;
  B[L] = rt >>> 0, B[L + 1] = Ce;
}
utils$f.sum64 = sum64$1;
function sum64_hi$1(B, L, J, ne) {
  var oe = L + ne >>> 0, ce = (oe < L ? 1 : 0) + B + J;
  return ce >>> 0;
}
utils$f.sum64_hi = sum64_hi$1;
function sum64_lo$1(B, L, J, ne) {
  var oe = L + ne;
  return oe >>> 0;
}
utils$f.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(B, L, J, ne, oe, ce, Ce, rt) {
  var at = 0, ht = L;
  ht = ht + ne >>> 0, at += ht < L ? 1 : 0, ht = ht + ce >>> 0, at += ht < ce ? 1 : 0, ht = ht + rt >>> 0, at += ht < rt ? 1 : 0;
  var it = B + J + oe + Ce + at;
  return it >>> 0;
}
utils$f.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(B, L, J, ne, oe, ce, Ce, rt) {
  var at = L + ne + ce + rt;
  return at >>> 0;
}
utils$f.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(B, L, J, ne, oe, ce, Ce, rt, at, ht) {
  var it = 0, lt = L;
  lt = lt + ne >>> 0, it += lt < L ? 1 : 0, lt = lt + ce >>> 0, it += lt < ce ? 1 : 0, lt = lt + rt >>> 0, it += lt < rt ? 1 : 0, lt = lt + ht >>> 0, it += lt < ht ? 1 : 0;
  var Et = B + J + oe + Ce + at + it;
  return Et >>> 0;
}
utils$f.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(B, L, J, ne, oe, ce, Ce, rt, at, ht) {
  var it = L + ne + ce + rt + ht;
  return it >>> 0;
}
utils$f.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(B, L, J) {
  var ne = L << 32 - J | B >>> J;
  return ne >>> 0;
}
utils$f.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(B, L, J) {
  var ne = B << 32 - J | L >>> J;
  return ne >>> 0;
}
utils$f.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(B, L, J) {
  return B >>> J;
}
utils$f.shr64_hi = shr64_hi$1;
function shr64_lo$1(B, L, J) {
  var ne = B << 32 - J | L >>> J;
  return ne >>> 0;
}
utils$f.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$e = utils$f, assert$b = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(L, J) {
  if (L = utils$e.toArray(L, J), this.pending ? this.pending = this.pending.concat(L) : this.pending = L, this.pendingTotal += L.length, this.pending.length >= this._delta8) {
    L = this.pending;
    var ne = L.length % this._delta8;
    this.pending = L.slice(L.length - ne, L.length), this.pending.length === 0 && (this.pending = null), L = utils$e.join32(L, 0, L.length - ne, this.endian);
    for (var oe = 0; oe < L.length; oe += this._delta32)
      this._update(L, oe, oe + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(L) {
  return this.update(this._pad()), assert$b(this.pending === null), this._digest(L);
};
BlockHash$4.prototype._pad = function() {
  var L = this.pendingTotal, J = this._delta8, ne = J - (L + this.padLength) % J, oe = new Array(ne + this.padLength);
  oe[0] = 128;
  for (var ce = 1; ce < ne; ce++)
    oe[ce] = 0;
  if (L <<= 3, this.endian === "big") {
    for (var Ce = 8; Ce < this.padLength; Ce++)
      oe[ce++] = 0;
    oe[ce++] = 0, oe[ce++] = 0, oe[ce++] = 0, oe[ce++] = 0, oe[ce++] = L >>> 24 & 255, oe[ce++] = L >>> 16 & 255, oe[ce++] = L >>> 8 & 255, oe[ce++] = L & 255;
  } else
    for (oe[ce++] = L & 255, oe[ce++] = L >>> 8 & 255, oe[ce++] = L >>> 16 & 255, oe[ce++] = L >>> 24 & 255, oe[ce++] = 0, oe[ce++] = 0, oe[ce++] = 0, oe[ce++] = 0, Ce = 8; Ce < this.padLength; Ce++)
      oe[ce++] = 0;
  return oe;
};
var sha = {}, common$4 = {}, utils$d = utils$f, rotr32 = utils$d.rotr32;
function ft_1$1(B, L, J, ne) {
  if (B === 0)
    return ch32$1(L, J, ne);
  if (B === 1 || B === 3)
    return p32(L, J, ne);
  if (B === 2)
    return maj32$1(L, J, ne);
}
common$4.ft_1 = ft_1$1;
function ch32$1(B, L, J) {
  return B & L ^ ~B & J;
}
common$4.ch32 = ch32$1;
function maj32$1(B, L, J) {
  return B & L ^ B & J ^ L & J;
}
common$4.maj32 = maj32$1;
function p32(B, L, J) {
  return B ^ L ^ J;
}
common$4.p32 = p32;
function s0_256$1(B) {
  return rotr32(B, 2) ^ rotr32(B, 13) ^ rotr32(B, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(B) {
  return rotr32(B, 6) ^ rotr32(B, 11) ^ rotr32(B, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(B) {
  return rotr32(B, 7) ^ rotr32(B, 18) ^ B >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(B) {
  return rotr32(B, 17) ^ rotr32(B, 19) ^ B >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$c = utils$f, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$c.rotl32, sum32$2 = utils$c.sum32, sum32_5$1 = utils$c.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$c.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(L, J) {
  for (var ne = this.W, oe = 0; oe < 16; oe++)
    ne[oe] = L[J + oe];
  for (; oe < ne.length; oe++)
    ne[oe] = rotl32$1(ne[oe - 3] ^ ne[oe - 8] ^ ne[oe - 14] ^ ne[oe - 16], 1);
  var ce = this.h[0], Ce = this.h[1], rt = this.h[2], at = this.h[3], ht = this.h[4];
  for (oe = 0; oe < ne.length; oe++) {
    var it = ~~(oe / 20), lt = sum32_5$1(rotl32$1(ce, 5), ft_1(it, Ce, rt, at), ht, ne[oe], sha1_K[it]);
    ht = at, at = rt, rt = rotl32$1(Ce, 30), Ce = ce, ce = lt;
  }
  this.h[0] = sum32$2(this.h[0], ce), this.h[1] = sum32$2(this.h[1], Ce), this.h[2] = sum32$2(this.h[2], rt), this.h[3] = sum32$2(this.h[3], at), this.h[4] = sum32$2(this.h[4], ht);
};
SHA1.prototype._digest = function(L) {
  return L === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$f, common$2 = common$5, shaCommon = common$4, assert$a = minimalisticAssert, sum32$1 = utils$b.sum32, sum32_4$1 = utils$b.sum32_4, sum32_5 = utils$b.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$b.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(L, J) {
  for (var ne = this.W, oe = 0; oe < 16; oe++)
    ne[oe] = L[J + oe];
  for (; oe < ne.length; oe++)
    ne[oe] = sum32_4$1(g1_256(ne[oe - 2]), ne[oe - 7], g0_256(ne[oe - 15]), ne[oe - 16]);
  var ce = this.h[0], Ce = this.h[1], rt = this.h[2], at = this.h[3], ht = this.h[4], it = this.h[5], lt = this.h[6], Et = this.h[7];
  for (assert$a(this.k.length === ne.length), oe = 0; oe < ne.length; oe++) {
    var wt = sum32_5(Et, s1_256(ht), ch32(ht, it, lt), this.k[oe], ne[oe]), Rt = sum32$1(s0_256(ce), maj32(ce, Ce, rt));
    Et = lt, lt = it, it = ht, ht = sum32$1(at, wt), at = rt, rt = Ce, Ce = ce, ce = sum32$1(wt, Rt);
  }
  this.h[0] = sum32$1(this.h[0], ce), this.h[1] = sum32$1(this.h[1], Ce), this.h[2] = sum32$1(this.h[2], rt), this.h[3] = sum32$1(this.h[3], at), this.h[4] = sum32$1(this.h[4], ht), this.h[5] = sum32$1(this.h[5], it), this.h[6] = sum32$1(this.h[6], lt), this.h[7] = sum32$1(this.h[7], Et);
};
SHA256$1.prototype._digest = function(L) {
  return L === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$f, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$a.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(L) {
  return L === "hex" ? utils$a.toHex32(this.h.slice(0, 7), "big") : utils$a.split32(this.h.slice(0, 7), "big");
};
var utils$9 = utils$f, common$1 = common$5, assert$9 = minimalisticAssert, rotr64_hi = utils$9.rotr64_hi, rotr64_lo = utils$9.rotr64_lo, shr64_hi = utils$9.shr64_hi, shr64_lo = utils$9.shr64_lo, sum64 = utils$9.sum64, sum64_hi = utils$9.sum64_hi, sum64_lo = utils$9.sum64_lo, sum64_4_hi = utils$9.sum64_4_hi, sum64_4_lo = utils$9.sum64_4_lo, sum64_5_hi = utils$9.sum64_5_hi, sum64_5_lo = utils$9.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$9.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function(L, J) {
  for (var ne = this.W, oe = 0; oe < 32; oe++)
    ne[oe] = L[J + oe];
  for (; oe < ne.length; oe += 2) {
    var ce = g1_512_hi(ne[oe - 4], ne[oe - 3]), Ce = g1_512_lo(ne[oe - 4], ne[oe - 3]), rt = ne[oe - 14], at = ne[oe - 13], ht = g0_512_hi(ne[oe - 30], ne[oe - 29]), it = g0_512_lo(ne[oe - 30], ne[oe - 29]), lt = ne[oe - 32], Et = ne[oe - 31];
    ne[oe] = sum64_4_hi(
      ce,
      Ce,
      rt,
      at,
      ht,
      it,
      lt,
      Et
    ), ne[oe + 1] = sum64_4_lo(
      ce,
      Ce,
      rt,
      at,
      ht,
      it,
      lt,
      Et
    );
  }
};
SHA512$2.prototype._update = function(L, J) {
  this._prepareBlock(L, J);
  var ne = this.W, oe = this.h[0], ce = this.h[1], Ce = this.h[2], rt = this.h[3], at = this.h[4], ht = this.h[5], it = this.h[6], lt = this.h[7], Et = this.h[8], wt = this.h[9], Rt = this.h[10], Mt = this.h[11], Lt = this.h[12], zt = this.h[13], Ot = this.h[14], It = this.h[15];
  assert$9(this.k.length === ne.length);
  for (var Ft = 0; Ft < ne.length; Ft += 2) {
    var Jt = Ot, Vt = It, yr = s1_512_hi(Et, wt), jt = s1_512_lo(Et, wt), Ut = ch64_hi(Et, wt, Rt, Mt, Lt), er = ch64_lo(Et, wt, Rt, Mt, Lt, zt), Ht = this.k[Ft], ct = this.k[Ft + 1], dt = ne[Ft], ot = ne[Ft + 1], ut = sum64_5_hi(
      Jt,
      Vt,
      yr,
      jt,
      Ut,
      er,
      Ht,
      ct,
      dt,
      ot
    ), mt = sum64_5_lo(
      Jt,
      Vt,
      yr,
      jt,
      Ut,
      er,
      Ht,
      ct,
      dt,
      ot
    );
    Jt = s0_512_hi(oe, ce), Vt = s0_512_lo(oe, ce), yr = maj64_hi(oe, ce, Ce, rt, at), jt = maj64_lo(oe, ce, Ce, rt, at, ht);
    var gt = sum64_hi(Jt, Vt, yr, jt), St = sum64_lo(Jt, Vt, yr, jt);
    Ot = Lt, It = zt, Lt = Rt, zt = Mt, Rt = Et, Mt = wt, Et = sum64_hi(it, lt, ut, mt), wt = sum64_lo(lt, lt, ut, mt), it = at, lt = ht, at = Ce, ht = rt, Ce = oe, rt = ce, oe = sum64_hi(ut, mt, gt, St), ce = sum64_lo(ut, mt, gt, St);
  }
  sum64(this.h, 0, oe, ce), sum64(this.h, 2, Ce, rt), sum64(this.h, 4, at, ht), sum64(this.h, 6, it, lt), sum64(this.h, 8, Et, wt), sum64(this.h, 10, Rt, Mt), sum64(this.h, 12, Lt, zt), sum64(this.h, 14, Ot, It);
};
SHA512$2.prototype._digest = function(L) {
  return L === "hex" ? utils$9.toHex32(this.h, "big") : utils$9.split32(this.h, "big");
};
function ch64_hi(B, L, J, ne, oe) {
  var ce = B & J ^ ~B & oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function ch64_lo(B, L, J, ne, oe, ce) {
  var Ce = L & ne ^ ~L & ce;
  return Ce < 0 && (Ce += 4294967296), Ce;
}
function maj64_hi(B, L, J, ne, oe) {
  var ce = B & J ^ B & oe ^ J & oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function maj64_lo(B, L, J, ne, oe, ce) {
  var Ce = L & ne ^ L & ce ^ ne & ce;
  return Ce < 0 && (Ce += 4294967296), Ce;
}
function s0_512_hi(B, L) {
  var J = rotr64_hi(B, L, 28), ne = rotr64_hi(L, B, 2), oe = rotr64_hi(L, B, 7), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function s0_512_lo(B, L) {
  var J = rotr64_lo(B, L, 28), ne = rotr64_lo(L, B, 2), oe = rotr64_lo(L, B, 7), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function s1_512_hi(B, L) {
  var J = rotr64_hi(B, L, 14), ne = rotr64_hi(B, L, 18), oe = rotr64_hi(L, B, 9), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function s1_512_lo(B, L) {
  var J = rotr64_lo(B, L, 14), ne = rotr64_lo(B, L, 18), oe = rotr64_lo(L, B, 9), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function g0_512_hi(B, L) {
  var J = rotr64_hi(B, L, 1), ne = rotr64_hi(B, L, 8), oe = shr64_hi(B, L, 7), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function g0_512_lo(B, L) {
  var J = rotr64_lo(B, L, 1), ne = rotr64_lo(B, L, 8), oe = shr64_lo(B, L, 7), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function g1_512_hi(B, L) {
  var J = rotr64_hi(B, L, 19), ne = rotr64_hi(L, B, 29), oe = shr64_hi(B, L, 6), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
function g1_512_lo(B, L) {
  var J = rotr64_lo(B, L, 19), ne = rotr64_lo(L, B, 29), oe = shr64_lo(B, L, 6), ce = J ^ ne ^ oe;
  return ce < 0 && (ce += 4294967296), ce;
}
var utils$8 = utils$f, SHA512$1 = _512;
function SHA384$1() {
  if (!(this instanceof SHA384$1))
    return new SHA384$1();
  SHA512$1.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$8.inherits(SHA384$1, SHA512$1);
var _384 = SHA384$1;
SHA384$1.blockSize = 1024;
SHA384$1.outSize = 384;
SHA384$1.hmacStrength = 192;
SHA384$1.padLength = 128;
SHA384$1.prototype._digest = function(L) {
  return L === "hex" ? utils$8.toHex32(this.h.slice(0, 12), "big") : utils$8.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$7 = utils$f, common = common$5, rotl32 = utils$7.rotl32, sum32 = utils$7.sum32, sum32_3 = utils$7.sum32_3, sum32_4 = utils$7.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$7.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(L, J) {
  for (var ne = this.h[0], oe = this.h[1], ce = this.h[2], Ce = this.h[3], rt = this.h[4], at = ne, ht = oe, it = ce, lt = Ce, Et = rt, wt = 0; wt < 80; wt++) {
    var Rt = sum32(
      rotl32(
        sum32_4(ne, f$1(wt, oe, ce, Ce), L[r$1[wt] + J], K(wt)),
        s$1[wt]
      ),
      rt
    );
    ne = rt, rt = Ce, Ce = rotl32(ce, 10), ce = oe, oe = Rt, Rt = sum32(
      rotl32(
        sum32_4(at, f$1(79 - wt, ht, it, lt), L[rh[wt] + J], Kh(wt)),
        sh[wt]
      ),
      Et
    ), at = Et, Et = lt, lt = rotl32(it, 10), it = ht, ht = Rt;
  }
  Rt = sum32_3(this.h[1], ce, lt), this.h[1] = sum32_3(this.h[2], Ce, Et), this.h[2] = sum32_3(this.h[3], rt, at), this.h[3] = sum32_3(this.h[4], ne, ht), this.h[4] = sum32_3(this.h[0], oe, it), this.h[0] = Rt;
};
RIPEMD160.prototype._digest = function(L) {
  return L === "hex" ? utils$7.toHex32(this.h, "little") : utils$7.split32(this.h, "little");
};
function f$1(B, L, J, ne) {
  return B <= 15 ? L ^ J ^ ne : B <= 31 ? L & J | ~L & ne : B <= 47 ? (L | ~J) ^ ne : B <= 63 ? L & ne | J & ~ne : L ^ (J | ~ne);
}
function K(B) {
  return B <= 15 ? 0 : B <= 31 ? 1518500249 : B <= 47 ? 1859775393 : B <= 63 ? 2400959708 : 2840853838;
}
function Kh(B) {
  return B <= 15 ? 1352829926 : B <= 31 ? 1548603684 : B <= 47 ? 1836072691 : B <= 63 ? 2053994217 : 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$6 = utils$f, assert$8 = minimalisticAssert;
function Hmac(B, L, J) {
  if (!(this instanceof Hmac))
    return new Hmac(B, L, J);
  this.Hash = B, this.blockSize = B.blockSize / 8, this.outSize = B.outSize / 8, this.inner = null, this.outer = null, this._init(utils$6.toArray(L, J));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function(L) {
  L.length > this.blockSize && (L = new this.Hash().update(L).digest()), assert$8(L.length <= this.blockSize);
  for (var J = L.length; J < this.blockSize; J++)
    L.push(0);
  for (J = 0; J < L.length; J++)
    L[J] ^= 54;
  for (this.inner = new this.Hash().update(L), J = 0; J < L.length; J++)
    L[J] ^= 106;
  this.outer = new this.Hash().update(L);
};
Hmac.prototype.update = function(L, J) {
  return this.inner.update(L, J), this;
};
Hmac.prototype.digest = function(L) {
  return this.outer.update(this.inner.digest()), this.outer.digest(L);
};
(function(B) {
  var L = B;
  L.utils = utils$f, L.common = common$5, L.sha = sha, L.ripemd = ripemd, L.hmac = hmac$1, L.sha1 = L.sha.sha1, L.sha256 = L.sha.sha256, L.sha224 = L.sha.sha224, L.sha384 = L.sha.sha384, L.sha512 = L.sha.sha512, L.ripemd160 = L.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(B) {
  var L = B, J = hash$2, ne = curve, oe = utils$l, ce = oe.assert;
  function Ce(ht) {
    ht.type === "short" ? this.curve = new ne.short(ht) : ht.type === "edwards" ? this.curve = new ne.edwards(ht) : this.curve = new ne.mont(ht), this.g = this.curve.g, this.n = this.curve.n, this.hash = ht.hash, ce(this.g.validate(), "Invalid curve"), ce(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  L.PresetCurve = Ce;
  function rt(ht, it) {
    Object.defineProperty(L, ht, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var lt = new Ce(it);
        return Object.defineProperty(L, ht, {
          configurable: !0,
          enumerable: !0,
          value: lt
        }), lt;
      }
    });
  }
  rt("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: J.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), rt("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: J.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), rt("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: J.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), rt("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: J.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), rt("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: J.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), rt("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: J.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), rt("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: J.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var at;
  try {
    at = requireSecp256k1();
  } catch {
    at = void 0;
  }
  rt("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: J.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      at
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$5 = utils$k, assert$7 = minimalisticAssert;
function HmacDRBG(B) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(B);
  this.hash = B.hash, this.predResist = !!B.predResist, this.outLen = this.hash.outSize, this.minEntropy = B.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var L = utils$5.toArray(B.entropy, B.entropyEnc || "hex"), J = utils$5.toArray(B.nonce, B.nonceEnc || "hex"), ne = utils$5.toArray(B.pers, B.persEnc || "hex");
  assert$7(
    L.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(L, J, ne);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(L, J, ne) {
  var oe = L.concat(J).concat(ne);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var ce = 0; ce < this.V.length; ce++)
    this.K[ce] = 0, this.V[ce] = 1;
  this._update(oe), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(L) {
  var J = this._hmac().update(this.V).update([0]);
  L && (J = J.update(L)), this.K = J.digest(), this.V = this._hmac().update(this.V).digest(), L && (this.K = this._hmac().update(this.V).update([1]).update(L).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(L, J, ne, oe) {
  typeof J != "string" && (oe = ne, ne = J, J = null), L = utils$5.toArray(L, J), ne = utils$5.toArray(ne, oe), assert$7(
    L.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(L.concat(ne || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(L, J, ne, oe) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof J != "string" && (oe = ne, ne = J, J = null), ne && (ne = utils$5.toArray(ne, oe || "hex"), this._update(ne));
  for (var ce = []; ce.length < L; )
    this.V = this._hmac().update(this.V).digest(), ce = ce.concat(this.V);
  var Ce = ce.slice(0, L);
  return this._update(ne), this._reseed++, utils$5.encode(Ce, J);
};
var BN$5 = bnExports$1, utils$4 = utils$l, assert$6 = utils$4.assert;
function KeyPair$2(B, L) {
  this.ec = B, this.priv = null, this.pub = null, L.priv && this._importPrivate(L.priv, L.privEnc), L.pub && this._importPublic(L.pub, L.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(L, J, ne) {
  return J instanceof KeyPair$2 ? J : new KeyPair$2(L, {
    pub: J,
    pubEnc: ne
  });
};
KeyPair$2.fromPrivate = function(L, J, ne) {
  return J instanceof KeyPair$2 ? J : new KeyPair$2(L, {
    priv: J,
    privEnc: ne
  });
};
KeyPair$2.prototype.validate = function() {
  var L = this.getPublic();
  return L.isInfinity() ? { result: !1, reason: "Invalid public key" } : L.validate() ? L.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(L, J) {
  return typeof L == "string" && (J = L, L = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), J ? this.pub.encode(J, L) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(L) {
  return L === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(L, J) {
  this.priv = new BN$5(L, J || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(L, J) {
  if (L.x || L.y) {
    this.ec.curve.type === "mont" ? assert$6(L.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$6(L.x && L.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(L.x, L.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(L, J);
};
KeyPair$2.prototype.derive = function(L) {
  return L.validate() || assert$6(L.validate(), "public point not validated"), L.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(L, J, ne) {
  return this.ec.sign(L, this, J, ne);
};
KeyPair$2.prototype.verify = function(L, J) {
  return this.ec.verify(L, J, this);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$1, utils$3 = utils$l, assert$5 = utils$3.assert;
function Signature$2(B, L) {
  if (B instanceof Signature$2)
    return B;
  this._importDER(B, L) || (assert$5(B.r && B.s, "Signature without r or s"), this.r = new BN$4(B.r, 16), this.s = new BN$4(B.s, 16), B.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = B.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(B, L) {
  var J = B[L.place++];
  if (!(J & 128))
    return J;
  var ne = J & 15;
  if (ne === 0 || ne > 4 || B[L.place] === 0)
    return !1;
  for (var oe = 0, ce = 0, Ce = L.place; ce < ne; ce++, Ce++)
    oe <<= 8, oe |= B[Ce], oe >>>= 0;
  return oe <= 127 ? !1 : (L.place = Ce, oe);
}
function rmPadding(B) {
  for (var L = 0, J = B.length - 1; !B[L] && !(B[L + 1] & 128) && L < J; )
    L++;
  return L === 0 ? B : B.slice(L);
}
Signature$2.prototype._importDER = function(L, J) {
  L = utils$3.toArray(L, J);
  var ne = new Position();
  if (L[ne.place++] !== 48)
    return !1;
  var oe = getLength(L, ne);
  if (oe === !1 || oe + ne.place !== L.length || L[ne.place++] !== 2)
    return !1;
  var ce = getLength(L, ne);
  if (ce === !1 || L[ne.place] & 128)
    return !1;
  var Ce = L.slice(ne.place, ce + ne.place);
  if (ne.place += ce, L[ne.place++] !== 2)
    return !1;
  var rt = getLength(L, ne);
  if (rt === !1 || L.length !== rt + ne.place || L[ne.place] & 128)
    return !1;
  var at = L.slice(ne.place, rt + ne.place);
  if (Ce[0] === 0)
    if (Ce[1] & 128)
      Ce = Ce.slice(1);
    else
      return !1;
  if (at[0] === 0)
    if (at[1] & 128)
      at = at.slice(1);
    else
      return !1;
  return this.r = new BN$4(Ce), this.s = new BN$4(at), this.recoveryParam = null, !0;
};
function constructLength(B, L) {
  if (L < 128) {
    B.push(L);
    return;
  }
  var J = 1 + (Math.log(L) / Math.LN2 >>> 3);
  for (B.push(J | 128); --J; )
    B.push(L >>> (J << 3) & 255);
  B.push(L);
}
Signature$2.prototype.toDER = function(L) {
  var J = this.r.toArray(), ne = this.s.toArray();
  for (J[0] & 128 && (J = [0].concat(J)), ne[0] & 128 && (ne = [0].concat(ne)), J = rmPadding(J), ne = rmPadding(ne); !ne[0] && !(ne[1] & 128); )
    ne = ne.slice(1);
  var oe = [2];
  constructLength(oe, J.length), oe = oe.concat(J), oe.push(2), constructLength(oe, ne.length);
  var ce = oe.concat(ne), Ce = [48];
  return constructLength(Ce, ce.length), Ce = Ce.concat(ce), utils$3.encode(Ce, L);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = bnExports$1, L = hmacDrbg, J = utils$l, ne = curves$1, oe = requireBrorand(), ce = J.assert, Ce = key$1, rt = signature$1;
  function at(ht) {
    if (!(this instanceof at))
      return new at(ht);
    typeof ht == "string" && (ce(
      Object.prototype.hasOwnProperty.call(ne, ht),
      "Unknown curve " + ht
    ), ht = ne[ht]), ht instanceof ne.PresetCurve && (ht = { curve: ht }), this.curve = ht.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ht.curve.g, this.g.precompute(ht.curve.n.bitLength() + 1), this.hash = ht.hash || ht.curve.hash;
  }
  return ec = at, at.prototype.keyPair = function(it) {
    return new Ce(this, it);
  }, at.prototype.keyFromPrivate = function(it, lt) {
    return Ce.fromPrivate(this, it, lt);
  }, at.prototype.keyFromPublic = function(it, lt) {
    return Ce.fromPublic(this, it, lt);
  }, at.prototype.genKeyPair = function(it) {
    it || (it = {});
    for (var lt = new L({
      hash: this.hash,
      pers: it.pers,
      persEnc: it.persEnc || "utf8",
      entropy: it.entropy || oe(this.hash.hmacStrength),
      entropyEnc: it.entropy && it.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Et = this.n.byteLength(), wt = this.n.sub(new B(2)); ; ) {
      var Rt = new B(lt.generate(Et));
      if (!(Rt.cmp(wt) > 0))
        return Rt.iaddn(1), this.keyFromPrivate(Rt);
    }
  }, at.prototype._truncateToN = function(it, lt) {
    var Et = it.byteLength() * 8 - this.n.bitLength();
    return Et > 0 && (it = it.ushrn(Et)), !lt && it.cmp(this.n) >= 0 ? it.sub(this.n) : it;
  }, at.prototype.sign = function(it, lt, Et, wt) {
    typeof Et == "object" && (wt = Et, Et = null), wt || (wt = {}), lt = this.keyFromPrivate(lt, Et), it = this._truncateToN(new B(it, 16));
    for (var Rt = this.n.byteLength(), Mt = lt.getPrivate().toArray("be", Rt), Lt = it.toArray("be", Rt), zt = new L({
      hash: this.hash,
      entropy: Mt,
      nonce: Lt,
      pers: wt.pers,
      persEnc: wt.persEnc || "utf8"
    }), Ot = this.n.sub(new B(1)), It = 0; ; It++) {
      var Ft = wt.k ? wt.k(It) : new B(zt.generate(this.n.byteLength()));
      if (Ft = this._truncateToN(Ft, !0), !(Ft.cmpn(1) <= 0 || Ft.cmp(Ot) >= 0)) {
        var Jt = this.g.mul(Ft);
        if (!Jt.isInfinity()) {
          var Vt = Jt.getX(), yr = Vt.umod(this.n);
          if (yr.cmpn(0) !== 0) {
            var jt = Ft.invm(this.n).mul(yr.mul(lt.getPrivate()).iadd(it));
            if (jt = jt.umod(this.n), jt.cmpn(0) !== 0) {
              var Ut = (Jt.getY().isOdd() ? 1 : 0) | (Vt.cmp(yr) !== 0 ? 2 : 0);
              return wt.canonical && jt.cmp(this.nh) > 0 && (jt = this.n.sub(jt), Ut ^= 1), new rt({ r: yr, s: jt, recoveryParam: Ut });
            }
          }
        }
      }
    }
  }, at.prototype.verify = function(it, lt, Et, wt) {
    it = this._truncateToN(new B(it, 16)), Et = this.keyFromPublic(Et, wt), lt = new rt(lt, "hex");
    var Rt = lt.r, Mt = lt.s;
    if (Rt.cmpn(1) < 0 || Rt.cmp(this.n) >= 0 || Mt.cmpn(1) < 0 || Mt.cmp(this.n) >= 0)
      return !1;
    var Lt = Mt.invm(this.n), zt = Lt.mul(it).umod(this.n), Ot = Lt.mul(Rt).umod(this.n), It;
    return this.curve._maxwellTrick ? (It = this.g.jmulAdd(zt, Et.getPublic(), Ot), It.isInfinity() ? !1 : It.eqXToP(Rt)) : (It = this.g.mulAdd(zt, Et.getPublic(), Ot), It.isInfinity() ? !1 : It.getX().umod(this.n).cmp(Rt) === 0);
  }, at.prototype.recoverPubKey = function(ht, it, lt, Et) {
    ce((3 & lt) === lt, "The recovery param is more than two bits"), it = new rt(it, Et);
    var wt = this.n, Rt = new B(ht), Mt = it.r, Lt = it.s, zt = lt & 1, Ot = lt >> 1;
    if (Mt.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ot)
      throw new Error("Unable to find sencond key candinate");
    Ot ? Mt = this.curve.pointFromX(Mt.add(this.curve.n), zt) : Mt = this.curve.pointFromX(Mt, zt);
    var It = it.r.invm(wt), Ft = wt.sub(Rt).mul(It).umod(wt), Jt = Lt.mul(It).umod(wt);
    return this.g.mulAdd(Ft, Mt, Jt);
  }, at.prototype.getKeyRecoveryParam = function(ht, it, lt, Et) {
    if (it = new rt(it, Et), it.recoveryParam !== null)
      return it.recoveryParam;
    for (var wt = 0; wt < 4; wt++) {
      var Rt;
      try {
        Rt = this.recoverPubKey(ht, it, wt);
      } catch {
        continue;
      }
      if (Rt.eq(lt))
        return wt;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$2 = utils$l, assert$4 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(B, L) {
  this.eddsa = B, this._secret = parseBytes$2(L.secret), B.isPoint(L.pub) ? this._pub = L.pub : this._pubBytes = parseBytes$2(L.pub);
}
KeyPair$1.fromPublic = function(L, J) {
  return J instanceof KeyPair$1 ? J : new KeyPair$1(L, { pub: J });
};
KeyPair$1.fromSecret = function(L, J) {
  return J instanceof KeyPair$1 ? J : new KeyPair$1(L, { secret: J });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var L = this.eddsa, J = this.hash(), ne = L.encodingLength - 1, oe = J.slice(0, L.encodingLength);
  return oe[0] &= 248, oe[ne] &= 127, oe[ne] |= 64, oe;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(L) {
  return assert$4(this._secret, "KeyPair can only verify"), this.eddsa.sign(L, this);
};
KeyPair$1.prototype.verify = function(L, J) {
  return this.eddsa.verify(L, J, this);
};
KeyPair$1.prototype.getSecret = function(L) {
  return assert$4(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), L);
};
KeyPair$1.prototype.getPublic = function(L) {
  return utils$2.encode(this.pubBytes(), L);
};
var key = KeyPair$1, BN$3 = bnExports$1, utils$1 = utils$l, assert$3 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(B, L) {
  this.eddsa = B, typeof L != "object" && (L = parseBytes$1(L)), Array.isArray(L) && (assert$3(L.length === B.encodingLength * 2, "Signature has invalid size"), L = {
    R: L.slice(0, B.encodingLength),
    S: L.slice(B.encodingLength)
  }), assert$3(L.R && L.S, "Signature without R or S"), B.isPoint(L.R) && (this._R = L.R), L.S instanceof BN$3 && (this._S = L.S), this._Rencoded = Array.isArray(L.R) ? L.R : L.Rencoded, this._Sencoded = Array.isArray(L.S) ? L.S : L.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils = utils$l, assert$2 = utils.assert, parseBytes = utils.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(B) {
  if (assert$2(B === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(B);
  B = curves[B].curve, this.curve = B, this.g = B.g, this.g.precompute(B.n.bitLength() + 1), this.pointClass = B.point().constructor, this.encodingLength = Math.ceil(B.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(L, J) {
  L = parseBytes(L);
  var ne = this.keyFromSecret(J), oe = this.hashInt(ne.messagePrefix(), L), ce = this.g.mul(oe), Ce = this.encodePoint(ce), rt = this.hashInt(Ce, ne.pubBytes(), L).mul(ne.priv()), at = oe.add(rt).umod(this.curve.n);
  return this.makeSignature({ R: ce, S: at, Rencoded: Ce });
};
EDDSA.prototype.verify = function(L, J, ne) {
  if (L = parseBytes(L), J = this.makeSignature(J), J.S().gte(J.eddsa.curve.n) || J.S().isNeg())
    return !1;
  var oe = this.keyFromPublic(ne), ce = this.hashInt(J.Rencoded(), oe.pubBytes(), L), Ce = this.g.mul(J.S()), rt = J.R().add(oe.pub().mul(ce));
  return rt.eq(Ce);
};
EDDSA.prototype.hashInt = function() {
  for (var L = this.hash(), J = 0; J < arguments.length; J++)
    L.update(arguments[J]);
  return utils.intFromLE(L.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(L) {
  return KeyPair.fromPublic(this, L);
};
EDDSA.prototype.keyFromSecret = function(L) {
  return KeyPair.fromSecret(this, L);
};
EDDSA.prototype.makeSignature = function(L) {
  return L instanceof Signature ? L : new Signature(this, L);
};
EDDSA.prototype.encodePoint = function(L) {
  var J = L.getY().toArray("le", this.encodingLength);
  return J[this.encodingLength - 1] |= L.getX().isOdd() ? 128 : 0, J;
};
EDDSA.prototype.decodePoint = function(L) {
  L = utils.parseBytes(L);
  var J = L.length - 1, ne = L.slice(0, J).concat(L[J] & -129), oe = (L[J] & 128) !== 0, ce = utils.intFromLE(ne);
  return this.curve.pointFromY(ce, oe);
};
EDDSA.prototype.encodeInt = function(L) {
  return L.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(L) {
  return utils.intFromLE(L);
};
EDDSA.prototype.isPoint = function(L) {
  return L instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var L = B;
    L.version = require$$0.version, L.utils = utils$l, L.rand = requireBrorand(), L.curve = curve, L.curves = curves$1, L.ec = requireEc(), L.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, L) {
      if (B.indexOf) return B.indexOf(L);
      for (var J = 0; J < B.length; J++)
        if (B[J] === L) return J;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var L = [];
      for (var J in B) L.push(J);
      return L;
    }, forEach = function(B, L) {
      if (B.forEach) return B.forEach(L);
      for (var J = 0; J < B.length; J++)
        L(B[J], J, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, L, J) {
          Object.defineProperty(B, L, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: J
          });
        };
      } catch {
        return function(L, J, ne) {
          L[J] = ne;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(L) {
      if (!(this instanceof Script)) return new Script(L);
      this.code = L;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var L = document.createElement("iframe");
      L.style || (L.style = {}), L.style.display = "none", document.body.appendChild(L);
      var J = L.contentWindow, ne = J.eval, oe = J.execScript;
      !ne && oe && (oe.call(J, "null"), ne = J.eval), forEach(Object_keys(B), function(rt) {
        J[rt] = B[rt];
      }), forEach(globals, function(rt) {
        B[rt] && (J[rt] = B[rt]);
      });
      var ce = Object_keys(J), Ce = ne.call(J, this.code);
      return forEach(Object_keys(J), function(rt) {
        (rt in B || indexOf(ce, rt) === -1) && (B[rt] = J[rt]);
      }), forEach(globals, function(rt) {
        rt in B || defineProp(B, rt, J[rt]);
      }), document.body.removeChild(L), Ce;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var L = Script.createContext(B), J = this.runInContext(L);
      return B && forEach(Object_keys(L), function(ne) {
        B[ne] = L[ne];
      }), J;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(L) {
        var J = Script(L);
        return J[B].apply(J, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var L = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(J) {
        L[J] = B[J];
      }), L;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var L = requireAsn1(), J = inherits_browserExports, ne = B;
    ne.define = function(Ce, rt) {
      return new oe(Ce, rt);
    };
    function oe(ce, Ce) {
      this.name = ce, this.body = Ce, this.decoders = {}, this.encoders = {};
    }
    oe.prototype._createNamed = function(Ce) {
      var rt;
      try {
        rt = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        rt = function(ht) {
          this._initNamed(ht);
        };
      }
      return J(rt, Ce), rt.prototype._initNamed = function(ht) {
        Ce.call(this, ht);
      }, new rt(this);
    }, oe.prototype._getDecoder = function(Ce) {
      return Ce = Ce || "der", this.decoders.hasOwnProperty(Ce) || (this.decoders[Ce] = this._createNamed(L.decoders[Ce])), this.decoders[Ce];
    }, oe.prototype.decode = function(Ce, rt, at) {
      return this._getDecoder(rt).decode(Ce, at);
    }, oe.prototype._getEncoder = function(Ce) {
      return Ce = Ce || "der", this.encoders.hasOwnProperty(Ce) || (this.encoders[Ce] = this._createNamed(L.encoders[Ce])), this.encoders[Ce];
    }, oe.prototype.encode = function(Ce, rt, at) {
      return this._getEncoder(rt).encode(Ce, at);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(B) {
  this._reporterState = {
    obj: null,
    path: [],
    options: B || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function B(L) {
  return L instanceof ReporterError;
};
Reporter.prototype.save = function B() {
  var L = this._reporterState;
  return { obj: L.obj, pathLen: L.path.length };
};
Reporter.prototype.restore = function B(L) {
  var J = this._reporterState;
  J.obj = L.obj, J.path = J.path.slice(0, L.pathLen);
};
Reporter.prototype.enterKey = function B(L) {
  return this._reporterState.path.push(L);
};
Reporter.prototype.exitKey = function B(L) {
  var J = this._reporterState;
  J.path = J.path.slice(0, L - 1);
};
Reporter.prototype.leaveKey = function B(L, J, ne) {
  var oe = this._reporterState;
  this.exitKey(L), oe.obj !== null && (oe.obj[J] = ne);
};
Reporter.prototype.path = function B() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function B() {
  var L = this._reporterState, J = L.obj;
  return L.obj = {}, J;
};
Reporter.prototype.leaveObject = function B(L) {
  var J = this._reporterState, ne = J.obj;
  return J.obj = L, ne;
};
Reporter.prototype.error = function B(L) {
  var J, ne = this._reporterState, oe = L instanceof ReporterError;
  if (oe ? J = L : J = new ReporterError(ne.path.map(function(ce) {
    return "[" + JSON.stringify(ce) + "]";
  }).join(""), L.message || L, L.stack), !ne.options.partial)
    throw J;
  return oe || ne.errors.push(J), J;
};
Reporter.prototype.wrapResult = function B(L) {
  var J = this._reporterState;
  return J.options.partial ? {
    result: this.isError(L) ? null : L,
    errors: J.errors
  } : L;
};
function ReporterError(B, L) {
  this.path = B, this.rethrow(L);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function B(L) {
  if (this.message = L + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (J) {
      this.stack = J.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = inherits_browserExports, L = requireBase().Reporter, J = require$$1$2.Buffer;
  function ne(ce, Ce) {
    if (L.call(this, Ce), !J.isBuffer(ce)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = ce, this.offset = 0, this.length = ce.length;
  }
  B(ne, L), buffer.DecoderBuffer = ne, ne.prototype.save = function() {
    return { offset: this.offset, reporter: L.prototype.save.call(this) };
  }, ne.prototype.restore = function(Ce) {
    var rt = new ne(this.base);
    return rt.offset = Ce.offset, rt.length = this.offset, this.offset = Ce.offset, L.prototype.restore.call(this, Ce.reporter), rt;
  }, ne.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, ne.prototype.readUInt8 = function(Ce) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(Ce || "DecoderBuffer overrun");
  }, ne.prototype.skip = function(Ce, rt) {
    if (!(this.offset + Ce <= this.length))
      return this.error(rt || "DecoderBuffer overrun");
    var at = new ne(this.base);
    return at._reporterState = this._reporterState, at.offset = this.offset, at.length = this.offset + Ce, this.offset += Ce, at;
  }, ne.prototype.raw = function(Ce) {
    return this.base.slice(Ce ? Ce.offset : this.offset, this.length);
  };
  function oe(ce, Ce) {
    if (Array.isArray(ce))
      this.length = 0, this.value = ce.map(function(rt) {
        return rt instanceof oe || (rt = new oe(rt, Ce)), this.length += rt.length, rt;
      }, this);
    else if (typeof ce == "number") {
      if (!(0 <= ce && ce <= 255))
        return Ce.error("non-byte EncoderBuffer value");
      this.value = ce, this.length = 1;
    } else if (typeof ce == "string")
      this.value = ce, this.length = J.byteLength(ce);
    else if (J.isBuffer(ce))
      this.value = ce, this.length = ce.length;
    else
      return Ce.error("Unsupported type: " + typeof ce);
  }
  return buffer.EncoderBuffer = oe, oe.prototype.join = function(Ce, rt) {
    return Ce || (Ce = new J(this.length)), rt || (rt = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(at) {
      at.join(Ce, rt), rt += at.length;
    }) : (typeof this.value == "number" ? Ce[rt] = this.value : typeof this.value == "string" ? Ce.write(this.value, rt) : J.isBuffer(this.value) && this.value.copy(Ce, rt), rt += this.length)), Ce;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, L = requireBase().EncoderBuffer, J = requireBase().DecoderBuffer, ne = minimalisticAssert, oe = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], ce = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(oe), Ce = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function rt(ht, it) {
    var lt = {};
    this._baseState = lt, lt.enc = ht, lt.parent = it || null, lt.children = null, lt.tag = null, lt.args = null, lt.reverseArgs = null, lt.choice = null, lt.optional = !1, lt.any = !1, lt.obj = !1, lt.use = null, lt.useDecoder = null, lt.key = null, lt.default = null, lt.explicit = null, lt.implicit = null, lt.contains = null, lt.parent || (lt.children = [], this._wrap());
  }
  node = rt;
  var at = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return rt.prototype.clone = function() {
    var it = this._baseState, lt = {};
    at.forEach(function(wt) {
      lt[wt] = it[wt];
    });
    var Et = new this.constructor(lt.parent);
    return Et._baseState = lt, Et;
  }, rt.prototype._wrap = function() {
    var it = this._baseState;
    ce.forEach(function(lt) {
      this[lt] = function() {
        var wt = new this.constructor(this);
        return it.children.push(wt), wt[lt].apply(wt, arguments);
      };
    }, this);
  }, rt.prototype._init = function(it) {
    var lt = this._baseState;
    ne(lt.parent === null), it.call(this), lt.children = lt.children.filter(function(Et) {
      return Et._baseState.parent === this;
    }, this), ne.equal(lt.children.length, 1, "Root node can have only one child");
  }, rt.prototype._useArgs = function(it) {
    var lt = this._baseState, Et = it.filter(function(wt) {
      return wt instanceof this.constructor;
    }, this);
    it = it.filter(function(wt) {
      return !(wt instanceof this.constructor);
    }, this), Et.length !== 0 && (ne(lt.children === null), lt.children = Et, Et.forEach(function(wt) {
      wt._baseState.parent = this;
    }, this)), it.length !== 0 && (ne(lt.args === null), lt.args = it, lt.reverseArgs = it.map(function(wt) {
      if (typeof wt != "object" || wt.constructor !== Object)
        return wt;
      var Rt = {};
      return Object.keys(wt).forEach(function(Mt) {
        Mt == (Mt | 0) && (Mt |= 0);
        var Lt = wt[Mt];
        Rt[Lt] = Mt;
      }), Rt;
    }));
  }, Ce.forEach(function(ht) {
    rt.prototype[ht] = function() {
      var lt = this._baseState;
      throw new Error(ht + " not implemented for encoding: " + lt.enc);
    };
  }), oe.forEach(function(ht) {
    rt.prototype[ht] = function() {
      var lt = this._baseState, Et = Array.prototype.slice.call(arguments);
      return ne(lt.tag === null), lt.tag = ht, this._useArgs(Et), this;
    };
  }), rt.prototype.use = function(it) {
    ne(it);
    var lt = this._baseState;
    return ne(lt.use === null), lt.use = it, this;
  }, rt.prototype.optional = function() {
    var it = this._baseState;
    return it.optional = !0, this;
  }, rt.prototype.def = function(it) {
    var lt = this._baseState;
    return ne(lt.default === null), lt.default = it, lt.optional = !0, this;
  }, rt.prototype.explicit = function(it) {
    var lt = this._baseState;
    return ne(lt.explicit === null && lt.implicit === null), lt.explicit = it, this;
  }, rt.prototype.implicit = function(it) {
    var lt = this._baseState;
    return ne(lt.explicit === null && lt.implicit === null), lt.implicit = it, this;
  }, rt.prototype.obj = function() {
    var it = this._baseState, lt = Array.prototype.slice.call(arguments);
    return it.obj = !0, lt.length !== 0 && this._useArgs(lt), this;
  }, rt.prototype.key = function(it) {
    var lt = this._baseState;
    return ne(lt.key === null), lt.key = it, this;
  }, rt.prototype.any = function() {
    var it = this._baseState;
    return it.any = !0, this;
  }, rt.prototype.choice = function(it) {
    var lt = this._baseState;
    return ne(lt.choice === null), lt.choice = it, this._useArgs(Object.keys(it).map(function(Et) {
      return it[Et];
    })), this;
  }, rt.prototype.contains = function(it) {
    var lt = this._baseState;
    return ne(lt.use === null), lt.contains = it, this;
  }, rt.prototype._decode = function(it, lt) {
    var Et = this._baseState;
    if (Et.parent === null)
      return it.wrapResult(Et.children[0]._decode(it, lt));
    var wt = Et.default, Rt = !0, Mt = null;
    if (Et.key !== null && (Mt = it.enterKey(Et.key)), Et.optional) {
      var Lt = null;
      if (Et.explicit !== null ? Lt = Et.explicit : Et.implicit !== null ? Lt = Et.implicit : Et.tag !== null && (Lt = Et.tag), Lt === null && !Et.any) {
        var zt = it.save();
        try {
          Et.choice === null ? this._decodeGeneric(Et.tag, it, lt) : this._decodeChoice(it, lt), Rt = !0;
        } catch {
          Rt = !1;
        }
        it.restore(zt);
      } else if (Rt = this._peekTag(it, Lt, Et.any), it.isError(Rt))
        return Rt;
    }
    var Ot;
    if (Et.obj && Rt && (Ot = it.enterObject()), Rt) {
      if (Et.explicit !== null) {
        var It = this._decodeTag(it, Et.explicit);
        if (it.isError(It))
          return It;
        it = It;
      }
      var Ft = it.offset;
      if (Et.use === null && Et.choice === null) {
        if (Et.any)
          var zt = it.save();
        var Jt = this._decodeTag(
          it,
          Et.implicit !== null ? Et.implicit : Et.tag,
          Et.any
        );
        if (it.isError(Jt))
          return Jt;
        Et.any ? wt = it.raw(zt) : it = Jt;
      }
      if (lt && lt.track && Et.tag !== null && lt.track(it.path(), Ft, it.length, "tagged"), lt && lt.track && Et.tag !== null && lt.track(it.path(), it.offset, it.length, "content"), Et.any ? wt = wt : Et.choice === null ? wt = this._decodeGeneric(Et.tag, it, lt) : wt = this._decodeChoice(it, lt), it.isError(wt))
        return wt;
      if (!Et.any && Et.choice === null && Et.children !== null && Et.children.forEach(function(jt) {
        jt._decode(it, lt);
      }), Et.contains && (Et.tag === "octstr" || Et.tag === "bitstr")) {
        var Vt = new J(wt);
        wt = this._getUse(Et.contains, it._reporterState.obj)._decode(Vt, lt);
      }
    }
    return Et.obj && Rt && (wt = it.leaveObject(Ot)), Et.key !== null && (wt !== null || Rt === !0) ? it.leaveKey(Mt, Et.key, wt) : Mt !== null && it.exitKey(Mt), wt;
  }, rt.prototype._decodeGeneric = function(it, lt, Et) {
    var wt = this._baseState;
    return it === "seq" || it === "set" ? null : it === "seqof" || it === "setof" ? this._decodeList(lt, it, wt.args[0], Et) : /str$/.test(it) ? this._decodeStr(lt, it, Et) : it === "objid" && wt.args ? this._decodeObjid(lt, wt.args[0], wt.args[1], Et) : it === "objid" ? this._decodeObjid(lt, null, null, Et) : it === "gentime" || it === "utctime" ? this._decodeTime(lt, it, Et) : it === "null_" ? this._decodeNull(lt, Et) : it === "bool" ? this._decodeBool(lt, Et) : it === "objDesc" ? this._decodeStr(lt, it, Et) : it === "int" || it === "enum" ? this._decodeInt(lt, wt.args && wt.args[0], Et) : wt.use !== null ? this._getUse(wt.use, lt._reporterState.obj)._decode(lt, Et) : lt.error("unknown tag: " + it);
  }, rt.prototype._getUse = function(it, lt) {
    var Et = this._baseState;
    return Et.useDecoder = this._use(it, lt), ne(Et.useDecoder._baseState.parent === null), Et.useDecoder = Et.useDecoder._baseState.children[0], Et.implicit !== Et.useDecoder._baseState.implicit && (Et.useDecoder = Et.useDecoder.clone(), Et.useDecoder._baseState.implicit = Et.implicit), Et.useDecoder;
  }, rt.prototype._decodeChoice = function(it, lt) {
    var Et = this._baseState, wt = null, Rt = !1;
    return Object.keys(Et.choice).some(function(Mt) {
      var Lt = it.save(), zt = Et.choice[Mt];
      try {
        var Ot = zt._decode(it, lt);
        if (it.isError(Ot))
          return !1;
        wt = { type: Mt, value: Ot }, Rt = !0;
      } catch {
        return it.restore(Lt), !1;
      }
      return !0;
    }, this), Rt ? wt : it.error("Choice not matched");
  }, rt.prototype._createEncoderBuffer = function(it) {
    return new L(it, this.reporter);
  }, rt.prototype._encode = function(it, lt, Et) {
    var wt = this._baseState;
    if (!(wt.default !== null && wt.default === it)) {
      var Rt = this._encodeValue(it, lt, Et);
      if (Rt !== void 0 && !this._skipDefault(Rt, lt, Et))
        return Rt;
    }
  }, rt.prototype._encodeValue = function(it, lt, Et) {
    var wt = this._baseState;
    if (wt.parent === null)
      return wt.children[0]._encode(it, lt || new B());
    var zt = null;
    if (this.reporter = lt, wt.optional && it === void 0)
      if (wt.default !== null)
        it = wt.default;
      else
        return;
    var Rt = null, Mt = !1;
    if (wt.any)
      zt = this._createEncoderBuffer(it);
    else if (wt.choice)
      zt = this._encodeChoice(it, lt);
    else if (wt.contains)
      Rt = this._getUse(wt.contains, Et)._encode(it, lt), Mt = !0;
    else if (wt.children)
      Rt = wt.children.map(function(Ft) {
        if (Ft._baseState.tag === "null_")
          return Ft._encode(null, lt, it);
        if (Ft._baseState.key === null)
          return lt.error("Child should have a key");
        var Jt = lt.enterKey(Ft._baseState.key);
        if (typeof it != "object")
          return lt.error("Child expected, but input is not object");
        var Vt = Ft._encode(it[Ft._baseState.key], lt, it);
        return lt.leaveKey(Jt), Vt;
      }, this).filter(function(Ft) {
        return Ft;
      }), Rt = this._createEncoderBuffer(Rt);
    else if (wt.tag === "seqof" || wt.tag === "setof") {
      if (!(wt.args && wt.args.length === 1))
        return lt.error("Too many args for : " + wt.tag);
      if (!Array.isArray(it))
        return lt.error("seqof/setof, but data is not Array");
      var Lt = this.clone();
      Lt._baseState.implicit = null, Rt = this._createEncoderBuffer(it.map(function(Ft) {
        var Jt = this._baseState;
        return this._getUse(Jt.args[0], it)._encode(Ft, lt);
      }, Lt));
    } else wt.use !== null ? zt = this._getUse(wt.use, Et)._encode(it, lt) : (Rt = this._encodePrimitive(wt.tag, it), Mt = !0);
    var zt;
    if (!wt.any && wt.choice === null) {
      var Ot = wt.implicit !== null ? wt.implicit : wt.tag, It = wt.implicit === null ? "universal" : "context";
      Ot === null ? wt.use === null && lt.error("Tag could be omitted only for .use()") : wt.use === null && (zt = this._encodeComposite(Ot, Mt, It, Rt));
    }
    return wt.explicit !== null && (zt = this._encodeComposite(wt.explicit, !1, "context", zt)), zt;
  }, rt.prototype._encodeChoice = function(it, lt) {
    var Et = this._baseState, wt = Et.choice[it.type];
    return wt || ne(
      !1,
      it.type + " not found in " + JSON.stringify(Object.keys(Et.choice))
    ), wt._encode(it.value, lt);
  }, rt.prototype._encodePrimitive = function(it, lt) {
    var Et = this._baseState;
    if (/str$/.test(it))
      return this._encodeStr(lt, it);
    if (it === "objid" && Et.args)
      return this._encodeObjid(lt, Et.reverseArgs[0], Et.args[1]);
    if (it === "objid")
      return this._encodeObjid(lt, null, null);
    if (it === "gentime" || it === "utctime")
      return this._encodeTime(lt, it);
    if (it === "null_")
      return this._encodeNull();
    if (it === "int" || it === "enum")
      return this._encodeInt(lt, Et.args && Et.reverseArgs[0]);
    if (it === "bool")
      return this._encodeBool(lt);
    if (it === "objDesc")
      return this._encodeStr(lt, it);
    throw new Error("Unsupported tag: " + it);
  }, rt.prototype._isNumstr = function(it) {
    return /^[0-9 ]*$/.test(it);
  }, rt.prototype._isPrintstr = function(it) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(it);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var L = B;
    L.Reporter = reporter.Reporter, L.DecoderBuffer = requireBuffer().DecoderBuffer, L.EncoderBuffer = requireBuffer().EncoderBuffer, L.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var L = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = L._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = L._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var L = B;
    L._reverse = function(ne) {
      var oe = {};
      return Object.keys(ne).forEach(function(ce) {
        (ce | 0) == ce && (ce = ce | 0);
        var Ce = ne[ce];
        oe[Ce] = ce;
      }), oe;
    }, L.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = inherits_browserExports, L = requireAsn1(), J = L.base, ne = L.bignum, oe = L.constants.der;
  function ce(ht) {
    this.enc = "der", this.name = ht.name, this.entity = ht, this.tree = new Ce(), this.tree._init(ht.body);
  }
  der_1$1 = ce, ce.prototype.decode = function(it, lt) {
    return it instanceof J.DecoderBuffer || (it = new J.DecoderBuffer(it, lt)), this.tree._decode(it, lt);
  };
  function Ce(ht) {
    J.Node.call(this, "der", ht);
  }
  B(Ce, J.Node), Ce.prototype._peekTag = function(it, lt, Et) {
    if (it.isEmpty())
      return !1;
    var wt = it.save(), Rt = rt(it, 'Failed to peek tag: "' + lt + '"');
    return it.isError(Rt) ? Rt : (it.restore(wt), Rt.tag === lt || Rt.tagStr === lt || Rt.tagStr + "of" === lt || Et);
  }, Ce.prototype._decodeTag = function(it, lt, Et) {
    var wt = rt(
      it,
      'Failed to decode tag of "' + lt + '"'
    );
    if (it.isError(wt))
      return wt;
    var Rt = at(
      it,
      wt.primitive,
      'Failed to get length of "' + lt + '"'
    );
    if (it.isError(Rt))
      return Rt;
    if (!Et && wt.tag !== lt && wt.tagStr !== lt && wt.tagStr + "of" !== lt)
      return it.error('Failed to match tag: "' + lt + '"');
    if (wt.primitive || Rt !== null)
      return it.skip(Rt, 'Failed to match body of: "' + lt + '"');
    var Mt = it.save(), Lt = this._skipUntilEnd(
      it,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return it.isError(Lt) ? Lt : (Rt = it.offset - Mt.offset, it.restore(Mt), it.skip(Rt, 'Failed to match body of: "' + lt + '"'));
  }, Ce.prototype._skipUntilEnd = function(it, lt) {
    for (; ; ) {
      var Et = rt(it, lt);
      if (it.isError(Et))
        return Et;
      var wt = at(it, Et.primitive, lt);
      if (it.isError(wt))
        return wt;
      var Rt;
      if (Et.primitive || wt !== null ? Rt = it.skip(wt) : Rt = this._skipUntilEnd(it, lt), it.isError(Rt))
        return Rt;
      if (Et.tagStr === "end")
        break;
    }
  }, Ce.prototype._decodeList = function(it, lt, Et, wt) {
    for (var Rt = []; !it.isEmpty(); ) {
      var Mt = this._peekTag(it, "end");
      if (it.isError(Mt))
        return Mt;
      var Lt = Et.decode(it, "der", wt);
      if (it.isError(Lt) && Mt)
        break;
      Rt.push(Lt);
    }
    return Rt;
  }, Ce.prototype._decodeStr = function(it, lt) {
    if (lt === "bitstr") {
      var Et = it.readUInt8();
      return it.isError(Et) ? Et : { unused: Et, data: it.raw() };
    } else if (lt === "bmpstr") {
      var wt = it.raw();
      if (wt.length % 2 === 1)
        return it.error("Decoding of string type: bmpstr length mismatch");
      for (var Rt = "", Mt = 0; Mt < wt.length / 2; Mt++)
        Rt += String.fromCharCode(wt.readUInt16BE(Mt * 2));
      return Rt;
    } else if (lt === "numstr") {
      var Lt = it.raw().toString("ascii");
      return this._isNumstr(Lt) ? Lt : it.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (lt === "octstr")
        return it.raw();
      if (lt === "objDesc")
        return it.raw();
      if (lt === "printstr") {
        var zt = it.raw().toString("ascii");
        return this._isPrintstr(zt) ? zt : it.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(lt) ? it.raw().toString() : it.error("Decoding of string type: " + lt + " unsupported");
    }
  }, Ce.prototype._decodeObjid = function(it, lt, Et) {
    for (var wt, Rt = [], Mt = 0; !it.isEmpty(); ) {
      var Lt = it.readUInt8();
      Mt <<= 7, Mt |= Lt & 127, Lt & 128 || (Rt.push(Mt), Mt = 0);
    }
    Lt & 128 && Rt.push(Mt);
    var zt = Rt[0] / 40 | 0, Ot = Rt[0] % 40;
    if (Et ? wt = Rt : wt = [zt, Ot].concat(Rt.slice(1)), lt) {
      var It = lt[wt.join(" ")];
      It === void 0 && (It = lt[wt.join(".")]), It !== void 0 && (wt = It);
    }
    return wt;
  }, Ce.prototype._decodeTime = function(it, lt) {
    var Et = it.raw().toString();
    if (lt === "gentime")
      var wt = Et.slice(0, 4) | 0, Rt = Et.slice(4, 6) | 0, Mt = Et.slice(6, 8) | 0, Lt = Et.slice(8, 10) | 0, zt = Et.slice(10, 12) | 0, Ot = Et.slice(12, 14) | 0;
    else if (lt === "utctime") {
      var wt = Et.slice(0, 2) | 0, Rt = Et.slice(2, 4) | 0, Mt = Et.slice(4, 6) | 0, Lt = Et.slice(6, 8) | 0, zt = Et.slice(8, 10) | 0, Ot = Et.slice(10, 12) | 0;
      wt < 70 ? wt = 2e3 + wt : wt = 1900 + wt;
    } else
      return it.error("Decoding " + lt + " time is not supported yet");
    return Date.UTC(wt, Rt - 1, Mt, Lt, zt, Ot, 0);
  }, Ce.prototype._decodeNull = function(it) {
    return null;
  }, Ce.prototype._decodeBool = function(it) {
    var lt = it.readUInt8();
    return it.isError(lt) ? lt : lt !== 0;
  }, Ce.prototype._decodeInt = function(it, lt) {
    var Et = it.raw(), wt = new ne(Et);
    return lt && (wt = lt[wt.toString(10)] || wt), wt;
  }, Ce.prototype._use = function(it, lt) {
    return typeof it == "function" && (it = it(lt)), it._getDecoder("der").tree;
  };
  function rt(ht, it) {
    var lt = ht.readUInt8(it);
    if (ht.isError(lt))
      return lt;
    var Et = oe.tagClass[lt >> 6], wt = (lt & 32) === 0;
    if ((lt & 31) === 31) {
      var Rt = lt;
      for (lt = 0; (Rt & 128) === 128; ) {
        if (Rt = ht.readUInt8(it), ht.isError(Rt))
          return Rt;
        lt <<= 7, lt |= Rt & 127;
      }
    } else
      lt &= 31;
    var Mt = oe.tag[lt];
    return {
      cls: Et,
      primitive: wt,
      tag: lt,
      tagStr: Mt
    };
  }
  function at(ht, it, lt) {
    var Et = ht.readUInt8(lt);
    if (ht.isError(Et))
      return Et;
    if (!it && Et === 128)
      return null;
    if (!(Et & 128))
      return Et;
    var wt = Et & 127;
    if (wt > 4)
      return ht.error("length octect is too long");
    Et = 0;
    for (var Rt = 0; Rt < wt; Rt++) {
      Et <<= 8;
      var Mt = ht.readUInt8(lt);
      if (ht.isError(Mt))
        return Mt;
      Et |= Mt;
    }
    return Et;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = inherits_browserExports, L = require$$1$2.Buffer, J = requireDer$1();
  function ne(oe) {
    J.call(this, oe), this.enc = "pem";
  }
  return B(ne, J), pem$1 = ne, ne.prototype.decode = function(ce, Ce) {
    for (var rt = ce.toString().split(/[\r\n]+/g), at = Ce.label.toUpperCase(), ht = /^-----(BEGIN|END) ([^-]+)-----$/, it = -1, lt = -1, Et = 0; Et < rt.length; Et++) {
      var wt = rt[Et].match(ht);
      if (wt !== null && wt[2] === at)
        if (it === -1) {
          if (wt[1] !== "BEGIN")
            break;
          it = Et;
        } else {
          if (wt[1] !== "END")
            break;
          lt = Et;
          break;
        }
    }
    if (it === -1 || lt === -1)
      throw new Error("PEM section not found for: " + at);
    var Rt = rt.slice(it + 1, lt).join("");
    Rt.replace(/[^a-z0-9\+\/=]+/gi, "");
    var Mt = new L(Rt, "base64");
    return J.prototype.decode.call(this, Mt, Ce);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var L = B;
    L.der = requireDer$1(), L.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = inherits_browserExports, L = require$$1$2.Buffer, J = requireAsn1(), ne = J.base, oe = J.constants.der;
  function ce(ht) {
    this.enc = "der", this.name = ht.name, this.entity = ht, this.tree = new Ce(), this.tree._init(ht.body);
  }
  der_1 = ce, ce.prototype.encode = function(it, lt) {
    return this.tree._encode(it, lt).join();
  };
  function Ce(ht) {
    ne.Node.call(this, "der", ht);
  }
  B(Ce, ne.Node), Ce.prototype._encodeComposite = function(it, lt, Et, wt) {
    var Rt = at(it, lt, Et, this.reporter);
    if (wt.length < 128) {
      var zt = new L(2);
      return zt[0] = Rt, zt[1] = wt.length, this._createEncoderBuffer([zt, wt]);
    }
    for (var Mt = 1, Lt = wt.length; Lt >= 256; Lt >>= 8)
      Mt++;
    var zt = new L(2 + Mt);
    zt[0] = Rt, zt[1] = 128 | Mt;
    for (var Lt = 1 + Mt, Ot = wt.length; Ot > 0; Lt--, Ot >>= 8)
      zt[Lt] = Ot & 255;
    return this._createEncoderBuffer([zt, wt]);
  }, Ce.prototype._encodeStr = function(it, lt) {
    if (lt === "bitstr")
      return this._createEncoderBuffer([it.unused | 0, it.data]);
    if (lt === "bmpstr") {
      for (var Et = new L(it.length * 2), wt = 0; wt < it.length; wt++)
        Et.writeUInt16BE(it.charCodeAt(wt), wt * 2);
      return this._createEncoderBuffer(Et);
    } else return lt === "numstr" ? this._isNumstr(it) ? this._createEncoderBuffer(it) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : lt === "printstr" ? this._isPrintstr(it) ? this._createEncoderBuffer(it) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(lt) ? this._createEncoderBuffer(it) : lt === "objDesc" ? this._createEncoderBuffer(it) : this.reporter.error("Encoding of string type: " + lt + " unsupported");
  }, Ce.prototype._encodeObjid = function(it, lt, Et) {
    if (typeof it == "string") {
      if (!lt)
        return this.reporter.error("string objid given, but no values map found");
      if (!lt.hasOwnProperty(it))
        return this.reporter.error("objid not found in values map");
      it = lt[it].split(/[\s\.]+/g);
      for (var wt = 0; wt < it.length; wt++)
        it[wt] |= 0;
    } else if (Array.isArray(it)) {
      it = it.slice();
      for (var wt = 0; wt < it.length; wt++)
        it[wt] |= 0;
    }
    if (!Array.isArray(it))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(it));
    if (!Et) {
      if (it[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      it.splice(0, 2, it[0] * 40 + it[1]);
    }
    for (var Rt = 0, wt = 0; wt < it.length; wt++) {
      var Mt = it[wt];
      for (Rt++; Mt >= 128; Mt >>= 7)
        Rt++;
    }
    for (var Lt = new L(Rt), zt = Lt.length - 1, wt = it.length - 1; wt >= 0; wt--) {
      var Mt = it[wt];
      for (Lt[zt--] = Mt & 127; (Mt >>= 7) > 0; )
        Lt[zt--] = 128 | Mt & 127;
    }
    return this._createEncoderBuffer(Lt);
  };
  function rt(ht) {
    return ht < 10 ? "0" + ht : ht;
  }
  Ce.prototype._encodeTime = function(it, lt) {
    var Et, wt = new Date(it);
    return lt === "gentime" ? Et = [
      rt(wt.getFullYear()),
      rt(wt.getUTCMonth() + 1),
      rt(wt.getUTCDate()),
      rt(wt.getUTCHours()),
      rt(wt.getUTCMinutes()),
      rt(wt.getUTCSeconds()),
      "Z"
    ].join("") : lt === "utctime" ? Et = [
      rt(wt.getFullYear() % 100),
      rt(wt.getUTCMonth() + 1),
      rt(wt.getUTCDate()),
      rt(wt.getUTCHours()),
      rt(wt.getUTCMinutes()),
      rt(wt.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + lt + " time is not supported yet"), this._encodeStr(Et, "octstr");
  }, Ce.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Ce.prototype._encodeInt = function(it, lt) {
    if (typeof it == "string") {
      if (!lt)
        return this.reporter.error("String int or enum given, but no values map");
      if (!lt.hasOwnProperty(it))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(it));
      it = lt[it];
    }
    if (typeof it != "number" && !L.isBuffer(it)) {
      var Et = it.toArray();
      !it.sign && Et[0] & 128 && Et.unshift(0), it = new L(Et);
    }
    if (L.isBuffer(it)) {
      var wt = it.length;
      it.length === 0 && wt++;
      var Mt = new L(wt);
      return it.copy(Mt), it.length === 0 && (Mt[0] = 0), this._createEncoderBuffer(Mt);
    }
    if (it < 128)
      return this._createEncoderBuffer(it);
    if (it < 256)
      return this._createEncoderBuffer([0, it]);
    for (var wt = 1, Rt = it; Rt >= 256; Rt >>= 8)
      wt++;
    for (var Mt = new Array(wt), Rt = Mt.length - 1; Rt >= 0; Rt--)
      Mt[Rt] = it & 255, it >>= 8;
    return Mt[0] & 128 && Mt.unshift(0), this._createEncoderBuffer(new L(Mt));
  }, Ce.prototype._encodeBool = function(it) {
    return this._createEncoderBuffer(it ? 255 : 0);
  }, Ce.prototype._use = function(it, lt) {
    return typeof it == "function" && (it = it(lt)), it._getEncoder("der").tree;
  }, Ce.prototype._skipDefault = function(it, lt, Et) {
    var wt = this._baseState, Rt;
    if (wt.default === null)
      return !1;
    var Mt = it.join();
    if (wt.defaultBuffer === void 0 && (wt.defaultBuffer = this._encodeValue(wt.default, lt, Et).join()), Mt.length !== wt.defaultBuffer.length)
      return !1;
    for (Rt = 0; Rt < Mt.length; Rt++)
      if (Mt[Rt] !== wt.defaultBuffer[Rt])
        return !1;
    return !0;
  };
  function at(ht, it, lt, Et) {
    var wt;
    if (ht === "seqof" ? ht = "seq" : ht === "setof" && (ht = "set"), oe.tagByName.hasOwnProperty(ht))
      wt = oe.tagByName[ht];
    else if (typeof ht == "number" && (ht | 0) === ht)
      wt = ht;
    else
      return Et.error("Unknown tag: " + ht);
    return wt >= 31 ? Et.error("Multi-octet tag encoding unsupported") : (it || (wt |= 32), wt |= oe.tagClassByName[lt || "universal"] << 6, wt);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = inherits_browserExports, L = requireDer();
  function J(ne) {
    L.call(this, ne), this.enc = "pem";
  }
  return B(J, L), pem = J, J.prototype.encode = function(oe, ce) {
    for (var Ce = L.prototype.encode.call(this, oe), rt = Ce.toString("base64"), at = ["-----BEGIN " + ce.label + "-----"], ht = 0; ht < rt.length; ht += 64)
      at.push(rt.slice(ht, ht + 64));
    return at.push("-----END " + ce.label + "-----"), at.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var L = B;
    L.der = requireDer(), L.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(B) {
    var L = B;
    L.bignum = bnExports$1, L.define = requireApi().define, L.base = requireBase(), L.constants = requireConstants(), L.decoders = requireDecoders(), L.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$7 = safeBufferExports$1.Buffer, fixProc$1 = function(B, L) {
  var J = B.toString(), ne = J.match(findProc), oe;
  if (ne) {
    var Ce = "aes" + ne[1], rt = Buffer$7.from(ne[2], "hex"), at = Buffer$7.from(ne[3].replace(/[\r\n]/g, ""), "base64"), ht = evp(L, rt.slice(0, 8), parseInt(ne[1], 10)).key, it = [], lt = ciphers$1.createDecipheriv(Ce, ht, rt);
    it.push(lt.update(at)), it.push(lt.final()), oe = Buffer$7.concat(it);
  } else {
    var ce = J.match(fullRegex);
    oe = Buffer$7.from(ce[2].replace(/[\r\n]/g, ""), "base64");
  }
  var Et = J.match(startRegex)[1];
  return {
    tag: Et,
    data: oe
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$6 = safeBufferExports$1.Buffer;
function decrypt(B, L) {
  var J = B.algorithm.decrypt.kde.kdeparams.salt, ne = parseInt(B.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), oe = aesid[B.algorithm.decrypt.cipher.algo.join(".")], ce = B.algorithm.decrypt.cipher.iv, Ce = B.subjectPrivateKey, rt = parseInt(oe.split("-")[1], 10) / 8, at = compat.pbkdf2Sync(L, J, ne, rt, "sha1"), ht = ciphers.createDecipheriv(oe, at, ce), it = [];
  return it.push(ht.update(Ce)), it.push(ht.final()), Buffer$6.concat(it);
}
function parseKeys$2(B) {
  var L;
  typeof B == "object" && !Buffer$6.isBuffer(B) && (L = B.passphrase, B = B.key), typeof B == "string" && (B = Buffer$6.from(B));
  var J = fixProc(B, L), ne = J.tag, oe = J.data, ce, Ce;
  switch (ne) {
    case "CERTIFICATE":
      Ce = asn1.certificate.decode(oe, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (Ce || (Ce = asn1.PublicKey.decode(oe, "der")), ce = Ce.algorithm.algorithm.join("."), ce) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(Ce.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return Ce.subjectPrivateKey = Ce.subjectPublicKey, {
            type: "ec",
            data: Ce
          };
        case "1.2.840.10040.4.1":
          return Ce.algorithm.params.pub_key = asn1.DSAparam.decode(Ce.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: Ce.algorithm.params
          };
        default:
          throw new Error("unknown key id " + ce);
      }
    case "ENCRYPTED PRIVATE KEY":
      oe = asn1.EncryptedPrivateKey.decode(oe, "der"), oe = decrypt(oe, L);
    case "PRIVATE KEY":
      switch (Ce = asn1.PrivateKey.decode(oe, "der"), ce = Ce.algorithm.algorithm.join("."), ce) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(Ce.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: Ce.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(Ce.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return Ce.algorithm.params.priv_key = asn1.DSAparam.decode(Ce.subjectPrivateKey, "der"), {
            type: "dsa",
            params: Ce.algorithm.params
          };
        default:
          throw new Error("unknown key id " + ce);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(oe, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(oe, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(oe, "der")
      };
    case "EC PRIVATE KEY":
      return oe = asn1.ECPrivateKey.decode(oe, "der"), {
        curve: oe.parameters.value,
        privateKey: oe.privateKey
      };
    default:
      throw new Error("unknown key type " + ne);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign$1.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports$1.Buffer, L = browser$8, J = browserifyRsa, ne = requireElliptic().ec, oe = bnExports, ce = parseAsn1, Ce = require$$4, rt = 1;
  function at(zt, Ot, It, Ft, Jt) {
    var Vt = ce(Ot);
    if (Vt.curve) {
      if (Ft !== "ecdsa" && Ft !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ht(zt, Vt);
    } else if (Vt.type === "dsa") {
      if (Ft !== "dsa")
        throw new Error("wrong private key type");
      return it(zt, Vt, It);
    }
    if (Ft !== "rsa" && Ft !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Ot.padding !== void 0 && Ot.padding !== rt)
      throw new Error("illegal or unsupported padding mode");
    zt = B.concat([Jt, zt]);
    for (var yr = Vt.modulus.byteLength(), jt = [0, 1]; zt.length + jt.length + 1 < yr; )
      jt.push(255);
    jt.push(0);
    for (var Ut = -1; ++Ut < zt.length; )
      jt.push(zt[Ut]);
    var er = J(jt, Vt);
    return er;
  }
  function ht(zt, Ot) {
    var It = Ce[Ot.curve.join(".")];
    if (!It)
      throw new Error("unknown curve " + Ot.curve.join("."));
    var Ft = new ne(It), Jt = Ft.keyFromPrivate(Ot.privateKey), Vt = Jt.sign(zt);
    return B.from(Vt.toDER());
  }
  function it(zt, Ot, It) {
    for (var Ft = Ot.params.priv_key, Jt = Ot.params.p, Vt = Ot.params.q, yr = Ot.params.g, jt = new oe(0), Ut, er = wt(zt, Vt).mod(Vt), Ht = !1, ct = Et(Ft, Vt, zt, It); Ht === !1; )
      Ut = Mt(Vt, ct, It), jt = Lt(yr, Ut, Jt, Vt), Ht = Ut.invm(Vt).imul(er.add(Ft.mul(jt))).mod(Vt), Ht.cmpn(0) === 0 && (Ht = !1, jt = new oe(0));
    return lt(jt, Ht);
  }
  function lt(zt, Ot) {
    zt = zt.toArray(), Ot = Ot.toArray(), zt[0] & 128 && (zt = [0].concat(zt)), Ot[0] & 128 && (Ot = [0].concat(Ot));
    var It = zt.length + Ot.length + 4, Ft = [
      48,
      It,
      2,
      zt.length
    ];
    return Ft = Ft.concat(zt, [2, Ot.length], Ot), B.from(Ft);
  }
  function Et(zt, Ot, It, Ft) {
    if (zt = B.from(zt.toArray()), zt.length < Ot.byteLength()) {
      var Jt = B.alloc(Ot.byteLength() - zt.length);
      zt = B.concat([Jt, zt]);
    }
    var Vt = It.length, yr = Rt(It, Ot), jt = B.alloc(Vt);
    jt.fill(1);
    var Ut = B.alloc(Vt);
    return Ut = L(Ft, Ut).update(jt).update(B.from([0])).update(zt).update(yr).digest(), jt = L(Ft, Ut).update(jt).digest(), Ut = L(Ft, Ut).update(jt).update(B.from([1])).update(zt).update(yr).digest(), jt = L(Ft, Ut).update(jt).digest(), { k: Ut, v: jt };
  }
  function wt(zt, Ot) {
    var It = new oe(zt), Ft = (zt.length << 3) - Ot.bitLength();
    return Ft > 0 && It.ishrn(Ft), It;
  }
  function Rt(zt, Ot) {
    zt = wt(zt, Ot), zt = zt.mod(Ot);
    var It = B.from(zt.toArray());
    if (It.length < Ot.byteLength()) {
      var Ft = B.alloc(Ot.byteLength() - It.length);
      It = B.concat([Ft, It]);
    }
    return It;
  }
  function Mt(zt, Ot, It) {
    var Ft, Jt;
    do {
      for (Ft = B.alloc(0); Ft.length * 8 < zt.bitLength(); )
        Ot.v = L(It, Ot.k).update(Ot.v).digest(), Ft = B.concat([Ft, Ot.v]);
      Jt = wt(Ft, zt), Ot.k = L(It, Ot.k).update(Ot.v).update(B.from([0])).digest(), Ot.v = L(It, Ot.k).update(Ot.v).digest();
    } while (Jt.cmp(zt) !== -1);
    return Jt;
  }
  function Lt(zt, Ot, It, Ft) {
    return zt.toRed(oe.mont(It)).redPow(Ot).fromRed().mod(Ft);
  }
  return sign$1.exports = at, sign$1.exports.getKey = Et, sign$1.exports.makeKey = Mt, sign$1.exports;
}
var verify_1$1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1$1;
  hasRequiredVerify = 1;
  var B = safeBufferExports$1.Buffer, L = bnExports, J = requireElliptic().ec, ne = parseAsn1, oe = require$$4;
  function ce(ht, it, lt, Et, wt) {
    var Rt = ne(lt);
    if (Rt.type === "ec") {
      if (Et !== "ecdsa" && Et !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return Ce(ht, it, Rt);
    } else if (Rt.type === "dsa") {
      if (Et !== "dsa")
        throw new Error("wrong public key type");
      return rt(ht, it, Rt);
    }
    if (Et !== "rsa" && Et !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    it = B.concat([wt, it]);
    for (var Mt = Rt.modulus.byteLength(), Lt = [1], zt = 0; it.length + Lt.length + 2 < Mt; )
      Lt.push(255), zt += 1;
    Lt.push(0);
    for (var Ot = -1; ++Ot < it.length; )
      Lt.push(it[Ot]);
    Lt = B.from(Lt);
    var It = L.mont(Rt.modulus);
    ht = new L(ht).toRed(It), ht = ht.redPow(new L(Rt.publicExponent)), ht = B.from(ht.fromRed().toArray());
    var Ft = zt < 8 ? 1 : 0;
    for (Mt = Math.min(ht.length, Lt.length), ht.length !== Lt.length && (Ft = 1), Ot = -1; ++Ot < Mt; )
      Ft |= ht[Ot] ^ Lt[Ot];
    return Ft === 0;
  }
  function Ce(ht, it, lt) {
    var Et = oe[lt.data.algorithm.curve.join(".")];
    if (!Et)
      throw new Error("unknown curve " + lt.data.algorithm.curve.join("."));
    var wt = new J(Et), Rt = lt.data.subjectPrivateKey.data;
    return wt.verify(it, ht, Rt);
  }
  function rt(ht, it, lt) {
    var Et = lt.data.p, wt = lt.data.q, Rt = lt.data.g, Mt = lt.data.pub_key, Lt = ne.signature.decode(ht, "der"), zt = Lt.s, Ot = Lt.r;
    at(zt, wt), at(Ot, wt);
    var It = L.mont(Et), Ft = zt.invm(wt), Jt = Rt.toRed(It).redPow(new L(it).mul(Ft).mod(wt)).fromRed().mul(Mt.toRed(It).redPow(Ot.mul(Ft).mod(wt)).fromRed()).mod(Et).mod(wt);
    return Jt.cmp(Ot) === 0;
  }
  function at(ht, it) {
    if (ht.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ht.cmp(it) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1$1 = ce, verify_1$1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var B = safeBufferExports$1.Buffer, L = browser$9, J = readableBrowserExports, ne = inherits_browserExports, oe = requireSign(), ce = requireVerify(), Ce = require$$6;
  Object.keys(Ce).forEach(function(lt) {
    Ce[lt].id = B.from(Ce[lt].id, "hex"), Ce[lt.toLowerCase()] = Ce[lt];
  });
  function rt(lt) {
    J.Writable.call(this);
    var Et = Ce[lt];
    if (!Et)
      throw new Error("Unknown message digest");
    this._hashType = Et.hash, this._hash = L(Et.hash), this._tag = Et.id, this._signType = Et.sign;
  }
  ne(rt, J.Writable), rt.prototype._write = function(Et, wt, Rt) {
    this._hash.update(Et), Rt();
  }, rt.prototype.update = function(Et, wt) {
    return this._hash.update(typeof Et == "string" ? B.from(Et, wt) : Et), this;
  }, rt.prototype.sign = function(Et, wt) {
    this.end();
    var Rt = this._hash.digest(), Mt = oe(Rt, Et, this._hashType, this._signType, this._tag);
    return wt ? Mt.toString(wt) : Mt;
  };
  function at(lt) {
    J.Writable.call(this);
    var Et = Ce[lt];
    if (!Et)
      throw new Error("Unknown message digest");
    this._hash = L(Et.hash), this._tag = Et.id, this._signType = Et.sign;
  }
  ne(at, J.Writable), at.prototype._write = function(Et, wt, Rt) {
    this._hash.update(Et), Rt();
  }, at.prototype.update = function(Et, wt) {
    return this._hash.update(typeof Et == "string" ? B.from(Et, wt) : Et), this;
  }, at.prototype.verify = function(Et, wt, Rt) {
    var Mt = typeof wt == "string" ? B.from(wt, Rt) : wt;
    this.end();
    var Lt = this._hash.digest();
    return ce(Mt, Lt, Et, this._signType, this._tag);
  };
  function ht(lt) {
    return new rt(lt);
  }
  function it(lt) {
    return new at(lt);
  }
  return browser$3 = {
    Sign: ht,
    Verify: it,
    createSign: ht,
    createVerify: it
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var B = requireElliptic(), L = bnExports$1;
  browser$2 = function(Ce) {
    return new ne(Ce);
  };
  var J = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  J.p224 = J.secp224r1, J.p256 = J.secp256r1 = J.prime256v1, J.p192 = J.secp192r1 = J.prime192v1, J.p384 = J.secp384r1, J.p521 = J.secp521r1;
  function ne(ce) {
    this.curveType = J[ce], this.curveType || (this.curveType = {
      name: ce
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  ne.prototype.generateKeys = function(ce, Ce) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(ce, Ce);
  }, ne.prototype.computeSecret = function(ce, Ce, rt) {
    Ce = Ce || "utf8", Buffer$D.isBuffer(ce) || (ce = new Buffer$D(ce, Ce));
    var at = this.curve.keyFromPublic(ce).getPublic(), ht = at.mul(this.keys.getPrivate()).getX();
    return oe(ht, rt, this.curveType.byteLength);
  }, ne.prototype.getPublicKey = function(ce, Ce) {
    var rt = this.keys.getPublic(Ce === "compressed", !0);
    return Ce === "hybrid" && (rt[rt.length - 1] % 2 ? rt[0] = 7 : rt[0] = 6), oe(rt, ce);
  }, ne.prototype.getPrivateKey = function(ce) {
    return oe(this.keys.getPrivate(), ce);
  }, ne.prototype.setPublicKey = function(ce, Ce) {
    return Ce = Ce || "utf8", Buffer$D.isBuffer(ce) || (ce = new Buffer$D(ce, Ce)), this.keys._importPublic(ce), this;
  }, ne.prototype.setPrivateKey = function(ce, Ce) {
    Ce = Ce || "utf8", Buffer$D.isBuffer(ce) || (ce = new Buffer$D(ce, Ce));
    var rt = new L(ce);
    return rt = rt.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(rt), this;
  };
  function oe(ce, Ce, rt) {
    Array.isArray(ce) || (ce = ce.toArray());
    var at = new Buffer$D(ce);
    if (rt && at.length < rt) {
      var ht = new Buffer$D(rt - at.length);
      ht.fill(0), at = Buffer$D.concat([ht, at]);
    }
    return Ce ? at.toString(Ce) : at;
  }
  return browser$2;
}
var browser$1 = {}, createHash$3 = browser$9, Buffer$5 = safeBufferExports$1.Buffer, mgf$2 = function(B, L) {
  for (var J = Buffer$5.alloc(0), ne = 0, oe; J.length < L; )
    oe = i2ops(ne++), J = Buffer$5.concat([J, createHash$3("sha1").update(B).update(oe).digest()]);
  return J.slice(0, L);
};
function i2ops(B) {
  var L = Buffer$5.allocUnsafe(4);
  return L.writeUInt32BE(B, 0), L;
}
var xor$2 = function B(L, J) {
  for (var ne = L.length, oe = -1; ++oe < ne; )
    L[oe] ^= J[oe];
  return L;
}, BN$2 = bnExports$1, Buffer$4 = safeBufferExports$1.Buffer;
function withPublic$2(B, L) {
  return Buffer$4.from(B.toRed(BN$2.mont(L.modulus)).redPow(new BN$2(L.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes$1 = browserExports, createHash$2 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$1, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$3 = safeBufferExports$1.Buffer, publicEncrypt = function B(L, J, ne) {
  var oe;
  L.padding ? oe = L.padding : ne ? oe = 1 : oe = 4;
  var ce = parseKeys$1(L), Ce;
  if (oe === 4)
    Ce = oaep$1(ce, J);
  else if (oe === 1)
    Ce = pkcs1$1(ce, J, ne);
  else if (oe === 3) {
    if (Ce = new BN$1(J), Ce.cmp(ce.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return ne ? crt$1(Ce, ce) : withPublic$1(Ce, ce);
};
function oaep$1(B, L) {
  var J = B.modulus.byteLength(), ne = L.length, oe = createHash$2("sha1").update(Buffer$3.alloc(0)).digest(), ce = oe.length, Ce = 2 * ce;
  if (ne > J - Ce - 2)
    throw new Error("message too long");
  var rt = Buffer$3.alloc(J - ne - Ce - 2), at = J - ce - 1, ht = randomBytes$1(ce), it = xor$1(Buffer$3.concat([oe, rt, Buffer$3.alloc(1, 1), L], at), mgf$1(ht, at)), lt = xor$1(ht, mgf$1(it, ce));
  return new BN$1(Buffer$3.concat([Buffer$3.alloc(1), lt, it], J));
}
function pkcs1$1(B, L, J) {
  var ne = L.length, oe = B.modulus.byteLength();
  if (ne > oe - 11)
    throw new Error("message too long");
  var ce;
  return J ? ce = Buffer$3.alloc(oe - ne - 3, 255) : ce = nonZero(oe - ne - 3), new BN$1(Buffer$3.concat([Buffer$3.from([0, J ? 1 : 2]), ce, Buffer$3.alloc(1), L], oe));
}
function nonZero(B) {
  for (var L = Buffer$3.allocUnsafe(B), J = 0, ne = randomBytes$1(B * 2), oe = 0, ce; J < B; )
    oe === ne.length && (ne = randomBytes$1(B * 2), oe = 0), ce = ne[oe++], ce && (L[J++] = ce);
  return L;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$1, crt = browserifyRsa, createHash$1 = browser$9, withPublic = withPublic_1, Buffer$2 = safeBufferExports$1.Buffer, privateDecrypt = function B(L, J, ne) {
  var oe;
  L.padding ? oe = L.padding : ne ? oe = 1 : oe = 4;
  var ce = parseKeys(L), Ce = ce.modulus.byteLength();
  if (J.length > Ce || new BN(J).cmp(ce.modulus) >= 0)
    throw new Error("decryption error");
  var rt;
  ne ? rt = withPublic(new BN(J), ce) : rt = crt(J, ce);
  var at = Buffer$2.alloc(Ce - rt.length);
  if (rt = Buffer$2.concat([at, rt], Ce), oe === 4)
    return oaep(ce, rt);
  if (oe === 1)
    return pkcs1(ce, rt, ne);
  if (oe === 3)
    return rt;
  throw new Error("unknown padding");
};
function oaep(B, L) {
  var J = B.modulus.byteLength(), ne = createHash$1("sha1").update(Buffer$2.alloc(0)).digest(), oe = ne.length;
  if (L[0] !== 0)
    throw new Error("decryption error");
  var ce = L.slice(1, oe + 1), Ce = L.slice(oe + 1), rt = xor(ce, mgf(Ce, oe)), at = xor(Ce, mgf(rt, J - oe - 1));
  if (compare$1(ne, at.slice(0, oe)))
    throw new Error("decryption error");
  for (var ht = oe; at[ht] === 0; )
    ht++;
  if (at[ht++] !== 1)
    throw new Error("decryption error");
  return at.slice(ht);
}
function pkcs1(B, L, J) {
  for (var ne = L.slice(0, 2), oe = 2, ce = 0; L[oe++] !== 0; )
    if (oe >= L.length) {
      ce++;
      break;
    }
  var Ce = L.slice(2, oe - 1);
  if ((ne.toString("hex") !== "0002" && !J || ne.toString("hex") !== "0001" && J) && ce++, Ce.length < 8 && ce++, ce)
    throw new Error("decryption error");
  return L.slice(oe);
}
function compare$1(B, L) {
  B = Buffer$2.from(B), L = Buffer$2.from(L);
  var J = 0, ne = B.length;
  B.length !== L.length && (J++, ne = Math.min(B.length, L.length));
  for (var oe = -1; ++oe < ne; )
    J += B[oe] ^ L[oe];
  return J;
}
(function(B) {
  B.publicEncrypt = publicEncrypt, B.privateDecrypt = privateDecrypt, B.privateEncrypt = function(J, ne) {
    return B.publicEncrypt(J, ne, !0);
  }, B.publicDecrypt = function(J, ne) {
    return B.privateDecrypt(J, ne, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$1, randombytes = browserExports, Buffer$1 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(B, L) {
  if (typeof B != "number" || B !== B)
    throw new TypeError("offset must be a number");
  if (B > kMaxUint32 || B < 0)
    throw new TypeError("offset must be a uint32");
  if (B > kBufferMaxLength || B > L)
    throw new RangeError("offset out of range");
}
function assertSize(B, L, J) {
  if (typeof B != "number" || B !== B)
    throw new TypeError("size must be a number");
  if (B > kMaxUint32 || B < 0)
    throw new TypeError("size must be a uint32");
  if (B + L > J || B > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$3 && crypto$3.getRandomValues || !process$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(B, L, J, ne) {
  if (!Buffer$1.isBuffer(B) && !(B instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof L == "function")
    ne = L, L = 0, J = B.length;
  else if (typeof J == "function")
    ne = J, J = B.length - L;
  else if (typeof ne != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(L, B.length), assertSize(J, L, B.length), actualFill(B, L, J, ne);
}
function actualFill(B, L, J, ne) {
  if (process$1.browser) {
    var oe = B.buffer, ce = new Uint8Array(oe, L, J);
    if (crypto$3.getRandomValues(ce), ne) {
      process$1.nextTick(function() {
        ne(null, B);
      });
      return;
    }
    return B;
  }
  if (ne) {
    randombytes(J, function(rt, at) {
      if (rt)
        return ne(rt);
      at.copy(B, L), ne(null, B);
    });
    return;
  }
  var Ce = randombytes(J);
  return Ce.copy(B, L), B;
}
function randomFillSync(B, L, J) {
  if (typeof L > "u" && (L = 0), !Buffer$1.isBuffer(B) && !(B instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(L, B.length), J === void 0 && (J = B.length - L), assertSize(J, L, B.length), actualFill(B, L, J);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var B = algos, L = Object.keys(B), J = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(L);
  cryptoBrowserify.getHashes = function() {
    return J;
  };
  var ne = browser$7;
  cryptoBrowserify.pbkdf2 = ne.pbkdf2, cryptoBrowserify.pbkdf2Sync = ne.pbkdf2Sync;
  var oe = browser$6;
  cryptoBrowserify.Cipher = oe.Cipher, cryptoBrowserify.createCipher = oe.createCipher, cryptoBrowserify.Cipheriv = oe.Cipheriv, cryptoBrowserify.createCipheriv = oe.createCipheriv, cryptoBrowserify.Decipher = oe.Decipher, cryptoBrowserify.createDecipher = oe.createDecipher, cryptoBrowserify.Decipheriv = oe.Decipheriv, cryptoBrowserify.createDecipheriv = oe.createDecipheriv, cryptoBrowserify.getCiphers = oe.getCiphers, cryptoBrowserify.listCiphers = oe.listCiphers;
  var ce = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = ce.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ce.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ce.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ce.createDiffieHellman, cryptoBrowserify.DiffieHellman = ce.DiffieHellman;
  var Ce = requireBrowser$1();
  cryptoBrowserify.createSign = Ce.createSign, cryptoBrowserify.Sign = Ce.Sign, cryptoBrowserify.createVerify = Ce.createVerify, cryptoBrowserify.Verify = Ce.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var rt = browser$1;
  cryptoBrowserify.publicEncrypt = rt.publicEncrypt, cryptoBrowserify.privateEncrypt = rt.privateEncrypt, cryptoBrowserify.publicDecrypt = rt.publicDecrypt, cryptoBrowserify.privateDecrypt = rt.privateDecrypt;
  var at = browser;
  return cryptoBrowserify.randomFill = at.randomFill, cryptoBrowserify.randomFillSync = at.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const L = requireCryptoBrowserify(), J = BigInt(0), ne = BigInt(1), oe = BigInt(2), ce = BigInt(3), Ce = BigInt(8), rt = Object.freeze({
    a: J,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: ne,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = rt;
  const at = (ur, ir) => (ur + ir / oe) / ir, ht = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(ur) {
      const { n: ir } = rt, lr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), gr = -ne * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Ar = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Fr = lr, jr = BigInt("0x100000000000000000000000000000000"), Xr = at(Fr * ur, ir), pn = at(-gr * ur, ir);
      let Yr = Bt(ur - Xr * lr - pn * Ar, ir), vn = Bt(-Xr * gr - pn * Fr, ir);
      const Cn = Yr > jr, dn = vn > jr;
      if (Cn && (Yr = ir - Yr), dn && (vn = ir - vn), Yr > jr || vn > jr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + ur);
      return { k1neg: Cn, k1: Yr, k2neg: dn, k2: vn };
    }
  }, it = 32, lt = 32, Et = 32, wt = it + 1, Rt = 2 * it + 1;
  function Mt(ur) {
    const { a: ir, b: lr } = rt, gr = Bt(ur * ur), Ar = Bt(gr * ur);
    return Bt(Ar + ir * ur + lr);
  }
  const Lt = rt.a === J;
  class zt extends Error {
    constructor(ir) {
      super(ir);
    }
  }
  function Ot(ur) {
    if (!(ur instanceof It))
      throw new TypeError("JacobianPoint expected");
  }
  class It {
    constructor(ir, lr, gr) {
      this.x = ir, this.y = lr, this.z = gr;
    }
    static fromAffine(ir) {
      if (!(ir instanceof Vt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return ir.equals(Vt.ZERO) ? It.ZERO : new It(ir.x, ir.y, ne);
    }
    static toAffineBatch(ir) {
      const lr = Dt(ir.map((gr) => gr.z));
      return ir.map((gr, Ar) => gr.toAffine(lr[Ar]));
    }
    static normalizeZ(ir) {
      return It.toAffineBatch(ir).map(It.fromAffine);
    }
    equals(ir) {
      Ot(ir);
      const { x: lr, y: gr, z: Ar } = this, { x: Fr, y: jr, z: Xr } = ir, pn = Bt(Ar * Ar), Yr = Bt(Xr * Xr), vn = Bt(lr * Yr), Cn = Bt(Fr * pn), dn = Bt(Bt(gr * Xr) * Yr), fr = Bt(Bt(jr * Ar) * pn);
      return vn === Cn && dn === fr;
    }
    negate() {
      return new It(this.x, Bt(-this.y), this.z);
    }
    double() {
      const { x: ir, y: lr, z: gr } = this, Ar = Bt(ir * ir), Fr = Bt(lr * lr), jr = Bt(Fr * Fr), Xr = ir + Fr, pn = Bt(oe * (Bt(Xr * Xr) - Ar - jr)), Yr = Bt(ce * Ar), vn = Bt(Yr * Yr), Cn = Bt(vn - oe * pn), dn = Bt(Yr * (pn - Cn) - Ce * jr), fr = Bt(oe * lr * gr);
      return new It(Cn, dn, fr);
    }
    add(ir) {
      Ot(ir);
      const { x: lr, y: gr, z: Ar } = this, { x: Fr, y: jr, z: Xr } = ir;
      if (Fr === J || jr === J)
        return this;
      if (lr === J || gr === J)
        return ir;
      const pn = Bt(Ar * Ar), Yr = Bt(Xr * Xr), vn = Bt(lr * Yr), Cn = Bt(Fr * pn), dn = Bt(Bt(gr * Xr) * Yr), fr = Bt(Bt(jr * Ar) * pn), Nr = Bt(Cn - vn), Ir = Bt(fr - dn);
      if (Nr === J)
        return Ir === J ? this.double() : It.ZERO;
      const sn = Bt(Nr * Nr), Tn = Bt(Nr * sn), kn = Bt(vn * sn), Dn = Bt(Ir * Ir - Tn - oe * kn), Jn = Bt(Ir * (kn - Dn) - dn * Tn), Ti = Bt(Ar * Xr * Nr);
      return new It(Dn, Jn, Ti);
    }
    subtract(ir) {
      return this.add(ir.negate());
    }
    multiplyUnsafe(ir) {
      const lr = It.ZERO;
      if (typeof ir == "bigint" && ir === J)
        return lr;
      let gr = yt(ir);
      if (gr === ne)
        return this;
      if (!Lt) {
        let Cn = lr, dn = this;
        for (; gr > J; )
          gr & ne && (Cn = Cn.add(dn)), dn = dn.double(), gr >>= ne;
        return Cn;
      }
      let { k1neg: Ar, k1: Fr, k2neg: jr, k2: Xr } = ht.splitScalar(gr), pn = lr, Yr = lr, vn = this;
      for (; Fr > J || Xr > J; )
        Fr & ne && (pn = pn.add(vn)), Xr & ne && (Yr = Yr.add(vn)), vn = vn.double(), Fr >>= ne, Xr >>= ne;
      return Ar && (pn = pn.negate()), jr && (Yr = Yr.negate()), Yr = new It(Bt(Yr.x * ht.beta), Yr.y, Yr.z), pn.add(Yr);
    }
    precomputeWindow(ir) {
      const lr = Lt ? 128 / ir + 1 : 256 / ir + 1, gr = [];
      let Ar = this, Fr = Ar;
      for (let jr = 0; jr < lr; jr++) {
        Fr = Ar, gr.push(Fr);
        for (let Xr = 1; Xr < 2 ** (ir - 1); Xr++)
          Fr = Fr.add(Ar), gr.push(Fr);
        Ar = Fr.double();
      }
      return gr;
    }
    wNAF(ir, lr) {
      !lr && this.equals(It.BASE) && (lr = Vt.BASE);
      const gr = lr && lr._WINDOW_SIZE || 1;
      if (256 % gr)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Ar = lr && Jt.get(lr);
      Ar || (Ar = this.precomputeWindow(gr), lr && gr !== 1 && (Ar = It.normalizeZ(Ar), Jt.set(lr, Ar)));
      let Fr = It.ZERO, jr = It.BASE;
      const Xr = 1 + (Lt ? 128 / gr : 256 / gr), pn = 2 ** (gr - 1), Yr = BigInt(2 ** gr - 1), vn = 2 ** gr, Cn = BigInt(gr);
      for (let dn = 0; dn < Xr; dn++) {
        const fr = dn * pn;
        let Nr = Number(ir & Yr);
        ir >>= Cn, Nr > pn && (Nr -= vn, ir += ne);
        const Ir = fr, sn = fr + Math.abs(Nr) - 1, Tn = dn % 2 !== 0, kn = Nr < 0;
        Nr === 0 ? jr = jr.add(Ft(Tn, Ar[Ir])) : Fr = Fr.add(Ft(kn, Ar[sn]));
      }
      return { p: Fr, f: jr };
    }
    multiply(ir, lr) {
      let gr = yt(ir), Ar, Fr;
      if (Lt) {
        const { k1neg: jr, k1: Xr, k2neg: pn, k2: Yr } = ht.splitScalar(gr);
        let { p: vn, f: Cn } = this.wNAF(Xr, lr), { p: dn, f: fr } = this.wNAF(Yr, lr);
        vn = Ft(jr, vn), dn = Ft(pn, dn), dn = new It(Bt(dn.x * ht.beta), dn.y, dn.z), Ar = vn.add(dn), Fr = Cn.add(fr);
      } else {
        const { p: jr, f: Xr } = this.wNAF(gr, lr);
        Ar = jr, Fr = Xr;
      }
      return It.normalizeZ([Ar, Fr])[0];
    }
    toAffine(ir) {
      const { x: lr, y: gr, z: Ar } = this, Fr = this.equals(It.ZERO);
      ir == null && (ir = Fr ? Ce : tr(Ar));
      const jr = ir, Xr = Bt(jr * jr), pn = Bt(Xr * jr), Yr = Bt(lr * Xr), vn = Bt(gr * pn), Cn = Bt(Ar * jr);
      if (Fr)
        return Vt.ZERO;
      if (Cn !== ne)
        throw new Error("invZ was invalid");
      return new Vt(Yr, vn);
    }
  }
  It.BASE = new It(rt.Gx, rt.Gy, ne), It.ZERO = new It(J, ne, J);
  function Ft(ur, ir) {
    const lr = ir.negate();
    return ur ? lr : ir;
  }
  const Jt = /* @__PURE__ */ new WeakMap();
  class Vt {
    constructor(ir, lr) {
      this.x = ir, this.y = lr;
    }
    _setWindowSize(ir) {
      this._WINDOW_SIZE = ir, Jt.delete(this);
    }
    hasEvenY() {
      return this.y % oe === J;
    }
    static fromCompressedHex(ir) {
      const lr = ir.length === 32, gr = vt(lr ? ir : ir.subarray(1));
      if (!Dr(gr))
        throw new Error("Point is not on curve");
      const Ar = Mt(gr);
      let Fr = dr(Ar);
      const jr = (Fr & ne) === ne;
      lr ? jr && (Fr = Bt(-Fr)) : (ir[0] & 1) === 1 !== jr && (Fr = Bt(-Fr));
      const Xr = new Vt(gr, Fr);
      return Xr.assertValidity(), Xr;
    }
    static fromUncompressedHex(ir) {
      const lr = vt(ir.subarray(1, it + 1)), gr = vt(ir.subarray(it + 1, it * 2 + 1)), Ar = new Vt(lr, gr);
      return Ar.assertValidity(), Ar;
    }
    static fromHex(ir) {
      const lr = $t(ir), gr = lr.length, Ar = lr[0];
      if (gr === it)
        return this.fromCompressedHex(lr);
      if (gr === wt && (Ar === 2 || Ar === 3))
        return this.fromCompressedHex(lr);
      if (gr === Rt && Ar === 4)
        return this.fromUncompressedHex(lr);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${wt} compressed bytes or ${Rt} uncompressed bytes, not ${gr}`);
    }
    static fromPrivateKey(ir) {
      return Vt.BASE.multiply(Zr(ir));
    }
    static fromSignature(ir, lr, gr) {
      const { r: Ar, s: Fr } = _n(lr);
      if (![0, 1, 2, 3].includes(gr))
        throw new Error("Cannot recover: invalid recovery bit");
      const jr = or($t(ir)), { n: Xr } = rt, pn = gr === 2 || gr === 3 ? Ar + Xr : Ar, Yr = tr(pn, Xr), vn = Bt(-jr * Yr, Xr), Cn = Bt(Fr * Yr, Xr), dn = gr & 1 ? "03" : "02", fr = Vt.fromHex(dn + ut(pn)), Nr = Vt.BASE.multiplyAndAddUnsafe(fr, vn, Cn);
      if (!Nr)
        throw new Error("Cannot recover signature: point at infinify");
      return Nr.assertValidity(), Nr;
    }
    toRawBytes(ir = !1) {
      return xt(this.toHex(ir));
    }
    toHex(ir = !1) {
      const lr = ut(this.x);
      return ir ? `${this.hasEvenY() ? "02" : "03"}${lr}` : `04${lr}${ut(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const ir = "Point is not on elliptic curve", { x: lr, y: gr } = this;
      if (!Dr(lr) || !Dr(gr))
        throw new Error(ir);
      const Ar = Bt(gr * gr), Fr = Mt(lr);
      if (Bt(Ar - Fr) !== J)
        throw new Error(ir);
    }
    equals(ir) {
      return this.x === ir.x && this.y === ir.y;
    }
    negate() {
      return new Vt(this.x, Bt(-this.y));
    }
    double() {
      return It.fromAffine(this).double().toAffine();
    }
    add(ir) {
      return It.fromAffine(this).add(It.fromAffine(ir)).toAffine();
    }
    subtract(ir) {
      return this.add(ir.negate());
    }
    multiply(ir) {
      return It.fromAffine(this).multiply(ir, this).toAffine();
    }
    multiplyAndAddUnsafe(ir, lr, gr) {
      const Ar = It.fromAffine(this), Fr = lr === J || lr === ne || this !== Vt.BASE ? Ar.multiplyUnsafe(lr) : Ar.multiply(lr), jr = It.fromAffine(ir).multiplyUnsafe(gr), Xr = Fr.add(jr);
      return Xr.equals(It.ZERO) ? void 0 : Xr.toAffine();
    }
  }
  B.Point = Vt, Vt.BASE = new Vt(rt.Gx, rt.Gy), Vt.ZERO = new Vt(J, J);
  function yr(ur) {
    return Number.parseInt(ur[0], 16) >= 8 ? "00" + ur : ur;
  }
  function jt(ur) {
    if (ur.length < 2 || ur[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${dt(ur)}`);
    const ir = ur[1], lr = ur.subarray(2, ir + 2);
    if (!ir || lr.length !== ir)
      throw new Error("Invalid signature integer: wrong length");
    if (lr[0] === 0 && lr[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: vt(lr), left: ur.subarray(ir + 2) };
  }
  function Ut(ur) {
    if (ur.length < 2 || ur[0] != 48)
      throw new Error(`Invalid signature tag: ${dt(ur)}`);
    if (ur[1] !== ur.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: ir, left: lr } = jt(ur.subarray(2)), { data: gr, left: Ar } = jt(lr);
    if (Ar.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${dt(Ar)}`);
    return { r: ir, s: gr };
  }
  class er {
    constructor(ir, lr) {
      this.r = ir, this.s = lr, this.assertValidity();
    }
    static fromCompact(ir) {
      const lr = ir instanceof Uint8Array, gr = "Signature.fromCompact";
      if (typeof ir != "string" && !lr)
        throw new TypeError(`${gr}: Expected string or Uint8Array`);
      const Ar = lr ? dt(ir) : ir;
      if (Ar.length !== 128)
        throw new Error(`${gr}: Expected 64-byte hex`);
      return new er(St(Ar.slice(0, 64)), St(Ar.slice(64, 128)));
    }
    static fromDER(ir) {
      const lr = ir instanceof Uint8Array;
      if (typeof ir != "string" && !lr)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: gr, s: Ar } = Ut(lr ? ir : xt(ir));
      return new er(gr, Ar);
    }
    static fromHex(ir) {
      return this.fromDER(ir);
    }
    assertValidity() {
      const { r: ir, s: lr } = this;
      if (!br(ir))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!br(lr))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const ir = rt.n >> ne;
      return this.s > ir;
    }
    normalizeS() {
      return this.hasHighS() ? new er(this.r, Bt(-this.s, rt.n)) : this;
    }
    toDERRawBytes() {
      return xt(this.toDERHex());
    }
    toDERHex() {
      const ir = yr(gt(this.s)), lr = yr(gt(this.r)), gr = ir.length / 2, Ar = lr.length / 2, Fr = gt(gr), jr = gt(Ar);
      return `30${gt(Ar + gr + 4)}02${jr}${lr}02${Fr}${ir}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return xt(this.toCompactHex());
    }
    toCompactHex() {
      return ut(this.r) + ut(this.s);
    }
  }
  B.Signature = er;
  function Ht(...ur) {
    if (!ur.every((gr) => gr instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (ur.length === 1)
      return ur[0];
    const ir = ur.reduce((gr, Ar) => gr + Ar.length, 0), lr = new Uint8Array(ir);
    for (let gr = 0, Ar = 0; gr < ur.length; gr++) {
      const Fr = ur[gr];
      lr.set(Fr, Ar), Ar += Fr.length;
    }
    return lr;
  }
  const ct = Array.from({ length: 256 }, (ur, ir) => ir.toString(16).padStart(2, "0"));
  function dt(ur) {
    if (!(ur instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let ir = "";
    for (let lr = 0; lr < ur.length; lr++)
      ir += ct[ur[lr]];
    return ir;
  }
  const ot = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function ut(ur) {
    if (typeof ur != "bigint")
      throw new Error("Expected bigint");
    if (!(J <= ur && ur < ot))
      throw new Error("Expected number 0 <= n < 2^256");
    return ur.toString(16).padStart(64, "0");
  }
  function mt(ur) {
    const ir = xt(ut(ur));
    if (ir.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return ir;
  }
  function gt(ur) {
    const ir = ur.toString(16);
    return ir.length & 1 ? `0${ir}` : ir;
  }
  function St(ur) {
    if (typeof ur != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof ur);
    return BigInt(`0x${ur}`);
  }
  function xt(ur) {
    if (typeof ur != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof ur);
    if (ur.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + ur.length);
    const ir = new Uint8Array(ur.length / 2);
    for (let lr = 0; lr < ir.length; lr++) {
      const gr = lr * 2, Ar = ur.slice(gr, gr + 2), Fr = Number.parseInt(Ar, 16);
      if (Number.isNaN(Fr) || Fr < 0)
        throw new Error("Invalid byte sequence");
      ir[lr] = Fr;
    }
    return ir;
  }
  function vt(ur) {
    return St(dt(ur));
  }
  function $t(ur) {
    return ur instanceof Uint8Array ? Uint8Array.from(ur) : xt(ur);
  }
  function yt(ur) {
    if (typeof ur == "number" && Number.isSafeInteger(ur) && ur > 0)
      return BigInt(ur);
    if (typeof ur == "bigint" && br(ur))
      return ur;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Bt(ur, ir = rt.P) {
    const lr = ur % ir;
    return lr >= J ? lr : ir + lr;
  }
  function rr(ur, ir) {
    const { P: lr } = rt;
    let gr = ur;
    for (; ir-- > J; )
      gr *= gr, gr %= lr;
    return gr;
  }
  function dr(ur) {
    const { P: ir } = rt, lr = BigInt(6), gr = BigInt(11), Ar = BigInt(22), Fr = BigInt(23), jr = BigInt(44), Xr = BigInt(88), pn = ur * ur * ur % ir, Yr = pn * pn * ur % ir, vn = rr(Yr, ce) * Yr % ir, Cn = rr(vn, ce) * Yr % ir, dn = rr(Cn, oe) * pn % ir, fr = rr(dn, gr) * dn % ir, Nr = rr(fr, Ar) * fr % ir, Ir = rr(Nr, jr) * Nr % ir, sn = rr(Ir, Xr) * Ir % ir, Tn = rr(sn, jr) * Nr % ir, kn = rr(Tn, ce) * Yr % ir, Dn = rr(kn, Fr) * fr % ir, Jn = rr(Dn, lr) * pn % ir, Ti = rr(Jn, oe);
    if (Ti * Ti % ir !== ur)
      throw new Error("Cannot find square root");
    return Ti;
  }
  function tr(ur, ir = rt.P) {
    if (ur === J || ir <= J)
      throw new Error(`invert: expected positive integers, got n=${ur} mod=${ir}`);
    let lr = Bt(ur, ir), gr = ir, Ar = J, Fr = ne;
    for (; lr !== J; ) {
      const Xr = gr / lr, pn = gr % lr, Yr = Ar - Fr * Xr;
      gr = lr, lr = pn, Ar = Fr, Fr = Yr;
    }
    if (gr !== ne)
      throw new Error("invert: does not exist");
    return Bt(Ar, ir);
  }
  function Dt(ur, ir = rt.P) {
    const lr = new Array(ur.length), gr = ur.reduce((Fr, jr, Xr) => jr === J ? Fr : (lr[Xr] = Fr, Bt(Fr * jr, ir)), ne), Ar = tr(gr, ir);
    return ur.reduceRight((Fr, jr, Xr) => jr === J ? Fr : (lr[Xr] = Bt(Fr * lr[Xr], ir), Bt(Fr * jr, ir)), Ar), lr;
  }
  function Wt(ur) {
    const ir = ur.length * 8 - lt * 8, lr = vt(ur);
    return ir > 0 ? lr >> BigInt(ir) : lr;
  }
  function or(ur, ir = !1) {
    const lr = Wt(ur);
    if (ir)
      return lr;
    const { n: gr } = rt;
    return lr >= gr ? lr - gr : lr;
  }
  let _r, Xt;
  class Qt {
    constructor(ir, lr) {
      if (this.hashLen = ir, this.qByteLen = lr, typeof ir != "number" || ir < 2)
        throw new Error("hashLen must be a number");
      if (typeof lr != "number" || lr < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(ir).fill(1), this.k = new Uint8Array(ir).fill(0), this.counter = 0;
    }
    hmac(...ir) {
      return B.utils.hmacSha256(this.k, ...ir);
    }
    hmacSync(...ir) {
      return Xt(this.k, ...ir);
    }
    checkSync() {
      if (typeof Xt != "function")
        throw new zt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(ir = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), ir), this.v = await this.hmac(this.v), ir.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), ir), this.v = await this.hmac(this.v));
    }
    reseedSync(ir = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), ir), this.v = this.hmacSync(this.v), ir.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), ir), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let ir = 0;
      const lr = [];
      for (; ir < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const gr = this.v.slice();
        lr.push(gr), ir += this.v.length;
      }
      return Ht(...lr);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let ir = 0;
      const lr = [];
      for (; ir < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const gr = this.v.slice();
        lr.push(gr), ir += this.v.length;
      }
      return Ht(...lr);
    }
  }
  function br(ur) {
    return J < ur && ur < rt.n;
  }
  function Dr(ur) {
    return J < ur && ur < rt.P;
  }
  function Vr(ur, ir, lr, gr = !0) {
    const { n: Ar } = rt, Fr = or(ur, !0);
    if (!br(Fr))
      return;
    const jr = tr(Fr, Ar), Xr = Vt.BASE.multiply(Fr), pn = Bt(Xr.x, Ar);
    if (pn === J)
      return;
    const Yr = Bt(jr * Bt(ir + lr * pn, Ar), Ar);
    if (Yr === J)
      return;
    let vn = new er(pn, Yr), Cn = (Xr.x === vn.r ? 0 : 2) | Number(Xr.y & ne);
    return gr && vn.hasHighS() && (vn = vn.normalizeS(), Cn ^= 1), { sig: vn, recovery: Cn };
  }
  function Zr(ur) {
    let ir;
    if (typeof ur == "bigint")
      ir = ur;
    else if (typeof ur == "number" && Number.isSafeInteger(ur) && ur > 0)
      ir = BigInt(ur);
    else if (typeof ur == "string") {
      if (ur.length !== 2 * lt)
        throw new Error("Expected 32 bytes of private key");
      ir = St(ur);
    } else if (ur instanceof Uint8Array) {
      if (ur.length !== lt)
        throw new Error("Expected 32 bytes of private key");
      ir = vt(ur);
    } else
      throw new TypeError("Expected valid private key");
    if (!br(ir))
      throw new Error("Expected private key: 0 < key < n");
    return ir;
  }
  function ln(ur) {
    return ur instanceof Vt ? (ur.assertValidity(), ur) : Vt.fromHex(ur);
  }
  function _n(ur) {
    if (ur instanceof er)
      return ur.assertValidity(), ur;
    try {
      return er.fromDER(ur);
    } catch {
      return er.fromCompact(ur);
    }
  }
  function Mr(ur, ir = !1) {
    return Vt.fromPrivateKey(ur).toRawBytes(ir);
  }
  B.getPublicKey = Mr;
  function Wn(ur, ir, lr, gr = !1) {
    return Vt.fromSignature(ur, ir, lr).toRawBytes(gr);
  }
  B.recoverPublicKey = Wn;
  function xn(ur) {
    const ir = ur instanceof Uint8Array, lr = typeof ur == "string", gr = (ir || lr) && ur.length;
    return ir ? gr === wt || gr === Rt : lr ? gr === wt * 2 || gr === Rt * 2 : ur instanceof Vt;
  }
  function ni(ur, ir, lr = !1) {
    if (xn(ur))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!xn(ir))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const gr = ln(ir);
    return gr.assertValidity(), gr.multiply(Zr(ur)).toRawBytes(lr);
  }
  B.getSharedSecret = ni;
  function Gn(ur) {
    const ir = ur.length > it ? ur.slice(0, it) : ur;
    return vt(ir);
  }
  function En(ur) {
    const ir = Gn(ur), lr = Bt(ir, rt.n);
    return Pn(lr < J ? ir : lr);
  }
  function Pn(ur) {
    return mt(ur);
  }
  function ti(ur, ir, lr) {
    if (ur == null)
      throw new Error(`sign: expected valid message hash, not "${ur}"`);
    const gr = $t(ur), Ar = Zr(ir), Fr = [Pn(Ar), En(gr)];
    if (lr != null) {
      lr === !0 && (lr = B.utils.randomBytes(it));
      const pn = $t(lr);
      if (pn.length !== it)
        throw new Error(`sign: Expected ${it} bytes of extra data`);
      Fr.push(pn);
    }
    const jr = Ht(...Fr), Xr = Gn(gr);
    return { seed: jr, m: Xr, d: Ar };
  }
  function gn(ur, ir) {
    const { sig: lr, recovery: gr } = ur, { der: Ar, recovered: Fr } = Object.assign({ canonical: !0, der: !0 }, ir), jr = Ar ? lr.toDERRawBytes() : lr.toCompactRawBytes();
    return Fr ? [jr, gr] : jr;
  }
  async function Kn(ur, ir, lr = {}) {
    const { seed: gr, m: Ar, d: Fr } = ti(ur, ir, lr.extraEntropy), jr = new Qt(Et, lt);
    await jr.reseed(gr);
    let Xr;
    for (; !(Xr = Vr(await jr.generate(), Ar, Fr, lr.canonical)); )
      await jr.reseed();
    return gn(Xr, lr);
  }
  B.sign = Kn;
  function gi(ur, ir, lr = {}) {
    const { seed: gr, m: Ar, d: Fr } = ti(ur, ir, lr.extraEntropy), jr = new Qt(Et, lt);
    jr.reseedSync(gr);
    let Xr;
    for (; !(Xr = Vr(jr.generateSync(), Ar, Fr, lr.canonical)); )
      jr.reseedSync();
    return gn(Xr, lr);
  }
  B.signSync = gi;
  const Gt = { strict: !0 };
  function At(ur, ir, lr, gr = Gt) {
    let Ar;
    try {
      Ar = _n(ur), ir = $t(ir);
    } catch {
      return !1;
    }
    const { r: Fr, s: jr } = Ar;
    if (gr.strict && Ar.hasHighS())
      return !1;
    const Xr = or(ir);
    let pn;
    try {
      pn = ln(lr);
    } catch {
      return !1;
    }
    const { n: Yr } = rt, vn = tr(jr, Yr), Cn = Bt(Xr * vn, Yr), dn = Bt(Fr * vn, Yr), fr = Vt.BASE.multiplyAndAddUnsafe(pn, Cn, dn);
    return fr ? Bt(fr.x, Yr) === Fr : !1;
  }
  B.verify = At;
  function kt(ur) {
    return Bt(vt(ur), rt.n);
  }
  class Zt {
    constructor(ir, lr) {
      this.r = ir, this.s = lr, this.assertValidity();
    }
    static fromHex(ir) {
      const lr = $t(ir);
      if (lr.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${lr.length}`);
      const gr = vt(lr.subarray(0, 32)), Ar = vt(lr.subarray(32, 64));
      return new Zt(gr, Ar);
    }
    assertValidity() {
      const { r: ir, s: lr } = this;
      if (!Dr(ir) || !br(lr))
        throw new Error("Invalid signature");
    }
    toHex() {
      return ut(this.r) + ut(this.s);
    }
    toRawBytes() {
      return xt(this.toHex());
    }
  }
  function pr(ur) {
    return Vt.fromPrivateKey(ur).toRawX();
  }
  class Sr {
    constructor(ir, lr, gr = B.utils.randomBytes()) {
      if (ir == null)
        throw new TypeError(`sign: Expected valid message, not "${ir}"`);
      this.m = $t(ir);
      const { x: Ar, scalar: Fr } = this.getScalar(Zr(lr));
      if (this.px = Ar, this.d = Fr, this.rand = $t(gr), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(ir) {
      const lr = Vt.fromPrivateKey(ir), gr = lr.hasEvenY() ? ir : rt.n - ir;
      return { point: lr, scalar: gr, x: lr.toRawX() };
    }
    initNonce(ir, lr) {
      return mt(ir ^ vt(lr));
    }
    finalizeNonce(ir) {
      const lr = Bt(vt(ir), rt.n);
      if (lr === J)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: gr, x: Ar, scalar: Fr } = this.getScalar(lr);
      return { R: gr, rx: Ar, k: Fr };
    }
    finalizeSig(ir, lr, gr, Ar) {
      return new Zt(ir.x, Bt(lr + gr * Ar, rt.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: ir, d: lr, px: gr, rand: Ar } = this, Fr = B.utils.taggedHash, jr = this.initNonce(lr, await Fr(ci.aux, Ar)), { R: Xr, rx: pn, k: Yr } = this.finalizeNonce(await Fr(ci.nonce, jr, gr, ir)), vn = kt(await Fr(ci.challenge, pn, gr, ir)), Cn = this.finalizeSig(Xr, Yr, vn, lr);
      return await In(Cn, ir, gr) || this.error(), Cn;
    }
    calcSync() {
      const { m: ir, d: lr, px: gr, rand: Ar } = this, Fr = B.utils.taggedHashSync, jr = this.initNonce(lr, Fr(ci.aux, Ar)), { R: Xr, rx: pn, k: Yr } = this.finalizeNonce(Fr(ci.nonce, jr, gr, ir)), vn = kt(Fr(ci.challenge, pn, gr, ir)), Cn = this.finalizeSig(Xr, Yr, vn, lr);
      return hn(Cn, ir, gr) || this.error(), Cn;
    }
  }
  async function Tr(ur, ir, lr) {
    return new Sr(ur, ir, lr).calc();
  }
  function fn(ur, ir, lr) {
    return new Sr(ur, ir, lr).calcSync();
  }
  function On(ur, ir, lr) {
    const gr = ur instanceof Zt, Ar = gr ? ur : Zt.fromHex(ur);
    return gr && Ar.assertValidity(), {
      ...Ar,
      m: $t(ir),
      P: ln(lr)
    };
  }
  function tn(ur, ir, lr, gr) {
    const Ar = Vt.BASE.multiplyAndAddUnsafe(ir, Zr(lr), Bt(-gr, rt.n));
    return !(!Ar || !Ar.hasEvenY() || Ar.x !== ur);
  }
  async function In(ur, ir, lr) {
    try {
      const { r: gr, s: Ar, m: Fr, P: jr } = On(ur, ir, lr), Xr = kt(await B.utils.taggedHash(ci.challenge, mt(gr), jr.toRawX(), Fr));
      return tn(gr, jr, Ar, Xr);
    } catch {
      return !1;
    }
  }
  function hn(ur, ir, lr) {
    try {
      const { r: gr, s: Ar, m: Fr, P: jr } = On(ur, ir, lr), Xr = kt(B.utils.taggedHashSync(ci.challenge, mt(gr), jr.toRawX(), Fr));
      return tn(gr, jr, Ar, Xr);
    } catch (gr) {
      if (gr instanceof zt)
        throw gr;
      return !1;
    }
  }
  B.schnorr = {
    Signature: Zt,
    getPublicKey: pr,
    sign: Tr,
    verify: In,
    signSync: fn,
    verifySync: hn
  }, Vt.BASE._setWindowSize(8);
  const cn = {
    node: L,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, ci = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, pi = {};
  B.utils = {
    bytesToHex: dt,
    hexToBytes: xt,
    concatBytes: Ht,
    mod: Bt,
    invert: tr,
    isValidPrivateKey(ur) {
      try {
        return Zr(ur), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: mt,
    _normalizePrivateKey: Zr,
    hashToPrivateKey: (ur) => {
      ur = $t(ur);
      const ir = lt + 8;
      if (ur.length < ir || ur.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const lr = Bt(vt(ur), rt.n - ne) + ne;
      return mt(lr);
    },
    randomBytes: (ur = 32) => {
      if (cn.web)
        return cn.web.getRandomValues(new Uint8Array(ur));
      if (cn.node) {
        const { randomBytes: ir } = cn.node;
        return Uint8Array.from(ir(ur));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(lt + 8)),
    precompute(ur = 8, ir = Vt.BASE) {
      const lr = ir === Vt.BASE ? ir : new Vt(ir.x, ir.y);
      return lr._setWindowSize(ur), lr.multiply(ce), lr;
    },
    sha256: async (...ur) => {
      if (cn.web) {
        const ir = await cn.web.subtle.digest("SHA-256", Ht(...ur));
        return new Uint8Array(ir);
      } else if (cn.node) {
        const { createHash: ir } = cn.node, lr = ir("sha256");
        return ur.forEach((gr) => lr.update(gr)), Uint8Array.from(lr.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (ur, ...ir) => {
      if (cn.web) {
        const lr = await cn.web.subtle.importKey("raw", ur, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), gr = Ht(...ir), Ar = await cn.web.subtle.sign("HMAC", lr, gr);
        return new Uint8Array(Ar);
      } else if (cn.node) {
        const { createHmac: lr } = cn.node, gr = lr("sha256", ur);
        return ir.forEach((Ar) => gr.update(Ar)), Uint8Array.from(gr.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (ur, ...ir) => {
      let lr = pi[ur];
      if (lr === void 0) {
        const gr = await B.utils.sha256(Uint8Array.from(ur, (Ar) => Ar.charCodeAt(0)));
        lr = Ht(gr, gr), pi[ur] = lr;
      }
      return B.utils.sha256(lr, ...ir);
    },
    taggedHashSync: (ur, ...ir) => {
      if (typeof _r != "function")
        throw new zt("sha256Sync is undefined, you need to set it");
      let lr = pi[ur];
      if (lr === void 0) {
        const gr = _r(Uint8Array.from(ur, (Ar) => Ar.charCodeAt(0)));
        lr = Ht(gr, gr), pi[ur] = lr;
      }
      return _r(lr, ...ir);
    },
    _JacobianPoint: It
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return _r;
      },
      set(ur) {
        _r || (_r = ur);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Xt;
      },
      set(ur) {
        Xt || (Xt = ur);
      }
    }
  });
})(lib$1);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const L = paramBytesForAlg[B];
  if (L)
    return L;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, L) {
  const J = signatureAsBytes(B), ne = getParamBytesForAlg(L), oe = ne + 1, ce = J.length;
  let Ce = 0;
  if (J[Ce++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let rt = J[Ce++];
  if (rt === (MAX_OCTET | 1) && (rt = J[Ce++]), ce - Ce < rt)
    throw new Error(`"seq" specified length of "${rt}", only "${ce - Ce}" remaining`);
  if (J[Ce++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const at = J[Ce++];
  if (ce - Ce - 2 < at)
    throw new Error(`"r" specified length of "${at}", only "${ce - Ce - 2}" available`);
  if (oe < at)
    throw new Error(`"r" specified length of "${at}", max of "${oe}" is acceptable`);
  const ht = Ce;
  if (Ce += at, J[Ce++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const it = J[Ce++];
  if (ce - Ce !== it)
    throw new Error(`"s" specified length of "${it}", expected "${ce - Ce}"`);
  if (oe < it)
    throw new Error(`"s" specified length of "${it}", max of "${oe}" is acceptable`);
  const lt = Ce;
  if (Ce += it, Ce !== ce)
    throw new Error(`Expected to consume entire array, but "${ce - Ce}" bytes remain`);
  const Et = ne - at, wt = ne - it, Rt = new Uint8Array(Et + at + wt + it);
  for (Ce = 0; Ce < Et; ++Ce)
    Rt[Ce] = 0;
  Rt.set(J.subarray(ht + Math.max(-Et, 0), ht + at), Ce), Ce = ne;
  for (const Mt = Ce; Ce < Mt + wt; ++Ce)
    Rt[Ce] = 0;
  return Rt.set(J.subarray(lt + Math.max(-wt, 0), lt + it), Ce), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(Rt));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, L, J) {
  let ne = 0;
  for (; L + ne < J && B[L + ne] === 0; )
    ++ne;
  return B[L + ne] >= MAX_OCTET && --ne, ne;
}
function joseToDer(B, L) {
  B = signatureAsBytes(B);
  const J = getParamBytesForAlg(L), ne = B.length;
  if (ne !== J * 2)
    throw new TypeError(`"${L}" signatures must be "${J * 2}" bytes, saw "${ne}"`);
  const oe = countPadding(B, 0, J), ce = countPadding(B, J, B.length), Ce = J - oe, rt = J - ce, at = 2 + Ce + 1 + 1 + rt, ht = at < MAX_OCTET, it = new Uint8Array((ht ? 2 : 3) + at);
  let lt = 0;
  return it[lt++] = ENCODED_TAG_SEQ, ht ? it[lt++] = at : (it[lt++] = MAX_OCTET | 1, it[lt++] = at & 255), it[lt++] = ENCODED_TAG_INT, it[lt++] = Ce, oe < 0 ? (it[lt++] = 0, it.set(B.subarray(0, J), lt), lt += J) : (it.set(B.subarray(oe, J), lt), lt += J - oe), it[lt++] = ENCODED_TAG_INT, it[lt++] = rt, ce < 0 ? (it[lt++] = 0, it.set(B.subarray(J), lt)) : it.set(B.subarray(J + ce), lt), it;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors = {};
Object.defineProperty(errors, "__esModule", { value: !0 });
errors.InvalidTokenError = errors.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(L) {
    super(), this.name = "MissingParametersError", this.message = L || "";
  }
}
errors.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(L) {
    super(), this.name = "InvalidTokenError", this.message = L || "";
  }
}
errors.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1$1 = hmac$2, sha256_1$5 = sha256$5, secp = lib$1, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors, utils_1 = utils$p;
secp.utils.hmacSha256Sync = (B, ...L) => {
  const J = hmac_1$1.hmac.create(sha256_1$5.sha256, B);
  return L.forEach((ne) => J.update(ne)), J.digest();
};
class SECP256K1Client {
  static derivePublicKey(L, J = !0) {
    return L.length === 66 && (L = L.slice(0, 64)), L.length < 64 && (L = L.padStart(64, "0")), (0, utils_1.bytesToHex)(secp.getPublicKey(L, J));
  }
  static signHash(L, J, ne = "jose") {
    if (!L || !J)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const oe = secp.signSync(L, J.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (ne === "der")
      return (0, utils_1.bytesToHex)(oe);
    if (ne === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(oe, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(L) {
    return (0, ecdsaSigFormatter_1.joseToDer)(L, "ES256");
  }
  static verifyHash(L, J, ne) {
    if (!L || !J || !ne)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(J, L, ne, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const L = secp256k1$1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return L.SECP256K1Client;
  } });
  const J = {
    ES256K: L.SECP256K1Client
  };
  B.cryptoClients = J;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, L, J, ne) {
  function oe(ce) {
    return ce instanceof J ? ce : new J(function(Ce) {
      Ce(ce);
    });
  }
  return new (J || (J = Promise))(function(ce, Ce) {
    function rt(it) {
      try {
        ht(ne.next(it));
      } catch (lt) {
        Ce(lt);
      }
    }
    function at(it) {
      try {
        ht(ne.throw(it));
      } catch (lt) {
        Ce(lt);
      }
    }
    function ht(it) {
      it.done ? ce(it.value) : oe(it.value).then(rt, at);
    }
    ht((ne = ne.apply(B, L || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$4 = sha256$5;
function hashSha256(B) {
  return (0, sha256_1$4.sha256)(B);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const J = typeof B == "string" ? new TextEncoder().encode(B) : B, ne = yield crypto.subtle.digest("SHA-256", J);
        return new Uint8Array(ne);
      } else {
        const J = requireCryptoBrowserify();
        if (!J.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(J.createHash("sha256").update(B).digest());
      }
    } catch (L) {
      return console.log(L), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, L, J, ne) {
  function oe(ce) {
    return ce instanceof J ? ce : new J(function(Ce) {
      Ce(ce);
    });
  }
  return new (J || (J = Promise))(function(ce, Ce) {
    function rt(it) {
      try {
        ht(ne.next(it));
      } catch (lt) {
        Ce(lt);
      }
    }
    function at(it) {
      try {
        ht(ne.throw(it));
      } catch (lt) {
        Ce(lt);
      }
    }
    function ht(it) {
      it.done ? ce(it.value) : oe(it.value).then(rt, at);
    }
    ht((ne = ne.apply(B, L || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors, sha256_1$3 = sha256$1;
function createSigningInput(B, L) {
  const J = [], ne = base64url$2.encode(JSON.stringify(L));
  J.push(ne);
  const oe = base64url$2.encode(JSON.stringify(B));
  return J.push(oe), J.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(L, J) {
    if (!(L && J))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof L != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (L = L.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(L))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[L], this.rawPrivateKey = J;
  }
  header(L = {}) {
    const J = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, J, L);
  }
  sign(L, J = !1, ne = {}) {
    const oe = this.header(ne), ce = createSigningInput(L, oe), Ce = (0, sha256_1$3.hashSha256)(ce);
    return this.createWithSignedHash(L, J, oe, ce, Ce);
  }
  signAsync(L, J = !1, ne = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const oe = this.header(ne), ce = createSigningInput(L, oe), Ce = yield (0, sha256_1$3.hashSha256Async)(ce);
      return this.createWithSignedHash(L, J, oe, ce, Ce);
    });
  }
  createWithSignedHash(L, J, ne, oe, ce) {
    const Ce = this.cryptoClient.signHash(ce, this.rawPrivateKey);
    return J ? {
      header: [base64url$2.encode(JSON.stringify(ne))],
      payload: JSON.stringify(L),
      signature: [Ce]
    } : [oe, Ce].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors, sha256_1$2 = sha256$1;
class TokenVerifier {
  constructor(L, J) {
    if (!(L && J))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof L != "string")
      throw "signing algorithm parameter must be a string";
    if (L = L.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(L))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[L], this.rawPublicKey = J;
  }
  verify(L) {
    return typeof L == "string" ? this.verifyCompact(L, !1) : typeof L == "object" ? this.verifyExpanded(L, !1) : !1;
  }
  verifyAsync(L) {
    return typeof L == "string" ? this.verifyCompact(L, !0) : typeof L == "object" ? this.verifyExpanded(L, !0) : Promise.resolve(!1);
  }
  verifyCompact(L, J) {
    const ne = L.split("."), oe = ne[0] + "." + ne[1], ce = (Ce) => {
      const rt = this.cryptoClient.loadSignature(ne[2]);
      return this.cryptoClient.verifyHash(Ce, rt, this.rawPublicKey);
    };
    if (J)
      return (0, sha256_1$2.hashSha256Async)(oe).then((Ce) => ce(Ce));
    {
      const Ce = (0, sha256_1$2.hashSha256)(oe);
      return ce(Ce);
    }
  }
  verifyExpanded(L, J) {
    const ne = [L.header.join("."), base64url$1.encode(L.payload)].join(".");
    let oe = !0;
    const ce = (Ce) => (L.signature.map((rt) => {
      const at = this.cryptoClient.loadSignature(rt);
      this.cryptoClient.verifyHash(Ce, at, this.rawPublicKey) || (oe = !1);
    }), oe);
    if (J)
      return (0, sha256_1$2.hashSha256Async)(ne).then((Ce) => ce(Ce));
    {
      const Ce = (0, sha256_1$2.hashSha256)(ne);
      return ce(Ce);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$1 = {};
Object.defineProperty(decode$1, "__esModule", { value: !0 });
decode$1.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const L = B.split("."), J = JSON.parse(base64url.decode(L[0])), ne = JSON.parse(base64url.decode(L[1])), oe = L[2];
    return {
      header: J,
      payload: ne,
      signature: oe
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let L = B.payload;
    B.payload[0] !== "{" && (L = base64url.decode(L));
    const J = [];
    return B.header.map((ne) => {
      const oe = JSON.parse(base64url.decode(ne));
      J.push(oe);
    }), {
      header: J,
      payload: JSON.parse(L),
      signature: B.signature
    };
  }
}
decode$1.decodeToken = decodeToken;
(function(B) {
  var L = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ne, oe, ce, Ce) {
    Ce === void 0 && (Ce = ce);
    var rt = Object.getOwnPropertyDescriptor(oe, ce);
    (!rt || ("get" in rt ? !oe.__esModule : rt.writable || rt.configurable)) && (rt = { enumerable: !0, get: function() {
      return oe[ce];
    } }), Object.defineProperty(ne, Ce, rt);
  } : function(ne, oe, ce, Ce) {
    Ce === void 0 && (Ce = ce), ne[Ce] = oe[ce];
  }), J = commonjsGlobal && commonjsGlobal.__exportStar || function(ne, oe) {
    for (var ce in ne) ce !== "default" && !Object.prototype.hasOwnProperty.call(oe, ce) && L(oe, ne, ce);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), J(signer, B), J(verifier, B), J(decode$1, B), J(errors, B), J(cryptoClients, B);
})(lib$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t = function() {
  return t = Object.assign || function(B) {
    for (var L, J = 1, ne = arguments.length; J < ne; J++) for (var oe in L = arguments[J]) Object.prototype.hasOwnProperty.call(L, oe) && (B[oe] = L[oe]);
    return B;
  }, t.apply(this, arguments);
}, r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", e = (B) => {
  if (!B || typeof B != "string") throw new Error(`Expected base58 string but got ${B}`);
  if (B.match(/[IOl0]/gmu)) throw new Error(`Invalid base58 character ${B.match(/[IOl0]/gmu)}`);
  const L = B.match(/^1+/gmu), J = L ? L[0].length : 0, ne = (B.length - J) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
  return new Uint8Array([...new Uint8Array(J), ...B.match(/.{1}/gmu).map((ce) => r.indexOf(ce)).reduce((ce, Ce) => ce = ce.map((rt) => {
    const at = 58 * rt + Ce;
    return Ce = at >> 8, at;
  }), new Uint8Array(ne)).reverse().filter((oe = !1, (ce) => oe = oe || ce))]);
  var oe;
};
(() => {
  const B = Array(256).fill(-1);
  for (let L = 0; L < r.length; ++L) B[r.charCodeAt(L)] = L;
})();
var n = e, s, i, o, h$2 = (s = function(B, L) {
  Object.defineProperty(L, "__esModule", { value: !0 }), L.bech32m = L.bech32 = void 0;
  const J = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ne = {};
  for (let lt = 0; lt < 32; lt++) {
    const Et = J.charAt(lt);
    ne[Et] = lt;
  }
  function oe(lt) {
    const Et = lt >> 25;
    return (33554431 & lt) << 5 ^ 996825010 & -(Et >> 0 & 1) ^ 642813549 & -(Et >> 1 & 1) ^ 513874426 & -(Et >> 2 & 1) ^ 1027748829 & -(Et >> 3 & 1) ^ 705979059 & -(Et >> 4 & 1);
  }
  function ce(lt) {
    let Et = 1;
    for (let wt = 0; wt < lt.length; ++wt) {
      const Rt = lt.charCodeAt(wt);
      if (Rt < 33 || Rt > 126) return "Invalid prefix (" + lt + ")";
      Et = oe(Et) ^ Rt >> 5;
    }
    Et = oe(Et);
    for (let wt = 0; wt < lt.length; ++wt) {
      const Rt = lt.charCodeAt(wt);
      Et = oe(Et) ^ 31 & Rt;
    }
    return Et;
  }
  function Ce(lt, Et, wt, Rt) {
    let Mt = 0, Lt = 0;
    const zt = (1 << wt) - 1, Ot = [];
    for (let It = 0; It < lt.length; ++It) for (Mt = Mt << Et | lt[It], Lt += Et; Lt >= wt; ) Lt -= wt, Ot.push(Mt >> Lt & zt);
    if (Rt) Lt > 0 && Ot.push(Mt << wt - Lt & zt);
    else {
      if (Lt >= Et) return "Excess padding";
      if (Mt << wt - Lt & zt) return "Non-zero padding";
    }
    return Ot;
  }
  function rt(lt) {
    return Ce(lt, 8, 5, !0);
  }
  function at(lt) {
    const Et = Ce(lt, 5, 8, !1);
    if (Array.isArray(Et)) return Et;
  }
  function ht(lt) {
    const Et = Ce(lt, 5, 8, !1);
    if (Array.isArray(Et)) return Et;
    throw new Error(Et);
  }
  function it(lt) {
    let Et;
    function wt(Rt, Mt) {
      if (Mt = Mt || 90, Rt.length < 8) return Rt + " too short";
      if (Rt.length > Mt) return "Exceeds length limit";
      const Lt = Rt.toLowerCase(), zt = Rt.toUpperCase();
      if (Rt !== Lt && Rt !== zt) return "Mixed-case string " + Rt;
      const Ot = (Rt = Lt).lastIndexOf("1");
      if (Ot === -1) return "No separator character for " + Rt;
      if (Ot === 0) return "Missing prefix for " + Rt;
      const It = Rt.slice(0, Ot), Ft = Rt.slice(Ot + 1);
      if (Ft.length < 6) return "Data too short";
      let Jt = ce(It);
      if (typeof Jt == "string") return Jt;
      const Vt = [];
      for (let yr = 0; yr < Ft.length; ++yr) {
        const jt = Ft.charAt(yr), Ut = ne[jt];
        if (Ut === void 0) return "Unknown character " + jt;
        Jt = oe(Jt) ^ Ut, yr + 6 >= Ft.length || Vt.push(Ut);
      }
      return Jt !== Et ? "Invalid checksum for " + Rt : { prefix: It, words: Vt };
    }
    return Et = lt === "bech32" ? 1 : 734539939, { decodeUnsafe: function(Rt, Mt) {
      const Lt = wt(Rt, Mt);
      if (typeof Lt == "object") return Lt;
    }, decode: function(Rt, Mt) {
      const Lt = wt(Rt, Mt);
      if (typeof Lt == "object") return Lt;
      throw new Error(Lt);
    }, encode: function(Rt, Mt, Lt) {
      if (Lt = Lt || 90, Rt.length + 7 + Mt.length > Lt) throw new TypeError("Exceeds length limit");
      let zt = ce(Rt = Rt.toLowerCase());
      if (typeof zt == "string") throw new Error(zt);
      let Ot = Rt + "1";
      for (let It = 0; It < Mt.length; ++It) {
        const Ft = Mt[It];
        if (Ft >> 5) throw new Error("Non 5-bit word");
        zt = oe(zt) ^ Ft, Ot += J.charAt(Ft);
      }
      for (let It = 0; It < 6; ++It) zt = oe(zt);
      zt ^= Et;
      for (let It = 0; It < 6; ++It) Ot += J.charAt(zt >> 5 * (5 - It) & 31);
      return Ot;
    }, toWords: rt, fromWordsUnsafe: at, fromWords: ht };
  }
  L.bech32 = it("bech32"), L.bech32m = it("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$2) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
var c = h$2.bech32m, a = h$2.bech32;
const f = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];
class l {
  constructor() {
    this.A = 1779033703, this.B = -1150833019, this.C = 1013904242, this.D = -1521486534, this.E = 1359893119, this.F = -1694144372, this.G = 528734635, this.H = 1541459225, this._size = 0, this._sp = 0, (!p || w >= 8e3) && (p = new ArrayBuffer(8e3), w = 0), this._byte = new Uint8Array(p, w, 80), this._word = new Int32Array(p, w, 20), w += 80;
  }
  update(L) {
    if (typeof L == "string") return this._utf8(L);
    if (L == null) throw new TypeError("Invalid type: " + typeof L);
    const J = L.byteOffset, ne = L.byteLength;
    let oe = ne / 64 | 0, ce = 0;
    if (oe && !(3 & J) && !(this._size % 64)) {
      const Ce = new Int32Array(L.buffer, J, 16 * oe);
      for (; oe--; ) this._int32(Ce, ce >> 2), ce += 64;
      this._size += ce;
    }
    if (L.BYTES_PER_ELEMENT !== 1 && L.buffer) {
      const Ce = new Uint8Array(L.buffer, J + ce, ne - ce);
      return this._uint8(Ce);
    }
    return ce === ne ? this : this._uint8(L, ce);
  }
  _uint8(L, J) {
    const { _byte: ne, _word: oe } = this, ce = L.length;
    for (J |= 0; J < ce; ) {
      const Ce = this._size % 64;
      let rt = Ce;
      for (; J < ce && rt < 64; ) ne[rt++] = L[J++];
      rt >= 64 && this._int32(oe), this._size += rt - Ce;
    }
    return this;
  }
  _utf8(L) {
    const { _byte: J, _word: ne } = this, oe = L.length;
    let ce = this._sp;
    for (let Ce = 0; Ce < oe; ) {
      const rt = this._size % 64;
      let at = rt;
      for (; Ce < oe && at < 64; ) {
        let ht = 0 | L.charCodeAt(Ce++);
        ht < 128 ? J[at++] = ht : ht < 2048 ? (J[at++] = 192 | ht >>> 6, J[at++] = 128 | 63 & ht) : ht < 55296 || ht > 57343 ? (J[at++] = 224 | ht >>> 12, J[at++] = 128 | ht >>> 6 & 63, J[at++] = 128 | 63 & ht) : ce ? (ht = ((1023 & ce) << 10) + (1023 & ht) + 65536, J[at++] = 240 | ht >>> 18, J[at++] = 128 | ht >>> 12 & 63, J[at++] = 128 | ht >>> 6 & 63, J[at++] = 128 | 63 & ht, ce = 0) : ce = ht;
      }
      at >= 64 && (this._int32(ne), ne[0] = ne[16]), this._size += at - rt;
    }
    return this._sp = ce, this;
  }
  _int32(L, J) {
    let { A: ne, B: oe, C: ce, D: Ce, E: rt, F: at, G: ht, H: it } = this, lt = 0;
    for (J |= 0; lt < 16; ) d[lt++] = g(L[J++]);
    for (lt = 16; lt < 64; lt++) d[lt] = A(d[lt - 2]) + d[lt - 7] + m(d[lt - 15]) + d[lt - 16] | 0;
    for (lt = 0; lt < 64; lt++) {
      const Et = it + E(rt) + b(rt, at, ht) + f[lt] + d[lt] | 0, wt = v(ne) + _(ne, oe, ce) | 0;
      it = ht, ht = at, at = rt, rt = Ce + Et | 0, Ce = ce, ce = oe, oe = ne, ne = Et + wt | 0;
    }
    this.A = ne + this.A | 0, this.B = oe + this.B | 0, this.C = ce + this.C | 0, this.D = Ce + this.D | 0, this.E = rt + this.E | 0, this.F = at + this.F | 0, this.G = ht + this.G | 0, this.H = it + this.H | 0;
  }
  digest(L) {
    const { _byte: J, _word: ne } = this;
    let oe = this._size % 64 | 0;
    for (J[oe++] = 128; 3 & oe; ) J[oe++] = 0;
    if (oe >>= 2, oe > 14) {
      for (; oe < 16; ) ne[oe++] = 0;
      oe = 0, this._int32(ne);
    }
    for (; oe < 16; ) ne[oe++] = 0;
    const ce = 8 * this._size, Ce = (4294967295 & ce) >>> 0, rt = (ce - Ce) / 4294967296;
    return rt && (ne[14] = g(rt)), Ce && (ne[15] = g(Ce)), this._int32(ne), L === "hex" ? this._hex() : this._bin();
  }
  _hex() {
    const { A: L, B: J, C: ne, D: oe, E: ce, F: Ce, G: rt, H: at } = this;
    return y(L) + y(J) + y(ne) + y(oe) + y(ce) + y(Ce) + y(rt) + y(at);
  }
  _bin() {
    const { A: L, B: J, C: ne, D: oe, E: ce, F: Ce, G: rt, H: at, _byte: ht, _word: it } = this;
    return it[0] = g(L), it[1] = g(J), it[2] = g(ne), it[3] = g(oe), it[4] = g(ce), it[5] = g(Ce), it[6] = g(rt), it[7] = g(at), ht.slice(0, 32);
  }
}
const d = new Int32Array(64);
let p, w = 0;
const y = (B) => (B + 4294967296).toString(16).substr(-8), g = new Uint8Array(new Uint16Array([65279]).buffer)[0] === 254 ? (B) => B : (B) => B << 24 & 4278190080 | B << 8 & 16711680 | B >> 8 & 65280 | B >> 24 & 255, b = (B, L, J) => J ^ B & (L ^ J), _ = (B, L, J) => B & L | J & (B | L), v = (B) => (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10), E = (B) => (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7), m = (B) => (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3, A = (B) => (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
var x, k, I = function(B) {
  return function(L) {
    return new l();
  }().update(B).digest();
};
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
var C = { 0: { type: k.p2pkh, network: x.mainnet }, 111: { type: k.p2pkh, network: x.testnet }, 5: { type: k.p2sh, network: x.mainnet }, 196: { type: k.p2sh, network: x.testnet } }, z = function(B) {
  var L, J = B.substr(0, 2).toLowerCase();
  if (J === "bc" || J === "tb") return function(at) {
    var ht;
    try {
      ht = at.startsWith("bc1p") || at.startsWith("tb1p") || at.startsWith("bcrt1p") ? c.decode(at) : a.decode(at);
    } catch {
      throw new Error("Invalid address");
    }
    var it = { bc: x.mainnet, tb: x.testnet, bcrt: x.regtest }[ht.prefix];
    if (it === void 0) throw new Error("Invalid address");
    var lt = ht.words[0];
    if (lt < 0 || lt > 16) throw new Error("Invalid address");
    return { bech32: !0, network: it, address: at, type: a.fromWords(ht.words.slice(1)).length === 20 ? k.p2wpkh : lt === 1 ? k.p2tr : k.p2wsh };
  }(B);
  try {
    L = n(B);
  } catch {
    throw new Error("Invalid address");
  }
  var ne = L.length;
  if (ne !== 25) throw new Error("Invalid address");
  var oe = L[0], ce = L.slice(ne - 4, ne), Ce = L.slice(0, ne - 4), rt = I(I(Ce)).slice(0, 4);
  if (ce.some(function(at, ht) {
    return at !== rt[ht];
  })) throw new Error("Invalid address");
  if (!Object.keys(C).map(Number).includes(oe)) throw new Error("Invalid address");
  return t(t({}, C[oe]), { address: B, bech32: !1 });
}, O = function(B, L) {
  try {
    var J = z(B);
    return !L || L === J.network;
  } catch {
    return !1;
  }
}, BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Signet = "Signet", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: RpcIdSchema
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
async function getProviderOrThrow(B) {
  var J;
  const L = await (B == null ? void 0 : B()) || ((J = window.XverseProviders) == null ? void 0 : J.BitcoinProvider) || window.BitcoinProvider;
  if (!L)
    throw new Error("No Bitcoin wallet installed");
  return L;
}
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType)
}), getAddress = async (B) => {
  var ne, oe;
  const L = await getProviderOrThrow(B.getProvider), { purposes: J } = B.payload;
  if (!J)
    throw new Error("Address purposes are required");
  try {
    const ce = lib$2.createUnsecuredToken(B.payload), Ce = await L.connect(ce);
    (ne = B.onFinish) == null || ne.call(B, Ce);
  } catch (ce) {
    console.error("[Connect] Error during address request", ce), (oe = B.onCancel) == null || oe.call(B);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    id: string()
  }).entries
});
var getRunesBalanceMethodName = "runes_getBalance", getRunesBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getRunesBalanceMethodName),
    params: getRunesBalanceParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var signMessage$6 = async (B) => {
  var oe, ce;
  const L = await getProviderOrThrow(B.getProvider), { address: J, message: ne } = B.payload;
  if (!J)
    throw new Error("An address is required to sign a message");
  if (!ne)
    throw new Error("A message to be signed is required");
  try {
    const Ce = lib$2.createUnsecuredToken(B.payload), rt = await L.signMessage(Ce);
    (oe = B.onFinish) == null || oe.call(B, rt);
  } catch (Ce) {
    console.error("[Connect] Error during sign message request", Ce), (ce = B.onCancel) == null || ce.call(B);
  }
}, serializer = (B) => B.map((L) => {
  const { address: J, amountSats: ne } = L;
  return {
    address: J,
    amountSats: ne.toString()
  };
}), sendBtcTransaction = async (B) => {
  var Ce, rt;
  const L = await getProviderOrThrow(B.getProvider), { recipients: J, senderAddress: ne, network: oe, message: ce } = B.payload;
  if (!J || J.length === 0)
    throw new Error("At least one recipient is required");
  if (J.some(
    (at) => typeof at.address != "string" || typeof at.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!ne)
    throw new Error("The sender address is required");
  try {
    const at = serializer(J), ht = {
      network: oe,
      senderAddress: ne,
      message: ce,
      recipients: at
    }, it = lib$2.createUnsecuredToken(ht), lt = await L.sendBtcTransaction(it);
    (Ce = B.onFinish) == null || Ce.call(B, lt);
  } catch (at) {
    console.error("[Connect] Error during send BTC transaction request", at), (rt = B.onCancel) == null || rt.call(B);
  }
}, signTransaction = async (B) => {
  var oe, ce;
  const L = await getProviderOrThrow(B.getProvider), { psbtBase64: J, inputsToSign: ne } = B.payload;
  if (!J)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!ne)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const Ce = lib$2.createUnsecuredToken(B.payload), rt = await L.signTransaction(Ce);
    (oe = B.onFinish) == null || oe.call(B, rt);
  } catch (Ce) {
    console.error("[Connect] Error during sign transaction request", Ce), (ce = B.onCancel) == null || ce.call(B);
  }
}, dist = {}, necc = lib$1, hmac = hmac$2, sha256 = sha256$5;
function _interopNamespaceDefault(B) {
  var L = /* @__PURE__ */ Object.create(null);
  return B && Object.keys(B).forEach(function(J) {
    if (J !== "default") {
      var ne = Object.getOwnPropertyDescriptor(B, J);
      Object.defineProperty(L, J, ne.get ? ne : {
        enumerable: !0,
        get: function() {
          return B[J];
        }
      });
    }
  }), L.default = B, Object.freeze(L);
}
var necc__namespace = /* @__PURE__ */ _interopNamespaceDefault(necc);
const THROW_BAD_PRIVATE = "Expected Private", THROW_BAD_POINT = "Expected Point", THROW_BAD_TWEAK = "Expected Tweak", THROW_BAD_HASH = "Expected Hash", THROW_BAD_SIGNATURE = "Expected Signature", THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)", THROW_BAD_SCALAR = "Expected Scalar", THROW_BAD_RECOVERY_ID = "Bad Recovery Id";
necc__namespace.utils.hmacSha256Sync = (B, ...L) => hmac.hmac(sha256.sha256, B, necc__namespace.utils.concatBytes(...L));
necc__namespace.utils.sha256Sync = (...B) => sha256.sha256(necc__namespace.utils.concatBytes(...B));
const normalizePrivateKey = necc__namespace.utils._normalizePrivateKey, HASH_SIZE = 32, TWEAK_SIZE = 32, BN32_N = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]), EXTRA_DATA_SIZE = 32, BN32_ZERO = new Uint8Array(32), BN32_P_MINUS_N = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function isUint8Array(B) {
  return B instanceof Uint8Array;
}
function cmpBN32(B, L) {
  for (let J = 0; J < 32; ++J)
    if (B[J] !== L[J])
      return B[J] < L[J] ? -1 : 1;
  return 0;
}
function isZero(B) {
  return cmpBN32(B, BN32_ZERO) === 0;
}
function isTweak(B) {
  return !(!(B instanceof Uint8Array) || B.length !== TWEAK_SIZE || cmpBN32(B, BN32_N) >= 0);
}
function isSignature(B) {
  return B instanceof Uint8Array && B.length === 64 && cmpBN32(B.subarray(0, 32), BN32_N) < 0 && cmpBN32(B.subarray(32, 64), BN32_N) < 0;
}
function isSigrLessThanPMinusN(B) {
  return isUint8Array(B) && B.length === 64 && cmpBN32(B.subarray(0, 32), BN32_P_MINUS_N) < 0;
}
function isSignatureNonzeroRS(B) {
  return !(isZero(B.subarray(0, 32)) || isZero(B.subarray(32, 64)));
}
function isHash(B) {
  return B instanceof Uint8Array && B.length === HASH_SIZE;
}
function isExtraData(B) {
  return B === void 0 || B instanceof Uint8Array && B.length === EXTRA_DATA_SIZE;
}
function hexToNumber(B) {
  if (typeof B != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof B);
  return BigInt(`0x${B}`);
}
function bytesToNumber(B) {
  return hexToNumber(necc__namespace.utils.bytesToHex(B));
}
function normalizeScalar(B) {
  let L;
  if (typeof B == "bigint")
    L = B;
  else if (typeof B == "number" && Number.isSafeInteger(B) && B >= 0)
    L = BigInt(B);
  else if (typeof B == "string") {
    if (B.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    L = hexToNumber(B);
  } else if (B instanceof Uint8Array) {
    if (B.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    L = bytesToNumber(B);
  } else
    throw new TypeError("Expected valid private scalar");
  if (L < 0) throw new Error("Expected private scalar >= 0");
  return L;
}
const _privateAdd = (B, L) => {
  const J = normalizePrivateKey(B), ne = normalizeScalar(L), oe = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(J + ne, necc__namespace.CURVE.n));
  return necc__namespace.utils.isValidPrivateKey(oe) ? oe : null;
}, _privateSub = (B, L) => {
  const J = normalizePrivateKey(B), ne = normalizeScalar(L), oe = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(J - ne, necc__namespace.CURVE.n));
  return necc__namespace.utils.isValidPrivateKey(oe) ? oe : null;
}, _privateNegate = (B) => {
  const L = normalizePrivateKey(B), J = necc__namespace.utils._bigintTo32Bytes(necc__namespace.CURVE.n - L);
  return necc__namespace.utils.isValidPrivateKey(J) ? J : null;
}, _pointAddScalar = (B, L, J) => {
  const ne = necc__namespace.Point.fromHex(B), oe = normalizeScalar(L), ce = necc__namespace.Point.BASE.multiplyAndAddUnsafe(ne, oe, BigInt(1));
  if (!ce) throw new Error("Tweaked point at infinity");
  return ce.toRawBytes(J);
}, _pointMultiply = (B, L, J) => {
  const ne = necc__namespace.Point.fromHex(B), oe = typeof L == "string" ? L : necc__namespace.utils.bytesToHex(L), ce = BigInt(`0x${oe}`);
  return ne.multiply(ce).toRawBytes(J);
};
function assumeCompression(B, L) {
  return B === void 0 ? L !== void 0 ? isPointCompressed(L) : !0 : !!B;
}
function throwToNull(B) {
  try {
    return B();
  } catch {
    return null;
  }
}
function _isPoint(B, L) {
  if (B.length === 32 !== L) return !1;
  try {
    return !!necc__namespace.Point.fromHex(B);
  } catch {
    return !1;
  }
}
function isPoint(B) {
  return _isPoint(B, !1);
}
function isPointCompressed(B) {
  return _isPoint(B, !1) && B.length === 33;
}
function isPrivate(B) {
  return necc__namespace.utils.isValidPrivateKey(B);
}
function isXOnlyPoint(B) {
  return _isPoint(B, !0);
}
function xOnlyPointAddTweak(B, L) {
  if (!isXOnlyPoint(B))
    throw new Error(THROW_BAD_POINT);
  if (!isTweak(L))
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => {
    const J = _pointAddScalar(B, L, !0);
    return { parity: J[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: J.slice(1) };
  });
}
function xOnlyPointFromPoint(B) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  return B.slice(1, 33);
}
function pointFromScalar(B, L) {
  if (!isPrivate(B))
    throw new Error(THROW_BAD_PRIVATE);
  return throwToNull(
    () => necc__namespace.getPublicKey(B, assumeCompression(L))
  );
}
function xOnlyPointFromScalar(B) {
  if (!isPrivate(B))
    throw new Error(THROW_BAD_PRIVATE);
  return xOnlyPointFromPoint(pointFromScalar(B));
}
function pointCompress(B, L) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  return necc__namespace.Point.fromHex(B).toRawBytes(assumeCompression(L, B));
}
function pointMultiply(B, L, J) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  if (!isTweak(L))
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(
    () => _pointMultiply(B, L, assumeCompression(J, B))
  );
}
function pointAdd(B, L, J) {
  if (!isPoint(B) || !isPoint(L))
    throw new Error(THROW_BAD_POINT);
  return throwToNull(() => {
    const ne = necc__namespace.Point.fromHex(B), oe = necc__namespace.Point.fromHex(L);
    return ne.equals(oe.negate()) ? null : ne.add(oe).toRawBytes(assumeCompression(J, B));
  });
}
function pointAddScalar(B, L, J) {
  if (!isPoint(B))
    throw new Error(THROW_BAD_POINT);
  if (!isTweak(L))
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(
    () => _pointAddScalar(B, L, assumeCompression(J, B))
  );
}
function privateAdd(B, L) {
  if (isPrivate(B) === !1)
    throw new Error(THROW_BAD_PRIVATE);
  if (isTweak(L) === !1)
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _privateAdd(B, L));
}
function privateSub(B, L) {
  if (isPrivate(B) === !1)
    throw new Error(THROW_BAD_PRIVATE);
  if (isTweak(L) === !1)
    throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _privateSub(B, L));
}
function privateNegate(B) {
  if (isPrivate(B) === !1)
    throw new Error(THROW_BAD_PRIVATE);
  return _privateNegate(B);
}
function sign(B, L, J) {
  if (!isPrivate(L))
    throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(J))
    throw new Error(THROW_BAD_EXTRA_DATA);
  return necc__namespace.signSync(B, L, { der: !1, extraEntropy: J });
}
function signRecoverable(B, L, J) {
  if (!isPrivate(L))
    throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(J))
    throw new Error(THROW_BAD_EXTRA_DATA);
  const [ne, oe] = necc__namespace.signSync(B, L, { der: !1, extraEntropy: J, recovered: !0 });
  return { signature: ne, recoveryId: oe };
}
function signSchnorr(B, L, J = Buffer$D.alloc(32, 0)) {
  if (!isPrivate(L))
    throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(J))
    throw new Error(THROW_BAD_EXTRA_DATA);
  return necc__namespace.schnorr.signSync(B, L, J);
}
function recover(B, L, J, ne) {
  if (!isHash(B))
    throw new Error(THROW_BAD_HASH);
  if (!isSignature(L) || !isSignatureNonzeroRS(L))
    throw new Error(THROW_BAD_SIGNATURE);
  if (J & 2 && !isSigrLessThanPMinusN(L))
    throw new Error(THROW_BAD_RECOVERY_ID);
  if (!isXOnlyPoint(L.subarray(0, 32)))
    throw new Error(THROW_BAD_SIGNATURE);
  return necc__namespace.recoverPublicKey(B, L, J, assumeCompression(ne));
}
function verify(B, L, J, ne) {
  if (!isPoint(L))
    throw new Error(THROW_BAD_POINT);
  if (!isSignature(J))
    throw new Error(THROW_BAD_SIGNATURE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  return necc__namespace.verify(J, B, L, { strict: ne });
}
function verifySchnorr(B, L, J) {
  if (!isXOnlyPoint(L))
    throw new Error(THROW_BAD_POINT);
  if (!isSignature(J))
    throw new Error(THROW_BAD_SIGNATURE);
  if (!isHash(B))
    throw new Error(THROW_BAD_SCALAR);
  return necc__namespace.schnorr.verifySync(J, B, L);
}
var isPoint_1 = dist.isPoint = isPoint, isPointCompressed_1 = dist.isPointCompressed = isPointCompressed, isPrivate_1 = dist.isPrivate = isPrivate, isXOnlyPoint_1 = dist.isXOnlyPoint = isXOnlyPoint, pointAdd_1 = dist.pointAdd = pointAdd, pointAddScalar_1 = dist.pointAddScalar = pointAddScalar, pointCompress_1 = dist.pointCompress = pointCompress, pointFromScalar_1 = dist.pointFromScalar = pointFromScalar, pointMultiply_1 = dist.pointMultiply = pointMultiply, privateAdd_1 = dist.privateAdd = privateAdd, privateNegate_1 = dist.privateNegate = privateNegate, privateSub_1 = dist.privateSub = privateSub, recover_1 = dist.recover = recover, sign_1 = dist.sign = sign, signRecoverable_1 = dist.signRecoverable = signRecoverable, signSchnorr_1 = dist.signSchnorr = signSchnorr, verify_1 = dist.verify = verify, verifySchnorr_1 = dist.verifySchnorr = verifySchnorr, xOnlyPointAddTweak_1 = dist.xOnlyPointAddTweak = xOnlyPointAddTweak, xOnlyPointFromPoint_1 = dist.xOnlyPointFromPoint = xOnlyPointFromPoint, xOnlyPointFromScalar_1 = dist.xOnlyPointFromScalar = xOnlyPointFromScalar;
const ecc = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: dist,
  isPoint: isPoint_1,
  isPointCompressed: isPointCompressed_1,
  isPrivate: isPrivate_1,
  isXOnlyPoint: isXOnlyPoint_1,
  pointAdd: pointAdd_1,
  pointAddScalar: pointAddScalar_1,
  pointCompress: pointCompress_1,
  pointFromScalar: pointFromScalar_1,
  pointMultiply: pointMultiply_1,
  privateAdd: privateAdd_1,
  privateNegate: privateNegate_1,
  privateSub: privateSub_1,
  recover: recover_1,
  sign: sign_1,
  signRecoverable: signRecoverable_1,
  signSchnorr: signSchnorr_1,
  verify: verify_1,
  verifySchnorr: verifySchnorr_1,
  xOnlyPointAddTweak: xOnlyPointAddTweak_1,
  xOnlyPointFromPoint: xOnlyPointFromPoint_1,
  xOnlyPointFromScalar: xOnlyPointFromScalar_1
}, [dist]);
var src$2 = {}, bip32 = {}, crypto$2 = {}, sha512 = {}, _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: !0 });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(B, L = !1) {
  return L ? { h: Number(B & U32_MASK64), l: Number(B >> _32n & U32_MASK64) } : { h: Number(B >> _32n & U32_MASK64) | 0, l: Number(B & U32_MASK64) | 0 };
}
_u64.fromBig = fromBig;
function split(B, L = !1) {
  let J = new Uint32Array(B.length), ne = new Uint32Array(B.length);
  for (let oe = 0; oe < B.length; oe++) {
    const { h: ce, l: Ce } = fromBig(B[oe], L);
    [J[oe], ne[oe]] = [ce, Ce];
  }
  return [J, ne];
}
_u64.split = split;
const toBig = (B, L) => BigInt(B >>> 0) << _32n | BigInt(L >>> 0);
_u64.toBig = toBig;
const shrSH = (B, L, J) => B >>> J;
_u64.shrSH = shrSH;
const shrSL = (B, L, J) => B << 32 - J | L >>> J;
_u64.shrSL = shrSL;
const rotrSH = (B, L, J) => B >>> J | L << 32 - J;
_u64.rotrSH = rotrSH;
const rotrSL = (B, L, J) => B << 32 - J | L >>> J;
_u64.rotrSL = rotrSL;
const rotrBH = (B, L, J) => B << 64 - J | L >>> J - 32;
_u64.rotrBH = rotrBH;
const rotrBL = (B, L, J) => B >>> J - 32 | L << 64 - J;
_u64.rotrBL = rotrBL;
const rotr32H = (B, L) => L;
_u64.rotr32H = rotr32H;
const rotr32L = (B, L) => B;
_u64.rotr32L = rotr32L;
const rotlSH = (B, L, J) => B << J | L >>> 32 - J;
_u64.rotlSH = rotlSH;
const rotlSL = (B, L, J) => L << J | B >>> 32 - J;
_u64.rotlSL = rotlSL;
const rotlBH = (B, L, J) => L << J - 32 | B >>> 64 - J;
_u64.rotlBH = rotlBH;
const rotlBL = (B, L, J) => B << J - 32 | L >>> 64 - J;
_u64.rotlBL = rotlBL;
function add(B, L, J, ne) {
  const oe = (L >>> 0) + (ne >>> 0);
  return { h: B + J + (oe / 2 ** 32 | 0) | 0, l: oe | 0 };
}
_u64.add = add;
const add3L = (B, L, J) => (B >>> 0) + (L >>> 0) + (J >>> 0);
_u64.add3L = add3L;
const add3H = (B, L, J, ne) => L + J + ne + (B / 2 ** 32 | 0) | 0;
_u64.add3H = add3H;
const add4L = (B, L, J, ne) => (B >>> 0) + (L >>> 0) + (J >>> 0) + (ne >>> 0);
_u64.add4L = add4L;
const add4H = (B, L, J, ne, oe) => L + J + ne + oe + (B / 2 ** 32 | 0) | 0;
_u64.add4H = add4H;
const add5L = (B, L, J, ne, oe) => (B >>> 0) + (L >>> 0) + (J >>> 0) + (ne >>> 0) + (oe >>> 0);
_u64.add5L = add5L;
const add5H = (B, L, J, ne, oe, ce) => L + J + ne + oe + ce + (B / 2 ** 32 | 0) | 0;
_u64.add5H = add5H;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
_u64.default = u64;
Object.defineProperty(sha512, "__esModule", { value: !0 });
sha512.sha384 = sha512.sha512_256 = sha512.sha512_224 = sha512.sha512 = sha512.SHA512 = void 0;
const _md_js_1 = _md, _u64_js_1 = _u64, utils_js_1 = utils$p, [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((B) => BigInt(B))), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_js_1.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: L, Al: J, Bh: ne, Bl: oe, Ch: ce, Cl: Ce, Dh: rt, Dl: at, Eh: ht, El: it, Fh: lt, Fl: Et, Gh: wt, Gl: Rt, Hh: Mt, Hl: Lt } = this;
    return [L, J, ne, oe, ce, Ce, rt, at, ht, it, lt, Et, wt, Rt, Mt, Lt];
  }
  // prettier-ignore
  set(L, J, ne, oe, ce, Ce, rt, at, ht, it, lt, Et, wt, Rt, Mt, Lt) {
    this.Ah = L | 0, this.Al = J | 0, this.Bh = ne | 0, this.Bl = oe | 0, this.Ch = ce | 0, this.Cl = Ce | 0, this.Dh = rt | 0, this.Dl = at | 0, this.Eh = ht | 0, this.El = it | 0, this.Fh = lt | 0, this.Fl = Et | 0, this.Gh = wt | 0, this.Gl = Rt | 0, this.Hh = Mt | 0, this.Hl = Lt | 0;
  }
  process(L, J) {
    for (let It = 0; It < 16; It++, J += 4)
      SHA512_W_H[It] = L.getUint32(J), SHA512_W_L[It] = L.getUint32(J += 4);
    for (let It = 16; It < 80; It++) {
      const Ft = SHA512_W_H[It - 15] | 0, Jt = SHA512_W_L[It - 15] | 0, Vt = _u64_js_1.default.rotrSH(Ft, Jt, 1) ^ _u64_js_1.default.rotrSH(Ft, Jt, 8) ^ _u64_js_1.default.shrSH(Ft, Jt, 7), yr = _u64_js_1.default.rotrSL(Ft, Jt, 1) ^ _u64_js_1.default.rotrSL(Ft, Jt, 8) ^ _u64_js_1.default.shrSL(Ft, Jt, 7), jt = SHA512_W_H[It - 2] | 0, Ut = SHA512_W_L[It - 2] | 0, er = _u64_js_1.default.rotrSH(jt, Ut, 19) ^ _u64_js_1.default.rotrBH(jt, Ut, 61) ^ _u64_js_1.default.shrSH(jt, Ut, 6), Ht = _u64_js_1.default.rotrSL(jt, Ut, 19) ^ _u64_js_1.default.rotrBL(jt, Ut, 61) ^ _u64_js_1.default.shrSL(jt, Ut, 6), ct = _u64_js_1.default.add4L(yr, Ht, SHA512_W_L[It - 7], SHA512_W_L[It - 16]), dt = _u64_js_1.default.add4H(ct, Vt, er, SHA512_W_H[It - 7], SHA512_W_H[It - 16]);
      SHA512_W_H[It] = dt | 0, SHA512_W_L[It] = ct | 0;
    }
    let { Ah: ne, Al: oe, Bh: ce, Bl: Ce, Ch: rt, Cl: at, Dh: ht, Dl: it, Eh: lt, El: Et, Fh: wt, Fl: Rt, Gh: Mt, Gl: Lt, Hh: zt, Hl: Ot } = this;
    for (let It = 0; It < 80; It++) {
      const Ft = _u64_js_1.default.rotrSH(lt, Et, 14) ^ _u64_js_1.default.rotrSH(lt, Et, 18) ^ _u64_js_1.default.rotrBH(lt, Et, 41), Jt = _u64_js_1.default.rotrSL(lt, Et, 14) ^ _u64_js_1.default.rotrSL(lt, Et, 18) ^ _u64_js_1.default.rotrBL(lt, Et, 41), Vt = lt & wt ^ ~lt & Mt, yr = Et & Rt ^ ~Et & Lt, jt = _u64_js_1.default.add5L(Ot, Jt, yr, SHA512_Kl[It], SHA512_W_L[It]), Ut = _u64_js_1.default.add5H(jt, zt, Ft, Vt, SHA512_Kh[It], SHA512_W_H[It]), er = jt | 0, Ht = _u64_js_1.default.rotrSH(ne, oe, 28) ^ _u64_js_1.default.rotrBH(ne, oe, 34) ^ _u64_js_1.default.rotrBH(ne, oe, 39), ct = _u64_js_1.default.rotrSL(ne, oe, 28) ^ _u64_js_1.default.rotrBL(ne, oe, 34) ^ _u64_js_1.default.rotrBL(ne, oe, 39), dt = ne & ce ^ ne & rt ^ ce & rt, ot = oe & Ce ^ oe & at ^ Ce & at;
      zt = Mt | 0, Ot = Lt | 0, Mt = wt | 0, Lt = Rt | 0, wt = lt | 0, Rt = Et | 0, { h: lt, l: Et } = _u64_js_1.default.add(ht | 0, it | 0, Ut | 0, er | 0), ht = rt | 0, it = at | 0, rt = ce | 0, at = Ce | 0, ce = ne | 0, Ce = oe | 0;
      const ut = _u64_js_1.default.add3L(er, ct, ot);
      ne = _u64_js_1.default.add3H(ut, Ut, Ht, dt), oe = ut | 0;
    }
    ({ h: ne, l: oe } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, ne | 0, oe | 0)), { h: ce, l: Ce } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, ce | 0, Ce | 0), { h: rt, l: at } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, rt | 0, at | 0), { h: ht, l: it } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, ht | 0, it | 0), { h: lt, l: Et } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, lt | 0, Et | 0), { h: wt, l: Rt } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, wt | 0, Rt | 0), { h: Mt, l: Lt } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Mt | 0, Lt | 0), { h: zt, l: Ot } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, zt | 0, Ot | 0), this.set(ne, oe, ce, Ce, rt, at, ht, it, lt, Et, wt, Rt, Mt, Lt, zt, Ot);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
sha512.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class SHA512_256 extends SHA512 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class SHA384 extends SHA512 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
sha512.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
sha512.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
sha512.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
sha512.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.hmacSHA512 = crypto$2.hash160 = void 0;
const hmac_1 = hmac$2, ripemd160_1 = ripemd160$1, sha256_1$1 = sha256$5, sha512_1 = sha512;
function hash160(B) {
  const L = (0, sha256_1$1.sha256)(Uint8Array.from(B));
  return Buffer$D.from((0, ripemd160_1.ripemd160)(L));
}
crypto$2.hash160 = hash160;
function hmacSHA512(B, L) {
  return Buffer$D.from((0, hmac_1.hmac)(sha512_1.sha512, B, L));
}
crypto$2.hmacSHA512 = hmacSHA512;
var testecc$1 = {};
Object.defineProperty(testecc$1, "__esModule", { value: !0 });
testecc$1.testEcc = void 0;
const h$1 = (B) => Buffer$D.from(B, "hex");
function testEcc$1(B) {
  if (assert$1(B.isPoint(h$1("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$1(!B.isPoint(h$1("030000000000000000000000000000000000000000000000000000000000000005"))), assert$1(B.isPrivate(h$1("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$1(B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert$1(!B.isPrivate(h$1("0000000000000000000000000000000000000000000000000000000000000000"))), assert$1(!B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), assert$1(!B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), assert$1(Buffer$D.from(B.pointFromScalar(h$1("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h$1("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99"))), B.xOnlyPointAddTweak) {
    assert$1(B.xOnlyPointAddTweak(h$1("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let L = B.xOnlyPointAddTweak(h$1("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h$1("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    assert$1(Buffer$D.from(L.xOnlyPubkey).equals(h$1("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) && L.parity === 1), L = B.xOnlyPointAddTweak(h$1("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h$1("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  assert$1(Buffer$D.from(B.pointAddScalar(h$1("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("0000000000000000000000000000000000000000000000000000000000000003"))).equals(h$1("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5"))), assert$1(Buffer$D.from(B.privateAdd(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h$1("0000000000000000000000000000000000000000000000000000000000000002"))).equals(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), B.privateNegate && (assert$1(Buffer$D.from(B.privateNegate(h$1("0000000000000000000000000000000000000000000000000000000000000001"))).equals(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert$1(Buffer$D.from(B.privateNegate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"))).equals(h$1("0000000000000000000000000000000000000000000000000000000000000003"))), assert$1(Buffer$D.from(B.privateNegate(h$1("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h$1("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")))), assert$1(Buffer$D.from(B.sign(h$1("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))).equals(h$1("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), assert$1(B.verify(h$1("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h$1("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), B.signSchnorr && assert$1(Buffer$D.from(B.signSchnorr(h$1("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h$1("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h$1("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906"))).equals(h$1("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"))), B.verifySchnorr && assert$1(B.verifySchnorr(h$1("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h$1("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h$1("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
testecc$1.testEcc = testEcc$1;
function assert$1(B) {
  if (!B)
    throw new Error("ecc library invalid");
}
var lib = {};
(function(B) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bytes = B.stringToBytes = B.str = B.bytesToString = B.hex = B.utf8 = B.bech32m = B.bech32 = B.base58check = B.createBase58check = B.base58xmr = B.base58xrp = B.base58flickr = B.base58 = B.base64urlnopad = B.base64url = B.base64nopad = B.base64 = B.base32crockford = B.base32hexnopad = B.base32hex = B.base32nopad = B.base32 = B.base16 = B.utils = B.assertNumber = void 0;
  // @__NO_SIDE_EFFECTS__
  function L(ct) {
    if (!Number.isSafeInteger(ct))
      throw new Error(`Wrong integer: ${ct}`);
  }
  B.assertNumber = L;
  function J(ct) {
    return ct instanceof Uint8Array || ct != null && typeof ct == "object" && ct.constructor.name === "Uint8Array";
  }
  // @__NO_SIDE_EFFECTS__
  function ne(...ct) {
    const dt = (gt) => gt, ot = (gt, St) => (xt) => gt(St(xt)), ut = ct.map((gt) => gt.encode).reduceRight(ot, dt), mt = ct.map((gt) => gt.decode).reduce(ot, dt);
    return { encode: ut, decode: mt };
  }
  // @__NO_SIDE_EFFECTS__
  function oe(ct) {
    return {
      encode: (dt) => {
        if (!Array.isArray(dt) || dt.length && typeof dt[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return dt.map((ot) => {
          if (ot < 0 || ot >= ct.length)
            throw new Error(`Digit index outside alphabet: ${ot} (alphabet: ${ct.length})`);
          return ct[ot];
        });
      },
      decode: (dt) => {
        if (!Array.isArray(dt) || dt.length && typeof dt[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return dt.map((ot) => {
          if (typeof ot != "string")
            throw new Error(`alphabet.decode: not string element=${ot}`);
          const ut = ct.indexOf(ot);
          if (ut === -1)
            throw new Error(`Unknown letter: "${ot}". Allowed: ${ct}`);
          return ut;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function ce(ct = "") {
    if (typeof ct != "string")
      throw new Error("join separator should be string");
    return {
      encode: (dt) => {
        if (!Array.isArray(dt) || dt.length && typeof dt[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let ot of dt)
          if (typeof ot != "string")
            throw new Error(`join.encode: non-string input=${ot}`);
        return dt.join(ct);
      },
      decode: (dt) => {
        if (typeof dt != "string")
          throw new Error("join.decode input should be string");
        return dt.split(ct);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function Ce(ct, dt = "=") {
    if (typeof dt != "string")
      throw new Error("padding chr should be string");
    return {
      encode(ot) {
        if (!Array.isArray(ot) || ot.length && typeof ot[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let ut of ot)
          if (typeof ut != "string")
            throw new Error(`padding.encode: non-string input=${ut}`);
        for (; ot.length * ct % 8; )
          ot.push(dt);
        return ot;
      },
      decode(ot) {
        if (!Array.isArray(ot) || ot.length && typeof ot[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let mt of ot)
          if (typeof mt != "string")
            throw new Error(`padding.decode: non-string input=${mt}`);
        let ut = ot.length;
        if (ut * ct % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; ut > 0 && ot[ut - 1] === dt; ut--)
          if (!((ut - 1) * ct % 8))
            throw new Error("Invalid padding: string has too much padding");
        return ot.slice(0, ut);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function rt(ct) {
    if (typeof ct != "function")
      throw new Error("normalize fn should be function");
    return { encode: (dt) => dt, decode: (dt) => ct(dt) };
  }
  // @__NO_SIDE_EFFECTS__
  function at(ct, dt, ot) {
    if (dt < 2)
      throw new Error(`convertRadix: wrong from=${dt}, base cannot be less than 2`);
    if (ot < 2)
      throw new Error(`convertRadix: wrong to=${ot}, base cannot be less than 2`);
    if (!Array.isArray(ct))
      throw new Error("convertRadix: data should be array");
    if (!ct.length)
      return [];
    let ut = 0;
    const mt = [], gt = Array.from(ct);
    for (gt.forEach((St) => {
      if (St < 0 || St >= dt)
        throw new Error(`Wrong integer: ${St}`);
    }); ; ) {
      let St = 0, xt = !0;
      for (let vt = ut; vt < gt.length; vt++) {
        const $t = gt[vt], yt = dt * St + $t;
        if (!Number.isSafeInteger(yt) || dt * St / dt !== St || yt - $t !== dt * St)
          throw new Error("convertRadix: carry overflow");
        St = yt % ot;
        const Bt = Math.floor(yt / ot);
        if (gt[vt] = Bt, !Number.isSafeInteger(Bt) || Bt * ot + St !== yt)
          throw new Error("convertRadix: carry overflow");
        if (xt)
          Bt ? xt = !1 : ut = vt;
        else continue;
      }
      if (mt.push(St), xt)
        break;
    }
    for (let St = 0; St < ct.length - 1 && ct[St] === 0; St++)
      mt.push(0);
    return mt.reverse();
  }
  const ht = /* @__NO_SIDE_EFFECTS__ */ (ct, dt) => dt ? /* @__PURE__ */ ht(dt, ct % dt) : ct, it = /* @__NO_SIDE_EFFECTS__ */ (ct, dt) => ct + (dt - /* @__PURE__ */ ht(ct, dt));
  // @__NO_SIDE_EFFECTS__
  function lt(ct, dt, ot, ut) {
    if (!Array.isArray(ct))
      throw new Error("convertRadix2: data should be array");
    if (dt <= 0 || dt > 32)
      throw new Error(`convertRadix2: wrong from=${dt}`);
    if (ot <= 0 || ot > 32)
      throw new Error(`convertRadix2: wrong to=${ot}`);
    if (/* @__PURE__ */ it(dt, ot) > 32)
      throw new Error(`convertRadix2: carry overflow from=${dt} to=${ot} carryBits=${/* @__PURE__ */ it(dt, ot)}`);
    let mt = 0, gt = 0;
    const St = 2 ** ot - 1, xt = [];
    for (const vt of ct) {
      if (vt >= 2 ** dt)
        throw new Error(`convertRadix2: invalid data word=${vt} from=${dt}`);
      if (mt = mt << dt | vt, gt + dt > 32)
        throw new Error(`convertRadix2: carry overflow pos=${gt} from=${dt}`);
      for (gt += dt; gt >= ot; gt -= ot)
        xt.push((mt >> gt - ot & St) >>> 0);
      mt &= 2 ** gt - 1;
    }
    if (mt = mt << ot - gt & St, !ut && gt >= dt)
      throw new Error("Excess padding");
    if (!ut && mt)
      throw new Error(`Non-zero padding: ${mt}`);
    return ut && gt > 0 && xt.push(mt >>> 0), xt;
  }
  // @__NO_SIDE_EFFECTS__
  function Et(ct) {
    return {
      encode: (dt) => {
        if (!J(dt))
          throw new Error("radix.encode input should be Uint8Array");
        return /* @__PURE__ */ at(Array.from(dt), 2 ** 8, ct);
      },
      decode: (dt) => {
        if (!Array.isArray(dt) || dt.length && typeof dt[0] != "number")
          throw new Error("radix.decode input should be array of numbers");
        return Uint8Array.from(/* @__PURE__ */ at(dt, ct, 2 ** 8));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function wt(ct, dt = !1) {
    if (ct <= 0 || ct > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ it(8, ct) > 32 || /* @__PURE__ */ it(ct, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (ot) => {
        if (!J(ot))
          throw new Error("radix2.encode input should be Uint8Array");
        return /* @__PURE__ */ lt(Array.from(ot), 8, ct, !dt);
      },
      decode: (ot) => {
        if (!Array.isArray(ot) || ot.length && typeof ot[0] != "number")
          throw new Error("radix2.decode input should be array of numbers");
        return Uint8Array.from(/* @__PURE__ */ lt(ot, ct, 8, dt));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function Rt(ct) {
    if (typeof ct != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...dt) {
      try {
        return ct.apply(null, dt);
      } catch {
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function Mt(ct, dt) {
    if (typeof dt != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(ot) {
        if (!J(ot))
          throw new Error("checksum.encode: input should be Uint8Array");
        const ut = dt(ot).slice(0, ct), mt = new Uint8Array(ot.length + ct);
        return mt.set(ot), mt.set(ut, ot.length), mt;
      },
      decode(ot) {
        if (!J(ot))
          throw new Error("checksum.decode: input should be Uint8Array");
        const ut = ot.slice(0, -ct), mt = dt(ut).slice(0, ct), gt = ot.slice(-ct);
        for (let St = 0; St < ct; St++)
          if (mt[St] !== gt[St])
            throw new Error("Invalid checksum");
        return ut;
      }
    };
  }
  B.utils = {
    alphabet: oe,
    chain: ne,
    checksum: Mt,
    convertRadix: at,
    convertRadix2: lt,
    radix: Et,
    radix2: wt,
    join: ce,
    padding: Ce
  }, B.base16 = /* @__PURE__ */ ne(/* @__PURE__ */ wt(4), /* @__PURE__ */ oe("0123456789ABCDEF"), /* @__PURE__ */ ce("")), B.base32 = /* @__PURE__ */ ne(/* @__PURE__ */ wt(5), /* @__PURE__ */ oe("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ Ce(5), /* @__PURE__ */ ce("")), B.base32nopad = /* @__PURE__ */ ne(/* @__PURE__ */ wt(5), /* @__PURE__ */ oe("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ ce("")), B.base32hex = /* @__PURE__ */ ne(/* @__PURE__ */ wt(5), /* @__PURE__ */ oe("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ Ce(5), /* @__PURE__ */ ce("")), B.base32hexnopad = /* @__PURE__ */ ne(/* @__PURE__ */ wt(5), /* @__PURE__ */ oe("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ ce("")), B.base32crockford = /* @__PURE__ */ ne(/* @__PURE__ */ wt(5), /* @__PURE__ */ oe("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ ce(""), /* @__PURE__ */ rt((ct) => ct.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), B.base64 = /* @__PURE__ */ ne(/* @__PURE__ */ wt(6), /* @__PURE__ */ oe("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ Ce(6), /* @__PURE__ */ ce("")), B.base64nopad = /* @__PURE__ */ ne(/* @__PURE__ */ wt(6), /* @__PURE__ */ oe("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ ce("")), B.base64url = /* @__PURE__ */ ne(/* @__PURE__ */ wt(6), /* @__PURE__ */ oe("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ Ce(6), /* @__PURE__ */ ce("")), B.base64urlnopad = /* @__PURE__ */ ne(/* @__PURE__ */ wt(6), /* @__PURE__ */ oe("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ ce(""));
  const Lt = (ct) => /* @__PURE__ */ ne(/* @__PURE__ */ Et(58), /* @__PURE__ */ oe(ct), /* @__PURE__ */ ce(""));
  B.base58 = Lt("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), B.base58flickr = Lt("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), B.base58xrp = Lt("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const zt = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  B.base58xmr = {
    encode(ct) {
      let dt = "";
      for (let ot = 0; ot < ct.length; ot += 8) {
        const ut = ct.subarray(ot, ot + 8);
        dt += B.base58.encode(ut).padStart(zt[ut.length], "1");
      }
      return dt;
    },
    decode(ct) {
      let dt = [];
      for (let ot = 0; ot < ct.length; ot += 11) {
        const ut = ct.slice(ot, ot + 11), mt = zt.indexOf(ut.length), gt = B.base58.decode(ut);
        for (let St = 0; St < gt.length - mt; St++)
          if (gt[St] !== 0)
            throw new Error("base58xmr: wrong padding");
        dt = dt.concat(Array.from(gt.slice(gt.length - mt)));
      }
      return Uint8Array.from(dt);
    }
  };
  const Ot = (ct) => /* @__PURE__ */ ne(/* @__PURE__ */ Mt(4, (dt) => ct(ct(dt))), B.base58);
  B.createBase58check = Ot, B.base58check = B.createBase58check;
  const It = /* @__PURE__ */ ne(/* @__PURE__ */ oe("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ ce("")), Ft = [996825010, 642813549, 513874426, 1027748829, 705979059];
  // @__NO_SIDE_EFFECTS__
  function Jt(ct) {
    const dt = ct >> 25;
    let ot = (ct & 33554431) << 5;
    for (let ut = 0; ut < Ft.length; ut++)
      (dt >> ut & 1) === 1 && (ot ^= Ft[ut]);
    return ot;
  }
  // @__NO_SIDE_EFFECTS__
  function Vt(ct, dt, ot = 1) {
    const ut = ct.length;
    let mt = 1;
    for (let gt = 0; gt < ut; gt++) {
      const St = ct.charCodeAt(gt);
      if (St < 33 || St > 126)
        throw new Error(`Invalid prefix (${ct})`);
      mt = /* @__PURE__ */ Jt(mt) ^ St >> 5;
    }
    mt = /* @__PURE__ */ Jt(mt);
    for (let gt = 0; gt < ut; gt++)
      mt = /* @__PURE__ */ Jt(mt) ^ ct.charCodeAt(gt) & 31;
    for (let gt of dt)
      mt = /* @__PURE__ */ Jt(mt) ^ gt;
    for (let gt = 0; gt < 6; gt++)
      mt = /* @__PURE__ */ Jt(mt);
    return mt ^= ot, It.encode(/* @__PURE__ */ lt([mt % 2 ** 30], 30, 5, !1));
  }
  // @__NO_SIDE_EFFECTS__
  function yr(ct) {
    const dt = ct === "bech32" ? 1 : 734539939, ot = /* @__PURE__ */ wt(5), ut = ot.decode, mt = ot.encode, gt = /* @__PURE__ */ Rt(ut);
    function St(yt, Bt, rr = 90) {
      if (typeof yt != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof yt}`);
      if (!Array.isArray(Bt) || Bt.length && typeof Bt[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof Bt}`);
      if (yt.length === 0)
        throw new TypeError(`Invalid prefix length ${yt.length}`);
      const dr = yt.length + 7 + Bt.length;
      if (rr !== !1 && dr > rr)
        throw new TypeError(`Length ${dr} exceeds limit ${rr}`);
      const tr = yt.toLowerCase(), Dt = /* @__PURE__ */ Vt(tr, Bt, dt);
      return `${tr}1${It.encode(Bt)}${Dt}`;
    }
    function xt(yt, Bt = 90) {
      if (typeof yt != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof yt}`);
      if (yt.length < 8 || Bt !== !1 && yt.length > Bt)
        throw new TypeError(`Wrong string length: ${yt.length} (${yt}). Expected (8..${Bt})`);
      const rr = yt.toLowerCase();
      if (yt !== rr && yt !== yt.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      const dr = rr.lastIndexOf("1");
      if (dr === 0 || dr === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const tr = rr.slice(0, dr), Dt = rr.slice(dr + 1);
      if (Dt.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const Wt = It.decode(Dt).slice(0, -6), or = /* @__PURE__ */ Vt(tr, Wt, dt);
      if (!Dt.endsWith(or))
        throw new Error(`Invalid checksum in ${yt}: expected "${or}"`);
      return { prefix: tr, words: Wt };
    }
    const vt = /* @__PURE__ */ Rt(xt);
    function $t(yt) {
      const { prefix: Bt, words: rr } = xt(yt, !1);
      return { prefix: Bt, words: rr, bytes: ut(rr) };
    }
    return { encode: St, decode: xt, decodeToBytes: $t, decodeUnsafe: vt, fromWords: ut, fromWordsUnsafe: gt, toWords: mt };
  }
  B.bech32 = /* @__PURE__ */ yr("bech32"), B.bech32m = /* @__PURE__ */ yr("bech32m"), B.utf8 = {
    encode: (ct) => new TextDecoder().decode(ct),
    decode: (ct) => new TextEncoder().encode(ct)
  }, B.hex = /* @__PURE__ */ ne(/* @__PURE__ */ wt(4), /* @__PURE__ */ oe("0123456789abcdef"), /* @__PURE__ */ ce(""), /* @__PURE__ */ rt((ct) => {
    if (typeof ct != "string" || ct.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof ct} with length ${ct.length}`);
    return ct.toLowerCase();
  }));
  const jt = {
    utf8: B.utf8,
    hex: B.hex,
    base16: B.base16,
    base32: B.base32,
    base64: B.base64,
    base64url: B.base64url,
    base58: B.base58,
    base58xmr: B.base58xmr
  }, Ut = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", er = (ct, dt) => {
    if (typeof ct != "string" || !jt.hasOwnProperty(ct))
      throw new TypeError(Ut);
    if (!J(dt))
      throw new TypeError("bytesToString() expects Uint8Array");
    return jt[ct].encode(dt);
  };
  B.bytesToString = er, B.str = B.bytesToString;
  const Ht = (ct, dt) => {
    if (!jt.hasOwnProperty(ct))
      throw new TypeError(Ut);
    if (typeof dt != "string")
      throw new TypeError("stringToBytes() expects string");
    return jt[ct].decode(dt);
  };
  B.stringToBytes = Ht, B.bytes = B.stringToBytes;
})(lib);
var _Buffer = safeBufferExports$1.Buffer;
function base$1(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var L = new Uint8Array(256), J = 0; J < L.length; J++)
    L[J] = 255;
  for (var ne = 0; ne < B.length; ne++) {
    var oe = B.charAt(ne), ce = oe.charCodeAt(0);
    if (L[ce] !== 255)
      throw new TypeError(oe + " is ambiguous");
    L[ce] = ne;
  }
  var Ce = B.length, rt = B.charAt(0), at = Math.log(Ce) / Math.log(256), ht = Math.log(256) / Math.log(Ce);
  function it(wt) {
    if ((Array.isArray(wt) || wt instanceof Uint8Array) && (wt = _Buffer.from(wt)), !_Buffer.isBuffer(wt))
      throw new TypeError("Expected Buffer");
    if (wt.length === 0)
      return "";
    for (var Rt = 0, Mt = 0, Lt = 0, zt = wt.length; Lt !== zt && wt[Lt] === 0; )
      Lt++, Rt++;
    for (var Ot = (zt - Lt) * ht + 1 >>> 0, It = new Uint8Array(Ot); Lt !== zt; ) {
      for (var Ft = wt[Lt], Jt = 0, Vt = Ot - 1; (Ft !== 0 || Jt < Mt) && Vt !== -1; Vt--, Jt++)
        Ft += 256 * It[Vt] >>> 0, It[Vt] = Ft % Ce >>> 0, Ft = Ft / Ce >>> 0;
      if (Ft !== 0)
        throw new Error("Non-zero carry");
      Mt = Jt, Lt++;
    }
    for (var yr = Ot - Mt; yr !== Ot && It[yr] === 0; )
      yr++;
    for (var jt = rt.repeat(Rt); yr < Ot; ++yr)
      jt += B.charAt(It[yr]);
    return jt;
  }
  function lt(wt) {
    if (typeof wt != "string")
      throw new TypeError("Expected String");
    if (wt.length === 0)
      return _Buffer.alloc(0);
    for (var Rt = 0, Mt = 0, Lt = 0; wt[Rt] === rt; )
      Mt++, Rt++;
    for (var zt = (wt.length - Rt) * at + 1 >>> 0, Ot = new Uint8Array(zt); Rt < wt.length; ) {
      var It = L[wt.charCodeAt(Rt)];
      if (It === 255)
        return;
      for (var Ft = 0, Jt = zt - 1; (It !== 0 || Ft < Lt) && Jt !== -1; Jt--, Ft++)
        It += Ce * Ot[Jt] >>> 0, Ot[Jt] = It % 256 >>> 0, It = It / 256 >>> 0;
      if (It !== 0)
        throw new Error("Non-zero carry");
      Lt = Ft, Rt++;
    }
    for (var Vt = zt - Lt; Vt !== zt && Ot[Vt] === 0; )
      Vt++;
    var yr = _Buffer.allocUnsafe(Mt + (zt - Vt));
    yr.fill(0, 0, Mt);
    for (var jt = Mt; Vt !== zt; )
      yr[jt++] = Ot[Vt++];
    return yr;
  }
  function Et(wt) {
    var Rt = lt(wt);
    if (Rt)
      return Rt;
    throw new Error("Non-base" + Ce + " character");
  }
  return {
    encode: it,
    decodeUnsafe: lt,
    decode: Et
  };
}
var src$1 = base$1, basex = src$1, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET), base58 = bs58, Buffer = safeBufferExports$1.Buffer, base = function(B) {
  function L(ce) {
    var Ce = B(ce);
    return base58.encode(Buffer.concat([
      ce,
      Ce
    ], ce.length + 4));
  }
  function J(ce) {
    var Ce = ce.slice(0, -4), rt = ce.slice(-4), at = B(Ce);
    if (!(rt[0] ^ at[0] | rt[1] ^ at[1] | rt[2] ^ at[2] | rt[3] ^ at[3]))
      return Ce;
  }
  function ne(ce) {
    var Ce = base58.decodeUnsafe(ce);
    if (Ce)
      return J(Ce);
  }
  function oe(ce) {
    var Ce = base58.decode(ce), rt = J(Ce);
    if (!rt) throw new Error("Invalid checksum");
    return rt;
  }
  return {
    encode: L,
    decode: oe,
    decodeUnsafe: ne
  };
}, createHash = browser$9, bs58checkBase = base;
function sha256x2(B) {
  var L = createHash("sha256").update(B).digest();
  return createHash("sha256").update(L).digest();
}
var bs58check$2 = bs58checkBase(sha256x2), bs58check$1 = bs58check$2;
function decodeRaw(B, L) {
  if (L !== void 0 && B[0] !== L) throw new Error("Invalid network version");
  if (B.length === 33)
    return {
      version: B[0],
      privateKey: B.slice(1, 33),
      compressed: !1
    };
  if (B.length !== 34) throw new Error("Invalid WIF length");
  if (B[33] !== 1) throw new Error("Invalid compression flag");
  return {
    version: B[0],
    privateKey: B.slice(1, 33),
    compressed: !0
  };
}
function encodeRaw(B, L, J) {
  var ne = new Buffer$D(J ? 34 : 33);
  return ne.writeUInt8(B, 0), L.copy(ne, 1), J && (ne[33] = 1), ne;
}
function decode(B, L) {
  return decodeRaw(bs58check$1.decode(B), L);
}
function encode(B, L, J) {
  return typeof B == "number" ? bs58check$1.encode(encodeRaw(B, L, J)) : bs58check$1.encode(
    encodeRaw(
      B.version,
      B.privateKey,
      B.compressed
    )
  );
}
var wif$2 = {
  decode,
  decodeRaw,
  encode,
  encodeRaw
};
Object.defineProperty(bip32, "__esModule", { value: !0 });
bip32.BIP32Factory = void 0;
const crypto$1 = crypto$2, testecc_1$1 = testecc$1, base_1 = lib, sha256_1 = sha256$5, typeforce = typeforce_1, wif$1 = wif$2, _bs58check = (0, base_1.base58check)(sha256_1.sha256), bs58check = {
  encode: (B) => _bs58check.encode(Uint8Array.from(B)),
  decode: (B) => Buffer$D.from(_bs58check.decode(B))
};
function BIP32Factory(B) {
  (0, testecc_1$1.testEcc)(B);
  const L = typeforce.BufferN(32), J = typeforce.compile({
    wif: typeforce.UInt8,
    bip32: {
      public: typeforce.UInt32,
      private: typeforce.UInt32
    }
  }), ne = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, oe = 2147483648, ce = Math.pow(2, 31) - 1;
  function Ce(zt) {
    return typeforce.String(zt) && zt.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
  }
  function rt(zt) {
    return typeforce.UInt32(zt) && zt <= ce;
  }
  function at(zt) {
    return zt.length === 32 ? zt : zt.slice(1, 33);
  }
  class ht {
    constructor(Ot, It) {
      this.__D = Ot, this.__Q = It, this.lowR = !1;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = Buffer$D.from(B.pointFromScalar(this.__D, !0))), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(Ot, It) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (It === void 0 && (It = this.lowR), It === !1)
        return Buffer$D.from(B.sign(Ot, this.privateKey));
      {
        let Ft = Buffer$D.from(B.sign(Ot, this.privateKey));
        const Jt = Buffer$D.alloc(32, 0);
        let Vt = 0;
        for (; Ft[0] > 127; )
          Vt++, Jt.writeUIntLE(Vt, 0, 6), Ft = Buffer$D.from(B.sign(Ot, this.privateKey, Jt));
        return Ft;
      }
    }
    signSchnorr(Ot) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!B.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer$D.from(B.signSchnorr(Ot, this.privateKey));
    }
    verify(Ot, It) {
      return B.verify(Ot, this.publicKey, It);
    }
    verifySchnorr(Ot, It) {
      if (!B.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return B.verifySchnorr(Ot, this.publicKey.subarray(1, 33), It);
    }
  }
  class it extends ht {
    constructor(Ot, It, Ft, Jt, Vt = 0, yr = 0, jt = 0) {
      super(Ot, It), this.chainCode = Ft, this.network = Jt, this.__DEPTH = Vt, this.__INDEX = yr, this.__PARENT_FINGERPRINT = jt, typeforce(J, Jt);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return crypto$1.hash160(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return Mt(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const Ot = this.network, It = this.isNeutered() ? Ot.bip32.public : Ot.bip32.private, Ft = Buffer$D.allocUnsafe(78);
      return Ft.writeUInt32BE(It, 0), Ft.writeUInt8(this.depth, 4), Ft.writeUInt32BE(this.parentFingerprint, 5), Ft.writeUInt32BE(this.index, 9), this.chainCode.copy(Ft, 13), this.isNeutered() ? this.publicKey.copy(Ft, 45) : (Ft.writeUInt8(0, 45), this.privateKey.copy(Ft, 46)), bs58check.encode(Ft);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return wif$1.encode(this.network.wif, this.privateKey, !0);
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(Ot) {
      typeforce(typeforce.UInt32, Ot);
      const It = Ot >= oe, Ft = Buffer$D.allocUnsafe(37);
      if (It) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        Ft[0] = 0, this.privateKey.copy(Ft, 1), Ft.writeUInt32BE(Ot, 33);
      } else
        this.publicKey.copy(Ft, 0), Ft.writeUInt32BE(Ot, 33);
      const Jt = crypto$1.hmacSHA512(this.chainCode, Ft), Vt = Jt.slice(0, 32), yr = Jt.slice(32);
      if (!B.isPrivate(Vt))
        return this.derive(Ot + 1);
      let jt;
      if (this.isNeutered()) {
        const Ut = Buffer$D.from(B.pointAddScalar(this.publicKey, Vt, !0));
        if (Ut === null)
          return this.derive(Ot + 1);
        jt = Mt(Ut, yr, this.network, this.depth + 1, Ot, this.fingerprint.readUInt32BE(0));
      } else {
        const Ut = Buffer$D.from(B.privateAdd(this.privateKey, Vt));
        if (Ut == null)
          return this.derive(Ot + 1);
        jt = wt(Ut, yr, this.network, this.depth + 1, Ot, this.fingerprint.readUInt32BE(0));
      }
      return jt;
    }
    deriveHardened(Ot) {
      return typeforce(rt, Ot), this.derive(Ot + oe);
    }
    derivePath(Ot) {
      typeforce(Ce, Ot);
      let It = Ot.split("/");
      if (It[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        It = It.slice(1);
      }
      return It.reduce((Ft, Jt) => {
        let Vt;
        return Jt.slice(-1) === "'" ? (Vt = parseInt(Jt.slice(0, -1), 10), Ft.deriveHardened(Vt)) : (Vt = parseInt(Jt, 10), Ft.derive(Vt));
      }, this);
    }
    tweak(Ot) {
      return this.privateKey ? this.tweakFromPrivateKey(Ot) : this.tweakFromPublicKey(Ot);
    }
    tweakFromPublicKey(Ot) {
      const It = at(this.publicKey);
      if (!B.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const Ft = B.xOnlyPointAddTweak(It, Ot);
      if (!Ft || Ft.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const Jt = Buffer$D.from([
        Ft.parity === 0 ? 2 : 3
      ]), Vt = Buffer$D.concat([
        Jt,
        Ft.xOnlyPubkey
      ]);
      return new ht(void 0, Vt);
    }
    tweakFromPrivateKey(Ot) {
      const It = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, Ft = (() => {
        if (It) {
          if (B.privateNegate)
            return B.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), Jt = B.privateAdd(Ft, Ot);
      if (!Jt)
        throw new Error("Invalid tweaked private key!");
      return new ht(Buffer$D.from(Jt), void 0);
    }
  }
  function lt(zt, Ot) {
    const It = bs58check.decode(zt);
    if (It.length !== 78)
      throw new TypeError("Invalid buffer length");
    Ot = Ot || ne;
    const Ft = It.readUInt32BE(0);
    if (Ft !== Ot.bip32.private && Ft !== Ot.bip32.public)
      throw new TypeError("Invalid network version");
    const Jt = It[4], Vt = It.readUInt32BE(5);
    if (Jt === 0 && Vt !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const yr = It.readUInt32BE(9);
    if (Jt === 0 && yr !== 0)
      throw new TypeError("Invalid index");
    const jt = It.slice(13, 45);
    let Ut;
    if (Ft === Ot.bip32.private) {
      if (It.readUInt8(45) !== 0)
        throw new TypeError("Invalid private key");
      const er = It.slice(46, 78);
      Ut = wt(er, jt, Ot, Jt, yr, Vt);
    } else {
      const er = It.slice(45, 78);
      Ut = Mt(er, jt, Ot, Jt, yr, Vt);
    }
    return Ut;
  }
  function Et(zt, Ot, It) {
    return wt(zt, Ot, It);
  }
  function wt(zt, Ot, It, Ft, Jt, Vt) {
    if (typeforce({
      privateKey: L,
      chainCode: L
    }, { privateKey: zt, chainCode: Ot }), It = It || ne, !B.isPrivate(zt))
      throw new TypeError("Private key not in range [1, n)");
    return new it(zt, void 0, Ot, It, Ft, Jt, Vt);
  }
  function Rt(zt, Ot, It) {
    return Mt(zt, Ot, It);
  }
  function Mt(zt, Ot, It, Ft, Jt, Vt) {
    if (typeforce({
      publicKey: typeforce.BufferN(33),
      chainCode: L
    }, { publicKey: zt, chainCode: Ot }), It = It || ne, !B.isPoint(zt))
      throw new TypeError("Point is not on the curve");
    return new it(void 0, zt, Ot, It, Ft, Jt, Vt);
  }
  function Lt(zt, Ot) {
    if (typeforce(typeforce.Buffer, zt), zt.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (zt.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    Ot = Ot || ne;
    const It = crypto$1.hmacSHA512(Buffer$D.from("Bitcoin seed", "utf8"), zt), Ft = It.slice(0, 32), Jt = It.slice(32);
    return Et(Ft, Jt, Ot);
  }
  return {
    fromSeed: Lt,
    fromBase58: lt,
    fromPublicKey: Rt,
    fromPrivateKey: Et
  };
}
bip32.BIP32Factory = BIP32Factory;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.BIP32Factory = B.default = void 0;
  var L = bip32;
  Object.defineProperty(B, "default", { enumerable: !0, get: function() {
    return L.BIP32Factory;
  } }), Object.defineProperty(B, "BIP32Factory", { enumerable: !0, get: function() {
    return L.BIP32Factory;
  } });
})(src$2);
const MINIMUM_AMOUNT_IN_SATS = 600, MAXIMUM_FEE = 5e6, INSTANT_BUY_SELLER_INPUT_INDEX = 2, BIP32 = src$2.BIP32Factory(ecc), CHAIN_CODE = Buffer$D.alloc(32, 1);
var src = {}, ecpair = {}, networks$1 = {};
Object.defineProperty(networks$1, "__esModule", { value: !0 });
networks$1.testnet = networks$1.bitcoin = void 0;
networks$1.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
networks$1.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var types$1 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.maybe = B.Boolean = B.Array = B.Buffer256bit = B.Network = B.typeforce = void 0, B.typeforce = typeforce_1, B.Network = B.typeforce.compile({
    messagePrefix: B.typeforce.oneOf(
      B.typeforce.Buffer,
      B.typeforce.String
    ),
    bip32: {
      public: B.typeforce.UInt32,
      private: B.typeforce.UInt32
    },
    pubKeyHash: B.typeforce.UInt8,
    scriptHash: B.typeforce.UInt8,
    wif: B.typeforce.UInt8
  }), B.Buffer256bit = B.typeforce.BufferN(32), B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.maybe = B.typeforce.maybe;
})(types$1);
var testecc = {};
Object.defineProperty(testecc, "__esModule", { value: !0 });
testecc.testEcc = void 0;
const h = (B) => Buffer$D.from(B, "hex");
function testEcc(B) {
  assert(
    B.isPoint(
      h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    !B.isPoint(
      h("030000000000000000000000000000000000000000000000000000000000000005")
    )
  ), assert(
    B.isPrivate(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isPrivate(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), assert(
    !B.isPrivate(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isPrivate(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
    )
  ), assert(
    !B.isPrivate(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
    )
  ), assert(
    Buffer$D.from(
      B.privateAdd(
        h("0000000000000000000000000000000000000000000000000000000000000001"),
        h("0000000000000000000000000000000000000000000000000000000000000000")
      )
    ).equals(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    B.privateAdd(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      h("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null
  ), assert(
    Buffer$D.from(
      B.privateAdd(
        h("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
        h("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
      )
    ).equals(
      h("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    )
  ), assert(
    Buffer$D.from(
      B.privateNegate(
        h("0000000000000000000000000000000000000000000000000000000000000001")
      )
    ).equals(
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), assert(
    Buffer$D.from(
      B.privateNegate(
        h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      )
    ).equals(
      h("0000000000000000000000000000000000000000000000000000000000000003")
    )
  ), assert(
    Buffer$D.from(
      B.privateNegate(
        h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    )
  ), assert(
    Buffer$D.from(
      B.pointCompress(
        h(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      )
    ).equals(
      h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    Buffer$D.from(
      B.pointCompress(
        h(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      )
    ).equals(
      h(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), assert(
    Buffer$D.from(
      B.pointCompress(
        h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !0
      )
    ).equals(
      h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    Buffer$D.from(
      B.pointCompress(
        h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !1
      )
    ).equals(
      h(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), assert(
    Buffer$D.from(
      B.pointFromScalar(
        h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    )
  ), assert(
    B.xOnlyPointAddTweak(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null
  );
  let L = B.xOnlyPointAddTweak(
    h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  assert(
    Buffer$D.from(L.xOnlyPubkey).equals(
      h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && L.parity === 1
  ), L = B.xOnlyPointAddTweak(
    h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), assert(
    Buffer$D.from(L.xOnlyPubkey).equals(
      h("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && L.parity === 0
  ), assert(
    Buffer$D.from(
      B.sign(
        h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
        h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ).equals(
      h(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), assert(
    B.verify(
      h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      h(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), B.signSchnorr && assert(
    Buffer$D.from(
      B.signSchnorr(
        h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
        h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
        h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
      )
    ).equals(
      h(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  ), B.verifySchnorr && assert(
    B.verifySchnorr(
      h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
      h(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  );
}
testecc.testEcc = testEcc;
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
Object.defineProperty(ecpair, "__esModule", { value: !0 });
ecpair.ECPairFactory = ecpair.networks = void 0;
const networks = networks$1;
ecpair.networks = networks;
const types = types$1, randomBytes = browserExports, wif = wif$2, testecc_1 = testecc, isOptions = types.typeforce.maybe(
  types.typeforce.compile({
    compressed: types.maybe(types.Boolean),
    network: types.maybe(types.Network)
  })
), toXOnly$1 = (B) => B.length === 32 ? B : B.slice(1, 33);
function ECPairFactory(B) {
  (0, testecc_1.testEcc)(B);
  function L(rt) {
    return B.isPoint(rt);
  }
  function J(rt, at) {
    if (types.typeforce(types.Buffer256bit, rt), !B.isPrivate(rt))
      throw new TypeError("Private key not in range [1, n)");
    return types.typeforce(isOptions, at), new Ce(rt, void 0, at);
  }
  function ne(rt, at) {
    return types.typeforce(B.isPoint, rt), types.typeforce(isOptions, at), new Ce(void 0, rt, at);
  }
  function oe(rt, at) {
    const ht = wif.decode(rt), it = ht.version;
    if (types.Array(at)) {
      if (at = at.filter((lt) => it === lt.wif).pop(), !at) throw new Error("Unknown network version");
    } else if (at = at || networks.bitcoin, it !== at.wif) throw new Error("Invalid network version");
    return J(ht.privateKey, {
      compressed: ht.compressed,
      network: at
    });
  }
  function ce(rt) {
    types.typeforce(isOptions, rt), rt === void 0 && (rt = {});
    const at = rt.rng || randomBytes;
    let ht;
    do
      ht = at(32), types.typeforce(types.Buffer256bit, ht);
    while (!B.isPrivate(ht));
    return J(ht, rt);
  }
  class Ce {
    constructor(at, ht, it) {
      Li(this, "__D");
      Li(this, "__Q");
      Li(this, "compressed");
      Li(this, "network");
      Li(this, "lowR");
      this.__D = at, this.__Q = ht, this.lowR = !1, it === void 0 && (it = {}), this.compressed = it.compressed === void 0 ? !0 : it.compressed, this.network = it.network || networks.bitcoin, ht !== void 0 && (this.__Q = Buffer$D.from(B.pointCompress(ht, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const at = B.pointFromScalar(this.__D, this.compressed);
        this.__Q = Buffer$D.from(at);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error("Missing private key");
      return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(at) {
      return this.privateKey ? this.tweakFromPrivateKey(at) : this.tweakFromPublicKey(at);
    }
    sign(at, ht) {
      if (!this.__D) throw new Error("Missing private key");
      if (ht === void 0 && (ht = this.lowR), ht === !1)
        return Buffer$D.from(B.sign(at, this.__D));
      {
        let it = B.sign(at, this.__D);
        const lt = Buffer$D.alloc(32, 0);
        let Et = 0;
        for (; it[0] > 127; )
          Et++, lt.writeUIntLE(Et, 0, 6), it = B.sign(at, this.__D, lt);
        return Buffer$D.from(it);
      }
    }
    signSchnorr(at) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (!B.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer$D.from(B.signSchnorr(at, this.privateKey));
    }
    verify(at, ht) {
      return B.verify(at, this.publicKey, ht);
    }
    verifySchnorr(at, ht) {
      if (!B.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return B.verifySchnorr(at, this.publicKey.subarray(1, 33), ht);
    }
    tweakFromPublicKey(at) {
      const ht = toXOnly$1(this.publicKey), it = B.xOnlyPointAddTweak(ht, at);
      if (!it || it.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const lt = Buffer$D.from([
        it.parity === 0 ? 2 : 3
      ]);
      return ne(
        Buffer$D.concat([lt, it.xOnlyPubkey]),
        { network: this.network, compressed: this.compressed }
      );
    }
    tweakFromPrivateKey(at) {
      const it = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1 ? B.privateNegate(this.privateKey) : this.privateKey, lt = B.privateAdd(it, at);
      if (!lt) throw new Error("Invalid tweaked private key!");
      return J(Buffer$D.from(lt), {
        network: this.network,
        compressed: this.compressed
      });
    }
  }
  return {
    isPoint: L,
    fromPrivateKey: J,
    fromPublicKey: ne,
    fromWIF: oe,
    makeRandom: ce
  };
}
ecpair.ECPairFactory = ECPairFactory;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.networks = B.ECPairFactory = B.default = void 0;
  var L = ecpair;
  Object.defineProperty(B, "default", {
    enumerable: !0,
    get: function() {
      return L.ECPairFactory;
    }
  }), Object.defineProperty(B, "ECPairFactory", {
    enumerable: !0,
    get: function() {
      return L.ECPairFactory;
    }
  }), Object.defineProperty(B, "networks", {
    enumerable: !0,
    get: function() {
      return L.networks;
    }
  });
})(src);
function invert(B) {
  return Object.fromEntries(
    Object.entries(B).map(([L, J]) => [J, L])
  );
}
const ADDRESS_TYPE_TO_FORMAT = {
  p2pkh: "legacy",
  p2sh: "p2sh-p2wpkh",
  p2wsh: "p2wsh",
  p2wpkh: "segwit",
  p2tr: "taproot"
}, ADDRESS_FORMAT_TO_TYPE = invert(ADDRESS_TYPE_TO_FORMAT);
function getNetwork(B) {
  return B === "mainnet" ? src$4.networks.bitcoin : B === "signet" ? src$4.networks.testnet : src$4.networks[B];
}
function createPayment(B, L, J, ne) {
  src$4.initEccLib(ecc);
  const oe = typeof J == "string" ? getNetwork(J) : J;
  return L === "p2tr" ? src$4.payments.p2tr({
    internalPubkey: B,
    network: oe,
    ...ne
  }) : L === "p2sh" ? src$4.payments.p2sh({
    redeem: src$4.payments.p2wpkh({ pubkey: B, network: oe }),
    network: oe
  }) : src$4.payments[L]({ pubkey: B, network: oe });
}
function toXOnly(B) {
  return B.subarray(1, 33);
}
const isObject = (B) => (B == null ? void 0 : B.constructor) === Object, isString$1 = (B) => B instanceof String || typeof B == "string";
function encodeDecodeObject(B, { encode: L, depth: J = 0 }) {
  if (J > 5)
    throw new OrditSDKError("Object too deep");
  for (const oe in B) {
    if (!B.hasOwnProperty(oe))
      continue;
    const ce = B[oe];
    isObject(ce) ? B[oe] = encodeDecodeObject(ce, {
      encode: L,
      depth: J + 1
    }) : isString$1(ce) && (B[oe] = L ? encodeURIComponent(ce) : decodeURIComponent(ce));
  }
  return B;
}
function UNSTABLE_decodeObject(B) {
  return encodeDecodeObject(B, { encode: !1 });
}
function convertSatoshisToBTC(B) {
  return B / 10 ** 8;
}
function generateTxUniqueIdentifier(B, L) {
  return `${B}:${L}`;
}
function outpointToIdFormat(B) {
  return B.includes(":") ? B.replace(":", "i") : B.includes("i") ? B : `${B}i0`;
}
function isPaymentFactory(B, L) {
  return (J) => {
    try {
      return B({ output: J, network: getNetwork(L) });
    } catch {
      return !1;
    }
  };
}
const isP2PKH = (B, L) => ({
  type: "p2pkh",
  payload: isPaymentFactory(src$4.payments.p2pkh, L)(B)
}), isP2WPKH = (B, L) => ({
  type: "p2wpkh",
  payload: isPaymentFactory(src$4.payments.p2wpkh, L)(B)
}), isP2SHScript = (B, L) => ({
  type: "p2sh",
  payload: isPaymentFactory(src$4.payments.p2sh, L)(B)
}), isP2TR = (B, L) => ({
  type: "p2tr",
  payload: isPaymentFactory(src$4.payments.p2tr, L)(B)
});
function getScriptType(B, L) {
  const J = isP2PKH(B, L);
  if (J.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2pkh,
      ...J
    };
  const ne = isP2WPKH(B, L);
  if (ne.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2wpkh,
      ...ne
    };
  const oe = isP2SHScript(B, L);
  if (oe.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2sh,
      ...oe
    };
  const ce = isP2TR(B, L);
  if (ce.payload)
    return {
      format: ADDRESS_TYPE_TO_FORMAT.p2tr,
      ...ce
    };
  throw new OrditSDKError("Unsupported input");
}
function getAddressFormatForRegTest(B) {
  try {
    const { type: L, network: J, bech32: ne } = z(B);
    if (!ne && J !== "testnet" || ne && J !== "regtest")
      throw new Error("Invalid address");
    return ADDRESS_TYPE_TO_FORMAT[L];
  } catch {
    throw new OrditSDKError("Invalid address");
  }
}
function getAddressFormat(B, L) {
  if (L === "regtest")
    return getAddressFormatForRegTest(B);
  if (!O(
    B,
    L === "signet" ? "testnet" : L
  ))
    throw new OrditSDKError("Invalid address");
  const { type: J } = z(B);
  return ADDRESS_TYPE_TO_FORMAT[J];
}
function getTaprootAddressFromBip32PublicKey(B, L) {
  const J = B.subarray(1, 33), { address: ne } = createPayment(J, "p2tr", L);
  return {
    address: ne,
    // address will never be undefined
    format: ADDRESS_TYPE_TO_FORMAT.p2tr,
    publicKey: B.toString("hex"),
    xKey: J.toString("hex")
  };
}
function getAddressFromBip32PublicKey(B, L, J) {
  if (J === "p2tr")
    return getTaprootAddressFromBip32PublicKey(B, L);
  const { address: ne } = createPayment(B, J, L);
  return {
    address: ne,
    // address will never be undefined
    format: ADDRESS_TYPE_TO_FORMAT[J],
    publicKey: B.toString("hex")
  };
}
function getAddressesFromPublicKey(B, L = "mainnet", J = "all") {
  const ne = Buffer$D.isBuffer(B) ? B : Buffer$D.from(B, "hex"), { publicKey: oe } = BIP32.fromPublicKey(
    ne,
    CHAIN_CODE,
    getNetwork(L)
  );
  return J === "all" ? Object.keys(ADDRESS_TYPE_TO_FORMAT).filter((Ce) => Ce !== "p2wsh").map(
    (Ce) => getAddressFromBip32PublicKey(oe, L, Ce)
  ) : [getAddressFromBip32PublicKey(oe, L, J)];
}
const NETWORK_TO_BITCOIN_NETWORK_TYPE = {
  mainnet: BitcoinNetworkType.Mainnet,
  testnet: BitcoinNetworkType.Testnet
};
function fromXOnlyToFullPubkey(B) {
  return Buffer$D.from(B, "hex").length === 33 ? B : `02${B}`;
}
src$4.initEccLib(ecc);
async function satsConnectWalletGetAddresses(B, L = "mainnet") {
  if (L === "signet")
    throw new OrditSDKError("signet network is not supported");
  const J = [], ne = (Ce) => {
    if (!Ce || !Ce.addresses || Ce.addresses.length !== 2)
      throw new BrowserWalletSigningError(
        "Failed to retrieve addresses using selected wallet"
      );
    Ce.addresses.forEach((rt) => {
      const at = getAddressFormat(rt.address, L);
      let ht = rt.publicKey;
      at === "taproot" && (ht = fromXOnlyToFullPubkey(rt.publicKey)), J.push({
        publicKey: ht,
        address: rt.address,
        format: at
      });
    });
  }, oe = () => {
    throw new BrowserWalletRequestCancelledByUserError();
  }, ce = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: NETWORK_TO_BITCOIN_NETWORK_TYPE[L]
      }
    },
    getProvider: B,
    onFinish: (Ce) => ne(Ce),
    onCancel: oe
  };
  return await getAddress(ce), J;
}
async function satsConnectWalletSignPsbt(B, L, {
  finalize: J = !0,
  extractTx: ne = !0,
  network: oe,
  inputsToSign: ce
} = { network: "mainnet", inputsToSign: [] }) {
  if (oe === "signet")
    throw new OrditSDKError("signet network is not supported");
  if (!J && ne)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  if (!L || !oe || !ce.length)
    throw new OrditSDKError("Invalid options provided");
  let Ce, rt = null;
  const at = (lt) => {
    const { psbtBase64: Et } = lt;
    if (!Et)
      throw new BrowserWalletSigningError(
        "Failed to sign psbt using selected wallet"
      );
    const wt = src$4.Psbt.fromBase64(Et);
    if (J && ce.forEach((Rt) => {
      Rt.signingIndexes.forEach((Mt) => {
        try {
          wt.finalizeInput(Mt);
        } catch (Lt) {
          throw console.error("Sign psbt error", Lt), new OrditSDKError("Failed to finalize input");
        }
      });
    }), ne) {
      try {
        Ce = wt.extractTransaction().toHex();
      } catch (Rt) {
        throw Rt instanceof Error && Rt.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
      }
      rt = null;
    } else
      Ce = wt.toHex(), rt = wt.toBase64();
  }, ht = () => {
    throw new BrowserWalletRequestCancelledByUserError();
  }, it = {
    payload: {
      network: {
        type: NETWORK_TO_BITCOIN_NETWORK_TYPE[oe]
      },
      message: "Sign PSBT",
      psbtBase64: L.toBase64(),
      broadcast: !1,
      inputsToSign: ce
    },
    onFinish: at,
    onCancel: ht,
    getProvider: B
  };
  return await signTransaction(it), { hex: Ce, base64: rt };
}
async function satsConnectWalletSignMessage(B, L, J, ne = "mainnet") {
  if (ne === "signet")
    throw new OrditSDKError("signet network is not supported");
  if (!L || !ne || !J)
    throw new OrditSDKError("Invalid options provided");
  let oe, ce = null;
  const Ce = (ht) => {
    if (!ht)
      throw new BrowserWalletSigningError(
        "Failed to sign message using selected wallet"
      );
    oe = Buffer$D.from(ht, "base64").toString("hex"), ce = ht;
  }, rt = () => {
    throw new BrowserWalletRequestCancelledByUserError();
  }, at = {
    payload: {
      network: {
        type: NETWORK_TO_BITCOIN_NETWORK_TYPE[ne]
      },
      message: L,
      address: J
    },
    getProvider: B,
    onFinish: Ce,
    onCancel: rt
  };
  return await signMessage$6(at), { hex: oe, base64: ce };
}
async function getMagicEdenWalletProvider() {
  const { get: B } = getWallets(), J = B().find(
    (ne) => {
      var oe, ce;
      return ne.name === "Magic Eden" && ((ce = (oe = ne.features["sats-connect:"]) == null ? void 0 : oe.provider) == null ? void 0 : ce.isMagicEden) === !0;
    }
  );
  if (!J)
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  return J.features["sats-connect:"].provider;
}
async function isInstalled$4() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  try {
    const B = await getMagicEdenWalletProvider();
    return B.isMagicEden !== void 0 && B.isMagicEden === !0;
  } catch (B) {
    if (B instanceof BrowserWalletNotInstalledError)
      return !1;
    throw B;
  }
}
async function getAddresses$2(B = "mainnet") {
  if (!isInstalled$4())
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  if (B !== "mainnet")
    throw new BrowserWalletNetworkMismatchError(
      "Magic Eden Wallet only supports mainnet"
    );
  return satsConnectWalletGetAddresses(getMagicEdenWalletProvider, B);
}
async function signPsbt$5(B, {
  finalize: L = !0,
  extractTx: J = !0,
  network: ne,
  inputsToSign: oe
} = { network: "mainnet", inputsToSign: [] }) {
  if (!isInstalled$4())
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  if (ne !== "mainnet")
    throw new BrowserWalletNetworkMismatchError(
      "Magic Eden Wallet only supports mainnet"
    );
  return satsConnectWalletSignPsbt(getMagicEdenWalletProvider, B, {
    finalize: L,
    extractTx: J,
    network: ne,
    inputsToSign: oe
  });
}
async function signMessage$5(B, L, J = "mainnet") {
  if (!isInstalled$4())
    throw new BrowserWalletNotInstalledError(
      "Magic Eden Wallet not installed."
    );
  if (J !== "mainnet")
    throw new BrowserWalletNetworkMismatchError(
      "Magic Eden Wallet only supports mainnet"
    );
  return satsConnectWalletSignMessage(
    getMagicEdenWalletProvider,
    B,
    L,
    J
  );
}
const NETWORK_TO_UNISAT_NETWORK = {
  mainnet: "livenet",
  testnet: "testnet"
};
function isInstalled$3() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof window.unisat < "u";
}
async function getAddresses$1(B = "mainnet", L) {
  if (B === "signet")
    throw new OrditSDKError("signet network is not supported");
  if (!isInstalled$3())
    throw new BrowserWalletNotInstalledError("Unisat not installed");
  try {
    const J = await window.unisat.getNetwork(), ne = NETWORK_TO_UNISAT_NETWORK[B];
    J !== ne && await window.unisat.switchNetwork(ne);
    const oe = L ? await window.unisat.getAccounts() : await window.unisat.requestAccounts(), ce = await window.unisat.getPublicKey(), Ce = oe[0];
    if (!Ce)
      return [];
    const rt = getAddressFormat(Ce, B);
    return [
      {
        publicKey: ce,
        address: Ce,
        format: rt
      }
    ];
  } catch (J) {
    if (J instanceof OrditSDKError)
      throw J;
    const ne = J;
    throw (ne == null ? void 0 : ne.code) === 4001 ? new BrowserWalletRequestCancelledByUserError() : new OrditSDKError(ne.message);
  }
}
async function signPsbt$4(B, { finalize: L = !0, extractTx: J = !0 } = {}) {
  if (!isInstalled$3())
    throw new BrowserWalletNotInstalledError("Unisat not installed");
  if (J && !L)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  const ne = B.toHex();
  let oe = "";
  try {
    oe = await window.unisat.signPsbt(ne, {
      autoFinalized: L
    });
  } catch (Ce) {
    const rt = Ce;
    if ((rt == null ? void 0 : rt.code) === 4001)
      throw new BrowserWalletRequestCancelledByUserError();
  }
  if (!oe)
    throw new BrowserWalletSigningError("Failed to sign psbt hex using Unisat");
  const ce = src$4.Psbt.fromHex(oe);
  if (J)
    try {
      return {
        base64: null,
        hex: ce.extractTransaction().toHex()
      };
    } catch (Ce) {
      throw Ce instanceof Error && Ce.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
    }
  else
    return {
      base64: ce.toBase64(),
      hex: ce.toHex()
    };
}
async function signMessage$4(B, L = "ecdsa") {
  if (!isInstalled$3())
    throw new BrowserWalletNotInstalledError("Unisat not installed");
  let J = "";
  try {
    J = await window.unisat.signMessage(B, L);
  } catch (ne) {
    const oe = ne;
    if ((oe == null ? void 0 : oe.code) === 4001)
      throw new BrowserWalletRequestCancelledByUserError();
  }
  if (!J)
    throw new BrowserWalletSigningError("Failed to sign message using Unisat");
  return {
    base64: J,
    hex: Buffer$D.from(J, "base64").toString("hex")
  };
}
function isInstalled$2() {
  var B;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof ((B = window.XverseProviders) == null ? void 0 : B.BitcoinProvider) < "u";
}
async function getXverseWalletProvider() {
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return window.XverseProviders.BitcoinProvider;
}
async function getAddresses(B = "mainnet") {
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return satsConnectWalletGetAddresses(getXverseWalletProvider, B);
}
async function signPsbt$3(B, {
  finalize: L = !0,
  extractTx: J = !0,
  network: ne,
  inputsToSign: oe
} = { network: "mainnet", inputsToSign: [] }) {
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return satsConnectWalletSignPsbt(getXverseWalletProvider, B, {
    finalize: L,
    extractTx: J,
    network: ne,
    inputsToSign: oe
  });
}
async function signMessage$3(B, L, J = "mainnet") {
  if (!isInstalled$2())
    throw new BrowserWalletNotInstalledError("Selected wallet not installed");
  return satsConnectWalletSignMessage(
    getXverseWalletProvider,
    B,
    L,
    J
  );
}
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
async function waitForUnisatExtensionReady() {
  let B = 0;
  const L = 20;
  for (; B < L; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const J = await window.unisat.getAccounts();
        if (J && J.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((J) => {
      setTimeout(J, 100);
    });
  }
  return !1;
}
const LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20200%20200'%3e%3cradialGradient%20id='a12'%20cx='.66'%20fx='.66'%20cy='.3125'%20fy='.3125'%20gradientTransform='scale(1.5)'%3e%3cstop%20offset='0'%20stop-color='%23D9D5D2'%3e%3c/stop%3e%3cstop%20offset='.3'%20stop-color='%23D9D5D2'%20stop-opacity='.9'%3e%3c/stop%3e%3cstop%20offset='.6'%20stop-color='%23D9D5D2'%20stop-opacity='.6'%3e%3c/stop%3e%3cstop%20offset='.8'%20stop-color='%23D9D5D2'%20stop-opacity='.3'%3e%3c/stop%3e%3cstop%20offset='1'%20stop-color='%23D9D5D2'%20stop-opacity='0'%3e%3c/stop%3e%3c/radialGradient%3e%3ccircle%20transform-origin='center'%20fill='none'%20stroke='url(%23a12)'%20stroke-width='15'%20stroke-linecap='round'%20stroke-dasharray='200%201000'%20stroke-dashoffset='0'%20cx='100'%20cy='100'%20r='70'%3e%3canimateTransform%20type='rotate'%20attributeName='transform'%20calcMode='spline'%20dur='2'%20values='360;0'%20keyTimes='0;1'%20keySplines='0%200%201%201'%20repeatCount='indefinite'%3e%3c/animateTransform%3e%3c/circle%3e%3ccircle%20transform-origin='center'%20fill='none'%20opacity='.2'%20stroke='%23D9D5D2'%20stroke-width='15'%20stroke-linecap='round'%20cx='100'%20cy='100'%20r='70'%3e%3c/circle%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  subtitle: L,
  onConnect: J,
  icon: ne,
  setErrorMessage: oe,
  isDisabled: ce,
  isMobileDevice: Ce
}) {
  const { wallet: rt, address: at } = useWallie(), [{ connectedWallet: ht, connectedAddress: it }] = reactExports.useState({
    connectedWallet: rt,
    connectedAddress: at
  }), [lt, Et] = reactExports.useState(!1), wt = WALLET_TO_NAME[B], Rt = reactExports.useCallback(async () => {
    Et(!0), await Promise.race([
      J().then(() => Et(!1)).catch(() => Et(!1)),
      new Promise((Lt) => {
        setTimeout(() => Lt("timeout"), 5e3);
      })
    ]) === "timeout" ? oe(
      "No wallet pop-up? The extension is not responding. Try reloading your browser."
    ) : Et(!1);
  }, [J, oe]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      className: "wallie-w-full wallie-flex wallie-flex-row wallie-justify-between wallie-items-center wallie-text-ord-light-gray wallie-bg-ord-light-blue wallie-hover:bg-ord-light-blue-250 wallie-p-2 wallie-rounded-lg md:wallie-text-xl wallie-space-x-4 md:space-x-6 wallie-ease-in wallie-transition-all wallie-duration-100 wallie-ease-in-outscale-120",
      onClick: Rt,
      disabled: ce,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallie-flex wallie-flex-row wallie-space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallie-w-5 md:wallie-w-8", src: ne, alt: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-text-lg wallie-block wallie-font-medium", children: wt }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "wallie-text-sm wallie-font-medium",
              style: { display: Ce ? "block" : "none" },
              children: L
            }
          )
        ] }),
        ht === B && it.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-flex wallie-flex-row wallie-ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-text-sm wallie-font-medium wallie-pr-3", children: truncateMiddle(it.ordinals) }) }) : null,
        lt && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: 24,
            alt: `${wt} extension is loading`
          }
        )
      ]
    }
  );
}
const WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download"
  // their www subdomain doesn't work
};
function SelectWalletModal({
  isOpen: B,
  closeModal: L
}) {
  const {
    updateAddress: J,
    network: ne,
    updateWallet: oe,
    updatePublicKey: ce,
    updateFormat: Ce,
    wallet: rt,
    format: at,
    address: ht,
    publicKey: it,
    disconnectWallet: lt
  } = useWallie(), [Et, wt] = reactExports.useState(""), Rt = isMobileUserAgent(), Mt = reactExports.useCallback(
    (It, Ft) => {
      Ft instanceof BrowserWalletNotInstalledError && window.open(
        WALLET_CHROME_EXTENSION_URL[It],
        "_blank",
        "noopener,noreferrer"
      ), wt(Ft.message ?? Ft.toString()), console.error(`Error while connecting to ${It} wallet`, Ft), lt();
    },
    [lt]
  ), Lt = reactExports.useCallback(async () => {
    if (ne === "testnet") {
      const It = new Error(
        "Magic Eden wallet is not supported on testnet"
      );
      return Mt(Wallet.MAGICEDEN, It), !1;
    }
    try {
      wt("");
      const It = await getAddresses$2(ne);
      if (!It || It.length < 1)
        throw lt(), new Error("Magic Eden via Ordit returned no addresses.");
      const Ft = It.find(
        (Vt) => Vt.format === "segwit" || Vt.format === "p2sh-p2wpkh"
      );
      if (!Ft)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address."
        );
      const Jt = It.find(
        (Vt) => Vt.format === "taproot"
      );
      if (!Jt)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address."
        );
      return J({
        ordinals: Jt.address,
        payments: Ft.address
      }), ce({
        ordinals: Jt.publicKey,
        payments: Ft.publicKey
      }), oe(Wallet.MAGICEDEN), Ce({
        ordinals: Jt.format,
        payments: Ft.format
      }), L(), !0;
    } catch (It) {
      return Mt(Wallet.MAGICEDEN, It), !1;
    }
  }, [
    L,
    lt,
    ne,
    Mt,
    J,
    Ce,
    ce,
    oe
  ]), zt = reactExports.useCallback(
    async ({ readOnly: It } = {}) => {
      try {
        wt("");
        const Ft = await getAddresses$1(ne, It);
        if (!Ft || Ft.length < 1)
          throw lt(), new Error("Unisat via Ordit returned no addresses.");
        const Jt = Ft[0];
        return J({
          ordinals: Jt.address,
          payments: Jt.address
        }), ce({
          ordinals: Jt.publicKey,
          payments: Jt.publicKey
        }), oe(Wallet.UNISAT), Ce({
          ordinals: Jt.format,
          payments: Jt.format
        }), L(), !0;
      } catch (Ft) {
        return Mt(Wallet.UNISAT, Ft), !1;
      }
    },
    [
      L,
      lt,
      ne,
      Mt,
      J,
      Ce,
      ce,
      oe
    ]
  ), Ot = reactExports.useCallback(async () => {
    try {
      wt("");
      const It = await getAddresses(ne);
      if (!It || It.length < 1)
        throw lt(), new Error("Xverse via Ordit returned no addresses.");
      const Ft = It.find(
        (Vt) => Vt.format === "p2sh-p2wpkh" || Vt.format === "segwit"
      );
      if (!Ft)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address."
        );
      const Jt = It.find(
        (Vt) => Vt.format === "taproot"
      );
      if (!Jt)
        throw new Error("Xverse via Ordit did not return a Taproot address.");
      return J({
        ordinals: Jt.address,
        payments: Ft.address
      }), ce({
        ordinals: Jt.publicKey,
        payments: Ft.publicKey
      }), oe(Wallet.XVERSE), Ce({
        ordinals: Jt.format,
        payments: Ft.format
      }), L(), !0;
    } catch (It) {
      return Mt(Wallet.XVERSE, It), !1;
    }
  }, [
    L,
    lt,
    ne,
    Mt,
    J,
    Ce,
    ce,
    oe
  ]);
  return reactExports.useEffect(() => {
    if (rt !== Wallet.UNISAT)
      return;
    let It = !0, Ft = !1;
    const Jt = () => zt();
    return ht && it && at && (async () => {
      const yr = await waitForUnisatExtensionReady();
      if (It) {
        if (!yr) {
          lt();
          return;
        }
        Ft = await zt({ readOnly: !0 }), It && Ft && window.unisat.addListener("accountsChanged", Jt);
      }
    })(), () => {
      It = !1, Ft && window.unisat.removeListener("accountsChanged", Jt);
    };
  }, [
    rt,
    zt,
    lt,
    ht,
    it,
    at
  ]), /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: B, as: reactExports.Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "wallie-z-50 wallie-fixed wallie-inset-0 wallie-overflow-y-auto",
      onClose: L,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: reactExports.Fragment,
            enter: "wallie-ease-out wallie-duration-300",
            enterFrom: "wallie-opacity-0",
            enterTo: "wallie-opacity-100",
            leave: "wallie-ease-in wallie-duration-200",
            leaveFrom: "wallie-opacity-100",
            leaveTo: "wallie-opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-fixed wallie-inset-0 wallie-bg-black wallie-bg-opacity-90 md:wallie-bg-opacity-75 wallie-transition-opacity" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "wallie-fixed wallie-inset-0 wallie-z-10 wallie-overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-flex wallie-min-h-full wallie-w-full md:wallie-w-96 wallie-mx-auto wallie-items-end wallie-justify-center wallie-p-4 wallie-text-left sm:wallie-items-center sm:wallie-p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: reactExports.Fragment,
            enter: "wallie-ease-out wallie-duration-300",
            enterFrom: "wallie-opacity-0 wallie-scale-95",
            enterTo: "wallie-opacity-100 wallie-scale-100",
            leave: "wallie-ease-in wallie-duration-200",
            leaveFrom: "wallie-opacity-100 wallie-scale-100",
            leaveTo: "wallie-opacity-0 wallie-scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "wallie-relative wallie-bg-ord-blue-600 wallie-transform wallie-overflow-hidden wallie-rounded-lg wallie-p-8 wallie-transition-all wallie-w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "wallie-flex wallie-flex-row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  _t.Title,
                  {
                    as: "h3",
                    className: "wallie-text-[21px] wallie-font-medium wallie-leading-8 wallie--mt-1  wallie-text-ord-gray",
                    children: "Connect a wallet to continue"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: L,
                    className: "wallie-ml-auto",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: CloseModalIcon,
                        alt: "close modal",
                        className: "wallie-w-[19px] wallie-h-[19px]"
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallie-text-ord-light-blue-400 wallie-font-medium wallie-py-3", children: "Choose a wallet below to connect and continue" }),
              Et && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallie-text-ord-alert wallie-pb-4", children: Et }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "wallie-w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "wallie-w-full wallie-space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.XVERSE,
                    subtitle: "",
                    onConnect: Ot,
                    icon: XverseWalletIcon,
                    setErrorMessage: wt,
                    isMobileDevice: Rt
                  }
                ),
                !Rt && // TODO: remove this once unisat supported on mobile devices
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.UNISAT,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: zt,
                    icon: UnisatWalletIcon,
                    setErrorMessage: wt,
                    isDisabled: Rt,
                    isMobileDevice: Rt
                  }
                ),
                !Rt && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.MAGICEDEN,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: Lt,
                    icon: MagicEdenWalletIcon,
                    setErrorMessage: wt,
                    isDisabled: Rt,
                    isMobileDevice: Rt
                  }
                ) })
              ] }) })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  connectButton: B,
  connectButtonComponent: L,
  hideConnectButton: J,
  onViewProfile: ne,
  onChangeWalletClick: oe,
  onDisconnectWalletClick: ce
}) {
  const {
    address: Ce,
    disconnectWallet: rt,
    network: at,
    isModalOpen: ht,
    openModal: it,
    closeModal: lt
  } = useWallie(), Et = useHasMounted(), wt = () => J ? null : Ce != null && Ce.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: Ce.ordinals,
      network: at,
      onViewProfile: ne,
      onChangeWallet: () => {
        it(), oe == null || oe();
      },
      onDisconnectWallet: () => {
        rt(), ce == null || ce();
      }
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    PreConnectButton,
    {
      disabled: !Et,
      connectButton: B,
      connectButtonComponent: L,
      openModal: it
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    wt(),
    Et ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectWalletModal, { isOpen: ht, closeModal: lt }) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var L, J, ne, oe = Ot.prototype = { constructor: Ot, toString: null, valueOf: null }, ce = new Ot(1), Ce = 20, rt = 4, at = -7, ht = 21, it = -1e7, lt = 1e7, Et = !1, wt = 1, Rt = 0, Mt = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, Lt = "0123456789abcdefghijklmnopqrstuvwxyz", zt = !0;
  function Ot(jt, Ut) {
    var er, Ht, ct, dt, ot, ut, mt, gt, St = this;
    if (!(St instanceof Ot)) return new Ot(jt, Ut);
    if (Ut == null) {
      if (jt && jt._isBigNumber === !0) {
        St.s = jt.s, !jt.c || jt.e > lt ? St.c = St.e = null : jt.e < it ? St.c = [St.e = 0] : (St.e = jt.e, St.c = jt.c.slice());
        return;
      }
      if ((ut = typeof jt == "number") && jt * 0 == 0) {
        if (St.s = 1 / jt < 0 ? (jt = -jt, -1) : 1, jt === ~~jt) {
          for (dt = 0, ot = jt; ot >= 10; ot /= 10, dt++) ;
          dt > lt ? St.c = St.e = null : (St.e = dt, St.c = [jt]);
          return;
        }
        gt = String(jt);
      } else {
        if (!isNumeric.test(gt = String(jt))) return ne(St, gt, ut);
        St.s = gt.charCodeAt(0) == 45 ? (gt = gt.slice(1), -1) : 1;
      }
      (dt = gt.indexOf(".")) > -1 && (gt = gt.replace(".", "")), (ot = gt.search(/e/i)) > 0 ? (dt < 0 && (dt = ot), dt += +gt.slice(ot + 1), gt = gt.substring(0, ot)) : dt < 0 && (dt = gt.length);
    } else {
      if (intCheck(Ut, 2, Lt.length, "Base"), Ut == 10 && zt)
        return St = new Ot(jt), Vt(St, Ce + St.e + 1, rt);
      if (gt = String(jt), ut = typeof jt == "number") {
        if (jt * 0 != 0) return ne(St, gt, ut, Ut);
        if (St.s = 1 / jt < 0 ? (gt = gt.slice(1), -1) : 1, Ot.DEBUG && gt.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + jt);
      } else
        St.s = gt.charCodeAt(0) === 45 ? (gt = gt.slice(1), -1) : 1;
      for (er = Lt.slice(0, Ut), dt = ot = 0, mt = gt.length; ot < mt; ot++)
        if (er.indexOf(Ht = gt.charAt(ot)) < 0) {
          if (Ht == ".") {
            if (ot > dt) {
              dt = mt;
              continue;
            }
          } else if (!ct && (gt == gt.toUpperCase() && (gt = gt.toLowerCase()) || gt == gt.toLowerCase() && (gt = gt.toUpperCase()))) {
            ct = !0, ot = -1, dt = 0;
            continue;
          }
          return ne(St, String(jt), ut, Ut);
        }
      ut = !1, gt = J(gt, Ut, 10, St.s), (dt = gt.indexOf(".")) > -1 ? gt = gt.replace(".", "") : dt = gt.length;
    }
    for (ot = 0; gt.charCodeAt(ot) === 48; ot++) ;
    for (mt = gt.length; gt.charCodeAt(--mt) === 48; ) ;
    if (gt = gt.slice(ot, ++mt)) {
      if (mt -= ot, ut && Ot.DEBUG && mt > 15 && (jt > MAX_SAFE_INTEGER || jt !== mathfloor(jt)))
        throw Error(tooManyDigits + St.s * jt);
      if ((dt = dt - ot - 1) > lt)
        St.c = St.e = null;
      else if (dt < it)
        St.c = [St.e = 0];
      else {
        if (St.e = dt, St.c = [], ot = (dt + 1) % LOG_BASE, dt < 0 && (ot += LOG_BASE), ot < mt) {
          for (ot && St.c.push(+gt.slice(0, ot)), mt -= LOG_BASE; ot < mt; )
            St.c.push(+gt.slice(ot, ot += LOG_BASE));
          ot = LOG_BASE - (gt = gt.slice(ot)).length;
        } else
          ot -= mt;
        for (; ot--; gt += "0") ;
        St.c.push(+gt);
      }
    } else
      St.c = [St.e = 0];
  }
  Ot.clone = clone, Ot.ROUND_UP = 0, Ot.ROUND_DOWN = 1, Ot.ROUND_CEIL = 2, Ot.ROUND_FLOOR = 3, Ot.ROUND_HALF_UP = 4, Ot.ROUND_HALF_DOWN = 5, Ot.ROUND_HALF_EVEN = 6, Ot.ROUND_HALF_CEIL = 7, Ot.ROUND_HALF_FLOOR = 8, Ot.EUCLID = 9, Ot.config = Ot.set = function(jt) {
    var Ut, er;
    if (jt != null)
      if (typeof jt == "object") {
        if (jt.hasOwnProperty(Ut = "DECIMAL_PLACES") && (er = jt[Ut], intCheck(er, 0, MAX, Ut), Ce = er), jt.hasOwnProperty(Ut = "ROUNDING_MODE") && (er = jt[Ut], intCheck(er, 0, 8, Ut), rt = er), jt.hasOwnProperty(Ut = "EXPONENTIAL_AT") && (er = jt[Ut], er && er.pop ? (intCheck(er[0], -MAX, 0, Ut), intCheck(er[1], 0, MAX, Ut), at = er[0], ht = er[1]) : (intCheck(er, -MAX, MAX, Ut), at = -(ht = er < 0 ? -er : er))), jt.hasOwnProperty(Ut = "RANGE"))
          if (er = jt[Ut], er && er.pop)
            intCheck(er[0], -MAX, -1, Ut), intCheck(er[1], 1, MAX, Ut), it = er[0], lt = er[1];
          else if (intCheck(er, -MAX, MAX, Ut), er)
            it = -(lt = er < 0 ? -er : er);
          else
            throw Error(bignumberError + Ut + " cannot be zero: " + er);
        if (jt.hasOwnProperty(Ut = "CRYPTO"))
          if (er = jt[Ut], er === !!er)
            if (er)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Et = er;
              else
                throw Et = !er, Error(bignumberError + "crypto unavailable");
            else
              Et = er;
          else
            throw Error(bignumberError + Ut + " not true or false: " + er);
        if (jt.hasOwnProperty(Ut = "MODULO_MODE") && (er = jt[Ut], intCheck(er, 0, 9, Ut), wt = er), jt.hasOwnProperty(Ut = "POW_PRECISION") && (er = jt[Ut], intCheck(er, 0, MAX, Ut), Rt = er), jt.hasOwnProperty(Ut = "FORMAT"))
          if (er = jt[Ut], typeof er == "object") Mt = er;
          else throw Error(bignumberError + Ut + " not an object: " + er);
        if (jt.hasOwnProperty(Ut = "ALPHABET"))
          if (er = jt[Ut], typeof er == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(er))
            zt = er.slice(0, 10) == "0123456789", Lt = er;
          else
            throw Error(bignumberError + Ut + " invalid: " + er);
      } else
        throw Error(bignumberError + "Object expected: " + jt);
    return {
      DECIMAL_PLACES: Ce,
      ROUNDING_MODE: rt,
      EXPONENTIAL_AT: [at, ht],
      RANGE: [it, lt],
      CRYPTO: Et,
      MODULO_MODE: wt,
      POW_PRECISION: Rt,
      FORMAT: Mt,
      ALPHABET: Lt
    };
  }, Ot.isBigNumber = function(jt) {
    if (!jt || jt._isBigNumber !== !0) return !1;
    if (!Ot.DEBUG) return !0;
    var Ut, er, Ht = jt.c, ct = jt.e, dt = jt.s;
    e: if ({}.toString.call(Ht) == "[object Array]") {
      if ((dt === 1 || dt === -1) && ct >= -MAX && ct <= MAX && ct === mathfloor(ct)) {
        if (Ht[0] === 0) {
          if (ct === 0 && Ht.length === 1) return !0;
          break e;
        }
        if (Ut = (ct + 1) % LOG_BASE, Ut < 1 && (Ut += LOG_BASE), String(Ht[0]).length == Ut) {
          for (Ut = 0; Ut < Ht.length; Ut++)
            if (er = Ht[Ut], er < 0 || er >= BASE || er !== mathfloor(er)) break e;
          if (er !== 0) return !0;
        }
      }
    } else if (Ht === null && ct === null && (dt === null || dt === 1 || dt === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + jt);
  }, Ot.maximum = Ot.max = function() {
    return Ft(arguments, -1);
  }, Ot.minimum = Ot.min = function() {
    return Ft(arguments, 1);
  }, Ot.random = function() {
    var jt = 9007199254740992, Ut = Math.random() * jt & 2097151 ? function() {
      return mathfloor(Math.random() * jt);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(er) {
      var Ht, ct, dt, ot, ut, mt = 0, gt = [], St = new Ot(ce);
      if (er == null ? er = Ce : intCheck(er, 0, MAX), ot = mathceil(er / LOG_BASE), Et)
        if (crypto.getRandomValues) {
          for (Ht = crypto.getRandomValues(new Uint32Array(ot *= 2)); mt < ot; )
            ut = Ht[mt] * 131072 + (Ht[mt + 1] >>> 11), ut >= 9e15 ? (ct = crypto.getRandomValues(new Uint32Array(2)), Ht[mt] = ct[0], Ht[mt + 1] = ct[1]) : (gt.push(ut % 1e14), mt += 2);
          mt = ot / 2;
        } else if (crypto.randomBytes) {
          for (Ht = crypto.randomBytes(ot *= 7); mt < ot; )
            ut = (Ht[mt] & 31) * 281474976710656 + Ht[mt + 1] * 1099511627776 + Ht[mt + 2] * 4294967296 + Ht[mt + 3] * 16777216 + (Ht[mt + 4] << 16) + (Ht[mt + 5] << 8) + Ht[mt + 6], ut >= 9e15 ? crypto.randomBytes(7).copy(Ht, mt) : (gt.push(ut % 1e14), mt += 7);
          mt = ot / 7;
        } else
          throw Et = !1, Error(bignumberError + "crypto unavailable");
      if (!Et)
        for (; mt < ot; )
          ut = Ut(), ut < 9e15 && (gt[mt++] = ut % 1e14);
      for (ot = gt[--mt], er %= LOG_BASE, ot && er && (ut = POWS_TEN[LOG_BASE - er], gt[mt] = mathfloor(ot / ut) * ut); gt[mt] === 0; gt.pop(), mt--) ;
      if (mt < 0)
        gt = [dt = 0];
      else {
        for (dt = -1; gt[0] === 0; gt.splice(0, 1), dt -= LOG_BASE) ;
        for (mt = 1, ut = gt[0]; ut >= 10; ut /= 10, mt++) ;
        mt < LOG_BASE && (dt -= LOG_BASE - mt);
      }
      return St.e = dt, St.c = gt, St;
    };
  }(), Ot.sum = function() {
    for (var jt = 1, Ut = arguments, er = new Ot(Ut[0]); jt < Ut.length; ) er = er.plus(Ut[jt++]);
    return er;
  }, J = /* @__PURE__ */ function() {
    var jt = "0123456789";
    function Ut(er, Ht, ct, dt) {
      for (var ot, ut = [0], mt, gt = 0, St = er.length; gt < St; ) {
        for (mt = ut.length; mt--; ut[mt] *= Ht) ;
        for (ut[0] += dt.indexOf(er.charAt(gt++)), ot = 0; ot < ut.length; ot++)
          ut[ot] > ct - 1 && (ut[ot + 1] == null && (ut[ot + 1] = 0), ut[ot + 1] += ut[ot] / ct | 0, ut[ot] %= ct);
      }
      return ut.reverse();
    }
    return function(er, Ht, ct, dt, ot) {
      var ut, mt, gt, St, xt, vt, $t, yt, Bt = er.indexOf("."), rr = Ce, dr = rt;
      for (Bt >= 0 && (St = Rt, Rt = 0, er = er.replace(".", ""), yt = new Ot(Ht), vt = yt.pow(er.length - Bt), Rt = St, yt.c = Ut(
        toFixedPoint(coeffToString(vt.c), vt.e, "0"),
        10,
        ct,
        jt
      ), yt.e = yt.c.length), $t = Ut(er, Ht, ct, ot ? (ut = Lt, jt) : (ut = jt, Lt)), gt = St = $t.length; $t[--St] == 0; $t.pop()) ;
      if (!$t[0]) return ut.charAt(0);
      if (Bt < 0 ? --gt : (vt.c = $t, vt.e = gt, vt.s = dt, vt = L(vt, yt, rr, dr, ct), $t = vt.c, xt = vt.r, gt = vt.e), mt = gt + rr + 1, Bt = $t[mt], St = ct / 2, xt = xt || mt < 0 || $t[mt + 1] != null, xt = dr < 4 ? (Bt != null || xt) && (dr == 0 || dr == (vt.s < 0 ? 3 : 2)) : Bt > St || Bt == St && (dr == 4 || xt || dr == 6 && $t[mt - 1] & 1 || dr == (vt.s < 0 ? 8 : 7)), mt < 1 || !$t[0])
        er = xt ? toFixedPoint(ut.charAt(1), -rr, ut.charAt(0)) : ut.charAt(0);
      else {
        if ($t.length = mt, xt)
          for (--ct; ++$t[--mt] > ct; )
            $t[mt] = 0, mt || (++gt, $t = [1].concat($t));
        for (St = $t.length; !$t[--St]; ) ;
        for (Bt = 0, er = ""; Bt <= St; er += ut.charAt($t[Bt++])) ;
        er = toFixedPoint(er, gt, ut.charAt(0));
      }
      return er;
    };
  }(), L = /* @__PURE__ */ function() {
    function jt(Ht, ct, dt) {
      var ot, ut, mt, gt, St = 0, xt = Ht.length, vt = ct % SQRT_BASE, $t = ct / SQRT_BASE | 0;
      for (Ht = Ht.slice(); xt--; )
        mt = Ht[xt] % SQRT_BASE, gt = Ht[xt] / SQRT_BASE | 0, ot = $t * mt + gt * vt, ut = vt * mt + ot % SQRT_BASE * SQRT_BASE + St, St = (ut / dt | 0) + (ot / SQRT_BASE | 0) + $t * gt, Ht[xt] = ut % dt;
      return St && (Ht = [St].concat(Ht)), Ht;
    }
    function Ut(Ht, ct, dt, ot) {
      var ut, mt;
      if (dt != ot)
        mt = dt > ot ? 1 : -1;
      else
        for (ut = mt = 0; ut < dt; ut++)
          if (Ht[ut] != ct[ut]) {
            mt = Ht[ut] > ct[ut] ? 1 : -1;
            break;
          }
      return mt;
    }
    function er(Ht, ct, dt, ot) {
      for (var ut = 0; dt--; )
        Ht[dt] -= ut, ut = Ht[dt] < ct[dt] ? 1 : 0, Ht[dt] = ut * ot + Ht[dt] - ct[dt];
      for (; !Ht[0] && Ht.length > 1; Ht.splice(0, 1)) ;
    }
    return function(Ht, ct, dt, ot, ut) {
      var mt, gt, St, xt, vt, $t, yt, Bt, rr, dr, tr, Dt, Wt, or, _r, Xt, Qt, br = Ht.s == ct.s ? 1 : -1, Dr = Ht.c, Vr = ct.c;
      if (!Dr || !Dr[0] || !Vr || !Vr[0])
        return new Ot(
          // Return NaN if either NaN, or both Infinity or 0.
          !Ht.s || !ct.s || (Dr ? Vr && Dr[0] == Vr[0] : !Vr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            Dr && Dr[0] == 0 || !Vr ? br * 0 : br / 0
          )
        );
      for (Bt = new Ot(br), rr = Bt.c = [], gt = Ht.e - ct.e, br = dt + gt + 1, ut || (ut = BASE, gt = bitFloor(Ht.e / LOG_BASE) - bitFloor(ct.e / LOG_BASE), br = br / LOG_BASE | 0), St = 0; Vr[St] == (Dr[St] || 0); St++) ;
      if (Vr[St] > (Dr[St] || 0) && gt--, br < 0)
        rr.push(1), xt = !0;
      else {
        for (or = Dr.length, Xt = Vr.length, St = 0, br += 2, vt = mathfloor(ut / (Vr[0] + 1)), vt > 1 && (Vr = jt(Vr, vt, ut), Dr = jt(Dr, vt, ut), Xt = Vr.length, or = Dr.length), Wt = Xt, dr = Dr.slice(0, Xt), tr = dr.length; tr < Xt; dr[tr++] = 0) ;
        Qt = Vr.slice(), Qt = [0].concat(Qt), _r = Vr[0], Vr[1] >= ut / 2 && _r++;
        do {
          if (vt = 0, mt = Ut(Vr, dr, Xt, tr), mt < 0) {
            if (Dt = dr[0], Xt != tr && (Dt = Dt * ut + (dr[1] || 0)), vt = mathfloor(Dt / _r), vt > 1)
              for (vt >= ut && (vt = ut - 1), $t = jt(Vr, vt, ut), yt = $t.length, tr = dr.length; Ut($t, dr, yt, tr) == 1; )
                vt--, er($t, Xt < yt ? Qt : Vr, yt, ut), yt = $t.length, mt = 1;
            else
              vt == 0 && (mt = vt = 1), $t = Vr.slice(), yt = $t.length;
            if (yt < tr && ($t = [0].concat($t)), er(dr, $t, tr, ut), tr = dr.length, mt == -1)
              for (; Ut(Vr, dr, Xt, tr) < 1; )
                vt++, er(dr, Xt < tr ? Qt : Vr, tr, ut), tr = dr.length;
          } else mt === 0 && (vt++, dr = [0]);
          rr[St++] = vt, dr[0] ? dr[tr++] = Dr[Wt] || 0 : (dr = [Dr[Wt]], tr = 1);
        } while ((Wt++ < or || dr[0] != null) && br--);
        xt = dr[0] != null, rr[0] || rr.splice(0, 1);
      }
      if (ut == BASE) {
        for (St = 1, br = rr[0]; br >= 10; br /= 10, St++) ;
        Vt(Bt, dt + (Bt.e = St + gt * LOG_BASE - 1) + 1, ot, xt);
      } else
        Bt.e = gt, Bt.r = +xt;
      return Bt;
    };
  }();
  function It(jt, Ut, er, Ht) {
    var ct, dt, ot, ut, mt;
    if (er == null ? er = rt : intCheck(er, 0, 8), !jt.c) return jt.toString();
    if (ct = jt.c[0], ot = jt.e, Ut == null)
      mt = coeffToString(jt.c), mt = Ht == 1 || Ht == 2 && (ot <= at || ot >= ht) ? toExponential(mt, ot) : toFixedPoint(mt, ot, "0");
    else if (jt = Vt(new Ot(jt), Ut, er), dt = jt.e, mt = coeffToString(jt.c), ut = mt.length, Ht == 1 || Ht == 2 && (Ut <= dt || dt <= at)) {
      for (; ut < Ut; mt += "0", ut++) ;
      mt = toExponential(mt, dt);
    } else if (Ut -= ot, mt = toFixedPoint(mt, dt, "0"), dt + 1 > ut) {
      if (--Ut > 0) for (mt += "."; Ut--; mt += "0") ;
    } else if (Ut += dt - ut, Ut > 0)
      for (dt + 1 == ut && (mt += "."); Ut--; mt += "0") ;
    return jt.s < 0 && ct ? "-" + mt : mt;
  }
  function Ft(jt, Ut) {
    for (var er, Ht, ct = 1, dt = new Ot(jt[0]); ct < jt.length; ct++)
      Ht = new Ot(jt[ct]), (!Ht.s || (er = compare(dt, Ht)) === Ut || er === 0 && dt.s === Ut) && (dt = Ht);
    return dt;
  }
  function Jt(jt, Ut, er) {
    for (var Ht = 1, ct = Ut.length; !Ut[--ct]; Ut.pop()) ;
    for (ct = Ut[0]; ct >= 10; ct /= 10, Ht++) ;
    return (er = Ht + er * LOG_BASE - 1) > lt ? jt.c = jt.e = null : er < it ? jt.c = [jt.e = 0] : (jt.e = er, jt.c = Ut), jt;
  }
  ne = /* @__PURE__ */ function() {
    var jt = /^(-?)0([xbo])(?=\w[\w.]*$)/i, Ut = /^([^.]+)\.$/, er = /^\.([^.]+)$/, Ht = /^-?(Infinity|NaN)$/, ct = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(dt, ot, ut, mt) {
      var gt, St = ut ? ot : ot.replace(ct, "");
      if (Ht.test(St))
        dt.s = isNaN(St) ? null : St < 0 ? -1 : 1;
      else {
        if (!ut && (St = St.replace(jt, function(xt, vt, $t) {
          return gt = ($t = $t.toLowerCase()) == "x" ? 16 : $t == "b" ? 2 : 8, !mt || mt == gt ? vt : xt;
        }), mt && (gt = mt, St = St.replace(Ut, "$1").replace(er, "0.$1")), ot != St))
          return new Ot(St, gt);
        if (Ot.DEBUG)
          throw Error(bignumberError + "Not a" + (mt ? " base " + mt : "") + " number: " + ot);
        dt.s = null;
      }
      dt.c = dt.e = null;
    };
  }();
  function Vt(jt, Ut, er, Ht) {
    var ct, dt, ot, ut, mt, gt, St, xt = jt.c, vt = POWS_TEN;
    if (xt) {
      e: {
        for (ct = 1, ut = xt[0]; ut >= 10; ut /= 10, ct++) ;
        if (dt = Ut - ct, dt < 0)
          dt += LOG_BASE, ot = Ut, mt = xt[gt = 0], St = mathfloor(mt / vt[ct - ot - 1] % 10);
        else if (gt = mathceil((dt + 1) / LOG_BASE), gt >= xt.length)
          if (Ht) {
            for (; xt.length <= gt; xt.push(0)) ;
            mt = St = 0, ct = 1, dt %= LOG_BASE, ot = dt - LOG_BASE + 1;
          } else
            break e;
        else {
          for (mt = ut = xt[gt], ct = 1; ut >= 10; ut /= 10, ct++) ;
          dt %= LOG_BASE, ot = dt - LOG_BASE + ct, St = ot < 0 ? 0 : mathfloor(mt / vt[ct - ot - 1] % 10);
        }
        if (Ht = Ht || Ut < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xt[gt + 1] != null || (ot < 0 ? mt : mt % vt[ct - ot - 1]), Ht = er < 4 ? (St || Ht) && (er == 0 || er == (jt.s < 0 ? 3 : 2)) : St > 5 || St == 5 && (er == 4 || Ht || er == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (dt > 0 ? ot > 0 ? mt / vt[ct - ot] : 0 : xt[gt - 1]) % 10 & 1 || er == (jt.s < 0 ? 8 : 7)), Ut < 1 || !xt[0])
          return xt.length = 0, Ht ? (Ut -= jt.e + 1, xt[0] = vt[(LOG_BASE - Ut % LOG_BASE) % LOG_BASE], jt.e = -Ut || 0) : xt[0] = jt.e = 0, jt;
        if (dt == 0 ? (xt.length = gt, ut = 1, gt--) : (xt.length = gt + 1, ut = vt[LOG_BASE - dt], xt[gt] = ot > 0 ? mathfloor(mt / vt[ct - ot] % vt[ot]) * ut : 0), Ht)
          for (; ; )
            if (gt == 0) {
              for (dt = 1, ot = xt[0]; ot >= 10; ot /= 10, dt++) ;
              for (ot = xt[0] += ut, ut = 1; ot >= 10; ot /= 10, ut++) ;
              dt != ut && (jt.e++, xt[0] == BASE && (xt[0] = 1));
              break;
            } else {
              if (xt[gt] += ut, xt[gt] != BASE) break;
              xt[gt--] = 0, ut = 1;
            }
        for (dt = xt.length; xt[--dt] === 0; xt.pop()) ;
      }
      jt.e > lt ? jt.c = jt.e = null : jt.e < it && (jt.c = [jt.e = 0]);
    }
    return jt;
  }
  function yr(jt) {
    var Ut, er = jt.e;
    return er === null ? jt.toString() : (Ut = coeffToString(jt.c), Ut = er <= at || er >= ht ? toExponential(Ut, er) : toFixedPoint(Ut, er, "0"), jt.s < 0 ? "-" + Ut : Ut);
  }
  return oe.absoluteValue = oe.abs = function() {
    var jt = new Ot(this);
    return jt.s < 0 && (jt.s = 1), jt;
  }, oe.comparedTo = function(jt, Ut) {
    return compare(this, new Ot(jt, Ut));
  }, oe.decimalPlaces = oe.dp = function(jt, Ut) {
    var er, Ht, ct, dt = this;
    if (jt != null)
      return intCheck(jt, 0, MAX), Ut == null ? Ut = rt : intCheck(Ut, 0, 8), Vt(new Ot(dt), jt + dt.e + 1, Ut);
    if (!(er = dt.c)) return null;
    if (Ht = ((ct = er.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, ct = er[ct]) for (; ct % 10 == 0; ct /= 10, Ht--) ;
    return Ht < 0 && (Ht = 0), Ht;
  }, oe.dividedBy = oe.div = function(jt, Ut) {
    return L(this, new Ot(jt, Ut), Ce, rt);
  }, oe.dividedToIntegerBy = oe.idiv = function(jt, Ut) {
    return L(this, new Ot(jt, Ut), 0, 1);
  }, oe.exponentiatedBy = oe.pow = function(jt, Ut) {
    var er, Ht, ct, dt, ot, ut, mt, gt, St, xt = this;
    if (jt = new Ot(jt), jt.c && !jt.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + yr(jt));
    if (Ut != null && (Ut = new Ot(Ut)), ut = jt.e > 14, !xt.c || !xt.c[0] || xt.c[0] == 1 && !xt.e && xt.c.length == 1 || !jt.c || !jt.c[0])
      return St = new Ot(Math.pow(+yr(xt), ut ? jt.s * (2 - isOdd(jt)) : +yr(jt))), Ut ? St.mod(Ut) : St;
    if (mt = jt.s < 0, Ut) {
      if (Ut.c ? !Ut.c[0] : !Ut.s) return new Ot(NaN);
      Ht = !mt && xt.isInteger() && Ut.isInteger(), Ht && (xt = xt.mod(Ut));
    } else {
      if (jt.e > 9 && (xt.e > 0 || xt.e < -1 || (xt.e == 0 ? xt.c[0] > 1 || ut && xt.c[1] >= 24e7 : xt.c[0] < 8e13 || ut && xt.c[0] <= 9999975e7)))
        return dt = xt.s < 0 && isOdd(jt) ? -0 : 0, xt.e > -1 && (dt = 1 / dt), new Ot(mt ? 1 / dt : dt);
      Rt && (dt = mathceil(Rt / LOG_BASE + 2));
    }
    for (ut ? (er = new Ot(0.5), mt && (jt.s = 1), gt = isOdd(jt)) : (ct = Math.abs(+yr(jt)), gt = ct % 2), St = new Ot(ce); ; ) {
      if (gt) {
        if (St = St.times(xt), !St.c) break;
        dt ? St.c.length > dt && (St.c.length = dt) : Ht && (St = St.mod(Ut));
      }
      if (ct) {
        if (ct = mathfloor(ct / 2), ct === 0) break;
        gt = ct % 2;
      } else if (jt = jt.times(er), Vt(jt, jt.e + 1, 1), jt.e > 14)
        gt = isOdd(jt);
      else {
        if (ct = +yr(jt), ct === 0) break;
        gt = ct % 2;
      }
      xt = xt.times(xt), dt ? xt.c && xt.c.length > dt && (xt.c.length = dt) : Ht && (xt = xt.mod(Ut));
    }
    return Ht ? St : (mt && (St = ce.div(St)), Ut ? St.mod(Ut) : dt ? Vt(St, Rt, rt, ot) : St);
  }, oe.integerValue = function(jt) {
    var Ut = new Ot(this);
    return jt == null ? jt = rt : intCheck(jt, 0, 8), Vt(Ut, Ut.e + 1, jt);
  }, oe.isEqualTo = oe.eq = function(jt, Ut) {
    return compare(this, new Ot(jt, Ut)) === 0;
  }, oe.isFinite = function() {
    return !!this.c;
  }, oe.isGreaterThan = oe.gt = function(jt, Ut) {
    return compare(this, new Ot(jt, Ut)) > 0;
  }, oe.isGreaterThanOrEqualTo = oe.gte = function(jt, Ut) {
    return (Ut = compare(this, new Ot(jt, Ut))) === 1 || Ut === 0;
  }, oe.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, oe.isLessThan = oe.lt = function(jt, Ut) {
    return compare(this, new Ot(jt, Ut)) < 0;
  }, oe.isLessThanOrEqualTo = oe.lte = function(jt, Ut) {
    return (Ut = compare(this, new Ot(jt, Ut))) === -1 || Ut === 0;
  }, oe.isNaN = function() {
    return !this.s;
  }, oe.isNegative = function() {
    return this.s < 0;
  }, oe.isPositive = function() {
    return this.s > 0;
  }, oe.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, oe.minus = function(jt, Ut) {
    var er, Ht, ct, dt, ot = this, ut = ot.s;
    if (jt = new Ot(jt, Ut), Ut = jt.s, !ut || !Ut) return new Ot(NaN);
    if (ut != Ut)
      return jt.s = -Ut, ot.plus(jt);
    var mt = ot.e / LOG_BASE, gt = jt.e / LOG_BASE, St = ot.c, xt = jt.c;
    if (!mt || !gt) {
      if (!St || !xt) return St ? (jt.s = -Ut, jt) : new Ot(xt ? ot : NaN);
      if (!St[0] || !xt[0])
        return xt[0] ? (jt.s = -Ut, jt) : new Ot(St[0] ? ot : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          rt == 3 ? -0 : 0
        ));
    }
    if (mt = bitFloor(mt), gt = bitFloor(gt), St = St.slice(), ut = mt - gt) {
      for ((dt = ut < 0) ? (ut = -ut, ct = St) : (gt = mt, ct = xt), ct.reverse(), Ut = ut; Ut--; ct.push(0)) ;
      ct.reverse();
    } else
      for (Ht = (dt = (ut = St.length) < (Ut = xt.length)) ? ut : Ut, ut = Ut = 0; Ut < Ht; Ut++)
        if (St[Ut] != xt[Ut]) {
          dt = St[Ut] < xt[Ut];
          break;
        }
    if (dt && (ct = St, St = xt, xt = ct, jt.s = -jt.s), Ut = (Ht = xt.length) - (er = St.length), Ut > 0) for (; Ut--; St[er++] = 0) ;
    for (Ut = BASE - 1; Ht > ut; ) {
      if (St[--Ht] < xt[Ht]) {
        for (er = Ht; er && !St[--er]; St[er] = Ut) ;
        --St[er], St[Ht] += BASE;
      }
      St[Ht] -= xt[Ht];
    }
    for (; St[0] == 0; St.splice(0, 1), --gt) ;
    return St[0] ? Jt(jt, St, gt) : (jt.s = rt == 3 ? -1 : 1, jt.c = [jt.e = 0], jt);
  }, oe.modulo = oe.mod = function(jt, Ut) {
    var er, Ht, ct = this;
    return jt = new Ot(jt, Ut), !ct.c || !jt.s || jt.c && !jt.c[0] ? new Ot(NaN) : !jt.c || ct.c && !ct.c[0] ? new Ot(ct) : (wt == 9 ? (Ht = jt.s, jt.s = 1, er = L(ct, jt, 0, 3), jt.s = Ht, er.s *= Ht) : er = L(ct, jt, 0, wt), jt = ct.minus(er.times(jt)), !jt.c[0] && wt == 1 && (jt.s = ct.s), jt);
  }, oe.multipliedBy = oe.times = function(jt, Ut) {
    var er, Ht, ct, dt, ot, ut, mt, gt, St, xt, vt, $t, yt, Bt, rr, dr = this, tr = dr.c, Dt = (jt = new Ot(jt, Ut)).c;
    if (!tr || !Dt || !tr[0] || !Dt[0])
      return !dr.s || !jt.s || tr && !tr[0] && !Dt || Dt && !Dt[0] && !tr ? jt.c = jt.e = jt.s = null : (jt.s *= dr.s, !tr || !Dt ? jt.c = jt.e = null : (jt.c = [0], jt.e = 0)), jt;
    for (Ht = bitFloor(dr.e / LOG_BASE) + bitFloor(jt.e / LOG_BASE), jt.s *= dr.s, mt = tr.length, xt = Dt.length, mt < xt && (yt = tr, tr = Dt, Dt = yt, ct = mt, mt = xt, xt = ct), ct = mt + xt, yt = []; ct--; yt.push(0)) ;
    for (Bt = BASE, rr = SQRT_BASE, ct = xt; --ct >= 0; ) {
      for (er = 0, vt = Dt[ct] % rr, $t = Dt[ct] / rr | 0, ot = mt, dt = ct + ot; dt > ct; )
        gt = tr[--ot] % rr, St = tr[ot] / rr | 0, ut = $t * gt + St * vt, gt = vt * gt + ut % rr * rr + yt[dt] + er, er = (gt / Bt | 0) + (ut / rr | 0) + $t * St, yt[dt--] = gt % Bt;
      yt[dt] = er;
    }
    return er ? ++Ht : yt.splice(0, 1), Jt(jt, yt, Ht);
  }, oe.negated = function() {
    var jt = new Ot(this);
    return jt.s = -jt.s || null, jt;
  }, oe.plus = function(jt, Ut) {
    var er, Ht = this, ct = Ht.s;
    if (jt = new Ot(jt, Ut), Ut = jt.s, !ct || !Ut) return new Ot(NaN);
    if (ct != Ut)
      return jt.s = -Ut, Ht.minus(jt);
    var dt = Ht.e / LOG_BASE, ot = jt.e / LOG_BASE, ut = Ht.c, mt = jt.c;
    if (!dt || !ot) {
      if (!ut || !mt) return new Ot(ct / 0);
      if (!ut[0] || !mt[0]) return mt[0] ? jt : new Ot(ut[0] ? Ht : ct * 0);
    }
    if (dt = bitFloor(dt), ot = bitFloor(ot), ut = ut.slice(), ct = dt - ot) {
      for (ct > 0 ? (ot = dt, er = mt) : (ct = -ct, er = ut), er.reverse(); ct--; er.push(0)) ;
      er.reverse();
    }
    for (ct = ut.length, Ut = mt.length, ct - Ut < 0 && (er = mt, mt = ut, ut = er, Ut = ct), ct = 0; Ut; )
      ct = (ut[--Ut] = ut[Ut] + mt[Ut] + ct) / BASE | 0, ut[Ut] = BASE === ut[Ut] ? 0 : ut[Ut] % BASE;
    return ct && (ut = [ct].concat(ut), ++ot), Jt(jt, ut, ot);
  }, oe.precision = oe.sd = function(jt, Ut) {
    var er, Ht, ct, dt = this;
    if (jt != null && jt !== !!jt)
      return intCheck(jt, 1, MAX), Ut == null ? Ut = rt : intCheck(Ut, 0, 8), Vt(new Ot(dt), jt, Ut);
    if (!(er = dt.c)) return null;
    if (ct = er.length - 1, Ht = ct * LOG_BASE + 1, ct = er[ct]) {
      for (; ct % 10 == 0; ct /= 10, Ht--) ;
      for (ct = er[0]; ct >= 10; ct /= 10, Ht++) ;
    }
    return jt && dt.e + 1 > Ht && (Ht = dt.e + 1), Ht;
  }, oe.shiftedBy = function(jt) {
    return intCheck(jt, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER), this.times("1e" + jt);
  }, oe.squareRoot = oe.sqrt = function() {
    var jt, Ut, er, Ht, ct, dt = this, ot = dt.c, ut = dt.s, mt = dt.e, gt = Ce + 4, St = new Ot("0.5");
    if (ut !== 1 || !ot || !ot[0])
      return new Ot(!ut || ut < 0 && (!ot || ot[0]) ? NaN : ot ? dt : 1 / 0);
    if (ut = Math.sqrt(+yr(dt)), ut == 0 || ut == 1 / 0 ? (Ut = coeffToString(ot), (Ut.length + mt) % 2 == 0 && (Ut += "0"), ut = Math.sqrt(+Ut), mt = bitFloor((mt + 1) / 2) - (mt < 0 || mt % 2), ut == 1 / 0 ? Ut = "5e" + mt : (Ut = ut.toExponential(), Ut = Ut.slice(0, Ut.indexOf("e") + 1) + mt), er = new Ot(Ut)) : er = new Ot(ut + ""), er.c[0]) {
      for (mt = er.e, ut = mt + gt, ut < 3 && (ut = 0); ; )
        if (ct = er, er = St.times(ct.plus(L(dt, ct, gt, 1))), coeffToString(ct.c).slice(0, ut) === (Ut = coeffToString(er.c)).slice(0, ut))
          if (er.e < mt && --ut, Ut = Ut.slice(ut - 3, ut + 1), Ut == "9999" || !Ht && Ut == "4999") {
            if (!Ht && (Vt(ct, ct.e + Ce + 2, 0), ct.times(ct).eq(dt))) {
              er = ct;
              break;
            }
            gt += 4, ut += 4, Ht = 1;
          } else {
            (!+Ut || !+Ut.slice(1) && Ut.charAt(0) == "5") && (Vt(er, er.e + Ce + 2, 1), jt = !er.times(er).eq(dt));
            break;
          }
    }
    return Vt(er, er.e + Ce + 1, rt, jt);
  }, oe.toExponential = function(jt, Ut) {
    return jt != null && (intCheck(jt, 0, MAX), jt++), It(this, jt, Ut, 1);
  }, oe.toFixed = function(jt, Ut) {
    return jt != null && (intCheck(jt, 0, MAX), jt = jt + this.e + 1), It(this, jt, Ut);
  }, oe.toFormat = function(jt, Ut, er) {
    var Ht, ct = this;
    if (er == null)
      jt != null && Ut && typeof Ut == "object" ? (er = Ut, Ut = null) : jt && typeof jt == "object" ? (er = jt, jt = Ut = null) : er = Mt;
    else if (typeof er != "object")
      throw Error(bignumberError + "Argument not an object: " + er);
    if (Ht = ct.toFixed(jt, Ut), ct.c) {
      var dt, ot = Ht.split("."), ut = +er.groupSize, mt = +er.secondaryGroupSize, gt = er.groupSeparator || "", St = ot[0], xt = ot[1], vt = ct.s < 0, $t = vt ? St.slice(1) : St, yt = $t.length;
      if (mt && (dt = ut, ut = mt, mt = dt, yt -= dt), ut > 0 && yt > 0) {
        for (dt = yt % ut || ut, St = $t.substr(0, dt); dt < yt; dt += ut) St += gt + $t.substr(dt, ut);
        mt > 0 && (St += gt + $t.slice(dt)), vt && (St = "-" + St);
      }
      Ht = xt ? St + (er.decimalSeparator || "") + ((mt = +er.fractionGroupSize) ? xt.replace(
        new RegExp("\\d{" + mt + "}\\B", "g"),
        "$&" + (er.fractionGroupSeparator || "")
      ) : xt) : St;
    }
    return (er.prefix || "") + Ht + (er.suffix || "");
  }, oe.toFraction = function(jt) {
    var Ut, er, Ht, ct, dt, ot, ut, mt, gt, St, xt, vt, $t = this, yt = $t.c;
    if (jt != null && (ut = new Ot(jt), !ut.isInteger() && (ut.c || ut.s !== 1) || ut.lt(ce)))
      throw Error(bignumberError + "Argument " + (ut.isInteger() ? "out of range: " : "not an integer: ") + yr(ut));
    if (!yt) return new Ot($t);
    for (Ut = new Ot(ce), gt = er = new Ot(ce), Ht = mt = new Ot(ce), vt = coeffToString(yt), dt = Ut.e = vt.length - $t.e - 1, Ut.c[0] = POWS_TEN[(ot = dt % LOG_BASE) < 0 ? LOG_BASE + ot : ot], jt = !jt || ut.comparedTo(Ut) > 0 ? dt > 0 ? Ut : gt : ut, ot = lt, lt = 1 / 0, ut = new Ot(vt), mt.c[0] = 0; St = L(ut, Ut, 0, 1), ct = er.plus(St.times(Ht)), ct.comparedTo(jt) != 1; )
      er = Ht, Ht = ct, gt = mt.plus(St.times(ct = gt)), mt = ct, Ut = ut.minus(St.times(ct = Ut)), ut = ct;
    return ct = L(jt.minus(er), Ht, 0, 1), mt = mt.plus(ct.times(gt)), er = er.plus(ct.times(Ht)), mt.s = gt.s = $t.s, dt = dt * 2, xt = L(gt, Ht, dt, rt).minus($t).abs().comparedTo(
      L(mt, er, dt, rt).minus($t).abs()
    ) < 1 ? [gt, Ht] : [mt, er], lt = ot, xt;
  }, oe.toNumber = function() {
    return +yr(this);
  }, oe.toPrecision = function(jt, Ut) {
    return jt != null && intCheck(jt, 1, MAX), It(this, jt, Ut, 2);
  }, oe.toString = function(jt) {
    var Ut, er = this, Ht = er.s, ct = er.e;
    return ct === null ? Ht ? (Ut = "Infinity", Ht < 0 && (Ut = "-" + Ut)) : Ut = "NaN" : (jt == null ? Ut = ct <= at || ct >= ht ? toExponential(coeffToString(er.c), ct) : toFixedPoint(coeffToString(er.c), ct, "0") : jt === 10 && zt ? (er = Vt(new Ot(er), Ce + ct + 1, rt), Ut = toFixedPoint(coeffToString(er.c), er.e, "0")) : (intCheck(jt, 2, Lt.length, "Base"), Ut = J(toFixedPoint(coeffToString(er.c), ct, "0"), 10, jt, Ht, !0)), Ht < 0 && er.c[0] && (Ut = "-" + Ut)), Ut;
  }, oe.valueOf = oe.toJSON = function() {
    return yr(this);
  }, oe._isBigNumber = !0, oe[Symbol.toStringTag] = "BigNumber", oe[Symbol.for("nodejs.util.inspect.custom")] = oe.valueOf, B != null && Ot.set(B), Ot;
}
function bitFloor(B) {
  var L = B | 0;
  return B > 0 || B === L ? L : L - 1;
}
function coeffToString(B) {
  for (var L, J, ne = 1, oe = B.length, ce = B[0] + ""; ne < oe; ) {
    for (L = B[ne++] + "", J = LOG_BASE - L.length; J--; L = "0" + L) ;
    ce += L;
  }
  for (oe = ce.length; ce.charCodeAt(--oe) === 48; ) ;
  return ce.slice(0, oe + 1 || 1);
}
function compare(B, L) {
  var J, ne, oe = B.c, ce = L.c, Ce = B.s, rt = L.s, at = B.e, ht = L.e;
  if (!Ce || !rt) return null;
  if (J = oe && !oe[0], ne = ce && !ce[0], J || ne) return J ? ne ? 0 : -rt : Ce;
  if (Ce != rt) return Ce;
  if (J = Ce < 0, ne = at == ht, !oe || !ce) return ne ? 0 : !oe ^ J ? 1 : -1;
  if (!ne) return at > ht ^ J ? 1 : -1;
  for (rt = (at = oe.length) < (ht = ce.length) ? at : ht, Ce = 0; Ce < rt; Ce++) if (oe[Ce] != ce[Ce]) return oe[Ce] > ce[Ce] ^ J ? 1 : -1;
  return at == ht ? 0 : at > ht ^ J ? 1 : -1;
}
function intCheck(B, L, J, ne) {
  if (B < L || B > J || B !== mathfloor(B))
    throw Error(bignumberError + (ne || "Argument") + (typeof B == "number" ? B < L || B > J ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var L = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == L && B.c[L] % 2 != 0;
}
function toExponential(B, L) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (L < 0 ? "e" : "e+") + L;
}
function toFixedPoint(B, L, J) {
  var ne, oe;
  if (L < 0) {
    for (oe = J + "."; ++L; oe += J) ;
    B = oe + B;
  } else if (ne = B.length, ++L > ne) {
    for (oe = J, L -= ne; --L; oe += J) ;
    B += oe;
  } else L < ne && (B = B.slice(0, L) + "." + B.slice(L));
  return B;
}
var BigNumber = clone();
class BaseDatasource {
  constructor({ network: L }) {
    Li(this, "network");
    this.network = L;
  }
}
class DatasourceUtility {
  /**
   * Parses an inscription.
   *
   * @param inscription Inscription
   * @param options Options
   * - `decodeMetadata` decodes the metadata object into [valid URI components](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent).
   * @returns Parsed inscription
   */
  static parseInscription(L, { decodeMetadata: J }) {
    return {
      ...L,
      meta: J && L.meta ? UNSTABLE_decodeObject(L.meta) : L.meta
    };
  }
  /**
   * Parses inscriptions.
   *
   * @param inscriptions Inscriptions
   * @param options Options
   * - `decodeMetadata` decodes the metadata object into [valid URI components](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent).
   * @returns Parsed inscriptions
   */
  static parseInscriptions(L, { decodeMetadata: J }) {
    return L.map(
      (ne) => this.parseInscription(ne, { decodeMetadata: J })
    );
  }
  static segregateUTXOsBySpendStatus({
    utxos: L
  }) {
    const { spendableUTXOs: J, unspendableUTXOs: ne } = L.reduce(
      (oe, ce) => (ce.safeToSpend ? oe.spendableUTXOs.push(ce) : oe.unspendableUTXOs.push(ce), oe),
      {
        spendableUTXOs: [],
        unspendableUTXOs: []
      }
    );
    return {
      totalUTXOs: L.length,
      spendableUTXOs: J,
      unspendableUTXOs: ne
    };
  }
}
var browserPonyfill = { exports: {} };
(function(B, L) {
  var J = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof commonjsGlobal < "u" && commonjsGlobal, ne = function() {
    function ce() {
      this.fetch = !1, this.DOMException = J.DOMException;
    }
    return ce.prototype = J, new ce();
  }();
  (function(ce) {
    (function(Ce) {
      var rt = typeof ce < "u" && ce || typeof self < "u" && self || typeof rt < "u" && rt, at = {
        searchParams: "URLSearchParams" in rt,
        iterable: "Symbol" in rt && "iterator" in Symbol,
        blob: "FileReader" in rt && "Blob" in rt && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in rt,
        arrayBuffer: "ArrayBuffer" in rt
      };
      function ht(ut) {
        return ut && DataView.prototype.isPrototypeOf(ut);
      }
      if (at.arrayBuffer)
        var it = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], lt = ArrayBuffer.isView || function(ut) {
          return ut && it.indexOf(Object.prototype.toString.call(ut)) > -1;
        };
      function Et(ut) {
        if (typeof ut != "string" && (ut = String(ut)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(ut) || ut === "")
          throw new TypeError('Invalid character in header field name: "' + ut + '"');
        return ut.toLowerCase();
      }
      function wt(ut) {
        return typeof ut != "string" && (ut = String(ut)), ut;
      }
      function Rt(ut) {
        var mt = {
          next: function() {
            var gt = ut.shift();
            return { done: gt === void 0, value: gt };
          }
        };
        return at.iterable && (mt[Symbol.iterator] = function() {
          return mt;
        }), mt;
      }
      function Mt(ut) {
        this.map = {}, ut instanceof Mt ? ut.forEach(function(mt, gt) {
          this.append(gt, mt);
        }, this) : Array.isArray(ut) ? ut.forEach(function(mt) {
          this.append(mt[0], mt[1]);
        }, this) : ut && Object.getOwnPropertyNames(ut).forEach(function(mt) {
          this.append(mt, ut[mt]);
        }, this);
      }
      Mt.prototype.append = function(ut, mt) {
        ut = Et(ut), mt = wt(mt);
        var gt = this.map[ut];
        this.map[ut] = gt ? gt + ", " + mt : mt;
      }, Mt.prototype.delete = function(ut) {
        delete this.map[Et(ut)];
      }, Mt.prototype.get = function(ut) {
        return ut = Et(ut), this.has(ut) ? this.map[ut] : null;
      }, Mt.prototype.has = function(ut) {
        return this.map.hasOwnProperty(Et(ut));
      }, Mt.prototype.set = function(ut, mt) {
        this.map[Et(ut)] = wt(mt);
      }, Mt.prototype.forEach = function(ut, mt) {
        for (var gt in this.map)
          this.map.hasOwnProperty(gt) && ut.call(mt, this.map[gt], gt, this);
      }, Mt.prototype.keys = function() {
        var ut = [];
        return this.forEach(function(mt, gt) {
          ut.push(gt);
        }), Rt(ut);
      }, Mt.prototype.values = function() {
        var ut = [];
        return this.forEach(function(mt) {
          ut.push(mt);
        }), Rt(ut);
      }, Mt.prototype.entries = function() {
        var ut = [];
        return this.forEach(function(mt, gt) {
          ut.push([gt, mt]);
        }), Rt(ut);
      }, at.iterable && (Mt.prototype[Symbol.iterator] = Mt.prototype.entries);
      function Lt(ut) {
        if (ut.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        ut.bodyUsed = !0;
      }
      function zt(ut) {
        return new Promise(function(mt, gt) {
          ut.onload = function() {
            mt(ut.result);
          }, ut.onerror = function() {
            gt(ut.error);
          };
        });
      }
      function Ot(ut) {
        var mt = new FileReader(), gt = zt(mt);
        return mt.readAsArrayBuffer(ut), gt;
      }
      function It(ut) {
        var mt = new FileReader(), gt = zt(mt);
        return mt.readAsText(ut), gt;
      }
      function Ft(ut) {
        for (var mt = new Uint8Array(ut), gt = new Array(mt.length), St = 0; St < mt.length; St++)
          gt[St] = String.fromCharCode(mt[St]);
        return gt.join("");
      }
      function Jt(ut) {
        if (ut.slice)
          return ut.slice(0);
        var mt = new Uint8Array(ut.byteLength);
        return mt.set(new Uint8Array(ut)), mt.buffer;
      }
      function Vt() {
        return this.bodyUsed = !1, this._initBody = function(ut) {
          this.bodyUsed = this.bodyUsed, this._bodyInit = ut, ut ? typeof ut == "string" ? this._bodyText = ut : at.blob && Blob.prototype.isPrototypeOf(ut) ? this._bodyBlob = ut : at.formData && FormData.prototype.isPrototypeOf(ut) ? this._bodyFormData = ut : at.searchParams && URLSearchParams.prototype.isPrototypeOf(ut) ? this._bodyText = ut.toString() : at.arrayBuffer && at.blob && ht(ut) ? (this._bodyArrayBuffer = Jt(ut.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : at.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(ut) || lt(ut)) ? this._bodyArrayBuffer = Jt(ut) : this._bodyText = ut = Object.prototype.toString.call(ut) : this._bodyText = "", this.headers.get("content-type") || (typeof ut == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : at.searchParams && URLSearchParams.prototype.isPrototypeOf(ut) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, at.blob && (this.blob = function() {
          var ut = Lt(this);
          if (ut)
            return ut;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var ut = Lt(this);
            return ut || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            ) : Promise.resolve(this._bodyArrayBuffer));
          } else
            return this.blob().then(Ot);
        }), this.text = function() {
          var ut = Lt(this);
          if (ut)
            return ut;
          if (this._bodyBlob)
            return It(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(Ft(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, at.formData && (this.formData = function() {
          return this.text().then(er);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var yr = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function jt(ut) {
        var mt = ut.toUpperCase();
        return yr.indexOf(mt) > -1 ? mt : ut;
      }
      function Ut(ut, mt) {
        if (!(this instanceof Ut))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        mt = mt || {};
        var gt = mt.body;
        if (ut instanceof Ut) {
          if (ut.bodyUsed)
            throw new TypeError("Already read");
          this.url = ut.url, this.credentials = ut.credentials, mt.headers || (this.headers = new Mt(ut.headers)), this.method = ut.method, this.mode = ut.mode, this.signal = ut.signal, !gt && ut._bodyInit != null && (gt = ut._bodyInit, ut.bodyUsed = !0);
        } else
          this.url = String(ut);
        if (this.credentials = mt.credentials || this.credentials || "same-origin", (mt.headers || !this.headers) && (this.headers = new Mt(mt.headers)), this.method = jt(mt.method || this.method || "GET"), this.mode = mt.mode || this.mode || null, this.signal = mt.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && gt)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(gt), (this.method === "GET" || this.method === "HEAD") && (mt.cache === "no-store" || mt.cache === "no-cache")) {
          var St = /([?&])_=[^&]*/;
          if (St.test(this.url))
            this.url = this.url.replace(St, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
          else {
            var xt = /\?/;
            this.url += (xt.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
          }
        }
      }
      Ut.prototype.clone = function() {
        return new Ut(this, { body: this._bodyInit });
      };
      function er(ut) {
        var mt = new FormData();
        return ut.trim().split("&").forEach(function(gt) {
          if (gt) {
            var St = gt.split("="), xt = St.shift().replace(/\+/g, " "), vt = St.join("=").replace(/\+/g, " ");
            mt.append(decodeURIComponent(xt), decodeURIComponent(vt));
          }
        }), mt;
      }
      function Ht(ut) {
        var mt = new Mt(), gt = ut.replace(/\r?\n[\t ]+/g, " ");
        return gt.split("\r").map(function(St) {
          return St.indexOf(`
`) === 0 ? St.substr(1, St.length) : St;
        }).forEach(function(St) {
          var xt = St.split(":"), vt = xt.shift().trim();
          if (vt) {
            var $t = xt.join(":").trim();
            mt.append(vt, $t);
          }
        }), mt;
      }
      Vt.call(Ut.prototype);
      function ct(ut, mt) {
        if (!(this instanceof ct))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        mt || (mt = {}), this.type = "default", this.status = mt.status === void 0 ? 200 : mt.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = mt.statusText === void 0 ? "" : "" + mt.statusText, this.headers = new Mt(mt.headers), this.url = mt.url || "", this._initBody(ut);
      }
      Vt.call(ct.prototype), ct.prototype.clone = function() {
        return new ct(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Mt(this.headers),
          url: this.url
        });
      }, ct.error = function() {
        var ut = new ct(null, { status: 0, statusText: "" });
        return ut.type = "error", ut;
      };
      var dt = [301, 302, 303, 307, 308];
      ct.redirect = function(ut, mt) {
        if (dt.indexOf(mt) === -1)
          throw new RangeError("Invalid status code");
        return new ct(null, { status: mt, headers: { location: ut } });
      }, Ce.DOMException = rt.DOMException;
      try {
        new Ce.DOMException();
      } catch {
        Ce.DOMException = function(mt, gt) {
          this.message = mt, this.name = gt;
          var St = Error(mt);
          this.stack = St.stack;
        }, Ce.DOMException.prototype = Object.create(Error.prototype), Ce.DOMException.prototype.constructor = Ce.DOMException;
      }
      function ot(ut, mt) {
        return new Promise(function(gt, St) {
          var xt = new Ut(ut, mt);
          if (xt.signal && xt.signal.aborted)
            return St(new Ce.DOMException("Aborted", "AbortError"));
          var vt = new XMLHttpRequest();
          function $t() {
            vt.abort();
          }
          vt.onload = function() {
            var Bt = {
              status: vt.status,
              statusText: vt.statusText,
              headers: Ht(vt.getAllResponseHeaders() || "")
            };
            Bt.url = "responseURL" in vt ? vt.responseURL : Bt.headers.get("X-Request-URL");
            var rr = "response" in vt ? vt.response : vt.responseText;
            setTimeout(function() {
              gt(new ct(rr, Bt));
            }, 0);
          }, vt.onerror = function() {
            setTimeout(function() {
              St(new TypeError("Network request failed"));
            }, 0);
          }, vt.ontimeout = function() {
            setTimeout(function() {
              St(new TypeError("Network request failed"));
            }, 0);
          }, vt.onabort = function() {
            setTimeout(function() {
              St(new Ce.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function yt(Bt) {
            try {
              return Bt === "" && rt.location.href ? rt.location.href : Bt;
            } catch {
              return Bt;
            }
          }
          vt.open(xt.method, yt(xt.url), !0), xt.credentials === "include" ? vt.withCredentials = !0 : xt.credentials === "omit" && (vt.withCredentials = !1), "responseType" in vt && (at.blob ? vt.responseType = "blob" : at.arrayBuffer && xt.headers.get("Content-Type") && xt.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (vt.responseType = "arraybuffer")), mt && typeof mt.headers == "object" && !(mt.headers instanceof Mt) ? Object.getOwnPropertyNames(mt.headers).forEach(function(Bt) {
            vt.setRequestHeader(Bt, wt(mt.headers[Bt]));
          }) : xt.headers.forEach(function(Bt, rr) {
            vt.setRequestHeader(rr, Bt);
          }), xt.signal && (xt.signal.addEventListener("abort", $t), vt.onreadystatechange = function() {
            vt.readyState === 4 && xt.signal.removeEventListener("abort", $t);
          }), vt.send(typeof xt._bodyInit > "u" ? null : xt._bodyInit);
        });
      }
      return ot.polyfill = !0, rt.fetch || (rt.fetch = ot, rt.Headers = Mt, rt.Request = Ut, rt.Response = ct), Ce.Headers = Mt, Ce.Request = Ut, Ce.Response = ct, Ce.fetch = ot, Ce;
    })({});
  })(ne), ne.fetch.ponyfill = !0, delete ne.fetch.polyfill;
  var oe = J.fetch ? J : ne;
  L = oe.fetch, L.default = oe.fetch, L.fetch = oe.fetch, L.Headers = oe.Headers, L.Request = oe.Request, L.Response = oe.Response, B.exports = L;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const fetch = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports), API_CONFIG = {
  version: "0.0.0.10",
  apis: {
    mainnet: {
      batter: "https://mainnet.ordit.io/"
    },
    regtest: {
      batter: "https://regtest.ordit.io/"
    },
    testnet: {
      batter: "https://testnet.ordit.io/"
    },
    signet: {
      batter: "https://signet.ordit.io/"
    }
  }
};
function isNumber(B) {
  return typeof B == "number" && B > Number.NEGATIVE_INFINITY && B < Number.POSITIVE_INFINITY;
}
function isInteger(B) {
  return isNumber(B) && B % 1 === 0;
}
function isString(B) {
  return typeof B == "string";
}
function isJsonRpcId(B) {
  return isString(B) || isInteger(B) || B === null;
}
function getRpcUrl(B) {
  return B[B.length - 1] === "/" ? B.substring(0, B.length - 1) : B;
}
class JsonRpc {
  constructor(L) {
    this.url = L;
  }
  /**
   * Send a JSON-RPC 2.0 notification to the connected Sado compliant server.
   *
   * @param method - Method to call.
   * @param params - JSON-RPC 2.0 parameters.
   */
  async notify(L, J) {
    await fetch(`${this.url}/rpc`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: L,
        params: J
      })
    });
  }
  async call(L, J, ne) {
    let oe = {}, ce = ne;
    isJsonRpcId(J) ? ce = J : oe = J;
    const Ce = await fetch(`${this.url}/rpc`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: L,
        params: oe,
        id: ce
      })
    });
    if (Ce.status === 200) {
      const rt = await Ce.json();
      if (rt.error) {
        const at = typeof rt.error.data == "string" ? rt.error.data : rt.error.message;
        throw new OrditSDKError(at);
      }
      return rt.result;
    }
    throw new OrditSDKError("Internal Server Error");
  }
}
const rpc = {
  get id() {
    return Math.floor(Math.random() * 1e5);
  },
  mainnet: new JsonRpc(getRpcUrl(API_CONFIG.apis.mainnet.batter)),
  testnet: new JsonRpc(getRpcUrl(API_CONFIG.apis.testnet.batter)),
  signet: new JsonRpc(getRpcUrl(API_CONFIG.apis.signet.batter)),
  regtest: new JsonRpc(getRpcUrl(API_CONFIG.apis.regtest.batter))
};
class JsonRpcDatasource extends BaseDatasource {
  constructor({ network: L }) {
    super({ network: L });
  }
  async getBalance({ address: L }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    return rpc[this.network].call(
      "Address.GetBalance",
      { address: L },
      rpc.id
    );
  }
  async getInscription({
    id: L,
    decodeMetadata: J = !1
  }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    const ne = outpointToIdFormat(L), oe = await rpc[this.network].call(
      "Ordinals.GetInscription",
      { id: ne },
      rpc.id
    );
    return DatasourceUtility.parseInscription(oe, { decodeMetadata: J });
  }
  async getInscriptionUTXO({ id: L }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    const J = outpointToIdFormat(L);
    return rpc[this.network].call(
      "Ordinals.GetInscriptionUtxo",
      { id: J },
      rpc.id
    );
  }
  async getInscriptions({
    creator: L,
    owner: J,
    mimeType: ne,
    mimeSubType: oe,
    outpoint: ce,
    decodeMetadata: Ce = !1,
    sort: rt = "asc",
    limit: at = 25,
    next: ht = null
  }) {
    let it = [], lt = ht;
    do {
      const { inscriptions: Et, pagination: wt } = await rpc[this.network].call(
        "Ordinals.GetInscriptions",
        {
          filter: { creator: L, owner: J, mimeType: ne, mimeSubType: oe, outpoint: ce },
          sort: { number: rt },
          pagination: { limit: at, next: lt }
        },
        rpc.id
      );
      it = it.concat(Et), lt = wt.next;
    } while (lt !== null);
    return DatasourceUtility.parseInscriptions(it, {
      decodeMetadata: Ce
    });
  }
  async getSpendables({
    address: L,
    value: J,
    rarity: ne = ["common"],
    filter: oe = [],
    limit: ce = 200,
    type: Ce = "spendable"
  }) {
    if (!L || Number.isNaN(J) || !J)
      throw new OrditSDKError("Invalid request");
    return rpc[this.network].call(
      "Address.GetSpendables",
      {
        address: L,
        value: J,
        safetospend: Ce === "spendable",
        allowedrarity: ne,
        filter: oe,
        limit: ce
      },
      rpc.id
    );
  }
  async getTransaction({
    txId: L,
    ordinals: J = !0,
    hex: ne = !1,
    witness: oe = !0,
    decodeMetadata: ce = !0
  }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    const Ce = await rpc[this.network].call(
      "Transactions.GetTransaction",
      {
        txid: L,
        options: {
          ord: J,
          hex: ne,
          witness: oe
        }
      },
      rpc.id
    );
    return Ce.vout = Ce.vout.map((rt) => ({
      ...rt,
      inscriptions: DatasourceUtility.parseInscriptions(rt.inscriptions, {
        decodeMetadata: ce
      })
    })), {
      tx: Ce,
      rawTx: ne && Ce.hex ? src$4.Transaction.fromHex(Ce.hex) : void 0
    };
  }
  async getUnspents({
    address: L,
    type: J = "spendable",
    rarity: ne = ["common"],
    sort: oe = "desc",
    limit: ce = 50,
    next: Ce = null
  }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    let rt = [], at = Ce;
    do {
      const { unspents: ht, pagination: it } = await rpc[this.network].call(
        "Address.GetUnspents",
        {
          address: L,
          options: {
            allowedrarity: ne,
            safetospend: J === "spendable"
          },
          pagination: {
            limit: ce,
            next: at
          },
          sort: { value: oe }
        },
        rpc.id
      );
      rt = rt.concat(ht), at = it.next;
    } while (at !== null);
    return DatasourceUtility.segregateUTXOsBySpendStatus({ utxos: rt });
  }
  async relay({ hex: L, maxFeeRate: J, validate: ne = !0 }) {
    if (!L)
      throw new OrditSDKError("Invalid request");
    if (J && (J < 0 || Number.isNaN(J)))
      throw new OrditSDKError("Invalid max fee rate");
    return rpc[this.network].call(
      "Transactions.Relay",
      { hex: L, maxFeeRate: J, validate: ne },
      rpc.id
    );
  }
}
function useBalance() {
  const { network: B, publicKey: L, format: J } = useWallie(), [ne, oe] = reactExports.useState(null), [ce, Ce] = reactExports.useState(!1);
  return { getBalance: reactExports.useCallback(async () => {
    Ce(!0);
    try {
      if (oe(null), !J || !J.payments || !L || !L.payments)
        throw new Error("No wallet is connected");
      const { address: at } = getAddressesFromPublicKey(
        L.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[J.payments]
      )[0], it = await new JsonRpcDatasource({ network: B }).getBalance({ address: at }), lt = Number(
        new BigNumber(it).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return Ce(!1), lt;
    } catch (at) {
      throw oe(at.message), Ce(!1), at;
    }
  }, [J, B, L]), error: ne, loading: ce };
}
var LeatherAddressType = /* @__PURE__ */ ((B) => (B.P2WPKH = "p2wpkh", B.P2TR = "p2tr", B))(LeatherAddressType || {});
async function leatherRequest$1(B, L) {
  try {
    return (await window.LeatherProvider.request(
      B,
      L
    )).result;
  } catch (J) {
    const ne = J, { message: oe } = ne.error;
    throw ne.error.code === 4001 ? new BrowserWalletRequestCancelledByUserError(oe) : new OrditSDKError(`Leather error: ${oe}`);
  }
}
function isInstalled$1() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof window.LeatherProvider < "u";
}
async function signMessage$2(B, { network: L = "mainnet", paymentType: J }) {
  if (!isInstalled$1())
    throw new BrowserWalletNotInstalledError("Leather not installed");
  const { signature: ne } = await leatherRequest$1(
    "signMessage",
    {
      message: B,
      paymentType: J,
      network: L
    }
  );
  return {
    base64: ne,
    hex: Buffer$D.from(ne, "base64").toString("hex")
  };
}
async function signPsbt$2(B, {
  finalize: L = !0,
  extractTx: J = !0,
  allowedSighash: ne,
  accountNumber: oe,
  network: ce = "mainnet",
  signAtIndexes: Ce = []
} = {}) {
  if (!isInstalled$1())
    throw new BrowserWalletNotInstalledError("Leather not installed");
  if (J && !L)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  const rt = B.toHex(), at = await leatherRequest$1("signPsbt", {
    hex: rt,
    allowedSighash: ne,
    account: oe,
    network: ce,
    signAtIndex: Ce,
    broadcast: !1
  }), ht = src$4.Psbt.fromHex(at.hex);
  if (L && Ce.forEach((it) => {
    try {
      ht.finalizeInput(it);
    } catch (lt) {
      throw console.error("Sign psbt error", lt), new OrditSDKError("Failed to finalize input");
    }
  }), J)
    try {
      return {
        base64: null,
        hex: ht.extractTransaction().toHex()
      };
    } catch (it) {
      throw it instanceof Error && it.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
    }
  return {
    base64: ht.toBase64(),
    hex: ht.toHex()
  };
}
function isInstalled() {
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  return typeof window.okxwallet < "u";
}
function getOKXWalletProvider(B = "mainnet") {
  if (!isInstalled())
    throw new BrowserWalletNotInstalledError("OKX Wallet not installed");
  let L;
  switch (B) {
    case "mainnet":
      L = window.okxwallet.bitcoin;
      break;
    case "testnet":
      L = window.okxwallet.bitcoinTestnet;
      break;
    case "signet":
      L = window.okxwallet.bitcoinSignet;
      break;
    default:
      throw new OrditSDKError("Invalid network");
  }
  if (!L)
    throw new OrditSDKError("Failed to get OKX Wallet provider");
  return L;
}
async function signPsbt$1(B, {
  finalize: L = !0,
  extractTx: J = !0,
  network: ne,
  inputsToSign: oe
} = { network: "mainnet", inputsToSign: [] }) {
  if (!isInstalled())
    throw new BrowserWalletNotInstalledError("OKX Wallet not installed");
  if (J && !L)
    throw new BrowserWalletExtractTxFromNonFinalizedPsbtError();
  const ce = getOKXWalletProvider(ne), Ce = B.toHex();
  let rt = "";
  const at = [];
  oe.forEach((it) => {
    const { address: lt, signingIndexes: Et, sigHash: wt } = it;
    Et.forEach((Rt) => {
      at.push({
        index: Rt,
        address: lt,
        sighashTypes: wt ? [wt] : void 0
      });
    });
  });
  try {
    rt = await ce.signPsbt(Ce, {
      autoFinalized: L,
      toSignInputs: at
    });
  } catch (it) {
    const lt = it;
    throw lt.code === 4001 ? new BrowserWalletRequestCancelledByUserError() : new OrditSDKError(lt.message);
  }
  if (!rt)
    throw new BrowserWalletSigningError(
      "Failed to sign psbt hex using OKX Wallet"
    );
  const ht = src$4.Psbt.fromHex(rt);
  if (J)
    try {
      return {
        base64: null,
        hex: ht.extractTransaction().toHex()
      };
    } catch (it) {
      throw it instanceof Error && it.message === "Not finalized" ? new BrowserWalletExtractTxFromNonFinalizedPsbtError() : new OrditSDKError("Failed to extract transaction from PSBT");
    }
  else
    return {
      base64: ht.toBase64(),
      hex: ht.toHex()
    };
}
async function signMessage$1(B, L = "ecdsa", J = "mainnet") {
  if (!isInstalled())
    throw new BrowserWalletNotInstalledError("OKX Wallet not installed");
  const ne = getOKXWalletProvider(J);
  let oe = "";
  try {
    oe = await ne.signMessage(B, L);
  } catch (ce) {
    const Ce = ce;
    throw Ce.code === 4001 ? new BrowserWalletRequestCancelledByUserError() : new OrditSDKError(Ce.message);
  }
  if (!oe)
    throw new BrowserWalletSigningError(
      "Failed to sign message using OKX Wallet"
    );
  return {
    base64: oe,
    hex: Buffer$D.from(oe, "base64").toString("hex")
  };
}
async function signPsbt({
  address: B,
  wallet: L,
  network: J,
  psbt: ne,
  options: oe
}) {
  var at, ht;
  if ((at = oe == null ? void 0 : oe.signingIndexes) != null && at.length && ((ht = oe == null ? void 0 : oe.inputsToSign) != null && ht.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const ce = (oe == null ? void 0 : oe.finalize) ?? !0, Ce = (oe == null ? void 0 : oe.extractTx) ?? !0, rt = () => ne.data.inputs.map((it, lt) => lt);
  if (L === Wallet.MAGICEDEN)
    return await signPsbt$5(ne, {
      network: J,
      inputsToSign: (oe == null ? void 0 : oe.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? rt(),
          sigHash: oe == null ? void 0 : oe.sigHash
        }
      ],
      finalize: ce,
      extractTx: Ce
    });
  if (L === Wallet.UNISAT)
    return await signPsbt$4(ne, {
      finalize: ce,
      extractTx: Ce
    });
  if (L === Wallet.XVERSE)
    return await signPsbt$3(ne, {
      network: J,
      inputsToSign: (oe == null ? void 0 : oe.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? rt(),
          // If signingIndexes is not provided, just sign everything
          sigHash: oe == null ? void 0 : oe.sigHash
        }
      ],
      finalize: ce,
      extractTx: Ce
    });
  if (L === Wallet.LEATHER)
    return await signPsbt$2(ne, {
      network: J,
      finalize: ce,
      extractTx: Ce,
      allowedSighash: oe != null && oe.sigHash ? [oe == null ? void 0 : oe.sigHash] : [],
      signAtIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? rt()
      // If signingIndexes is not provided, just sign everything
    });
  if (L === Wallet.OKX)
    return await signPsbt$1(ne, {
      finalize: ce,
      extractTx: Ce,
      network: J,
      inputsToSign: (oe == null ? void 0 : oe.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? rt(),
          // If signingIndexes is not provided, just sign everything
          sigHash: oe == null ? void 0 : oe.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
var bufferReverse = function B(L) {
  for (var J = new Buffer$D(L.length), ne = 0, oe = L.length - 1; ne <= oe; ++ne, --oe)
    J[ne] = L[oe], J[oe] = L[ne];
  return J;
};
const reverseBuffer = /* @__PURE__ */ getDefaultExportFromCjs(bufferReverse), TRANSACTION_HEADER_SIZE = 10.5;
function getBaseSizeByType(B) {
  switch (B) {
    case "taproot":
      return { input: 42, output: 43, witness: 66 };
    case "segwit":
      return { input: 41, output: 31, witness: 105 };
    case "p2sh-p2wpkh":
      return { input: 64, output: 32, witness: 105 };
    case "legacy":
      return { input: 148, output: 34, witness: 0 };
    default:
      throw new OrditSDKError("Invalid type");
  }
}
class FeeEstimator {
  constructor({ feeRate: L, network: J, psbt: ne, witness: oe }) {
    /**
     * Fee in satoshis
     */
    Li(this, "fee", 0);
    /**
     * Fee rate in satoshis
     */
    Li(this, "feeRate");
    Li(this, "network");
    Li(this, "psbt");
    Li(this, "witness", []);
    Li(this, "virtualSize", 0);
    Li(this, "weight", 0);
    if (L < 0 || !Number.isSafeInteger(L))
      throw new OrditSDKError("Invalid feeRate");
    this.feeRate = L, this.network = J, this.witness = oe || [], this.psbt = ne || new src$4.Psbt({ network: getNetwork(this.network) });
  }
  get data() {
    return {
      fee: this.fee,
      virtualSize: this.virtualSize,
      weight: this.weight
    };
  }
  /**
   * Calculates network fee based on virtual size of transaction and fee rate.
   *
   * @returns Estimated network fee
   * @throws {OrditSDKError} Fee is above MAXIMUM_FEE (5,000,000 satoshis)
   */
  calculateNetworkFee() {
    if (this.fee = this.calculateVirtualSize() * this.feeRate, this.fee > MAXIMUM_FEE)
      throw new OrditSDKError("Error while calculating fees");
    return this.fee;
  }
  getInputAndOutputScriptTypes() {
    const { inputs: L } = this.psbt.data, J = this.psbt.txOutputs;
    if (L.length === 0)
      throw new OrditSDKError("PSBT must have at least one input");
    if (J.length === 0)
      throw new OrditSDKError("PSBT must have at least one output");
    return {
      inputTypes: L.map((ne) => {
        const oe = ne.witnessUtxo && ne.witnessUtxo.script ? ne.witnessUtxo.script : null;
        if (!oe)
          throw new OrditSDKError("Invalid script");
        return getScriptType(oe, this.network).format;
      }),
      outputTypes: J.map(
        (ne) => getScriptType(ne.script, this.network).format
      )
    };
  }
  calculateScriptWitnessSize() {
    var J;
    const { inputTypes: L } = this.getInputAndOutputScriptTypes();
    return L.includes("taproot") && ((J = this.witness) != null && J.length) ? this.witness.reduce((ne, oe) => ne + oe.byteLength, 0) : 0;
  }
  getBaseSize() {
    var at, ht;
    const { inputTypes: L, outputTypes: J } = this.getInputAndOutputScriptTypes(), ne = 2, oe = L.reduce(
      (it, lt) => {
        const { input: Et, witness: wt } = getBaseSizeByType(lt);
        return it.input += Et, it.witness += wt, it;
      },
      {
        input: 0,
        witness: 0
      }
    ), ce = J.reduce((it, lt) => {
      const { output: Et } = getBaseSizeByType(lt);
      return it + Et;
    }, 0), Ce = oe.witness + ((at = this.witness) != null && at.length ? this.calculateScriptWitnessSize() : 0);
    let rt = 0;
    return (ht = this.witness) != null && ht.length ? rt = Ce : Ce > 0 && (rt = ne + Ce), {
      baseSize: oe.input + TRANSACTION_HEADER_SIZE + ce,
      witnessSize: rt
    };
  }
  calculateVirtualSize() {
    const { baseSize: L, witnessSize: J } = this.getBaseSize();
    return this.weight = L * 3 + (L + J), this.virtualSize = Math.ceil(this.weight / 4), this.virtualSize;
  }
}
function generateTaprootInput({
  utxo: B,
  pubKey: L,
  network: J,
  sighashType: ne,
  witness: oe
}) {
  const ce = BIP32.fromPublicKey(
    Buffer$D.from(L, "hex"),
    CHAIN_CODE,
    getNetwork(J)
  ), Ce = toXOnly(ce.publicKey);
  if (!B.scriptPubKey.hex)
    throw new Error("Unable to process p2tr input");
  return {
    type: "taproot",
    hash: B.txid,
    index: B.n,
    tapInternalKey: Ce,
    witnessUtxo: {
      script: Buffer$D.from(B.scriptPubKey.hex, "hex"),
      value: B.sats
    },
    witness: oe,
    ...ne ? { sighashType: ne } : void 0
  };
}
function generateSegwitInput({
  utxo: B,
  sighashType: L
}) {
  if (!B.scriptPubKey.hex)
    throw new Error("Unable to process Segwit input");
  return {
    type: "segwit",
    hash: B.txid,
    index: B.n,
    witnessUtxo: {
      script: Buffer$D.from(B.scriptPubKey.hex, "hex"),
      value: B.sats
    },
    ...L ? { sighashType: L } : void 0
  };
}
function generateP2SHP2WPKHInput({
  utxo: B,
  pubKey: L,
  network: J,
  sighashType: ne
}) {
  const oe = createPayment(Buffer$D.from(L, "hex"), "p2sh", J);
  if (!oe || !oe.output || !oe.redeem)
    throw new Error("Unable to process P2SH input");
  return {
    type: "p2sh-p2wpkh",
    hash: B.txid,
    index: B.n,
    redeemScript: oe.redeem.output,
    witnessUtxo: {
      script: Buffer$D.from(B.scriptPubKey.hex, "hex"),
      value: B.sats
    },
    ...ne ? { sighashType: ne } : void 0
  };
}
async function generateLegacyInput({
  utxo: B,
  sighashType: L,
  network: J,
  pubKey: ne,
  datasource: oe
}) {
  const { rawTx: ce } = await oe.getTransaction({
    txId: B.txid,
    hex: !0
  });
  if (!ce)
    throw new Error("Unable to process legacy input");
  const Ce = createPayment(Buffer$D.from(ne, "hex"), "p2pkh", J);
  return {
    type: "legacy",
    hash: B.txid,
    index: B.n,
    nonWitnessUtxo: ce == null ? void 0 : ce.toBuffer(),
    witnessUtxo: {
      script: Ce.output,
      value: B.sats
    },
    ...L ? { sighashType: L } : void 0
  };
}
async function processInput({
  utxo: B,
  pubKey: L,
  network: J,
  sighashType: ne,
  witness: oe,
  datasource: ce
}) {
  const Ce = ce || new JsonRpcDatasource({ network: J });
  switch (B.scriptPubKey.type) {
    case "witness_v1_taproot":
      return generateTaprootInput({
        utxo: B,
        pubKey: L,
        network: J,
        sighashType: ne,
        witness: oe
      });
    case "witness_v0_scripthash":
    case "witness_v0_keyhash":
      return generateSegwitInput({ utxo: B, sighashType: ne });
    case "scripthash":
      return generateP2SHP2WPKHInput({ utxo: B, pubKey: L, network: J, sighashType: ne });
    case "pubkeyhash":
      return generateLegacyInput({
        utxo: B,
        sighashType: ne,
        network: J,
        pubKey: L,
        datasource: Ce
      });
    default:
      throw new Error("invalid script pub type");
  }
}
class PSBTBuilder extends FeeEstimator {
  constructor({
    address: J,
    changeAddress: ne,
    datasource: oe,
    feeRate: ce,
    network: Ce = "mainnet",
    publicKey: rt,
    outputs: at,
    autoAdjustment: ht = !0,
    instantTradeMode: it = !1
  }) {
    super({
      feeRate: ce,
      network: Ce
    });
    Li(this, "address");
    Li(this, "changeAddress");
    /**
     * Change amount in satoshis
     */
    Li(this, "changeAmount", 0);
    Li(this, "datasource");
    Li(this, "injectableInputs", []);
    Li(this, "injectableOutputs", []);
    /**
     * Input amount in satoshis
     */
    Li(this, "inputAmount", 0);
    Li(this, "inputs", []);
    /**
     * Output amount in satoshis
     */
    Li(this, "outputAmount", 0);
    Li(this, "outputs", []);
    Li(this, "psbt");
    Li(this, "publicKey");
    /**
     * Replace-by-fee (RBF) is a feature that allows users to replace one version of an unconfirmed transaction
     * with a different version of the transaction that pays a higher transaction fee.
     * This can be done multiple times while the transaction is unconfirmed.
     *
     * Reference: [BIP-125](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki)
     */
    Li(this, "rbf", !0);
    Li(this, "utxos", []);
    Li(this, "usedUTXOs", []);
    /**
     * Enable auto adjustment.
     *
     * When `true`, change is calculated and UTXOs will be added as required to account for network fees.
     *
     * Otherwise, change is not calculated and no UTXOs will be added.
     */
    Li(this, "autoAdjustment");
    Li(this, "instantTradeMode");
    Li(this, "noMoreUTXOS", !1);
    this.address = J, this.changeAddress = ne, this.datasource = oe || new JsonRpcDatasource({ network: this.network }), this.outputs = at, this.publicKey = rt, this.autoAdjustment = ht, this.instantTradeMode = it, this.psbt = new src$4.Psbt({ network: getNetwork(Ce) });
  }
  get data() {
    return {
      fee: this.fee,
      virtualSize: this.virtualSize,
      weight: this.weight,
      changeAmount: this.changeAmount,
      inputAmount: this.inputAmount,
      outputAmount: this.outputAmount
    };
  }
  toPSBT() {
    return this.psbt;
  }
  toHex() {
    return this.psbt.toHex();
  }
  toBase64() {
    return this.psbt.toBase64();
  }
  /**
   * Set Replace-by-fee (RBF) value
   *
   * Replace-by-fee (RBF) is a feature that allows users to replace one version of an unconfirmed transaction
   * with a different version of the transaction that pays a higher transaction fee.
   * This can be done multiple times while the transaction is unconfirmed.
   *
   * Reference: [BIP-125](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki)
   */
  setRBF(J) {
    this.rbf = J, this.addInputs();
  }
  /**
   * Gets the x-coordinate of the public key.
   */
  get xKey() {
    return toXOnly(Buffer$D.from(this.publicKey, "hex")).toString("hex");
  }
  get inputsToSign() {
    const J = this.instantTradeMode && !this.autoAdjustment;
    return this.psbt.txInputs.reduce(
      (ne, oe, ce) => ((!this.instantTradeMode || this.instantTradeMode && ce !== INSTANT_BUY_SELLER_INPUT_INDEX) && (ne.signingIndexes = ne.signingIndexes.concat(ce)), J && (ne.sigHash = // eslint-disable-next-line no-bitwise
      src$4.Transaction.SIGHASH_SINGLE | src$4.Transaction.SIGHASH_ANYONECANPAY), ne),
      {
        address: this.address,
        signingIndexes: []
      }
    );
  }
  initPSBT() {
    this.psbt = new src$4.Psbt({ network: getNetwork(this.network) }), this.psbt.setMaximumFeeRate(this.feeRate);
  }
  getInputSequence() {
    return this.rbf ? 4294967293 : 4294967295;
  }
  injectInput(J) {
    this.psbt.data.globalMap.unsignedTx.tx.ins[J.injectionIndex] = J.txInput, this.psbt.data.inputs[J.injectionIndex] = J.standardInput;
  }
  injectOutput(J) {
    let ne = J.injectionIndex;
    do {
      if (!!!this.psbt.data.globalMap.unsignedTx.tx.outs[ne]) {
        this.psbt.data.globalMap.unsignedTx.tx.outs[ne] = J.txOutput, this.psbt.data.outputs[ne] = // TODO: remove hack
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        J.standardOutput;
        break;
      }
      ne += 1;
    } while (ne);
  }
  addInputs() {
    const J = this.injectableInputs.map(
      (oe) => oe.injectionIndex
    ), ne = [];
    this.inputs.forEach((oe, ce) => {
      const Ce = J.includes(ce);
      if (Ce) {
        const at = this.injectableInputs.find(
          (ht) => ht.injectionIndex === ce
        );
        this.injectInput(at), ne.push(at.injectionIndex);
      }
      this.psbt.txInputs.map((at) => {
        const ht = reverseBuffer(at.hash);
        return generateTxUniqueIdentifier(ht.toString("hex"), at.index);
      }).includes(
        generateTxUniqueIdentifier(oe.hash, oe.index)
      ) || (this.psbt.addInput(oe), this.psbt.setInputSequence(
        Ce ? ce + 1 : ce,
        this.getInputSequence()
      ));
    }), this.injectableInputs.forEach((oe) => {
      ne.includes(oe.injectionIndex) || (this.injectInput(oe), ne.push(oe.injectionIndex));
    });
  }
  addOutputs() {
    const J = this.injectableOutputs.map((oe) => oe.injectionIndex), ne = [];
    this.outputs.forEach((oe, ce) => {
      if (J.includes(ce)) {
        const Ce = this.injectableOutputs.find(
          (rt) => rt.injectionIndex === ce
        );
        this.injectOutput(Ce), ne.push(Ce.injectionIndex);
      }
      this.psbt.addOutput({
        address: oe.address,
        value: oe.value
      });
    }), this.injectableOutputs.forEach((oe) => {
      ne.includes(oe.injectionIndex) || (this.injectOutput(oe), ne.push(oe.injectionIndex));
    }), this.changeAmount >= MINIMUM_AMOUNT_IN_SATS && this.psbt.addOutput({
      address: this.changeAddress || this.address,
      value: this.changeAmount
    });
  }
  calculateOutputAmount() {
    if (this.outputAmount = Math.floor(
      this.outputs.reduce((J, ne) => J + ne.value, 0) + this.injectableOutputs.reduce((J, ne) => J + ne.sats, 0)
    ), this.outputAmount < MINIMUM_AMOUNT_IN_SATS)
      throw new Error(
        `Output amount too low. Minimum output amount needs to be ${MINIMUM_AMOUNT_IN_SATS} sats`
      );
  }
  /**
   * Calculates change amount from transaction and fetches additional UTXOs as required to cover output and network fees, if change is negative.
   */
  async recursivelyCalculateChangeAmount() {
    if (this.autoAdjustment && (this.changeAmount = Math.floor(
      this.inputAmount - this.outputAmount - this.fee
    ), this.changeAmount < 0 && (await this.prepare(), this.noMoreUTXOS)))
      throw new Error(
        `Insufficient balance. Decrease the output amount by ${this.changeAmount * -1} sats`
      );
  }
  getRetrievedUTXOsValue() {
    return this.utxos.reduce((J, ne) => J + ne.sats, 0);
  }
  getReservedUTXOs() {
    return this.utxos.map(
      (J) => generateTxUniqueIdentifier(J.txid, J.n)
    );
  }
  getUTXOAmountToRequestFromChangeAmount() {
    return this.changeAmount < 0 ? Math.abs(this.changeAmount) : this.outputAmount - this.getRetrievedUTXOsValue();
  }
  /**
   * Retrieves UTXOs using `getSpendables` RPC.
   *
   * @param address Address
   * @param amount Amount in satoshis
   */
  async retrieveUTXOs(J, ne) {
    if (!this.autoAdjustment && !J)
      return;
    const oe = ne && ne > 0 ? ne : this.getUTXOAmountToRequestFromChangeAmount();
    if (ne && this.getRetrievedUTXOsValue() >= ne || oe <= 0)
      return;
    const ce = await this.datasource.getSpendables({
      address: J || this.address,
      value: convertSatoshisToBTC(oe),
      filter: this.getReservedUTXOs()
    });
    this.noMoreUTXOS = ce.length === 0, this.utxos.push(...ce);
  }
  async retrieveSelectedUTXOs(J, ne) {
    await this.retrieveUTXOs(J, ne);
    const oe = this.utxos.find((ce) => ce.sats >= ne);
    return this.utxos = oe ? [oe] : [], this.utxos;
  }
  /**
   * Prepares inputs from UTXOs.
   */
  async prepareInputs() {
    if (!this.autoAdjustment)
      return;
    const J = [];
    this.utxos.forEach((oe) => {
      if (this.usedUTXOs.includes(generateTxUniqueIdentifier(oe.txid, oe.n)))
        return;
      this.inputAmount += oe.sats;
      const ce = processInput({
        utxo: oe,
        pubKey: this.publicKey,
        network: this.network,
        datasource: this.datasource
      });
      J.push(ce);
    });
    const ne = await Promise.all(J);
    this.inputAmount += this.injectableInputs.reduce(
      (oe, ce) => oe + ce.sats,
      0
    ), ne.forEach((oe) => {
      const ce = generateTxUniqueIdentifier(
        oe.hash,
        oe.index
      );
      this.usedUTXOs.includes(ce) || this.usedUTXOs.push(ce);
    }), this.inputs = this.inputs.concat(ne);
  }
  /**
   * Prepares PSBT to be set to a network, calculating and validating both inputs and outputs.
   */
  async prepare() {
    this.calculateOutputAmount(), await this.retrieveUTXOs(), await this.prepareInputs(), await this.recursivelyCalculateChangeAmount(), this.process(), await this.recursivelyCalculateChangeAmount(), this.calculateOutputAmount(), this.process();
  }
  /**
   * Initializes PSBT instance, adding all inputs and outputs and calculates network fees.
   *
   * @returns PSBTBuilder instance
   */
  process() {
    return this.initPSBT(), this.addInputs(), this.addOutputs(), this.calculateNetworkFee(), this;
  }
}
function useSend() {
  const { wallet: B, network: L, address: J, publicKey: ne } = useWallie(), [oe, ce] = reactExports.useState(null), [Ce, rt] = reactExports.useState(!1);
  return { send: reactExports.useCallback(
    async (ht, it, lt, Et = !0) => {
      rt(!0);
      try {
        if (ce(null), !J || !J.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const wt = new PSBTBuilder({
          address: J.payments,
          feeRate: lt,
          network: L,
          publicKey: ne.payments,
          outputs: [
            {
              address: ht,
              value: it
            }
          ]
        });
        await wt.prepare();
        const Rt = await signPsbt({
          address: J.payments,
          wallet: B,
          network: L,
          psbt: wt.toPSBT()
        });
        if (Et) {
          const Lt = await new JsonRpcDatasource({ network: L }).relay({ hex: Rt.hex });
          return rt(!1), Lt;
        }
        return rt(!1), Rt.hex;
      } catch (wt) {
        return ce(wt.message), rt(!1), null;
      }
    },
    [J, L, ne, B]
  ), error: oe, loading: Ce };
}
async function leatherRequest(B, L) {
  if (typeof window < "u" && window.LeatherProvider)
    try {
      return (await window.LeatherProvider.request(
        B,
        L
      )).result;
    } catch (J) {
      const ne = J, { message: oe } = ne.error;
      throw ne.error.code === 4001 ? new Error(oe) : new Error(`Leather error: ${oe}`);
    }
  else
    throw new Error("LeatherProvider not found");
}
async function walletProvider() {
  const { get: B } = getWallets(), J = B().find(
    (ne) => {
      var oe, ce;
      return ne.name === "Magic Eden" && ((ce = (oe = ne.features["sats-connect:"]) == null ? void 0 : oe.provider) == null ? void 0 : ce.isMagicEden) === !0;
    }
  );
  if (!J)
    throw new Error("Magic Eden wallet not found");
  return J.features["sats-connect:"].provider;
}
function useSendBtc() {
  const { wallet: B, network: L, address: J, publicKey: ne } = useWallie(), [oe, ce] = reactExports.useState(null), [Ce, rt] = reactExports.useState(!1);
  return { send: reactExports.useCallback(
    async (ht, it) => {
      rt(!0);
      try {
        if (ce(null), !J || !J.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        if (B === "magiceden" || B === "xverse") {
          const lt = B === "magiceden" ? await walletProvider() : void 0;
          let Et = null;
          return Et = await new Promise((wt, Rt) => {
            sendBtcTransaction({
              payload: {
                network: {
                  type: L === "mainnet" ? BitcoinNetworkType.Mainnet : BitcoinNetworkType.Testnet
                },
                message: "Sign Transaction",
                recipients: [
                  {
                    address: ht,
                    amountSats: BigInt(it)
                  }
                ],
                senderAddress: J.payments
              },
              getProvider: async () => lt,
              onFinish: (Mt) => {
                wt(Mt);
              },
              onCancel: () => {
                Rt(new Error("Transaction canceled"));
              }
            });
          }), rt(!1), Et;
        }
        if (B === "unisat") {
          let lt = "";
          return lt = await window.unisat.sendBitcoin(ht, it, {}), rt(!1), lt;
        }
        if (B === "leather") {
          let lt = "";
          return lt = (await leatherRequest(
            "sendTransfer",
            {
              recipients: [
                {
                  address: ht,
                  amount: it
                }
              ],
              network: L
            }
          )).txid, rt(!1), lt;
        }
        if (B === "okx") {
          let lt = "";
          if (L === "mainnet")
            return lt = await window.okxwallet.bitcoin.sendBitcoin(
              ht,
              it,
              {}
            ), rt(!1), lt;
          if (L === "testnet")
            return lt = await window.okxwallet.bitcoinTestnet.sendBitcoin(
              ht,
              it,
              {}
            ), rt(!1), lt;
        }
        return rt(!1), null;
      } catch (lt) {
        return ce(lt.message), rt(!1), null;
      }
    },
    [J, L, ne, B]
  ), error: oe, loading: Ce };
}
function useSendV2() {
  const { wallet: B, network: L, address: J, publicKey: ne } = useWallie(), [oe, ce] = reactExports.useState(!1);
  return { send: reactExports.useCallback(
    async ({
      toAddress: rt,
      satoshis: at,
      feeRate: ht,
      relay: it = !0,
      rbf: lt = !1
    }) => {
      ce(!0);
      try {
        if (!J || !J.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Et = new PSBTBuilder({
          address: J.payments,
          feeRate: ht,
          network: L,
          publicKey: ne.payments,
          outputs: [
            {
              address: rt,
              value: at
            }
          ]
        });
        Et.setRBF(lt), await Et.prepare();
        const wt = await signPsbt({
          address: J.payments,
          wallet: B,
          network: L,
          psbt: Et.toPSBT()
        });
        if (it) {
          const Mt = await new JsonRpcDatasource({ network: L }).relay({ hex: wt.hex });
          return ce(!1), {
            txId: Mt
          };
        }
        return ce(!1), {
          signedPsbtHex: wt.hex
        };
      } catch (Et) {
        return ce(!1), {
          error: Et.message
        };
      }
    },
    [J, L, ne, B]
  ), isLoading: oe };
}
function useSign() {
  const { network: B, publicKey: L, format: J, wallet: ne } = useWallie(), [oe, ce] = reactExports.useState(null), [Ce, rt] = reactExports.useState(!1);
  return { sign: reactExports.useCallback(
    async (ht, it, lt) => {
      rt(!0);
      try {
        if (ce(null), !J || !L || !ne)
          throw new Error("No wallet is connected");
        const Et = src$4.Psbt.fromBase64(it), wt = await signPsbt({
          address: ht,
          wallet: ne,
          network: B,
          psbt: Et,
          options: lt
        });
        return rt(!1), wt;
      } catch (Et) {
        throw ce(Et.message), rt(!1), Et;
      }
    },
    [J, B, L, ne]
  ), error: oe, loading: Ce };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: B,
  wallet: L,
  address: J,
  network: ne,
  format: oe
}) {
  if (L === Wallet.MAGICEDEN) {
    const { base64: ce } = await signMessage$5(B, J, ne);
    return ce;
  }
  if (L === Wallet.UNISAT) {
    const { base64: ce } = await signMessage$4(B, "bip322-simple");
    return ce;
  }
  if (L === Wallet.XVERSE) {
    const { base64: ce } = await signMessage$3(B, J, ne);
    return ce;
  }
  if (L === Wallet.LEATHER) {
    const ce = leatherPaymentTypeFromFormat(oe), { base64: Ce } = await signMessage$2(B, {
      paymentType: ce,
      network: ne
    });
    return Ce;
  }
  if (L === Wallet.OKX) {
    const { base64: ce } = await signMessage$1(B, "bip322-simple", ne);
    return ce;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: L,
    publicKey: J,
    format: ne,
    address: oe
  } = useWallie(), [ce, Ce] = reactExports.useState(null), [rt, at] = reactExports.useState(!1);
  return { signMsg: reactExports.useCallback(
    async (it, lt) => {
      at(!0);
      try {
        if (Ce(null), !ne || !J || !L)
          throw new Error("No wallet is connected");
        if (oe.ordinals !== it && oe.payments !== it)
          throw new Error("Address supplied is not connected address");
        const Et = await signMessage({
          address: it,
          wallet: L,
          message: lt,
          network: B,
          format: oe.ordinals === it ? ne.ordinals : ne.payments
        });
        return at(!1), Et;
      } catch (Et) {
        throw Ce(Et.message), at(!1), Et;
      }
    },
    [ne, B, J, L, oe]
  ), error: ce, isLoading: rt };
}
export {
  Network,
  OrdConnectKit,
  SelectWalletModal,
  Wallet,
  WallieProvider,
  useBalance,
  useSend,
  useSendBtc,
  useSendV2,
  useSign,
  useSignMessage,
  useWallie
};
