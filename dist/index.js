(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=Poppins:wght@400;500;600;700&display=swap";/*! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.fixed{position:fixed}.relative{position:relative}.inset-0{top:0;right:0;bottom:0;left:0}.z-10{z-index:10}.z-50{z-index:50}.mx-auto{margin-left:auto;margin-right:auto}.-mt-1{margin-top:-.25rem}.mb-1{margin-bottom:.25rem}.ml-auto{margin-left:auto}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.hidden{display:none}.h-\\[19px\\]{height:19px}.h-screen{height:100vh}.min-h-full{min-height:100%}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-\\[19px\\]{width:19px}.w-full{width:100%}.scale-100{--tw-scale-x:1;--tw-scale-y:1}.scale-100,.scale-95{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scale-95{--tw-scale-x:.95;--tw-scale-y:.95}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(1rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(1rem*var(--tw-space-x-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(1rem*var(--tw-space-y-reverse));margin-top:calc(1rem*(1 - var(--tw-space-y-reverse)))}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.break-all{word-break:break-all}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.bg-ord-blue-600{--tw-bg-opacity:1;background-color:rgb(23 30 45/var(--tw-bg-opacity))}.bg-ord-light-blue{--tw-bg-opacity:1;background-color:rgb(48 55 70/var(--tw-bg-opacity))}.bg-ord-light-blue-400{--tw-bg-opacity:1;background-color:rgb(73 82 102/var(--tw-bg-opacity))}.bg-ord-orange{--tw-bg-opacity:1;background-color:rgb(255 108 58/var(--tw-bg-opacity))}.bg-opacity-90{--tw-bg-opacity:.9}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-4{padding:1rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.py-3{padding-bottom:.75rem;padding-top:.75rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.pr-3{padding-right:.75rem}.pt-4{padding-top:1rem}.text-left{text-align:left}.text-\\[21px\\]{font-size:21px}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-medium{font-weight:500}.leading-8{line-height:2rem}.text-ord-alert{--tw-text-opacity:1;color:rgb(248 242 94/var(--tw-text-opacity))}.text-ord-blue{--tw-text-opacity:1;color:rgb(17 22 33/var(--tw-text-opacity))}.text-ord-gray{--tw-text-opacity:1;color:rgb(137 138 149/var(--tw-text-opacity))}.text-ord-light-blue-400{--tw-text-opacity:1;color:rgb(73 82 102/var(--tw-text-opacity))}.text-ord-light-gray{--tw-text-opacity:1;color:rgb(217 213 210/var(--tw-text-opacity))}.transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-100{transition-duration:.1s}.duration-75{transition-duration:75ms}body,html{font-family:Outfit,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;scroll-behavior:smooth}.transition{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}.hover\\:bg-ord-light-blue-250:hover{--tw-bg-opacity:1;background-color:rgb(45 50 61/var(--tw-bg-opacity))}@media (min-width:640px){.sm\\:items-center{align-items:center}.sm\\:p-0{padding:0}}@media (min-width:768px){.md\\:block{display:block}.md\\:w-7{width:1.75rem}.md\\:w-8{width:2rem}.md\\:w-96{width:24rem}.md\\:space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.md\\:space-x-6>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(1.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(1.5rem*var(--tw-space-x-reverse))}.md\\:bg-opacity-75{--tw-bg-opacity:.75}.md\\:px-3{padding-left:.75rem}.md\\:pr-3,.md\\:px-3{padding-right:.75rem}.md\\:text-xl{font-size:1.25rem;line-height:1.75rem}}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
import * as C$2 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { BrowserWalletNotInstalledError, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses as getAddresses$4, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
import { createPortal } from "react-dom";
function getDefaultExportFromCjs$1(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(A) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(A, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(A, 0);
  try {
    return cachedSetTimeout(A, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, A, 0);
    } catch {
      return cachedSetTimeout.call(this, A, 0);
    }
  }
}
function runClearTimeout(A) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(A);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(A);
  try {
    return cachedClearTimeout(A);
  } catch {
    try {
      return cachedClearTimeout.call(null, A);
    } catch {
      return cachedClearTimeout.call(this, A);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var A = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var B = queue.length; B; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < B; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, B = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(A);
  }
}
process.nextTick = function(A) {
  var B = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var L = 1; L < arguments.length; L++)
      B[L - 1] = arguments[L];
  queue.push(new Item(A, B)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(A, B) {
  this.fun = A, this.array = B;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(A) {
  return [];
};
process.binding = function(A) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(A) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
function getAugmentedNamespace(A) {
  if (A.__esModule) return A;
  var B = A.default;
  if (typeof B == "function") {
    var L = function K() {
      return this instanceof K ? Reflect.construct(B, arguments, this.constructor) : B.apply(this, arguments);
    };
    L.prototype = B.prototype;
  } else L = {};
  return Object.defineProperty(L, "__esModule", { value: !0 }), Object.keys(A).forEach(function(K) {
    var J = Object.getOwnPropertyDescriptor(A, K);
    Object.defineProperty(L, K, J.get ? J : {
      enumerable: !0,
      get: function() {
        return A[K];
      }
    });
  }), L;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.fragment"), K = Object.prototype.hasOwnProperty, J = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, W = { key: !0, ref: !0, __self: !0, __source: !0 };
  function V(ne, ie, oe) {
    var re, ce = {}, ke = null, Ce = null;
    oe !== void 0 && (ke = "" + oe), ie.key !== void 0 && (ke = "" + ie.key), ie.ref !== void 0 && (Ce = ie.ref);
    for (re in ie) K.call(ie, re) && !W.hasOwnProperty(re) && (ce[re] = ie[re]);
    if (ne && ne.defaultProps) for (re in ie = ne.defaultProps, ie) ce[re] === void 0 && (ce[re] = ie[re]);
    return { $$typeof: B, type: ne, key: ke, ref: Ce, props: ce, _owner: J.current };
  }
  return reactJsxRuntime_production_min.Fragment = L, reactJsxRuntime_production_min.jsx = V, reactJsxRuntime_production_min.jsxs = V, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), V = Symbol.for("react.provider"), ne = Symbol.for("react.context"), ie = Symbol.for("react.forward_ref"), oe = Symbol.for("react.suspense"), re = Symbol.for("react.suspense_list"), ce = Symbol.for("react.memo"), ke = Symbol.for("react.lazy"), Ce = Symbol.for("react.offscreen"), it = Symbol.iterator, at = "@@iterator";
    function lt(Lt) {
      if (Lt === null || typeof Lt != "object")
        return null;
      var Jt = it && Lt[it] || Lt[at];
      return typeof Jt == "function" ? Jt : null;
    }
    var ht = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function dt(Lt) {
      {
        for (var Jt = arguments.length, er = new Array(Jt > 1 ? Jt - 1 : 0), or = 1; or < Jt; or++)
          er[or - 1] = arguments[or];
        vt("error", Lt, er);
      }
    }
    function vt(Lt, Jt, er) {
      {
        var or = ht.ReactDebugCurrentFrame, vr = or.getStackAddendum();
        vr !== "" && (Jt += "%s", er = er.concat([vr]));
        var Er = er.map(function(Tr) {
          return String(Tr);
        });
        Er.unshift("Warning: " + Jt), Function.prototype.apply.call(console[Lt], console, Er);
      }
    }
    var mt = !1, Pt = !1, $t = !1, qt = !1, At = !1, bt;
    bt = Symbol.for("react.module.reference");
    function xt(Lt) {
      return !!(typeof Lt == "string" || typeof Lt == "function" || Lt === K || Lt === W || At || Lt === J || Lt === oe || Lt === re || qt || Lt === Ce || mt || Pt || $t || typeof Lt == "object" && Lt !== null && (Lt.$$typeof === ke || Lt.$$typeof === ce || Lt.$$typeof === V || Lt.$$typeof === ne || Lt.$$typeof === ie || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Lt.$$typeof === bt || Lt.getModuleId !== void 0));
    }
    function wt(Lt, Jt, er) {
      var or = Lt.displayName;
      if (or)
        return or;
      var vr = Jt.displayName || Jt.name || "";
      return vr !== "" ? er + "(" + vr + ")" : er;
    }
    function Oe(Lt) {
      return Lt.displayName || "Context";
    }
    function rt(Lt) {
      if (Lt == null)
        return null;
      if (typeof Lt.tag == "number" && dt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Lt == "function")
        return Lt.displayName || Lt.name || null;
      if (typeof Lt == "string")
        return Lt;
      switch (Lt) {
        case K:
          return "Fragment";
        case L:
          return "Portal";
        case W:
          return "Profiler";
        case J:
          return "StrictMode";
        case oe:
          return "Suspense";
        case re:
          return "SuspenseList";
      }
      if (typeof Lt == "object")
        switch (Lt.$$typeof) {
          case ne:
            var Jt = Lt;
            return Oe(Jt) + ".Consumer";
          case V:
            var er = Lt;
            return Oe(er._context) + ".Provider";
          case ie:
            return wt(Lt, Lt.render, "ForwardRef");
          case ce:
            var or = Lt.displayName || null;
            return or !== null ? or : rt(Lt.type) || "Memo";
          case ke: {
            var vr = Lt, Er = vr._payload, Tr = vr._init;
            try {
              return rt(Tr(Er));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var pe = Object.assign, nt = 0, ot, st, ut, pt, ft, yt, ct;
    function Et() {
    }
    Et.__reactDisabledLog = !0;
    function Nt() {
      {
        if (nt === 0) {
          ot = console.log, st = console.info, ut = console.warn, pt = console.error, ft = console.group, yt = console.groupCollapsed, ct = console.groupEnd;
          var Lt = {
            configurable: !0,
            enumerable: !0,
            value: Et,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Lt,
            log: Lt,
            warn: Lt,
            error: Lt,
            group: Lt,
            groupCollapsed: Lt,
            groupEnd: Lt
          });
        }
        nt++;
      }
    }
    function jt() {
      {
        if (nt--, nt === 0) {
          var Lt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: pe({}, Lt, {
              value: ot
            }),
            info: pe({}, Lt, {
              value: st
            }),
            warn: pe({}, Lt, {
              value: ut
            }),
            error: pe({}, Lt, {
              value: pt
            }),
            group: pe({}, Lt, {
              value: ft
            }),
            groupCollapsed: pe({}, Lt, {
              value: yt
            }),
            groupEnd: pe({}, Lt, {
              value: ct
            })
          });
        }
        nt < 0 && dt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ot = ht.ReactCurrentDispatcher, Bt;
    function Tt(Lt, Jt, er) {
      {
        if (Bt === void 0)
          try {
            throw Error();
          } catch (vr) {
            var or = vr.stack.trim().match(/\n( *(at )?)/);
            Bt = or && or[1] || "";
          }
        return `
` + Bt + Lt;
      }
    }
    var Ut = !1, Gt;
    {
      var It = typeof WeakMap == "function" ? WeakMap : Map;
      Gt = new It();
    }
    function Mt(Lt, Jt) {
      if (!Lt || Ut)
        return "";
      {
        var er = Gt.get(Lt);
        if (er !== void 0)
          return er;
      }
      var or;
      Ut = !0;
      var vr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Er;
      Er = Ot.current, Ot.current = null, Nt();
      try {
        if (Jt) {
          var Tr = function() {
            throw Error();
          };
          if (Object.defineProperty(Tr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Tr, []);
            } catch (Lr) {
              or = Lr;
            }
            Reflect.construct(Lt, [], Tr);
          } else {
            try {
              Tr.call();
            } catch (Lr) {
              or = Lr;
            }
            Lt.call(Tr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Lr) {
            or = Lr;
          }
          Lt();
        }
      } catch (Lr) {
        if (Lr && or && typeof Lr.stack == "string") {
          for (var Pr = Lr.stack.split(`
`), Nr = or.stack.split(`
`), qr = Pr.length - 1, Fr = Nr.length - 1; qr >= 1 && Fr >= 0 && Pr[qr] !== Nr[Fr]; )
            Fr--;
          for (; qr >= 1 && Fr >= 0; qr--, Fr--)
            if (Pr[qr] !== Nr[Fr]) {
              if (qr !== 1 || Fr !== 1)
                do
                  if (qr--, Fr--, Fr < 0 || Pr[qr] !== Nr[Fr]) {
                    var Ur = `
` + Pr[qr].replace(" at new ", " at ");
                    return Lt.displayName && Ur.includes("<anonymous>") && (Ur = Ur.replace("<anonymous>", Lt.displayName)), typeof Lt == "function" && Gt.set(Lt, Ur), Ur;
                  }
                while (qr >= 1 && Fr >= 0);
              break;
            }
        }
      } finally {
        Ut = !1, Ot.current = Er, jt(), Error.prepareStackTrace = vr;
      }
      var jr = Lt ? Lt.displayName || Lt.name : "", Dr = jr ? Tt(jr) : "";
      return typeof Lt == "function" && Gt.set(Lt, Dr), Dr;
    }
    function Kt(Lt, Jt, er) {
      return Mt(Lt, !1);
    }
    function Qt(Lt) {
      var Jt = Lt.prototype;
      return !!(Jt && Jt.isReactComponent);
    }
    function rr(Lt, Jt, er) {
      if (Lt == null)
        return "";
      if (typeof Lt == "function")
        return Mt(Lt, Qt(Lt));
      if (typeof Lt == "string")
        return Tt(Lt);
      switch (Lt) {
        case oe:
          return Tt("Suspense");
        case re:
          return Tt("SuspenseList");
      }
      if (typeof Lt == "object")
        switch (Lt.$$typeof) {
          case ie:
            return Kt(Lt.render);
          case ce:
            return rr(Lt.type, Jt, er);
          case ke: {
            var or = Lt, vr = or._payload, Er = or._init;
            try {
              return rr(Er(vr), Jt, er);
            } catch {
            }
          }
        }
      return "";
    }
    var ar = Object.prototype.hasOwnProperty, ur = {}, hr = ht.ReactDebugCurrentFrame;
    function Yt(Lt) {
      if (Lt) {
        var Jt = Lt._owner, er = rr(Lt.type, Lt._source, Jt ? Jt.type : null);
        hr.setExtraStackFrame(er);
      } else
        hr.setExtraStackFrame(null);
    }
    function Rr(Lt, Jt, er, or, vr) {
      {
        var Er = Function.call.bind(ar);
        for (var Tr in Lt)
          if (Er(Lt, Tr)) {
            var Pr = void 0;
            try {
              if (typeof Lt[Tr] != "function") {
                var Nr = Error((or || "React class") + ": " + er + " type `" + Tr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Lt[Tr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Nr.name = "Invariant Violation", Nr;
              }
              Pr = Lt[Tr](Jt, Tr, or, er, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (qr) {
              Pr = qr;
            }
            Pr && !(Pr instanceof Error) && (Yt(vr), dt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", or || "React class", er, Tr, typeof Pr), Yt(null)), Pr instanceof Error && !(Pr.message in ur) && (ur[Pr.message] = !0, Yt(vr), dt("Failed %s type: %s", er, Pr.message), Yt(null));
          }
      }
    }
    var lr = Array.isArray;
    function $r(Lt) {
      return lr(Lt);
    }
    function Br(Lt) {
      {
        var Jt = typeof Symbol == "function" && Symbol.toStringTag, er = Jt && Lt[Symbol.toStringTag] || Lt.constructor.name || "Object";
        return er;
      }
    }
    function dr(Lt) {
      try {
        return Sr(Lt), !1;
      } catch {
        return !0;
      }
    }
    function Sr(Lt) {
      return "" + Lt;
    }
    function Mr(Lt) {
      if (dr(Lt))
        return dt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Br(Lt)), Sr(Lt);
    }
    var br = ht.ReactCurrentOwner, Ir = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Or, Rt, gt;
    gt = {};
    function St(Lt) {
      if (ar.call(Lt, "ref")) {
        var Jt = Object.getOwnPropertyDescriptor(Lt, "ref").get;
        if (Jt && Jt.isReactWarning)
          return !1;
      }
      return Lt.ref !== void 0;
    }
    function Ct(Lt) {
      if (ar.call(Lt, "key")) {
        var Jt = Object.getOwnPropertyDescriptor(Lt, "key").get;
        if (Jt && Jt.isReactWarning)
          return !1;
      }
      return Lt.key !== void 0;
    }
    function Wt(Lt, Jt) {
      if (typeof Lt.ref == "string" && br.current && Jt && br.current.stateNode !== Jt) {
        var er = rt(br.current.type);
        gt[er] || (dt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', rt(br.current.type), Lt.ref), gt[er] = !0);
      }
    }
    function zt(Lt, Jt) {
      {
        var er = function() {
          Or || (Or = !0, dt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Jt));
        };
        er.isReactWarning = !0, Object.defineProperty(Lt, "key", {
          get: er,
          configurable: !0
        });
      }
    }
    function Vt(Lt, Jt) {
      {
        var er = function() {
          Rt || (Rt = !0, dt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Jt));
        };
        er.isReactWarning = !0, Object.defineProperty(Lt, "ref", {
          get: er,
          configurable: !0
        });
      }
    }
    var yr = function(Lt, Jt, er, or, vr, Er, Tr) {
      var Pr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: B,
        // Built-in properties that belong on the element
        type: Lt,
        key: Jt,
        ref: er,
        props: Tr,
        // Record the component responsible for creating this element.
        _owner: Er
      };
      return Pr._store = {}, Object.defineProperty(Pr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Pr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: or
      }), Object.defineProperty(Pr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: vr
      }), Object.freeze && (Object.freeze(Pr.props), Object.freeze(Pr)), Pr;
    };
    function xr(Lt, Jt, er, or, vr) {
      {
        var Er, Tr = {}, Pr = null, Nr = null;
        er !== void 0 && (Mr(er), Pr = "" + er), Ct(Jt) && (Mr(Jt.key), Pr = "" + Jt.key), St(Jt) && (Nr = Jt.ref, Wt(Jt, vr));
        for (Er in Jt)
          ar.call(Jt, Er) && !Ir.hasOwnProperty(Er) && (Tr[Er] = Jt[Er]);
        if (Lt && Lt.defaultProps) {
          var qr = Lt.defaultProps;
          for (Er in qr)
            Tr[Er] === void 0 && (Tr[Er] = qr[Er]);
        }
        if (Pr || Nr) {
          var Fr = typeof Lt == "function" ? Lt.displayName || Lt.name || "Unknown" : Lt;
          Pr && zt(Tr, Fr), Nr && Vt(Tr, Fr);
        }
        return yr(Lt, Pr, Nr, vr, or, br.current, Tr);
      }
    }
    var cr = ht.ReactCurrentOwner, Ar = ht.ReactDebugCurrentFrame;
    function gr(Lt) {
      if (Lt) {
        var Jt = Lt._owner, er = rr(Lt.type, Lt._source, Jt ? Jt.type : null);
        Ar.setExtraStackFrame(er);
      } else
        Ar.setExtraStackFrame(null);
    }
    var _r;
    _r = !1;
    function kr(Lt) {
      return typeof Lt == "object" && Lt !== null && Lt.$$typeof === B;
    }
    function Cr() {
      {
        if (cr.current) {
          var Lt = rt(cr.current.type);
          if (Lt)
            return `

Check the render method of \`` + Lt + "`.";
        }
        return "";
      }
    }
    function Ft(Lt) {
      return "";
    }
    var kt = {};
    function Dt(Lt) {
      {
        var Jt = Cr();
        if (!Jt) {
          var er = typeof Lt == "string" ? Lt : Lt.displayName || Lt.name;
          er && (Jt = `

Check the top-level render call using <` + er + ">.");
        }
        return Jt;
      }
    }
    function Ht(Lt, Jt) {
      {
        if (!Lt._store || Lt._store.validated || Lt.key != null)
          return;
        Lt._store.validated = !0;
        var er = Dt(Jt);
        if (kt[er])
          return;
        kt[er] = !0;
        var or = "";
        Lt && Lt._owner && Lt._owner !== cr.current && (or = " It was passed a child from " + rt(Lt._owner.type) + "."), gr(Lt), dt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', er, or), gr(null);
      }
    }
    function Xt(Lt, Jt) {
      {
        if (typeof Lt != "object")
          return;
        if ($r(Lt))
          for (var er = 0; er < Lt.length; er++) {
            var or = Lt[er];
            kr(or) && Ht(or, Jt);
          }
        else if (kr(Lt))
          Lt._store && (Lt._store.validated = !0);
        else if (Lt) {
          var vr = lt(Lt);
          if (typeof vr == "function" && vr !== Lt.entries)
            for (var Er = vr.call(Lt), Tr; !(Tr = Er.next()).done; )
              kr(Tr.value) && Ht(Tr.value, Jt);
        }
      }
    }
    function Zt(Lt) {
      {
        var Jt = Lt.type;
        if (Jt == null || typeof Jt == "string")
          return;
        var er;
        if (typeof Jt == "function")
          er = Jt.propTypes;
        else if (typeof Jt == "object" && (Jt.$$typeof === ie || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Jt.$$typeof === ce))
          er = Jt.propTypes;
        else
          return;
        if (er) {
          var or = rt(Jt);
          Rr(er, Lt.props, "prop", or, Lt);
        } else if (Jt.PropTypes !== void 0 && !_r) {
          _r = !0;
          var vr = rt(Jt);
          dt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", vr || "Unknown");
        }
        typeof Jt.getDefaultProps == "function" && !Jt.getDefaultProps.isReactClassApproved && dt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function tr(Lt) {
      {
        for (var Jt = Object.keys(Lt.props), er = 0; er < Jt.length; er++) {
          var or = Jt[er];
          if (or !== "children" && or !== "key") {
            gr(Lt), dt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", or), gr(null);
            break;
          }
        }
        Lt.ref !== null && (gr(Lt), dt("Invalid attribute `ref` supplied to `React.Fragment`."), gr(null));
      }
    }
    var nr = {};
    function fr(Lt, Jt, er, or, vr, Er) {
      {
        var Tr = xt(Lt);
        if (!Tr) {
          var Pr = "";
          (Lt === void 0 || typeof Lt == "object" && Lt !== null && Object.keys(Lt).length === 0) && (Pr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Nr = Ft();
          Nr ? Pr += Nr : Pr += Cr();
          var qr;
          Lt === null ? qr = "null" : $r(Lt) ? qr = "array" : Lt !== void 0 && Lt.$$typeof === B ? (qr = "<" + (rt(Lt.type) || "Unknown") + " />", Pr = " Did you accidentally export a JSX literal instead of a component?") : qr = typeof Lt, dt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", qr, Pr);
        }
        var Fr = xr(Lt, Jt, er, vr, Er);
        if (Fr == null)
          return Fr;
        if (Tr) {
          var Ur = Jt.children;
          if (Ur !== void 0)
            if (or)
              if ($r(Ur)) {
                for (var jr = 0; jr < Ur.length; jr++)
                  Xt(Ur[jr], Lt);
                Object.freeze && Object.freeze(Ur);
              } else
                dt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Xt(Ur, Lt);
        }
        if (ar.call(Jt, "key")) {
          var Dr = rt(Lt), Lr = Object.keys(Jt).filter(function(Gr) {
            return Gr !== "key";
          }), Hr = Lr.length > 0 ? "{key: someKey, " + Lr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!nr[Dr + Hr]) {
            var Wr = Lr.length > 0 ? "{" + Lr.join(": ..., ") + ": ...}" : "{}";
            dt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hr, Dr, Wr, Dr), nr[Dr + Hr] = !0;
          }
        }
        return Lt === K ? tr(Fr) : Zt(Fr), Fr;
      }
    }
    function ir(Lt, Jt, er) {
      return fr(Lt, Jt, er, !0);
    }
    function pr(Lt, Jt, er) {
      return fr(Lt, Jt, er, !1);
    }
    var wr = pr, sr = ir;
    reactJsxRuntime_development.Fragment = K, reactJsxRuntime_development.jsx = wr, reactJsxRuntime_development.jsxs = sr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [A, B] = useState(!1);
  return useEffect(() => {
    B(!0);
  }, []), A;
}
const KEY_PREFIX = "wallie";
function isBrowser() {
  return typeof window < "u";
}
function getItemFromLocalStorage(A) {
  if (!isBrowser())
    return null;
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${A} even though environment is not a browser.`
  );
  const B = `${KEY_PREFIX}_${A}`;
  try {
    const L = window.localStorage.getItem(B);
    return L != null ? JSON.parse(L) : null;
  } catch (L) {
    return console.error(`Error retrieving ${B} from localStorage`, L), null;
  }
}
function setItemToLocalStorage(A, B) {
  if (!isBrowser())
    return;
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${A} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${A}`;
  try {
    B ? window.localStorage.setItem(L, JSON.stringify(B)) : window.localStorage.removeItem(L);
  } catch (K) {
    console.error(`Error saving ${L} to localStorage`, K);
  }
}
function useLocalStorage(A, B, L = {}) {
  const { initializeWithValue: K = !0 } = L, J = useCallback(() => {
    const ie = getItemFromLocalStorage(A);
    return ie || (setItemToLocalStorage(A, B), B);
  }, [B, A]), [W, V] = useState(() => K ? J() : B), ne = useCallback(
    (ie) => {
      setItemToLocalStorage(A, ie), V(ie);
    },
    [A]
  );
  return useEffect(() => {
    V(J());
  }, [A]), [W, ne];
}
var Network = /* @__PURE__ */ ((A) => (A.MAINNET = "mainnet", A.TESTNET = "testnet", A.SIGNET = "signet", A))(Network || {}), Wallet = /* @__PURE__ */ ((A) => (A.UNISAT = "unisat", A.XVERSE = "xverse", A.MAGICEDEN = "magiceden", A.LEATHER = "leather", A.OKX = "okx", A))(Wallet || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, WallieContext = createContext(void 0), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function WallieProvider({
  children: A,
  initialNetwork: B,
  ssr: L = !1
}) {
  if (!B)
    throw new Error("Initial network cannot be empty");
  const [K, J] = useState(B), [W, V] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !L }
  ), [ne, ie] = useLocalStorage(WALLET, null, {
    initializeWithValue: !L
  }), [oe, re] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !L }
  ), [ce, ke] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !L }
  ), [Ce, it] = useState(!1), at = useCallback(() => it(!0), []), lt = useCallback(() => it(!1), []), ht = useCallback(() => {
    V(EMPTY_BIADDRESS_OBJECT), re(EMPTY_BIADDRESS_OBJECT), ke(EMPTY_BIADDRESS_OBJECT), ie(null);
  }, [V, ke, re, ie]), dt = useMemo(
    () => ({
      address: W,
      updateAddress: V,
      publicKey: oe,
      updatePublicKey: re,
      network: K,
      updateNetwork: J,
      wallet: ne,
      updateWallet: ie,
      isModalOpen: Ce,
      openModal: at,
      closeModal: lt,
      format: ce,
      updateFormat: ke,
      disconnectWallet: ht
    }),
    [
      W,
      V,
      oe,
      re,
      K,
      J,
      ne,
      ie,
      Ce,
      at,
      lt,
      ce,
      ke,
      ht
    ]
  );
  return useEffect(() => {
    J(B);
  }, [B]), /* @__PURE__ */ jsxRuntimeExports.jsx(WallieContext.Provider, { value: dt, children: A });
}
function useWallie() {
  const A = useContext(WallieContext);
  if (!A)
    throw new Error("useWallie must be used within WallieProvider");
  return A;
}
var build = { exports: {} };
(function(A, B) {
  (function(L, K) {
    A.exports = K(C__default);
  })(commonjsGlobal, function(L) {
    return function(K) {
      var J = {};
      function W(V) {
        if (J[V]) return J[V].exports;
        var ne = J[V] = { i: V, l: !1, exports: {} };
        return K[V].call(ne.exports, ne, ne.exports, W), ne.l = !0, ne.exports;
      }
      return W.m = K, W.c = J, W.d = function(V, ne, ie) {
        W.o(V, ne) || Object.defineProperty(V, ne, { enumerable: !0, get: ie });
      }, W.r = function(V) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(V, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(V, "__esModule", { value: !0 });
      }, W.t = function(V, ne) {
        if (1 & ne && (V = W(V)), 8 & ne || 4 & ne && typeof V == "object" && V && V.__esModule) return V;
        var ie = /* @__PURE__ */ Object.create(null);
        if (W.r(ie), Object.defineProperty(ie, "default", { enumerable: !0, value: V }), 2 & ne && typeof V != "string") for (var oe in V) W.d(ie, oe, (function(re) {
          return V[re];
        }).bind(null, oe));
        return ie;
      }, W.n = function(V) {
        var ne = V && V.__esModule ? function() {
          return V.default;
        } : function() {
          return V;
        };
        return W.d(ne, "a", ne), ne;
      }, W.o = function(V, ne) {
        return Object.prototype.hasOwnProperty.call(V, ne);
      }, W.p = "/", W(W.s = 1);
    }([function(K, J) {
      K.exports = L;
    }, function(K, J, W) {
      K.exports = W(2);
    }, function(K, J, W) {
      function V(bt, xt, wt) {
        return xt in bt ? Object.defineProperty(bt, xt, { value: wt, enumerable: !0, configurable: !0, writable: !0 }) : bt[xt] = wt, bt;
      }
      function ne(bt, xt) {
        var wt = Object.keys(bt);
        if (Object.getOwnPropertySymbols) {
          var Oe = Object.getOwnPropertySymbols(bt);
          xt && (Oe = Oe.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(bt, rt).enumerable;
          })), wt.push.apply(wt, Oe);
        }
        return wt;
      }
      function ie(bt, xt) {
        if (bt == null) return {};
        var wt, Oe, rt = function(nt, ot) {
          if (nt == null) return {};
          var st, ut, pt = {}, ft = Object.keys(nt);
          for (ut = 0; ut < ft.length; ut++) st = ft[ut], ot.indexOf(st) >= 0 || (pt[st] = nt[st]);
          return pt;
        }(bt, xt);
        if (Object.getOwnPropertySymbols) {
          var pe = Object.getOwnPropertySymbols(bt);
          for (Oe = 0; Oe < pe.length; Oe++) wt = pe[Oe], xt.indexOf(wt) >= 0 || Object.prototype.propertyIsEnumerable.call(bt, wt) && (rt[wt] = bt[wt]);
        }
        return rt;
      }
      W.r(J);
      var oe = W(0), re = W.n(oe), ce = function(bt) {
        for (var xt = 0, wt = 0; wt < bt.length; wt++)
          xt = (xt << 5) - xt + bt.charCodeAt(wt), xt &= xt;
        return Math.abs(xt);
      }, ke = function(bt, xt) {
        return Math.floor(bt / Math.pow(10, xt) % 10);
      }, Ce = function(bt, xt) {
        return !(ke(bt, xt) % 2);
      }, it = function(bt, xt, wt) {
        var Oe = bt % xt;
        return wt && ke(bt, wt) % 2 === 0 ? -Oe : Oe;
      }, at = function(bt, xt, wt) {
        return xt[bt % wt];
      }, lt = function(bt) {
        var xt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 4 }, function(ot, st) {
            return { color: at(pe + st, rt, nt), translateX: it(pe * (st + 1), 40 - (st + 17), 1), translateY: it(pe * (st + 1), 40 - (st + 17), 2), rotate: it(pe * (st + 1), 360), isSquare: Ce(pe, 2) };
          });
        }(bt.name, bt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: bt.size, height: bt.size }, bt.title && oe.createElement("title", null, bt.name), oe.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: bt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 80, height: 80, fill: xt[0].color }), oe.createElement("rect", { x: 10, y: 30, width: 80, height: xt[1].isSquare ? 80 : 10, fill: xt[1].color, transform: "translate(" + xt[1].translateX + " " + xt[1].translateY + ") rotate(" + xt[1].rotate + " 40 40)" }), oe.createElement("circle", { cx: 40, cy: 40, fill: xt[2].color, r: 16, transform: "translate(" + xt[2].translateX + " " + xt[2].translateY + ")" }), oe.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: xt[3].color, transform: "translate(" + xt[3].translateX + " " + xt[3].translateY + ") rotate(" + xt[3].rotate + " 40 40)" })));
      }, ht = function(bt) {
        var xt = function(Oe, rt) {
          var pe = ce(rt), nt = Oe && Oe.length, ot = Array.from({ length: 5 }, function(ut, pt) {
            return at(pe + pt, Oe, nt);
          }), st = [];
          return st[0] = ot[0], st[1] = ot[1], st[2] = ot[1], st[3] = ot[2], st[4] = ot[2], st[5] = ot[3], st[6] = ot[3], st[7] = ot[0], st[8] = ot[4], st;
        }(bt.colors, bt.name), wt = re.a.useId();
        return re.a.createElement("svg", { viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: bt.size, height: bt.size }, bt.title && re.a.createElement("title", null, bt.name), re.a.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, re.a.createElement("rect", { width: 90, height: 90, rx: bt.square ? void 0 : 180, fill: "#FFFFFF" })), re.a.createElement("g", { mask: "url(#".concat(wt, ")") }, re.a.createElement("path", { d: "M0 0h90v45H0z", fill: xt[0] }), re.a.createElement("path", { d: "M0 45h90v45H0z", fill: xt[1] }), re.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: xt[2] }), re.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: xt[3] }), re.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: xt[4] }), re.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: xt[5] }), re.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: xt[6] }), re.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: xt[7] }), re.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: xt[8] })));
      }, dt = function(bt) {
        var xt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 64 }, function(ot, st) {
            return at(pe % (st + 1), rt, nt);
          });
        }(bt.name, bt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: bt.size, height: bt.size }, bt.title && oe.createElement("title", null, bt.name), oe.createElement("mask", { id: wt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: bt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 10, height: 10, fill: xt[0] }), oe.createElement("rect", { x: 20, width: 10, height: 10, fill: xt[1] }), oe.createElement("rect", { x: 40, width: 10, height: 10, fill: xt[2] }), oe.createElement("rect", { x: 60, width: 10, height: 10, fill: xt[3] }), oe.createElement("rect", { x: 10, width: 10, height: 10, fill: xt[4] }), oe.createElement("rect", { x: 30, width: 10, height: 10, fill: xt[5] }), oe.createElement("rect", { x: 50, width: 10, height: 10, fill: xt[6] }), oe.createElement("rect", { x: 70, width: 10, height: 10, fill: xt[7] }), oe.createElement("rect", { y: 10, width: 10, height: 10, fill: xt[8] }), oe.createElement("rect", { y: 20, width: 10, height: 10, fill: xt[9] }), oe.createElement("rect", { y: 30, width: 10, height: 10, fill: xt[10] }), oe.createElement("rect", { y: 40, width: 10, height: 10, fill: xt[11] }), oe.createElement("rect", { y: 50, width: 10, height: 10, fill: xt[12] }), oe.createElement("rect", { y: 60, width: 10, height: 10, fill: xt[13] }), oe.createElement("rect", { y: 70, width: 10, height: 10, fill: xt[14] }), oe.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: xt[15] }), oe.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: xt[16] }), oe.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: xt[17] }), oe.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: xt[18] }), oe.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: xt[19] }), oe.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: xt[20] }), oe.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: xt[21] }), oe.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: xt[22] }), oe.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: xt[23] }), oe.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: xt[24] }), oe.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: xt[25] }), oe.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: xt[26] }), oe.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: xt[27] }), oe.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: xt[28] }), oe.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: xt[29] }), oe.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: xt[30] }), oe.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: xt[31] }), oe.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: xt[32] }), oe.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: xt[33] }), oe.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: xt[34] }), oe.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: xt[35] }), oe.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: xt[36] }), oe.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: xt[37] }), oe.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: xt[38] }), oe.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: xt[39] }), oe.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: xt[40] }), oe.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: xt[41] }), oe.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: xt[42] }), oe.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: xt[43] }), oe.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: xt[44] }), oe.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: xt[45] }), oe.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: xt[46] }), oe.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: xt[47] }), oe.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: xt[48] }), oe.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: xt[49] }), oe.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: xt[50] }), oe.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: xt[51] }), oe.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: xt[52] }), oe.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: xt[53] }), oe.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: xt[54] }), oe.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: xt[55] }), oe.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: xt[56] }), oe.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: xt[57] }), oe.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: xt[58] }), oe.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: xt[59] }), oe.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: xt[60] }), oe.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: xt[61] }), oe.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: xt[62] }), oe.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: xt[63] })));
      }, vt = function(bt) {
        var xt = function(Oe, rt) {
          var pe, nt = ce(Oe), ot = rt && rt.length, st = at(nt, rt, ot), ut = it(nt, 10, 1), pt = ut < 5 ? ut + 4 : ut, ft = it(nt, 10, 2), yt = ft < 5 ? ft + 4 : ft;
          return { wrapperColor: st, faceColor: (pe = st, pe.slice(0, 1) === "#" && (pe = pe.slice(1)), (299 * parseInt(pe.substr(0, 2), 16) + 587 * parseInt(pe.substr(2, 2), 16) + 114 * parseInt(pe.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: at(nt + 13, rt, ot), wrapperTranslateX: pt, wrapperTranslateY: yt, wrapperRotate: it(nt, 360), wrapperScale: 1 + it(nt, 3) / 10, isMouthOpen: Ce(nt, 2), isCircle: Ce(nt, 1), eyeSpread: it(nt, 5), mouthSpread: it(nt, 3), faceRotate: it(nt, 10, 3), faceTranslateX: pt > 6 ? pt / 2 : it(nt, 8, 1), faceTranslateY: yt > 6 ? yt / 2 : it(nt, 7, 2) };
        }(bt.name, bt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: bt.size, height: bt.size }, bt.title && oe.createElement("title", null, bt.name), oe.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, oe.createElement("rect", { width: 36, height: 36, rx: bt.square ? void 0 : 72, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 36, height: 36, fill: xt.backgroundColor }), oe.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + xt.wrapperTranslateX + " " + xt.wrapperTranslateY + ") rotate(" + xt.wrapperRotate + " 18 18) scale(" + xt.wrapperScale + ")", fill: xt.wrapperColor, rx: xt.isCircle ? 36 : 6 }), oe.createElement("g", { transform: "translate(" + xt.faceTranslateX + " " + xt.faceTranslateY + ") rotate(" + xt.faceRotate + " 18 18)" }, xt.isMouthOpen ? oe.createElement("path", { d: "M15 " + (19 + xt.mouthSpread) + "c2 1 4 1 6 0", stroke: xt.faceColor, fill: "none", strokeLinecap: "round" }) : oe.createElement("path", { d: "M13," + (19 + xt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: xt.faceColor }), oe.createElement("rect", { x: 14 - xt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: xt.faceColor }), oe.createElement("rect", { x: 20 + xt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: xt.faceColor }))));
      }, mt = function(bt) {
        var xt = function(rt, pe) {
          var nt = ce(rt), ot = pe && pe.length;
          return Array.from({ length: 4 }, function(st, ut) {
            return at(nt + ut, pe, ot);
          });
        }(bt.name, bt.colors), wt = bt.name.replace(/\s/g, ""), Oe = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: bt.size, height: bt.size }, bt.title && oe.createElement("title", null, bt.name), oe.createElement("mask", { id: Oe, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: bt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(Oe, ")") }, oe.createElement("path", { fill: "url(#gradient_paint0_linear_" + wt + ")", d: "M0 0h80v40H0z" }), oe.createElement("path", { fill: "url(#gradient_paint1_linear_" + wt + ")", d: "M0 40h80v40H0z" })), oe.createElement("defs", null, oe.createElement("linearGradient", { id: "gradient_paint0_linear_" + wt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, oe.createElement("stop", { stopColor: xt[0] }), oe.createElement("stop", { offset: 1, stopColor: xt[1] })), oe.createElement("linearGradient", { id: "gradient_paint1_linear_" + wt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, oe.createElement("stop", { stopColor: xt[2] }), oe.createElement("stop", { offset: 1, stopColor: xt[3] }))));
      }, Pt = function(bt) {
        var xt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 3 }, function(ot, st) {
            return { color: at(pe + st, rt, nt), translateX: it(pe * (st + 1), 8, 1), translateY: it(pe * (st + 1), 8, 2), scale: 1.2 + it(pe * (st + 1), 4) / 10, rotate: it(pe * (st + 1), 360, 1) };
          });
        }(bt.name, bt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: bt.size, height: bt.size }, bt.title && oe.createElement("title", null, bt.name), oe.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: bt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 80, height: 80, fill: xt[0].color }), oe.createElement("path", { filter: "url(#filter_".concat(wt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: xt[1].color, transform: "translate(" + xt[1].translateX + " " + xt[1].translateY + ") rotate(" + xt[1].rotate + " 40 40) scale(" + xt[2].scale + ")" }), oe.createElement("path", { filter: "url(#filter_".concat(wt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: xt[2].color, transform: "translate(" + xt[2].translateX + " " + xt[2].translateY + ") rotate(" + xt[2].rotate + " 40 40) scale(" + xt[2].scale + ")" })), oe.createElement("defs", null, oe.createElement("filter", { id: "filter_".concat(wt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, oe.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), oe.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), oe.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, $t = ["pixel", "bauhaus", "ring", "beam", "sunset", "marble"], qt = { geometric: "beam", abstract: "bauhaus" }, At = function(bt) {
        var xt = bt.variant, wt = xt === void 0 ? "marble" : xt, Oe = bt.colors, rt = Oe === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Oe, pe = bt.name, nt = pe === void 0 ? "Clara Barton" : pe, ot = bt.square, st = ot !== void 0 && ot, ut = bt.title, pt = ut !== void 0 && ut, ft = bt.size, yt = function(ct) {
          for (var Et = 1; Et < arguments.length; Et++) {
            var Nt = arguments[Et] != null ? arguments[Et] : {};
            Et % 2 ? ne(Object(Nt), !0).forEach(function(jt) {
              V(ct, jt, Nt[jt]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ct, Object.getOwnPropertyDescriptors(Nt)) : ne(Object(Nt)).forEach(function(jt) {
              Object.defineProperty(ct, jt, Object.getOwnPropertyDescriptor(Nt, jt));
            });
          }
          return ct;
        }({ colors: rt, name: nt, title: pt, size: ft === void 0 ? 40 : ft, square: st }, ie(bt, ["variant", "colors", "name", "square", "title", "size"]));
        return { pixel: re.a.createElement(dt, yt), bauhaus: re.a.createElement(lt, yt), ring: re.a.createElement(ht, yt), beam: re.a.createElement(vt, yt), sunset: re.a.createElement(mt, yt), marble: re.a.createElement(Pt, yt) }[Object.keys(qt).includes(wt) ? qt[wt] : $t.includes(wt) ? wt : "marble"];
      };
      J.default = At;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
var i$7 = Object.defineProperty, d$5 = (A, B, L) => B in A ? i$7(A, B, { enumerable: !0, configurable: !0, writable: !0, value: L }) : A[B] = L, r$4 = (A, B, L) => (d$5(A, typeof B != "symbol" ? B + "" : B, L), L);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$5 = (A, B) => {
  s$a.isServer ? useEffect(A, B) : useLayoutEffect(A, B);
};
function s$9(A) {
  let B = useRef(A);
  return l$5(() => {
    B.current = A;
  }, [A]), B;
}
let o$6 = function(A) {
  let B = s$9(A);
  return C__default.useCallback((...L) => B.current(...L), [B]);
};
function t$7(A) {
  typeof queueMicrotask == "function" ? queueMicrotask(A) : Promise.resolve().then(A).catch((B) => setTimeout(() => {
    throw B;
  }));
}
function o$5() {
  let A = [], B = { addEventListener(L, K, J, W) {
    return L.addEventListener(K, J, W), B.add(() => L.removeEventListener(K, J, W));
  }, requestAnimationFrame(...L) {
    let K = requestAnimationFrame(...L);
    return B.add(() => cancelAnimationFrame(K));
  }, nextFrame(...L) {
    return B.requestAnimationFrame(() => B.requestAnimationFrame(...L));
  }, setTimeout(...L) {
    let K = setTimeout(...L);
    return B.add(() => clearTimeout(K));
  }, microTask(...L) {
    let K = { current: !0 };
    return t$7(() => {
      K.current && L[0]();
    }), B.add(() => {
      K.current = !1;
    });
  }, style(L, K, J) {
    let W = L.style.getPropertyValue(K);
    return Object.assign(L.style, { [K]: J }), this.add(() => {
      Object.assign(L.style, { [K]: W });
    });
  }, group(L) {
    let K = o$5();
    return L(K), this.add(() => K.dispose());
  }, add(L) {
    return A.push(L), () => {
      let K = A.indexOf(L);
      if (K >= 0) for (let J of A.splice(K, 1)) J();
    };
  }, dispose() {
    for (let L of A.splice(0)) L();
  } };
  return B;
}
function p$3() {
  let [A] = useState(o$5);
  return useEffect(() => () => A.dispose(), [A]), A;
}
function s$8() {
  let A = typeof document > "u";
  return "useSyncExternalStore" in C$2 ? ((B) => B.useSyncExternalStore)(C$2)(() => () => {
  }, () => !1, () => !A) : !1;
}
function l$4() {
  let A = s$8(), [B, L] = C$2.useState(s$a.isHandoffComplete);
  return B && s$a.isHandoffComplete === !1 && L(!1), C$2.useEffect(() => {
    B !== !0 && L(!0);
  }, [B]), C$2.useEffect(() => s$a.handoff(), []), A ? !1 : B;
}
var o$4;
let I$5 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let A = l$4(), [B, L] = C__default.useState(A ? () => s$a.nextId() : null);
  return l$5(() => {
    B === null && L(s$a.nextId());
  }, [B]), B != null ? "" + B : void 0;
};
function u$7(A, B, ...L) {
  if (A in B) {
    let J = B[A];
    return typeof J == "function" ? J(...L) : J;
  }
  let K = new Error(`Tried to handle "${A}" but there is no handler defined. Only defined handlers are: ${Object.keys(B).map((J) => `"${J}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(K, u$7), K;
}
function o$3(A) {
  return s$a.isServer ? null : A instanceof Node ? A.ownerDocument : A != null && A.hasOwnProperty("current") && A.current instanceof Node ? A.current.ownerDocument : document;
}
let c$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((A) => `${A}:not([tabindex='-1'])`).join(",");
var M$2 = ((A) => (A[A.First = 1] = "First", A[A.Previous = 2] = "Previous", A[A.Next = 4] = "Next", A[A.Last = 8] = "Last", A[A.WrapAround = 16] = "WrapAround", A[A.NoScroll = 32] = "NoScroll", A))(M$2 || {}), N$2 = ((A) => (A[A.Error = 0] = "Error", A[A.Overflow = 1] = "Overflow", A[A.Success = 2] = "Success", A[A.Underflow = 3] = "Underflow", A))(N$2 || {}), F$3 = ((A) => (A[A.Previous = -1] = "Previous", A[A.Next = 1] = "Next", A))(F$3 || {});
function f$6(A = document.body) {
  return A == null ? [] : Array.from(A.querySelectorAll(c$5)).sort((B, L) => Math.sign((B.tabIndex || Number.MAX_SAFE_INTEGER) - (L.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((A) => (A[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A))(T$2 || {});
function h$4(A, B = 0) {
  var L;
  return A === ((L = o$3(A)) == null ? void 0 : L.body) ? !1 : u$7(B, { 0() {
    return A.matches(c$5);
  }, 1() {
    let K = A;
    for (; K !== null; ) {
      if (K.matches(c$5)) return !0;
      K = K.parentElement;
    }
    return !1;
  } });
}
function D$3(A) {
  let B = o$3(A);
  o$5().nextFrame(() => {
    B && !h$4(B.activeElement, 0) && y$3(A);
  });
}
var w$2 = ((A) => (A[A.Keyboard = 0] = "Keyboard", A[A.Mouse = 1] = "Mouse", A))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (A) => {
  A.metaKey || A.altKey || A.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (A) => {
  A.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : A.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(A) {
  A == null || A.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(A) {
  var B, L;
  return (L = (B = A == null ? void 0 : A.matches) == null ? void 0 : B.call(A, S$5)) != null ? L : !1;
}
function I$4(A, B = (L) => L) {
  return A.slice().sort((L, K) => {
    let J = B(L), W = B(K);
    if (J === null || W === null) return 0;
    let V = J.compareDocumentPosition(W);
    return V & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : V & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$2(A, B) {
  return O$1(f$6(), B, { relativeTo: A });
}
function O$1(A, B, { sorted: L = !0, relativeTo: K = null, skipElements: J = [] } = {}) {
  let W = Array.isArray(A) ? A.length > 0 ? A[0].ownerDocument : document : A.ownerDocument, V = Array.isArray(A) ? L ? I$4(A) : A : f$6(A);
  J.length > 0 && V.length > 1 && (V = V.filter((Ce) => !J.includes(Ce))), K = K ?? W.activeElement;
  let ne = (() => {
    if (B & 5) return 1;
    if (B & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ie = (() => {
    if (B & 1) return 0;
    if (B & 2) return Math.max(0, V.indexOf(K)) - 1;
    if (B & 4) return Math.max(0, V.indexOf(K)) + 1;
    if (B & 8) return V.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), oe = B & 32 ? { preventScroll: !0 } : {}, re = 0, ce = V.length, ke;
  do {
    if (re >= ce || re + ce <= 0) return 0;
    let Ce = ie + re;
    if (B & 16) Ce = (Ce + ce) % ce;
    else {
      if (Ce < 0) return 3;
      if (Ce >= ce) return 1;
    }
    ke = V[Ce], ke == null || ke.focus(oe), re += ne;
  } while (ke !== W.activeElement);
  return B & 6 && H(ke) && ke.select(), 2;
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$6() || i$6();
}
function d$4(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function J(W) {
      K.current(W);
    }
    return document.addEventListener(A, J, L), () => document.removeEventListener(A, J, L);
  }, [A, L]);
}
function s$7(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function J(W) {
      K.current(W);
    }
    return window.addEventListener(A, J, L), () => window.removeEventListener(A, J, L);
  }, [A, L]);
}
function y$2(A, B, L = !0) {
  let K = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      K.current = L;
    });
  }, [L]);
  function J(V, ne) {
    if (!K.current || V.defaultPrevented) return;
    let ie = ne(V);
    if (ie === null || !ie.getRootNode().contains(ie) || !ie.isConnected) return;
    let oe = function re(ce) {
      return typeof ce == "function" ? re(ce()) : Array.isArray(ce) || ce instanceof Set ? ce : [ce];
    }(A);
    for (let re of oe) {
      if (re === null) continue;
      let ce = re instanceof HTMLElement ? re : re.current;
      if (ce != null && ce.contains(ie) || V.composed && V.composedPath().includes(ce)) return;
    }
    return !h$4(ie, T$2.Loose) && ie.tabIndex !== -1 && V.preventDefault(), B(V, ie);
  }
  let W = useRef(null);
  d$4("pointerdown", (V) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = V.composedPath) == null ? void 0 : ne.call(V)) == null ? void 0 : ie[0]) || V.target);
  }, !0), d$4("mousedown", (V) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = V.composedPath) == null ? void 0 : ne.call(V)) == null ? void 0 : ie[0]) || V.target);
  }, !0), d$4("click", (V) => {
    n$3() || W.current && (J(V, () => W.current), W.current = null);
  }, !0), d$4("touchend", (V) => J(V, () => V.target instanceof HTMLElement ? V.target : null), !0), s$7("blur", (V) => J(V, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...A) {
  return useMemo(() => o$3(...A), [...A]);
}
function i$5(A) {
  var B;
  if (A.type) return A.type;
  let L = (B = A.as) != null ? B : "button";
  if (typeof L == "string" && L.toLowerCase() === "button") return "button";
}
function T$1(A, B) {
  let [L, K] = useState(() => i$5(A));
  return l$5(() => {
    K(i$5(A));
  }, [A.type, A.as]), l$5(() => {
    L || B.current && B.current instanceof HTMLButtonElement && !B.current.hasAttribute("type") && K("button");
  }, [L, B]), L;
}
let u$6 = Symbol();
function T(A, B = !0) {
  return Object.assign(A, { [u$6]: B });
}
function y$1(...A) {
  let B = useRef(A);
  useEffect(() => {
    B.current = A;
  }, [A]);
  let L = o$6((K) => {
    for (let J of B.current) J != null && (typeof J == "function" ? J(K) : J.current = K);
  });
  return A.every((K) => K == null || (K == null ? void 0 : K[u$6])) ? void 0 : L;
}
function t$5(A) {
  return [A.screenX, A.screenY];
}
function u$5() {
  let A = useRef([-1, -1]);
  return { wasMoved(B) {
    let L = t$5(B);
    return A.current[0] === L[0] && A.current[1] === L[1] ? !1 : (A.current = L, !0);
  }, update(B) {
    A.current = t$5(B);
  } };
}
function F$2({ container: A, accept: B, walk: L, enabled: K = !0 }) {
  let J = useRef(B), W = useRef(L);
  useEffect(() => {
    J.current = B, W.current = L;
  }, [B, L]), l$5(() => {
    if (!A || !K) return;
    let V = o$3(A);
    if (!V) return;
    let ne = J.current, ie = W.current, oe = Object.assign((ce) => ne(ce), { acceptNode: ne }), re = V.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, oe, !1);
    for (; re.nextNode(); ) ie(re.currentNode);
  }, [A, K, J, W]);
}
function m$2(A, B) {
  let L = useRef([]), K = o$6(A);
  useEffect(() => {
    let J = [...L.current];
    for (let [W, V] of B.entries()) if (L.current[W] !== V) {
      let ne = K(B, J);
      return L.current = B, ne;
    }
  }, [K, ...B]);
}
function t$4(...A) {
  return Array.from(new Set(A.flatMap((B) => typeof B == "string" ? B.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((A) => (A[A.None = 0] = "None", A[A.RenderStrategy = 1] = "RenderStrategy", A[A.Static = 2] = "Static", A))(O || {}), v$1 = ((A) => (A[A.Unmount = 0] = "Unmount", A[A.Hidden = 1] = "Hidden", A))(v$1 || {});
function C$1({ ourProps: A, theirProps: B, slot: L, defaultTag: K, features: J, visible: W = !0, name: V, mergeRefs: ne }) {
  ne = ne ?? k$1;
  let ie = R(B, A);
  if (W) return m$1(ie, L, K, V, ne);
  let oe = J ?? 0;
  if (oe & 2) {
    let { static: re = !1, ...ce } = ie;
    if (re) return m$1(ce, L, K, V, ne);
  }
  if (oe & 1) {
    let { unmount: re = !0, ...ce } = ie;
    return u$7(re ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...ce, hidden: !0, style: { display: "none" } }, L, K, V, ne);
    } });
  }
  return m$1(ie, L, K, V, ne);
}
function m$1(A, B = {}, L, K, J) {
  let { as: W = L, children: V, refName: ne = "ref", ...ie } = F$1(A, ["unmount", "static"]), oe = A.ref !== void 0 ? { [ne]: A.ref } : {}, re = typeof V == "function" ? V(B) : V;
  "className" in ie && ie.className && typeof ie.className == "function" && (ie.className = ie.className(B));
  let ce = {};
  if (B) {
    let ke = !1, Ce = [];
    for (let [it, at] of Object.entries(B)) typeof at == "boolean" && (ke = !0), at === !0 && Ce.push(it);
    ke && (ce["data-headlessui-state"] = Ce.join(" "));
  }
  if (W === Fragment && Object.keys(x$2(ie)).length > 0) {
    if (!isValidElement(re) || Array.isArray(re) && re.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${K} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(ie).map((at) => `  - ${at}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((at) => `  - ${at}`).join(`
`)].join(`
`));
    let ke = re.props, Ce = typeof (ke == null ? void 0 : ke.className) == "function" ? (...at) => t$4(ke == null ? void 0 : ke.className(...at), ie.className) : t$4(ke == null ? void 0 : ke.className, ie.className), it = Ce ? { className: Ce } : {};
    return cloneElement(re, Object.assign({}, R(re.props, x$2(F$1(ie, ["ref"]))), ce, oe, { ref: J(re.ref, oe.ref) }, it));
  }
  return createElement(W, Object.assign({}, F$1(ie, ["ref"]), W !== Fragment && oe, W !== Fragment && ce), re);
}
function k$1(...A) {
  return A.every((B) => B == null) ? void 0 : (B) => {
    for (let L of A) L != null && (typeof L == "function" ? L(B) : L.current = B);
  };
}
function R(...A) {
  if (A.length === 0) return {};
  if (A.length === 1) return A[0];
  let B = {}, L = {};
  for (let K of A) for (let J in K) J.startsWith("on") && typeof K[J] == "function" ? (L[J] != null || (L[J] = []), L[J].push(K[J])) : B[J] = K[J];
  if (B.disabled || B["aria-disabled"]) return Object.assign(B, Object.fromEntries(Object.keys(L).map((K) => [K, void 0])));
  for (let K in L) Object.assign(B, { [K](J, ...W) {
    let V = L[K];
    for (let ne of V) {
      if ((J instanceof Event || (J == null ? void 0 : J.nativeEvent) instanceof Event) && J.defaultPrevented) return;
      ne(J, ...W);
    }
  } });
  return B;
}
function U$3(A) {
  var B;
  return Object.assign(forwardRef(A), { displayName: (B = A.displayName) != null ? B : A.name });
}
function x$2(A) {
  let B = Object.assign({}, A);
  for (let L in B) B[L] === void 0 && delete B[L];
  return B;
}
function F$1(A, B = []) {
  let L = Object.assign({}, A);
  for (let K of B) K in L && delete L[K];
  return L;
}
let p$2 = "div";
var s$6 = ((A) => (A[A.None = 1] = "None", A[A.Focusable = 2] = "Focusable", A[A.Hidden = 4] = "Hidden", A))(s$6 || {});
function l$3(A, B) {
  var L;
  let { features: K = 1, ...J } = A, W = { ref: B, "aria-hidden": (K & 2) === 2 ? !0 : (L = J["aria-hidden"]) != null ? L : void 0, hidden: (K & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(K & 4) === 4 && (K & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: W, theirProps: J, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let u$4 = U$3(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((A) => (A[A.Open = 1] = "Open", A[A.Closed = 2] = "Closed", A[A.Closing = 4] = "Closing", A[A.Opening = 8] = "Opening", A))(d$3 || {});
function u$3() {
  return useContext(n$1);
}
function s$5({ value: A, children: B }) {
  return C__default.createElement(n$1.Provider, { value: A }, B);
}
function t$3(A) {
  function B() {
    document.readyState !== "loading" && (A(), document.removeEventListener("DOMContentLoaded", B));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", B), B());
}
let t$2 = [];
t$3(() => {
  function A(B) {
    B.target instanceof HTMLElement && B.target !== document.body && t$2[0] !== B.target && (t$2.unshift(B.target), t$2 = t$2.filter((L) => L != null && L.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", A, { capture: !0 }), window.addEventListener("mousedown", A, { capture: !0 }), window.addEventListener("focus", A, { capture: !0 }), document.body.addEventListener("click", A, { capture: !0 }), document.body.addEventListener("mousedown", A, { capture: !0 }), document.body.addEventListener("focus", A, { capture: !0 });
});
function r$3(A) {
  let B = A.parentElement, L = null;
  for (; B && !(B instanceof HTMLFieldSetElement); ) B instanceof HTMLLegendElement && (L = B), B = B.parentElement;
  let K = (B == null ? void 0 : B.getAttribute("disabled")) === "";
  return K && i$4(L) ? !1 : K;
}
function i$4(A) {
  if (!A) return !1;
  let B = A.previousElementSibling;
  for (; B !== null; ) {
    if (B instanceof HTMLLegendElement) return !1;
    B = B.previousElementSibling;
  }
  return !0;
}
function u$2(A) {
  throw new Error("Unexpected object: " + A);
}
var c$4 = ((A) => (A[A.First = 0] = "First", A[A.Previous = 1] = "Previous", A[A.Next = 2] = "Next", A[A.Last = 3] = "Last", A[A.Specific = 4] = "Specific", A[A.Nothing = 5] = "Nothing", A))(c$4 || {});
function f$5(A, B) {
  let L = B.resolveItems();
  if (L.length <= 0) return null;
  let K = B.resolveActiveIndex(), J = K ?? -1;
  switch (A.focus) {
    case 0: {
      for (let W = 0; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 1: {
      for (let W = J - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 2: {
      for (let W = J + 1; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 3: {
      for (let W = L.length - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 4: {
      for (let W = 0; W < L.length; ++W) if (B.resolveId(L[W], W, L) === A.id) return W;
      return K;
    }
    case 5:
      return null;
    default:
      u$2(A);
  }
}
var o$2 = ((A) => (A.Space = " ", A.Enter = "Enter", A.Escape = "Escape", A.Backspace = "Backspace", A.Delete = "Delete", A.ArrowLeft = "ArrowLeft", A.ArrowUp = "ArrowUp", A.ArrowRight = "ArrowRight", A.ArrowDown = "ArrowDown", A.Home = "Home", A.End = "End", A.PageUp = "PageUp", A.PageDown = "PageDown", A.Tab = "Tab", A))(o$2 || {});
function E(A, B, L, K) {
  let J = s$9(L);
  useEffect(() => {
    A = A ?? window;
    function W(V) {
      J.current(V);
    }
    return A.addEventListener(B, W, K), () => A.removeEventListener(B, W, K);
  }, [A, B, K]);
}
function f$4() {
  let A = useRef(!1);
  return l$5(() => (A.current = !0, () => {
    A.current = !1;
  }), []), A;
}
function c$3(A) {
  let B = o$6(A), L = useRef(!1);
  useEffect(() => (L.current = !1, () => {
    L.current = !0, t$7(() => {
      L.current && B();
    });
  }), [B]);
}
var s$4 = ((A) => (A[A.Forwards = 0] = "Forwards", A[A.Backwards = 1] = "Backwards", A))(s$4 || {});
function n() {
  let A = useRef(0);
  return s$7("keydown", (B) => {
    B.key === "Tab" && (A.current = B.shiftKey ? 1 : 0);
  }, !0), A;
}
function P(A) {
  if (!A) return /* @__PURE__ */ new Set();
  if (typeof A == "function") return new Set(A());
  let B = /* @__PURE__ */ new Set();
  for (let L of A.current) L.current instanceof HTMLElement && B.add(L.current);
  return B;
}
let X = "div";
var _$1 = ((A) => (A[A.None = 1] = "None", A[A.InitialFocus = 2] = "InitialFocus", A[A.TabLock = 4] = "TabLock", A[A.FocusLock = 8] = "FocusLock", A[A.RestoreFocus = 16] = "RestoreFocus", A[A.All = 30] = "All", A))(_$1 || {});
function z(A, B) {
  let L = useRef(null), K = y$1(L, B), { initialFocus: J, containers: W, features: V = 30, ...ne } = A;
  l$4() || (V = 1);
  let ie = n$2(L);
  Y({ ownerDocument: ie }, !!(V & 16));
  let oe = Z({ ownerDocument: ie, container: L, initialFocus: J }, !!(V & 2));
  $({ ownerDocument: ie, container: L, containers: W, previousActiveElement: oe }, !!(V & 8));
  let re = n(), ce = o$6((at) => {
    let lt = L.current;
    lt && ((ht) => ht())(() => {
      u$7(re.current, { [s$4.Forwards]: () => {
        O$1(lt, M$2.First, { skipElements: [at.relatedTarget] });
      }, [s$4.Backwards]: () => {
        O$1(lt, M$2.Last, { skipElements: [at.relatedTarget] });
      } });
    });
  }), ke = p$3(), Ce = useRef(!1), it = { ref: K, onKeyDown(at) {
    at.key == "Tab" && (Ce.current = !0, ke.requestAnimationFrame(() => {
      Ce.current = !1;
    }));
  }, onBlur(at) {
    let lt = P(W);
    L.current instanceof HTMLElement && lt.add(L.current);
    let ht = at.relatedTarget;
    ht instanceof HTMLElement && ht.dataset.headlessuiFocusGuard !== "true" && (S$4(lt, ht) || (Ce.current ? O$1(L.current, u$7(re.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: at.target }) : at.target instanceof HTMLElement && y$3(at.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(V & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: ce, features: s$6.Focusable }), C$1({ ourProps: it, theirProps: ne, defaultTag: X, name: "FocusTrap" }), !!(V & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: ce, features: s$6.Focusable }));
}
let D$2 = U$3(z), de$1 = Object.assign(D$2, { features: _$1 });
function Q(A = !0) {
  let B = useRef(t$2.slice());
  return m$2(([L], [K]) => {
    K === !0 && L === !1 && t$7(() => {
      B.current.splice(0);
    }), K === !1 && L === !0 && (B.current = t$2.slice());
  }, [A, t$2, B]), o$6(() => {
    var L;
    return (L = B.current.find((K) => K != null && K.isConnected)) != null ? L : null;
  });
}
function Y({ ownerDocument: A }, B) {
  let L = Q(B);
  m$2(() => {
    B || (A == null ? void 0 : A.activeElement) === (A == null ? void 0 : A.body) && y$3(L());
  }, [B]), c$3(() => {
    B && y$3(L());
  });
}
function Z({ ownerDocument: A, container: B, initialFocus: L }, K) {
  let J = useRef(null), W = f$4();
  return m$2(() => {
    if (!K) return;
    let V = B.current;
    V && t$7(() => {
      if (!W.current) return;
      let ne = A == null ? void 0 : A.activeElement;
      if (L != null && L.current) {
        if ((L == null ? void 0 : L.current) === ne) {
          J.current = ne;
          return;
        }
      } else if (V.contains(ne)) {
        J.current = ne;
        return;
      }
      L != null && L.current ? y$3(L.current) : O$1(V, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), J.current = A == null ? void 0 : A.activeElement;
    });
  }, [K]), J;
}
function $({ ownerDocument: A, container: B, containers: L, previousActiveElement: K }, J) {
  let W = f$4();
  E(A == null ? void 0 : A.defaultView, "focus", (V) => {
    if (!J || !W.current) return;
    let ne = P(L);
    B.current instanceof HTMLElement && ne.add(B.current);
    let ie = K.current;
    if (!ie) return;
    let oe = V.target;
    oe && oe instanceof HTMLElement ? S$4(ne, oe) ? (K.current = oe, y$3(oe)) : (V.preventDefault(), V.stopPropagation(), y$3(ie)) : y$3(K.current);
  }, !0);
}
function S$4(A, B) {
  for (let L of A) if (L.contains(B)) return !0;
  return !1;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function l$2(A) {
  return C__default.createElement(e.Provider, { value: A.force }, A.children);
}
function F(A) {
  let B = a$5(), L = useContext(_), K = n$2(A), [J, W] = useState(() => {
    if (!B && L !== null || s$a.isServer) return null;
    let V = K == null ? void 0 : K.getElementById("headlessui-portal-root");
    if (V) return V;
    if (K === null) return null;
    let ne = K.createElement("div");
    return ne.setAttribute("id", "headlessui-portal-root"), K.body.appendChild(ne);
  });
  return useEffect(() => {
    J !== null && (K != null && K.body.contains(J) || K == null || K.body.appendChild(J));
  }, [J, K]), useEffect(() => {
    B || L !== null && W(L.current);
  }, [L, W, B]), J;
}
let U$2 = Fragment;
function N$1(A, B) {
  let L = A, K = useRef(null), J = y$1(T((re) => {
    K.current = re;
  }), B), W = n$2(K), V = F(K), [ne] = useState(() => {
    var re;
    return s$a.isServer ? null : (re = W == null ? void 0 : W.createElement("div")) != null ? re : null;
  }), ie = useContext(f$3), oe = l$4();
  return l$5(() => {
    !V || !ne || V.contains(ne) || (ne.setAttribute("data-headlessui-portal", ""), V.appendChild(ne));
  }, [V, ne]), l$5(() => {
    if (ne && ie) return ie.register(ne);
  }, [ie, ne]), c$3(() => {
    var re;
    !V || !ne || (ne instanceof Node && V.contains(ne) && V.removeChild(ne), V.childNodes.length <= 0 && ((re = V.parentElement) == null || re.removeChild(V)));
  }), oe ? !V || !ne ? null : createPortal(C$1({ ourProps: { ref: J }, theirProps: L, defaultTag: U$2, name: "Portal" }), ne) : null;
}
let S$3 = Fragment, _ = createContext(null);
function j(A, B) {
  let { target: L, ...K } = A, J = { ref: y$1(B) };
  return C__default.createElement(_.Provider, { value: L }, C$1({ ourProps: J, theirProps: K, defaultTag: S$3, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee() {
  let A = useContext(f$3), B = useRef([]), L = o$6((W) => (B.current.push(W), A && A.register(W), () => K(W))), K = o$6((W) => {
    let V = B.current.indexOf(W);
    V !== -1 && B.current.splice(V, 1), A && A.unregister(W);
  }), J = useMemo(() => ({ register: L, unregister: K, portals: B }), [L, K, B]);
  return [B, useMemo(() => function({ children: W }) {
    return C__default.createElement(f$3.Provider, { value: J }, W);
  }, [J])];
}
let D$1 = U$3(N$1), I$3 = U$3(j), te = Object.assign(D$1, { Group: I$3 });
function i$3(A, B) {
  return A === B && (A !== 0 || 1 / A === 1 / B) || A !== A && B !== B;
}
const d$2 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$3, useLayoutEffect: f$2, useDebugValue: p$1 } = C$2;
function y(A, B, L) {
  const K = B(), [{ inst: J }, W] = u$1({ inst: { value: K, getSnapshot: B } });
  return f$2(() => {
    J.value = K, J.getSnapshot = B, r$2(J) && W({ inst: J });
  }, [A, K, B]), h$3(() => (r$2(J) && W({ inst: J }), A(() => {
    r$2(J) && W({ inst: J });
  })), [A]), p$1(K), K;
}
function r$2(A) {
  const B = A.getSnapshot, L = A.value;
  try {
    const K = B();
    return !d$2(L, K);
  } catch {
    return !0;
  }
}
function t$1(A, B, L) {
  return B();
}
const r$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$3 = !r$1, c$2 = s$3 ? t$1 : y, a$4 = "useSyncExternalStore" in C$2 ? ((A) => A.useSyncExternalStore)(C$2) : c$2;
function S$2(A) {
  return a$4(A.subscribe, A.getSnapshot, A.getSnapshot);
}
function a$3(A, B) {
  let L = A(), K = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return L;
  }, subscribe(J) {
    return K.add(J), () => K.delete(J);
  }, dispatch(J, ...W) {
    let V = B[J].call(L, ...W);
    V && (L = V, K.forEach((ne) => ne()));
  } };
}
function c$1() {
  let A;
  return { before({ doc: B }) {
    var L;
    let K = B.documentElement;
    A = ((L = B.defaultView) != null ? L : window).innerWidth - K.clientWidth;
  }, after({ doc: B, d: L }) {
    let K = B.documentElement, J = K.clientWidth - K.offsetWidth, W = A - J;
    L.style(K, "paddingRight", `${W}px`);
  } };
}
function d$1() {
  return t$6() ? { before({ doc: A, d: B, meta: L }) {
    function K(J) {
      return L.containers.flatMap((W) => W()).some((W) => W.contains(J));
    }
    B.microTask(() => {
      var J;
      if (window.getComputedStyle(A.documentElement).scrollBehavior !== "auto") {
        let ne = o$5();
        ne.style(A.documentElement, "scrollBehavior", "auto"), B.add(() => B.microTask(() => ne.dispose()));
      }
      let W = (J = window.scrollY) != null ? J : window.pageYOffset, V = null;
      B.addEventListener(A, "click", (ne) => {
        if (ne.target instanceof HTMLElement) try {
          let ie = ne.target.closest("a");
          if (!ie) return;
          let { hash: oe } = new URL(ie.href), re = A.querySelector(oe);
          re && !K(re) && (V = re);
        } catch {
        }
      }, !0), B.addEventListener(A, "touchstart", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && K(ie.parentElement); ) ie = ie.parentElement;
          B.style(ie, "overscrollBehavior", "contain");
        } else B.style(ne.target, "touchAction", "none");
      }), B.addEventListener(A, "touchmove", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && ie.dataset.headlessuiPortal !== "" && !(ie.scrollHeight > ie.clientHeight || ie.scrollWidth > ie.clientWidth); ) ie = ie.parentElement;
          ie.dataset.headlessuiPortal === "" && ne.preventDefault();
        } else ne.preventDefault();
      }, { passive: !1 }), B.add(() => {
        var ne;
        let ie = (ne = window.scrollY) != null ? ne : window.pageYOffset;
        W !== ie && window.scrollTo(0, W), V && V.isConnected && (V.scrollIntoView({ block: "nearest" }), V = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: A, d: B }) {
    B.style(A.documentElement, "overflow", "hidden");
  } };
}
function m(A) {
  let B = {};
  for (let L of A) Object.assign(B, L(B));
  return B;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(A, B) {
  var L;
  let K = (L = this.get(A)) != null ? L : { doc: A, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return K.count++, K.meta.add(B), this.set(A, K), this;
}, POP(A, B) {
  let L = this.get(A);
  return L && (L.count--, L.meta.delete(B)), this;
}, SCROLL_PREVENT({ doc: A, d: B, meta: L }) {
  let K = { doc: A, d: B, meta: m(L) }, J = [d$1(), c$1(), l$1()];
  J.forEach(({ before: W }) => W == null ? void 0 : W(K)), J.forEach(({ after: W }) => W == null ? void 0 : W(K));
}, SCROLL_ALLOW({ d: A }) {
  A.dispose();
}, TEARDOWN({ doc: A }) {
  this.delete(A);
} });
a$2.subscribe(() => {
  let A = a$2.getSnapshot(), B = /* @__PURE__ */ new Map();
  for (let [L] of A) B.set(L, L.documentElement.style.overflow);
  for (let L of A.values()) {
    let K = B.get(L.doc) === "hidden", J = L.count !== 0;
    (J && !K || !J && K) && a$2.dispatch(L.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", L), L.count === 0 && a$2.dispatch("TEARDOWN", L);
  }
});
function p(A, B, L) {
  let K = S$2(a$2), J = A ? K.get(A) : void 0, W = J ? J.count > 0 : !1;
  return l$5(() => {
    if (!(!A || !B)) return a$2.dispatch("PUSH", A, L), () => a$2.dispatch("POP", A, L);
  }, [B, A]), W;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(A, B = !0) {
  l$5(() => {
    var L;
    if (!B) return;
    let K = typeof A == "function" ? A() : A.current;
    if (!K) return;
    function J() {
      var V;
      if (!K) return;
      let ne = (V = t.get(K)) != null ? V : 1;
      if (ne === 1 ? t.delete(K) : t.set(K, ne - 1), ne !== 1) return;
      let ie = u.get(K);
      ie && (ie["aria-hidden"] === null ? K.removeAttribute("aria-hidden") : K.setAttribute("aria-hidden", ie["aria-hidden"]), K.inert = ie.inert, u.delete(K));
    }
    let W = (L = t.get(K)) != null ? L : 0;
    return t.set(K, W + 1), W !== 0 || (u.set(K, { "aria-hidden": K.getAttribute("aria-hidden"), inert: K.inert }), K.setAttribute("aria-hidden", "true"), K.inert = !0), J;
  }, [A, B]);
}
function N({ defaultContainers: A = [], portals: B, mainTreeNodeRef: L } = {}) {
  var K;
  let J = useRef((K = L == null ? void 0 : L.current) != null ? K : null), W = n$2(J), V = o$6(() => {
    var ne, ie, oe;
    let re = [];
    for (let ce of A) ce !== null && (ce instanceof HTMLElement ? re.push(ce) : "current" in ce && ce.current instanceof HTMLElement && re.push(ce.current));
    if (B != null && B.current) for (let ce of B.current) re.push(ce);
    for (let ce of (ne = W == null ? void 0 : W.querySelectorAll("html > *, body > *")) != null ? ne : []) ce !== document.body && ce !== document.head && ce instanceof HTMLElement && ce.id !== "headlessui-portal-root" && (ce.contains(J.current) || ce.contains((oe = (ie = J.current) == null ? void 0 : ie.getRootNode()) == null ? void 0 : oe.host) || re.some((ke) => ce.contains(ke)) || re.push(ce));
    return re;
  });
  return { resolveContainers: V, contains: o$6((ne) => V().some((ie) => ie.contains(ne))), mainTreeNodeRef: J, MainTreeNode: useMemo(() => function() {
    return L != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: J });
  }, [J, L]) };
}
let a$1 = createContext(() => {
});
a$1.displayName = "StackContext";
var s$2 = ((A) => (A[A.Add = 0] = "Add", A[A.Remove = 1] = "Remove", A))(s$2 || {});
function x$1() {
  return useContext(a$1);
}
function b$2({ children: A, onUpdate: B, type: L, element: K, enabled: J }) {
  let W = x$1(), V = o$6((...ne) => {
    B == null || B(...ne), W(...ne);
  });
  return l$5(() => {
    let ne = J === void 0 || J === !0;
    return ne && V(0, L, K), () => {
      ne && V(1, L, K);
    };
  }, [V, L, K, J]), C__default.createElement(a$1.Provider, { value: V }, A);
}
let d = createContext(null);
function f$1() {
  let A = useContext(d);
  if (A === null) {
    let B = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(B, f$1), B;
  }
  return A;
}
function w$1() {
  let [A, B] = useState([]);
  return [A.length > 0 ? A.join(" ") : void 0, useMemo(() => function(L) {
    let K = o$6((W) => (B((V) => [...V, W]), () => B((V) => {
      let ne = V.slice(), ie = ne.indexOf(W);
      return ie !== -1 && ne.splice(ie, 1), ne;
    }))), J = useMemo(() => ({ register: K, slot: L.slot, name: L.name, props: L.props }), [K, L.slot, L.name, L.props]);
    return C__default.createElement(d.Provider, { value: J }, L.children);
  }, [B])];
}
let I$2 = "p";
function S$1(A, B) {
  let L = I$5(), { id: K = `headlessui-description-${L}`, ...J } = A, W = f$1(), V = y$1(B);
  l$5(() => W.register(K), [K, W.register]);
  let ne = { ref: V, ...W.props, id: K };
  return C$1({ ourProps: ne, theirProps: J, slot: W.slot || {}, defaultTag: I$2, name: W.name || "Description" });
}
let h$2 = U$3(S$1), G = Object.assign(h$2, {});
var Me$1 = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(Me$1 || {}), we = ((A) => (A[A.SetTitleId = 0] = "SetTitleId", A))(we || {});
let He$1 = { 0(A, B) {
  return A.titleId === B.id ? A : { ...A, titleId: B.id };
} }, I$1 = createContext(null);
I$1.displayName = "DialogContext";
function b$1(A) {
  let B = useContext(I$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, b$1), L;
  }
  return B;
}
function Be(A, B, L = () => [document.body]) {
  p(A, B, (K) => {
    var J;
    return { containers: [...(J = K.containers) != null ? J : [], L] };
  });
}
function Ge(A, B) {
  return u$7(B.type, He$1, A, B);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-${L}`, open: J, onClose: W, initialFocus: V, role: ne = "dialog", __demoMode: ie = !1, ...oe } = A, [re, ce] = useState(0), ke = useRef(!1);
  ne = function() {
    return ne === "dialog" || ne === "alertdialog" ? ne : (ke.current || (ke.current = !0, console.warn(`Invalid role [${ne}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Ce = u$3();
  J === void 0 && Ce !== null && (J = (Ce & d$3.Open) === d$3.Open);
  let it = useRef(null), at = y$1(it, B), lt = n$2(it), ht = A.hasOwnProperty("open") || Ce !== null, dt = A.hasOwnProperty("onClose");
  if (!ht && !dt) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!ht) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!dt) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof J != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${J}`);
  if (typeof W != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${W}`);
  let vt = J ? 0 : 1, [mt, Pt] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), $t = o$6(() => W(!1)), qt = o$6((It) => Pt({ type: 0, id: It })), At = l$4() ? ie ? !1 : vt === 0 : !1, bt = re > 1, xt = useContext(I$1) !== null, [wt, Oe] = ee(), rt = { get current() {
    var It;
    return (It = mt.panelRef.current) != null ? It : it.current;
  } }, { resolveContainers: pe, mainTreeNodeRef: nt, MainTreeNode: ot } = N({ portals: wt, defaultContainers: [rt] }), st = bt ? "parent" : "leaf", ut = Ce !== null ? (Ce & d$3.Closing) === d$3.Closing : !1, pt = xt || ut ? !1 : At, ft = useCallback(() => {
    var It, Mt;
    return (Mt = Array.from((It = lt == null ? void 0 : lt.querySelectorAll("body > *")) != null ? It : []).find((Kt) => Kt.id === "headlessui-portal-root" ? !1 : Kt.contains(nt.current) && Kt instanceof HTMLElement)) != null ? Mt : null;
  }, [nt]);
  b$3(ft, pt);
  let yt = bt ? !0 : At, ct = useCallback(() => {
    var It, Mt;
    return (Mt = Array.from((It = lt == null ? void 0 : lt.querySelectorAll("[data-headlessui-portal]")) != null ? It : []).find((Kt) => Kt.contains(nt.current) && Kt instanceof HTMLElement)) != null ? Mt : null;
  }, [nt]);
  b$3(ct, yt), y$2(pe, (It) => {
    It.preventDefault(), $t();
  }, !(!At || bt));
  let Nt = !(bt || vt !== 0);
  E(lt == null ? void 0 : lt.defaultView, "keydown", (It) => {
    Nt && (It.defaultPrevented || It.key === o$2.Escape && (It.preventDefault(), It.stopPropagation(), $t()));
  }), Be(lt, !(ut || vt !== 0 || xt), pe), useEffect(() => {
    if (vt !== 0 || !it.current) return;
    let It = new ResizeObserver((Mt) => {
      for (let Kt of Mt) {
        let Qt = Kt.target.getBoundingClientRect();
        Qt.x === 0 && Qt.y === 0 && Qt.width === 0 && Qt.height === 0 && $t();
      }
    });
    return It.observe(it.current), () => It.disconnect();
  }, [vt, it, $t]);
  let [Ot, Bt] = w$1(), Tt = useMemo(() => [{ dialogState: vt, close: $t, setTitleId: qt }, mt], [vt, mt, $t, qt]), Ut = useMemo(() => ({ open: vt === 0 }), [vt]), Gt = { ref: at, id: K, role: ne, "aria-modal": vt === 0 ? !0 : void 0, "aria-labelledby": mt.titleId, "aria-describedby": Ot };
  return C__default.createElement(b$2, { type: "Dialog", enabled: vt === 0, element: it, onUpdate: o$6((It, Mt) => {
    Mt === "Dialog" && u$7(It, { [s$2.Add]: () => ce((Kt) => Kt + 1), [s$2.Remove]: () => ce((Kt) => Kt - 1) });
  }) }, C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$1.Provider, { value: Tt }, C__default.createElement(te.Group, { target: it }, C__default.createElement(l$2, { force: !1 }, C__default.createElement(Bt, { slot: Ut, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: V, containers: pe, features: At ? u$7(st, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(Oe, null, C$1({ ourProps: Gt, theirProps: oe, slot: Ut, defaultTag: Ne$1, features: Ue, visible: vt === 0, name: "Dialog" }))))))))), C__default.createElement(ot, null));
}
let $e = "div";
function Ye(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-overlay-${L}`, ...J } = A, [{ dialogState: W, close: V }] = b$1("Dialog.Overlay"), ne = y$1(B), ie = o$6((re) => {
    if (re.target === re.currentTarget) {
      if (r$3(re.currentTarget)) return re.preventDefault();
      re.preventDefault(), re.stopPropagation(), V();
    }
  }), oe = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0, onClick: ie }, theirProps: J, slot: oe, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-backdrop-${L}`, ...J } = A, [{ dialogState: W }, V] = b$1("Dialog.Backdrop"), ne = y$1(B);
  useEffect(() => {
    if (V.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [V.panelRef]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0 }, theirProps: J, slot: ie, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-panel-${L}`, ...J } = A, [{ dialogState: W }, V] = b$1("Dialog.Panel"), ne = y$1(B, V.panelRef), ie = useMemo(() => ({ open: W === 0 }), [W]), oe = o$6((re) => {
    re.stopPropagation();
  });
  return C$1({ ourProps: { ref: ne, id: K, onClick: oe }, theirProps: J, slot: ie, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-title-${L}`, ...J } = A, [{ dialogState: W, setTitleId: V }] = b$1("Dialog.Title"), ne = y$1(B);
  useEffect(() => (V(K), () => V(null)), [K, V]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K }, theirProps: J, slot: ie, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(A) {
  var B, L;
  let K = (B = A.innerText) != null ? B : "", J = A.cloneNode(!0);
  if (!(J instanceof HTMLElement)) return K;
  let W = !1;
  for (let ne of J.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ne.remove(), W = !0;
  let V = W ? (L = J.innerText) != null ? L : "" : K;
  return a.test(V) && (V = V.replace(a, "")), V;
}
function g$1(A) {
  let B = A.getAttribute("aria-label");
  if (typeof B == "string") return B.trim();
  let L = A.getAttribute("aria-labelledby");
  if (L) {
    let K = L.split(" ").map((J) => {
      let W = document.getElementById(J);
      if (W) {
        let V = W.getAttribute("aria-label");
        return typeof V == "string" ? V.trim() : o$1(W).trim();
      }
      return null;
    }).filter(Boolean);
    if (K.length > 0) return K.join(", ");
  }
  return o$1(A).trim();
}
function s$1(A) {
  let B = useRef(""), L = useRef("");
  return o$6(() => {
    let K = A.current;
    if (!K) return "";
    let J = K.innerText;
    if (B.current === J) return L.current;
    let W = g$1(K).trim().toLowerCase();
    return B.current = J, L.current = W, W;
  });
}
var me = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(me || {}), de = ((A) => (A[A.Pointer = 0] = "Pointer", A[A.Other = 1] = "Other", A))(de || {}), fe = ((A) => (A[A.OpenMenu = 0] = "OpenMenu", A[A.CloseMenu = 1] = "CloseMenu", A[A.GoToItem = 2] = "GoToItem", A[A.Search = 3] = "Search", A[A.ClearSearch = 4] = "ClearSearch", A[A.RegisterItem = 5] = "RegisterItem", A[A.UnregisterItem = 6] = "UnregisterItem", A))(fe || {});
function w(A, B = (L) => L) {
  let L = A.activeItemIndex !== null ? A.items[A.activeItemIndex] : null, K = I$4(B(A.items.slice()), (W) => W.dataRef.current.domRef.current), J = L ? K.indexOf(L) : null;
  return J === -1 && (J = null), { items: K, activeItemIndex: J };
}
let Te = { 1(A) {
  return A.menuState === 1 ? A : { ...A, activeItemIndex: null, menuState: 1 };
}, 0(A) {
  return A.menuState === 0 ? A : { ...A, __demoMode: !1, menuState: 0 };
}, 2: (A, B) => {
  var L;
  let K = w(A), J = f$5(B, { resolveItems: () => K.items, resolveActiveIndex: () => K.activeItemIndex, resolveId: (W) => W.id, resolveDisabled: (W) => W.dataRef.current.disabled });
  return { ...A, ...K, searchQuery: "", activeItemIndex: J, activationTrigger: (L = B.trigger) != null ? L : 1 };
}, 3: (A, B) => {
  let L = A.searchQuery !== "" ? 0 : 1, K = A.searchQuery + B.value.toLowerCase(), J = (A.activeItemIndex !== null ? A.items.slice(A.activeItemIndex + L).concat(A.items.slice(0, A.activeItemIndex + L)) : A.items).find((V) => {
    var ne;
    return ((ne = V.dataRef.current.textValue) == null ? void 0 : ne.startsWith(K)) && !V.dataRef.current.disabled;
  }), W = J ? A.items.indexOf(J) : -1;
  return W === -1 || W === A.activeItemIndex ? { ...A, searchQuery: K } : { ...A, searchQuery: K, activeItemIndex: W, activationTrigger: 1 };
}, 4(A) {
  return A.searchQuery === "" ? A : { ...A, searchQuery: "", searchActiveItemIndex: null };
}, 5: (A, B) => {
  let L = w(A, (K) => [...K, { id: B.id, dataRef: B.dataRef }]);
  return { ...A, ...L };
}, 6: (A, B) => {
  let L = w(A, (K) => {
    let J = K.findIndex((W) => W.id === B.id);
    return J !== -1 && K.splice(J, 1), K;
  });
  return { ...A, ...L, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C(A) {
  let B = useContext(U$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, C), L;
  }
  return B;
}
function ye$1(A, B) {
  return u$7(B.type, Te, A, B);
}
let Ie = Fragment;
function Me(A, B) {
  let { __demoMode: L = !1, ...K } = A, J = useReducer(ye$1, { __demoMode: L, menuState: L ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: W, itemsRef: V, buttonRef: ne }, ie] = J, oe = y$1(B);
  y$2([ne, V], (Ce, it) => {
    var at;
    ie({ type: 1 }), h$4(it, T$2.Loose) || (Ce.preventDefault(), (at = ne.current) == null || at.focus());
  }, W === 0);
  let re = o$6(() => {
    ie({ type: 1 });
  }), ce = useMemo(() => ({ open: W === 0, close: re }), [W, re]), ke = { ref: oe };
  return C__default.createElement(U$1.Provider, { value: J }, C__default.createElement(s$5, { value: u$7(W, { 0: d$3.Open, 1: d$3.Closed }) }, C$1({ ourProps: ke, theirProps: K, slot: ce, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(A, B) {
  var L;
  let K = I$5(), { id: J = `headlessui-menu-button-${K}`, ...W } = A, [V, ne] = C("Menu.Button"), ie = y$1(V.buttonRef, B), oe = p$3(), re = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), oe.nextFrame(() => ne({ type: 2, focus: c$4.First }));
        break;
      case o$2.ArrowUp:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), oe.nextFrame(() => ne({ type: 2, focus: c$4.Last }));
        break;
    }
  }), ce = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
        at.preventDefault();
        break;
    }
  }), ke = o$6((at) => {
    if (r$3(at.currentTarget)) return at.preventDefault();
    A.disabled || (V.menuState === 0 ? (ne({ type: 1 }), oe.nextFrame(() => {
      var lt;
      return (lt = V.buttonRef.current) == null ? void 0 : lt.focus({ preventScroll: !0 });
    })) : (at.preventDefault(), ne({ type: 0 })));
  }), Ce = useMemo(() => ({ open: V.menuState === 0 }), [V]), it = { ref: ie, id: J, type: T$1(A, V.buttonRef), "aria-haspopup": "menu", "aria-controls": (L = V.itemsRef.current) == null ? void 0 : L.id, "aria-expanded": V.menuState === 0, onKeyDown: re, onKeyUp: ce, onClick: ke };
  return C$1({ ourProps: it, theirProps: W, slot: Ce, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O.RenderStrategy | O.Static;
function Ee(A, B) {
  var L, K;
  let J = I$5(), { id: W = `headlessui-menu-items-${J}`, ...V } = A, [ne, ie] = C("Menu.Items"), oe = y$1(ne.itemsRef, B), re = n$2(ne.itemsRef), ce = p$3(), ke = u$3(), Ce = ke !== null ? (ke & d$3.Open) === d$3.Open : ne.menuState === 0;
  useEffect(() => {
    let dt = ne.itemsRef.current;
    dt && ne.menuState === 0 && dt !== (re == null ? void 0 : re.activeElement) && dt.focus({ preventScroll: !0 });
  }, [ne.menuState, ne.itemsRef, re]), F$2({ container: ne.itemsRef.current, enabled: ne.menuState === 0, accept(dt) {
    return dt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : dt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(dt) {
    dt.setAttribute("role", "none");
  } });
  let it = o$6((dt) => {
    var vt, mt;
    switch (ce.dispose(), dt.key) {
      case o$2.Space:
        if (ne.searchQuery !== "") return dt.preventDefault(), dt.stopPropagation(), ie({ type: 3, value: dt.key });
      case o$2.Enter:
        if (dt.preventDefault(), dt.stopPropagation(), ie({ type: 1 }), ne.activeItemIndex !== null) {
          let { dataRef: Pt } = ne.items[ne.activeItemIndex];
          (mt = (vt = Pt.current) == null ? void 0 : vt.domRef.current) == null || mt.click();
        }
        D$3(ne.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.Next });
      case o$2.ArrowUp:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.First });
      case o$2.End:
      case o$2.PageDown:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.Last });
      case o$2.Escape:
        dt.preventDefault(), dt.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          var Pt;
          return (Pt = ne.buttonRef.current) == null ? void 0 : Pt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        dt.preventDefault(), dt.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          _$2(ne.buttonRef.current, dt.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        dt.key.length === 1 && (ie({ type: 3, value: dt.key }), ce.setTimeout(() => ie({ type: 4 }), 350));
        break;
    }
  }), at = o$6((dt) => {
    switch (dt.key) {
      case o$2.Space:
        dt.preventDefault();
        break;
    }
  }), lt = useMemo(() => ({ open: ne.menuState === 0 }), [ne]), ht = { "aria-activedescendant": ne.activeItemIndex === null || (L = ne.items[ne.activeItemIndex]) == null ? void 0 : L.id, "aria-labelledby": (K = ne.buttonRef.current) == null ? void 0 : K.id, id: W, onKeyDown: it, onKeyUp: at, role: "menu", tabIndex: 0, ref: oe };
  return C$1({ ourProps: ht, theirProps: V, slot: lt, defaultTag: Ae, features: be, visible: Ce, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(A, B) {
  let L = I$5(), { id: K = `headlessui-menu-item-${L}`, disabled: J = !1, ...W } = A, [V, ne] = C("Menu.Item"), ie = V.activeItemIndex !== null ? V.items[V.activeItemIndex].id === K : !1, oe = useRef(null), re = y$1(B, oe);
  l$5(() => {
    if (V.__demoMode || V.menuState !== 0 || !ie || V.activationTrigger === 0) return;
    let Pt = o$5();
    return Pt.requestAnimationFrame(() => {
      var $t, qt;
      (qt = ($t = oe.current) == null ? void 0 : $t.scrollIntoView) == null || qt.call($t, { block: "nearest" });
    }), Pt.dispose;
  }, [V.__demoMode, oe, ie, V.menuState, V.activationTrigger, V.activeItemIndex]);
  let ce = s$1(oe), ke = useRef({ disabled: J, domRef: oe, get textValue() {
    return ce();
  } });
  l$5(() => {
    ke.current.disabled = J;
  }, [ke, J]), l$5(() => (ne({ type: 5, id: K, dataRef: ke }), () => ne({ type: 6, id: K })), [ke, K]);
  let Ce = o$6(() => {
    ne({ type: 1 });
  }), it = o$6((Pt) => {
    if (J) return Pt.preventDefault();
    ne({ type: 1 }), D$3(V.buttonRef.current);
  }), at = o$6(() => {
    if (J) return ne({ type: 2, focus: c$4.Nothing });
    ne({ type: 2, focus: c$4.Specific, id: K });
  }), lt = u$5(), ht = o$6((Pt) => lt.update(Pt)), dt = o$6((Pt) => {
    lt.wasMoved(Pt) && (J || ie || ne({ type: 2, focus: c$4.Specific, id: K, trigger: 0 }));
  }), vt = o$6((Pt) => {
    lt.wasMoved(Pt) && (J || ie && ne({ type: 2, focus: c$4.Nothing }));
  }), mt = useMemo(() => ({ active: ie, disabled: J, close: Ce }), [ie, J, Ce]);
  return C$1({ ourProps: { id: K, ref: re, role: "menuitem", tabIndex: J === !0 ? void 0 : -1, "aria-disabled": J === !0 ? !0 : void 0, disabled: void 0, onClick: it, onFocus: at, onPointerEnter: ht, onMouseEnter: ht, onPointerMove: dt, onMouseMove: dt, onPointerLeave: vt, onMouseLeave: vt }, theirProps: W, slot: mt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c(A = 0) {
  let [B, L] = useState(A), K = f$4(), J = useCallback((ie) => {
    K.current && L((oe) => oe | ie);
  }, [B, K]), W = useCallback((ie) => !!(B & ie), [B]), V = useCallback((ie) => {
    K.current && L((oe) => oe & ~ie);
  }, [L, K]), ne = useCallback((ie) => {
    K.current && L((oe) => oe ^ ie);
  }, [L]);
  return { flags: B, addFlag: J, hasFlag: W, removeFlag: V, toggleFlag: ne };
}
function l(A) {
  let B = { called: !1 };
  return (...L) => {
    if (!B.called) return B.called = !0, A(...L);
  };
}
function g(A, ...B) {
  A && B.length > 0 && A.classList.add(...B);
}
function v(A, ...B) {
  A && B.length > 0 && A.classList.remove(...B);
}
function b(A, B) {
  let L = o$5();
  if (!A) return L.dispose;
  let { transitionDuration: K, transitionDelay: J } = getComputedStyle(A), [W, V] = [K, J].map((ie) => {
    let [oe = 0] = ie.split(",").filter(Boolean).map((re) => re.includes("ms") ? parseFloat(re) : parseFloat(re) * 1e3).sort((re, ce) => ce - re);
    return oe;
  }), ne = W + V;
  if (ne !== 0) {
    L.group((oe) => {
      oe.setTimeout(() => {
        B(), oe.dispose();
      }, ne), oe.addEventListener(A, "transitionrun", (re) => {
        re.target === re.currentTarget && oe.dispose();
      });
    });
    let ie = L.addEventListener(A, "transitionend", (oe) => {
      oe.target === oe.currentTarget && (B(), ie());
    });
  } else B();
  return L.add(() => B()), L.dispose;
}
function M$1(A, B, L, K) {
  let J = L ? "enter" : "leave", W = o$5(), V = K !== void 0 ? l(K) : () => {
  };
  J === "enter" && (A.removeAttribute("hidden"), A.style.display = "");
  let ne = u$7(J, { enter: () => B.enter, leave: () => B.leave }), ie = u$7(J, { enter: () => B.enterTo, leave: () => B.leaveTo }), oe = u$7(J, { enter: () => B.enterFrom, leave: () => B.leaveFrom });
  return v(A, ...B.base, ...B.enter, ...B.enterTo, ...B.enterFrom, ...B.leave, ...B.leaveFrom, ...B.leaveTo, ...B.entered), g(A, ...B.base, ...ne, ...oe), W.nextFrame(() => {
    v(A, ...B.base, ...ne, ...oe), g(A, ...B.base, ...ne, ...ie), b(A, () => (v(A, ...B.base, ...ne), g(A, ...B.base, ...B.entered), V()));
  }), W.dispose;
}
function D({ immediate: A, container: B, direction: L, classes: K, onStart: J, onStop: W }) {
  let V = f$4(), ne = p$3(), ie = s$9(L);
  l$5(() => {
    A && (ie.current = "enter");
  }, [A]), l$5(() => {
    let oe = o$5();
    ne.add(oe.dispose);
    let re = B.current;
    if (re && ie.current !== "idle" && V.current) return oe.dispose(), J.current(ie.current), oe.add(M$1(re, K.current, ie.current === "enter", () => {
      oe.dispose(), W.current(ie.current);
    })), oe.dispose;
  }, [L]);
}
function S(A = "") {
  return A.split(/\s+/).filter((B) => B.length > 1);
}
let I = createContext(null);
I.displayName = "TransitionContext";
var Se = ((A) => (A.Visible = "visible", A.Hidden = "hidden", A))(Se || {});
function ye() {
  let A = useContext(I);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
function xe() {
  let A = useContext(M);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(A) {
  return "children" in A ? U(A.children) : A.current.filter(({ el: B }) => B.current !== null).filter(({ state: B }) => B === "visible").length > 0;
}
function se(A, B) {
  let L = s$9(A), K = useRef([]), J = f$4(), W = p$3(), V = o$6((Ce, it = v$1.Hidden) => {
    let at = K.current.findIndex(({ el: lt }) => lt === Ce);
    at !== -1 && (u$7(it, { [v$1.Unmount]() {
      K.current.splice(at, 1);
    }, [v$1.Hidden]() {
      K.current[at].state = "hidden";
    } }), W.microTask(() => {
      var lt;
      !U(K) && J.current && ((lt = L.current) == null || lt.call(L));
    }));
  }), ne = o$6((Ce) => {
    let it = K.current.find(({ el: at }) => at === Ce);
    return it ? it.state !== "visible" && (it.state = "visible") : K.current.push({ el: Ce, state: "visible" }), () => V(Ce, v$1.Unmount);
  }), ie = useRef([]), oe = useRef(Promise.resolve()), re = useRef({ enter: [], leave: [], idle: [] }), ce = o$6((Ce, it, at) => {
    ie.current.splice(0), B && (B.chains.current[it] = B.chains.current[it].filter(([lt]) => lt !== Ce)), B == null || B.chains.current[it].push([Ce, new Promise((lt) => {
      ie.current.push(lt);
    })]), B == null || B.chains.current[it].push([Ce, new Promise((lt) => {
      Promise.all(re.current[it].map(([ht, dt]) => dt)).then(() => lt());
    })]), it === "enter" ? oe.current = oe.current.then(() => B == null ? void 0 : B.wait.current).then(() => at(it)) : at(it);
  }), ke = o$6((Ce, it, at) => {
    Promise.all(re.current[it].splice(0).map(([lt, ht]) => ht)).then(() => {
      var lt;
      (lt = ie.current.shift()) == null || lt();
    }).then(() => at(it));
  });
  return useMemo(() => ({ children: K, register: ne, unregister: V, onStart: ce, onStop: ke, wait: oe, chains: re }), [ne, V, K, ce, ke, re, oe]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(A) {
  var B;
  let L = {};
  for (let K of Pe) L[K] = (B = A[K]) != null ? B : Ne;
  return L;
}
function Re(A) {
  let B = useRef(ae(A));
  return useEffect(() => {
    B.current = ae(A);
  }, [A]), B;
}
let De = "div", le = O.RenderStrategy;
function He(A, B) {
  var L, K;
  let { beforeEnter: J, afterEnter: W, beforeLeave: V, afterLeave: ne, enter: ie, enterFrom: oe, enterTo: re, entered: ce, leave: ke, leaveFrom: Ce, leaveTo: it, ...at } = A, lt = useRef(null), ht = y$1(lt, B), dt = (L = at.unmount) == null || L ? v$1.Unmount : v$1.Hidden, { show: vt, appear: mt, initial: Pt } = ye(), [$t, qt] = useState(vt ? "visible" : "hidden"), At = xe(), { register: bt, unregister: xt } = At;
  useEffect(() => bt(lt), [bt, lt]), useEffect(() => {
    if (dt === v$1.Hidden && lt.current) {
      if (vt && $t !== "visible") {
        qt("visible");
        return;
      }
      return u$7($t, { hidden: () => xt(lt), visible: () => bt(lt) });
    }
  }, [$t, lt, bt, xt, vt, dt]);
  let wt = s$9({ base: S(at.className), enter: S(ie), enterFrom: S(oe), enterTo: S(re), entered: S(ce), leave: S(ke), leaveFrom: S(Ce), leaveTo: S(it) }), Oe = Re({ beforeEnter: J, afterEnter: W, beforeLeave: V, afterLeave: ne }), rt = l$4();
  useEffect(() => {
    if (rt && $t === "visible" && lt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [lt, $t, rt]);
  let pe = Pt && !mt, nt = mt && vt && Pt, ot = !rt || pe ? "idle" : vt ? "enter" : "leave", st = c(0), ut = o$6((Nt) => u$7(Nt, { enter: () => {
    st.addFlag(d$3.Opening), Oe.current.beforeEnter();
  }, leave: () => {
    st.addFlag(d$3.Closing), Oe.current.beforeLeave();
  }, idle: () => {
  } })), pt = o$6((Nt) => u$7(Nt, { enter: () => {
    st.removeFlag(d$3.Opening), Oe.current.afterEnter();
  }, leave: () => {
    st.removeFlag(d$3.Closing), Oe.current.afterLeave();
  }, idle: () => {
  } })), ft = se(() => {
    qt("hidden"), xt(lt);
  }, At), yt = useRef(!1);
  D({ immediate: nt, container: lt, classes: wt, direction: ot, onStart: s$9((Nt) => {
    yt.current = !0, ft.onStart(lt, Nt, ut);
  }), onStop: s$9((Nt) => {
    yt.current = !1, ft.onStop(lt, Nt, pt), Nt === "leave" && !U(ft) && (qt("hidden"), xt(lt));
  }) });
  let ct = at, Et = { ref: ht };
  return nt ? ct = { ...ct, className: t$4(at.className, ...wt.current.enter, ...wt.current.enterFrom) } : yt.current && (ct.className = t$4(at.className, (K = lt.current) == null ? void 0 : K.className), ct.className === "" && delete ct.className), C__default.createElement(M.Provider, { value: ft }, C__default.createElement(s$5, { value: u$7($t, { visible: d$3.Open, hidden: d$3.Closed }) | st.flags }, C$1({ ourProps: Et, theirProps: ct, defaultTag: De, features: le, visible: $t === "visible", name: "Transition.Child" })));
}
function Fe(A, B) {
  let { show: L, appear: K = !1, unmount: J = !0, ...W } = A, V = useRef(null), ne = y$1(V, B);
  l$4();
  let ie = u$3();
  if (L === void 0 && ie !== null && (L = (ie & d$3.Open) === d$3.Open), ![!0, !1].includes(L)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [oe, re] = useState(L ? "visible" : "hidden"), ce = se(() => {
    re("hidden");
  }), [ke, Ce] = useState(!0), it = useRef([L]);
  l$5(() => {
    ke !== !1 && it.current[it.current.length - 1] !== L && (it.current.push(L), Ce(!1));
  }, [it, L]);
  let at = useMemo(() => ({ show: L, appear: K, initial: ke }), [L, K, ke]);
  useEffect(() => {
    if (L) re("visible");
    else if (!U(ce)) re("hidden");
    else {
      let vt = V.current;
      if (!vt) return;
      let mt = vt.getBoundingClientRect();
      mt.x === 0 && mt.y === 0 && mt.width === 0 && mt.height === 0 && re("hidden");
    }
  }, [L, ce]);
  let lt = { unmount: J }, ht = o$6(() => {
    var vt;
    ke && Ce(!1), (vt = A.beforeEnter) == null || vt.call(A);
  }), dt = o$6(() => {
    var vt;
    ke && Ce(!1), (vt = A.beforeLeave) == null || vt.call(A);
  });
  return C__default.createElement(M.Provider, { value: ce }, C__default.createElement(I.Provider, { value: at }, C$1({ ourProps: { ...lt, as: Fragment, children: C__default.createElement(ue, { ref: ne, ...lt, ...W, beforeEnter: ht, beforeLeave: dt }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: oe === "visible", name: "Transition" })));
}
function _e(A, B) {
  let L = useContext(I) !== null, K = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !L && K ? C__default.createElement(q, { ref: B, ...A }) : C__default.createElement(ue, { ref: B, ...A }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20viewBox='0%200%2040%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3crect%20width='40'%20height='40'%20rx='5'%20fill='%23D13B75'%20/%3e%3cpath%20d='M25.4738%2016.4112L27.0141%2018.091C27.1904%2018.2824%2027.3436%2018.4312%2027.4126%2018.5234C27.8724%2018.9486%2028.1329%2019.5227%2028.1329%2020.1181C28.087%2020.8198%2027.5965%2021.3017%2027.1367%2021.8191L26.0562%2022.9886L25.4968%2023.5981C25.4738%2023.6194%2025.4661%2023.6478%2025.4585%2023.6761C25.4508%2023.7045%2025.4585%2023.7328%2025.4738%2023.7541C25.4891%2023.7824%2025.5044%2023.8037%2025.5351%2023.8179C25.5581%2023.832%2025.5887%2023.8391%2025.6194%2023.8391H31.2442C32.1025%2023.8391%2033.183%2024.5054%2033.1217%2025.5189C33.1217%2025.9796%2032.9148%2026.419%2032.5623%2026.7451C32.2021%2027.0711%2031.7193%2027.2554%2031.2136%2027.2554H22.4008C21.8184%2027.2554%2020.2628%2027.3121%2019.826%2026.0859C19.734%2025.8308%2019.7187%2025.5543%2019.7877%2025.2921C19.9179%2024.9023%2020.1172%2024.5337%2020.3777%2024.2077C20.8222%2023.5981%2021.2973%2022.9957%2021.7724%2022.4074C22.3855%2021.6349%2023.0062%2020.8906%2023.6269%2020.1039C23.6499%2020.0756%2023.6576%2020.0472%2023.6576%2020.0118C23.6576%2019.9763%2023.6423%2019.948%2023.6269%2019.9196L21.3893%2017.4886C21.3739%2017.4744%2021.3586%2017.4602%2021.3356%2017.446C21.3126%2017.4389%2021.2897%2017.4319%2021.2667%2017.4319C21.2437%2017.4319%2021.2207%2017.4389%2021.1977%2017.446C21.1747%2017.4531%2021.1594%2017.4673%2021.1441%2017.4886C20.5463%2018.2257%2017.9178%2021.4931%2017.3584%2022.1593C16.799%2022.8185%2015.4196%2022.861%2014.6533%2022.1593L11.1512%2018.9557C11.1282%2018.9344%2011.0975%2018.9203%2011.0669%2018.9132C11.0362%2018.9061%2011.0056%2018.9132%2010.9749%2018.9203C10.9443%2018.9344%2010.9213%2018.9486%2010.906%2018.977C10.8906%2018.9982%2010.8753%2019.0266%2010.883%2019.0549V25.2141C10.8906%2025.6536%2010.7527%2026.0788%2010.4768%2026.4403C10.2009%2026.8018%209.81777%2027.0711%209.36564%2027.22C9.07443%2027.3121%208.7679%2027.3404%208.46904%2027.2979C8.17017%2027.2554%207.87897%2027.1562%207.63374%2026.9931C7.38086%2026.8301%207.18161%2026.6175%207.04367%2026.3694C6.90573%2026.1214%206.8291%2025.8449%206.8291%2025.5685V14.4905C6.85209%2014.0936%207.00536%2013.7108%207.28123%2013.3919C7.55711%2013.08%207.92495%2012.8532%208.34642%2012.7469C8.7066%2012.6618%209.08976%2012.6618%209.44993%2012.7469C9.81011%2012.839%2010.1396%2013.0091%2010.4078%2013.2572L15.7951%2018.169C15.8104%2018.1832%2015.8334%2018.1973%2015.8487%2018.2044C15.8717%2018.2115%2015.8947%2018.2115%2015.9177%2018.2115C15.9407%2018.2115%2015.9637%2018.2044%2015.979%2018.1902C16.002%2018.1832%2016.0173%2018.169%2016.0327%2018.1477L19.8566%2013.321C20.0329%2013.1225%2020.2551%2012.9666%2020.508%2012.8603C20.7609%2012.754%2021.0368%2012.6902%2021.3126%2012.6902H31.2595C31.5354%2012.6902%2031.8036%2012.7469%2032.0489%2012.8461C32.2941%2012.9524%2032.5163%2013.1013%2032.7002%2013.2856C32.8765%2013.4698%2033.0144%2013.6896%2033.0911%2013.9305C33.1677%2014.1715%2033.1907%2014.4196%2033.1524%2014.6677C33.0834%2015.0929%2032.8458%2015.4827%2032.4857%2015.7592C32.1255%2016.0356%2031.6657%2016.1915%2031.1906%2016.1844H25.6194C25.5887%2016.1844%2025.5657%2016.1915%2025.5428%2016.2057C25.5198%2016.2199%2025.4968%2016.2411%2025.4891%2016.2624C25.4738%2016.2837%2025.4738%2016.312%2025.4738%2016.3333C25.4508%2016.3616%2025.4585%2016.39%2025.4738%2016.4112Z'%20fill='white'%20/%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(A, B = 4, L = 5) {
  if (A.length <= B + L)
    return A;
  const K = A.slice(0, B), J = A.slice(A.length - L);
  return `${K}...${J}`;
}
const WALLET_TO_ICON = {
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: A,
  network: B,
  onViewProfile: L,
  onChangeWallet: K,
  onDisconnectWallet: J,
  renderAvatar: W
}) {
  const { wallet: V } = useWallie();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(qe$1, { as: "section", className: "relative inline-block text-left", children: ({ open: ne }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { className: "ord-wallet-connected-button", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
        W ? W(A, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Avatar,
          {
            size: 28,
            variant: "beam",
            name: A,
            colors: ["#1C2DCB", "#F226B8"]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: WALLET_TO_ICON[V],
            alt: `${V} is connected`
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(A) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[B] ?? B })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: ChevronDownIcon,
          className: `dropdown-button ${ne ? "close-dropdown-button" : "expand-dropdown-button"}`,
          alt: "ord connect dropdown"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      qe,
      {
        as: Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            qe$1.Item,
            {
              as: "button",
              className: "dropdown-button",
              onClick: () => L == null ? void 0 : L(),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(A) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            qe$1.Item,
            {
              as: "button",
              className: "dropdown-button",
              onClick: () => K == null ? void 0 : K(),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            qe$1.Item,
            {
              as: "button",
              className: "dropdown-button",
              onClick: () => J == null ? void 0 : J(),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "logout" })
              ]
            }
          )
        ] })
      }
    )
  ] }) });
}
const WalletIcon = "data:image/svg+xml,%3csvg%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3cpath%20d='M9%206.25C7.61929%206.25%206.5%207.36929%206.5%208.75V21.25C6.5%2022.6308%207.61929%2023.75%209%2023.75H25C26.3808%2023.75%2027.5%2022.6308%2027.5%2021.25V18.75H23.75C21.6789%2018.75%2020%2017.0711%2020%2015C20%2012.9289%2021.6789%2011.25%2023.75%2011.25H27.5V8.75C27.5%207.36929%2026.3808%206.25%2025%206.25H9Z'%20fill='%231C2033'%20/%3e%3cpath%20d='M25%2015C25%2015.6904%2024.4404%2016.25%2023.75%2016.25C23.0596%2016.25%2022.5%2015.6904%2022.5%2015C22.5%2014.3096%2023.0596%2013.75%2023.75%2013.75C24.4404%2013.75%2025%2014.3096%2025%2015Z'%20fill='%231C2033'%20/%3e%3c/svg%3e";
function PreConnectButton({
  openModal: A,
  disabled: B,
  connectButton: L = "Wallet Connect",
  connectButtonComponent: K
}) {
  return K ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: A, "aria-label": "Connect Button", type: "button", className: "w-full", children: K }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      onClick: A,
      disabled: B,
      className: "bg-ord-orange rounded-full flex flex-row md:space-x-2 items-center p-1 pr-2 px-1 md:pr-3 md:px-3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "w-6 md:w-7", src: WalletIcon, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hidden md:block text-ord-blue  mb-1 pr-2", children: L })
      ]
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='19'%20height='19'%20viewBox='0%200%2019%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.07844%204.07811C4.25659%203.90001%204.49818%203.79996%204.75009%203.79996C5.002%203.79996%205.24359%203.90001%205.42174%204.07811L9.50009%208.15646L13.5784%204.07811C13.6661%203.98738%2013.7709%203.915%2013.8868%203.86521C14.0027%203.81542%2014.1274%203.78922%2014.2535%203.78812C14.3796%203.78703%2014.5047%203.81106%2014.6215%203.85883C14.7382%203.9066%2014.8443%203.97714%2014.9335%204.06633C15.0227%204.15553%2015.0933%204.2616%2015.141%204.37835C15.1888%204.4951%2015.2128%204.6202%2015.2117%204.74634C15.2106%204.87248%2015.1844%204.99714%2015.1346%205.11304C15.0848%205.22895%2015.0125%205.33378%2014.9217%205.42141L10.8434%209.49976L14.9217%2013.5781C15.0948%2013.7573%2015.1905%2013.9973%2015.1884%2014.2463C15.1862%2014.4954%2015.0863%2014.7337%2014.9102%2014.9098C14.734%2015.086%2014.4958%2015.1859%2014.2467%2015.1881C13.9976%2015.1902%2013.7576%2015.0945%2013.5784%2014.9214L9.50009%2010.8431L5.42174%2014.9214C5.24257%2015.0945%205.0026%2015.1902%204.75351%2015.1881C4.50442%2015.1859%204.26615%2015.086%204.09001%2014.9098C3.91387%2014.7337%203.81396%2014.4954%203.8118%2014.2463C3.80964%2013.9973%203.90539%2013.7573%204.07844%2013.5781L8.15679%209.49976L4.07844%205.42141C3.90034%205.24326%203.80029%205.00167%203.80029%204.74976C3.80029%204.49785%203.90034%204.25626%204.07844%204.07811Z'%20fill='%23D9D5D2'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
async function waitForUnisatExtensionReady() {
  let A = 0;
  const B = 20;
  for (; A < B; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const L = await window.unisat.getAccounts();
        if (L && L.length > 0)
          return !0;
      } catch {
        break;
      }
    A += 1, await new Promise((L) => {
      setTimeout(L, 100);
    });
  }
  return !1;
}
const LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: A,
  subtitle: B,
  onConnect: L,
  icon: K,
  setErrorMessage: J,
  isDisabled: W,
  isMobileDevice: V
  // renderAvatar,
}) {
  const { wallet: ne, address: ie } = useWallie(), [{ connectedWallet: oe, connectedAddress: re }] = useState({
    connectedWallet: ne,
    connectedAddress: ie
  }), [ce, ke] = useState(!1), Ce = WALLET_TO_NAME[A], it = useCallback(async () => {
    ke(!0), await Promise.race([
      L().then(() => ke(!1)).catch(() => ke(!1)),
      new Promise((lt) => {
        setTimeout(() => lt("timeout"), 5e3);
      })
    ]) === "timeout" ? J(
      "No wallet pop-up? The extension is not responding. Try reloading your browser."
    ) : ke(!1);
  }, [L, J]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      className: "w-full flex flex-row justify-between items-center text-ord-light-gray bg-ord-light-blue hover:bg-ord-light-blue-250 p-2 rounded-lg md:text-xl space-x-4 md:space-x-6 ease-in transition-all duration-100 ease-in-outscale-120",
      onClick: it,
      disabled: W,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "w-5 md:w-8", src: K, alt: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg block font-medium", children: Ce }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-sm font-medium",
              style: { display: V ? "block" : "none" },
              children: B
            }
          )
        ] }),
        oe === A && re.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium pr-3", children: truncateMiddle(re.ordinals) }) }) : null,
        ce && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: 24,
            alt: `${Ce} extension is loading`
          }
        )
      ]
    }
  );
}
const WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download"
  // their www subdomain doesn't work
};
function SelectWalletModal({
  isOpen: A,
  closeModal: B
}) {
  const {
    updateAddress: L,
    network: K,
    updateWallet: J,
    updatePublicKey: W,
    updateFormat: V,
    wallet: ne,
    format: ie,
    address: oe,
    publicKey: re,
    disconnectWallet: ce
  } = useWallie(), [ke, Ce] = useState(""), it = isMobileUserAgent(), at = useCallback(
    (Pt, $t) => {
      $t instanceof BrowserWalletNotInstalledError && window.open(
        WALLET_CHROME_EXTENSION_URL[Pt],
        "_blank",
        "noopener,noreferrer"
      ), Ce($t.message ?? $t.toString()), console.error(`Error while connecting to ${Pt} wallet`, $t), ce();
    },
    [ce]
  ), lt = useCallback(async () => {
    if (K === "testnet") {
      const Pt = new Error(
        "Magic Eden wallet is not supported on testnet"
      );
      return at(Wallet.MAGICEDEN, Pt), !1;
    }
    try {
      Ce("");
      const Pt = await getAddresses(K);
      if (!Pt || Pt.length < 1)
        throw ce(), new Error("Magic Eden via Ordit returned no addresses.");
      const $t = Pt.find(
        (At) => At.format === "segwit" || At.format === "p2sh-p2wpkh"
      );
      if (!$t)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address."
        );
      const qt = Pt.find(
        (At) => At.format === "taproot"
      );
      if (!qt)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address."
        );
      return L({
        ordinals: qt.address,
        payments: $t.address
      }), W({
        ordinals: qt.publicKey,
        payments: $t.publicKey
      }), J(Wallet.MAGICEDEN), V({
        ordinals: qt.format,
        payments: $t.format
      }), B(), !0;
    } catch (Pt) {
      return at(Wallet.MAGICEDEN, Pt), !1;
    }
  }, [
    B,
    ce,
    K,
    at,
    L,
    V,
    W,
    J
  ]), ht = useCallback(
    async ({ readOnly: Pt } = {}) => {
      try {
        Ce("");
        const $t = await getAddresses$1(K, Pt);
        if (!$t || $t.length < 1)
          throw ce(), new Error("Unisat via Ordit returned no addresses.");
        const qt = $t[0];
        return L({
          ordinals: qt.address,
          payments: qt.address
        }), W({
          ordinals: qt.publicKey,
          payments: qt.publicKey
        }), J(Wallet.UNISAT), V({
          ordinals: qt.format,
          payments: qt.format
        }), B(), !0;
      } catch ($t) {
        return at(Wallet.UNISAT, $t), !1;
      }
    },
    [
      B,
      ce,
      K,
      at,
      L,
      V,
      W,
      J
    ]
  ), dt = useCallback(async () => {
    try {
      Ce("");
      const Pt = await getAddresses$2(K);
      if (!Pt || Pt.length < 1)
        throw ce(), new Error("Xverse via Ordit returned no addresses.");
      const $t = Pt.find(
        (At) => At.format === "p2sh-p2wpkh" || At.format === "segwit"
      );
      if (!$t)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address."
        );
      const qt = Pt.find(
        (At) => At.format === "taproot"
      );
      if (!qt)
        throw new Error("Xverse via Ordit did not return a Taproot address.");
      return L({
        ordinals: qt.address,
        payments: $t.address
      }), W({
        ordinals: qt.publicKey,
        payments: $t.publicKey
      }), J(Wallet.XVERSE), V({
        ordinals: qt.format,
        payments: $t.format
      }), B(), !0;
    } catch (Pt) {
      return at(Wallet.XVERSE, Pt), !1;
    }
  }, [
    B,
    ce,
    K,
    at,
    L,
    V,
    W,
    J
  ]), vt = useCallback(async () => {
    try {
      Ce("");
      const Pt = await getAddresses$3(K);
      if (!Pt || Pt.length < 1)
        throw ce(), new Error("Leather via Ordit returned no addresses.");
      const $t = Pt.find(
        (At) => At.format === "segwit"
      );
      if (!$t)
        throw new Error("Leather via Ordit did not return a Segwit address.");
      const qt = Pt.find(
        (At) => At.format === "taproot"
      );
      if (!qt)
        throw new Error("Leather via Ordit did not return a Taproot address.");
      return L({
        ordinals: qt.address,
        payments: $t.address
      }), W({
        ordinals: qt.publicKey,
        payments: $t.publicKey
      }), J(Wallet.LEATHER), V({
        ordinals: qt.format,
        payments: $t.format
      }), B(), !0;
    } catch (Pt) {
      return at(Wallet.LEATHER, Pt), !1;
    }
  }, [
    B,
    ce,
    K,
    at,
    L,
    V,
    W,
    J
  ]), mt = useCallback(async () => {
    try {
      Ce("");
      const Pt = await getAddresses$4(K);
      if (!Pt || Pt.length < 1)
        throw ce(), new Error("OKX via Ordit returned no addresses.");
      const $t = Pt[0];
      return L({
        ordinals: $t.address,
        payments: $t.address
      }), W({
        ordinals: $t.publicKey,
        payments: $t.publicKey
      }), J(Wallet.OKX), V({
        ordinals: $t.format,
        payments: $t.format
      }), B(), !0;
    } catch (Pt) {
      return at(Wallet.OKX, Pt), !1;
    }
  }, [
    B,
    ce,
    K,
    at,
    L,
    V,
    W,
    J
  ]);
  return useEffect(() => {
    if (ne !== Wallet.UNISAT)
      return;
    let Pt = !0, $t = !1;
    const qt = () => ht();
    return oe && re && ie && (async () => {
      const bt = await waitForUnisatExtensionReady();
      if (Pt) {
        if (!bt) {
          ce();
          return;
        }
        $t = await ht({ readOnly: !0 }), Pt && $t && window.unisat.addListener("accountsChanged", qt);
      }
    })(), () => {
      Pt = !1, $t && window.unisat.removeListener("accountsChanged", qt);
    };
  }, [ne, ht, ce]), /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: A, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "z-50 fixed inset-0 overflow-y-auto",
      onClose: B,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-90 md:bg-opacity-75 transition-opacity" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "fixed inset-0 z-10 overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex min-h-full w-full md:w-96 mx-auto items-end justify-center p-4 text-left sm:items-center sm:p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "relative bg-ord-blue-600 transform overflow-hidden rounded-lg p-8 transition-all w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "flex flex-row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  _t.Title,
                  {
                    as: "h3",
                    className: "text-[21px] font-medium leading-8 -mt-1  text-ord-gray",
                    children: "Connect a wallet to continue"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: B,
                    className: "ml-auto",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: CloseModalIcon,
                        alt: "close modal",
                        className: "w-[19px] h-[19px]"
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-ord-light-blue-400 font-medium py-3", children: "Choose a wallet below to connect and continue" }),
              ke && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-ord-alert pb-4", children: ke }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "w-full space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.XVERSE,
                    subtitle: "",
                    onConnect: dt,
                    icon: XverseWalletIcon,
                    setErrorMessage: Ce,
                    isMobileDevice: it
                  }
                ),
                !it || it && K === Network.MAINNET ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.OKX,
                    subtitle: "",
                    onConnect: mt,
                    icon: OKXWalletIcon,
                    setErrorMessage: Ce,
                    isMobileDevice: it
                  }
                ) : null,
                !it && // TODO: remove this once unisat supported on mobile devices
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.UNISAT,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: ht,
                    icon: UnisatWalletIcon,
                    setErrorMessage: Ce,
                    isDisabled: it,
                    isMobileDevice: it
                  }
                ),
                !it && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    WalletButton,
                    {
                      wallet: Wallet.MAGICEDEN,
                      subtitle: "Coming soon on mobile browsing",
                      onConnect: lt,
                      icon: MagicEdenWalletIcon,
                      setErrorMessage: Ce,
                      isDisabled: it,
                      isMobileDevice: it
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    WalletButton,
                    {
                      wallet: Wallet.LEATHER,
                      subtitle: "Coming soon on mobile browsing",
                      onConnect: vt,
                      icon: LeatherWalletIcon,
                      setErrorMessage: Ce,
                      isDisabled: it,
                      isMobileDevice: it
                    }
                  )
                ] })
              ] }) })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  connectButton: A,
  connectButtonComponent: B,
  hideConnectButton: L,
  onViewProfile: K,
  onChangeWalletClick: J,
  onDisconnectWalletClick: W,
  renderAvatar: V
}) {
  const {
    address: ne,
    disconnectWallet: ie,
    network: oe,
    isModalOpen: re,
    openModal: ce,
    closeModal: ke
  } = useWallie(), Ce = useHasMounted(), it = () => L ? null : ne != null && ne.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ne.ordinals,
      network: oe,
      onViewProfile: K,
      onChangeWallet: () => {
        ce(), J == null || J();
      },
      onDisconnectWallet: () => {
        ie(), W == null || W();
      },
      renderAvatar: V
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    PreConnectButton,
    {
      disabled: !Ce,
      connectButton: A,
      connectButtonComponent: B,
      openModal: ce
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    it(),
    Ce ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectWalletModal, { isOpen: re, closeModal: ke }) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(A) {
  var B, L, K, J = dt.prototype = { constructor: dt, toString: null, valueOf: null }, W = new dt(1), V = 20, ne = 4, ie = -7, oe = 21, re = -1e7, ce = 1e7, ke = !1, Ce = 1, it = 0, at = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, lt = "0123456789abcdefghijklmnopqrstuvwxyz", ht = !0;
  function dt(At, bt) {
    var xt, wt, Oe, rt, pe, nt, ot, st, ut = this;
    if (!(ut instanceof dt)) return new dt(At, bt);
    if (bt == null) {
      if (At && At._isBigNumber === !0) {
        ut.s = At.s, !At.c || At.e > ce ? ut.c = ut.e = null : At.e < re ? ut.c = [ut.e = 0] : (ut.e = At.e, ut.c = At.c.slice());
        return;
      }
      if ((nt = typeof At == "number") && At * 0 == 0) {
        if (ut.s = 1 / At < 0 ? (At = -At, -1) : 1, At === ~~At) {
          for (rt = 0, pe = At; pe >= 10; pe /= 10, rt++) ;
          rt > ce ? ut.c = ut.e = null : (ut.e = rt, ut.c = [At]);
          return;
        }
        st = String(At);
      } else {
        if (!isNumeric.test(st = String(At))) return K(ut, st, nt);
        ut.s = st.charCodeAt(0) == 45 ? (st = st.slice(1), -1) : 1;
      }
      (rt = st.indexOf(".")) > -1 && (st = st.replace(".", "")), (pe = st.search(/e/i)) > 0 ? (rt < 0 && (rt = pe), rt += +st.slice(pe + 1), st = st.substring(0, pe)) : rt < 0 && (rt = st.length);
    } else {
      if (intCheck(bt, 2, lt.length, "Base"), bt == 10 && ht)
        return ut = new dt(At), $t(ut, V + ut.e + 1, ne);
      if (st = String(At), nt = typeof At == "number") {
        if (At * 0 != 0) return K(ut, st, nt, bt);
        if (ut.s = 1 / At < 0 ? (st = st.slice(1), -1) : 1, dt.DEBUG && st.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + At);
      } else
        ut.s = st.charCodeAt(0) === 45 ? (st = st.slice(1), -1) : 1;
      for (xt = lt.slice(0, bt), rt = pe = 0, ot = st.length; pe < ot; pe++)
        if (xt.indexOf(wt = st.charAt(pe)) < 0) {
          if (wt == ".") {
            if (pe > rt) {
              rt = ot;
              continue;
            }
          } else if (!Oe && (st == st.toUpperCase() && (st = st.toLowerCase()) || st == st.toLowerCase() && (st = st.toUpperCase()))) {
            Oe = !0, pe = -1, rt = 0;
            continue;
          }
          return K(ut, String(At), nt, bt);
        }
      nt = !1, st = L(st, bt, 10, ut.s), (rt = st.indexOf(".")) > -1 ? st = st.replace(".", "") : rt = st.length;
    }
    for (pe = 0; st.charCodeAt(pe) === 48; pe++) ;
    for (ot = st.length; st.charCodeAt(--ot) === 48; ) ;
    if (st = st.slice(pe, ++ot)) {
      if (ot -= pe, nt && dt.DEBUG && ot > 15 && (At > MAX_SAFE_INTEGER$2 || At !== mathfloor(At)))
        throw Error(tooManyDigits + ut.s * At);
      if ((rt = rt - pe - 1) > ce)
        ut.c = ut.e = null;
      else if (rt < re)
        ut.c = [ut.e = 0];
      else {
        if (ut.e = rt, ut.c = [], pe = (rt + 1) % LOG_BASE, rt < 0 && (pe += LOG_BASE), pe < ot) {
          for (pe && ut.c.push(+st.slice(0, pe)), ot -= LOG_BASE; pe < ot; )
            ut.c.push(+st.slice(pe, pe += LOG_BASE));
          pe = LOG_BASE - (st = st.slice(pe)).length;
        } else
          pe -= ot;
        for (; pe--; st += "0") ;
        ut.c.push(+st);
      }
    } else
      ut.c = [ut.e = 0];
  }
  dt.clone = clone, dt.ROUND_UP = 0, dt.ROUND_DOWN = 1, dt.ROUND_CEIL = 2, dt.ROUND_FLOOR = 3, dt.ROUND_HALF_UP = 4, dt.ROUND_HALF_DOWN = 5, dt.ROUND_HALF_EVEN = 6, dt.ROUND_HALF_CEIL = 7, dt.ROUND_HALF_FLOOR = 8, dt.EUCLID = 9, dt.config = dt.set = function(At) {
    var bt, xt;
    if (At != null)
      if (typeof At == "object") {
        if (At.hasOwnProperty(bt = "DECIMAL_PLACES") && (xt = At[bt], intCheck(xt, 0, MAX, bt), V = xt), At.hasOwnProperty(bt = "ROUNDING_MODE") && (xt = At[bt], intCheck(xt, 0, 8, bt), ne = xt), At.hasOwnProperty(bt = "EXPONENTIAL_AT") && (xt = At[bt], xt && xt.pop ? (intCheck(xt[0], -MAX, 0, bt), intCheck(xt[1], 0, MAX, bt), ie = xt[0], oe = xt[1]) : (intCheck(xt, -MAX, MAX, bt), ie = -(oe = xt < 0 ? -xt : xt))), At.hasOwnProperty(bt = "RANGE"))
          if (xt = At[bt], xt && xt.pop)
            intCheck(xt[0], -MAX, -1, bt), intCheck(xt[1], 1, MAX, bt), re = xt[0], ce = xt[1];
          else if (intCheck(xt, -MAX, MAX, bt), xt)
            re = -(ce = xt < 0 ? -xt : xt);
          else
            throw Error(bignumberError + bt + " cannot be zero: " + xt);
        if (At.hasOwnProperty(bt = "CRYPTO"))
          if (xt = At[bt], xt === !!xt)
            if (xt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                ke = xt;
              else
                throw ke = !xt, Error(bignumberError + "crypto unavailable");
            else
              ke = xt;
          else
            throw Error(bignumberError + bt + " not true or false: " + xt);
        if (At.hasOwnProperty(bt = "MODULO_MODE") && (xt = At[bt], intCheck(xt, 0, 9, bt), Ce = xt), At.hasOwnProperty(bt = "POW_PRECISION") && (xt = At[bt], intCheck(xt, 0, MAX, bt), it = xt), At.hasOwnProperty(bt = "FORMAT"))
          if (xt = At[bt], typeof xt == "object") at = xt;
          else throw Error(bignumberError + bt + " not an object: " + xt);
        if (At.hasOwnProperty(bt = "ALPHABET"))
          if (xt = At[bt], typeof xt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(xt))
            ht = xt.slice(0, 10) == "0123456789", lt = xt;
          else
            throw Error(bignumberError + bt + " invalid: " + xt);
      } else
        throw Error(bignumberError + "Object expected: " + At);
    return {
      DECIMAL_PLACES: V,
      ROUNDING_MODE: ne,
      EXPONENTIAL_AT: [ie, oe],
      RANGE: [re, ce],
      CRYPTO: ke,
      MODULO_MODE: Ce,
      POW_PRECISION: it,
      FORMAT: at,
      ALPHABET: lt
    };
  }, dt.isBigNumber = function(At) {
    if (!At || At._isBigNumber !== !0) return !1;
    if (!dt.DEBUG) return !0;
    var bt, xt, wt = At.c, Oe = At.e, rt = At.s;
    e: if ({}.toString.call(wt) == "[object Array]") {
      if ((rt === 1 || rt === -1) && Oe >= -MAX && Oe <= MAX && Oe === mathfloor(Oe)) {
        if (wt[0] === 0) {
          if (Oe === 0 && wt.length === 1) return !0;
          break e;
        }
        if (bt = (Oe + 1) % LOG_BASE, bt < 1 && (bt += LOG_BASE), String(wt[0]).length == bt) {
          for (bt = 0; bt < wt.length; bt++)
            if (xt = wt[bt], xt < 0 || xt >= BASE || xt !== mathfloor(xt)) break e;
          if (xt !== 0) return !0;
        }
      }
    } else if (wt === null && Oe === null && (rt === null || rt === 1 || rt === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + At);
  }, dt.maximum = dt.max = function() {
    return mt(arguments, -1);
  }, dt.minimum = dt.min = function() {
    return mt(arguments, 1);
  }, dt.random = function() {
    var At = 9007199254740992, bt = Math.random() * At & 2097151 ? function() {
      return mathfloor(Math.random() * At);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(xt) {
      var wt, Oe, rt, pe, nt, ot = 0, st = [], ut = new dt(W);
      if (xt == null ? xt = V : intCheck(xt, 0, MAX), pe = mathceil(xt / LOG_BASE), ke)
        if (crypto.getRandomValues) {
          for (wt = crypto.getRandomValues(new Uint32Array(pe *= 2)); ot < pe; )
            nt = wt[ot] * 131072 + (wt[ot + 1] >>> 11), nt >= 9e15 ? (Oe = crypto.getRandomValues(new Uint32Array(2)), wt[ot] = Oe[0], wt[ot + 1] = Oe[1]) : (st.push(nt % 1e14), ot += 2);
          ot = pe / 2;
        } else if (crypto.randomBytes) {
          for (wt = crypto.randomBytes(pe *= 7); ot < pe; )
            nt = (wt[ot] & 31) * 281474976710656 + wt[ot + 1] * 1099511627776 + wt[ot + 2] * 4294967296 + wt[ot + 3] * 16777216 + (wt[ot + 4] << 16) + (wt[ot + 5] << 8) + wt[ot + 6], nt >= 9e15 ? crypto.randomBytes(7).copy(wt, ot) : (st.push(nt % 1e14), ot += 7);
          ot = pe / 7;
        } else
          throw ke = !1, Error(bignumberError + "crypto unavailable");
      if (!ke)
        for (; ot < pe; )
          nt = bt(), nt < 9e15 && (st[ot++] = nt % 1e14);
      for (pe = st[--ot], xt %= LOG_BASE, pe && xt && (nt = POWS_TEN[LOG_BASE - xt], st[ot] = mathfloor(pe / nt) * nt); st[ot] === 0; st.pop(), ot--) ;
      if (ot < 0)
        st = [rt = 0];
      else {
        for (rt = -1; st[0] === 0; st.splice(0, 1), rt -= LOG_BASE) ;
        for (ot = 1, nt = st[0]; nt >= 10; nt /= 10, ot++) ;
        ot < LOG_BASE && (rt -= LOG_BASE - ot);
      }
      return ut.e = rt, ut.c = st, ut;
    };
  }(), dt.sum = function() {
    for (var At = 1, bt = arguments, xt = new dt(bt[0]); At < bt.length; ) xt = xt.plus(bt[At++]);
    return xt;
  }, L = /* @__PURE__ */ function() {
    var At = "0123456789";
    function bt(xt, wt, Oe, rt) {
      for (var pe, nt = [0], ot, st = 0, ut = xt.length; st < ut; ) {
        for (ot = nt.length; ot--; nt[ot] *= wt) ;
        for (nt[0] += rt.indexOf(xt.charAt(st++)), pe = 0; pe < nt.length; pe++)
          nt[pe] > Oe - 1 && (nt[pe + 1] == null && (nt[pe + 1] = 0), nt[pe + 1] += nt[pe] / Oe | 0, nt[pe] %= Oe);
      }
      return nt.reverse();
    }
    return function(xt, wt, Oe, rt, pe) {
      var nt, ot, st, ut, pt, ft, yt, ct, Et = xt.indexOf("."), Nt = V, jt = ne;
      for (Et >= 0 && (ut = it, it = 0, xt = xt.replace(".", ""), ct = new dt(wt), ft = ct.pow(xt.length - Et), it = ut, ct.c = bt(
        toFixedPoint(coeffToString(ft.c), ft.e, "0"),
        10,
        Oe,
        At
      ), ct.e = ct.c.length), yt = bt(xt, wt, Oe, pe ? (nt = lt, At) : (nt = At, lt)), st = ut = yt.length; yt[--ut] == 0; yt.pop()) ;
      if (!yt[0]) return nt.charAt(0);
      if (Et < 0 ? --st : (ft.c = yt, ft.e = st, ft.s = rt, ft = B(ft, ct, Nt, jt, Oe), yt = ft.c, pt = ft.r, st = ft.e), ot = st + Nt + 1, Et = yt[ot], ut = Oe / 2, pt = pt || ot < 0 || yt[ot + 1] != null, pt = jt < 4 ? (Et != null || pt) && (jt == 0 || jt == (ft.s < 0 ? 3 : 2)) : Et > ut || Et == ut && (jt == 4 || pt || jt == 6 && yt[ot - 1] & 1 || jt == (ft.s < 0 ? 8 : 7)), ot < 1 || !yt[0])
        xt = pt ? toFixedPoint(nt.charAt(1), -Nt, nt.charAt(0)) : nt.charAt(0);
      else {
        if (yt.length = ot, pt)
          for (--Oe; ++yt[--ot] > Oe; )
            yt[ot] = 0, ot || (++st, yt = [1].concat(yt));
        for (ut = yt.length; !yt[--ut]; ) ;
        for (Et = 0, xt = ""; Et <= ut; xt += nt.charAt(yt[Et++])) ;
        xt = toFixedPoint(xt, st, nt.charAt(0));
      }
      return xt;
    };
  }(), B = /* @__PURE__ */ function() {
    function At(wt, Oe, rt) {
      var pe, nt, ot, st, ut = 0, pt = wt.length, ft = Oe % SQRT_BASE, yt = Oe / SQRT_BASE | 0;
      for (wt = wt.slice(); pt--; )
        ot = wt[pt] % SQRT_BASE, st = wt[pt] / SQRT_BASE | 0, pe = yt * ot + st * ft, nt = ft * ot + pe % SQRT_BASE * SQRT_BASE + ut, ut = (nt / rt | 0) + (pe / SQRT_BASE | 0) + yt * st, wt[pt] = nt % rt;
      return ut && (wt = [ut].concat(wt)), wt;
    }
    function bt(wt, Oe, rt, pe) {
      var nt, ot;
      if (rt != pe)
        ot = rt > pe ? 1 : -1;
      else
        for (nt = ot = 0; nt < rt; nt++)
          if (wt[nt] != Oe[nt]) {
            ot = wt[nt] > Oe[nt] ? 1 : -1;
            break;
          }
      return ot;
    }
    function xt(wt, Oe, rt, pe) {
      for (var nt = 0; rt--; )
        wt[rt] -= nt, nt = wt[rt] < Oe[rt] ? 1 : 0, wt[rt] = nt * pe + wt[rt] - Oe[rt];
      for (; !wt[0] && wt.length > 1; wt.splice(0, 1)) ;
    }
    return function(wt, Oe, rt, pe, nt) {
      var ot, st, ut, pt, ft, yt, ct, Et, Nt, jt, Ot, Bt, Tt, Ut, Gt, It, Mt, Kt = wt.s == Oe.s ? 1 : -1, Qt = wt.c, rr = Oe.c;
      if (!Qt || !Qt[0] || !rr || !rr[0])
        return new dt(
          // Return NaN if either NaN, or both Infinity or 0.
          !wt.s || !Oe.s || (Qt ? rr && Qt[0] == rr[0] : !rr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            Qt && Qt[0] == 0 || !rr ? Kt * 0 : Kt / 0
          )
        );
      for (Et = new dt(Kt), Nt = Et.c = [], st = wt.e - Oe.e, Kt = rt + st + 1, nt || (nt = BASE, st = bitFloor(wt.e / LOG_BASE) - bitFloor(Oe.e / LOG_BASE), Kt = Kt / LOG_BASE | 0), ut = 0; rr[ut] == (Qt[ut] || 0); ut++) ;
      if (rr[ut] > (Qt[ut] || 0) && st--, Kt < 0)
        Nt.push(1), pt = !0;
      else {
        for (Ut = Qt.length, It = rr.length, ut = 0, Kt += 2, ft = mathfloor(nt / (rr[0] + 1)), ft > 1 && (rr = At(rr, ft, nt), Qt = At(Qt, ft, nt), It = rr.length, Ut = Qt.length), Tt = It, jt = Qt.slice(0, It), Ot = jt.length; Ot < It; jt[Ot++] = 0) ;
        Mt = rr.slice(), Mt = [0].concat(Mt), Gt = rr[0], rr[1] >= nt / 2 && Gt++;
        do {
          if (ft = 0, ot = bt(rr, jt, It, Ot), ot < 0) {
            if (Bt = jt[0], It != Ot && (Bt = Bt * nt + (jt[1] || 0)), ft = mathfloor(Bt / Gt), ft > 1)
              for (ft >= nt && (ft = nt - 1), yt = At(rr, ft, nt), ct = yt.length, Ot = jt.length; bt(yt, jt, ct, Ot) == 1; )
                ft--, xt(yt, It < ct ? Mt : rr, ct, nt), ct = yt.length, ot = 1;
            else
              ft == 0 && (ot = ft = 1), yt = rr.slice(), ct = yt.length;
            if (ct < Ot && (yt = [0].concat(yt)), xt(jt, yt, Ot, nt), Ot = jt.length, ot == -1)
              for (; bt(rr, jt, It, Ot) < 1; )
                ft++, xt(jt, It < Ot ? Mt : rr, Ot, nt), Ot = jt.length;
          } else ot === 0 && (ft++, jt = [0]);
          Nt[ut++] = ft, jt[0] ? jt[Ot++] = Qt[Tt] || 0 : (jt = [Qt[Tt]], Ot = 1);
        } while ((Tt++ < Ut || jt[0] != null) && Kt--);
        pt = jt[0] != null, Nt[0] || Nt.splice(0, 1);
      }
      if (nt == BASE) {
        for (ut = 1, Kt = Nt[0]; Kt >= 10; Kt /= 10, ut++) ;
        $t(Et, rt + (Et.e = ut + st * LOG_BASE - 1) + 1, pe, pt);
      } else
        Et.e = st, Et.r = +pt;
      return Et;
    };
  }();
  function vt(At, bt, xt, wt) {
    var Oe, rt, pe, nt, ot;
    if (xt == null ? xt = ne : intCheck(xt, 0, 8), !At.c) return At.toString();
    if (Oe = At.c[0], pe = At.e, bt == null)
      ot = coeffToString(At.c), ot = wt == 1 || wt == 2 && (pe <= ie || pe >= oe) ? toExponential(ot, pe) : toFixedPoint(ot, pe, "0");
    else if (At = $t(new dt(At), bt, xt), rt = At.e, ot = coeffToString(At.c), nt = ot.length, wt == 1 || wt == 2 && (bt <= rt || rt <= ie)) {
      for (; nt < bt; ot += "0", nt++) ;
      ot = toExponential(ot, rt);
    } else if (bt -= pe, ot = toFixedPoint(ot, rt, "0"), rt + 1 > nt) {
      if (--bt > 0) for (ot += "."; bt--; ot += "0") ;
    } else if (bt += rt - nt, bt > 0)
      for (rt + 1 == nt && (ot += "."); bt--; ot += "0") ;
    return At.s < 0 && Oe ? "-" + ot : ot;
  }
  function mt(At, bt) {
    for (var xt, wt, Oe = 1, rt = new dt(At[0]); Oe < At.length; Oe++)
      wt = new dt(At[Oe]), (!wt.s || (xt = compare(rt, wt)) === bt || xt === 0 && rt.s === bt) && (rt = wt);
    return rt;
  }
  function Pt(At, bt, xt) {
    for (var wt = 1, Oe = bt.length; !bt[--Oe]; bt.pop()) ;
    for (Oe = bt[0]; Oe >= 10; Oe /= 10, wt++) ;
    return (xt = wt + xt * LOG_BASE - 1) > ce ? At.c = At.e = null : xt < re ? At.c = [At.e = 0] : (At.e = xt, At.c = bt), At;
  }
  K = /* @__PURE__ */ function() {
    var At = /^(-?)0([xbo])(?=\w[\w.]*$)/i, bt = /^([^.]+)\.$/, xt = /^\.([^.]+)$/, wt = /^-?(Infinity|NaN)$/, Oe = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(rt, pe, nt, ot) {
      var st, ut = nt ? pe : pe.replace(Oe, "");
      if (wt.test(ut))
        rt.s = isNaN(ut) ? null : ut < 0 ? -1 : 1;
      else {
        if (!nt && (ut = ut.replace(At, function(pt, ft, yt) {
          return st = (yt = yt.toLowerCase()) == "x" ? 16 : yt == "b" ? 2 : 8, !ot || ot == st ? ft : pt;
        }), ot && (st = ot, ut = ut.replace(bt, "$1").replace(xt, "0.$1")), pe != ut))
          return new dt(ut, st);
        if (dt.DEBUG)
          throw Error(bignumberError + "Not a" + (ot ? " base " + ot : "") + " number: " + pe);
        rt.s = null;
      }
      rt.c = rt.e = null;
    };
  }();
  function $t(At, bt, xt, wt) {
    var Oe, rt, pe, nt, ot, st, ut, pt = At.c, ft = POWS_TEN;
    if (pt) {
      e: {
        for (Oe = 1, nt = pt[0]; nt >= 10; nt /= 10, Oe++) ;
        if (rt = bt - Oe, rt < 0)
          rt += LOG_BASE, pe = bt, ot = pt[st = 0], ut = mathfloor(ot / ft[Oe - pe - 1] % 10);
        else if (st = mathceil((rt + 1) / LOG_BASE), st >= pt.length)
          if (wt) {
            for (; pt.length <= st; pt.push(0)) ;
            ot = ut = 0, Oe = 1, rt %= LOG_BASE, pe = rt - LOG_BASE + 1;
          } else
            break e;
        else {
          for (ot = nt = pt[st], Oe = 1; nt >= 10; nt /= 10, Oe++) ;
          rt %= LOG_BASE, pe = rt - LOG_BASE + Oe, ut = pe < 0 ? 0 : mathfloor(ot / ft[Oe - pe - 1] % 10);
        }
        if (wt = wt || bt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        pt[st + 1] != null || (pe < 0 ? ot : ot % ft[Oe - pe - 1]), wt = xt < 4 ? (ut || wt) && (xt == 0 || xt == (At.s < 0 ? 3 : 2)) : ut > 5 || ut == 5 && (xt == 4 || wt || xt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (rt > 0 ? pe > 0 ? ot / ft[Oe - pe] : 0 : pt[st - 1]) % 10 & 1 || xt == (At.s < 0 ? 8 : 7)), bt < 1 || !pt[0])
          return pt.length = 0, wt ? (bt -= At.e + 1, pt[0] = ft[(LOG_BASE - bt % LOG_BASE) % LOG_BASE], At.e = -bt || 0) : pt[0] = At.e = 0, At;
        if (rt == 0 ? (pt.length = st, nt = 1, st--) : (pt.length = st + 1, nt = ft[LOG_BASE - rt], pt[st] = pe > 0 ? mathfloor(ot / ft[Oe - pe] % ft[pe]) * nt : 0), wt)
          for (; ; )
            if (st == 0) {
              for (rt = 1, pe = pt[0]; pe >= 10; pe /= 10, rt++) ;
              for (pe = pt[0] += nt, nt = 1; pe >= 10; pe /= 10, nt++) ;
              rt != nt && (At.e++, pt[0] == BASE && (pt[0] = 1));
              break;
            } else {
              if (pt[st] += nt, pt[st] != BASE) break;
              pt[st--] = 0, nt = 1;
            }
        for (rt = pt.length; pt[--rt] === 0; pt.pop()) ;
      }
      At.e > ce ? At.c = At.e = null : At.e < re && (At.c = [At.e = 0]);
    }
    return At;
  }
  function qt(At) {
    var bt, xt = At.e;
    return xt === null ? At.toString() : (bt = coeffToString(At.c), bt = xt <= ie || xt >= oe ? toExponential(bt, xt) : toFixedPoint(bt, xt, "0"), At.s < 0 ? "-" + bt : bt);
  }
  return J.absoluteValue = J.abs = function() {
    var At = new dt(this);
    return At.s < 0 && (At.s = 1), At;
  }, J.comparedTo = function(At, bt) {
    return compare(this, new dt(At, bt));
  }, J.decimalPlaces = J.dp = function(At, bt) {
    var xt, wt, Oe, rt = this;
    if (At != null)
      return intCheck(At, 0, MAX), bt == null ? bt = ne : intCheck(bt, 0, 8), $t(new dt(rt), At + rt.e + 1, bt);
    if (!(xt = rt.c)) return null;
    if (wt = ((Oe = xt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Oe = xt[Oe]) for (; Oe % 10 == 0; Oe /= 10, wt--) ;
    return wt < 0 && (wt = 0), wt;
  }, J.dividedBy = J.div = function(At, bt) {
    return B(this, new dt(At, bt), V, ne);
  }, J.dividedToIntegerBy = J.idiv = function(At, bt) {
    return B(this, new dt(At, bt), 0, 1);
  }, J.exponentiatedBy = J.pow = function(At, bt) {
    var xt, wt, Oe, rt, pe, nt, ot, st, ut, pt = this;
    if (At = new dt(At), At.c && !At.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + qt(At));
    if (bt != null && (bt = new dt(bt)), nt = At.e > 14, !pt.c || !pt.c[0] || pt.c[0] == 1 && !pt.e && pt.c.length == 1 || !At.c || !At.c[0])
      return ut = new dt(Math.pow(+qt(pt), nt ? At.s * (2 - isOdd(At)) : +qt(At))), bt ? ut.mod(bt) : ut;
    if (ot = At.s < 0, bt) {
      if (bt.c ? !bt.c[0] : !bt.s) return new dt(NaN);
      wt = !ot && pt.isInteger() && bt.isInteger(), wt && (pt = pt.mod(bt));
    } else {
      if (At.e > 9 && (pt.e > 0 || pt.e < -1 || (pt.e == 0 ? pt.c[0] > 1 || nt && pt.c[1] >= 24e7 : pt.c[0] < 8e13 || nt && pt.c[0] <= 9999975e7)))
        return rt = pt.s < 0 && isOdd(At) ? -0 : 0, pt.e > -1 && (rt = 1 / rt), new dt(ot ? 1 / rt : rt);
      it && (rt = mathceil(it / LOG_BASE + 2));
    }
    for (nt ? (xt = new dt(0.5), ot && (At.s = 1), st = isOdd(At)) : (Oe = Math.abs(+qt(At)), st = Oe % 2), ut = new dt(W); ; ) {
      if (st) {
        if (ut = ut.times(pt), !ut.c) break;
        rt ? ut.c.length > rt && (ut.c.length = rt) : wt && (ut = ut.mod(bt));
      }
      if (Oe) {
        if (Oe = mathfloor(Oe / 2), Oe === 0) break;
        st = Oe % 2;
      } else if (At = At.times(xt), $t(At, At.e + 1, 1), At.e > 14)
        st = isOdd(At);
      else {
        if (Oe = +qt(At), Oe === 0) break;
        st = Oe % 2;
      }
      pt = pt.times(pt), rt ? pt.c && pt.c.length > rt && (pt.c.length = rt) : wt && (pt = pt.mod(bt));
    }
    return wt ? ut : (ot && (ut = W.div(ut)), bt ? ut.mod(bt) : rt ? $t(ut, it, ne, pe) : ut);
  }, J.integerValue = function(At) {
    var bt = new dt(this);
    return At == null ? At = ne : intCheck(At, 0, 8), $t(bt, bt.e + 1, At);
  }, J.isEqualTo = J.eq = function(At, bt) {
    return compare(this, new dt(At, bt)) === 0;
  }, J.isFinite = function() {
    return !!this.c;
  }, J.isGreaterThan = J.gt = function(At, bt) {
    return compare(this, new dt(At, bt)) > 0;
  }, J.isGreaterThanOrEqualTo = J.gte = function(At, bt) {
    return (bt = compare(this, new dt(At, bt))) === 1 || bt === 0;
  }, J.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, J.isLessThan = J.lt = function(At, bt) {
    return compare(this, new dt(At, bt)) < 0;
  }, J.isLessThanOrEqualTo = J.lte = function(At, bt) {
    return (bt = compare(this, new dt(At, bt))) === -1 || bt === 0;
  }, J.isNaN = function() {
    return !this.s;
  }, J.isNegative = function() {
    return this.s < 0;
  }, J.isPositive = function() {
    return this.s > 0;
  }, J.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, J.minus = function(At, bt) {
    var xt, wt, Oe, rt, pe = this, nt = pe.s;
    if (At = new dt(At, bt), bt = At.s, !nt || !bt) return new dt(NaN);
    if (nt != bt)
      return At.s = -bt, pe.plus(At);
    var ot = pe.e / LOG_BASE, st = At.e / LOG_BASE, ut = pe.c, pt = At.c;
    if (!ot || !st) {
      if (!ut || !pt) return ut ? (At.s = -bt, At) : new dt(pt ? pe : NaN);
      if (!ut[0] || !pt[0])
        return pt[0] ? (At.s = -bt, At) : new dt(ut[0] ? pe : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ne == 3 ? -0 : 0
        ));
    }
    if (ot = bitFloor(ot), st = bitFloor(st), ut = ut.slice(), nt = ot - st) {
      for ((rt = nt < 0) ? (nt = -nt, Oe = ut) : (st = ot, Oe = pt), Oe.reverse(), bt = nt; bt--; Oe.push(0)) ;
      Oe.reverse();
    } else
      for (wt = (rt = (nt = ut.length) < (bt = pt.length)) ? nt : bt, nt = bt = 0; bt < wt; bt++)
        if (ut[bt] != pt[bt]) {
          rt = ut[bt] < pt[bt];
          break;
        }
    if (rt && (Oe = ut, ut = pt, pt = Oe, At.s = -At.s), bt = (wt = pt.length) - (xt = ut.length), bt > 0) for (; bt--; ut[xt++] = 0) ;
    for (bt = BASE - 1; wt > nt; ) {
      if (ut[--wt] < pt[wt]) {
        for (xt = wt; xt && !ut[--xt]; ut[xt] = bt) ;
        --ut[xt], ut[wt] += BASE;
      }
      ut[wt] -= pt[wt];
    }
    for (; ut[0] == 0; ut.splice(0, 1), --st) ;
    return ut[0] ? Pt(At, ut, st) : (At.s = ne == 3 ? -1 : 1, At.c = [At.e = 0], At);
  }, J.modulo = J.mod = function(At, bt) {
    var xt, wt, Oe = this;
    return At = new dt(At, bt), !Oe.c || !At.s || At.c && !At.c[0] ? new dt(NaN) : !At.c || Oe.c && !Oe.c[0] ? new dt(Oe) : (Ce == 9 ? (wt = At.s, At.s = 1, xt = B(Oe, At, 0, 3), At.s = wt, xt.s *= wt) : xt = B(Oe, At, 0, Ce), At = Oe.minus(xt.times(At)), !At.c[0] && Ce == 1 && (At.s = Oe.s), At);
  }, J.multipliedBy = J.times = function(At, bt) {
    var xt, wt, Oe, rt, pe, nt, ot, st, ut, pt, ft, yt, ct, Et, Nt, jt = this, Ot = jt.c, Bt = (At = new dt(At, bt)).c;
    if (!Ot || !Bt || !Ot[0] || !Bt[0])
      return !jt.s || !At.s || Ot && !Ot[0] && !Bt || Bt && !Bt[0] && !Ot ? At.c = At.e = At.s = null : (At.s *= jt.s, !Ot || !Bt ? At.c = At.e = null : (At.c = [0], At.e = 0)), At;
    for (wt = bitFloor(jt.e / LOG_BASE) + bitFloor(At.e / LOG_BASE), At.s *= jt.s, ot = Ot.length, pt = Bt.length, ot < pt && (ct = Ot, Ot = Bt, Bt = ct, Oe = ot, ot = pt, pt = Oe), Oe = ot + pt, ct = []; Oe--; ct.push(0)) ;
    for (Et = BASE, Nt = SQRT_BASE, Oe = pt; --Oe >= 0; ) {
      for (xt = 0, ft = Bt[Oe] % Nt, yt = Bt[Oe] / Nt | 0, pe = ot, rt = Oe + pe; rt > Oe; )
        st = Ot[--pe] % Nt, ut = Ot[pe] / Nt | 0, nt = yt * st + ut * ft, st = ft * st + nt % Nt * Nt + ct[rt] + xt, xt = (st / Et | 0) + (nt / Nt | 0) + yt * ut, ct[rt--] = st % Et;
      ct[rt] = xt;
    }
    return xt ? ++wt : ct.splice(0, 1), Pt(At, ct, wt);
  }, J.negated = function() {
    var At = new dt(this);
    return At.s = -At.s || null, At;
  }, J.plus = function(At, bt) {
    var xt, wt = this, Oe = wt.s;
    if (At = new dt(At, bt), bt = At.s, !Oe || !bt) return new dt(NaN);
    if (Oe != bt)
      return At.s = -bt, wt.minus(At);
    var rt = wt.e / LOG_BASE, pe = At.e / LOG_BASE, nt = wt.c, ot = At.c;
    if (!rt || !pe) {
      if (!nt || !ot) return new dt(Oe / 0);
      if (!nt[0] || !ot[0]) return ot[0] ? At : new dt(nt[0] ? wt : Oe * 0);
    }
    if (rt = bitFloor(rt), pe = bitFloor(pe), nt = nt.slice(), Oe = rt - pe) {
      for (Oe > 0 ? (pe = rt, xt = ot) : (Oe = -Oe, xt = nt), xt.reverse(); Oe--; xt.push(0)) ;
      xt.reverse();
    }
    for (Oe = nt.length, bt = ot.length, Oe - bt < 0 && (xt = ot, ot = nt, nt = xt, bt = Oe), Oe = 0; bt; )
      Oe = (nt[--bt] = nt[bt] + ot[bt] + Oe) / BASE | 0, nt[bt] = BASE === nt[bt] ? 0 : nt[bt] % BASE;
    return Oe && (nt = [Oe].concat(nt), ++pe), Pt(At, nt, pe);
  }, J.precision = J.sd = function(At, bt) {
    var xt, wt, Oe, rt = this;
    if (At != null && At !== !!At)
      return intCheck(At, 1, MAX), bt == null ? bt = ne : intCheck(bt, 0, 8), $t(new dt(rt), At, bt);
    if (!(xt = rt.c)) return null;
    if (Oe = xt.length - 1, wt = Oe * LOG_BASE + 1, Oe = xt[Oe]) {
      for (; Oe % 10 == 0; Oe /= 10, wt--) ;
      for (Oe = xt[0]; Oe >= 10; Oe /= 10, wt++) ;
    }
    return At && rt.e + 1 > wt && (wt = rt.e + 1), wt;
  }, J.shiftedBy = function(At) {
    return intCheck(At, -MAX_SAFE_INTEGER$2, MAX_SAFE_INTEGER$2), this.times("1e" + At);
  }, J.squareRoot = J.sqrt = function() {
    var At, bt, xt, wt, Oe, rt = this, pe = rt.c, nt = rt.s, ot = rt.e, st = V + 4, ut = new dt("0.5");
    if (nt !== 1 || !pe || !pe[0])
      return new dt(!nt || nt < 0 && (!pe || pe[0]) ? NaN : pe ? rt : 1 / 0);
    if (nt = Math.sqrt(+qt(rt)), nt == 0 || nt == 1 / 0 ? (bt = coeffToString(pe), (bt.length + ot) % 2 == 0 && (bt += "0"), nt = Math.sqrt(+bt), ot = bitFloor((ot + 1) / 2) - (ot < 0 || ot % 2), nt == 1 / 0 ? bt = "5e" + ot : (bt = nt.toExponential(), bt = bt.slice(0, bt.indexOf("e") + 1) + ot), xt = new dt(bt)) : xt = new dt(nt + ""), xt.c[0]) {
      for (ot = xt.e, nt = ot + st, nt < 3 && (nt = 0); ; )
        if (Oe = xt, xt = ut.times(Oe.plus(B(rt, Oe, st, 1))), coeffToString(Oe.c).slice(0, nt) === (bt = coeffToString(xt.c)).slice(0, nt))
          if (xt.e < ot && --nt, bt = bt.slice(nt - 3, nt + 1), bt == "9999" || !wt && bt == "4999") {
            if (!wt && ($t(Oe, Oe.e + V + 2, 0), Oe.times(Oe).eq(rt))) {
              xt = Oe;
              break;
            }
            st += 4, nt += 4, wt = 1;
          } else {
            (!+bt || !+bt.slice(1) && bt.charAt(0) == "5") && ($t(xt, xt.e + V + 2, 1), At = !xt.times(xt).eq(rt));
            break;
          }
    }
    return $t(xt, xt.e + V + 1, ne, At);
  }, J.toExponential = function(At, bt) {
    return At != null && (intCheck(At, 0, MAX), At++), vt(this, At, bt, 1);
  }, J.toFixed = function(At, bt) {
    return At != null && (intCheck(At, 0, MAX), At = At + this.e + 1), vt(this, At, bt);
  }, J.toFormat = function(At, bt, xt) {
    var wt, Oe = this;
    if (xt == null)
      At != null && bt && typeof bt == "object" ? (xt = bt, bt = null) : At && typeof At == "object" ? (xt = At, At = bt = null) : xt = at;
    else if (typeof xt != "object")
      throw Error(bignumberError + "Argument not an object: " + xt);
    if (wt = Oe.toFixed(At, bt), Oe.c) {
      var rt, pe = wt.split("."), nt = +xt.groupSize, ot = +xt.secondaryGroupSize, st = xt.groupSeparator || "", ut = pe[0], pt = pe[1], ft = Oe.s < 0, yt = ft ? ut.slice(1) : ut, ct = yt.length;
      if (ot && (rt = nt, nt = ot, ot = rt, ct -= rt), nt > 0 && ct > 0) {
        for (rt = ct % nt || nt, ut = yt.substr(0, rt); rt < ct; rt += nt) ut += st + yt.substr(rt, nt);
        ot > 0 && (ut += st + yt.slice(rt)), ft && (ut = "-" + ut);
      }
      wt = pt ? ut + (xt.decimalSeparator || "") + ((ot = +xt.fractionGroupSize) ? pt.replace(
        new RegExp("\\d{" + ot + "}\\B", "g"),
        "$&" + (xt.fractionGroupSeparator || "")
      ) : pt) : ut;
    }
    return (xt.prefix || "") + wt + (xt.suffix || "");
  }, J.toFraction = function(At) {
    var bt, xt, wt, Oe, rt, pe, nt, ot, st, ut, pt, ft, yt = this, ct = yt.c;
    if (At != null && (nt = new dt(At), !nt.isInteger() && (nt.c || nt.s !== 1) || nt.lt(W)))
      throw Error(bignumberError + "Argument " + (nt.isInteger() ? "out of range: " : "not an integer: ") + qt(nt));
    if (!ct) return new dt(yt);
    for (bt = new dt(W), st = xt = new dt(W), wt = ot = new dt(W), ft = coeffToString(ct), rt = bt.e = ft.length - yt.e - 1, bt.c[0] = POWS_TEN[(pe = rt % LOG_BASE) < 0 ? LOG_BASE + pe : pe], At = !At || nt.comparedTo(bt) > 0 ? rt > 0 ? bt : st : nt, pe = ce, ce = 1 / 0, nt = new dt(ft), ot.c[0] = 0; ut = B(nt, bt, 0, 1), Oe = xt.plus(ut.times(wt)), Oe.comparedTo(At) != 1; )
      xt = wt, wt = Oe, st = ot.plus(ut.times(Oe = st)), ot = Oe, bt = nt.minus(ut.times(Oe = bt)), nt = Oe;
    return Oe = B(At.minus(xt), wt, 0, 1), ot = ot.plus(Oe.times(st)), xt = xt.plus(Oe.times(wt)), ot.s = st.s = yt.s, rt = rt * 2, pt = B(st, wt, rt, ne).minus(yt).abs().comparedTo(
      B(ot, xt, rt, ne).minus(yt).abs()
    ) < 1 ? [st, wt] : [ot, xt], ce = pe, pt;
  }, J.toNumber = function() {
    return +qt(this);
  }, J.toPrecision = function(At, bt) {
    return At != null && intCheck(At, 1, MAX), vt(this, At, bt, 2);
  }, J.toString = function(At) {
    var bt, xt = this, wt = xt.s, Oe = xt.e;
    return Oe === null ? wt ? (bt = "Infinity", wt < 0 && (bt = "-" + bt)) : bt = "NaN" : (At == null ? bt = Oe <= ie || Oe >= oe ? toExponential(coeffToString(xt.c), Oe) : toFixedPoint(coeffToString(xt.c), Oe, "0") : At === 10 && ht ? (xt = $t(new dt(xt), V + Oe + 1, ne), bt = toFixedPoint(coeffToString(xt.c), xt.e, "0")) : (intCheck(At, 2, lt.length, "Base"), bt = L(toFixedPoint(coeffToString(xt.c), Oe, "0"), 10, At, wt, !0)), wt < 0 && xt.c[0] && (bt = "-" + bt)), bt;
  }, J.valueOf = J.toJSON = function() {
    return qt(this);
  }, J._isBigNumber = !0, J[Symbol.toStringTag] = "BigNumber", J[Symbol.for("nodejs.util.inspect.custom")] = J.valueOf, A != null && dt.set(A), dt;
}
function bitFloor(A) {
  var B = A | 0;
  return A > 0 || A === B ? B : B - 1;
}
function coeffToString(A) {
  for (var B, L, K = 1, J = A.length, W = A[0] + ""; K < J; ) {
    for (B = A[K++] + "", L = LOG_BASE - B.length; L--; B = "0" + B) ;
    W += B;
  }
  for (J = W.length; W.charCodeAt(--J) === 48; ) ;
  return W.slice(0, J + 1 || 1);
}
function compare(A, B) {
  var L, K, J = A.c, W = B.c, V = A.s, ne = B.s, ie = A.e, oe = B.e;
  if (!V || !ne) return null;
  if (L = J && !J[0], K = W && !W[0], L || K) return L ? K ? 0 : -ne : V;
  if (V != ne) return V;
  if (L = V < 0, K = ie == oe, !J || !W) return K ? 0 : !J ^ L ? 1 : -1;
  if (!K) return ie > oe ^ L ? 1 : -1;
  for (ne = (ie = J.length) < (oe = W.length) ? ie : oe, V = 0; V < ne; V++) if (J[V] != W[V]) return J[V] > W[V] ^ L ? 1 : -1;
  return ie == oe ? 0 : ie > oe ^ L ? 1 : -1;
}
function intCheck(A, B, L, K) {
  if (A < B || A > L || A !== mathfloor(A))
    throw Error(bignumberError + (K || "Argument") + (typeof A == "number" ? A < B || A > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(A));
}
function isOdd(A) {
  var B = A.c.length - 1;
  return bitFloor(A.e / LOG_BASE) == B && A.c[B] % 2 != 0;
}
function toExponential(A, B) {
  return (A.length > 1 ? A.charAt(0) + "." + A.slice(1) : A) + (B < 0 ? "e" : "e+") + B;
}
function toFixedPoint(A, B, L) {
  var K, J;
  if (B < 0) {
    for (J = L + "."; ++B; J += L) ;
    A = J + A;
  } else if (K = A.length, ++B > K) {
    for (J = L, B -= K; --B; J += L) ;
    A += J;
  } else B < K && (A = A.slice(0, B) + "." + A.slice(B));
  return A;
}
var BigNumber = clone();
function useBalance() {
  const { network: A, publicKey: B, format: L } = useWallie(), [K, J] = useState(null), [W, V] = useState(!1);
  return { getBalance: useCallback(async () => {
    V(!0);
    try {
      if (J(null), !L || !L.payments || !B || !B.payments)
        throw new Error("No wallet is connected");
      const { address: ie } = getAddressesFromPublicKey(
        B.payments,
        A,
        ADDRESS_FORMAT_TO_TYPE[L.payments]
      )[0], re = await new JsonRpcDatasource({ network: A }).getBalance({ address: ie }), ce = Number(
        new BigNumber(re).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return V(!1), ce;
    } catch (ie) {
      throw J(ie.message), V(!1), ie;
    }
  }, [L, A, B]), error: K, loading: W };
}
async function signPsbt({
  address: A,
  wallet: B,
  network: L,
  psbt: K,
  options: J
}) {
  var ie, oe;
  if ((ie = J == null ? void 0 : J.signingIndexes) != null && ie.length && ((oe = J == null ? void 0 : J.inputsToSign) != null && oe.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const W = (J == null ? void 0 : J.finalize) ?? !0, V = (J == null ? void 0 : J.extractTx) ?? !0, ne = () => K.data.inputs.map((re, ce) => ce);
  if (B === Wallet.MAGICEDEN)
    return await signPsbt$1(K, {
      network: L,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ne(),
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: W,
      extractTx: V
    });
  if (B === Wallet.UNISAT)
    return await signPsbt$2(K, {
      finalize: W,
      extractTx: V
    });
  if (B === Wallet.XVERSE)
    return await signPsbt$3(K, {
      network: L,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: W,
      extractTx: V
    });
  if (B === Wallet.LEATHER)
    return await signPsbt$4(K, {
      network: L,
      finalize: W,
      extractTx: V,
      allowedSighash: J != null && J.sigHash ? [J == null ? void 0 : J.sigHash] : [],
      signAtIndexes: (J == null ? void 0 : J.signingIndexes) ?? ne()
      // If signingIndexes is not provided, just sign everything
    });
  if (B === Wallet.OKX)
    return await signPsbt$5(K, {
      finalize: W,
      extractTx: V,
      network: L,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: A, network: B, address: L, publicKey: K } = useWallie(), [J, W] = useState(null), [V, ne] = useState(!1);
  return { send: useCallback(
    async (oe, re, ce, ke = !0) => {
      ne(!0);
      try {
        if (W(null), !L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const Ce = new PSBTBuilder({
          address: L.payments,
          feeRate: ce,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: oe,
              value: re
            }
          ]
        });
        await Ce.prepare();
        const it = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: Ce.toPSBT()
        });
        if (ke) {
          const lt = await new JsonRpcDatasource({ network: B }).relay({ hex: it.hex });
          return ne(!1), lt;
        }
        return ne(!1), it.hex;
      } catch (Ce) {
        return W(Ce.message), ne(!1), null;
      }
    },
    [L, B, K, A]
  ), error: J, loading: V };
}
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
function getValue$1(A, B) {
  return A == null ? void 0 : A[B];
}
function isHostObject(A) {
  var B = !1;
  if (A != null && typeof A.toString != "function")
    try {
      B = !!(A + "");
    } catch {
    }
  return B;
}
var funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var A = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return A ? "Symbol(src)_1." + A : "";
}(), funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), Symbol$1 = root.Symbol;
Symbol$1 && Symbol$1.isConcatSpreadable;
getNative(root, "Map");
getNative(Object, "create");
function baseIsNative(A) {
  if (!isObject(A) || isMasked(A))
    return !1;
  var B = isFunction(A) || isHostObject(A) ? reIsNative : reIsHostCtor;
  return B.test(toSource(A));
}
function getNative(A, B) {
  var L = getValue$1(A, B);
  return baseIsNative(L) ? L : void 0;
}
function isMasked(A) {
  return !!maskSrcKey && maskSrcKey in A;
}
function toSource(A) {
  if (A != null) {
    try {
      return funcToString.call(A);
    } catch {
    }
    try {
      return A + "";
    } catch {
    }
  }
  return "";
}
function isFunction(A) {
  var B = isObject(A) ? objectToString.call(A) : "";
  return B == funcTag || B == genTag;
}
function isObject(A) {
  var B = typeof A;
  return !!A && (B == "object" || B == "function");
}
var store2;
function getGlobalMessage(A) {
  return store2 == null ? void 0 : store2.get(A);
}
var store3;
function getSchemaMessage(A) {
  return store3 == null ? void 0 : store3.get(A);
}
var store4;
function getSpecificMessage(A, B) {
  var L;
  return (L = store4 == null ? void 0 : store4.get(A)) == null ? void 0 : L.get(B);
}
function _stringify(A) {
  var L, K;
  let B = typeof A;
  return B === "object" && (B = (A && ((K = (L = Object.getPrototypeOf(A)) == null ? void 0 : L.constructor) == null ? void 0 : K.name)) ?? "null"), B === "string" ? `"${A}"` : B === "number" || B === "bigint" || B === "boolean" ? `${A}` : B;
}
function _addIssue(A, B, L, K, J) {
  const W = J && "input" in J ? J.input : L.value, V = (J == null ? void 0 : J.expected) ?? A.expects ?? null, ne = (J == null ? void 0 : J.received) ?? _stringify(W), ie = {
    kind: A.kind,
    type: A.type,
    input: W,
    expected: V,
    received: ne,
    message: `Invalid ${B}: ${V ? `Expected ${V} but r` : "R"}eceived ${ne}`,
    // @ts-expect-error
    requirement: A.requirement,
    path: J == null ? void 0 : J.path,
    issues: J == null ? void 0 : J.issues,
    lang: K.lang,
    abortEarly: K.abortEarly,
    abortPipeEarly: K.abortPipeEarly
  }, oe = A.kind === "schema", re = (J == null ? void 0 : J.message) ?? // @ts-expect-error
  A.message ?? getSpecificMessage(A.reference, ie.lang) ?? (oe ? getSchemaMessage(ie.lang) : null) ?? K.message ?? getGlobalMessage(ie.lang);
  re && (ie.message = typeof re == "function" ? re(ie) : re), oe && (L.typed = !1), L.issues ? L.issues.push(ie) : L.issues = [ie];
}
function _isValidObjectKey(A, B) {
  return Object.hasOwn(A, B) && B !== "__proto__" && B !== "prototype" && B !== "constructor";
}
function getDefault(A, B, L) {
  return typeof A.default == "function" ? (
    // @ts-expect-error
    A.default(B, L)
  ) : (
    // @ts-expect-error
    A.default
  );
}
function array(A, B) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: A,
    message: B,
    _run(L, K) {
      var W;
      const J = L.value;
      if (Array.isArray(J)) {
        L.typed = !0, L.value = [];
        for (let V = 0; V < J.length; V++) {
          const ne = J[V], ie = this.item._run({ typed: !1, value: ne }, K);
          if (ie.issues) {
            const oe = {
              type: "array",
              origin: "value",
              input: J,
              key: V,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(oe) : re.path = [oe], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), L.value.push(ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function boolean(A) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "boolean" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function enum_(A, B) {
  const L = Object.entries(A).filter(([K]) => isNaN(+K)).map(([, K]) => K);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: L.map(_stringify).join(" | ") || "never",
    async: !1,
    enum: A,
    options: L,
    message: B,
    _run(K, J) {
      return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, J), K;
    }
  };
}
function literal(A, B) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(A),
    async: !1,
    literal: A,
    message: B,
    _run(L, K) {
      return L.value === this.literal ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function looseObject(A, B) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const J = L.value;
      if (J && typeof J == "object") {
        L.typed = !0, L.value = {};
        for (const V in this.entries) {
          const ne = J[V], ie = this.entries[V]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const oe = {
              type: "object",
              origin: "value",
              input: J,
              key: V,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(oe) : re.path = [oe], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || V in J) && (L.value[V] = ie.value);
        }
        if (!L.issues || !K.abortEarly)
          for (const V in J)
            _isValidObjectKey(J, V) && !(V in this.entries) && (L.value[V] = J[V]);
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function nonOptional(A, B) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: A,
    message: B,
    _run(L, K) {
      return L.value === void 0 ? (_addIssue(this, "type", L, K), L) : this.wrapped._run(L, K);
    }
  };
}
function null_(A) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === null ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function nullish(A, ...B) {
  const L = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${A.expects} | null | undefined`,
    async: !1,
    wrapped: A,
    _run(K, J) {
      return (K.value === null || K.value === void 0) && ("default" in this && (K.value = getDefault(
        this,
        K,
        J
      )), K.value === null || K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, J);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function number$1(A) {
  return {
    kind: "schema",
    type: "number",
    reference: number$1,
    expects: "number",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "number" && !isNaN(B.value) ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function object(A, B) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const J = L.value;
      if (J && typeof J == "object") {
        L.typed = !0, L.value = {};
        for (const V in this.entries) {
          const ne = J[V], ie = this.entries[V]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const oe = {
              type: "object",
              origin: "value",
              input: J,
              key: V,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(oe) : re.path = [oe], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || V in J) && (L.value[V] = ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function optional(A, ...B) {
  const L = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${A.expects} | undefined`,
    async: !1,
    wrapped: A,
    _run(K, J) {
      return K.value === void 0 && ("default" in this && (K.value = getDefault(
        this,
        K,
        J
      )), K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, J);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function picklist(A, B) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: A.map(_stringify).join(" | ") || "never",
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      return this.options.includes(L.value) ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function string(A) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "string" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function undefined_(A) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === void 0 ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function _subIssues(A) {
  let B;
  if (A)
    for (const L of A)
      B ? B.push(...L.issues) : B = L.issues;
  return B;
}
function union(A, B) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(A.map((L) => L.expects))].join(" | ") || "never",
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      let J, W, V;
      for (const ne of this.options) {
        const ie = ne._run(
          { typed: !1, value: L.value },
          K
        );
        if (ie.typed)
          if (ie.issues)
            W ? W.push(ie) : W = [ie];
          else {
            J = ie;
            break;
          }
        else
          V ? V.push(ie) : V = [ie];
      }
      if (J)
        return J;
      if (W) {
        if (W.length === 1)
          return W[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(W)
        }), L.typed = !0;
      } else {
        if ((V == null ? void 0 : V.length) === 1)
          return V[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(V)
        });
      }
      return L;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(A) {
      return A.typed = !0, A;
    }
  };
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength$1(A) {
  var B = getLens$1(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength$1(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray$1(A) {
  var B, L = getLens$1(A), K = L[0], J = L[1], W = new Arr$1(_byteLength$1(A, K, J)), V = 0, ne = J > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup$1[A.charCodeAt(ie)] << 18 | revLookup$1[A.charCodeAt(ie + 1)] << 12 | revLookup$1[A.charCodeAt(ie + 2)] << 6 | revLookup$1[A.charCodeAt(ie + 3)], W[V++] = B >> 16 & 255, W[V++] = B >> 8 & 255, W[V++] = B & 255;
  return J === 2 && (B = revLookup$1[A.charCodeAt(ie)] << 2 | revLookup$1[A.charCodeAt(ie + 1)] >> 4, W[V++] = B & 255), J === 1 && (B = revLookup$1[A.charCodeAt(ie)] << 10 | revLookup$1[A.charCodeAt(ie + 1)] << 4 | revLookup$1[A.charCodeAt(ie + 2)] >> 2, W[V++] = B >> 8 & 255, W[V++] = B & 255), W;
}
function tripletToBase64$1(A) {
  return lookup$1[A >> 18 & 63] + lookup$1[A >> 12 & 63] + lookup$1[A >> 6 & 63] + lookup$1[A & 63];
}
function encodeChunk$1(A, B, L) {
  for (var K, J = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), J.push(tripletToBase64$1(K));
  return J.join("");
}
function fromByteArray$1(A) {
  for (var B, L = A.length, K = L % 3, J = [], W = 16383, V = 0, ne = L - K; V < ne; V += W)
    J.push(encodeChunk$1(A, V, V + W > ne ? ne : V + W));
  return K === 1 ? (B = A[L - 1], J.push(
    lookup$1[B >> 2] + lookup$1[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], J.push(
    lookup$1[B >> 10] + lookup$1[B >> 4 & 63] + lookup$1[B << 2 & 63] + "="
  )), J.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js$1;
function pad(A) {
  return `${A}${"=".repeat(4 - (A.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(A) {
  return A.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(A) {
  return pad(A).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(A) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(A)));
}
base64Url.encode = encode$j;
function decode$j(A) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(A))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = _assert.isBytes = void 0;
function number(A) {
  if (!Number.isSafeInteger(A) || A < 0)
    throw new Error(`positive integer expected, not ${A}`);
}
_assert.number = number;
function bool(A) {
  if (typeof A != "boolean")
    throw new Error(`boolean expected, not ${A}`);
}
_assert.bool = bool;
function isBytes(A) {
  return A instanceof Uint8Array || A != null && typeof A == "object" && A.constructor.name === "Uint8Array";
}
_assert.isBytes = isBytes;
function bytes(A, ...B) {
  if (!isBytes(A))
    throw new Error("Uint8Array expected");
  if (B.length > 0 && !B.includes(A.length))
    throw new Error(`Uint8Array expected of length ${B}, not of length=${A.length}`);
}
_assert.bytes = bytes;
function hash$2(A) {
  if (typeof A != "function" || typeof A.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(A.outputLen), number(A.blockLen);
}
_assert.hash = hash$2;
function exists(A, B = !0) {
  if (A.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (B && A.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(A, B) {
  bytes(A);
  const L = B.outputLen;
  if (A.length < L)
    throw new Error(`digestInto() expects output buffer of length at least ${L}`);
}
_assert.output = output;
const assert$1 = { number, bool, bytes, hash: hash$2, exists, output };
_assert.default = assert$1;
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(A) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.randomBytes = A.wrapXOFConstructorWithOpts = A.wrapConstructorWithOpts = A.wrapConstructor = A.checkOpts = A.Hash = A.concatBytes = A.toBytes = A.utf8ToBytes = A.asyncLoop = A.nextTick = A.hexToBytes = A.bytesToHex = A.byteSwap32 = A.byteSwapIfBE = A.byteSwap = A.isLE = A.rotl = A.rotr = A.createView = A.u32 = A.u8 = A.isBytes = void 0;
  const B = crypto$2, L = _assert;
  function K(Oe) {
    return Oe instanceof Uint8Array || Oe != null && typeof Oe == "object" && Oe.constructor.name === "Uint8Array";
  }
  A.isBytes = K;
  const J = (Oe) => new Uint8Array(Oe.buffer, Oe.byteOffset, Oe.byteLength);
  A.u8 = J;
  const W = (Oe) => new Uint32Array(Oe.buffer, Oe.byteOffset, Math.floor(Oe.byteLength / 4));
  A.u32 = W;
  const V = (Oe) => new DataView(Oe.buffer, Oe.byteOffset, Oe.byteLength);
  A.createView = V;
  const ne = (Oe, rt) => Oe << 32 - rt | Oe >>> rt;
  A.rotr = ne;
  const ie = (Oe, rt) => Oe << rt | Oe >>> 32 - rt >>> 0;
  A.rotl = ie, A.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const oe = (Oe) => Oe << 24 & 4278190080 | Oe << 8 & 16711680 | Oe >>> 8 & 65280 | Oe >>> 24 & 255;
  A.byteSwap = oe, A.byteSwapIfBE = A.isLE ? (Oe) => Oe : (Oe) => (0, A.byteSwap)(Oe);
  function re(Oe) {
    for (let rt = 0; rt < Oe.length; rt++)
      Oe[rt] = (0, A.byteSwap)(Oe[rt]);
  }
  A.byteSwap32 = re;
  const ce = /* @__PURE__ */ Array.from({ length: 256 }, (Oe, rt) => rt.toString(16).padStart(2, "0"));
  function ke(Oe) {
    (0, L.bytes)(Oe);
    let rt = "";
    for (let pe = 0; pe < Oe.length; pe++)
      rt += ce[Oe[pe]];
    return rt;
  }
  A.bytesToHex = ke;
  const Ce = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function it(Oe) {
    if (Oe >= Ce._0 && Oe <= Ce._9)
      return Oe - Ce._0;
    if (Oe >= Ce._A && Oe <= Ce._F)
      return Oe - (Ce._A - 10);
    if (Oe >= Ce._a && Oe <= Ce._f)
      return Oe - (Ce._a - 10);
  }
  function at(Oe) {
    if (typeof Oe != "string")
      throw new Error("hex string expected, got " + typeof Oe);
    const rt = Oe.length, pe = rt / 2;
    if (rt % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + rt);
    const nt = new Uint8Array(pe);
    for (let ot = 0, st = 0; ot < pe; ot++, st += 2) {
      const ut = it(Oe.charCodeAt(st)), pt = it(Oe.charCodeAt(st + 1));
      if (ut === void 0 || pt === void 0) {
        const ft = Oe[st] + Oe[st + 1];
        throw new Error('hex string expected, got non-hex character "' + ft + '" at index ' + st);
      }
      nt[ot] = ut * 16 + pt;
    }
    return nt;
  }
  A.hexToBytes = at;
  const lt = async () => {
  };
  A.nextTick = lt;
  async function ht(Oe, rt, pe) {
    let nt = Date.now();
    for (let ot = 0; ot < Oe; ot++) {
      pe(ot);
      const st = Date.now() - nt;
      st >= 0 && st < rt || (await (0, A.nextTick)(), nt += st);
    }
  }
  A.asyncLoop = ht;
  function dt(Oe) {
    if (typeof Oe != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof Oe}`);
    return new Uint8Array(new TextEncoder().encode(Oe));
  }
  A.utf8ToBytes = dt;
  function vt(Oe) {
    return typeof Oe == "string" && (Oe = dt(Oe)), (0, L.bytes)(Oe), Oe;
  }
  A.toBytes = vt;
  function mt(...Oe) {
    let rt = 0;
    for (let nt = 0; nt < Oe.length; nt++) {
      const ot = Oe[nt];
      (0, L.bytes)(ot), rt += ot.length;
    }
    const pe = new Uint8Array(rt);
    for (let nt = 0, ot = 0; nt < Oe.length; nt++) {
      const st = Oe[nt];
      pe.set(st, ot), ot += st.length;
    }
    return pe;
  }
  A.concatBytes = mt;
  class Pt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  A.Hash = Pt;
  const $t = {}.toString;
  function qt(Oe, rt) {
    if (rt !== void 0 && $t.call(rt) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Oe, rt);
  }
  A.checkOpts = qt;
  function At(Oe) {
    const rt = (nt) => Oe().update(vt(nt)).digest(), pe = Oe();
    return rt.outputLen = pe.outputLen, rt.blockLen = pe.blockLen, rt.create = () => Oe(), rt;
  }
  A.wrapConstructor = At;
  function bt(Oe) {
    const rt = (nt, ot) => Oe(ot).update(vt(nt)).digest(), pe = Oe({});
    return rt.outputLen = pe.outputLen, rt.blockLen = pe.blockLen, rt.create = (nt) => Oe(nt), rt;
  }
  A.wrapConstructorWithOpts = bt;
  function xt(Oe) {
    const rt = (nt, ot) => Oe(ot).update(vt(nt)).digest(), pe = Oe({});
    return rt.outputLen = pe.outputLen, rt.blockLen = pe.blockLen, rt.create = (nt) => Oe(nt), rt;
  }
  A.wrapXOFConstructorWithOpts = xt;
  function wt(Oe = 32) {
    if (B.crypto && typeof B.crypto.getRandomValues == "function")
      return B.crypto.getRandomValues(new Uint8Array(Oe));
    throw new Error("crypto.getRandomValues must be defined");
  }
  A.randomBytes = wt;
})(utils$5);
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.hmac = A.HMAC = void 0;
  const B = _assert, L = utils$5;
  class K extends L.Hash {
    constructor(V, ne) {
      super(), this.finished = !1, this.destroyed = !1, (0, B.hash)(V);
      const ie = (0, L.toBytes)(ne);
      if (this.iHash = V.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const oe = this.blockLen, re = new Uint8Array(oe);
      re.set(ie.length > oe ? V.create().update(ie).digest() : ie);
      for (let ce = 0; ce < re.length; ce++)
        re[ce] ^= 54;
      this.iHash.update(re), this.oHash = V.create();
      for (let ce = 0; ce < re.length; ce++)
        re[ce] ^= 106;
      this.oHash.update(re), re.fill(0);
    }
    update(V) {
      return (0, B.exists)(this), this.iHash.update(V), this;
    }
    digestInto(V) {
      (0, B.exists)(this), (0, B.bytes)(V, this.outputLen), this.finished = !0, this.iHash.digestInto(V), this.oHash.update(V), this.oHash.digestInto(V), this.destroy();
    }
    digest() {
      const V = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(V), V;
    }
    _cloneInto(V) {
      V || (V = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ne, iHash: ie, finished: oe, destroyed: re, blockLen: ce, outputLen: ke } = this;
      return V = V, V.finished = oe, V.destroyed = re, V.blockLen = ce, V.outputLen = ke, V.oHash = ne._cloneInto(V.oHash), V.iHash = ie._cloneInto(V.iHash), V;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  A.HMAC = K;
  const J = (W, V, ne) => new K(W, V).update(ne).digest();
  A.hmac = J, A.hmac.create = (W, V) => new K(W, V);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = _md.Maj = _md.Chi = void 0;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(A, B, L, K) {
  if (typeof A.setBigUint64 == "function")
    return A.setBigUint64(B, L, K);
  const J = BigInt(32), W = BigInt(4294967295), V = Number(L >> J & W), ne = Number(L & W), ie = K ? 4 : 0, oe = K ? 0 : 4;
  A.setUint32(B + ie, V, K), A.setUint32(B + oe, ne, K);
}
const Chi = (A, B, L) => A & B ^ ~A & L;
_md.Chi = Chi;
const Maj = (A, B, L) => A & B ^ A & L ^ B & L;
_md.Maj = Maj;
class HashMD extends utils_js_1$3.Hash {
  constructor(B, L, K, J) {
    super(), this.blockLen = B, this.outputLen = L, this.padOffset = K, this.isLE = J, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(B), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(B) {
    (0, _assert_js_1.exists)(this);
    const { view: L, buffer: K, blockLen: J } = this;
    B = (0, utils_js_1$3.toBytes)(B);
    const W = B.length;
    for (let V = 0; V < W; ) {
      const ne = Math.min(J - this.pos, W - V);
      if (ne === J) {
        const ie = (0, utils_js_1$3.createView)(B);
        for (; J <= W - V; V += J)
          this.process(ie, V);
        continue;
      }
      K.set(B.subarray(V, V + ne), this.pos), this.pos += ne, V += ne, this.pos === J && (this.process(L, 0), this.pos = 0);
    }
    return this.length += B.length, this.roundClean(), this;
  }
  digestInto(B) {
    (0, _assert_js_1.exists)(this), (0, _assert_js_1.output)(B, this), this.finished = !0;
    const { buffer: L, view: K, blockLen: J, isLE: W } = this;
    let { pos: V } = this;
    L[V++] = 128, this.buffer.subarray(V).fill(0), this.padOffset > J - V && (this.process(K, 0), V = 0);
    for (let ce = V; ce < J; ce++)
      L[ce] = 0;
    setBigUint64(K, J - 8, BigInt(this.length * 8), W), this.process(K, 0);
    const ne = (0, utils_js_1$3.createView)(B), ie = this.outputLen;
    if (ie % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const oe = ie / 4, re = this.get();
    if (oe > re.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let ce = 0; ce < oe; ce++)
      ne.setUint32(4 * ce, re[ce], W);
  }
  digest() {
    const { buffer: B, outputLen: L } = this;
    this.digestInto(B);
    const K = B.slice(0, L);
    return this.destroy(), K;
  }
  _cloneInto(B) {
    B || (B = new this.constructor()), B.set(...this.get());
    const { blockLen: L, buffer: K, length: J, finished: W, destroyed: V, pos: ne } = this;
    return B.length = J, B.pos = ne, B.finished = W, B.destroyed = V, J % L && B.buffer.set(K), B;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: J, E: W, F: V, G: ne, H: ie } = this;
    return [B, L, K, J, W, V, ne, ie];
  }
  // prettier-ignore
  set(B, L, K, J, W, V, ne, ie) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = J | 0, this.E = W | 0, this.F = V | 0, this.G = ne | 0, this.H = ie | 0;
  }
  process(B, L) {
    for (let ce = 0; ce < 16; ce++, L += 4)
      SHA256_W[ce] = B.getUint32(L, !1);
    for (let ce = 16; ce < 64; ce++) {
      const ke = SHA256_W[ce - 15], Ce = SHA256_W[ce - 2], it = (0, utils_js_1$2.rotr)(ke, 7) ^ (0, utils_js_1$2.rotr)(ke, 18) ^ ke >>> 3, at = (0, utils_js_1$2.rotr)(Ce, 17) ^ (0, utils_js_1$2.rotr)(Ce, 19) ^ Ce >>> 10;
      SHA256_W[ce] = at + SHA256_W[ce - 7] + it + SHA256_W[ce - 16] | 0;
    }
    let { A: K, B: J, C: W, D: V, E: ne, F: ie, G: oe, H: re } = this;
    for (let ce = 0; ce < 64; ce++) {
      const ke = (0, utils_js_1$2.rotr)(ne, 6) ^ (0, utils_js_1$2.rotr)(ne, 11) ^ (0, utils_js_1$2.rotr)(ne, 25), Ce = re + ke + (0, _md_js_1$2.Chi)(ne, ie, oe) + SHA256_K[ce] + SHA256_W[ce] | 0, at = ((0, utils_js_1$2.rotr)(K, 2) ^ (0, utils_js_1$2.rotr)(K, 13) ^ (0, utils_js_1$2.rotr)(K, 22)) + (0, _md_js_1$2.Maj)(K, J, W) | 0;
      re = oe, oe = ie, ie = ne, ne = V + Ce | 0, V = W, W = J, J = K, K = Ce + at | 0;
    }
    K = K + this.A | 0, J = J + this.B | 0, W = W + this.C | 0, V = V + this.D | 0, ne = ne + this.E | 0, ie = ie + this.F | 0, oe = oe + this.G | 0, re = re + this.H | 0, this.set(K, J, W, V, ne, ie, oe, re);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} }, buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength(A) {
  var B = getLens(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray(A) {
  var B, L = getLens(A), K = L[0], J = L[1], W = new Arr(_byteLength(A, K, J)), V = 0, ne = J > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup[A.charCodeAt(ie)] << 18 | revLookup[A.charCodeAt(ie + 1)] << 12 | revLookup[A.charCodeAt(ie + 2)] << 6 | revLookup[A.charCodeAt(ie + 3)], W[V++] = B >> 16 & 255, W[V++] = B >> 8 & 255, W[V++] = B & 255;
  return J === 2 && (B = revLookup[A.charCodeAt(ie)] << 2 | revLookup[A.charCodeAt(ie + 1)] >> 4, W[V++] = B & 255), J === 1 && (B = revLookup[A.charCodeAt(ie)] << 10 | revLookup[A.charCodeAt(ie + 1)] << 4 | revLookup[A.charCodeAt(ie + 2)] >> 2, W[V++] = B >> 8 & 255, W[V++] = B & 255), W;
}
function tripletToBase64(A) {
  return lookup[A >> 18 & 63] + lookup[A >> 12 & 63] + lookup[A >> 6 & 63] + lookup[A & 63];
}
function encodeChunk(A, B, L) {
  for (var K, J = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), J.push(tripletToBase64(K));
  return J.join("");
}
function fromByteArray(A) {
  for (var B, L = A.length, K = L % 3, J = [], W = 16383, V = 0, ne = L - K; V < ne; V += W)
    J.push(encodeChunk(A, V, V + W > ne ? ne : V + W));
  return K === 1 ? (B = A[L - 1], J.push(
    lookup[B >> 2] + lookup[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], J.push(
    lookup[B >> 10] + lookup[B >> 4 & 63] + lookup[B << 2 & 63] + "="
  )), J.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(A, B, L, K, J) {
  var W, V, ne = J * 8 - K - 1, ie = (1 << ne) - 1, oe = ie >> 1, re = -7, ce = L ? J - 1 : 0, ke = L ? -1 : 1, Ce = A[B + ce];
  for (ce += ke, W = Ce & (1 << -re) - 1, Ce >>= -re, re += ne; re > 0; W = W * 256 + A[B + ce], ce += ke, re -= 8)
    ;
  for (V = W & (1 << -re) - 1, W >>= -re, re += K; re > 0; V = V * 256 + A[B + ce], ce += ke, re -= 8)
    ;
  if (W === 0)
    W = 1 - oe;
  else {
    if (W === ie)
      return V ? NaN : (Ce ? -1 : 1) * (1 / 0);
    V = V + Math.pow(2, K), W = W - oe;
  }
  return (Ce ? -1 : 1) * V * Math.pow(2, W - K);
};
ieee754.write = function(A, B, L, K, J, W) {
  var V, ne, ie, oe = W * 8 - J - 1, re = (1 << oe) - 1, ce = re >> 1, ke = J === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ce = K ? 0 : W - 1, it = K ? 1 : -1, at = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
  for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (ne = isNaN(B) ? 1 : 0, V = re) : (V = Math.floor(Math.log(B) / Math.LN2), B * (ie = Math.pow(2, -V)) < 1 && (V--, ie *= 2), V + ce >= 1 ? B += ke / ie : B += ke * Math.pow(2, 1 - ce), B * ie >= 2 && (V++, ie /= 2), V + ce >= re ? (ne = 0, V = re) : V + ce >= 1 ? (ne = (B * ie - 1) * Math.pow(2, J), V = V + ce) : (ne = B * Math.pow(2, ce - 1) * Math.pow(2, J), V = 0)); J >= 8; A[L + Ce] = ne & 255, Ce += it, ne /= 256, J -= 8)
    ;
  for (V = V << J | ne, oe += J; oe > 0; A[L + Ce] = V & 255, Ce += it, V /= 256, oe -= 8)
    ;
  A[L + Ce - it] |= at * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(A) {
  const B = base64Js, L = ieee754, K = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  A.Buffer = re, A.SlowBuffer = Pt, A.INSPECT_MAX_BYTES = 50;
  const J = 2147483647;
  A.kMaxLength = J;
  const { Uint8Array: W, ArrayBuffer: V, SharedArrayBuffer: ne } = globalThis;
  re.TYPED_ARRAY_SUPPORT = ie(), !re.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ie() {
    try {
      const Rt = new W(1), gt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(gt, W.prototype), Object.setPrototypeOf(Rt, gt), Rt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(re.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (re.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(re.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (re.isBuffer(this))
        return this.byteOffset;
    }
  });
  function oe(Rt) {
    if (Rt > J)
      throw new RangeError('The value "' + Rt + '" is invalid for option "size"');
    const gt = new W(Rt);
    return Object.setPrototypeOf(gt, re.prototype), gt;
  }
  function re(Rt, gt, St) {
    if (typeof Rt == "number") {
      if (typeof gt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return it(Rt);
    }
    return ce(Rt, gt, St);
  }
  re.poolSize = 8192;
  function ce(Rt, gt, St) {
    if (typeof Rt == "string")
      return at(Rt, gt);
    if (V.isView(Rt))
      return ht(Rt);
    if (Rt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Rt
      );
    if (Sr(Rt, V) || Rt && Sr(Rt.buffer, V) || typeof ne < "u" && (Sr(Rt, ne) || Rt && Sr(Rt.buffer, ne)))
      return dt(Rt, gt, St);
    if (typeof Rt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ct = Rt.valueOf && Rt.valueOf();
    if (Ct != null && Ct !== Rt)
      return re.from(Ct, gt, St);
    const Wt = vt(Rt);
    if (Wt) return Wt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Rt[Symbol.toPrimitive] == "function")
      return re.from(Rt[Symbol.toPrimitive]("string"), gt, St);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Rt
    );
  }
  re.from = function(Rt, gt, St) {
    return ce(Rt, gt, St);
  }, Object.setPrototypeOf(re.prototype, W.prototype), Object.setPrototypeOf(re, W);
  function ke(Rt) {
    if (typeof Rt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Rt < 0)
      throw new RangeError('The value "' + Rt + '" is invalid for option "size"');
  }
  function Ce(Rt, gt, St) {
    return ke(Rt), Rt <= 0 ? oe(Rt) : gt !== void 0 ? typeof St == "string" ? oe(Rt).fill(gt, St) : oe(Rt).fill(gt) : oe(Rt);
  }
  re.alloc = function(Rt, gt, St) {
    return Ce(Rt, gt, St);
  };
  function it(Rt) {
    return ke(Rt), oe(Rt < 0 ? 0 : mt(Rt) | 0);
  }
  re.allocUnsafe = function(Rt) {
    return it(Rt);
  }, re.allocUnsafeSlow = function(Rt) {
    return it(Rt);
  };
  function at(Rt, gt) {
    if ((typeof gt != "string" || gt === "") && (gt = "utf8"), !re.isEncoding(gt))
      throw new TypeError("Unknown encoding: " + gt);
    const St = $t(Rt, gt) | 0;
    let Ct = oe(St);
    const Wt = Ct.write(Rt, gt);
    return Wt !== St && (Ct = Ct.slice(0, Wt)), Ct;
  }
  function lt(Rt) {
    const gt = Rt.length < 0 ? 0 : mt(Rt.length) | 0, St = oe(gt);
    for (let Ct = 0; Ct < gt; Ct += 1)
      St[Ct] = Rt[Ct] & 255;
    return St;
  }
  function ht(Rt) {
    if (Sr(Rt, W)) {
      const gt = new W(Rt);
      return dt(gt.buffer, gt.byteOffset, gt.byteLength);
    }
    return lt(Rt);
  }
  function dt(Rt, gt, St) {
    if (gt < 0 || Rt.byteLength < gt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Rt.byteLength < gt + (St || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ct;
    return gt === void 0 && St === void 0 ? Ct = new W(Rt) : St === void 0 ? Ct = new W(Rt, gt) : Ct = new W(Rt, gt, St), Object.setPrototypeOf(Ct, re.prototype), Ct;
  }
  function vt(Rt) {
    if (re.isBuffer(Rt)) {
      const gt = mt(Rt.length) | 0, St = oe(gt);
      return St.length === 0 || Rt.copy(St, 0, 0, gt), St;
    }
    if (Rt.length !== void 0)
      return typeof Rt.length != "number" || Mr(Rt.length) ? oe(0) : lt(Rt);
    if (Rt.type === "Buffer" && Array.isArray(Rt.data))
      return lt(Rt.data);
  }
  function mt(Rt) {
    if (Rt >= J)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + J.toString(16) + " bytes");
    return Rt | 0;
  }
  function Pt(Rt) {
    return +Rt != Rt && (Rt = 0), re.alloc(+Rt);
  }
  re.isBuffer = function(gt) {
    return gt != null && gt._isBuffer === !0 && gt !== re.prototype;
  }, re.compare = function(gt, St) {
    if (Sr(gt, W) && (gt = re.from(gt, gt.offset, gt.byteLength)), Sr(St, W) && (St = re.from(St, St.offset, St.byteLength)), !re.isBuffer(gt) || !re.isBuffer(St))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (gt === St) return 0;
    let Ct = gt.length, Wt = St.length;
    for (let zt = 0, Vt = Math.min(Ct, Wt); zt < Vt; ++zt)
      if (gt[zt] !== St[zt]) {
        Ct = gt[zt], Wt = St[zt];
        break;
      }
    return Ct < Wt ? -1 : Wt < Ct ? 1 : 0;
  }, re.isEncoding = function(gt) {
    switch (String(gt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, re.concat = function(gt, St) {
    if (!Array.isArray(gt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (gt.length === 0)
      return re.alloc(0);
    let Ct;
    if (St === void 0)
      for (St = 0, Ct = 0; Ct < gt.length; ++Ct)
        St += gt[Ct].length;
    const Wt = re.allocUnsafe(St);
    let zt = 0;
    for (Ct = 0; Ct < gt.length; ++Ct) {
      let Vt = gt[Ct];
      if (Sr(Vt, W))
        zt + Vt.length > Wt.length ? (re.isBuffer(Vt) || (Vt = re.from(Vt)), Vt.copy(Wt, zt)) : W.prototype.set.call(
          Wt,
          Vt,
          zt
        );
      else if (re.isBuffer(Vt))
        Vt.copy(Wt, zt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      zt += Vt.length;
    }
    return Wt;
  };
  function $t(Rt, gt) {
    if (re.isBuffer(Rt))
      return Rt.length;
    if (V.isView(Rt) || Sr(Rt, V))
      return Rt.byteLength;
    if (typeof Rt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Rt
      );
    const St = Rt.length, Ct = arguments.length > 2 && arguments[2] === !0;
    if (!Ct && St === 0) return 0;
    let Wt = !1;
    for (; ; )
      switch (gt) {
        case "ascii":
        case "latin1":
        case "binary":
          return St;
        case "utf8":
        case "utf-8":
          return Rr(Rt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return St * 2;
        case "hex":
          return St >>> 1;
        case "base64":
          return Br(Rt).length;
        default:
          if (Wt)
            return Ct ? -1 : Rr(Rt).length;
          gt = ("" + gt).toLowerCase(), Wt = !0;
      }
  }
  re.byteLength = $t;
  function qt(Rt, gt, St) {
    let Ct = !1;
    if ((gt === void 0 || gt < 0) && (gt = 0), gt > this.length || ((St === void 0 || St > this.length) && (St = this.length), St <= 0) || (St >>>= 0, gt >>>= 0, St <= gt))
      return "";
    for (Rt || (Rt = "utf8"); ; )
      switch (Rt) {
        case "hex":
          return ct(this, gt, St);
        case "utf8":
        case "utf-8":
          return st(this, gt, St);
        case "ascii":
          return ft(this, gt, St);
        case "latin1":
        case "binary":
          return yt(this, gt, St);
        case "base64":
          return ot(this, gt, St);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Et(this, gt, St);
        default:
          if (Ct) throw new TypeError("Unknown encoding: " + Rt);
          Rt = (Rt + "").toLowerCase(), Ct = !0;
      }
  }
  re.prototype._isBuffer = !0;
  function At(Rt, gt, St) {
    const Ct = Rt[gt];
    Rt[gt] = Rt[St], Rt[St] = Ct;
  }
  re.prototype.swap16 = function() {
    const gt = this.length;
    if (gt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let St = 0; St < gt; St += 2)
      At(this, St, St + 1);
    return this;
  }, re.prototype.swap32 = function() {
    const gt = this.length;
    if (gt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let St = 0; St < gt; St += 4)
      At(this, St, St + 3), At(this, St + 1, St + 2);
    return this;
  }, re.prototype.swap64 = function() {
    const gt = this.length;
    if (gt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let St = 0; St < gt; St += 8)
      At(this, St, St + 7), At(this, St + 1, St + 6), At(this, St + 2, St + 5), At(this, St + 3, St + 4);
    return this;
  }, re.prototype.toString = function() {
    const gt = this.length;
    return gt === 0 ? "" : arguments.length === 0 ? st(this, 0, gt) : qt.apply(this, arguments);
  }, re.prototype.toLocaleString = re.prototype.toString, re.prototype.equals = function(gt) {
    if (!re.isBuffer(gt)) throw new TypeError("Argument must be a Buffer");
    return this === gt ? !0 : re.compare(this, gt) === 0;
  }, re.prototype.inspect = function() {
    let gt = "";
    const St = A.INSPECT_MAX_BYTES;
    return gt = this.toString("hex", 0, St).replace(/(.{2})/g, "$1 ").trim(), this.length > St && (gt += " ... "), "<Buffer " + gt + ">";
  }, K && (re.prototype[K] = re.prototype.inspect), re.prototype.compare = function(gt, St, Ct, Wt, zt) {
    if (Sr(gt, W) && (gt = re.from(gt, gt.offset, gt.byteLength)), !re.isBuffer(gt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof gt
      );
    if (St === void 0 && (St = 0), Ct === void 0 && (Ct = gt ? gt.length : 0), Wt === void 0 && (Wt = 0), zt === void 0 && (zt = this.length), St < 0 || Ct > gt.length || Wt < 0 || zt > this.length)
      throw new RangeError("out of range index");
    if (Wt >= zt && St >= Ct)
      return 0;
    if (Wt >= zt)
      return -1;
    if (St >= Ct)
      return 1;
    if (St >>>= 0, Ct >>>= 0, Wt >>>= 0, zt >>>= 0, this === gt) return 0;
    let Vt = zt - Wt, yr = Ct - St;
    const xr = Math.min(Vt, yr), cr = this.slice(Wt, zt), Ar = gt.slice(St, Ct);
    for (let gr = 0; gr < xr; ++gr)
      if (cr[gr] !== Ar[gr]) {
        Vt = cr[gr], yr = Ar[gr];
        break;
      }
    return Vt < yr ? -1 : yr < Vt ? 1 : 0;
  };
  function bt(Rt, gt, St, Ct, Wt) {
    if (Rt.length === 0) return -1;
    if (typeof St == "string" ? (Ct = St, St = 0) : St > 2147483647 ? St = 2147483647 : St < -2147483648 && (St = -2147483648), St = +St, Mr(St) && (St = Wt ? 0 : Rt.length - 1), St < 0 && (St = Rt.length + St), St >= Rt.length) {
      if (Wt) return -1;
      St = Rt.length - 1;
    } else if (St < 0)
      if (Wt) St = 0;
      else return -1;
    if (typeof gt == "string" && (gt = re.from(gt, Ct)), re.isBuffer(gt))
      return gt.length === 0 ? -1 : xt(Rt, gt, St, Ct, Wt);
    if (typeof gt == "number")
      return gt = gt & 255, typeof W.prototype.indexOf == "function" ? Wt ? W.prototype.indexOf.call(Rt, gt, St) : W.prototype.lastIndexOf.call(Rt, gt, St) : xt(Rt, [gt], St, Ct, Wt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function xt(Rt, gt, St, Ct, Wt) {
    let zt = 1, Vt = Rt.length, yr = gt.length;
    if (Ct !== void 0 && (Ct = String(Ct).toLowerCase(), Ct === "ucs2" || Ct === "ucs-2" || Ct === "utf16le" || Ct === "utf-16le")) {
      if (Rt.length < 2 || gt.length < 2)
        return -1;
      zt = 2, Vt /= 2, yr /= 2, St /= 2;
    }
    function xr(Ar, gr) {
      return zt === 1 ? Ar[gr] : Ar.readUInt16BE(gr * zt);
    }
    let cr;
    if (Wt) {
      let Ar = -1;
      for (cr = St; cr < Vt; cr++)
        if (xr(Rt, cr) === xr(gt, Ar === -1 ? 0 : cr - Ar)) {
          if (Ar === -1 && (Ar = cr), cr - Ar + 1 === yr) return Ar * zt;
        } else
          Ar !== -1 && (cr -= cr - Ar), Ar = -1;
    } else
      for (St + yr > Vt && (St = Vt - yr), cr = St; cr >= 0; cr--) {
        let Ar = !0;
        for (let gr = 0; gr < yr; gr++)
          if (xr(Rt, cr + gr) !== xr(gt, gr)) {
            Ar = !1;
            break;
          }
        if (Ar) return cr;
      }
    return -1;
  }
  re.prototype.includes = function(gt, St, Ct) {
    return this.indexOf(gt, St, Ct) !== -1;
  }, re.prototype.indexOf = function(gt, St, Ct) {
    return bt(this, gt, St, Ct, !0);
  }, re.prototype.lastIndexOf = function(gt, St, Ct) {
    return bt(this, gt, St, Ct, !1);
  };
  function wt(Rt, gt, St, Ct) {
    St = Number(St) || 0;
    const Wt = Rt.length - St;
    Ct ? (Ct = Number(Ct), Ct > Wt && (Ct = Wt)) : Ct = Wt;
    const zt = gt.length;
    Ct > zt / 2 && (Ct = zt / 2);
    let Vt;
    for (Vt = 0; Vt < Ct; ++Vt) {
      const yr = parseInt(gt.substr(Vt * 2, 2), 16);
      if (Mr(yr)) return Vt;
      Rt[St + Vt] = yr;
    }
    return Vt;
  }
  function Oe(Rt, gt, St, Ct) {
    return dr(Rr(gt, Rt.length - St), Rt, St, Ct);
  }
  function rt(Rt, gt, St, Ct) {
    return dr(lr(gt), Rt, St, Ct);
  }
  function pe(Rt, gt, St, Ct) {
    return dr(Br(gt), Rt, St, Ct);
  }
  function nt(Rt, gt, St, Ct) {
    return dr($r(gt, Rt.length - St), Rt, St, Ct);
  }
  re.prototype.write = function(gt, St, Ct, Wt) {
    if (St === void 0)
      Wt = "utf8", Ct = this.length, St = 0;
    else if (Ct === void 0 && typeof St == "string")
      Wt = St, Ct = this.length, St = 0;
    else if (isFinite(St))
      St = St >>> 0, isFinite(Ct) ? (Ct = Ct >>> 0, Wt === void 0 && (Wt = "utf8")) : (Wt = Ct, Ct = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const zt = this.length - St;
    if ((Ct === void 0 || Ct > zt) && (Ct = zt), gt.length > 0 && (Ct < 0 || St < 0) || St > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Wt || (Wt = "utf8");
    let Vt = !1;
    for (; ; )
      switch (Wt) {
        case "hex":
          return wt(this, gt, St, Ct);
        case "utf8":
        case "utf-8":
          return Oe(this, gt, St, Ct);
        case "ascii":
        case "latin1":
        case "binary":
          return rt(this, gt, St, Ct);
        case "base64":
          return pe(this, gt, St, Ct);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return nt(this, gt, St, Ct);
        default:
          if (Vt) throw new TypeError("Unknown encoding: " + Wt);
          Wt = ("" + Wt).toLowerCase(), Vt = !0;
      }
  }, re.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ot(Rt, gt, St) {
    return gt === 0 && St === Rt.length ? B.fromByteArray(Rt) : B.fromByteArray(Rt.slice(gt, St));
  }
  function st(Rt, gt, St) {
    St = Math.min(Rt.length, St);
    const Ct = [];
    let Wt = gt;
    for (; Wt < St; ) {
      const zt = Rt[Wt];
      let Vt = null, yr = zt > 239 ? 4 : zt > 223 ? 3 : zt > 191 ? 2 : 1;
      if (Wt + yr <= St) {
        let xr, cr, Ar, gr;
        switch (yr) {
          case 1:
            zt < 128 && (Vt = zt);
            break;
          case 2:
            xr = Rt[Wt + 1], (xr & 192) === 128 && (gr = (zt & 31) << 6 | xr & 63, gr > 127 && (Vt = gr));
            break;
          case 3:
            xr = Rt[Wt + 1], cr = Rt[Wt + 2], (xr & 192) === 128 && (cr & 192) === 128 && (gr = (zt & 15) << 12 | (xr & 63) << 6 | cr & 63, gr > 2047 && (gr < 55296 || gr > 57343) && (Vt = gr));
            break;
          case 4:
            xr = Rt[Wt + 1], cr = Rt[Wt + 2], Ar = Rt[Wt + 3], (xr & 192) === 128 && (cr & 192) === 128 && (Ar & 192) === 128 && (gr = (zt & 15) << 18 | (xr & 63) << 12 | (cr & 63) << 6 | Ar & 63, gr > 65535 && gr < 1114112 && (Vt = gr));
        }
      }
      Vt === null ? (Vt = 65533, yr = 1) : Vt > 65535 && (Vt -= 65536, Ct.push(Vt >>> 10 & 1023 | 55296), Vt = 56320 | Vt & 1023), Ct.push(Vt), Wt += yr;
    }
    return pt(Ct);
  }
  const ut = 4096;
  function pt(Rt) {
    const gt = Rt.length;
    if (gt <= ut)
      return String.fromCharCode.apply(String, Rt);
    let St = "", Ct = 0;
    for (; Ct < gt; )
      St += String.fromCharCode.apply(
        String,
        Rt.slice(Ct, Ct += ut)
      );
    return St;
  }
  function ft(Rt, gt, St) {
    let Ct = "";
    St = Math.min(Rt.length, St);
    for (let Wt = gt; Wt < St; ++Wt)
      Ct += String.fromCharCode(Rt[Wt] & 127);
    return Ct;
  }
  function yt(Rt, gt, St) {
    let Ct = "";
    St = Math.min(Rt.length, St);
    for (let Wt = gt; Wt < St; ++Wt)
      Ct += String.fromCharCode(Rt[Wt]);
    return Ct;
  }
  function ct(Rt, gt, St) {
    const Ct = Rt.length;
    (!gt || gt < 0) && (gt = 0), (!St || St < 0 || St > Ct) && (St = Ct);
    let Wt = "";
    for (let zt = gt; zt < St; ++zt)
      Wt += br[Rt[zt]];
    return Wt;
  }
  function Et(Rt, gt, St) {
    const Ct = Rt.slice(gt, St);
    let Wt = "";
    for (let zt = 0; zt < Ct.length - 1; zt += 2)
      Wt += String.fromCharCode(Ct[zt] + Ct[zt + 1] * 256);
    return Wt;
  }
  re.prototype.slice = function(gt, St) {
    const Ct = this.length;
    gt = ~~gt, St = St === void 0 ? Ct : ~~St, gt < 0 ? (gt += Ct, gt < 0 && (gt = 0)) : gt > Ct && (gt = Ct), St < 0 ? (St += Ct, St < 0 && (St = 0)) : St > Ct && (St = Ct), St < gt && (St = gt);
    const Wt = this.subarray(gt, St);
    return Object.setPrototypeOf(Wt, re.prototype), Wt;
  };
  function Nt(Rt, gt, St) {
    if (Rt % 1 !== 0 || Rt < 0) throw new RangeError("offset is not uint");
    if (Rt + gt > St) throw new RangeError("Trying to access beyond buffer length");
  }
  re.prototype.readUintLE = re.prototype.readUIntLE = function(gt, St, Ct) {
    gt = gt >>> 0, St = St >>> 0, Ct || Nt(gt, St, this.length);
    let Wt = this[gt], zt = 1, Vt = 0;
    for (; ++Vt < St && (zt *= 256); )
      Wt += this[gt + Vt] * zt;
    return Wt;
  }, re.prototype.readUintBE = re.prototype.readUIntBE = function(gt, St, Ct) {
    gt = gt >>> 0, St = St >>> 0, Ct || Nt(gt, St, this.length);
    let Wt = this[gt + --St], zt = 1;
    for (; St > 0 && (zt *= 256); )
      Wt += this[gt + --St] * zt;
    return Wt;
  }, re.prototype.readUint8 = re.prototype.readUInt8 = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 1, this.length), this[gt];
  }, re.prototype.readUint16LE = re.prototype.readUInt16LE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 2, this.length), this[gt] | this[gt + 1] << 8;
  }, re.prototype.readUint16BE = re.prototype.readUInt16BE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 2, this.length), this[gt] << 8 | this[gt + 1];
  }, re.prototype.readUint32LE = re.prototype.readUInt32LE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 4, this.length), (this[gt] | this[gt + 1] << 8 | this[gt + 2] << 16) + this[gt + 3] * 16777216;
  }, re.prototype.readUint32BE = re.prototype.readUInt32BE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 4, this.length), this[gt] * 16777216 + (this[gt + 1] << 16 | this[gt + 2] << 8 | this[gt + 3]);
  }, re.prototype.readBigUInt64LE = Ir(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const St = this[gt], Ct = this[gt + 7];
    (St === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = St + this[++gt] * 2 ** 8 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 24, zt = this[++gt] + this[++gt] * 2 ** 8 + this[++gt] * 2 ** 16 + Ct * 2 ** 24;
    return BigInt(Wt) + (BigInt(zt) << BigInt(32));
  }), re.prototype.readBigUInt64BE = Ir(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const St = this[gt], Ct = this[gt + 7];
    (St === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = St * 2 ** 24 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + this[++gt], zt = this[++gt] * 2 ** 24 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + Ct;
    return (BigInt(Wt) << BigInt(32)) + BigInt(zt);
  }), re.prototype.readIntLE = function(gt, St, Ct) {
    gt = gt >>> 0, St = St >>> 0, Ct || Nt(gt, St, this.length);
    let Wt = this[gt], zt = 1, Vt = 0;
    for (; ++Vt < St && (zt *= 256); )
      Wt += this[gt + Vt] * zt;
    return zt *= 128, Wt >= zt && (Wt -= Math.pow(2, 8 * St)), Wt;
  }, re.prototype.readIntBE = function(gt, St, Ct) {
    gt = gt >>> 0, St = St >>> 0, Ct || Nt(gt, St, this.length);
    let Wt = St, zt = 1, Vt = this[gt + --Wt];
    for (; Wt > 0 && (zt *= 256); )
      Vt += this[gt + --Wt] * zt;
    return zt *= 128, Vt >= zt && (Vt -= Math.pow(2, 8 * St)), Vt;
  }, re.prototype.readInt8 = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 1, this.length), this[gt] & 128 ? (255 - this[gt] + 1) * -1 : this[gt];
  }, re.prototype.readInt16LE = function(gt, St) {
    gt = gt >>> 0, St || Nt(gt, 2, this.length);
    const Ct = this[gt] | this[gt + 1] << 8;
    return Ct & 32768 ? Ct | 4294901760 : Ct;
  }, re.prototype.readInt16BE = function(gt, St) {
    gt = gt >>> 0, St || Nt(gt, 2, this.length);
    const Ct = this[gt + 1] | this[gt] << 8;
    return Ct & 32768 ? Ct | 4294901760 : Ct;
  }, re.prototype.readInt32LE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 4, this.length), this[gt] | this[gt + 1] << 8 | this[gt + 2] << 16 | this[gt + 3] << 24;
  }, re.prototype.readInt32BE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 4, this.length), this[gt] << 24 | this[gt + 1] << 16 | this[gt + 2] << 8 | this[gt + 3];
  }, re.prototype.readBigInt64LE = Ir(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const St = this[gt], Ct = this[gt + 7];
    (St === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = this[gt + 4] + this[gt + 5] * 2 ** 8 + this[gt + 6] * 2 ** 16 + (Ct << 24);
    return (BigInt(Wt) << BigInt(32)) + BigInt(St + this[++gt] * 2 ** 8 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 24);
  }), re.prototype.readBigInt64BE = Ir(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const St = this[gt], Ct = this[gt + 7];
    (St === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = (St << 24) + // Overflow
    this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + this[++gt];
    return (BigInt(Wt) << BigInt(32)) + BigInt(this[++gt] * 2 ** 24 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + Ct);
  }), re.prototype.readFloatLE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 4, this.length), L.read(this, gt, !0, 23, 4);
  }, re.prototype.readFloatBE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 4, this.length), L.read(this, gt, !1, 23, 4);
  }, re.prototype.readDoubleLE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 8, this.length), L.read(this, gt, !0, 52, 8);
  }, re.prototype.readDoubleBE = function(gt, St) {
    return gt = gt >>> 0, St || Nt(gt, 8, this.length), L.read(this, gt, !1, 52, 8);
  };
  function jt(Rt, gt, St, Ct, Wt, zt) {
    if (!re.isBuffer(Rt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (gt > Wt || gt < zt) throw new RangeError('"value" argument is out of bounds');
    if (St + Ct > Rt.length) throw new RangeError("Index out of range");
  }
  re.prototype.writeUintLE = re.prototype.writeUIntLE = function(gt, St, Ct, Wt) {
    if (gt = +gt, St = St >>> 0, Ct = Ct >>> 0, !Wt) {
      const yr = Math.pow(2, 8 * Ct) - 1;
      jt(this, gt, St, Ct, yr, 0);
    }
    let zt = 1, Vt = 0;
    for (this[St] = gt & 255; ++Vt < Ct && (zt *= 256); )
      this[St + Vt] = gt / zt & 255;
    return St + Ct;
  }, re.prototype.writeUintBE = re.prototype.writeUIntBE = function(gt, St, Ct, Wt) {
    if (gt = +gt, St = St >>> 0, Ct = Ct >>> 0, !Wt) {
      const yr = Math.pow(2, 8 * Ct) - 1;
      jt(this, gt, St, Ct, yr, 0);
    }
    let zt = Ct - 1, Vt = 1;
    for (this[St + zt] = gt & 255; --zt >= 0 && (Vt *= 256); )
      this[St + zt] = gt / Vt & 255;
    return St + Ct;
  }, re.prototype.writeUint8 = re.prototype.writeUInt8 = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 1, 255, 0), this[St] = gt & 255, St + 1;
  }, re.prototype.writeUint16LE = re.prototype.writeUInt16LE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 2, 65535, 0), this[St] = gt & 255, this[St + 1] = gt >>> 8, St + 2;
  }, re.prototype.writeUint16BE = re.prototype.writeUInt16BE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 2, 65535, 0), this[St] = gt >>> 8, this[St + 1] = gt & 255, St + 2;
  }, re.prototype.writeUint32LE = re.prototype.writeUInt32LE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 4, 4294967295, 0), this[St + 3] = gt >>> 24, this[St + 2] = gt >>> 16, this[St + 1] = gt >>> 8, this[St] = gt & 255, St + 4;
  }, re.prototype.writeUint32BE = re.prototype.writeUInt32BE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 4, 4294967295, 0), this[St] = gt >>> 24, this[St + 1] = gt >>> 16, this[St + 2] = gt >>> 8, this[St + 3] = gt & 255, St + 4;
  };
  function Ot(Rt, gt, St, Ct, Wt) {
    rr(gt, Ct, Wt, Rt, St, 7);
    let zt = Number(gt & BigInt(4294967295));
    Rt[St++] = zt, zt = zt >> 8, Rt[St++] = zt, zt = zt >> 8, Rt[St++] = zt, zt = zt >> 8, Rt[St++] = zt;
    let Vt = Number(gt >> BigInt(32) & BigInt(4294967295));
    return Rt[St++] = Vt, Vt = Vt >> 8, Rt[St++] = Vt, Vt = Vt >> 8, Rt[St++] = Vt, Vt = Vt >> 8, Rt[St++] = Vt, St;
  }
  function Bt(Rt, gt, St, Ct, Wt) {
    rr(gt, Ct, Wt, Rt, St, 7);
    let zt = Number(gt & BigInt(4294967295));
    Rt[St + 7] = zt, zt = zt >> 8, Rt[St + 6] = zt, zt = zt >> 8, Rt[St + 5] = zt, zt = zt >> 8, Rt[St + 4] = zt;
    let Vt = Number(gt >> BigInt(32) & BigInt(4294967295));
    return Rt[St + 3] = Vt, Vt = Vt >> 8, Rt[St + 2] = Vt, Vt = Vt >> 8, Rt[St + 1] = Vt, Vt = Vt >> 8, Rt[St] = Vt, St + 8;
  }
  re.prototype.writeBigUInt64LE = Ir(function(gt, St = 0) {
    return Ot(this, gt, St, BigInt(0), BigInt("0xffffffffffffffff"));
  }), re.prototype.writeBigUInt64BE = Ir(function(gt, St = 0) {
    return Bt(this, gt, St, BigInt(0), BigInt("0xffffffffffffffff"));
  }), re.prototype.writeIntLE = function(gt, St, Ct, Wt) {
    if (gt = +gt, St = St >>> 0, !Wt) {
      const xr = Math.pow(2, 8 * Ct - 1);
      jt(this, gt, St, Ct, xr - 1, -xr);
    }
    let zt = 0, Vt = 1, yr = 0;
    for (this[St] = gt & 255; ++zt < Ct && (Vt *= 256); )
      gt < 0 && yr === 0 && this[St + zt - 1] !== 0 && (yr = 1), this[St + zt] = (gt / Vt >> 0) - yr & 255;
    return St + Ct;
  }, re.prototype.writeIntBE = function(gt, St, Ct, Wt) {
    if (gt = +gt, St = St >>> 0, !Wt) {
      const xr = Math.pow(2, 8 * Ct - 1);
      jt(this, gt, St, Ct, xr - 1, -xr);
    }
    let zt = Ct - 1, Vt = 1, yr = 0;
    for (this[St + zt] = gt & 255; --zt >= 0 && (Vt *= 256); )
      gt < 0 && yr === 0 && this[St + zt + 1] !== 0 && (yr = 1), this[St + zt] = (gt / Vt >> 0) - yr & 255;
    return St + Ct;
  }, re.prototype.writeInt8 = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 1, 127, -128), gt < 0 && (gt = 255 + gt + 1), this[St] = gt & 255, St + 1;
  }, re.prototype.writeInt16LE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 2, 32767, -32768), this[St] = gt & 255, this[St + 1] = gt >>> 8, St + 2;
  }, re.prototype.writeInt16BE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 2, 32767, -32768), this[St] = gt >>> 8, this[St + 1] = gt & 255, St + 2;
  }, re.prototype.writeInt32LE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 4, 2147483647, -2147483648), this[St] = gt & 255, this[St + 1] = gt >>> 8, this[St + 2] = gt >>> 16, this[St + 3] = gt >>> 24, St + 4;
  }, re.prototype.writeInt32BE = function(gt, St, Ct) {
    return gt = +gt, St = St >>> 0, Ct || jt(this, gt, St, 4, 2147483647, -2147483648), gt < 0 && (gt = 4294967295 + gt + 1), this[St] = gt >>> 24, this[St + 1] = gt >>> 16, this[St + 2] = gt >>> 8, this[St + 3] = gt & 255, St + 4;
  }, re.prototype.writeBigInt64LE = Ir(function(gt, St = 0) {
    return Ot(this, gt, St, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), re.prototype.writeBigInt64BE = Ir(function(gt, St = 0) {
    return Bt(this, gt, St, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Tt(Rt, gt, St, Ct, Wt, zt) {
    if (St + Ct > Rt.length) throw new RangeError("Index out of range");
    if (St < 0) throw new RangeError("Index out of range");
  }
  function Ut(Rt, gt, St, Ct, Wt) {
    return gt = +gt, St = St >>> 0, Wt || Tt(Rt, gt, St, 4), L.write(Rt, gt, St, Ct, 23, 4), St + 4;
  }
  re.prototype.writeFloatLE = function(gt, St, Ct) {
    return Ut(this, gt, St, !0, Ct);
  }, re.prototype.writeFloatBE = function(gt, St, Ct) {
    return Ut(this, gt, St, !1, Ct);
  };
  function Gt(Rt, gt, St, Ct, Wt) {
    return gt = +gt, St = St >>> 0, Wt || Tt(Rt, gt, St, 8), L.write(Rt, gt, St, Ct, 52, 8), St + 8;
  }
  re.prototype.writeDoubleLE = function(gt, St, Ct) {
    return Gt(this, gt, St, !0, Ct);
  }, re.prototype.writeDoubleBE = function(gt, St, Ct) {
    return Gt(this, gt, St, !1, Ct);
  }, re.prototype.copy = function(gt, St, Ct, Wt) {
    if (!re.isBuffer(gt)) throw new TypeError("argument should be a Buffer");
    if (Ct || (Ct = 0), !Wt && Wt !== 0 && (Wt = this.length), St >= gt.length && (St = gt.length), St || (St = 0), Wt > 0 && Wt < Ct && (Wt = Ct), Wt === Ct || gt.length === 0 || this.length === 0) return 0;
    if (St < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ct < 0 || Ct >= this.length) throw new RangeError("Index out of range");
    if (Wt < 0) throw new RangeError("sourceEnd out of bounds");
    Wt > this.length && (Wt = this.length), gt.length - St < Wt - Ct && (Wt = gt.length - St + Ct);
    const zt = Wt - Ct;
    return this === gt && typeof W.prototype.copyWithin == "function" ? this.copyWithin(St, Ct, Wt) : W.prototype.set.call(
      gt,
      this.subarray(Ct, Wt),
      St
    ), zt;
  }, re.prototype.fill = function(gt, St, Ct, Wt) {
    if (typeof gt == "string") {
      if (typeof St == "string" ? (Wt = St, St = 0, Ct = this.length) : typeof Ct == "string" && (Wt = Ct, Ct = this.length), Wt !== void 0 && typeof Wt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Wt == "string" && !re.isEncoding(Wt))
        throw new TypeError("Unknown encoding: " + Wt);
      if (gt.length === 1) {
        const Vt = gt.charCodeAt(0);
        (Wt === "utf8" && Vt < 128 || Wt === "latin1") && (gt = Vt);
      }
    } else typeof gt == "number" ? gt = gt & 255 : typeof gt == "boolean" && (gt = Number(gt));
    if (St < 0 || this.length < St || this.length < Ct)
      throw new RangeError("Out of range index");
    if (Ct <= St)
      return this;
    St = St >>> 0, Ct = Ct === void 0 ? this.length : Ct >>> 0, gt || (gt = 0);
    let zt;
    if (typeof gt == "number")
      for (zt = St; zt < Ct; ++zt)
        this[zt] = gt;
    else {
      const Vt = re.isBuffer(gt) ? gt : re.from(gt, Wt), yr = Vt.length;
      if (yr === 0)
        throw new TypeError('The value "' + gt + '" is invalid for argument "value"');
      for (zt = 0; zt < Ct - St; ++zt)
        this[zt + St] = Vt[zt % yr];
    }
    return this;
  };
  const It = {};
  function Mt(Rt, gt, St) {
    It[Rt] = class extends St {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: gt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Rt}]`, this.stack, delete this.name;
      }
      get code() {
        return Rt;
      }
      set code(Wt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Wt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Rt}]: ${this.message}`;
      }
    };
  }
  Mt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Rt) {
      return Rt ? `${Rt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Mt(
    "ERR_INVALID_ARG_TYPE",
    function(Rt, gt) {
      return `The "${Rt}" argument must be of type number. Received type ${typeof gt}`;
    },
    TypeError
  ), Mt(
    "ERR_OUT_OF_RANGE",
    function(Rt, gt, St) {
      let Ct = `The value of "${Rt}" is out of range.`, Wt = St;
      return Number.isInteger(St) && Math.abs(St) > 2 ** 32 ? Wt = Kt(String(St)) : typeof St == "bigint" && (Wt = String(St), (St > BigInt(2) ** BigInt(32) || St < -(BigInt(2) ** BigInt(32))) && (Wt = Kt(Wt)), Wt += "n"), Ct += ` It must be ${gt}. Received ${Wt}`, Ct;
    },
    RangeError
  );
  function Kt(Rt) {
    let gt = "", St = Rt.length;
    const Ct = Rt[0] === "-" ? 1 : 0;
    for (; St >= Ct + 4; St -= 3)
      gt = `_${Rt.slice(St - 3, St)}${gt}`;
    return `${Rt.slice(0, St)}${gt}`;
  }
  function Qt(Rt, gt, St) {
    ar(gt, "offset"), (Rt[gt] === void 0 || Rt[gt + St] === void 0) && ur(gt, Rt.length - (St + 1));
  }
  function rr(Rt, gt, St, Ct, Wt, zt) {
    if (Rt > St || Rt < gt) {
      const Vt = typeof gt == "bigint" ? "n" : "";
      let yr;
      throw gt === 0 || gt === BigInt(0) ? yr = `>= 0${Vt} and < 2${Vt} ** ${(zt + 1) * 8}${Vt}` : yr = `>= -(2${Vt} ** ${(zt + 1) * 8 - 1}${Vt}) and < 2 ** ${(zt + 1) * 8 - 1}${Vt}`, new It.ERR_OUT_OF_RANGE("value", yr, Rt);
    }
    Qt(Ct, Wt, zt);
  }
  function ar(Rt, gt) {
    if (typeof Rt != "number")
      throw new It.ERR_INVALID_ARG_TYPE(gt, "number", Rt);
  }
  function ur(Rt, gt, St) {
    throw Math.floor(Rt) !== Rt ? (ar(Rt, St), new It.ERR_OUT_OF_RANGE("offset", "an integer", Rt)) : gt < 0 ? new It.ERR_BUFFER_OUT_OF_BOUNDS() : new It.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${gt}`,
      Rt
    );
  }
  const hr = /[^+/0-9A-Za-z-_]/g;
  function Yt(Rt) {
    if (Rt = Rt.split("=")[0], Rt = Rt.trim().replace(hr, ""), Rt.length < 2) return "";
    for (; Rt.length % 4 !== 0; )
      Rt = Rt + "=";
    return Rt;
  }
  function Rr(Rt, gt) {
    gt = gt || 1 / 0;
    let St;
    const Ct = Rt.length;
    let Wt = null;
    const zt = [];
    for (let Vt = 0; Vt < Ct; ++Vt) {
      if (St = Rt.charCodeAt(Vt), St > 55295 && St < 57344) {
        if (!Wt) {
          if (St > 56319) {
            (gt -= 3) > -1 && zt.push(239, 191, 189);
            continue;
          } else if (Vt + 1 === Ct) {
            (gt -= 3) > -1 && zt.push(239, 191, 189);
            continue;
          }
          Wt = St;
          continue;
        }
        if (St < 56320) {
          (gt -= 3) > -1 && zt.push(239, 191, 189), Wt = St;
          continue;
        }
        St = (Wt - 55296 << 10 | St - 56320) + 65536;
      } else Wt && (gt -= 3) > -1 && zt.push(239, 191, 189);
      if (Wt = null, St < 128) {
        if ((gt -= 1) < 0) break;
        zt.push(St);
      } else if (St < 2048) {
        if ((gt -= 2) < 0) break;
        zt.push(
          St >> 6 | 192,
          St & 63 | 128
        );
      } else if (St < 65536) {
        if ((gt -= 3) < 0) break;
        zt.push(
          St >> 12 | 224,
          St >> 6 & 63 | 128,
          St & 63 | 128
        );
      } else if (St < 1114112) {
        if ((gt -= 4) < 0) break;
        zt.push(
          St >> 18 | 240,
          St >> 12 & 63 | 128,
          St >> 6 & 63 | 128,
          St & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return zt;
  }
  function lr(Rt) {
    const gt = [];
    for (let St = 0; St < Rt.length; ++St)
      gt.push(Rt.charCodeAt(St) & 255);
    return gt;
  }
  function $r(Rt, gt) {
    let St, Ct, Wt;
    const zt = [];
    for (let Vt = 0; Vt < Rt.length && !((gt -= 2) < 0); ++Vt)
      St = Rt.charCodeAt(Vt), Ct = St >> 8, Wt = St % 256, zt.push(Wt), zt.push(Ct);
    return zt;
  }
  function Br(Rt) {
    return B.toByteArray(Yt(Rt));
  }
  function dr(Rt, gt, St, Ct) {
    let Wt;
    for (Wt = 0; Wt < Ct && !(Wt + St >= gt.length || Wt >= Rt.length); ++Wt)
      gt[Wt + St] = Rt[Wt];
    return Wt;
  }
  function Sr(Rt, gt) {
    return Rt instanceof gt || Rt != null && Rt.constructor != null && Rt.constructor.name != null && Rt.constructor.name === gt.name;
  }
  function Mr(Rt) {
    return Rt !== Rt;
  }
  const br = function() {
    const Rt = "0123456789abcdef", gt = new Array(256);
    for (let St = 0; St < 16; ++St) {
      const Ct = St * 16;
      for (let Wt = 0; Wt < 16; ++Wt)
        gt[Ct + Wt] = Rt[St] + Rt[Wt];
    }
    return gt;
  }();
  function Ir(Rt) {
    return typeof BigInt > "u" ? Or : Rt;
  }
  function Or() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(A, B) {
  var L = require$$0$1, K = L.Buffer;
  function J(V, ne) {
    for (var ie in V)
      ne[ie] = V[ie];
  }
  K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (J(L, B), B.Buffer = W);
  function W(V, ne, ie) {
    return K(V, ne, ie);
  }
  W.prototype = Object.create(K.prototype), J(K, W), W.from = function(V, ne, ie) {
    if (typeof V == "number")
      throw new TypeError("Argument must not be a number");
    return K(V, ne, ie);
  }, W.alloc = function(V, ne, ie) {
    if (typeof V != "number")
      throw new TypeError("Argument must be a number");
    var oe = K(V);
    return ne !== void 0 ? typeof ie == "string" ? oe.fill(ne, ie) : oe.fill(ne) : oe.fill(0), oe;
  }, W.allocUnsafe = function(V) {
    if (typeof V != "number")
      throw new TypeError("Argument must be a number");
    return K(V);
  }, W.allocUnsafeSlow = function(V) {
    if (typeof V != "number")
      throw new TypeError("Argument must be a number");
    return L.SlowBuffer(V);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var A = 65536, B = 4294967295;
  function L() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var K = safeBufferExports.Buffer, J = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  J && J.getRandomValues ? browser$b.exports = W : browser$b.exports = L;
  function W(V, ne) {
    if (V > B) throw new RangeError("requested too many random bytes");
    var ie = K.allocUnsafe(V);
    if (V > 0)
      if (V > A)
        for (var oe = 0; oe < V; oe += A)
          J.getRandomValues(ie.slice(oe, oe + A));
      else
        J.getRandomValues(ie);
    return typeof ne == "function" ? process$1.nextTick(function() {
      ne(null, ie);
    }) : ie;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(B, L) {
    L && (B.super_ = L, B.prototype = Object.create(L.prototype, {
      constructor: {
        value: B,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(B, L) {
    if (L) {
      B.super_ = L;
      var K = function() {
      };
      K.prototype = L.prototype, B.prototype = new K(), B.prototype.constructor = B;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var A = typeof Reflect == "object" ? Reflect : null, B = A && typeof A.apply == "function" ? A.apply : function(Pt, $t, qt) {
    return Function.prototype.apply.call(Pt, $t, qt);
  }, L;
  A && typeof A.ownKeys == "function" ? L = A.ownKeys : Object.getOwnPropertySymbols ? L = function(Pt) {
    return Object.getOwnPropertyNames(Pt).concat(Object.getOwnPropertySymbols(Pt));
  } : L = function(Pt) {
    return Object.getOwnPropertyNames(Pt);
  };
  function K(mt) {
    console && console.warn && console.warn(mt);
  }
  var J = Number.isNaN || function(Pt) {
    return Pt !== Pt;
  };
  function W() {
    W.init.call(this);
  }
  events.exports = W, events.exports.once = ht, W.EventEmitter = W, W.prototype._events = void 0, W.prototype._eventsCount = 0, W.prototype._maxListeners = void 0;
  var V = 10;
  function ne(mt) {
    if (typeof mt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof mt);
  }
  Object.defineProperty(W, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return V;
    },
    set: function(mt) {
      if (typeof mt != "number" || mt < 0 || J(mt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + mt + ".");
      V = mt;
    }
  }), W.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, W.prototype.setMaxListeners = function(Pt) {
    if (typeof Pt != "number" || Pt < 0 || J(Pt))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Pt + ".");
    return this._maxListeners = Pt, this;
  };
  function ie(mt) {
    return mt._maxListeners === void 0 ? W.defaultMaxListeners : mt._maxListeners;
  }
  W.prototype.getMaxListeners = function() {
    return ie(this);
  }, W.prototype.emit = function(Pt) {
    for (var $t = [], qt = 1; qt < arguments.length; qt++) $t.push(arguments[qt]);
    var At = Pt === "error", bt = this._events;
    if (bt !== void 0)
      At = At && bt.error === void 0;
    else if (!At)
      return !1;
    if (At) {
      var xt;
      if ($t.length > 0 && (xt = $t[0]), xt instanceof Error)
        throw xt;
      var wt = new Error("Unhandled error." + (xt ? " (" + xt.message + ")" : ""));
      throw wt.context = xt, wt;
    }
    var Oe = bt[Pt];
    if (Oe === void 0)
      return !1;
    if (typeof Oe == "function")
      B(Oe, this, $t);
    else
      for (var rt = Oe.length, pe = it(Oe, rt), qt = 0; qt < rt; ++qt)
        B(pe[qt], this, $t);
    return !0;
  };
  function oe(mt, Pt, $t, qt) {
    var At, bt, xt;
    if (ne($t), bt = mt._events, bt === void 0 ? (bt = mt._events = /* @__PURE__ */ Object.create(null), mt._eventsCount = 0) : (bt.newListener !== void 0 && (mt.emit(
      "newListener",
      Pt,
      $t.listener ? $t.listener : $t
    ), bt = mt._events), xt = bt[Pt]), xt === void 0)
      xt = bt[Pt] = $t, ++mt._eventsCount;
    else if (typeof xt == "function" ? xt = bt[Pt] = qt ? [$t, xt] : [xt, $t] : qt ? xt.unshift($t) : xt.push($t), At = ie(mt), At > 0 && xt.length > At && !xt.warned) {
      xt.warned = !0;
      var wt = new Error("Possible EventEmitter memory leak detected. " + xt.length + " " + String(Pt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      wt.name = "MaxListenersExceededWarning", wt.emitter = mt, wt.type = Pt, wt.count = xt.length, K(wt);
    }
    return mt;
  }
  W.prototype.addListener = function(Pt, $t) {
    return oe(this, Pt, $t, !1);
  }, W.prototype.on = W.prototype.addListener, W.prototype.prependListener = function(Pt, $t) {
    return oe(this, Pt, $t, !0);
  };
  function re() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function ce(mt, Pt, $t) {
    var qt = { fired: !1, wrapFn: void 0, target: mt, type: Pt, listener: $t }, At = re.bind(qt);
    return At.listener = $t, qt.wrapFn = At, At;
  }
  W.prototype.once = function(Pt, $t) {
    return ne($t), this.on(Pt, ce(this, Pt, $t)), this;
  }, W.prototype.prependOnceListener = function(Pt, $t) {
    return ne($t), this.prependListener(Pt, ce(this, Pt, $t)), this;
  }, W.prototype.removeListener = function(Pt, $t) {
    var qt, At, bt, xt, wt;
    if (ne($t), At = this._events, At === void 0)
      return this;
    if (qt = At[Pt], qt === void 0)
      return this;
    if (qt === $t || qt.listener === $t)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete At[Pt], At.removeListener && this.emit("removeListener", Pt, qt.listener || $t));
    else if (typeof qt != "function") {
      for (bt = -1, xt = qt.length - 1; xt >= 0; xt--)
        if (qt[xt] === $t || qt[xt].listener === $t) {
          wt = qt[xt].listener, bt = xt;
          break;
        }
      if (bt < 0)
        return this;
      bt === 0 ? qt.shift() : at(qt, bt), qt.length === 1 && (At[Pt] = qt[0]), At.removeListener !== void 0 && this.emit("removeListener", Pt, wt || $t);
    }
    return this;
  }, W.prototype.off = W.prototype.removeListener, W.prototype.removeAllListeners = function(Pt) {
    var $t, qt, At;
    if (qt = this._events, qt === void 0)
      return this;
    if (qt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : qt[Pt] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete qt[Pt]), this;
    if (arguments.length === 0) {
      var bt = Object.keys(qt), xt;
      for (At = 0; At < bt.length; ++At)
        xt = bt[At], xt !== "removeListener" && this.removeAllListeners(xt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if ($t = qt[Pt], typeof $t == "function")
      this.removeListener(Pt, $t);
    else if ($t !== void 0)
      for (At = $t.length - 1; At >= 0; At--)
        this.removeListener(Pt, $t[At]);
    return this;
  };
  function ke(mt, Pt, $t) {
    var qt = mt._events;
    if (qt === void 0)
      return [];
    var At = qt[Pt];
    return At === void 0 ? [] : typeof At == "function" ? $t ? [At.listener || At] : [At] : $t ? lt(At) : it(At, At.length);
  }
  W.prototype.listeners = function(Pt) {
    return ke(this, Pt, !0);
  }, W.prototype.rawListeners = function(Pt) {
    return ke(this, Pt, !1);
  }, W.listenerCount = function(mt, Pt) {
    return typeof mt.listenerCount == "function" ? mt.listenerCount(Pt) : Ce.call(mt, Pt);
  }, W.prototype.listenerCount = Ce;
  function Ce(mt) {
    var Pt = this._events;
    if (Pt !== void 0) {
      var $t = Pt[mt];
      if (typeof $t == "function")
        return 1;
      if ($t !== void 0)
        return $t.length;
    }
    return 0;
  }
  W.prototype.eventNames = function() {
    return this._eventsCount > 0 ? L(this._events) : [];
  };
  function it(mt, Pt) {
    for (var $t = new Array(Pt), qt = 0; qt < Pt; ++qt)
      $t[qt] = mt[qt];
    return $t;
  }
  function at(mt, Pt) {
    for (; Pt + 1 < mt.length; Pt++)
      mt[Pt] = mt[Pt + 1];
    mt.pop();
  }
  function lt(mt) {
    for (var Pt = new Array(mt.length), $t = 0; $t < Pt.length; ++$t)
      Pt[$t] = mt[$t].listener || mt[$t];
    return Pt;
  }
  function ht(mt, Pt) {
    return new Promise(function($t, qt) {
      function At(xt) {
        mt.removeListener(Pt, bt), qt(xt);
      }
      function bt() {
        typeof mt.removeListener == "function" && mt.removeListener("error", At), $t([].slice.call(arguments));
      }
      vt(mt, Pt, bt, { once: !0 }), Pt !== "error" && dt(mt, At, { once: !0 });
    });
  }
  function dt(mt, Pt, $t) {
    typeof mt.on == "function" && vt(mt, "error", Pt, $t);
  }
  function vt(mt, Pt, $t, qt) {
    if (typeof mt.on == "function")
      qt.once ? mt.once(Pt, $t) : mt.on(Pt, $t);
    else if (typeof mt.addEventListener == "function")
      mt.addEventListener(Pt, function At(bt) {
        qt.once && mt.removeEventListener(Pt, At), $t(bt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof mt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var B = {}, L = Symbol("test"), K = Object(L);
    if (typeof L == "string" || Object.prototype.toString.call(L) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]")
      return !1;
    var J = 42;
    B[L] = J;
    for (L in B)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0)
      return !1;
    var W = Object.getOwnPropertySymbols(B);
    if (W.length !== 1 || W[0] !== L || !Object.prototype.propertyIsEnumerable.call(B, L))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var V = Object.getOwnPropertyDescriptor(B, L);
      if (V.value !== J || V.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var A = requireShams$1();
  return shams = function() {
    return A() && !!Symbol.toStringTag;
  }, shams;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var A = typeof Symbol < "u" && Symbol, B = requireShams$1();
  return hasSymbols = function() {
    return typeof A != "function" || typeof Symbol != "function" || typeof A("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : B();
  }, hasSymbols;
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var A = {
    __proto__: null,
    foo: {}
  }, B = Object;
  return hasProto = function() {
    return { __proto__: A }.foo === A.foo && !(A instanceof B);
  }, hasProto;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var A = "Function.prototype.bind called on incompatible ", B = Object.prototype.toString, L = Math.max, K = "[object Function]", J = function(ie, oe) {
    for (var re = [], ce = 0; ce < ie.length; ce += 1)
      re[ce] = ie[ce];
    for (var ke = 0; ke < oe.length; ke += 1)
      re[ke + ie.length] = oe[ke];
    return re;
  }, W = function(ie, oe) {
    for (var re = [], ce = oe, ke = 0; ce < ie.length; ce += 1, ke += 1)
      re[ke] = ie[ce];
    return re;
  }, V = function(ne, ie) {
    for (var oe = "", re = 0; re < ne.length; re += 1)
      oe += ne[re], re + 1 < ne.length && (oe += ie);
    return oe;
  };
  return implementation = function(ie) {
    var oe = this;
    if (typeof oe != "function" || B.apply(oe) !== K)
      throw new TypeError(A + oe);
    for (var re = W(arguments, 1), ce, ke = function() {
      if (this instanceof ce) {
        var ht = oe.apply(
          this,
          J(re, arguments)
        );
        return Object(ht) === ht ? ht : this;
      }
      return oe.apply(
        ie,
        J(re, arguments)
      );
    }, Ce = L(0, oe.length - re.length), it = [], at = 0; at < Ce; at++)
      it[at] = "$" + at;
    if (ce = Function("binder", "return function (" + V(it, ",") + "){ return binder.apply(this,arguments); }")(ke), oe.prototype) {
      var lt = function() {
      };
      lt.prototype = oe.prototype, ce.prototype = new lt(), lt.prototype = null;
    }
    return ce;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var A = requireImplementation();
  return functionBind = Function.prototype.bind || A, functionBind;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var A = Function.prototype.call, B = Object.prototype.hasOwnProperty, L = requireFunctionBind();
  return hasown = L.call(A, B), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var A, B = requireEsErrors(), L = require_eval(), K = requireRange(), J = requireRef(), W = requireSyntax(), V = requireType(), ne = requireUri(), ie = Function, oe = function(st) {
    try {
      return ie('"use strict"; return (' + st + ").constructor;")();
    } catch {
    }
  }, re = Object.getOwnPropertyDescriptor;
  if (re)
    try {
      re({}, "");
    } catch {
      re = null;
    }
  var ce = function() {
    throw new V();
  }, ke = re ? function() {
    try {
      return arguments.callee, ce;
    } catch {
      try {
        return re(arguments, "callee").get;
      } catch {
        return ce;
      }
    }
  }() : ce, Ce = requireHasSymbols()(), it = requireHasProto()(), at = Object.getPrototypeOf || (it ? function(st) {
    return st.__proto__;
  } : null), lt = {}, ht = typeof Uint8Array > "u" || !at ? A : at(Uint8Array), dt = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? A : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? A : ArrayBuffer,
    "%ArrayIteratorPrototype%": Ce && at ? at([][Symbol.iterator]()) : A,
    "%AsyncFromSyncIteratorPrototype%": A,
    "%AsyncFunction%": lt,
    "%AsyncGenerator%": lt,
    "%AsyncGeneratorFunction%": lt,
    "%AsyncIteratorPrototype%": lt,
    "%Atomics%": typeof Atomics > "u" ? A : Atomics,
    "%BigInt%": typeof BigInt > "u" ? A : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? A : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? A : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? A : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": B,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": L,
    "%Float32Array%": typeof Float32Array > "u" ? A : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? A : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? A : FinalizationRegistry,
    "%Function%": ie,
    "%GeneratorFunction%": lt,
    "%Int8Array%": typeof Int8Array > "u" ? A : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? A : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? A : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Ce && at ? at(at([][Symbol.iterator]())) : A,
    "%JSON%": typeof JSON == "object" ? JSON : A,
    "%Map%": typeof Map > "u" ? A : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Ce || !at ? A : at((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? A : Promise,
    "%Proxy%": typeof Proxy > "u" ? A : Proxy,
    "%RangeError%": K,
    "%ReferenceError%": J,
    "%Reflect%": typeof Reflect > "u" ? A : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? A : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Ce || !at ? A : at((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? A : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Ce && at ? at(""[Symbol.iterator]()) : A,
    "%Symbol%": Ce ? Symbol : A,
    "%SyntaxError%": W,
    "%ThrowTypeError%": ke,
    "%TypedArray%": ht,
    "%TypeError%": V,
    "%Uint8Array%": typeof Uint8Array > "u" ? A : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? A : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? A : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? A : Uint32Array,
    "%URIError%": ne,
    "%WeakMap%": typeof WeakMap > "u" ? A : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? A : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? A : WeakSet
  };
  if (at)
    try {
      null.error;
    } catch (st) {
      var vt = at(at(st));
      dt["%Error.prototype%"] = vt;
    }
  var mt = function st(ut) {
    var pt;
    if (ut === "%AsyncFunction%")
      pt = oe("async function () {}");
    else if (ut === "%GeneratorFunction%")
      pt = oe("function* () {}");
    else if (ut === "%AsyncGeneratorFunction%")
      pt = oe("async function* () {}");
    else if (ut === "%AsyncGenerator%") {
      var ft = st("%AsyncGeneratorFunction%");
      ft && (pt = ft.prototype);
    } else if (ut === "%AsyncIteratorPrototype%") {
      var yt = st("%AsyncGenerator%");
      yt && at && (pt = at(yt.prototype));
    }
    return dt[ut] = pt, pt;
  }, Pt = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, $t = requireFunctionBind(), qt = requireHasown(), At = $t.call(Function.call, Array.prototype.concat), bt = $t.call(Function.apply, Array.prototype.splice), xt = $t.call(Function.call, String.prototype.replace), wt = $t.call(Function.call, String.prototype.slice), Oe = $t.call(Function.call, RegExp.prototype.exec), rt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, pe = /\\(\\)?/g, nt = function(ut) {
    var pt = wt(ut, 0, 1), ft = wt(ut, -1);
    if (pt === "%" && ft !== "%")
      throw new W("invalid intrinsic syntax, expected closing `%`");
    if (ft === "%" && pt !== "%")
      throw new W("invalid intrinsic syntax, expected opening `%`");
    var yt = [];
    return xt(ut, rt, function(ct, Et, Nt, jt) {
      yt[yt.length] = Nt ? xt(jt, pe, "$1") : Et || ct;
    }), yt;
  }, ot = function(ut, pt) {
    var ft = ut, yt;
    if (qt(Pt, ft) && (yt = Pt[ft], ft = "%" + yt[0] + "%"), qt(dt, ft)) {
      var ct = dt[ft];
      if (ct === lt && (ct = mt(ft)), typeof ct > "u" && !pt)
        throw new V("intrinsic " + ut + " exists, but is not available. Please file an issue!");
      return {
        alias: yt,
        name: ft,
        value: ct
      };
    }
    throw new W("intrinsic " + ut + " does not exist!");
  };
  return getIntrinsic = function(ut, pt) {
    if (typeof ut != "string" || ut.length === 0)
      throw new V("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof pt != "boolean")
      throw new V('"allowMissing" argument must be a boolean');
    if (Oe(/^%?[^%]*%?$/, ut) === null)
      throw new W("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ft = nt(ut), yt = ft.length > 0 ? ft[0] : "", ct = ot("%" + yt + "%", pt), Et = ct.name, Nt = ct.value, jt = !1, Ot = ct.alias;
    Ot && (yt = Ot[0], bt(ft, At([0, 1], Ot)));
    for (var Bt = 1, Tt = !0; Bt < ft.length; Bt += 1) {
      var Ut = ft[Bt], Gt = wt(Ut, 0, 1), It = wt(Ut, -1);
      if ((Gt === '"' || Gt === "'" || Gt === "`" || It === '"' || It === "'" || It === "`") && Gt !== It)
        throw new W("property names with quotes must have matching quotes");
      if ((Ut === "constructor" || !Tt) && (jt = !0), yt += "." + Ut, Et = "%" + yt + "%", qt(dt, Et))
        Nt = dt[Et];
      else if (Nt != null) {
        if (!(Ut in Nt)) {
          if (!pt)
            throw new V("base intrinsic for " + ut + " exists, but the property is not available.");
          return;
        }
        if (re && Bt + 1 >= ft.length) {
          var Mt = re(Nt, Ut);
          Tt = !!Mt, Tt && "get" in Mt && !("originalValue" in Mt.get) ? Nt = Mt.get : Nt = Nt[Ut];
        } else
          Tt = qt(Nt, Ut), Nt = Nt[Ut];
        Tt && !jt && (dt[Et] = Nt);
      }
    }
    return Nt;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var A = requireGetIntrinsic(), B = A("%Object.defineProperty%", !0) || !1;
  if (B)
    try {
      B({}, "a", { value: 1 });
    } catch {
      B = !1;
    }
  return esDefineProperty = B, esDefineProperty;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var A = requireGetIntrinsic(), B = A("%Object.getOwnPropertyDescriptor%", !0);
  if (B)
    try {
      B([], "length");
    } catch {
      B = null;
    }
  return gopd = B, gopd;
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var A = requireEsDefineProperty(), B = requireSyntax(), L = requireType(), K = requireGopd();
  return defineDataProperty = function(W, V, ne) {
    if (!W || typeof W != "object" && typeof W != "function")
      throw new L("`obj` must be an object or a function`");
    if (typeof V != "string" && typeof V != "symbol")
      throw new L("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new L("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new L("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new L("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new L("`loose`, if provided, must be a boolean");
    var ie = arguments.length > 3 ? arguments[3] : null, oe = arguments.length > 4 ? arguments[4] : null, re = arguments.length > 5 ? arguments[5] : null, ce = arguments.length > 6 ? arguments[6] : !1, ke = !!K && K(W, V);
    if (A)
      A(W, V, {
        configurable: re === null && ke ? ke.configurable : !re,
        enumerable: ie === null && ke ? ke.enumerable : !ie,
        value: ne,
        writable: oe === null && ke ? ke.writable : !oe
      });
    else if (ce || !ie && !oe && !re)
      W[V] = ne;
    else
      throw new B("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var A = requireEsDefineProperty(), B = function() {
    return !!A;
  };
  return B.hasArrayLengthDefineBug = function() {
    if (!A)
      return null;
    try {
      return A([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = B, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var A = requireGetIntrinsic(), B = requireDefineDataProperty(), L = requireHasPropertyDescriptors()(), K = requireGopd(), J = requireType(), W = A("%Math.floor%");
  return setFunctionLength = function(ne, ie) {
    if (typeof ne != "function")
      throw new J("`fn` is not a function");
    if (typeof ie != "number" || ie < 0 || ie > 4294967295 || W(ie) !== ie)
      throw new J("`length` must be a positive 32-bit integer");
    var oe = arguments.length > 2 && !!arguments[2], re = !0, ce = !0;
    if ("length" in ne && K) {
      var ke = K(ne, "length");
      ke && !ke.configurable && (re = !1), ke && !ke.writable && (ce = !1);
    }
    return (re || ce || !oe) && (L ? B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie,
      !0,
      !0
    ) : B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie
    )), ne;
  }, setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(A) {
    var B = requireFunctionBind(), L = requireGetIntrinsic(), K = requireSetFunctionLength(), J = requireType(), W = L("%Function.prototype.apply%"), V = L("%Function.prototype.call%"), ne = L("%Reflect.apply%", !0) || B.call(V, W), ie = requireEsDefineProperty(), oe = L("%Math.max%");
    A.exports = function(ke) {
      if (typeof ke != "function")
        throw new J("a function is required");
      var Ce = ne(B, V, arguments);
      return K(
        Ce,
        1 + oe(0, ke.length - (arguments.length - 1)),
        !0
      );
    };
    var re = function() {
      return ne(B, W, arguments);
    };
    ie ? ie(A.exports, "apply", { value: re }) : A.exports.apply = re;
  }(callBind)), callBind.exports;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var A = requireGetIntrinsic(), B = requireCallBind(), L = B(A("String.prototype.indexOf"));
  return callBound = function(J, W) {
    var V = A(J, !!W);
    return typeof V == "function" && L(J, ".prototype.") > -1 ? B(V) : V;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var A = requireShams()(), B = requireCallBound(), L = B("Object.prototype.toString"), K = function(ne) {
    return A && ne && typeof ne == "object" && Symbol.toStringTag in ne ? !1 : L(ne) === "[object Arguments]";
  }, J = function(ne) {
    return K(ne) ? !0 : ne !== null && typeof ne == "object" && typeof ne.length == "number" && ne.length >= 0 && L(ne) !== "[object Array]" && L(ne.callee) === "[object Function]";
  }, W = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = J, isArguments = W ? K : J, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var A = Object.prototype.toString, B = Function.prototype.toString, L = /^\s*(?:function)?\*/, K = requireShams()(), J = Object.getPrototypeOf, W = function() {
    if (!K)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, V;
  return isGeneratorFunction = function(ie) {
    if (typeof ie != "function")
      return !1;
    if (L.test(B.call(ie)))
      return !0;
    if (!K) {
      var oe = A.call(ie);
      return oe === "[object GeneratorFunction]";
    }
    if (!J)
      return !1;
    if (typeof V > "u") {
      var re = W();
      V = re ? J(re) : !1;
    }
    return J(ie) === V;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var A = Function.prototype.toString, B = typeof Reflect == "object" && Reflect !== null && Reflect.apply, L, K;
  if (typeof B == "function" && typeof Object.defineProperty == "function")
    try {
      L = Object.defineProperty({}, "length", {
        get: function() {
          throw K;
        }
      }), K = {}, B(function() {
        throw 42;
      }, null, L);
    } catch (dt) {
      dt !== K && (B = null);
    }
  else
    B = null;
  var J = /^\s*class\b/, W = function(vt) {
    try {
      var mt = A.call(vt);
      return J.test(mt);
    } catch {
      return !1;
    }
  }, V = function(vt) {
    try {
      return W(vt) ? !1 : (A.call(vt), !0);
    } catch {
      return !1;
    }
  }, ne = Object.prototype.toString, ie = "[object Object]", oe = "[object Function]", re = "[object GeneratorFunction]", ce = "[object HTMLAllCollection]", ke = "[object HTML document.all class]", Ce = "[object HTMLCollection]", it = typeof Symbol == "function" && !!Symbol.toStringTag, at = !(0 in [,]), lt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var ht = document.all;
    ne.call(ht) === ne.call(document.all) && (lt = function(vt) {
      if ((at || !vt) && (typeof vt > "u" || typeof vt == "object"))
        try {
          var mt = ne.call(vt);
          return (mt === ce || mt === ke || mt === Ce || mt === ie) && vt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = B ? function(vt) {
    if (lt(vt))
      return !0;
    if (!vt || typeof vt != "function" && typeof vt != "object")
      return !1;
    try {
      B(vt, null, L);
    } catch (mt) {
      if (mt !== K)
        return !1;
    }
    return !W(vt) && V(vt);
  } : function(vt) {
    if (lt(vt))
      return !0;
    if (!vt || typeof vt != "function" && typeof vt != "object")
      return !1;
    if (it)
      return V(vt);
    if (W(vt))
      return !1;
    var mt = ne.call(vt);
    return mt !== oe && mt !== re && !/^\[object HTML/.test(mt) ? !1 : V(vt);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var A = requireIsCallable(), B = Object.prototype.toString, L = Object.prototype.hasOwnProperty, K = function(ie, oe, re) {
    for (var ce = 0, ke = ie.length; ce < ke; ce++)
      L.call(ie, ce) && (re == null ? oe(ie[ce], ce, ie) : oe.call(re, ie[ce], ce, ie));
  }, J = function(ie, oe, re) {
    for (var ce = 0, ke = ie.length; ce < ke; ce++)
      re == null ? oe(ie.charAt(ce), ce, ie) : oe.call(re, ie.charAt(ce), ce, ie);
  }, W = function(ie, oe, re) {
    for (var ce in ie)
      L.call(ie, ce) && (re == null ? oe(ie[ce], ce, ie) : oe.call(re, ie[ce], ce, ie));
  }, V = function(ie, oe, re) {
    if (!A(oe))
      throw new TypeError("iterator must be a function");
    var ce;
    arguments.length >= 3 && (ce = re), B.call(ie) === "[object Array]" ? K(ie, oe, ce) : typeof ie == "string" ? J(ie, oe, ce) : W(ie, oe, ce);
  };
  return forEach_1 = V, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var A = requirePossibleTypedArrayNames(), B = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], J = 0; J < A.length; J++)
      typeof B[A[J]] == "function" && (K[K.length] = A[J]);
    return K;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var A = requireForEach(), B = requireAvailableTypedArrays(), L = requireCallBind(), K = requireCallBound(), J = requireGopd(), W = K("Object.prototype.toString"), V = requireShams()(), ne = typeof globalThis > "u" ? commonjsGlobal : globalThis, ie = B(), oe = K("String.prototype.slice"), re = Object.getPrototypeOf, ce = K("Array.prototype.indexOf", !0) || function(lt, ht) {
    for (var dt = 0; dt < lt.length; dt += 1)
      if (lt[dt] === ht)
        return dt;
    return -1;
  }, ke = { __proto__: null };
  V && J && re ? A(ie, function(at) {
    var lt = new ne[at]();
    if (Symbol.toStringTag in lt) {
      var ht = re(lt), dt = J(ht, Symbol.toStringTag);
      if (!dt) {
        var vt = re(ht);
        dt = J(vt, Symbol.toStringTag);
      }
      ke["$" + at] = L(dt.get);
    }
  }) : A(ie, function(at) {
    var lt = new ne[at](), ht = lt.slice || lt.set;
    ht && (ke["$" + at] = L(ht));
  });
  var Ce = function(lt) {
    var ht = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(dt, vt) {
        if (!ht)
          try {
            "$" + dt(lt) === vt && (ht = oe(vt, 1));
          } catch {
          }
      }
    ), ht;
  }, it = function(lt) {
    var ht = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(dt, vt) {
        if (!ht)
          try {
            dt(lt), ht = oe(vt, 1);
          } catch {
          }
      }
    ), ht;
  };
  return whichTypedArray = function(lt) {
    if (!lt || typeof lt != "object")
      return !1;
    if (!V) {
      var ht = oe(W(lt), 8, -1);
      return ce(ie, ht) > -1 ? ht : ht !== "Object" ? !1 : it(lt);
    }
    return J ? Ce(lt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var A = requireWhichTypedArray();
  return isTypedArray = function(L) {
    return !!A(L);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(A) {
    var B = requireIsArguments(), L = requireIsGeneratorFunction(), K = requireWhichTypedArray(), J = requireIsTypedArray();
    function W(Yt) {
      return Yt.call.bind(Yt);
    }
    var V = typeof BigInt < "u", ne = typeof Symbol < "u", ie = W(Object.prototype.toString), oe = W(Number.prototype.valueOf), re = W(String.prototype.valueOf), ce = W(Boolean.prototype.valueOf);
    if (V)
      var ke = W(BigInt.prototype.valueOf);
    if (ne)
      var Ce = W(Symbol.prototype.valueOf);
    function it(Yt, Rr) {
      if (typeof Yt != "object")
        return !1;
      try {
        return Rr(Yt), !0;
      } catch {
        return !1;
      }
    }
    A.isArgumentsObject = B, A.isGeneratorFunction = L, A.isTypedArray = J;
    function at(Yt) {
      return typeof Promise < "u" && Yt instanceof Promise || Yt !== null && typeof Yt == "object" && typeof Yt.then == "function" && typeof Yt.catch == "function";
    }
    A.isPromise = at;
    function lt(Yt) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Yt) : J(Yt) || Et(Yt);
    }
    A.isArrayBufferView = lt;
    function ht(Yt) {
      return K(Yt) === "Uint8Array";
    }
    A.isUint8Array = ht;
    function dt(Yt) {
      return K(Yt) === "Uint8ClampedArray";
    }
    A.isUint8ClampedArray = dt;
    function vt(Yt) {
      return K(Yt) === "Uint16Array";
    }
    A.isUint16Array = vt;
    function mt(Yt) {
      return K(Yt) === "Uint32Array";
    }
    A.isUint32Array = mt;
    function Pt(Yt) {
      return K(Yt) === "Int8Array";
    }
    A.isInt8Array = Pt;
    function $t(Yt) {
      return K(Yt) === "Int16Array";
    }
    A.isInt16Array = $t;
    function qt(Yt) {
      return K(Yt) === "Int32Array";
    }
    A.isInt32Array = qt;
    function At(Yt) {
      return K(Yt) === "Float32Array";
    }
    A.isFloat32Array = At;
    function bt(Yt) {
      return K(Yt) === "Float64Array";
    }
    A.isFloat64Array = bt;
    function xt(Yt) {
      return K(Yt) === "BigInt64Array";
    }
    A.isBigInt64Array = xt;
    function wt(Yt) {
      return K(Yt) === "BigUint64Array";
    }
    A.isBigUint64Array = wt;
    function Oe(Yt) {
      return ie(Yt) === "[object Map]";
    }
    Oe.working = typeof Map < "u" && Oe(/* @__PURE__ */ new Map());
    function rt(Yt) {
      return typeof Map > "u" ? !1 : Oe.working ? Oe(Yt) : Yt instanceof Map;
    }
    A.isMap = rt;
    function pe(Yt) {
      return ie(Yt) === "[object Set]";
    }
    pe.working = typeof Set < "u" && pe(/* @__PURE__ */ new Set());
    function nt(Yt) {
      return typeof Set > "u" ? !1 : pe.working ? pe(Yt) : Yt instanceof Set;
    }
    A.isSet = nt;
    function ot(Yt) {
      return ie(Yt) === "[object WeakMap]";
    }
    ot.working = typeof WeakMap < "u" && ot(/* @__PURE__ */ new WeakMap());
    function st(Yt) {
      return typeof WeakMap > "u" ? !1 : ot.working ? ot(Yt) : Yt instanceof WeakMap;
    }
    A.isWeakMap = st;
    function ut(Yt) {
      return ie(Yt) === "[object WeakSet]";
    }
    ut.working = typeof WeakSet < "u" && ut(/* @__PURE__ */ new WeakSet());
    function pt(Yt) {
      return ut(Yt);
    }
    A.isWeakSet = pt;
    function ft(Yt) {
      return ie(Yt) === "[object ArrayBuffer]";
    }
    ft.working = typeof ArrayBuffer < "u" && ft(new ArrayBuffer());
    function yt(Yt) {
      return typeof ArrayBuffer > "u" ? !1 : ft.working ? ft(Yt) : Yt instanceof ArrayBuffer;
    }
    A.isArrayBuffer = yt;
    function ct(Yt) {
      return ie(Yt) === "[object DataView]";
    }
    ct.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ct(new DataView(new ArrayBuffer(1), 0, 1));
    function Et(Yt) {
      return typeof DataView > "u" ? !1 : ct.working ? ct(Yt) : Yt instanceof DataView;
    }
    A.isDataView = Et;
    var Nt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function jt(Yt) {
      return ie(Yt) === "[object SharedArrayBuffer]";
    }
    function Ot(Yt) {
      return typeof Nt > "u" ? !1 : (typeof jt.working > "u" && (jt.working = jt(new Nt())), jt.working ? jt(Yt) : Yt instanceof Nt);
    }
    A.isSharedArrayBuffer = Ot;
    function Bt(Yt) {
      return ie(Yt) === "[object AsyncFunction]";
    }
    A.isAsyncFunction = Bt;
    function Tt(Yt) {
      return ie(Yt) === "[object Map Iterator]";
    }
    A.isMapIterator = Tt;
    function Ut(Yt) {
      return ie(Yt) === "[object Set Iterator]";
    }
    A.isSetIterator = Ut;
    function Gt(Yt) {
      return ie(Yt) === "[object Generator]";
    }
    A.isGeneratorObject = Gt;
    function It(Yt) {
      return ie(Yt) === "[object WebAssembly.Module]";
    }
    A.isWebAssemblyCompiledModule = It;
    function Mt(Yt) {
      return it(Yt, oe);
    }
    A.isNumberObject = Mt;
    function Kt(Yt) {
      return it(Yt, re);
    }
    A.isStringObject = Kt;
    function Qt(Yt) {
      return it(Yt, ce);
    }
    A.isBooleanObject = Qt;
    function rr(Yt) {
      return V && it(Yt, ke);
    }
    A.isBigIntObject = rr;
    function ar(Yt) {
      return ne && it(Yt, Ce);
    }
    A.isSymbolObject = ar;
    function ur(Yt) {
      return Mt(Yt) || Kt(Yt) || Qt(Yt) || rr(Yt) || ar(Yt);
    }
    A.isBoxedPrimitive = ur;
    function hr(Yt) {
      return typeof Uint8Array < "u" && (yt(Yt) || Ot(Yt));
    }
    A.isAnyArrayBuffer = hr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Yt) {
      Object.defineProperty(A, Yt, {
        enumerable: !1,
        value: function() {
          throw new Error(Yt + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(B) {
    return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(A) {
    var B = Object.getOwnPropertyDescriptors || function(Et) {
      for (var Nt = Object.keys(Et), jt = {}, Ot = 0; Ot < Nt.length; Ot++)
        jt[Nt[Ot]] = Object.getOwnPropertyDescriptor(Et, Nt[Ot]);
      return jt;
    }, L = /%[sdj%]/g;
    A.format = function(ct) {
      if (!Pt(ct)) {
        for (var Et = [], Nt = 0; Nt < arguments.length; Nt++)
          Et.push(V(arguments[Nt]));
        return Et.join(" ");
      }
      for (var Nt = 1, jt = arguments, Ot = jt.length, Bt = String(ct).replace(L, function(Ut) {
        if (Ut === "%%") return "%";
        if (Nt >= Ot) return Ut;
        switch (Ut) {
          case "%s":
            return String(jt[Nt++]);
          case "%d":
            return Number(jt[Nt++]);
          case "%j":
            try {
              return JSON.stringify(jt[Nt++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ut;
        }
      }), Tt = jt[Nt]; Nt < Ot; Tt = jt[++Nt])
        dt(Tt) || !bt(Tt) ? Bt += " " + Tt : Bt += " " + V(Tt);
      return Bt;
    }, A.deprecate = function(ct, Et) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return ct;
      if (typeof process$1 > "u")
        return function() {
          return A.deprecate(ct, Et).apply(this, arguments);
        };
      var Nt = !1;
      function jt() {
        if (!Nt) {
          if (process$1.throwDeprecation)
            throw new Error(Et);
          process$1.traceDeprecation ? console.trace(Et) : console.error(Et), Nt = !0;
        }
        return ct.apply(this, arguments);
      }
      return jt;
    };
    var K = {}, J = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var W = process$1.env.NODE_DEBUG;
      W = W.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), J = new RegExp("^" + W + "$", "i");
    }
    A.debuglog = function(ct) {
      if (ct = ct.toUpperCase(), !K[ct])
        if (J.test(ct)) {
          var Et = process$1.pid;
          K[ct] = function() {
            var Nt = A.format.apply(A, arguments);
            console.error("%s %d: %s", ct, Et, Nt);
          };
        } else
          K[ct] = function() {
          };
      return K[ct];
    };
    function V(ct, Et) {
      var Nt = {
        seen: [],
        stylize: ie
      };
      return arguments.length >= 3 && (Nt.depth = arguments[2]), arguments.length >= 4 && (Nt.colors = arguments[3]), ht(Et) ? Nt.showHidden = Et : Et && A._extend(Nt, Et), qt(Nt.showHidden) && (Nt.showHidden = !1), qt(Nt.depth) && (Nt.depth = 2), qt(Nt.colors) && (Nt.colors = !1), qt(Nt.customInspect) && (Nt.customInspect = !0), Nt.colors && (Nt.stylize = ne), re(Nt, ct, Nt.depth);
    }
    A.inspect = V, V.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, V.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function ne(ct, Et) {
      var Nt = V.styles[Et];
      return Nt ? "\x1B[" + V.colors[Nt][0] + "m" + ct + "\x1B[" + V.colors[Nt][1] + "m" : ct;
    }
    function ie(ct, Et) {
      return ct;
    }
    function oe(ct) {
      var Et = {};
      return ct.forEach(function(Nt, jt) {
        Et[Nt] = !0;
      }), Et;
    }
    function re(ct, Et, Nt) {
      if (ct.customInspect && Et && Oe(Et.inspect) && // Filter out the util module, it's inspect function is special
      Et.inspect !== A.inspect && // Also filter out any prototype objects using the circular check.
      !(Et.constructor && Et.constructor.prototype === Et)) {
        var jt = Et.inspect(Nt, ct);
        return Pt(jt) || (jt = re(ct, jt, Nt)), jt;
      }
      var Ot = ce(ct, Et);
      if (Ot)
        return Ot;
      var Bt = Object.keys(Et), Tt = oe(Bt);
      if (ct.showHidden && (Bt = Object.getOwnPropertyNames(Et)), wt(Et) && (Bt.indexOf("message") >= 0 || Bt.indexOf("description") >= 0))
        return ke(Et);
      if (Bt.length === 0) {
        if (Oe(Et)) {
          var Ut = Et.name ? ": " + Et.name : "";
          return ct.stylize("[Function" + Ut + "]", "special");
        }
        if (At(Et))
          return ct.stylize(RegExp.prototype.toString.call(Et), "regexp");
        if (xt(Et))
          return ct.stylize(Date.prototype.toString.call(Et), "date");
        if (wt(Et))
          return ke(Et);
      }
      var Gt = "", It = !1, Mt = ["{", "}"];
      if (lt(Et) && (It = !0, Mt = ["[", "]"]), Oe(Et)) {
        var Kt = Et.name ? ": " + Et.name : "";
        Gt = " [Function" + Kt + "]";
      }
      if (At(Et) && (Gt = " " + RegExp.prototype.toString.call(Et)), xt(Et) && (Gt = " " + Date.prototype.toUTCString.call(Et)), wt(Et) && (Gt = " " + ke(Et)), Bt.length === 0 && (!It || Et.length == 0))
        return Mt[0] + Gt + Mt[1];
      if (Nt < 0)
        return At(Et) ? ct.stylize(RegExp.prototype.toString.call(Et), "regexp") : ct.stylize("[Object]", "special");
      ct.seen.push(Et);
      var Qt;
      return It ? Qt = Ce(ct, Et, Nt, Tt, Bt) : Qt = Bt.map(function(rr) {
        return it(ct, Et, Nt, Tt, rr, It);
      }), ct.seen.pop(), at(Qt, Gt, Mt);
    }
    function ce(ct, Et) {
      if (qt(Et))
        return ct.stylize("undefined", "undefined");
      if (Pt(Et)) {
        var Nt = "'" + JSON.stringify(Et).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ct.stylize(Nt, "string");
      }
      if (mt(Et))
        return ct.stylize("" + Et, "number");
      if (ht(Et))
        return ct.stylize("" + Et, "boolean");
      if (dt(Et))
        return ct.stylize("null", "null");
    }
    function ke(ct) {
      return "[" + Error.prototype.toString.call(ct) + "]";
    }
    function Ce(ct, Et, Nt, jt, Ot) {
      for (var Bt = [], Tt = 0, Ut = Et.length; Tt < Ut; ++Tt)
        ut(Et, String(Tt)) ? Bt.push(it(
          ct,
          Et,
          Nt,
          jt,
          String(Tt),
          !0
        )) : Bt.push("");
      return Ot.forEach(function(Gt) {
        Gt.match(/^\d+$/) || Bt.push(it(
          ct,
          Et,
          Nt,
          jt,
          Gt,
          !0
        ));
      }), Bt;
    }
    function it(ct, Et, Nt, jt, Ot, Bt) {
      var Tt, Ut, Gt;
      if (Gt = Object.getOwnPropertyDescriptor(Et, Ot) || { value: Et[Ot] }, Gt.get ? Gt.set ? Ut = ct.stylize("[Getter/Setter]", "special") : Ut = ct.stylize("[Getter]", "special") : Gt.set && (Ut = ct.stylize("[Setter]", "special")), ut(jt, Ot) || (Tt = "[" + Ot + "]"), Ut || (ct.seen.indexOf(Gt.value) < 0 ? (dt(Nt) ? Ut = re(ct, Gt.value, null) : Ut = re(ct, Gt.value, Nt - 1), Ut.indexOf(`
`) > -1 && (Bt ? Ut = Ut.split(`
`).map(function(It) {
        return "  " + It;
      }).join(`
`).slice(2) : Ut = `
` + Ut.split(`
`).map(function(It) {
        return "   " + It;
      }).join(`
`))) : Ut = ct.stylize("[Circular]", "special")), qt(Tt)) {
        if (Bt && Ot.match(/^\d+$/))
          return Ut;
        Tt = JSON.stringify("" + Ot), Tt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Tt = Tt.slice(1, -1), Tt = ct.stylize(Tt, "name")) : (Tt = Tt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Tt = ct.stylize(Tt, "string"));
      }
      return Tt + ": " + Ut;
    }
    function at(ct, Et, Nt) {
      var jt = ct.reduce(function(Ot, Bt) {
        return Bt.indexOf(`
`) >= 0, Ot + Bt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return jt > 60 ? Nt[0] + (Et === "" ? "" : Et + `
 `) + " " + ct.join(`,
  `) + " " + Nt[1] : Nt[0] + Et + " " + ct.join(", ") + " " + Nt[1];
    }
    A.types = requireTypes();
    function lt(ct) {
      return Array.isArray(ct);
    }
    A.isArray = lt;
    function ht(ct) {
      return typeof ct == "boolean";
    }
    A.isBoolean = ht;
    function dt(ct) {
      return ct === null;
    }
    A.isNull = dt;
    function vt(ct) {
      return ct == null;
    }
    A.isNullOrUndefined = vt;
    function mt(ct) {
      return typeof ct == "number";
    }
    A.isNumber = mt;
    function Pt(ct) {
      return typeof ct == "string";
    }
    A.isString = Pt;
    function $t(ct) {
      return typeof ct == "symbol";
    }
    A.isSymbol = $t;
    function qt(ct) {
      return ct === void 0;
    }
    A.isUndefined = qt;
    function At(ct) {
      return bt(ct) && pe(ct) === "[object RegExp]";
    }
    A.isRegExp = At, A.types.isRegExp = At;
    function bt(ct) {
      return typeof ct == "object" && ct !== null;
    }
    A.isObject = bt;
    function xt(ct) {
      return bt(ct) && pe(ct) === "[object Date]";
    }
    A.isDate = xt, A.types.isDate = xt;
    function wt(ct) {
      return bt(ct) && (pe(ct) === "[object Error]" || ct instanceof Error);
    }
    A.isError = wt, A.types.isNativeError = wt;
    function Oe(ct) {
      return typeof ct == "function";
    }
    A.isFunction = Oe;
    function rt(ct) {
      return ct === null || typeof ct == "boolean" || typeof ct == "number" || typeof ct == "string" || typeof ct == "symbol" || // ES6 symbol
      typeof ct > "u";
    }
    A.isPrimitive = rt, A.isBuffer = requireIsBufferBrowser();
    function pe(ct) {
      return Object.prototype.toString.call(ct);
    }
    function nt(ct) {
      return ct < 10 ? "0" + ct.toString(10) : ct.toString(10);
    }
    var ot = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function st() {
      var ct = /* @__PURE__ */ new Date(), Et = [
        nt(ct.getHours()),
        nt(ct.getMinutes()),
        nt(ct.getSeconds())
      ].join(":");
      return [ct.getDate(), ot[ct.getMonth()], Et].join(" ");
    }
    A.log = function() {
      console.log("%s - %s", st(), A.format.apply(A, arguments));
    }, A.inherits = requireInherits_browser(), A._extend = function(ct, Et) {
      if (!Et || !bt(Et)) return ct;
      for (var Nt = Object.keys(Et), jt = Nt.length; jt--; )
        ct[Nt[jt]] = Et[Nt[jt]];
      return ct;
    };
    function ut(ct, Et) {
      return Object.prototype.hasOwnProperty.call(ct, Et);
    }
    var pt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    A.promisify = function(Et) {
      if (typeof Et != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (pt && Et[pt]) {
        var Nt = Et[pt];
        if (typeof Nt != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(Nt, pt, {
          value: Nt,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), Nt;
      }
      function Nt() {
        for (var jt, Ot, Bt = new Promise(function(Gt, It) {
          jt = Gt, Ot = It;
        }), Tt = [], Ut = 0; Ut < arguments.length; Ut++)
          Tt.push(arguments[Ut]);
        Tt.push(function(Gt, It) {
          Gt ? Ot(Gt) : jt(It);
        });
        try {
          Et.apply(this, Tt);
        } catch (Gt) {
          Ot(Gt);
        }
        return Bt;
      }
      return Object.setPrototypeOf(Nt, Object.getPrototypeOf(Et)), pt && Object.defineProperty(Nt, pt, {
        value: Nt,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        Nt,
        B(Et)
      );
    }, A.promisify.custom = pt;
    function ft(ct, Et) {
      if (!ct) {
        var Nt = new Error("Promise was rejected with a falsy value");
        Nt.reason = ct, ct = Nt;
      }
      return Et(ct);
    }
    function yt(ct) {
      if (typeof ct != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Et() {
        for (var Nt = [], jt = 0; jt < arguments.length; jt++)
          Nt.push(arguments[jt]);
        var Ot = Nt.pop();
        if (typeof Ot != "function")
          throw new TypeError("The last argument must be of type Function");
        var Bt = this, Tt = function() {
          return Ot.apply(Bt, arguments);
        };
        ct.apply(this, Nt).then(
          function(Ut) {
            process$1.nextTick(Tt.bind(null, null, Ut));
          },
          function(Ut) {
            process$1.nextTick(ft.bind(null, Ut, Tt));
          }
        );
      }
      return Object.setPrototypeOf(Et, Object.getPrototypeOf(ct)), Object.defineProperties(
        Et,
        B(ct)
      ), Et;
    }
    A.callbackify = yt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function A(it, at) {
    var lt = Object.keys(it);
    if (Object.getOwnPropertySymbols) {
      var ht = Object.getOwnPropertySymbols(it);
      at && (ht = ht.filter(function(dt) {
        return Object.getOwnPropertyDescriptor(it, dt).enumerable;
      })), lt.push.apply(lt, ht);
    }
    return lt;
  }
  function B(it) {
    for (var at = 1; at < arguments.length; at++) {
      var lt = arguments[at] != null ? arguments[at] : {};
      at % 2 ? A(Object(lt), !0).forEach(function(ht) {
        L(it, ht, lt[ht]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(it, Object.getOwnPropertyDescriptors(lt)) : A(Object(lt)).forEach(function(ht) {
        Object.defineProperty(it, ht, Object.getOwnPropertyDescriptor(lt, ht));
      });
    }
    return it;
  }
  function L(it, at, lt) {
    return at = V(at), at in it ? Object.defineProperty(it, at, { value: lt, enumerable: !0, configurable: !0, writable: !0 }) : it[at] = lt, it;
  }
  function K(it, at) {
    if (!(it instanceof at))
      throw new TypeError("Cannot call a class as a function");
  }
  function J(it, at) {
    for (var lt = 0; lt < at.length; lt++) {
      var ht = at[lt];
      ht.enumerable = ht.enumerable || !1, ht.configurable = !0, "value" in ht && (ht.writable = !0), Object.defineProperty(it, V(ht.key), ht);
    }
  }
  function W(it, at, lt) {
    return at && J(it.prototype, at), Object.defineProperty(it, "prototype", { writable: !1 }), it;
  }
  function V(it) {
    var at = ne(it, "string");
    return typeof at == "symbol" ? at : String(at);
  }
  function ne(it, at) {
    if (typeof it != "object" || it === null) return it;
    var lt = it[Symbol.toPrimitive];
    if (lt !== void 0) {
      var ht = lt.call(it, at || "default");
      if (typeof ht != "object") return ht;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (at === "string" ? String : Number)(it);
  }
  var ie = require$$0$1, oe = ie.Buffer, re = requireUtil$1(), ce = re.inspect, ke = ce && ce.custom || "inspect";
  function Ce(it, at, lt) {
    oe.prototype.copy.call(it, at, lt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function it() {
      K(this, it), this.head = null, this.tail = null, this.length = 0;
    }
    return W(it, [{
      key: "push",
      value: function(lt) {
        var ht = {
          data: lt,
          next: null
        };
        this.length > 0 ? this.tail.next = ht : this.head = ht, this.tail = ht, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(lt) {
        var ht = {
          data: lt,
          next: this.head
        };
        this.length === 0 && (this.tail = ht), this.head = ht, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var lt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, lt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(lt) {
        if (this.length === 0) return "";
        for (var ht = this.head, dt = "" + ht.data; ht = ht.next; ) dt += lt + ht.data;
        return dt;
      }
    }, {
      key: "concat",
      value: function(lt) {
        if (this.length === 0) return oe.alloc(0);
        for (var ht = oe.allocUnsafe(lt >>> 0), dt = this.head, vt = 0; dt; )
          Ce(dt.data, ht, vt), vt += dt.data.length, dt = dt.next;
        return ht;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(lt, ht) {
        var dt;
        return lt < this.head.data.length ? (dt = this.head.data.slice(0, lt), this.head.data = this.head.data.slice(lt)) : lt === this.head.data.length ? dt = this.shift() : dt = ht ? this._getString(lt) : this._getBuffer(lt), dt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(lt) {
        var ht = this.head, dt = 1, vt = ht.data;
        for (lt -= vt.length; ht = ht.next; ) {
          var mt = ht.data, Pt = lt > mt.length ? mt.length : lt;
          if (Pt === mt.length ? vt += mt : vt += mt.slice(0, lt), lt -= Pt, lt === 0) {
            Pt === mt.length ? (++dt, ht.next ? this.head = ht.next : this.head = this.tail = null) : (this.head = ht, ht.data = mt.slice(Pt));
            break;
          }
          ++dt;
        }
        return this.length -= dt, vt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(lt) {
        var ht = oe.allocUnsafe(lt), dt = this.head, vt = 1;
        for (dt.data.copy(ht), lt -= dt.data.length; dt = dt.next; ) {
          var mt = dt.data, Pt = lt > mt.length ? mt.length : lt;
          if (mt.copy(ht, ht.length - lt, 0, Pt), lt -= Pt, lt === 0) {
            Pt === mt.length ? (++vt, dt.next ? this.head = dt.next : this.head = this.tail = null) : (this.head = dt, dt.data = mt.slice(Pt));
            break;
          }
          ++vt;
        }
        return this.length -= vt, ht;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: ke,
      value: function(lt, ht) {
        return ce(this, B(B({}, ht), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), it;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function A(V, ne) {
    var ie = this, oe = this._readableState && this._readableState.destroyed, re = this._writableState && this._writableState.destroyed;
    return oe || re ? (ne ? ne(V) : V && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(J, this, V)) : process$1.nextTick(J, this, V)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(V || null, function(ce) {
      !ne && ce ? ie._writableState ? ie._writableState.errorEmitted ? process$1.nextTick(L, ie) : (ie._writableState.errorEmitted = !0, process$1.nextTick(B, ie, ce)) : process$1.nextTick(B, ie, ce) : ne ? (process$1.nextTick(L, ie), ne(ce)) : process$1.nextTick(L, ie);
    }), this);
  }
  function B(V, ne) {
    J(V, ne), L(V);
  }
  function L(V) {
    V._writableState && !V._writableState.emitClose || V._readableState && !V._readableState.emitClose || V.emit("close");
  }
  function K() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function J(V, ne) {
    V.emit("error", ne);
  }
  function W(V, ne) {
    var ie = V._readableState, oe = V._writableState;
    ie && ie.autoDestroy || oe && oe.autoDestroy ? V.destroy(ne) : V.emit("error", ne);
  }
  return destroy_1$1 = {
    destroy: A,
    undestroy: K,
    errorOrDestroy: W
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function A(ne, ie) {
    ne.prototype = Object.create(ie.prototype), ne.prototype.constructor = ne, ne.__proto__ = ie;
  }
  var B = {};
  function L(ne, ie, oe) {
    oe || (oe = Error);
    function re(ke, Ce, it) {
      return typeof ie == "string" ? ie : ie(ke, Ce, it);
    }
    var ce = /* @__PURE__ */ function(ke) {
      A(Ce, ke);
      function Ce(it, at, lt) {
        return ke.call(this, re(it, at, lt)) || this;
      }
      return Ce;
    }(oe);
    ce.prototype.name = oe.name, ce.prototype.code = ne, B[ne] = ce;
  }
  function K(ne, ie) {
    if (Array.isArray(ne)) {
      var oe = ne.length;
      return ne = ne.map(function(re) {
        return String(re);
      }), oe > 2 ? "one of ".concat(ie, " ").concat(ne.slice(0, oe - 1).join(", "), ", or ") + ne[oe - 1] : oe === 2 ? "one of ".concat(ie, " ").concat(ne[0], " or ").concat(ne[1]) : "of ".concat(ie, " ").concat(ne[0]);
    } else
      return "of ".concat(ie, " ").concat(String(ne));
  }
  function J(ne, ie, oe) {
    return ne.substr(0, ie.length) === ie;
  }
  function W(ne, ie, oe) {
    return (oe === void 0 || oe > ne.length) && (oe = ne.length), ne.substring(oe - ie.length, oe) === ie;
  }
  function V(ne, ie, oe) {
    return typeof oe != "number" && (oe = 0), oe + ie.length > ne.length ? !1 : ne.indexOf(ie, oe) !== -1;
  }
  return L("ERR_INVALID_OPT_VALUE", function(ne, ie) {
    return 'The value "' + ie + '" is invalid for option "' + ne + '"';
  }, TypeError), L("ERR_INVALID_ARG_TYPE", function(ne, ie, oe) {
    var re;
    typeof ie == "string" && J(ie, "not ") ? (re = "must not be", ie = ie.replace(/^not /, "")) : re = "must be";
    var ce;
    if (W(ne, " argument"))
      ce = "The ".concat(ne, " ").concat(re, " ").concat(K(ie, "type"));
    else {
      var ke = V(ne, ".") ? "property" : "argument";
      ce = 'The "'.concat(ne, '" ').concat(ke, " ").concat(re, " ").concat(K(ie, "type"));
    }
    return ce += ". Received type ".concat(typeof oe), ce;
  }, TypeError), L("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), L("ERR_METHOD_NOT_IMPLEMENTED", function(ne) {
    return "The " + ne + " method is not implemented";
  }), L("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), L("ERR_STREAM_DESTROYED", function(ne) {
    return "Cannot call " + ne + " after a stream was destroyed";
  }), L("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), L("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), L("ERR_STREAM_WRITE_AFTER_END", "write after end"), L("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), L("ERR_UNKNOWN_ENCODING", function(ne) {
    return "Unknown encoding: " + ne;
  }, TypeError), L("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = B, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var A = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function B(K, J, W) {
    return K.highWaterMark != null ? K.highWaterMark : J ? K[W] : null;
  }
  function L(K, J, W, V) {
    var ne = B(J, V, W);
    if (ne != null) {
      if (!(isFinite(ne) && Math.floor(ne) === ne) || ne < 0) {
        var ie = V ? W : "highWaterMark";
        throw new A(ie, ne);
      }
      return Math.floor(ne);
    }
    return K.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: L
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = A;
  function A(L, K) {
    if (B("noDeprecation"))
      return L;
    var J = !1;
    function W() {
      if (!J) {
        if (B("throwDeprecation"))
          throw new Error(K);
        B("traceDeprecation") ? console.trace(K) : console.warn(K), J = !0;
      }
      return L.apply(this, arguments);
    }
    return W;
  }
  function B(L) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[L];
    return K == null ? !1 : String(K).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = At;
  function A(Ot) {
    var Bt = this;
    this.next = null, this.entry = null, this.finish = function() {
      jt(Bt, Ot);
    };
  }
  var B;
  At.WritableState = $t;
  var L = {
    deprecate: requireBrowser$a()
  }, K = requireStreamBrowser$1(), J = require$$0$1.Buffer, W = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function V(Ot) {
    return J.from(Ot);
  }
  function ne(Ot) {
    return J.isBuffer(Ot) || Ot instanceof W;
  }
  var ie = requireDestroy$1(), oe = requireState(), re = oe.getHighWaterMark, ce = requireErrorsBrowser().codes, ke = ce.ERR_INVALID_ARG_TYPE, Ce = ce.ERR_METHOD_NOT_IMPLEMENTED, it = ce.ERR_MULTIPLE_CALLBACK, at = ce.ERR_STREAM_CANNOT_PIPE, lt = ce.ERR_STREAM_DESTROYED, ht = ce.ERR_STREAM_NULL_VALUES, dt = ce.ERR_STREAM_WRITE_AFTER_END, vt = ce.ERR_UNKNOWN_ENCODING, mt = ie.errorOrDestroy;
  requireInherits_browser()(At, K);
  function Pt() {
  }
  function $t(Ot, Bt, Tt) {
    B = B || require_stream_duplex$1(), Ot = Ot || {}, typeof Tt != "boolean" && (Tt = Bt instanceof B), this.objectMode = !!Ot.objectMode, Tt && (this.objectMode = this.objectMode || !!Ot.writableObjectMode), this.highWaterMark = re(this, Ot, "writableHighWaterMark", Tt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ut = Ot.decodeStrings === !1;
    this.decodeStrings = !Ut, this.defaultEncoding = Ot.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Gt) {
      ot(Bt, Gt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Ot.emitClose !== !1, this.autoDestroy = !!Ot.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
  }
  $t.prototype.getBuffer = function() {
    for (var Bt = this.bufferedRequest, Tt = []; Bt; )
      Tt.push(Bt), Bt = Bt.next;
    return Tt;
  }, function() {
    try {
      Object.defineProperty($t.prototype, "buffer", {
        get: L.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var qt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (qt = Function.prototype[Symbol.hasInstance], Object.defineProperty(At, Symbol.hasInstance, {
    value: function(Bt) {
      return qt.call(this, Bt) ? !0 : this !== At ? !1 : Bt && Bt._writableState instanceof $t;
    }
  })) : qt = function(Bt) {
    return Bt instanceof this;
  };
  function At(Ot) {
    B = B || require_stream_duplex$1();
    var Bt = this instanceof B;
    if (!Bt && !qt.call(At, this)) return new At(Ot);
    this._writableState = new $t(Ot, this, Bt), this.writable = !0, Ot && (typeof Ot.write == "function" && (this._write = Ot.write), typeof Ot.writev == "function" && (this._writev = Ot.writev), typeof Ot.destroy == "function" && (this._destroy = Ot.destroy), typeof Ot.final == "function" && (this._final = Ot.final)), K.call(this);
  }
  At.prototype.pipe = function() {
    mt(this, new at());
  };
  function bt(Ot, Bt) {
    var Tt = new dt();
    mt(Ot, Tt), process$1.nextTick(Bt, Tt);
  }
  function xt(Ot, Bt, Tt, Ut) {
    var Gt;
    return Tt === null ? Gt = new ht() : typeof Tt != "string" && !Bt.objectMode && (Gt = new ke("chunk", ["string", "Buffer"], Tt)), Gt ? (mt(Ot, Gt), process$1.nextTick(Ut, Gt), !1) : !0;
  }
  At.prototype.write = function(Ot, Bt, Tt) {
    var Ut = this._writableState, Gt = !1, It = !Ut.objectMode && ne(Ot);
    return It && !J.isBuffer(Ot) && (Ot = V(Ot)), typeof Bt == "function" && (Tt = Bt, Bt = null), It ? Bt = "buffer" : Bt || (Bt = Ut.defaultEncoding), typeof Tt != "function" && (Tt = Pt), Ut.ending ? bt(this, Tt) : (It || xt(this, Ut, Ot, Tt)) && (Ut.pendingcb++, Gt = Oe(this, Ut, It, Ot, Bt, Tt)), Gt;
  }, At.prototype.cork = function() {
    this._writableState.corked++;
  }, At.prototype.uncork = function() {
    var Ot = this._writableState;
    Ot.corked && (Ot.corked--, !Ot.writing && !Ot.corked && !Ot.bufferProcessing && Ot.bufferedRequest && pt(this, Ot));
  }, At.prototype.setDefaultEncoding = function(Bt) {
    if (typeof Bt == "string" && (Bt = Bt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Bt + "").toLowerCase()) > -1)) throw new vt(Bt);
    return this._writableState.defaultEncoding = Bt, this;
  }, Object.defineProperty(At.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function wt(Ot, Bt, Tt) {
    return !Ot.objectMode && Ot.decodeStrings !== !1 && typeof Bt == "string" && (Bt = J.from(Bt, Tt)), Bt;
  }
  Object.defineProperty(At.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Oe(Ot, Bt, Tt, Ut, Gt, It) {
    if (!Tt) {
      var Mt = wt(Bt, Ut, Gt);
      Ut !== Mt && (Tt = !0, Gt = "buffer", Ut = Mt);
    }
    var Kt = Bt.objectMode ? 1 : Ut.length;
    Bt.length += Kt;
    var Qt = Bt.length < Bt.highWaterMark;
    if (Qt || (Bt.needDrain = !0), Bt.writing || Bt.corked) {
      var rr = Bt.lastBufferedRequest;
      Bt.lastBufferedRequest = {
        chunk: Ut,
        encoding: Gt,
        isBuf: Tt,
        callback: It,
        next: null
      }, rr ? rr.next = Bt.lastBufferedRequest : Bt.bufferedRequest = Bt.lastBufferedRequest, Bt.bufferedRequestCount += 1;
    } else
      rt(Ot, Bt, !1, Kt, Ut, Gt, It);
    return Qt;
  }
  function rt(Ot, Bt, Tt, Ut, Gt, It, Mt) {
    Bt.writelen = Ut, Bt.writecb = Mt, Bt.writing = !0, Bt.sync = !0, Bt.destroyed ? Bt.onwrite(new lt("write")) : Tt ? Ot._writev(Gt, Bt.onwrite) : Ot._write(Gt, It, Bt.onwrite), Bt.sync = !1;
  }
  function pe(Ot, Bt, Tt, Ut, Gt) {
    --Bt.pendingcb, Tt ? (process$1.nextTick(Gt, Ut), process$1.nextTick(Et, Ot, Bt), Ot._writableState.errorEmitted = !0, mt(Ot, Ut)) : (Gt(Ut), Ot._writableState.errorEmitted = !0, mt(Ot, Ut), Et(Ot, Bt));
  }
  function nt(Ot) {
    Ot.writing = !1, Ot.writecb = null, Ot.length -= Ot.writelen, Ot.writelen = 0;
  }
  function ot(Ot, Bt) {
    var Tt = Ot._writableState, Ut = Tt.sync, Gt = Tt.writecb;
    if (typeof Gt != "function") throw new it();
    if (nt(Tt), Bt) pe(Ot, Tt, Ut, Bt, Gt);
    else {
      var It = ft(Tt) || Ot.destroyed;
      !It && !Tt.corked && !Tt.bufferProcessing && Tt.bufferedRequest && pt(Ot, Tt), Ut ? process$1.nextTick(st, Ot, Tt, It, Gt) : st(Ot, Tt, It, Gt);
    }
  }
  function st(Ot, Bt, Tt, Ut) {
    Tt || ut(Ot, Bt), Bt.pendingcb--, Ut(), Et(Ot, Bt);
  }
  function ut(Ot, Bt) {
    Bt.length === 0 && Bt.needDrain && (Bt.needDrain = !1, Ot.emit("drain"));
  }
  function pt(Ot, Bt) {
    Bt.bufferProcessing = !0;
    var Tt = Bt.bufferedRequest;
    if (Ot._writev && Tt && Tt.next) {
      var Ut = Bt.bufferedRequestCount, Gt = new Array(Ut), It = Bt.corkedRequestsFree;
      It.entry = Tt;
      for (var Mt = 0, Kt = !0; Tt; )
        Gt[Mt] = Tt, Tt.isBuf || (Kt = !1), Tt = Tt.next, Mt += 1;
      Gt.allBuffers = Kt, rt(Ot, Bt, !0, Bt.length, Gt, "", It.finish), Bt.pendingcb++, Bt.lastBufferedRequest = null, It.next ? (Bt.corkedRequestsFree = It.next, It.next = null) : Bt.corkedRequestsFree = new A(Bt), Bt.bufferedRequestCount = 0;
    } else {
      for (; Tt; ) {
        var Qt = Tt.chunk, rr = Tt.encoding, ar = Tt.callback, ur = Bt.objectMode ? 1 : Qt.length;
        if (rt(Ot, Bt, !1, ur, Qt, rr, ar), Tt = Tt.next, Bt.bufferedRequestCount--, Bt.writing)
          break;
      }
      Tt === null && (Bt.lastBufferedRequest = null);
    }
    Bt.bufferedRequest = Tt, Bt.bufferProcessing = !1;
  }
  At.prototype._write = function(Ot, Bt, Tt) {
    Tt(new Ce("_write()"));
  }, At.prototype._writev = null, At.prototype.end = function(Ot, Bt, Tt) {
    var Ut = this._writableState;
    return typeof Ot == "function" ? (Tt = Ot, Ot = null, Bt = null) : typeof Bt == "function" && (Tt = Bt, Bt = null), Ot != null && this.write(Ot, Bt), Ut.corked && (Ut.corked = 1, this.uncork()), Ut.ending || Nt(this, Ut, Tt), this;
  }, Object.defineProperty(At.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ft(Ot) {
    return Ot.ending && Ot.length === 0 && Ot.bufferedRequest === null && !Ot.finished && !Ot.writing;
  }
  function yt(Ot, Bt) {
    Ot._final(function(Tt) {
      Bt.pendingcb--, Tt && mt(Ot, Tt), Bt.prefinished = !0, Ot.emit("prefinish"), Et(Ot, Bt);
    });
  }
  function ct(Ot, Bt) {
    !Bt.prefinished && !Bt.finalCalled && (typeof Ot._final == "function" && !Bt.destroyed ? (Bt.pendingcb++, Bt.finalCalled = !0, process$1.nextTick(yt, Ot, Bt)) : (Bt.prefinished = !0, Ot.emit("prefinish")));
  }
  function Et(Ot, Bt) {
    var Tt = ft(Bt);
    if (Tt && (ct(Ot, Bt), Bt.pendingcb === 0 && (Bt.finished = !0, Ot.emit("finish"), Bt.autoDestroy))) {
      var Ut = Ot._readableState;
      (!Ut || Ut.autoDestroy && Ut.endEmitted) && Ot.destroy();
    }
    return Tt;
  }
  function Nt(Ot, Bt, Tt) {
    Bt.ending = !0, Et(Ot, Bt), Tt && (Bt.finished ? process$1.nextTick(Tt) : Ot.once("finish", Tt)), Bt.ended = !0, Ot.writable = !1;
  }
  function jt(Ot, Bt, Tt) {
    var Ut = Ot.entry;
    for (Ot.entry = null; Ut; ) {
      var Gt = Ut.callback;
      Bt.pendingcb--, Gt(Tt), Ut = Ut.next;
    }
    Bt.corkedRequestsFree.next = Ot;
  }
  return Object.defineProperty(At.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Bt) {
      this._writableState && (this._writableState.destroyed = Bt);
    }
  }), At.prototype.destroy = ie.destroy, At.prototype._undestroy = ie.undestroy, At.prototype._destroy = function(Ot, Bt) {
    Bt(Ot);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var A = Object.keys || function(oe) {
    var re = [];
    for (var ce in oe) re.push(ce);
    return re;
  };
  _stream_duplex$1 = V;
  var B = require_stream_readable$1(), L = require_stream_writable$1();
  requireInherits_browser()(V, B);
  for (var K = A(L.prototype), J = 0; J < K.length; J++) {
    var W = K[J];
    V.prototype[W] || (V.prototype[W] = L.prototype[W]);
  }
  function V(oe) {
    if (!(this instanceof V)) return new V(oe);
    B.call(this, oe), L.call(this, oe), this.allowHalfOpen = !0, oe && (oe.readable === !1 && (this.readable = !1), oe.writable === !1 && (this.writable = !1), oe.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ne)));
  }
  Object.defineProperty(V.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(V.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(V.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ne() {
    this._writableState.ended || process$1.nextTick(ie, this);
  }
  function ie(oe) {
    oe.end();
  }
  return Object.defineProperty(V.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(re) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = re, this._writableState.destroyed = re);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var A = safeBufferExports.Buffer, B = A.isEncoding || function(ht) {
    switch (ht = "" + ht, ht && ht.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function L(ht) {
    if (!ht) return "utf8";
    for (var dt; ; )
      switch (ht) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return ht;
        default:
          if (dt) return;
          ht = ("" + ht).toLowerCase(), dt = !0;
      }
  }
  function K(ht) {
    var dt = L(ht);
    if (typeof dt != "string" && (A.isEncoding === B || !B(ht))) throw new Error("Unknown encoding: " + ht);
    return dt || ht;
  }
  string_decoder.StringDecoder = J;
  function J(ht) {
    this.encoding = K(ht);
    var dt;
    switch (this.encoding) {
      case "utf16le":
        this.text = ce, this.end = ke, dt = 4;
        break;
      case "utf8":
        this.fillLast = ie, dt = 4;
        break;
      case "base64":
        this.text = Ce, this.end = it, dt = 3;
        break;
      default:
        this.write = at, this.end = lt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = A.allocUnsafe(dt);
  }
  J.prototype.write = function(ht) {
    if (ht.length === 0) return "";
    var dt, vt;
    if (this.lastNeed) {
      if (dt = this.fillLast(ht), dt === void 0) return "";
      vt = this.lastNeed, this.lastNeed = 0;
    } else
      vt = 0;
    return vt < ht.length ? dt ? dt + this.text(ht, vt) : this.text(ht, vt) : dt || "";
  }, J.prototype.end = re, J.prototype.text = oe, J.prototype.fillLast = function(ht) {
    if (this.lastNeed <= ht.length)
      return ht.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    ht.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ht.length), this.lastNeed -= ht.length;
  };
  function W(ht) {
    return ht <= 127 ? 0 : ht >> 5 === 6 ? 2 : ht >> 4 === 14 ? 3 : ht >> 3 === 30 ? 4 : ht >> 6 === 2 ? -1 : -2;
  }
  function V(ht, dt, vt) {
    var mt = dt.length - 1;
    if (mt < vt) return 0;
    var Pt = W(dt[mt]);
    return Pt >= 0 ? (Pt > 0 && (ht.lastNeed = Pt - 1), Pt) : --mt < vt || Pt === -2 ? 0 : (Pt = W(dt[mt]), Pt >= 0 ? (Pt > 0 && (ht.lastNeed = Pt - 2), Pt) : --mt < vt || Pt === -2 ? 0 : (Pt = W(dt[mt]), Pt >= 0 ? (Pt > 0 && (Pt === 2 ? Pt = 0 : ht.lastNeed = Pt - 3), Pt) : 0));
  }
  function ne(ht, dt, vt) {
    if ((dt[0] & 192) !== 128)
      return ht.lastNeed = 0, "";
    if (ht.lastNeed > 1 && dt.length > 1) {
      if ((dt[1] & 192) !== 128)
        return ht.lastNeed = 1, "";
      if (ht.lastNeed > 2 && dt.length > 2 && (dt[2] & 192) !== 128)
        return ht.lastNeed = 2, "";
    }
  }
  function ie(ht) {
    var dt = this.lastTotal - this.lastNeed, vt = ne(this, ht);
    if (vt !== void 0) return vt;
    if (this.lastNeed <= ht.length)
      return ht.copy(this.lastChar, dt, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    ht.copy(this.lastChar, dt, 0, ht.length), this.lastNeed -= ht.length;
  }
  function oe(ht, dt) {
    var vt = V(this, ht, dt);
    if (!this.lastNeed) return ht.toString("utf8", dt);
    this.lastTotal = vt;
    var mt = ht.length - (vt - this.lastNeed);
    return ht.copy(this.lastChar, 0, mt), ht.toString("utf8", dt, mt);
  }
  function re(ht) {
    var dt = ht && ht.length ? this.write(ht) : "";
    return this.lastNeed ? dt + "" : dt;
  }
  function ce(ht, dt) {
    if ((ht.length - dt) % 2 === 0) {
      var vt = ht.toString("utf16le", dt);
      if (vt) {
        var mt = vt.charCodeAt(vt.length - 1);
        if (mt >= 55296 && mt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = ht[ht.length - 2], this.lastChar[1] = ht[ht.length - 1], vt.slice(0, -1);
      }
      return vt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = ht[ht.length - 1], ht.toString("utf16le", dt, ht.length - 1);
  }
  function ke(ht) {
    var dt = ht && ht.length ? this.write(ht) : "";
    if (this.lastNeed) {
      var vt = this.lastTotal - this.lastNeed;
      return dt + this.lastChar.toString("utf16le", 0, vt);
    }
    return dt;
  }
  function Ce(ht, dt) {
    var vt = (ht.length - dt) % 3;
    return vt === 0 ? ht.toString("base64", dt) : (this.lastNeed = 3 - vt, this.lastTotal = 3, vt === 1 ? this.lastChar[0] = ht[ht.length - 1] : (this.lastChar[0] = ht[ht.length - 2], this.lastChar[1] = ht[ht.length - 1]), ht.toString("base64", dt, ht.length - vt));
  }
  function it(ht) {
    var dt = ht && ht.length ? this.write(ht) : "";
    return this.lastNeed ? dt + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : dt;
  }
  function at(ht) {
    return ht.toString(this.encoding);
  }
  function lt(ht) {
    return ht && ht.length ? this.write(ht) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var A = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function B(W) {
    var V = !1;
    return function() {
      if (!V) {
        V = !0;
        for (var ne = arguments.length, ie = new Array(ne), oe = 0; oe < ne; oe++)
          ie[oe] = arguments[oe];
        W.apply(this, ie);
      }
    };
  }
  function L() {
  }
  function K(W) {
    return W.setHeader && typeof W.abort == "function";
  }
  function J(W, V, ne) {
    if (typeof V == "function") return J(W, null, V);
    V || (V = {}), ne = B(ne || L);
    var ie = V.readable || V.readable !== !1 && W.readable, oe = V.writable || V.writable !== !1 && W.writable, re = function() {
      W.writable || ke();
    }, ce = W._writableState && W._writableState.finished, ke = function() {
      oe = !1, ce = !0, ie || ne.call(W);
    }, Ce = W._readableState && W._readableState.endEmitted, it = function() {
      ie = !1, Ce = !0, oe || ne.call(W);
    }, at = function(vt) {
      ne.call(W, vt);
    }, lt = function() {
      var vt;
      if (ie && !Ce)
        return (!W._readableState || !W._readableState.ended) && (vt = new A()), ne.call(W, vt);
      if (oe && !ce)
        return (!W._writableState || !W._writableState.ended) && (vt = new A()), ne.call(W, vt);
    }, ht = function() {
      W.req.on("finish", ke);
    };
    return K(W) ? (W.on("complete", ke), W.on("abort", lt), W.req ? ht() : W.on("request", ht)) : oe && !W._writableState && (W.on("end", re), W.on("close", re)), W.on("end", it), W.on("finish", ke), V.error !== !1 && W.on("error", at), W.on("close", lt), function() {
      W.removeListener("complete", ke), W.removeListener("abort", lt), W.removeListener("request", ht), W.req && W.req.removeListener("finish", ke), W.removeListener("end", re), W.removeListener("close", re), W.removeListener("finish", ke), W.removeListener("end", it), W.removeListener("error", at), W.removeListener("close", lt);
    };
  }
  return endOfStream = J, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var A;
  function B(vt, mt, Pt) {
    return mt = L(mt), mt in vt ? Object.defineProperty(vt, mt, { value: Pt, enumerable: !0, configurable: !0, writable: !0 }) : vt[mt] = Pt, vt;
  }
  function L(vt) {
    var mt = K(vt, "string");
    return typeof mt == "symbol" ? mt : String(mt);
  }
  function K(vt, mt) {
    if (typeof vt != "object" || vt === null) return vt;
    var Pt = vt[Symbol.toPrimitive];
    if (Pt !== void 0) {
      var $t = Pt.call(vt, mt || "default");
      if (typeof $t != "object") return $t;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (mt === "string" ? String : Number)(vt);
  }
  var J = requireEndOfStream(), W = Symbol("lastResolve"), V = Symbol("lastReject"), ne = Symbol("error"), ie = Symbol("ended"), oe = Symbol("lastPromise"), re = Symbol("handlePromise"), ce = Symbol("stream");
  function ke(vt, mt) {
    return {
      value: vt,
      done: mt
    };
  }
  function Ce(vt) {
    var mt = vt[W];
    if (mt !== null) {
      var Pt = vt[ce].read();
      Pt !== null && (vt[oe] = null, vt[W] = null, vt[V] = null, mt(ke(Pt, !1)));
    }
  }
  function it(vt) {
    process$1.nextTick(Ce, vt);
  }
  function at(vt, mt) {
    return function(Pt, $t) {
      vt.then(function() {
        if (mt[ie]) {
          Pt(ke(void 0, !0));
          return;
        }
        mt[re](Pt, $t);
      }, $t);
    };
  }
  var lt = Object.getPrototypeOf(function() {
  }), ht = Object.setPrototypeOf((A = {
    get stream() {
      return this[ce];
    },
    next: function() {
      var mt = this, Pt = this[ne];
      if (Pt !== null)
        return Promise.reject(Pt);
      if (this[ie])
        return Promise.resolve(ke(void 0, !0));
      if (this[ce].destroyed)
        return new Promise(function(bt, xt) {
          process$1.nextTick(function() {
            mt[ne] ? xt(mt[ne]) : bt(ke(void 0, !0));
          });
        });
      var $t = this[oe], qt;
      if ($t)
        qt = new Promise(at($t, this));
      else {
        var At = this[ce].read();
        if (At !== null)
          return Promise.resolve(ke(At, !1));
        qt = new Promise(this[re]);
      }
      return this[oe] = qt, qt;
    }
  }, B(A, Symbol.asyncIterator, function() {
    return this;
  }), B(A, "return", function() {
    var mt = this;
    return new Promise(function(Pt, $t) {
      mt[ce].destroy(null, function(qt) {
        if (qt) {
          $t(qt);
          return;
        }
        Pt(ke(void 0, !0));
      });
    });
  }), A), lt), dt = function(mt) {
    var Pt, $t = Object.create(ht, (Pt = {}, B(Pt, ce, {
      value: mt,
      writable: !0
    }), B(Pt, W, {
      value: null,
      writable: !0
    }), B(Pt, V, {
      value: null,
      writable: !0
    }), B(Pt, ne, {
      value: null,
      writable: !0
    }), B(Pt, ie, {
      value: mt._readableState.endEmitted,
      writable: !0
    }), B(Pt, re, {
      value: function(At, bt) {
        var xt = $t[ce].read();
        xt ? ($t[oe] = null, $t[W] = null, $t[V] = null, At(ke(xt, !1))) : ($t[W] = At, $t[V] = bt);
      },
      writable: !0
    }), Pt));
    return $t[oe] = null, J(mt, function(qt) {
      if (qt && qt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var At = $t[V];
        At !== null && ($t[oe] = null, $t[W] = null, $t[V] = null, At(qt)), $t[ne] = qt;
        return;
      }
      var bt = $t[W];
      bt !== null && ($t[oe] = null, $t[W] = null, $t[V] = null, bt(ke(void 0, !0))), $t[ie] = !0;
    }), mt.on("readable", it.bind(null, $t)), $t;
  };
  return async_iterator = dt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = bt;
  var A;
  bt.ReadableState = At, requireEvents().EventEmitter;
  var B = function(Mt, Kt) {
    return Mt.listeners(Kt).length;
  }, L = requireStreamBrowser$1(), K = require$$0$1.Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function W(It) {
    return K.from(It);
  }
  function V(It) {
    return K.isBuffer(It) || It instanceof J;
  }
  var ne = requireUtil$1(), ie;
  ne && ne.debuglog ? ie = ne.debuglog("stream") : ie = function() {
  };
  var oe = requireBuffer_list(), re = requireDestroy$1(), ce = requireState(), ke = ce.getHighWaterMark, Ce = requireErrorsBrowser().codes, it = Ce.ERR_INVALID_ARG_TYPE, at = Ce.ERR_STREAM_PUSH_AFTER_EOF, lt = Ce.ERR_METHOD_NOT_IMPLEMENTED, ht = Ce.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, dt, vt, mt;
  requireInherits_browser()(bt, L);
  var Pt = re.errorOrDestroy, $t = ["error", "close", "destroy", "pause", "resume"];
  function qt(It, Mt, Kt) {
    if (typeof It.prependListener == "function") return It.prependListener(Mt, Kt);
    !It._events || !It._events[Mt] ? It.on(Mt, Kt) : Array.isArray(It._events[Mt]) ? It._events[Mt].unshift(Kt) : It._events[Mt] = [Kt, It._events[Mt]];
  }
  function At(It, Mt, Kt) {
    A = A || require_stream_duplex$1(), It = It || {}, typeof Kt != "boolean" && (Kt = Mt instanceof A), this.objectMode = !!It.objectMode, Kt && (this.objectMode = this.objectMode || !!It.readableObjectMode), this.highWaterMark = ke(this, It, "readableHighWaterMark", Kt), this.buffer = new oe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = It.emitClose !== !1, this.autoDestroy = !!It.autoDestroy, this.destroyed = !1, this.defaultEncoding = It.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, It.encoding && (dt || (dt = requireString_decoder().StringDecoder), this.decoder = new dt(It.encoding), this.encoding = It.encoding);
  }
  function bt(It) {
    if (A = A || require_stream_duplex$1(), !(this instanceof bt)) return new bt(It);
    var Mt = this instanceof A;
    this._readableState = new At(It, this, Mt), this.readable = !0, It && (typeof It.read == "function" && (this._read = It.read), typeof It.destroy == "function" && (this._destroy = It.destroy)), L.call(this);
  }
  Object.defineProperty(bt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Mt) {
      this._readableState && (this._readableState.destroyed = Mt);
    }
  }), bt.prototype.destroy = re.destroy, bt.prototype._undestroy = re.undestroy, bt.prototype._destroy = function(It, Mt) {
    Mt(It);
  }, bt.prototype.push = function(It, Mt) {
    var Kt = this._readableState, Qt;
    return Kt.objectMode ? Qt = !0 : typeof It == "string" && (Mt = Mt || Kt.defaultEncoding, Mt !== Kt.encoding && (It = K.from(It, Mt), Mt = ""), Qt = !0), xt(this, It, Mt, !1, Qt);
  }, bt.prototype.unshift = function(It) {
    return xt(this, It, null, !0, !1);
  };
  function xt(It, Mt, Kt, Qt, rr) {
    ie("readableAddChunk", Mt);
    var ar = It._readableState;
    if (Mt === null)
      ar.reading = !1, ot(It, ar);
    else {
      var ur;
      if (rr || (ur = Oe(ar, Mt)), ur)
        Pt(It, ur);
      else if (ar.objectMode || Mt && Mt.length > 0)
        if (typeof Mt != "string" && !ar.objectMode && Object.getPrototypeOf(Mt) !== K.prototype && (Mt = W(Mt)), Qt)
          ar.endEmitted ? Pt(It, new ht()) : wt(It, ar, Mt, !0);
        else if (ar.ended)
          Pt(It, new at());
        else {
          if (ar.destroyed)
            return !1;
          ar.reading = !1, ar.decoder && !Kt ? (Mt = ar.decoder.write(Mt), ar.objectMode || Mt.length !== 0 ? wt(It, ar, Mt, !1) : pt(It, ar)) : wt(It, ar, Mt, !1);
        }
      else Qt || (ar.reading = !1, pt(It, ar));
    }
    return !ar.ended && (ar.length < ar.highWaterMark || ar.length === 0);
  }
  function wt(It, Mt, Kt, Qt) {
    Mt.flowing && Mt.length === 0 && !Mt.sync ? (Mt.awaitDrain = 0, It.emit("data", Kt)) : (Mt.length += Mt.objectMode ? 1 : Kt.length, Qt ? Mt.buffer.unshift(Kt) : Mt.buffer.push(Kt), Mt.needReadable && st(It)), pt(It, Mt);
  }
  function Oe(It, Mt) {
    var Kt;
    return !V(Mt) && typeof Mt != "string" && Mt !== void 0 && !It.objectMode && (Kt = new it("chunk", ["string", "Buffer", "Uint8Array"], Mt)), Kt;
  }
  bt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, bt.prototype.setEncoding = function(It) {
    dt || (dt = requireString_decoder().StringDecoder);
    var Mt = new dt(It);
    this._readableState.decoder = Mt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Kt = this._readableState.buffer.head, Qt = ""; Kt !== null; )
      Qt += Mt.write(Kt.data), Kt = Kt.next;
    return this._readableState.buffer.clear(), Qt !== "" && this._readableState.buffer.push(Qt), this._readableState.length = Qt.length, this;
  };
  var rt = 1073741824;
  function pe(It) {
    return It >= rt ? It = rt : (It--, It |= It >>> 1, It |= It >>> 2, It |= It >>> 4, It |= It >>> 8, It |= It >>> 16, It++), It;
  }
  function nt(It, Mt) {
    return It <= 0 || Mt.length === 0 && Mt.ended ? 0 : Mt.objectMode ? 1 : It !== It ? Mt.flowing && Mt.length ? Mt.buffer.head.data.length : Mt.length : (It > Mt.highWaterMark && (Mt.highWaterMark = pe(It)), It <= Mt.length ? It : Mt.ended ? Mt.length : (Mt.needReadable = !0, 0));
  }
  bt.prototype.read = function(It) {
    ie("read", It), It = parseInt(It, 10);
    var Mt = this._readableState, Kt = It;
    if (It !== 0 && (Mt.emittedReadable = !1), It === 0 && Mt.needReadable && ((Mt.highWaterMark !== 0 ? Mt.length >= Mt.highWaterMark : Mt.length > 0) || Mt.ended))
      return ie("read: emitReadable", Mt.length, Mt.ended), Mt.length === 0 && Mt.ended ? Tt(this) : st(this), null;
    if (It = nt(It, Mt), It === 0 && Mt.ended)
      return Mt.length === 0 && Tt(this), null;
    var Qt = Mt.needReadable;
    ie("need readable", Qt), (Mt.length === 0 || Mt.length - It < Mt.highWaterMark) && (Qt = !0, ie("length less than watermark", Qt)), Mt.ended || Mt.reading ? (Qt = !1, ie("reading or ended", Qt)) : Qt && (ie("do read"), Mt.reading = !0, Mt.sync = !0, Mt.length === 0 && (Mt.needReadable = !0), this._read(Mt.highWaterMark), Mt.sync = !1, Mt.reading || (It = nt(Kt, Mt)));
    var rr;
    return It > 0 ? rr = Bt(It, Mt) : rr = null, rr === null ? (Mt.needReadable = Mt.length <= Mt.highWaterMark, It = 0) : (Mt.length -= It, Mt.awaitDrain = 0), Mt.length === 0 && (Mt.ended || (Mt.needReadable = !0), Kt !== It && Mt.ended && Tt(this)), rr !== null && this.emit("data", rr), rr;
  };
  function ot(It, Mt) {
    if (ie("onEofChunk"), !Mt.ended) {
      if (Mt.decoder) {
        var Kt = Mt.decoder.end();
        Kt && Kt.length && (Mt.buffer.push(Kt), Mt.length += Mt.objectMode ? 1 : Kt.length);
      }
      Mt.ended = !0, Mt.sync ? st(It) : (Mt.needReadable = !1, Mt.emittedReadable || (Mt.emittedReadable = !0, ut(It)));
    }
  }
  function st(It) {
    var Mt = It._readableState;
    ie("emitReadable", Mt.needReadable, Mt.emittedReadable), Mt.needReadable = !1, Mt.emittedReadable || (ie("emitReadable", Mt.flowing), Mt.emittedReadable = !0, process$1.nextTick(ut, It));
  }
  function ut(It) {
    var Mt = It._readableState;
    ie("emitReadable_", Mt.destroyed, Mt.length, Mt.ended), !Mt.destroyed && (Mt.length || Mt.ended) && (It.emit("readable"), Mt.emittedReadable = !1), Mt.needReadable = !Mt.flowing && !Mt.ended && Mt.length <= Mt.highWaterMark, Ot(It);
  }
  function pt(It, Mt) {
    Mt.readingMore || (Mt.readingMore = !0, process$1.nextTick(ft, It, Mt));
  }
  function ft(It, Mt) {
    for (; !Mt.reading && !Mt.ended && (Mt.length < Mt.highWaterMark || Mt.flowing && Mt.length === 0); ) {
      var Kt = Mt.length;
      if (ie("maybeReadMore read 0"), It.read(0), Kt === Mt.length)
        break;
    }
    Mt.readingMore = !1;
  }
  bt.prototype._read = function(It) {
    Pt(this, new lt("_read()"));
  }, bt.prototype.pipe = function(It, Mt) {
    var Kt = this, Qt = this._readableState;
    switch (Qt.pipesCount) {
      case 0:
        Qt.pipes = It;
        break;
      case 1:
        Qt.pipes = [Qt.pipes, It];
        break;
      default:
        Qt.pipes.push(It);
        break;
    }
    Qt.pipesCount += 1, ie("pipe count=%d opts=%j", Qt.pipesCount, Mt);
    var rr = (!Mt || Mt.end !== !1) && It !== process$1.stdout && It !== process$1.stderr, ar = rr ? hr : Mr;
    Qt.endEmitted ? process$1.nextTick(ar) : Kt.once("end", ar), It.on("unpipe", ur);
    function ur(br, Ir) {
      ie("onunpipe"), br === Kt && Ir && Ir.hasUnpiped === !1 && (Ir.hasUnpiped = !0, lr());
    }
    function hr() {
      ie("onend"), It.end();
    }
    var Yt = yt(Kt);
    It.on("drain", Yt);
    var Rr = !1;
    function lr() {
      ie("cleanup"), It.removeListener("close", dr), It.removeListener("finish", Sr), It.removeListener("drain", Yt), It.removeListener("error", Br), It.removeListener("unpipe", ur), Kt.removeListener("end", hr), Kt.removeListener("end", Mr), Kt.removeListener("data", $r), Rr = !0, Qt.awaitDrain && (!It._writableState || It._writableState.needDrain) && Yt();
    }
    Kt.on("data", $r);
    function $r(br) {
      ie("ondata");
      var Ir = It.write(br);
      ie("dest.write", Ir), Ir === !1 && ((Qt.pipesCount === 1 && Qt.pipes === It || Qt.pipesCount > 1 && Gt(Qt.pipes, It) !== -1) && !Rr && (ie("false write response, pause", Qt.awaitDrain), Qt.awaitDrain++), Kt.pause());
    }
    function Br(br) {
      ie("onerror", br), Mr(), It.removeListener("error", Br), B(It, "error") === 0 && Pt(It, br);
    }
    qt(It, "error", Br);
    function dr() {
      It.removeListener("finish", Sr), Mr();
    }
    It.once("close", dr);
    function Sr() {
      ie("onfinish"), It.removeListener("close", dr), Mr();
    }
    It.once("finish", Sr);
    function Mr() {
      ie("unpipe"), Kt.unpipe(It);
    }
    return It.emit("pipe", Kt), Qt.flowing || (ie("pipe resume"), Kt.resume()), It;
  };
  function yt(It) {
    return function() {
      var Kt = It._readableState;
      ie("pipeOnDrain", Kt.awaitDrain), Kt.awaitDrain && Kt.awaitDrain--, Kt.awaitDrain === 0 && B(It, "data") && (Kt.flowing = !0, Ot(It));
    };
  }
  bt.prototype.unpipe = function(It) {
    var Mt = this._readableState, Kt = {
      hasUnpiped: !1
    };
    if (Mt.pipesCount === 0) return this;
    if (Mt.pipesCount === 1)
      return It && It !== Mt.pipes ? this : (It || (It = Mt.pipes), Mt.pipes = null, Mt.pipesCount = 0, Mt.flowing = !1, It && It.emit("unpipe", this, Kt), this);
    if (!It) {
      var Qt = Mt.pipes, rr = Mt.pipesCount;
      Mt.pipes = null, Mt.pipesCount = 0, Mt.flowing = !1;
      for (var ar = 0; ar < rr; ar++) Qt[ar].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ur = Gt(Mt.pipes, It);
    return ur === -1 ? this : (Mt.pipes.splice(ur, 1), Mt.pipesCount -= 1, Mt.pipesCount === 1 && (Mt.pipes = Mt.pipes[0]), It.emit("unpipe", this, Kt), this);
  }, bt.prototype.on = function(It, Mt) {
    var Kt = L.prototype.on.call(this, It, Mt), Qt = this._readableState;
    return It === "data" ? (Qt.readableListening = this.listenerCount("readable") > 0, Qt.flowing !== !1 && this.resume()) : It === "readable" && !Qt.endEmitted && !Qt.readableListening && (Qt.readableListening = Qt.needReadable = !0, Qt.flowing = !1, Qt.emittedReadable = !1, ie("on readable", Qt.length, Qt.reading), Qt.length ? st(this) : Qt.reading || process$1.nextTick(Et, this)), Kt;
  }, bt.prototype.addListener = bt.prototype.on, bt.prototype.removeListener = function(It, Mt) {
    var Kt = L.prototype.removeListener.call(this, It, Mt);
    return It === "readable" && process$1.nextTick(ct, this), Kt;
  }, bt.prototype.removeAllListeners = function(It) {
    var Mt = L.prototype.removeAllListeners.apply(this, arguments);
    return (It === "readable" || It === void 0) && process$1.nextTick(ct, this), Mt;
  };
  function ct(It) {
    var Mt = It._readableState;
    Mt.readableListening = It.listenerCount("readable") > 0, Mt.resumeScheduled && !Mt.paused ? Mt.flowing = !0 : It.listenerCount("data") > 0 && It.resume();
  }
  function Et(It) {
    ie("readable nexttick read 0"), It.read(0);
  }
  bt.prototype.resume = function() {
    var It = this._readableState;
    return It.flowing || (ie("resume"), It.flowing = !It.readableListening, Nt(this, It)), It.paused = !1, this;
  };
  function Nt(It, Mt) {
    Mt.resumeScheduled || (Mt.resumeScheduled = !0, process$1.nextTick(jt, It, Mt));
  }
  function jt(It, Mt) {
    ie("resume", Mt.reading), Mt.reading || It.read(0), Mt.resumeScheduled = !1, It.emit("resume"), Ot(It), Mt.flowing && !Mt.reading && It.read(0);
  }
  bt.prototype.pause = function() {
    return ie("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ie("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Ot(It) {
    var Mt = It._readableState;
    for (ie("flow", Mt.flowing); Mt.flowing && It.read() !== null; ) ;
  }
  bt.prototype.wrap = function(It) {
    var Mt = this, Kt = this._readableState, Qt = !1;
    It.on("end", function() {
      if (ie("wrapped end"), Kt.decoder && !Kt.ended) {
        var ur = Kt.decoder.end();
        ur && ur.length && Mt.push(ur);
      }
      Mt.push(null);
    }), It.on("data", function(ur) {
      if (ie("wrapped data"), Kt.decoder && (ur = Kt.decoder.write(ur)), !(Kt.objectMode && ur == null) && !(!Kt.objectMode && (!ur || !ur.length))) {
        var hr = Mt.push(ur);
        hr || (Qt = !0, It.pause());
      }
    });
    for (var rr in It)
      this[rr] === void 0 && typeof It[rr] == "function" && (this[rr] = /* @__PURE__ */ function(hr) {
        return function() {
          return It[hr].apply(It, arguments);
        };
      }(rr));
    for (var ar = 0; ar < $t.length; ar++)
      It.on($t[ar], this.emit.bind(this, $t[ar]));
    return this._read = function(ur) {
      ie("wrapped _read", ur), Qt && (Qt = !1, It.resume());
    }, this;
  }, typeof Symbol == "function" && (bt.prototype[Symbol.asyncIterator] = function() {
    return vt === void 0 && (vt = requireAsync_iterator()), vt(this);
  }), Object.defineProperty(bt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(bt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(bt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Mt) {
      this._readableState && (this._readableState.flowing = Mt);
    }
  }), bt._fromList = Bt, Object.defineProperty(bt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Bt(It, Mt) {
    if (Mt.length === 0) return null;
    var Kt;
    return Mt.objectMode ? Kt = Mt.buffer.shift() : !It || It >= Mt.length ? (Mt.decoder ? Kt = Mt.buffer.join("") : Mt.buffer.length === 1 ? Kt = Mt.buffer.first() : Kt = Mt.buffer.concat(Mt.length), Mt.buffer.clear()) : Kt = Mt.buffer.consume(It, Mt.decoder), Kt;
  }
  function Tt(It) {
    var Mt = It._readableState;
    ie("endReadable", Mt.endEmitted), Mt.endEmitted || (Mt.ended = !0, process$1.nextTick(Ut, Mt, It));
  }
  function Ut(It, Mt) {
    if (ie("endReadableNT", It.endEmitted, It.length), !It.endEmitted && It.length === 0 && (It.endEmitted = !0, Mt.readable = !1, Mt.emit("end"), It.autoDestroy)) {
      var Kt = Mt._writableState;
      (!Kt || Kt.autoDestroy && Kt.finished) && Mt.destroy();
    }
  }
  typeof Symbol == "function" && (bt.from = function(It, Mt) {
    return mt === void 0 && (mt = requireFromBrowser()), mt(bt, It, Mt);
  });
  function Gt(It, Mt) {
    for (var Kt = 0, Qt = It.length; Kt < Qt; Kt++)
      if (It[Kt] === Mt) return Kt;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ne;
  var A = requireErrorsBrowser().codes, B = A.ERR_METHOD_NOT_IMPLEMENTED, L = A.ERR_MULTIPLE_CALLBACK, K = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, J = A.ERR_TRANSFORM_WITH_LENGTH_0, W = require_stream_duplex$1();
  requireInherits_browser()(ne, W);
  function V(re, ce) {
    var ke = this._transformState;
    ke.transforming = !1;
    var Ce = ke.writecb;
    if (Ce === null)
      return this.emit("error", new L());
    ke.writechunk = null, ke.writecb = null, ce != null && this.push(ce), Ce(re);
    var it = this._readableState;
    it.reading = !1, (it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
  }
  function ne(re) {
    if (!(this instanceof ne)) return new ne(re);
    W.call(this, re), this._transformState = {
      afterTransform: V.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, re && (typeof re.transform == "function" && (this._transform = re.transform), typeof re.flush == "function" && (this._flush = re.flush)), this.on("prefinish", ie);
  }
  function ie() {
    var re = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(ce, ke) {
      oe(re, ce, ke);
    }) : oe(this, null, null);
  }
  ne.prototype.push = function(re, ce) {
    return this._transformState.needTransform = !1, W.prototype.push.call(this, re, ce);
  }, ne.prototype._transform = function(re, ce, ke) {
    ke(new B("_transform()"));
  }, ne.prototype._write = function(re, ce, ke) {
    var Ce = this._transformState;
    if (Ce.writecb = ke, Ce.writechunk = re, Ce.writeencoding = ce, !Ce.transforming) {
      var it = this._readableState;
      (Ce.needTransform || it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
    }
  }, ne.prototype._read = function(re) {
    var ce = this._transformState;
    ce.writechunk !== null && !ce.transforming ? (ce.transforming = !0, this._transform(ce.writechunk, ce.writeencoding, ce.afterTransform)) : ce.needTransform = !0;
  }, ne.prototype._destroy = function(re, ce) {
    W.prototype._destroy.call(this, re, function(ke) {
      ce(ke);
    });
  };
  function oe(re, ce, ke) {
    if (ce) return re.emit("error", ce);
    if (ke != null && re.push(ke), re._writableState.length) throw new J();
    if (re._transformState.transforming) throw new K();
    return re.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = B;
  var A = require_stream_transform$1();
  requireInherits_browser()(B, A);
  function B(L) {
    if (!(this instanceof B)) return new B(L);
    A.call(this, L);
  }
  return B.prototype._transform = function(L, K, J) {
    J(null, L);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var A;
  function B(ke) {
    var Ce = !1;
    return function() {
      Ce || (Ce = !0, ke.apply(void 0, arguments));
    };
  }
  var L = requireErrorsBrowser().codes, K = L.ERR_MISSING_ARGS, J = L.ERR_STREAM_DESTROYED;
  function W(ke) {
    if (ke) throw ke;
  }
  function V(ke) {
    return ke.setHeader && typeof ke.abort == "function";
  }
  function ne(ke, Ce, it, at) {
    at = B(at);
    var lt = !1;
    ke.on("close", function() {
      lt = !0;
    }), A === void 0 && (A = requireEndOfStream()), A(ke, {
      readable: Ce,
      writable: it
    }, function(dt) {
      if (dt) return at(dt);
      lt = !0, at();
    });
    var ht = !1;
    return function(dt) {
      if (!lt && !ht) {
        if (ht = !0, V(ke)) return ke.abort();
        if (typeof ke.destroy == "function") return ke.destroy();
        at(dt || new J("pipe"));
      }
    };
  }
  function ie(ke) {
    ke();
  }
  function oe(ke, Ce) {
    return ke.pipe(Ce);
  }
  function re(ke) {
    return !ke.length || typeof ke[ke.length - 1] != "function" ? W : ke.pop();
  }
  function ce() {
    for (var ke = arguments.length, Ce = new Array(ke), it = 0; it < ke; it++)
      Ce[it] = arguments[it];
    var at = re(Ce);
    if (Array.isArray(Ce[0]) && (Ce = Ce[0]), Ce.length < 2)
      throw new K("streams");
    var lt, ht = Ce.map(function(dt, vt) {
      var mt = vt < Ce.length - 1, Pt = vt > 0;
      return ne(dt, mt, Pt, function($t) {
        lt || (lt = $t), $t && ht.forEach(ie), !mt && (ht.forEach(ie), at(lt));
      });
    });
    return Ce.reduce(oe);
  }
  return pipeline_1 = ce, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(A, B) {
    B = A.exports = require_stream_readable$1(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable$1(), B.Duplex = require_stream_duplex$1(), B.Transform = require_stream_transform$1(), B.PassThrough = require_stream_passthrough$1(), B.finished = requireEndOfStream(), B.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var A = safeBufferExports.Buffer, B = requireReadableBrowser$1().Transform, L = requireInherits_browser();
  function K(W, V) {
    if (!A.isBuffer(W) && typeof W != "string")
      throw new TypeError(V + " must be a string or a buffer");
  }
  function J(W) {
    B.call(this), this._block = A.allocUnsafe(W), this._blockSize = W, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return L(J, B), J.prototype._transform = function(W, V, ne) {
    var ie = null;
    try {
      this.update(W, V);
    } catch (oe) {
      ie = oe;
    }
    ne(ie);
  }, J.prototype._flush = function(W) {
    var V = null;
    try {
      this.push(this.digest());
    } catch (ne) {
      V = ne;
    }
    W(V);
  }, J.prototype.update = function(W, V) {
    if (K(W, "Data"), this._finalized) throw new Error("Digest already called");
    A.isBuffer(W) || (W = A.from(W, V));
    for (var ne = this._block, ie = 0; this._blockOffset + W.length - ie >= this._blockSize; ) {
      for (var oe = this._blockOffset; oe < this._blockSize; ) ne[oe++] = W[ie++];
      this._update(), this._blockOffset = 0;
    }
    for (; ie < W.length; ) ne[this._blockOffset++] = W[ie++];
    for (var re = 0, ce = W.length * 8; ce > 0; ++re)
      this._length[re] += ce, ce = this._length[re] / 4294967296 | 0, ce > 0 && (this._length[re] -= 4294967296 * ce);
    return this;
  }, J.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, J.prototype.digest = function(W) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var V = this._digest();
    W !== void 0 && (V = V.toString(W)), this._block.fill(0), this._blockOffset = 0;
    for (var ne = 0; ne < 4; ++ne) this._length[ne] = 0;
    return V;
  }, J.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = J, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var A = requireInherits_browser(), B = requireHashBase(), L = safeBufferExports.Buffer, K = new Array(16);
  function J() {
    B.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  A(J, B), J.prototype._update = function() {
    for (var re = K, ce = 0; ce < 16; ++ce) re[ce] = this._block.readInt32LE(ce * 4);
    var ke = this._a, Ce = this._b, it = this._c, at = this._d;
    ke = V(ke, Ce, it, at, re[0], 3614090360, 7), at = V(at, ke, Ce, it, re[1], 3905402710, 12), it = V(it, at, ke, Ce, re[2], 606105819, 17), Ce = V(Ce, it, at, ke, re[3], 3250441966, 22), ke = V(ke, Ce, it, at, re[4], 4118548399, 7), at = V(at, ke, Ce, it, re[5], 1200080426, 12), it = V(it, at, ke, Ce, re[6], 2821735955, 17), Ce = V(Ce, it, at, ke, re[7], 4249261313, 22), ke = V(ke, Ce, it, at, re[8], 1770035416, 7), at = V(at, ke, Ce, it, re[9], 2336552879, 12), it = V(it, at, ke, Ce, re[10], 4294925233, 17), Ce = V(Ce, it, at, ke, re[11], 2304563134, 22), ke = V(ke, Ce, it, at, re[12], 1804603682, 7), at = V(at, ke, Ce, it, re[13], 4254626195, 12), it = V(it, at, ke, Ce, re[14], 2792965006, 17), Ce = V(Ce, it, at, ke, re[15], 1236535329, 22), ke = ne(ke, Ce, it, at, re[1], 4129170786, 5), at = ne(at, ke, Ce, it, re[6], 3225465664, 9), it = ne(it, at, ke, Ce, re[11], 643717713, 14), Ce = ne(Ce, it, at, ke, re[0], 3921069994, 20), ke = ne(ke, Ce, it, at, re[5], 3593408605, 5), at = ne(at, ke, Ce, it, re[10], 38016083, 9), it = ne(it, at, ke, Ce, re[15], 3634488961, 14), Ce = ne(Ce, it, at, ke, re[4], 3889429448, 20), ke = ne(ke, Ce, it, at, re[9], 568446438, 5), at = ne(at, ke, Ce, it, re[14], 3275163606, 9), it = ne(it, at, ke, Ce, re[3], 4107603335, 14), Ce = ne(Ce, it, at, ke, re[8], 1163531501, 20), ke = ne(ke, Ce, it, at, re[13], 2850285829, 5), at = ne(at, ke, Ce, it, re[2], 4243563512, 9), it = ne(it, at, ke, Ce, re[7], 1735328473, 14), Ce = ne(Ce, it, at, ke, re[12], 2368359562, 20), ke = ie(ke, Ce, it, at, re[5], 4294588738, 4), at = ie(at, ke, Ce, it, re[8], 2272392833, 11), it = ie(it, at, ke, Ce, re[11], 1839030562, 16), Ce = ie(Ce, it, at, ke, re[14], 4259657740, 23), ke = ie(ke, Ce, it, at, re[1], 2763975236, 4), at = ie(at, ke, Ce, it, re[4], 1272893353, 11), it = ie(it, at, ke, Ce, re[7], 4139469664, 16), Ce = ie(Ce, it, at, ke, re[10], 3200236656, 23), ke = ie(ke, Ce, it, at, re[13], 681279174, 4), at = ie(at, ke, Ce, it, re[0], 3936430074, 11), it = ie(it, at, ke, Ce, re[3], 3572445317, 16), Ce = ie(Ce, it, at, ke, re[6], 76029189, 23), ke = ie(ke, Ce, it, at, re[9], 3654602809, 4), at = ie(at, ke, Ce, it, re[12], 3873151461, 11), it = ie(it, at, ke, Ce, re[15], 530742520, 16), Ce = ie(Ce, it, at, ke, re[2], 3299628645, 23), ke = oe(ke, Ce, it, at, re[0], 4096336452, 6), at = oe(at, ke, Ce, it, re[7], 1126891415, 10), it = oe(it, at, ke, Ce, re[14], 2878612391, 15), Ce = oe(Ce, it, at, ke, re[5], 4237533241, 21), ke = oe(ke, Ce, it, at, re[12], 1700485571, 6), at = oe(at, ke, Ce, it, re[3], 2399980690, 10), it = oe(it, at, ke, Ce, re[10], 4293915773, 15), Ce = oe(Ce, it, at, ke, re[1], 2240044497, 21), ke = oe(ke, Ce, it, at, re[8], 1873313359, 6), at = oe(at, ke, Ce, it, re[15], 4264355552, 10), it = oe(it, at, ke, Ce, re[6], 2734768916, 15), Ce = oe(Ce, it, at, ke, re[13], 1309151649, 21), ke = oe(ke, Ce, it, at, re[4], 4149444226, 6), at = oe(at, ke, Ce, it, re[11], 3174756917, 10), it = oe(it, at, ke, Ce, re[2], 718787259, 15), Ce = oe(Ce, it, at, ke, re[9], 3951481745, 21), this._a = this._a + ke | 0, this._b = this._b + Ce | 0, this._c = this._c + it | 0, this._d = this._d + at | 0;
  }, J.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var re = L.allocUnsafe(16);
    return re.writeInt32LE(this._a, 0), re.writeInt32LE(this._b, 4), re.writeInt32LE(this._c, 8), re.writeInt32LE(this._d, 12), re;
  };
  function W(re, ce) {
    return re << ce | re >>> 32 - ce;
  }
  function V(re, ce, ke, Ce, it, at, lt) {
    return W(re + (ce & ke | ~ce & Ce) + it + at | 0, lt) + ce | 0;
  }
  function ne(re, ce, ke, Ce, it, at, lt) {
    return W(re + (ce & Ce | ke & ~Ce) + it + at | 0, lt) + ce | 0;
  }
  function ie(re, ce, ke, Ce, it, at, lt) {
    return W(re + (ce ^ ke ^ Ce) + it + at | 0, lt) + ce | 0;
  }
  function oe(re, ce, ke, Ce, it, at, lt) {
    return W(re + (ke ^ (ce | ~Ce)) + it + at | 0, lt) + ce | 0;
  }
  return md5_js = J, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var A = require$$0$1.Buffer, B = requireInherits_browser(), L = requireHashBase(), K = new Array(16), J = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], W = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], V = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ne = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ie = [0, 1518500249, 1859775393, 2400959708, 2840853838], oe = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function re() {
    L.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  B(re, L), re.prototype._update = function() {
    for (var ht = K, dt = 0; dt < 16; ++dt) ht[dt] = this._block.readInt32LE(dt * 4);
    for (var vt = this._a | 0, mt = this._b | 0, Pt = this._c | 0, $t = this._d | 0, qt = this._e | 0, At = this._a | 0, bt = this._b | 0, xt = this._c | 0, wt = this._d | 0, Oe = this._e | 0, rt = 0; rt < 80; rt += 1) {
      var pe, nt;
      rt < 16 ? (pe = ke(vt, mt, Pt, $t, qt, ht[J[rt]], ie[0], V[rt]), nt = lt(At, bt, xt, wt, Oe, ht[W[rt]], oe[0], ne[rt])) : rt < 32 ? (pe = Ce(vt, mt, Pt, $t, qt, ht[J[rt]], ie[1], V[rt]), nt = at(At, bt, xt, wt, Oe, ht[W[rt]], oe[1], ne[rt])) : rt < 48 ? (pe = it(vt, mt, Pt, $t, qt, ht[J[rt]], ie[2], V[rt]), nt = it(At, bt, xt, wt, Oe, ht[W[rt]], oe[2], ne[rt])) : rt < 64 ? (pe = at(vt, mt, Pt, $t, qt, ht[J[rt]], ie[3], V[rt]), nt = Ce(At, bt, xt, wt, Oe, ht[W[rt]], oe[3], ne[rt])) : (pe = lt(vt, mt, Pt, $t, qt, ht[J[rt]], ie[4], V[rt]), nt = ke(At, bt, xt, wt, Oe, ht[W[rt]], oe[4], ne[rt])), vt = qt, qt = $t, $t = ce(Pt, 10), Pt = mt, mt = pe, At = Oe, Oe = wt, wt = ce(xt, 10), xt = bt, bt = nt;
    }
    var ot = this._b + Pt + wt | 0;
    this._b = this._c + $t + Oe | 0, this._c = this._d + qt + At | 0, this._d = this._e + vt + bt | 0, this._e = this._a + mt + xt | 0, this._a = ot;
  }, re.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var ht = A.alloc ? A.alloc(20) : new A(20);
    return ht.writeInt32LE(this._a, 0), ht.writeInt32LE(this._b, 4), ht.writeInt32LE(this._c, 8), ht.writeInt32LE(this._d, 12), ht.writeInt32LE(this._e, 16), ht;
  };
  function ce(ht, dt) {
    return ht << dt | ht >>> 32 - dt;
  }
  function ke(ht, dt, vt, mt, Pt, $t, qt, At) {
    return ce(ht + (dt ^ vt ^ mt) + $t + qt | 0, At) + Pt | 0;
  }
  function Ce(ht, dt, vt, mt, Pt, $t, qt, At) {
    return ce(ht + (dt & vt | ~dt & mt) + $t + qt | 0, At) + Pt | 0;
  }
  function it(ht, dt, vt, mt, Pt, $t, qt, At) {
    return ce(ht + ((dt | ~vt) ^ mt) + $t + qt | 0, At) + Pt | 0;
  }
  function at(ht, dt, vt, mt, Pt, $t, qt, At) {
    return ce(ht + (dt & mt | vt & ~mt) + $t + qt | 0, At) + Pt | 0;
  }
  function lt(ht, dt, vt, mt, Pt, $t, qt, At) {
    return ce(ht + (dt ^ (vt | ~mt)) + $t + qt | 0, At) + Pt | 0;
  }
  return ripemd160$1 = re, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K) {
    this._block = A.alloc(L), this._finalSize = K, this._blockSize = L, this._len = 0;
  }
  return B.prototype.update = function(L, K) {
    typeof L == "string" && (K = K || "utf8", L = A.from(L, K));
    for (var J = this._block, W = this._blockSize, V = L.length, ne = this._len, ie = 0; ie < V; ) {
      for (var oe = ne % W, re = Math.min(V - ie, W - oe), ce = 0; ce < re; ce++)
        J[oe + ce] = L[ie + ce];
      ne += re, ie += re, ne % W === 0 && this._update(J);
    }
    return this._len += V, this;
  }, B.prototype.digest = function(L) {
    var K = this._len % this._blockSize;
    this._block[K] = 128, this._block.fill(0, K + 1), K >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var J = this._len * 8;
    if (J <= 4294967295)
      this._block.writeUInt32BE(J, this._blockSize - 4);
    else {
      var W = (J & 4294967295) >>> 0, V = (J - W) / 4294967296;
      this._block.writeUInt32BE(V, this._blockSize - 8), this._block.writeUInt32BE(W, this._blockSize - 4);
    }
    this._update(this._block);
    var ne = this._hash();
    return L ? ne.toString(L) : ne;
  }, B.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = B, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], J = new Array(80);
  function W() {
    this.init(), this._w = J, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function V(oe) {
    return oe << 5 | oe >>> 27;
  }
  function ne(oe) {
    return oe << 30 | oe >>> 2;
  }
  function ie(oe, re, ce, ke) {
    return oe === 0 ? re & ce | ~re & ke : oe === 2 ? re & ce | re & ke | ce & ke : re ^ ce ^ ke;
  }
  return W.prototype._update = function(oe) {
    for (var re = this._w, ce = this._a | 0, ke = this._b | 0, Ce = this._c | 0, it = this._d | 0, at = this._e | 0, lt = 0; lt < 16; ++lt) re[lt] = oe.readInt32BE(lt * 4);
    for (; lt < 80; ++lt) re[lt] = re[lt - 3] ^ re[lt - 8] ^ re[lt - 14] ^ re[lt - 16];
    for (var ht = 0; ht < 80; ++ht) {
      var dt = ~~(ht / 20), vt = V(ce) + ie(dt, ke, Ce, it) + at + re[ht] + K[dt] | 0;
      at = it, it = Ce, Ce = ne(ke), ke = ce, ce = vt;
    }
    this._a = ce + this._a | 0, this._b = ke + this._b | 0, this._c = Ce + this._c | 0, this._d = it + this._d | 0, this._e = at + this._e | 0;
  }, W.prototype._hash = function() {
    var oe = L.allocUnsafe(20);
    return oe.writeInt32BE(this._a | 0, 0), oe.writeInt32BE(this._b | 0, 4), oe.writeInt32BE(this._c | 0, 8), oe.writeInt32BE(this._d | 0, 12), oe.writeInt32BE(this._e | 0, 16), oe;
  }, sha$1 = W, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], J = new Array(80);
  function W() {
    this.init(), this._w = J, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function V(re) {
    return re << 1 | re >>> 31;
  }
  function ne(re) {
    return re << 5 | re >>> 27;
  }
  function ie(re) {
    return re << 30 | re >>> 2;
  }
  function oe(re, ce, ke, Ce) {
    return re === 0 ? ce & ke | ~ce & Ce : re === 2 ? ce & ke | ce & Ce | ke & Ce : ce ^ ke ^ Ce;
  }
  return W.prototype._update = function(re) {
    for (var ce = this._w, ke = this._a | 0, Ce = this._b | 0, it = this._c | 0, at = this._d | 0, lt = this._e | 0, ht = 0; ht < 16; ++ht) ce[ht] = re.readInt32BE(ht * 4);
    for (; ht < 80; ++ht) ce[ht] = V(ce[ht - 3] ^ ce[ht - 8] ^ ce[ht - 14] ^ ce[ht - 16]);
    for (var dt = 0; dt < 80; ++dt) {
      var vt = ~~(dt / 20), mt = ne(ke) + oe(vt, Ce, it, at) + lt + ce[dt] + K[vt] | 0;
      lt = at, at = it, it = ie(Ce), Ce = ke, ke = mt;
    }
    this._a = ke + this._a | 0, this._b = Ce + this._b | 0, this._c = it + this._c | 0, this._d = at + this._d | 0, this._e = lt + this._e | 0;
  }, W.prototype._hash = function() {
    var re = L.allocUnsafe(20);
    return re.writeInt32BE(this._a | 0, 0), re.writeInt32BE(this._b | 0, 4), re.writeInt32BE(this._c | 0, 8), re.writeInt32BE(this._d | 0, 12), re.writeInt32BE(this._e | 0, 16), re;
  }, sha1$1 = W, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], J = new Array(64);
  function W() {
    this.init(), this._w = J, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function V(ke, Ce, it) {
    return it ^ ke & (Ce ^ it);
  }
  function ne(ke, Ce, it) {
    return ke & Ce | it & (ke | Ce);
  }
  function ie(ke) {
    return (ke >>> 2 | ke << 30) ^ (ke >>> 13 | ke << 19) ^ (ke >>> 22 | ke << 10);
  }
  function oe(ke) {
    return (ke >>> 6 | ke << 26) ^ (ke >>> 11 | ke << 21) ^ (ke >>> 25 | ke << 7);
  }
  function re(ke) {
    return (ke >>> 7 | ke << 25) ^ (ke >>> 18 | ke << 14) ^ ke >>> 3;
  }
  function ce(ke) {
    return (ke >>> 17 | ke << 15) ^ (ke >>> 19 | ke << 13) ^ ke >>> 10;
  }
  return W.prototype._update = function(ke) {
    for (var Ce = this._w, it = this._a | 0, at = this._b | 0, lt = this._c | 0, ht = this._d | 0, dt = this._e | 0, vt = this._f | 0, mt = this._g | 0, Pt = this._h | 0, $t = 0; $t < 16; ++$t) Ce[$t] = ke.readInt32BE($t * 4);
    for (; $t < 64; ++$t) Ce[$t] = ce(Ce[$t - 2]) + Ce[$t - 7] + re(Ce[$t - 15]) + Ce[$t - 16] | 0;
    for (var qt = 0; qt < 64; ++qt) {
      var At = Pt + oe(dt) + V(dt, vt, mt) + K[qt] + Ce[qt] | 0, bt = ie(it) + ne(it, at, lt) | 0;
      Pt = mt, mt = vt, vt = dt, dt = ht + At | 0, ht = lt, lt = at, at = it, it = At + bt | 0;
    }
    this._a = it + this._a | 0, this._b = at + this._b | 0, this._c = lt + this._c | 0, this._d = ht + this._d | 0, this._e = dt + this._e | 0, this._f = vt + this._f | 0, this._g = mt + this._g | 0, this._h = Pt + this._h | 0;
  }, W.prototype._hash = function() {
    var ke = L.allocUnsafe(32);
    return ke.writeInt32BE(this._a, 0), ke.writeInt32BE(this._b, 4), ke.writeInt32BE(this._c, 8), ke.writeInt32BE(this._d, 12), ke.writeInt32BE(this._e, 16), ke.writeInt32BE(this._f, 20), ke.writeInt32BE(this._g, 24), ke.writeInt32BE(this._h, 28), ke;
  }, sha256$3 = W, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var A = requireInherits_browser(), B = requireSha256(), L = requireHash$1(), K = safeBufferExports.Buffer, J = new Array(64);
  function W() {
    this.init(), this._w = J, L.call(this, 64, 56);
  }
  return A(W, B), W.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, W.prototype._hash = function() {
    var V = K.allocUnsafe(28);
    return V.writeInt32BE(this._a, 0), V.writeInt32BE(this._b, 4), V.writeInt32BE(this._c, 8), V.writeInt32BE(this._d, 12), V.writeInt32BE(this._e, 16), V.writeInt32BE(this._f, 20), V.writeInt32BE(this._g, 24), V;
  }, sha224$1 = W, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], J = new Array(160);
  function W() {
    this.init(), this._w = J, B.call(this, 128, 112);
  }
  A(W, B), W.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function V(at, lt, ht) {
    return ht ^ at & (lt ^ ht);
  }
  function ne(at, lt, ht) {
    return at & lt | ht & (at | lt);
  }
  function ie(at, lt) {
    return (at >>> 28 | lt << 4) ^ (lt >>> 2 | at << 30) ^ (lt >>> 7 | at << 25);
  }
  function oe(at, lt) {
    return (at >>> 14 | lt << 18) ^ (at >>> 18 | lt << 14) ^ (lt >>> 9 | at << 23);
  }
  function re(at, lt) {
    return (at >>> 1 | lt << 31) ^ (at >>> 8 | lt << 24) ^ at >>> 7;
  }
  function ce(at, lt) {
    return (at >>> 1 | lt << 31) ^ (at >>> 8 | lt << 24) ^ (at >>> 7 | lt << 25);
  }
  function ke(at, lt) {
    return (at >>> 19 | lt << 13) ^ (lt >>> 29 | at << 3) ^ at >>> 6;
  }
  function Ce(at, lt) {
    return (at >>> 19 | lt << 13) ^ (lt >>> 29 | at << 3) ^ (at >>> 6 | lt << 26);
  }
  function it(at, lt) {
    return at >>> 0 < lt >>> 0 ? 1 : 0;
  }
  return W.prototype._update = function(at) {
    for (var lt = this._w, ht = this._ah | 0, dt = this._bh | 0, vt = this._ch | 0, mt = this._dh | 0, Pt = this._eh | 0, $t = this._fh | 0, qt = this._gh | 0, At = this._hh | 0, bt = this._al | 0, xt = this._bl | 0, wt = this._cl | 0, Oe = this._dl | 0, rt = this._el | 0, pe = this._fl | 0, nt = this._gl | 0, ot = this._hl | 0, st = 0; st < 32; st += 2)
      lt[st] = at.readInt32BE(st * 4), lt[st + 1] = at.readInt32BE(st * 4 + 4);
    for (; st < 160; st += 2) {
      var ut = lt[st - 30], pt = lt[st - 15 * 2 + 1], ft = re(ut, pt), yt = ce(pt, ut);
      ut = lt[st - 2 * 2], pt = lt[st - 2 * 2 + 1];
      var ct = ke(ut, pt), Et = Ce(pt, ut), Nt = lt[st - 7 * 2], jt = lt[st - 7 * 2 + 1], Ot = lt[st - 16 * 2], Bt = lt[st - 16 * 2 + 1], Tt = yt + jt | 0, Ut = ft + Nt + it(Tt, yt) | 0;
      Tt = Tt + Et | 0, Ut = Ut + ct + it(Tt, Et) | 0, Tt = Tt + Bt | 0, Ut = Ut + Ot + it(Tt, Bt) | 0, lt[st] = Ut, lt[st + 1] = Tt;
    }
    for (var Gt = 0; Gt < 160; Gt += 2) {
      Ut = lt[Gt], Tt = lt[Gt + 1];
      var It = ne(ht, dt, vt), Mt = ne(bt, xt, wt), Kt = ie(ht, bt), Qt = ie(bt, ht), rr = oe(Pt, rt), ar = oe(rt, Pt), ur = K[Gt], hr = K[Gt + 1], Yt = V(Pt, $t, qt), Rr = V(rt, pe, nt), lr = ot + ar | 0, $r = At + rr + it(lr, ot) | 0;
      lr = lr + Rr | 0, $r = $r + Yt + it(lr, Rr) | 0, lr = lr + hr | 0, $r = $r + ur + it(lr, hr) | 0, lr = lr + Tt | 0, $r = $r + Ut + it(lr, Tt) | 0;
      var Br = Qt + Mt | 0, dr = Kt + It + it(Br, Qt) | 0;
      At = qt, ot = nt, qt = $t, nt = pe, $t = Pt, pe = rt, rt = Oe + lr | 0, Pt = mt + $r + it(rt, Oe) | 0, mt = vt, Oe = wt, vt = dt, wt = xt, dt = ht, xt = bt, bt = lr + Br | 0, ht = $r + dr + it(bt, lr) | 0;
    }
    this._al = this._al + bt | 0, this._bl = this._bl + xt | 0, this._cl = this._cl + wt | 0, this._dl = this._dl + Oe | 0, this._el = this._el + rt | 0, this._fl = this._fl + pe | 0, this._gl = this._gl + nt | 0, this._hl = this._hl + ot | 0, this._ah = this._ah + ht + it(this._al, bt) | 0, this._bh = this._bh + dt + it(this._bl, xt) | 0, this._ch = this._ch + vt + it(this._cl, wt) | 0, this._dh = this._dh + mt + it(this._dl, Oe) | 0, this._eh = this._eh + Pt + it(this._el, rt) | 0, this._fh = this._fh + $t + it(this._fl, pe) | 0, this._gh = this._gh + qt + it(this._gl, nt) | 0, this._hh = this._hh + At + it(this._hl, ot) | 0;
  }, W.prototype._hash = function() {
    var at = L.allocUnsafe(64);
    function lt(ht, dt, vt) {
      at.writeInt32BE(ht, vt), at.writeInt32BE(dt, vt + 4);
    }
    return lt(this._ah, this._al, 0), lt(this._bh, this._bl, 8), lt(this._ch, this._cl, 16), lt(this._dh, this._dl, 24), lt(this._eh, this._el, 32), lt(this._fh, this._fl, 40), lt(this._gh, this._gl, 48), lt(this._hh, this._hl, 56), at;
  }, sha512$1 = W, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var A = requireInherits_browser(), B = requireSha512(), L = requireHash$1(), K = safeBufferExports.Buffer, J = new Array(160);
  function W() {
    this.init(), this._w = J, L.call(this, 128, 112);
  }
  return A(W, B), W.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, W.prototype._hash = function() {
    var V = K.allocUnsafe(48);
    function ne(ie, oe, re) {
      V.writeInt32BE(ie, re), V.writeInt32BE(oe, re + 4);
    }
    return ne(this._ah, this._al, 0), ne(this._bh, this._bl, 8), ne(this._ch, this._cl, 16), ne(this._dh, this._dl, 24), ne(this._eh, this._el, 32), ne(this._fh, this._fl, 40), V;
  }, sha384$1 = W, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var A = sha_js.exports = function(L) {
    L = L.toLowerCase();
    var K = A[L];
    if (!K) throw new Error(L + " is not supported (we accept pull requests)");
    return new K();
  };
  return A.sha = requireSha$1(), A.sha1 = requireSha1(), A.sha224 = requireSha224(), A.sha256 = requireSha256(), A.sha384 = requireSha384(), A.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = L;
  var A = requireEvents().EventEmitter, B = requireInherits_browser();
  B(L, A), L.Readable = require_stream_readable$1(), L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline(), L.Stream = L;
  function L() {
    A.call(this);
  }
  return L.prototype.pipe = function(K, J) {
    var W = this;
    function V(Ce) {
      K.writable && K.write(Ce) === !1 && W.pause && W.pause();
    }
    W.on("data", V);
    function ne() {
      W.readable && W.resume && W.resume();
    }
    K.on("drain", ne), !K._isStdio && (!J || J.end !== !1) && (W.on("end", oe), W.on("close", re));
    var ie = !1;
    function oe() {
      ie || (ie = !0, K.end());
    }
    function re() {
      ie || (ie = !0, typeof K.destroy == "function" && K.destroy());
    }
    function ce(Ce) {
      if (ke(), A.listenerCount(this, "error") === 0)
        throw Ce;
    }
    W.on("error", ce), K.on("error", ce);
    function ke() {
      W.removeListener("data", V), K.removeListener("drain", ne), W.removeListener("end", oe), W.removeListener("close", re), W.removeListener("error", ce), K.removeListener("error", ce), W.removeListener("end", ke), W.removeListener("close", ke), K.removeListener("close", ke);
    }
    return W.on("end", ke), W.on("close", ke), K.on("close", ke), K.emit("pipe", W), K;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var A = safeBufferExports.Buffer, B = requireStreamBrowserify().Transform, L = requireString_decoder().StringDecoder, K = requireInherits_browser();
  function J(W) {
    B.call(this), this.hashMode = typeof W == "string", this.hashMode ? this[W] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return K(J, B), J.prototype.update = function(W, V, ne) {
    typeof W == "string" && (W = A.from(W, V));
    var ie = this._update(W);
    return this.hashMode ? this : (ne && (ie = this._toString(ie, ne)), ie);
  }, J.prototype.setAutoPadding = function() {
  }, J.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, J.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, J.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, J.prototype._transform = function(W, V, ne) {
    var ie;
    try {
      this.hashMode ? this._update(W) : this.push(this._update(W));
    } catch (oe) {
      ie = oe;
    } finally {
      ne(ie);
    }
  }, J.prototype._flush = function(W) {
    var V;
    try {
      this.push(this.__final());
    } catch (ne) {
      V = ne;
    }
    W(V);
  }, J.prototype._finalOrDigest = function(W) {
    var V = this.__final() || A.alloc(0);
    return W && (V = this._toString(V, W, !0)), V;
  }, J.prototype._toString = function(W, V, ne) {
    if (this._decoder || (this._decoder = new L(V), this._encoding = V), this._encoding !== V) throw new Error("can't switch encodings");
    var ie = this._decoder.write(W);
    return ne && (ie += this._decoder.end()), ie;
  }, cipherBase = J, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var A = requireInherits_browser(), B = requireMd5_js(), L = requireRipemd160(), K = requireSha_js(), J = requireCipherBase();
  function W(V) {
    J.call(this, "digest"), this._hash = V;
  }
  return A(W, J), W.prototype._update = function(V) {
    this._hash.update(V);
  }, W.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(ne) {
    return ne = ne.toLowerCase(), ne === "md5" ? new B() : ne === "rmd160" || ne === "ripemd160" ? new L() : new W(K(ne));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var A = requireInherits_browser(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = B.alloc(128), J = 64;
  function W(V, ne) {
    L.call(this, "digest"), typeof ne == "string" && (ne = B.from(ne)), this._alg = V, this._key = ne, ne.length > J ? ne = V(ne) : ne.length < J && (ne = B.concat([ne, K], J));
    for (var ie = this._ipad = B.allocUnsafe(J), oe = this._opad = B.allocUnsafe(J), re = 0; re < J; re++)
      ie[re] = ne[re] ^ 54, oe[re] = ne[re] ^ 92;
    this._hash = [ie];
  }
  return A(W, L), W.prototype._update = function(V) {
    this._hash.push(V);
  }, W.prototype._final = function() {
    var V = this._alg(B.concat(this._hash));
    return this._alg(B.concat([this._opad, V]));
  }, legacy = W, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var A = requireMd5_js();
  return md5 = function(B) {
    return new A().update(B).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var A = requireInherits_browser(), B = requireLegacy(), L = requireCipherBase(), K = safeBufferExports.Buffer, J = requireMd5(), W = requireRipemd160(), V = requireSha_js(), ne = K.alloc(128);
  function ie(oe, re) {
    L.call(this, "digest"), typeof re == "string" && (re = K.from(re));
    var ce = oe === "sha512" || oe === "sha384" ? 128 : 64;
    if (this._alg = oe, this._key = re, re.length > ce) {
      var ke = oe === "rmd160" ? new W() : V(oe);
      re = ke.update(re).digest();
    } else re.length < ce && (re = K.concat([re, ne], ce));
    for (var Ce = this._ipad = K.allocUnsafe(ce), it = this._opad = K.allocUnsafe(ce), at = 0; at < ce; at++)
      Ce[at] = re[at] ^ 54, it[at] = re[at] ^ 92;
    this._hash = oe === "rmd160" ? new W() : V(oe), this._hash.update(Ce);
  }
  return A(ie, L), ie.prototype._update = function(oe) {
    this._hash.update(oe);
  }, ie.prototype._final = function() {
    var oe = this._hash.digest(), re = this._alg === "rmd160" ? new W() : V(this._alg);
    return re.update(this._opad).update(oe).digest();
  }, browser$8 = function(re, ce) {
    return re = re.toLowerCase(), re === "rmd160" || re === "ripemd160" ? new ie("rmd160", ce) : re === "md5" ? new B(J, ce) : new ie(re, ce);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var A = Math.pow(2, 30) - 1;
  return precondition = function(B, L) {
    if (typeof B != "number")
      throw new TypeError("Iterations not a number");
    if (B < 0)
      throw new TypeError("Bad iterations");
    if (typeof L != "number")
      throw new TypeError("Key length not a number");
    if (L < 0 || L > A || L !== L)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var A;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    A = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var B = parseInt(process$1.version.split(".")[0].slice(1), 10);
    A = B >= 6 ? "utf-8" : "binary";
  } else
    A = "utf-8";
  return defaultEncoding_1 = A, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var A = safeBufferExports.Buffer;
  return toBuffer$1 = function(B, L, K) {
    if (A.isBuffer(B))
      return B;
    if (typeof B == "string")
      return A.from(B, L);
    if (ArrayBuffer.isView(B))
      return A.from(B.buffer);
    throw new TypeError(K + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var A = requireMd5(), B = requireRipemd160(), L = requireSha_js(), K = safeBufferExports.Buffer, J = requirePrecondition(), W = requireDefaultEncoding(), V = requireToBuffer(), ne = K.alloc(128), ie = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function oe(ke, Ce, it) {
    var at = re(ke), lt = ke === "sha512" || ke === "sha384" ? 128 : 64;
    Ce.length > lt ? Ce = at(Ce) : Ce.length < lt && (Ce = K.concat([Ce, ne], lt));
    for (var ht = K.allocUnsafe(lt + ie[ke]), dt = K.allocUnsafe(lt + ie[ke]), vt = 0; vt < lt; vt++)
      ht[vt] = Ce[vt] ^ 54, dt[vt] = Ce[vt] ^ 92;
    var mt = K.allocUnsafe(lt + it + 4);
    ht.copy(mt, 0, 0, lt), this.ipad1 = mt, this.ipad2 = ht, this.opad = dt, this.alg = ke, this.blocksize = lt, this.hash = at, this.size = ie[ke];
  }
  oe.prototype.run = function(ke, Ce) {
    ke.copy(Ce, this.blocksize);
    var it = this.hash(Ce);
    return it.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function re(ke) {
    function Ce(at) {
      return L(ke).update(at).digest();
    }
    function it(at) {
      return new B().update(at).digest();
    }
    return ke === "rmd160" || ke === "ripemd160" ? it : ke === "md5" ? A : Ce;
  }
  function ce(ke, Ce, it, at, lt) {
    J(it, at), ke = V(ke, W, "Password"), Ce = V(Ce, W, "Salt"), lt = lt || "sha1";
    var ht = new oe(lt, ke, Ce.length), dt = K.allocUnsafe(at), vt = K.allocUnsafe(Ce.length + 4);
    Ce.copy(vt, 0, 0, Ce.length);
    for (var mt = 0, Pt = ie[lt], $t = Math.ceil(at / Pt), qt = 1; qt <= $t; qt++) {
      vt.writeUInt32BE(qt, Ce.length);
      for (var At = ht.run(vt, ht.ipad1), bt = At, xt = 1; xt < it; xt++) {
        bt = ht.run(bt, ht.ipad2);
        for (var wt = 0; wt < Pt; wt++) At[wt] ^= bt[wt];
      }
      At.copy(dt, mt), mt += Pt;
    }
    return dt;
  }
  return syncBrowser = ce, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var A = safeBufferExports.Buffer, B = requirePrecondition(), L = requireDefaultEncoding(), K = requireSyncBrowser(), J = requireToBuffer(), W, V = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ne = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ie = [];
  function oe(it) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !V || !V.importKey || !V.deriveBits)
      return Promise.resolve(!1);
    if (ie[it] !== void 0)
      return ie[it];
    W = W || A.alloc(8);
    var at = ke(W, W, 10, 128, it).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ie[it] = at, at;
  }
  var re;
  function ce() {
    return re || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? re = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? re = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? re = commonjsGlobal.setImmediate : re = commonjsGlobal.setTimeout, re);
  }
  function ke(it, at, lt, ht, dt) {
    return V.importKey(
      "raw",
      it,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(vt) {
      return V.deriveBits({
        name: "PBKDF2",
        salt: at,
        iterations: lt,
        hash: {
          name: dt
        }
      }, vt, ht << 3);
    }).then(function(vt) {
      return A.from(vt);
    });
  }
  function Ce(it, at) {
    it.then(function(lt) {
      ce()(function() {
        at(null, lt);
      });
    }, function(lt) {
      ce()(function() {
        at(lt);
      });
    });
  }
  return async = function(it, at, lt, ht, dt, vt) {
    typeof dt == "function" && (vt = dt, dt = void 0), dt = dt || "sha1";
    var mt = ne[dt.toLowerCase()];
    if (!mt || typeof commonjsGlobal.Promise != "function") {
      ce()(function() {
        var Pt;
        try {
          Pt = K(it, at, lt, ht, dt);
        } catch ($t) {
          return vt($t);
        }
        vt(null, Pt);
      });
      return;
    }
    if (B(lt, ht), it = J(it, L, "Password"), at = J(at, L, "Salt"), typeof vt != "function") throw new Error("No callback provided to pbkdf2");
    Ce(oe(mt).then(function(Pt) {
      return Pt ? ke(it, at, lt, ht, mt) : K(it, at, lt, ht, dt);
    }), vt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(J, W) {
    var V = J[0 + W] << 24 | J[1 + W] << 16 | J[2 + W] << 8 | J[3 + W];
    return V >>> 0;
  }, utils$4.writeUInt32BE = function(J, W, V) {
    J[0 + V] = W >>> 24, J[1 + V] = W >>> 16 & 255, J[2 + V] = W >>> 8 & 255, J[3 + V] = W & 255;
  }, utils$4.ip = function(J, W, V, ne) {
    for (var ie = 0, oe = 0, re = 6; re >= 0; re -= 2) {
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= W >>> ce + re & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= J >>> ce + re & 1;
    }
    for (var re = 6; re >= 0; re -= 2) {
      for (var ce = 1; ce <= 25; ce += 8)
        oe <<= 1, oe |= W >>> ce + re & 1;
      for (var ce = 1; ce <= 25; ce += 8)
        oe <<= 1, oe |= J >>> ce + re & 1;
    }
    V[ne + 0] = ie >>> 0, V[ne + 1] = oe >>> 0;
  }, utils$4.rip = function(J, W, V, ne) {
    for (var ie = 0, oe = 0, re = 0; re < 4; re++)
      for (var ce = 24; ce >= 0; ce -= 8)
        ie <<= 1, ie |= W >>> ce + re & 1, ie <<= 1, ie |= J >>> ce + re & 1;
    for (var re = 4; re < 8; re++)
      for (var ce = 24; ce >= 0; ce -= 8)
        oe <<= 1, oe |= W >>> ce + re & 1, oe <<= 1, oe |= J >>> ce + re & 1;
    V[ne + 0] = ie >>> 0, V[ne + 1] = oe >>> 0;
  }, utils$4.pc1 = function(J, W, V, ne) {
    for (var ie = 0, oe = 0, re = 7; re >= 5; re--) {
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= W >> ce + re & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= J >> ce + re & 1;
    }
    for (var ce = 0; ce <= 24; ce += 8)
      ie <<= 1, ie |= W >> ce + re & 1;
    for (var re = 1; re <= 3; re++) {
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= W >> ce + re & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= J >> ce + re & 1;
    }
    for (var ce = 0; ce <= 24; ce += 8)
      oe <<= 1, oe |= J >> ce + re & 1;
    V[ne + 0] = ie >>> 0, V[ne + 1] = oe >>> 0;
  }, utils$4.r28shl = function(J, W) {
    return J << W & 268435455 | J >>> 28 - W;
  };
  var A = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(J, W, V, ne) {
    for (var ie = 0, oe = 0, re = A.length >>> 1, ce = 0; ce < re; ce++)
      ie <<= 1, ie |= J >>> A[ce] & 1;
    for (var ce = re; ce < A.length; ce++)
      oe <<= 1, oe |= W >>> A[ce] & 1;
    V[ne + 0] = ie >>> 0, V[ne + 1] = oe >>> 0;
  }, utils$4.expand = function(J, W, V) {
    var ne = 0, ie = 0;
    ne = (J & 1) << 5 | J >>> 27;
    for (var oe = 23; oe >= 15; oe -= 4)
      ne <<= 6, ne |= J >>> oe & 63;
    for (var oe = 11; oe >= 3; oe -= 4)
      ie |= J >>> oe & 63, ie <<= 6;
    ie |= (J & 31) << 1 | J >>> 31, W[V + 0] = ne >>> 0, W[V + 1] = ie >>> 0;
  };
  var B = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(J, W) {
    for (var V = 0, ne = 0; ne < 4; ne++) {
      var ie = J >>> 18 - ne * 6 & 63, oe = B[ne * 64 + ie];
      V <<= 4, V |= oe;
    }
    for (var ne = 0; ne < 4; ne++) {
      var ie = W >>> 18 - ne * 6 & 63, oe = B[4 * 64 + ne * 64 + ie];
      V <<= 4, V |= oe;
    }
    return V >>> 0;
  };
  var L = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(J) {
    for (var W = 0, V = 0; V < L.length; V++)
      W <<= 1, W |= J >>> L[V] & 1;
    return W >>> 0;
  }, utils$4.padSplit = function(J, W, V) {
    for (var ne = J.toString(2); ne.length < W; )
      ne = "0" + ne;
    for (var ie = [], oe = 0; oe < W; oe += V)
      ie.push(ne.slice(oe, oe + V));
    return ie.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = A;
  function A(B, L) {
    if (!B)
      throw new Error(L || "Assertion failed");
  }
  return A.equal = function(L, K, J) {
    if (L != K)
      throw new Error(J || "Assertion failed: " + L + " != " + K);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var A = requireMinimalisticAssert();
  function B(L) {
    this.options = L, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = L.padding !== !1;
  }
  return cipher = B, B.prototype._init = function() {
  }, B.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, B.prototype._buffer = function(K, J) {
    for (var W = Math.min(this.buffer.length - this.bufferOff, K.length - J), V = 0; V < W; V++)
      this.buffer[this.bufferOff + V] = K[J + V];
    return this.bufferOff += W, W;
  }, B.prototype._flushBuffer = function(K, J) {
    return this._update(this.buffer, 0, K, J), this.bufferOff = 0, this.blockSize;
  }, B.prototype._updateEncrypt = function(K) {
    var J = 0, W = 0, V = (this.bufferOff + K.length) / this.blockSize | 0, ne = new Array(V * this.blockSize);
    this.bufferOff !== 0 && (J += this._buffer(K, J), this.bufferOff === this.buffer.length && (W += this._flushBuffer(ne, W)));
    for (var ie = K.length - (K.length - J) % this.blockSize; J < ie; J += this.blockSize)
      this._update(K, J, ne, W), W += this.blockSize;
    for (; J < K.length; J++, this.bufferOff++)
      this.buffer[this.bufferOff] = K[J];
    return ne;
  }, B.prototype._updateDecrypt = function(K) {
    for (var J = 0, W = 0, V = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, ne = new Array(V * this.blockSize); V > 0; V--)
      J += this._buffer(K, J), W += this._flushBuffer(ne, W);
    return J += this._buffer(K, J), ne;
  }, B.prototype.final = function(K) {
    var J;
    K && (J = this.update(K));
    var W;
    return this.type === "encrypt" ? W = this._finalEncrypt() : W = this._finalDecrypt(), J ? J.concat(W) : W;
  }, B.prototype._pad = function(K, J) {
    if (J === 0)
      return !1;
    for (; J < K.length; )
      K[J++] = 0;
    return !0;
  }, B.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, B.prototype._unpad = function(K) {
    return K;
  }, B.prototype._finalDecrypt = function() {
    A.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireUtils$3(), K = requireCipher();
  function J() {
    this.tmp = new Array(2), this.keys = null;
  }
  function W(ne) {
    K.call(this, ne);
    var ie = new J();
    this._desState = ie, this.deriveKeys(ie, ne.key);
  }
  B(W, K), des = W, W.create = function(ie) {
    return new W(ie);
  };
  var V = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return W.prototype.deriveKeys = function(ie, oe) {
    ie.keys = new Array(16 * 2), A.equal(oe.length, this.blockSize, "Invalid key length");
    var re = L.readUInt32BE(oe, 0), ce = L.readUInt32BE(oe, 4);
    L.pc1(re, ce, ie.tmp, 0), re = ie.tmp[0], ce = ie.tmp[1];
    for (var ke = 0; ke < ie.keys.length; ke += 2) {
      var Ce = V[ke >>> 1];
      re = L.r28shl(re, Ce), ce = L.r28shl(ce, Ce), L.pc2(re, ce, ie.keys, ke);
    }
  }, W.prototype._update = function(ie, oe, re, ce) {
    var ke = this._desState, Ce = L.readUInt32BE(ie, oe), it = L.readUInt32BE(ie, oe + 4);
    L.ip(Ce, it, ke.tmp, 0), Ce = ke.tmp[0], it = ke.tmp[1], this.type === "encrypt" ? this._encrypt(ke, Ce, it, ke.tmp, 0) : this._decrypt(ke, Ce, it, ke.tmp, 0), Ce = ke.tmp[0], it = ke.tmp[1], L.writeUInt32BE(re, Ce, ce), L.writeUInt32BE(re, it, ce + 4);
  }, W.prototype._pad = function(ie, oe) {
    if (this.padding === !1)
      return !1;
    for (var re = ie.length - oe, ce = oe; ce < ie.length; ce++)
      ie[ce] = re;
    return !0;
  }, W.prototype._unpad = function(ie) {
    if (this.padding === !1)
      return ie;
    for (var oe = ie[ie.length - 1], re = ie.length - oe; re < ie.length; re++)
      A.equal(ie[re], oe);
    return ie.slice(0, ie.length - oe);
  }, W.prototype._encrypt = function(ie, oe, re, ce, ke) {
    for (var Ce = oe, it = re, at = 0; at < ie.keys.length; at += 2) {
      var lt = ie.keys[at], ht = ie.keys[at + 1];
      L.expand(it, ie.tmp, 0), lt ^= ie.tmp[0], ht ^= ie.tmp[1];
      var dt = L.substitute(lt, ht), vt = L.permute(dt), mt = it;
      it = (Ce ^ vt) >>> 0, Ce = mt;
    }
    L.rip(it, Ce, ce, ke);
  }, W.prototype._decrypt = function(ie, oe, re, ce, ke) {
    for (var Ce = re, it = oe, at = ie.keys.length - 2; at >= 0; at -= 2) {
      var lt = ie.keys[at], ht = ie.keys[at + 1];
      L.expand(Ce, ie.tmp, 0), lt ^= ie.tmp[0], ht ^= ie.tmp[1];
      var dt = L.substitute(lt, ht), vt = L.permute(dt), mt = Ce;
      Ce = (it ^ vt) >>> 0, it = mt;
    }
    L.rip(Ce, it, ce, ke);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = {};
  function K(W) {
    A.equal(W.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var V = 0; V < this.iv.length; V++)
      this.iv[V] = W[V];
  }
  function J(W) {
    function V(re) {
      W.call(this, re), this._cbcInit();
    }
    B(V, W);
    for (var ne = Object.keys(L), ie = 0; ie < ne.length; ie++) {
      var oe = ne[ie];
      V.prototype[oe] = L[oe];
    }
    return V.create = function(ce) {
      return new V(ce);
    }, V;
  }
  return cbc$1.instantiate = J, L._cbcInit = function() {
    var V = new K(this.options.iv);
    this._cbcState = V;
  }, L._update = function(V, ne, ie, oe) {
    var re = this._cbcState, ce = this.constructor.super_.prototype, ke = re.iv;
    if (this.type === "encrypt") {
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] ^= V[ne + Ce];
      ce._update.call(this, ke, 0, ie, oe);
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] = ie[oe + Ce];
    } else {
      ce._update.call(this, V, ne, ie, oe);
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ie[oe + Ce] ^= ke[Ce];
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] = V[ne + Ce];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireCipher(), K = requireDes$1();
  function J(V, ne) {
    A.equal(ne.length, 24, "Invalid key length");
    var ie = ne.slice(0, 8), oe = ne.slice(8, 16), re = ne.slice(16, 24);
    V === "encrypt" ? this.ciphers = [
      K.create({ type: "encrypt", key: ie }),
      K.create({ type: "decrypt", key: oe }),
      K.create({ type: "encrypt", key: re })
    ] : this.ciphers = [
      K.create({ type: "decrypt", key: re }),
      K.create({ type: "encrypt", key: oe }),
      K.create({ type: "decrypt", key: ie })
    ];
  }
  function W(V) {
    L.call(this, V);
    var ne = new J(this.type, this.options.key);
    this._edeState = ne;
  }
  return B(W, L), ede = W, W.create = function(ne) {
    return new W(ne);
  }, W.prototype._update = function(ne, ie, oe, re) {
    var ce = this._edeState;
    ce.ciphers[0]._update(ne, ie, oe, re), ce.ciphers[1]._update(oe, re, oe, re), ce.ciphers[2]._update(oe, re, oe, re);
  }, W.prototype._pad = K.prototype._pad, W.prototype._unpad = K.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var A = requireCipherBase(), B = requireDes(), L = requireInherits_browser(), K = safeBufferExports.Buffer, J = {
    "des-ede3-cbc": B.CBC.instantiate(B.EDE),
    "des-ede3": B.EDE,
    "des-ede-cbc": B.CBC.instantiate(B.EDE),
    "des-ede": B.EDE,
    "des-cbc": B.CBC.instantiate(B.DES),
    "des-ecb": B.DES
  };
  J.des = J["des-cbc"], J.des3 = J["des-ede3-cbc"], browserifyDes = W, L(W, A);
  function W(V) {
    A.call(this);
    var ne = V.mode.toLowerCase(), ie = J[ne], oe;
    V.decrypt ? oe = "decrypt" : oe = "encrypt";
    var re = V.key;
    K.isBuffer(re) || (re = K.from(re)), (ne === "des-ede" || ne === "des-ede-cbc") && (re = K.concat([re, re.slice(0, 8)]));
    var ce = V.iv;
    K.isBuffer(ce) || (ce = K.from(ce)), this._des = ie.create({
      key: re,
      iv: ce,
      type: oe
    });
  }
  return W.prototype._update = function(V) {
    return K.from(this._des.update(V));
  }, W.prototype._final = function() {
    return K.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(A, B) {
    return A._cipher.encryptBlock(B);
  }, ecb.decrypt = function(A, B) {
    return A._cipher.decryptBlock(B);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(B, L) {
    for (var K = Math.min(B.length, L.length), J = new Buffer$1(K), W = 0; W < K; ++W)
      J[W] = B[W] ^ L[W];
    return J;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var A = requireBufferXor();
  return cbc.encrypt = function(B, L) {
    var K = A(L, B._prev);
    return B._prev = B._cipher.encryptBlock(K), B._prev;
  }, cbc.decrypt = function(B, L) {
    var K = B._prev;
    B._prev = L;
    var J = B._cipher.decryptBlock(L);
    return A(J, K);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var A = safeBufferExports.Buffer, B = requireBufferXor();
  function L(K, J, W) {
    var V = J.length, ne = B(J, K._cache);
    return K._cache = K._cache.slice(V), K._prev = A.concat([K._prev, W ? J : ne]), ne;
  }
  return cfb.encrypt = function(K, J, W) {
    for (var V = A.allocUnsafe(0), ne; J.length; )
      if (K._cache.length === 0 && (K._cache = K._cipher.encryptBlock(K._prev), K._prev = A.allocUnsafe(0)), K._cache.length <= J.length)
        ne = K._cache.length, V = A.concat([V, L(K, J.slice(0, ne), W)]), J = J.slice(ne);
      else {
        V = A.concat([V, L(K, J, W)]);
        break;
      }
    return V;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K, J) {
    var W = L._cipher.encryptBlock(L._prev), V = W[0] ^ K;
    return L._prev = A.concat([
      L._prev.slice(1),
      A.from([J ? K : V])
    ]), V;
  }
  return cfb8.encrypt = function(L, K, J) {
    for (var W = K.length, V = A.allocUnsafe(W), ne = -1; ++ne < W; )
      V[ne] = B(L, K[ne], J);
    return V;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var A = safeBufferExports.Buffer;
  function B(K, J, W) {
    for (var V, ne = -1, ie = 8, oe = 0, re, ce; ++ne < ie; )
      V = K._cipher.encryptBlock(K._prev), re = J & 1 << 7 - ne ? 128 : 0, ce = V[0] ^ re, oe += (ce & 128) >> ne % 8, K._prev = L(K._prev, W ? re : ce);
    return oe;
  }
  function L(K, J) {
    var W = K.length, V = -1, ne = A.allocUnsafe(K.length);
    for (K = A.concat([K, A.from([J])]); ++V < W; )
      ne[V] = K[V] << 1 | K[V + 1] >> 7;
    return ne;
  }
  return cfb1.encrypt = function(K, J, W) {
    for (var V = J.length, ne = A.allocUnsafe(V), ie = -1; ++ie < V; )
      ne[ie] = B(K, J[ie], W);
    return ne;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var A = requireBufferXor();
  function B(L) {
    return L._prev = L._cipher.encryptBlock(L._prev), L._prev;
  }
  return ofb.encrypt = function(L, K) {
    for (; L._cache.length < K.length; )
      L._cache = Buffer$1.concat([L._cache, B(L)]);
    var J = L._cache.slice(0, K.length);
    return L._cache = L._cache.slice(K.length), A(K, J);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function A(B) {
    for (var L = B.length, K; L--; )
      if (K = B.readUInt8(L), K === 255)
        B.writeUInt8(0, L);
      else {
        K++, B.writeUInt8(K, L);
        break;
      }
  }
  return incr32_1 = A, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var A = requireBufferXor(), B = safeBufferExports.Buffer, L = requireIncr32();
  function K(W) {
    var V = W._cipher.encryptBlockRaw(W._prev);
    return L(W._prev), V;
  }
  var J = 16;
  return ctr.encrypt = function(W, V) {
    var ne = Math.ceil(V.length / J), ie = W._cache.length;
    W._cache = B.concat([
      W._cache,
      B.allocUnsafe(ne * J)
    ]);
    for (var oe = 0; oe < ne; oe++) {
      var re = K(W), ce = ie + oe * J;
      W._cache.writeUInt32BE(re[0], ce + 0), W._cache.writeUInt32BE(re[1], ce + 4), W._cache.writeUInt32BE(re[2], ce + 8), W._cache.writeUInt32BE(re[3], ce + 12);
    }
    var ke = W._cache.slice(0, V.length);
    return W._cache = W._cache.slice(V.length), A(V, ke);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var A = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, B = require$$2;
  for (var L in B)
    B[L].module = A[B[L].mode];
  return modes_1 = B, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var A = safeBufferExports.Buffer;
  function B(ne) {
    A.isBuffer(ne) || (ne = A.from(ne));
    for (var ie = ne.length / 4 | 0, oe = new Array(ie), re = 0; re < ie; re++)
      oe[re] = ne.readUInt32BE(re * 4);
    return oe;
  }
  function L(ne) {
    for (var ie = 0; ie < ne.length; ne++)
      ne[ie] = 0;
  }
  function K(ne, ie, oe, re, ce) {
    for (var ke = oe[0], Ce = oe[1], it = oe[2], at = oe[3], lt = ne[0] ^ ie[0], ht = ne[1] ^ ie[1], dt = ne[2] ^ ie[2], vt = ne[3] ^ ie[3], mt, Pt, $t, qt, At = 4, bt = 1; bt < ce; bt++)
      mt = ke[lt >>> 24] ^ Ce[ht >>> 16 & 255] ^ it[dt >>> 8 & 255] ^ at[vt & 255] ^ ie[At++], Pt = ke[ht >>> 24] ^ Ce[dt >>> 16 & 255] ^ it[vt >>> 8 & 255] ^ at[lt & 255] ^ ie[At++], $t = ke[dt >>> 24] ^ Ce[vt >>> 16 & 255] ^ it[lt >>> 8 & 255] ^ at[ht & 255] ^ ie[At++], qt = ke[vt >>> 24] ^ Ce[lt >>> 16 & 255] ^ it[ht >>> 8 & 255] ^ at[dt & 255] ^ ie[At++], lt = mt, ht = Pt, dt = $t, vt = qt;
    return mt = (re[lt >>> 24] << 24 | re[ht >>> 16 & 255] << 16 | re[dt >>> 8 & 255] << 8 | re[vt & 255]) ^ ie[At++], Pt = (re[ht >>> 24] << 24 | re[dt >>> 16 & 255] << 16 | re[vt >>> 8 & 255] << 8 | re[lt & 255]) ^ ie[At++], $t = (re[dt >>> 24] << 24 | re[vt >>> 16 & 255] << 16 | re[lt >>> 8 & 255] << 8 | re[ht & 255]) ^ ie[At++], qt = (re[vt >>> 24] << 24 | re[lt >>> 16 & 255] << 16 | re[ht >>> 8 & 255] << 8 | re[dt & 255]) ^ ie[At++], mt = mt >>> 0, Pt = Pt >>> 0, $t = $t >>> 0, qt = qt >>> 0, [mt, Pt, $t, qt];
  }
  var J = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], W = function() {
    for (var ne = new Array(256), ie = 0; ie < 256; ie++)
      ie < 128 ? ne[ie] = ie << 1 : ne[ie] = ie << 1 ^ 283;
    for (var oe = [], re = [], ce = [[], [], [], []], ke = [[], [], [], []], Ce = 0, it = 0, at = 0; at < 256; ++at) {
      var lt = it ^ it << 1 ^ it << 2 ^ it << 3 ^ it << 4;
      lt = lt >>> 8 ^ lt & 255 ^ 99, oe[Ce] = lt, re[lt] = Ce;
      var ht = ne[Ce], dt = ne[ht], vt = ne[dt], mt = ne[lt] * 257 ^ lt * 16843008;
      ce[0][Ce] = mt << 24 | mt >>> 8, ce[1][Ce] = mt << 16 | mt >>> 16, ce[2][Ce] = mt << 8 | mt >>> 24, ce[3][Ce] = mt, mt = vt * 16843009 ^ dt * 65537 ^ ht * 257 ^ Ce * 16843008, ke[0][lt] = mt << 24 | mt >>> 8, ke[1][lt] = mt << 16 | mt >>> 16, ke[2][lt] = mt << 8 | mt >>> 24, ke[3][lt] = mt, Ce === 0 ? Ce = it = 1 : (Ce = ht ^ ne[ne[ne[vt ^ ht]]], it ^= ne[ne[it]]);
    }
    return {
      SBOX: oe,
      INV_SBOX: re,
      SUB_MIX: ce,
      INV_SUB_MIX: ke
    };
  }();
  function V(ne) {
    this._key = B(ne), this._reset();
  }
  return V.blockSize = 4 * 4, V.keySize = 256 / 8, V.prototype.blockSize = V.blockSize, V.prototype.keySize = V.keySize, V.prototype._reset = function() {
    for (var ne = this._key, ie = ne.length, oe = ie + 6, re = (oe + 1) * 4, ce = [], ke = 0; ke < ie; ke++)
      ce[ke] = ne[ke];
    for (ke = ie; ke < re; ke++) {
      var Ce = ce[ke - 1];
      ke % ie === 0 ? (Ce = Ce << 8 | Ce >>> 24, Ce = W.SBOX[Ce >>> 24] << 24 | W.SBOX[Ce >>> 16 & 255] << 16 | W.SBOX[Ce >>> 8 & 255] << 8 | W.SBOX[Ce & 255], Ce ^= J[ke / ie | 0] << 24) : ie > 6 && ke % ie === 4 && (Ce = W.SBOX[Ce >>> 24] << 24 | W.SBOX[Ce >>> 16 & 255] << 16 | W.SBOX[Ce >>> 8 & 255] << 8 | W.SBOX[Ce & 255]), ce[ke] = ce[ke - ie] ^ Ce;
    }
    for (var it = [], at = 0; at < re; at++) {
      var lt = re - at, ht = ce[lt - (at % 4 ? 0 : 4)];
      at < 4 || lt <= 4 ? it[at] = ht : it[at] = W.INV_SUB_MIX[0][W.SBOX[ht >>> 24]] ^ W.INV_SUB_MIX[1][W.SBOX[ht >>> 16 & 255]] ^ W.INV_SUB_MIX[2][W.SBOX[ht >>> 8 & 255]] ^ W.INV_SUB_MIX[3][W.SBOX[ht & 255]];
    }
    this._nRounds = oe, this._keySchedule = ce, this._invKeySchedule = it;
  }, V.prototype.encryptBlockRaw = function(ne) {
    return ne = B(ne), K(ne, this._keySchedule, W.SUB_MIX, W.SBOX, this._nRounds);
  }, V.prototype.encryptBlock = function(ne) {
    var ie = this.encryptBlockRaw(ne), oe = A.allocUnsafe(16);
    return oe.writeUInt32BE(ie[0], 0), oe.writeUInt32BE(ie[1], 4), oe.writeUInt32BE(ie[2], 8), oe.writeUInt32BE(ie[3], 12), oe;
  }, V.prototype.decryptBlock = function(ne) {
    ne = B(ne);
    var ie = ne[1];
    ne[1] = ne[3], ne[3] = ie;
    var oe = K(ne, this._invKeySchedule, W.INV_SUB_MIX, W.INV_SBOX, this._nRounds), re = A.allocUnsafe(16);
    return re.writeUInt32BE(oe[0], 0), re.writeUInt32BE(oe[3], 4), re.writeUInt32BE(oe[2], 8), re.writeUInt32BE(oe[1], 12), re;
  }, V.prototype.scrub = function() {
    L(this._keySchedule), L(this._invKeySchedule), L(this._key);
  }, aes.AES = V, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var A = safeBufferExports.Buffer, B = A.alloc(16, 0);
  function L(W) {
    return [
      W.readUInt32BE(0),
      W.readUInt32BE(4),
      W.readUInt32BE(8),
      W.readUInt32BE(12)
    ];
  }
  function K(W) {
    var V = A.allocUnsafe(16);
    return V.writeUInt32BE(W[0] >>> 0, 0), V.writeUInt32BE(W[1] >>> 0, 4), V.writeUInt32BE(W[2] >>> 0, 8), V.writeUInt32BE(W[3] >>> 0, 12), V;
  }
  function J(W) {
    this.h = W, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
  }
  return J.prototype.ghash = function(W) {
    for (var V = -1; ++V < W.length; )
      this.state[V] ^= W[V];
    this._multiply();
  }, J.prototype._multiply = function() {
    for (var W = L(this.h), V = [0, 0, 0, 0], ne, ie, oe, re = -1; ++re < 128; ) {
      for (ie = (this.state[~~(re / 8)] & 1 << 7 - re % 8) !== 0, ie && (V[0] ^= W[0], V[1] ^= W[1], V[2] ^= W[2], V[3] ^= W[3]), oe = (W[3] & 1) !== 0, ne = 3; ne > 0; ne--)
        W[ne] = W[ne] >>> 1 | (W[ne - 1] & 1) << 31;
      W[0] = W[0] >>> 1, oe && (W[0] = W[0] ^ 225 << 24);
    }
    this.state = K(V);
  }, J.prototype.update = function(W) {
    this.cache = A.concat([this.cache, W]);
    for (var V; this.cache.length >= 16; )
      V = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(V);
  }, J.prototype.final = function(W, V) {
    return this.cache.length && this.ghash(A.concat([this.cache, B], 16)), this.ghash(K([0, W, 0, V])), this.state;
  }, ghash = J, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser(), J = requireGhash(), W = requireBufferXor(), V = requireIncr32();
  function ne(re, ce) {
    var ke = 0;
    re.length !== ce.length && ke++;
    for (var Ce = Math.min(re.length, ce.length), it = 0; it < Ce; ++it)
      ke += re[it] ^ ce[it];
    return ke;
  }
  function ie(re, ce, ke) {
    if (ce.length === 12)
      return re._finID = B.concat([ce, B.from([0, 0, 0, 1])]), B.concat([ce, B.from([0, 0, 0, 2])]);
    var Ce = new J(ke), it = ce.length, at = it % 16;
    Ce.update(ce), at && (at = 16 - at, Ce.update(B.alloc(at, 0))), Ce.update(B.alloc(8, 0));
    var lt = it * 8, ht = B.alloc(8);
    ht.writeUIntBE(lt, 0, 8), Ce.update(ht), re._finID = Ce.state;
    var dt = B.from(re._finID);
    return V(dt), dt;
  }
  function oe(re, ce, ke, Ce) {
    L.call(this);
    var it = B.alloc(4, 0);
    this._cipher = new A.AES(ce);
    var at = this._cipher.encryptBlock(it);
    this._ghash = new J(at), ke = ie(this, ke, at), this._prev = B.from(ke), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = Ce, this._alen = 0, this._len = 0, this._mode = re, this._authTag = null, this._called = !1;
  }
  return K(oe, L), oe.prototype._update = function(re) {
    if (!this._called && this._alen) {
      var ce = 16 - this._alen % 16;
      ce < 16 && (ce = B.alloc(ce, 0), this._ghash.update(ce));
    }
    this._called = !0;
    var ke = this._mode.encrypt(this, re);
    return this._decrypt ? this._ghash.update(re) : this._ghash.update(ke), this._len += re.length, ke;
  }, oe.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var re = W(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ne(re, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = re, this._cipher.scrub();
  }, oe.prototype.getAuthTag = function() {
    if (this._decrypt || !B.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, oe.prototype.setAuthTag = function(ce) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = ce;
  }, oe.prototype.setAAD = function(ce) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(ce), this._alen += ce.length;
  }, authCipher = oe, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser();
  function J(W, V, ne, ie) {
    L.call(this), this._cipher = new A.AES(V), this._prev = B.from(ne), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = ie, this._mode = W;
  }
  return K(J, L), J.prototype._update = function(W) {
    return this._mode.encrypt(this, W, this._decrypt);
  }, J.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = J, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var A = safeBufferExports.Buffer, B = requireMd5_js();
  function L(K, J, W, V) {
    if (A.isBuffer(K) || (K = A.from(K, "binary")), J && (A.isBuffer(J) || (J = A.from(J, "binary")), J.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var ne = W / 8, ie = A.alloc(ne), oe = A.alloc(V || 0), re = A.alloc(0); ne > 0 || V > 0; ) {
      var ce = new B();
      ce.update(re), ce.update(K), J && ce.update(J), re = ce.digest();
      var ke = 0;
      if (ne > 0) {
        var Ce = ie.length - ne;
        ke = Math.min(ne, re.length), re.copy(ie, Ce, 0, ke), ne -= ke;
      }
      if (ke < re.length && V > 0) {
        var it = oe.length - V, at = Math.min(V, re.length - ke);
        re.copy(oe, it, ke, ke + at), V -= at;
      }
    }
    return re.fill(0), { key: ie, iv: oe };
  }
  return evp_bytestokey = L, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var A = requireModes$1(), B = requireAuthCipher(), L = safeBufferExports.Buffer, K = requireStreamCipher(), J = requireCipherBase(), W = requireAes(), V = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Ce, it, at) {
    J.call(this), this._cache = new re(), this._cipher = new W.AES(it), this._prev = L.from(at), this._mode = Ce, this._autopadding = !0;
  }
  ne(ie, J), ie.prototype._update = function(Ce) {
    this._cache.add(Ce);
    for (var it, at, lt = []; it = this._cache.get(); )
      at = this._mode.encrypt(this, it), lt.push(at);
    return L.concat(lt);
  };
  var oe = L.alloc(16, 16);
  ie.prototype._final = function() {
    var Ce = this._cache.flush();
    if (this._autopadding)
      return Ce = this._mode.encrypt(this, Ce), this._cipher.scrub(), Ce;
    if (!Ce.equals(oe))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Ce) {
    return this._autopadding = !!Ce, this;
  };
  function re() {
    this.cache = L.allocUnsafe(0);
  }
  re.prototype.add = function(Ce) {
    this.cache = L.concat([this.cache, Ce]);
  }, re.prototype.get = function() {
    if (this.cache.length > 15) {
      var Ce = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Ce;
    }
    return null;
  }, re.prototype.flush = function() {
    for (var Ce = 16 - this.cache.length, it = L.allocUnsafe(Ce), at = -1; ++at < Ce; )
      it.writeUInt8(Ce, at);
    return L.concat([this.cache, it]);
  };
  function ce(Ce, it, at) {
    var lt = A[Ce.toLowerCase()];
    if (!lt) throw new TypeError("invalid suite type");
    if (typeof it == "string" && (it = L.from(it)), it.length !== lt.key / 8) throw new TypeError("invalid key length " + it.length);
    if (typeof at == "string" && (at = L.from(at)), lt.mode !== "GCM" && at.length !== lt.iv) throw new TypeError("invalid iv length " + at.length);
    return lt.type === "stream" ? new K(lt.module, it, at) : lt.type === "auth" ? new B(lt.module, it, at) : new ie(lt.module, it, at);
  }
  function ke(Ce, it) {
    var at = A[Ce.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var lt = V(it, !1, at.key, at.iv);
    return ce(Ce, lt.key, lt.iv);
  }
  return encrypter.createCipheriv = ce, encrypter.createCipher = ke, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var A = requireAuthCipher(), B = safeBufferExports.Buffer, L = requireModes$1(), K = requireStreamCipher(), J = requireCipherBase(), W = requireAes(), V = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Ce, it, at) {
    J.call(this), this._cache = new oe(), this._last = void 0, this._cipher = new W.AES(it), this._prev = B.from(at), this._mode = Ce, this._autopadding = !0;
  }
  ne(ie, J), ie.prototype._update = function(Ce) {
    this._cache.add(Ce);
    for (var it, at, lt = []; it = this._cache.get(this._autopadding); )
      at = this._mode.decrypt(this, it), lt.push(at);
    return B.concat(lt);
  }, ie.prototype._final = function() {
    var Ce = this._cache.flush();
    if (this._autopadding)
      return re(this._mode.decrypt(this, Ce));
    if (Ce)
      throw new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Ce) {
    return this._autopadding = !!Ce, this;
  };
  function oe() {
    this.cache = B.allocUnsafe(0);
  }
  oe.prototype.add = function(Ce) {
    this.cache = B.concat([this.cache, Ce]);
  }, oe.prototype.get = function(Ce) {
    var it;
    if (Ce) {
      if (this.cache.length > 16)
        return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    } else if (this.cache.length >= 16)
      return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    return null;
  }, oe.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function re(Ce) {
    var it = Ce[15];
    if (it < 1 || it > 16)
      throw new Error("unable to decrypt data");
    for (var at = -1; ++at < it; )
      if (Ce[at + (16 - it)] !== it)
        throw new Error("unable to decrypt data");
    if (it !== 16)
      return Ce.slice(0, 16 - it);
  }
  function ce(Ce, it, at) {
    var lt = L[Ce.toLowerCase()];
    if (!lt) throw new TypeError("invalid suite type");
    if (typeof at == "string" && (at = B.from(at)), lt.mode !== "GCM" && at.length !== lt.iv) throw new TypeError("invalid iv length " + at.length);
    if (typeof it == "string" && (it = B.from(it)), it.length !== lt.key / 8) throw new TypeError("invalid key length " + it.length);
    return lt.type === "stream" ? new K(lt.module, it, at, !0) : lt.type === "auth" ? new A(lt.module, it, at, !0) : new ie(lt.module, it, at);
  }
  function ke(Ce, it) {
    var at = L[Ce.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var lt = V(it, !1, at.key, at.iv);
    return ce(Ce, lt.key, lt.iv);
  }
  return decrypter.createDecipher = ke, decrypter.createDecipheriv = ce, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var A = requireEncrypter(), B = requireDecrypter(), L = require$$2;
  function K() {
    return Object.keys(L);
  }
  return browser$5.createCipher = browser$5.Cipher = A.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = A.createCipheriv, browser$5.createDecipher = browser$5.Decipher = B.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = B.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = K, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(A) {
    A["des-ecb"] = {
      key: 8,
      iv: 0
    }, A["des-cbc"] = A.des = {
      key: 8,
      iv: 8
    }, A["des-ede3-cbc"] = A.des3 = {
      key: 24,
      iv: 8
    }, A["des-ede3"] = {
      key: 24,
      iv: 0
    }, A["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, A["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var A = requireBrowserifyDes(), B = requireBrowser$6(), L = requireModes$1(), K = requireModes(), J = requireEvp_bytestokey();
  function W(re, ce) {
    re = re.toLowerCase();
    var ke, Ce;
    if (L[re])
      ke = L[re].key, Ce = L[re].iv;
    else if (K[re])
      ke = K[re].key * 8, Ce = K[re].iv;
    else
      throw new TypeError("invalid suite type");
    var it = J(ce, !1, ke, Ce);
    return ne(re, it.key, it.iv);
  }
  function V(re, ce) {
    re = re.toLowerCase();
    var ke, Ce;
    if (L[re])
      ke = L[re].key, Ce = L[re].iv;
    else if (K[re])
      ke = K[re].key * 8, Ce = K[re].iv;
    else
      throw new TypeError("invalid suite type");
    var it = J(ce, !1, ke, Ce);
    return ie(re, it.key, it.iv);
  }
  function ne(re, ce, ke) {
    if (re = re.toLowerCase(), L[re]) return B.createCipheriv(re, ce, ke);
    if (K[re]) return new A({ key: ce, iv: ke, mode: re });
    throw new TypeError("invalid suite type");
  }
  function ie(re, ce, ke) {
    if (re = re.toLowerCase(), L[re]) return B.createDecipheriv(re, ce, ke);
    if (K[re]) return new A({ key: ce, iv: ke, mode: re, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function oe() {
    return Object.keys(K).concat(B.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = W, browser$6.createCipheriv = browser$6.Cipheriv = ne, browser$6.createDecipher = browser$6.Decipher = V, browser$6.createDecipheriv = browser$6.Decipheriv = ie, browser$6.listCiphers = browser$6.getCiphers = oe, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(A) {
    (function(B, L) {
      function K(wt, Oe) {
        if (!wt) throw new Error(Oe || "Assertion failed");
      }
      function J(wt, Oe) {
        wt.super_ = Oe;
        var rt = function() {
        };
        rt.prototype = Oe.prototype, wt.prototype = new rt(), wt.prototype.constructor = wt;
      }
      function W(wt, Oe, rt) {
        if (W.isBN(wt))
          return wt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, wt !== null && ((Oe === "le" || Oe === "be") && (rt = Oe, Oe = 10), this._init(wt || 0, Oe || 10, rt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var V;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? V = window.Buffer : V = require$$0$1.Buffer;
      } catch {
      }
      W.isBN = function(Oe) {
        return Oe instanceof W ? !0 : Oe !== null && typeof Oe == "object" && Oe.constructor.wordSize === W.wordSize && Array.isArray(Oe.words);
      }, W.max = function(Oe, rt) {
        return Oe.cmp(rt) > 0 ? Oe : rt;
      }, W.min = function(Oe, rt) {
        return Oe.cmp(rt) < 0 ? Oe : rt;
      }, W.prototype._init = function(Oe, rt, pe) {
        if (typeof Oe == "number")
          return this._initNumber(Oe, rt, pe);
        if (typeof Oe == "object")
          return this._initArray(Oe, rt, pe);
        rt === "hex" && (rt = 16), K(rt === (rt | 0) && rt >= 2 && rt <= 36), Oe = Oe.toString().replace(/\s+/g, "");
        var nt = 0;
        Oe[0] === "-" && (nt++, this.negative = 1), nt < Oe.length && (rt === 16 ? this._parseHex(Oe, nt, pe) : (this._parseBase(Oe, rt, nt), pe === "le" && this._initArray(this.toArray(), rt, pe)));
      }, W.prototype._initNumber = function(Oe, rt, pe) {
        Oe < 0 && (this.negative = 1, Oe = -Oe), Oe < 67108864 ? (this.words = [Oe & 67108863], this.length = 1) : Oe < 4503599627370496 ? (this.words = [
          Oe & 67108863,
          Oe / 67108864 & 67108863
        ], this.length = 2) : (K(Oe < 9007199254740992), this.words = [
          Oe & 67108863,
          Oe / 67108864 & 67108863,
          1
        ], this.length = 3), pe === "le" && this._initArray(this.toArray(), rt, pe);
      }, W.prototype._initArray = function(Oe, rt, pe) {
        if (K(typeof Oe.length == "number"), Oe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Oe.length / 3), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var ot, st, ut = 0;
        if (pe === "be")
          for (nt = Oe.length - 1, ot = 0; nt >= 0; nt -= 3)
            st = Oe[nt] | Oe[nt - 1] << 8 | Oe[nt - 2] << 16, this.words[ot] |= st << ut & 67108863, this.words[ot + 1] = st >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ot++);
        else if (pe === "le")
          for (nt = 0, ot = 0; nt < Oe.length; nt += 3)
            st = Oe[nt] | Oe[nt + 1] << 8 | Oe[nt + 2] << 16, this.words[ot] |= st << ut & 67108863, this.words[ot + 1] = st >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ot++);
        return this.strip();
      };
      function ne(wt, Oe) {
        var rt = wt.charCodeAt(Oe);
        return rt >= 65 && rt <= 70 ? rt - 55 : rt >= 97 && rt <= 102 ? rt - 87 : rt - 48 & 15;
      }
      function ie(wt, Oe, rt) {
        var pe = ne(wt, rt);
        return rt - 1 >= Oe && (pe |= ne(wt, rt - 1) << 4), pe;
      }
      W.prototype._parseHex = function(Oe, rt, pe) {
        this.length = Math.ceil((Oe.length - rt) / 6), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var ot = 0, st = 0, ut;
        if (pe === "be")
          for (nt = Oe.length - 1; nt >= rt; nt -= 2)
            ut = ie(Oe, rt, nt) << ot, this.words[st] |= ut & 67108863, ot >= 18 ? (ot -= 18, st += 1, this.words[st] |= ut >>> 26) : ot += 8;
        else {
          var pt = Oe.length - rt;
          for (nt = pt % 2 === 0 ? rt + 1 : rt; nt < Oe.length; nt += 2)
            ut = ie(Oe, rt, nt) << ot, this.words[st] |= ut & 67108863, ot >= 18 ? (ot -= 18, st += 1, this.words[st] |= ut >>> 26) : ot += 8;
        }
        this.strip();
      };
      function oe(wt, Oe, rt, pe) {
        for (var nt = 0, ot = Math.min(wt.length, rt), st = Oe; st < ot; st++) {
          var ut = wt.charCodeAt(st) - 48;
          nt *= pe, ut >= 49 ? nt += ut - 49 + 10 : ut >= 17 ? nt += ut - 17 + 10 : nt += ut;
        }
        return nt;
      }
      W.prototype._parseBase = function(Oe, rt, pe) {
        this.words = [0], this.length = 1;
        for (var nt = 0, ot = 1; ot <= 67108863; ot *= rt)
          nt++;
        nt--, ot = ot / rt | 0;
        for (var st = Oe.length - pe, ut = st % nt, pt = Math.min(st, st - ut) + pe, ft = 0, yt = pe; yt < pt; yt += nt)
          ft = oe(Oe, yt, yt + nt, rt), this.imuln(ot), this.words[0] + ft < 67108864 ? this.words[0] += ft : this._iaddn(ft);
        if (ut !== 0) {
          var ct = 1;
          for (ft = oe(Oe, yt, Oe.length, rt), yt = 0; yt < ut; yt++)
            ct *= rt;
          this.imuln(ct), this.words[0] + ft < 67108864 ? this.words[0] += ft : this._iaddn(ft);
        }
        this.strip();
      }, W.prototype.copy = function(Oe) {
        Oe.words = new Array(this.length);
        for (var rt = 0; rt < this.length; rt++)
          Oe.words[rt] = this.words[rt];
        Oe.length = this.length, Oe.negative = this.negative, Oe.red = this.red;
      }, W.prototype.clone = function() {
        var Oe = new W(null);
        return this.copy(Oe), Oe;
      }, W.prototype._expand = function(Oe) {
        for (; this.length < Oe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, W.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var re = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], ce = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ke = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(Oe, rt) {
        Oe = Oe || 10, rt = rt | 0 || 1;
        var pe;
        if (Oe === 16 || Oe === "hex") {
          pe = "";
          for (var nt = 0, ot = 0, st = 0; st < this.length; st++) {
            var ut = this.words[st], pt = ((ut << nt | ot) & 16777215).toString(16);
            ot = ut >>> 24 - nt & 16777215, ot !== 0 || st !== this.length - 1 ? pe = re[6 - pt.length] + pt + pe : pe = pt + pe, nt += 2, nt >= 26 && (nt -= 26, st--);
          }
          for (ot !== 0 && (pe = ot.toString(16) + pe); pe.length % rt !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        if (Oe === (Oe | 0) && Oe >= 2 && Oe <= 36) {
          var ft = ce[Oe], yt = ke[Oe];
          pe = "";
          var ct = this.clone();
          for (ct.negative = 0; !ct.isZero(); ) {
            var Et = ct.modn(yt).toString(Oe);
            ct = ct.idivn(yt), ct.isZero() ? pe = Et + pe : pe = re[ft - Et.length] + Et + pe;
          }
          for (this.isZero() && (pe = "0" + pe); pe.length % rt !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var Oe = this.words[0];
        return this.length === 2 ? Oe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Oe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Oe : Oe;
      }, W.prototype.toJSON = function() {
        return this.toString(16);
      }, W.prototype.toBuffer = function(Oe, rt) {
        return K(typeof V < "u"), this.toArrayLike(V, Oe, rt);
      }, W.prototype.toArray = function(Oe, rt) {
        return this.toArrayLike(Array, Oe, rt);
      }, W.prototype.toArrayLike = function(Oe, rt, pe) {
        var nt = this.byteLength(), ot = pe || Math.max(1, nt);
        K(nt <= ot, "byte array longer than desired length"), K(ot > 0, "Requested array length <= 0"), this.strip();
        var st = rt === "le", ut = new Oe(ot), pt, ft, yt = this.clone();
        if (st) {
          for (ft = 0; !yt.isZero(); ft++)
            pt = yt.andln(255), yt.iushrn(8), ut[ft] = pt;
          for (; ft < ot; ft++)
            ut[ft] = 0;
        } else {
          for (ft = 0; ft < ot - nt; ft++)
            ut[ft] = 0;
          for (ft = 0; !yt.isZero(); ft++)
            pt = yt.andln(255), yt.iushrn(8), ut[ot - ft - 1] = pt;
        }
        return ut;
      }, Math.clz32 ? W.prototype._countBits = function(Oe) {
        return 32 - Math.clz32(Oe);
      } : W.prototype._countBits = function(Oe) {
        var rt = Oe, pe = 0;
        return rt >= 4096 && (pe += 13, rt >>>= 13), rt >= 64 && (pe += 7, rt >>>= 7), rt >= 8 && (pe += 4, rt >>>= 4), rt >= 2 && (pe += 2, rt >>>= 2), pe + rt;
      }, W.prototype._zeroBits = function(Oe) {
        if (Oe === 0) return 26;
        var rt = Oe, pe = 0;
        return rt & 8191 || (pe += 13, rt >>>= 13), rt & 127 || (pe += 7, rt >>>= 7), rt & 15 || (pe += 4, rt >>>= 4), rt & 3 || (pe += 2, rt >>>= 2), rt & 1 || pe++, pe;
      }, W.prototype.bitLength = function() {
        var Oe = this.words[this.length - 1], rt = this._countBits(Oe);
        return (this.length - 1) * 26 + rt;
      };
      function Ce(wt) {
        for (var Oe = new Array(wt.bitLength()), rt = 0; rt < Oe.length; rt++) {
          var pe = rt / 26 | 0, nt = rt % 26;
          Oe[rt] = (wt.words[pe] & 1 << nt) >>> nt;
        }
        return Oe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Oe = 0, rt = 0; rt < this.length; rt++) {
          var pe = this._zeroBits(this.words[rt]);
          if (Oe += pe, pe !== 26) break;
        }
        return Oe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(Oe) {
        return this.negative !== 0 ? this.abs().inotn(Oe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(Oe) {
        return this.testn(Oe - 1) ? this.notn(Oe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(Oe) {
        for (; this.length < Oe.length; )
          this.words[this.length++] = 0;
        for (var rt = 0; rt < Oe.length; rt++)
          this.words[rt] = this.words[rt] | Oe.words[rt];
        return this.strip();
      }, W.prototype.ior = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuor(Oe);
      }, W.prototype.or = function(Oe) {
        return this.length > Oe.length ? this.clone().ior(Oe) : Oe.clone().ior(this);
      }, W.prototype.uor = function(Oe) {
        return this.length > Oe.length ? this.clone().iuor(Oe) : Oe.clone().iuor(this);
      }, W.prototype.iuand = function(Oe) {
        var rt;
        this.length > Oe.length ? rt = Oe : rt = this;
        for (var pe = 0; pe < rt.length; pe++)
          this.words[pe] = this.words[pe] & Oe.words[pe];
        return this.length = rt.length, this.strip();
      }, W.prototype.iand = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuand(Oe);
      }, W.prototype.and = function(Oe) {
        return this.length > Oe.length ? this.clone().iand(Oe) : Oe.clone().iand(this);
      }, W.prototype.uand = function(Oe) {
        return this.length > Oe.length ? this.clone().iuand(Oe) : Oe.clone().iuand(this);
      }, W.prototype.iuxor = function(Oe) {
        var rt, pe;
        this.length > Oe.length ? (rt = this, pe = Oe) : (rt = Oe, pe = this);
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = rt.words[nt] ^ pe.words[nt];
        if (this !== rt)
          for (; nt < rt.length; nt++)
            this.words[nt] = rt.words[nt];
        return this.length = rt.length, this.strip();
      }, W.prototype.ixor = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuxor(Oe);
      }, W.prototype.xor = function(Oe) {
        return this.length > Oe.length ? this.clone().ixor(Oe) : Oe.clone().ixor(this);
      }, W.prototype.uxor = function(Oe) {
        return this.length > Oe.length ? this.clone().iuxor(Oe) : Oe.clone().iuxor(this);
      }, W.prototype.inotn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Math.ceil(Oe / 26) | 0, pe = Oe % 26;
        this._expand(rt), pe > 0 && rt--;
        for (var nt = 0; nt < rt; nt++)
          this.words[nt] = ~this.words[nt] & 67108863;
        return pe > 0 && (this.words[nt] = ~this.words[nt] & 67108863 >> 26 - pe), this.strip();
      }, W.prototype.notn = function(Oe) {
        return this.clone().inotn(Oe);
      }, W.prototype.setn = function(Oe, rt) {
        K(typeof Oe == "number" && Oe >= 0);
        var pe = Oe / 26 | 0, nt = Oe % 26;
        return this._expand(pe + 1), rt ? this.words[pe] = this.words[pe] | 1 << nt : this.words[pe] = this.words[pe] & ~(1 << nt), this.strip();
      }, W.prototype.iadd = function(Oe) {
        var rt;
        if (this.negative !== 0 && Oe.negative === 0)
          return this.negative = 0, rt = this.isub(Oe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Oe.negative !== 0)
          return Oe.negative = 0, rt = this.isub(Oe), Oe.negative = 1, rt._normSign();
        var pe, nt;
        this.length > Oe.length ? (pe = this, nt = Oe) : (pe = Oe, nt = this);
        for (var ot = 0, st = 0; st < nt.length; st++)
          rt = (pe.words[st] | 0) + (nt.words[st] | 0) + ot, this.words[st] = rt & 67108863, ot = rt >>> 26;
        for (; ot !== 0 && st < pe.length; st++)
          rt = (pe.words[st] | 0) + ot, this.words[st] = rt & 67108863, ot = rt >>> 26;
        if (this.length = pe.length, ot !== 0)
          this.words[this.length] = ot, this.length++;
        else if (pe !== this)
          for (; st < pe.length; st++)
            this.words[st] = pe.words[st];
        return this;
      }, W.prototype.add = function(Oe) {
        var rt;
        return Oe.negative !== 0 && this.negative === 0 ? (Oe.negative = 0, rt = this.sub(Oe), Oe.negative ^= 1, rt) : Oe.negative === 0 && this.negative !== 0 ? (this.negative = 0, rt = Oe.sub(this), this.negative = 1, rt) : this.length > Oe.length ? this.clone().iadd(Oe) : Oe.clone().iadd(this);
      }, W.prototype.isub = function(Oe) {
        if (Oe.negative !== 0) {
          Oe.negative = 0;
          var rt = this.iadd(Oe);
          return Oe.negative = 1, rt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Oe), this.negative = 1, this._normSign();
        var pe = this.cmp(Oe);
        if (pe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var nt, ot;
        pe > 0 ? (nt = this, ot = Oe) : (nt = Oe, ot = this);
        for (var st = 0, ut = 0; ut < ot.length; ut++)
          rt = (nt.words[ut] | 0) - (ot.words[ut] | 0) + st, st = rt >> 26, this.words[ut] = rt & 67108863;
        for (; st !== 0 && ut < nt.length; ut++)
          rt = (nt.words[ut] | 0) + st, st = rt >> 26, this.words[ut] = rt & 67108863;
        if (st === 0 && ut < nt.length && nt !== this)
          for (; ut < nt.length; ut++)
            this.words[ut] = nt.words[ut];
        return this.length = Math.max(this.length, ut), nt !== this && (this.negative = 1), this.strip();
      }, W.prototype.sub = function(Oe) {
        return this.clone().isub(Oe);
      };
      function it(wt, Oe, rt) {
        rt.negative = Oe.negative ^ wt.negative;
        var pe = wt.length + Oe.length | 0;
        rt.length = pe, pe = pe - 1 | 0;
        var nt = wt.words[0] | 0, ot = Oe.words[0] | 0, st = nt * ot, ut = st & 67108863, pt = st / 67108864 | 0;
        rt.words[0] = ut;
        for (var ft = 1; ft < pe; ft++) {
          for (var yt = pt >>> 26, ct = pt & 67108863, Et = Math.min(ft, Oe.length - 1), Nt = Math.max(0, ft - wt.length + 1); Nt <= Et; Nt++) {
            var jt = ft - Nt | 0;
            nt = wt.words[jt] | 0, ot = Oe.words[Nt] | 0, st = nt * ot + ct, yt += st / 67108864 | 0, ct = st & 67108863;
          }
          rt.words[ft] = ct | 0, pt = yt | 0;
        }
        return pt !== 0 ? rt.words[ft] = pt | 0 : rt.length--, rt.strip();
      }
      var at = function(Oe, rt, pe) {
        var nt = Oe.words, ot = rt.words, st = pe.words, ut = 0, pt, ft, yt, ct = nt[0] | 0, Et = ct & 8191, Nt = ct >>> 13, jt = nt[1] | 0, Ot = jt & 8191, Bt = jt >>> 13, Tt = nt[2] | 0, Ut = Tt & 8191, Gt = Tt >>> 13, It = nt[3] | 0, Mt = It & 8191, Kt = It >>> 13, Qt = nt[4] | 0, rr = Qt & 8191, ar = Qt >>> 13, ur = nt[5] | 0, hr = ur & 8191, Yt = ur >>> 13, Rr = nt[6] | 0, lr = Rr & 8191, $r = Rr >>> 13, Br = nt[7] | 0, dr = Br & 8191, Sr = Br >>> 13, Mr = nt[8] | 0, br = Mr & 8191, Ir = Mr >>> 13, Or = nt[9] | 0, Rt = Or & 8191, gt = Or >>> 13, St = ot[0] | 0, Ct = St & 8191, Wt = St >>> 13, zt = ot[1] | 0, Vt = zt & 8191, yr = zt >>> 13, xr = ot[2] | 0, cr = xr & 8191, Ar = xr >>> 13, gr = ot[3] | 0, _r = gr & 8191, kr = gr >>> 13, Cr = ot[4] | 0, Ft = Cr & 8191, kt = Cr >>> 13, Dt = ot[5] | 0, Ht = Dt & 8191, Xt = Dt >>> 13, Zt = ot[6] | 0, tr = Zt & 8191, nr = Zt >>> 13, fr = ot[7] | 0, ir = fr & 8191, pr = fr >>> 13, wr = ot[8] | 0, sr = wr & 8191, Lt = wr >>> 13, Jt = ot[9] | 0, er = Jt & 8191, or = Jt >>> 13;
        pe.negative = Oe.negative ^ rt.negative, pe.length = 19, pt = Math.imul(Et, Ct), ft = Math.imul(Et, Wt), ft = ft + Math.imul(Nt, Ct) | 0, yt = Math.imul(Nt, Wt);
        var vr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, pt = Math.imul(Ot, Ct), ft = Math.imul(Ot, Wt), ft = ft + Math.imul(Bt, Ct) | 0, yt = Math.imul(Bt, Wt), pt = pt + Math.imul(Et, Vt) | 0, ft = ft + Math.imul(Et, yr) | 0, ft = ft + Math.imul(Nt, Vt) | 0, yt = yt + Math.imul(Nt, yr) | 0;
        var Er = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, pt = Math.imul(Ut, Ct), ft = Math.imul(Ut, Wt), ft = ft + Math.imul(Gt, Ct) | 0, yt = Math.imul(Gt, Wt), pt = pt + Math.imul(Ot, Vt) | 0, ft = ft + Math.imul(Ot, yr) | 0, ft = ft + Math.imul(Bt, Vt) | 0, yt = yt + Math.imul(Bt, yr) | 0, pt = pt + Math.imul(Et, cr) | 0, ft = ft + Math.imul(Et, Ar) | 0, ft = ft + Math.imul(Nt, cr) | 0, yt = yt + Math.imul(Nt, Ar) | 0;
        var Tr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, pt = Math.imul(Mt, Ct), ft = Math.imul(Mt, Wt), ft = ft + Math.imul(Kt, Ct) | 0, yt = Math.imul(Kt, Wt), pt = pt + Math.imul(Ut, Vt) | 0, ft = ft + Math.imul(Ut, yr) | 0, ft = ft + Math.imul(Gt, Vt) | 0, yt = yt + Math.imul(Gt, yr) | 0, pt = pt + Math.imul(Ot, cr) | 0, ft = ft + Math.imul(Ot, Ar) | 0, ft = ft + Math.imul(Bt, cr) | 0, yt = yt + Math.imul(Bt, Ar) | 0, pt = pt + Math.imul(Et, _r) | 0, ft = ft + Math.imul(Et, kr) | 0, ft = ft + Math.imul(Nt, _r) | 0, yt = yt + Math.imul(Nt, kr) | 0;
        var Pr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, pt = Math.imul(rr, Ct), ft = Math.imul(rr, Wt), ft = ft + Math.imul(ar, Ct) | 0, yt = Math.imul(ar, Wt), pt = pt + Math.imul(Mt, Vt) | 0, ft = ft + Math.imul(Mt, yr) | 0, ft = ft + Math.imul(Kt, Vt) | 0, yt = yt + Math.imul(Kt, yr) | 0, pt = pt + Math.imul(Ut, cr) | 0, ft = ft + Math.imul(Ut, Ar) | 0, ft = ft + Math.imul(Gt, cr) | 0, yt = yt + Math.imul(Gt, Ar) | 0, pt = pt + Math.imul(Ot, _r) | 0, ft = ft + Math.imul(Ot, kr) | 0, ft = ft + Math.imul(Bt, _r) | 0, yt = yt + Math.imul(Bt, kr) | 0, pt = pt + Math.imul(Et, Ft) | 0, ft = ft + Math.imul(Et, kt) | 0, ft = ft + Math.imul(Nt, Ft) | 0, yt = yt + Math.imul(Nt, kt) | 0;
        var Nr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, pt = Math.imul(hr, Ct), ft = Math.imul(hr, Wt), ft = ft + Math.imul(Yt, Ct) | 0, yt = Math.imul(Yt, Wt), pt = pt + Math.imul(rr, Vt) | 0, ft = ft + Math.imul(rr, yr) | 0, ft = ft + Math.imul(ar, Vt) | 0, yt = yt + Math.imul(ar, yr) | 0, pt = pt + Math.imul(Mt, cr) | 0, ft = ft + Math.imul(Mt, Ar) | 0, ft = ft + Math.imul(Kt, cr) | 0, yt = yt + Math.imul(Kt, Ar) | 0, pt = pt + Math.imul(Ut, _r) | 0, ft = ft + Math.imul(Ut, kr) | 0, ft = ft + Math.imul(Gt, _r) | 0, yt = yt + Math.imul(Gt, kr) | 0, pt = pt + Math.imul(Ot, Ft) | 0, ft = ft + Math.imul(Ot, kt) | 0, ft = ft + Math.imul(Bt, Ft) | 0, yt = yt + Math.imul(Bt, kt) | 0, pt = pt + Math.imul(Et, Ht) | 0, ft = ft + Math.imul(Et, Xt) | 0, ft = ft + Math.imul(Nt, Ht) | 0, yt = yt + Math.imul(Nt, Xt) | 0;
        var qr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(lr, Ct), ft = Math.imul(lr, Wt), ft = ft + Math.imul($r, Ct) | 0, yt = Math.imul($r, Wt), pt = pt + Math.imul(hr, Vt) | 0, ft = ft + Math.imul(hr, yr) | 0, ft = ft + Math.imul(Yt, Vt) | 0, yt = yt + Math.imul(Yt, yr) | 0, pt = pt + Math.imul(rr, cr) | 0, ft = ft + Math.imul(rr, Ar) | 0, ft = ft + Math.imul(ar, cr) | 0, yt = yt + Math.imul(ar, Ar) | 0, pt = pt + Math.imul(Mt, _r) | 0, ft = ft + Math.imul(Mt, kr) | 0, ft = ft + Math.imul(Kt, _r) | 0, yt = yt + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(Ut, Ft) | 0, ft = ft + Math.imul(Ut, kt) | 0, ft = ft + Math.imul(Gt, Ft) | 0, yt = yt + Math.imul(Gt, kt) | 0, pt = pt + Math.imul(Ot, Ht) | 0, ft = ft + Math.imul(Ot, Xt) | 0, ft = ft + Math.imul(Bt, Ht) | 0, yt = yt + Math.imul(Bt, Xt) | 0, pt = pt + Math.imul(Et, tr) | 0, ft = ft + Math.imul(Et, nr) | 0, ft = ft + Math.imul(Nt, tr) | 0, yt = yt + Math.imul(Nt, nr) | 0;
        var Fr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(dr, Ct), ft = Math.imul(dr, Wt), ft = ft + Math.imul(Sr, Ct) | 0, yt = Math.imul(Sr, Wt), pt = pt + Math.imul(lr, Vt) | 0, ft = ft + Math.imul(lr, yr) | 0, ft = ft + Math.imul($r, Vt) | 0, yt = yt + Math.imul($r, yr) | 0, pt = pt + Math.imul(hr, cr) | 0, ft = ft + Math.imul(hr, Ar) | 0, ft = ft + Math.imul(Yt, cr) | 0, yt = yt + Math.imul(Yt, Ar) | 0, pt = pt + Math.imul(rr, _r) | 0, ft = ft + Math.imul(rr, kr) | 0, ft = ft + Math.imul(ar, _r) | 0, yt = yt + Math.imul(ar, kr) | 0, pt = pt + Math.imul(Mt, Ft) | 0, ft = ft + Math.imul(Mt, kt) | 0, ft = ft + Math.imul(Kt, Ft) | 0, yt = yt + Math.imul(Kt, kt) | 0, pt = pt + Math.imul(Ut, Ht) | 0, ft = ft + Math.imul(Ut, Xt) | 0, ft = ft + Math.imul(Gt, Ht) | 0, yt = yt + Math.imul(Gt, Xt) | 0, pt = pt + Math.imul(Ot, tr) | 0, ft = ft + Math.imul(Ot, nr) | 0, ft = ft + Math.imul(Bt, tr) | 0, yt = yt + Math.imul(Bt, nr) | 0, pt = pt + Math.imul(Et, ir) | 0, ft = ft + Math.imul(Et, pr) | 0, ft = ft + Math.imul(Nt, ir) | 0, yt = yt + Math.imul(Nt, pr) | 0;
        var Ur = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(br, Ct), ft = Math.imul(br, Wt), ft = ft + Math.imul(Ir, Ct) | 0, yt = Math.imul(Ir, Wt), pt = pt + Math.imul(dr, Vt) | 0, ft = ft + Math.imul(dr, yr) | 0, ft = ft + Math.imul(Sr, Vt) | 0, yt = yt + Math.imul(Sr, yr) | 0, pt = pt + Math.imul(lr, cr) | 0, ft = ft + Math.imul(lr, Ar) | 0, ft = ft + Math.imul($r, cr) | 0, yt = yt + Math.imul($r, Ar) | 0, pt = pt + Math.imul(hr, _r) | 0, ft = ft + Math.imul(hr, kr) | 0, ft = ft + Math.imul(Yt, _r) | 0, yt = yt + Math.imul(Yt, kr) | 0, pt = pt + Math.imul(rr, Ft) | 0, ft = ft + Math.imul(rr, kt) | 0, ft = ft + Math.imul(ar, Ft) | 0, yt = yt + Math.imul(ar, kt) | 0, pt = pt + Math.imul(Mt, Ht) | 0, ft = ft + Math.imul(Mt, Xt) | 0, ft = ft + Math.imul(Kt, Ht) | 0, yt = yt + Math.imul(Kt, Xt) | 0, pt = pt + Math.imul(Ut, tr) | 0, ft = ft + Math.imul(Ut, nr) | 0, ft = ft + Math.imul(Gt, tr) | 0, yt = yt + Math.imul(Gt, nr) | 0, pt = pt + Math.imul(Ot, ir) | 0, ft = ft + Math.imul(Ot, pr) | 0, ft = ft + Math.imul(Bt, ir) | 0, yt = yt + Math.imul(Bt, pr) | 0, pt = pt + Math.imul(Et, sr) | 0, ft = ft + Math.imul(Et, Lt) | 0, ft = ft + Math.imul(Nt, sr) | 0, yt = yt + Math.imul(Nt, Lt) | 0;
        var jr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(Rt, Ct), ft = Math.imul(Rt, Wt), ft = ft + Math.imul(gt, Ct) | 0, yt = Math.imul(gt, Wt), pt = pt + Math.imul(br, Vt) | 0, ft = ft + Math.imul(br, yr) | 0, ft = ft + Math.imul(Ir, Vt) | 0, yt = yt + Math.imul(Ir, yr) | 0, pt = pt + Math.imul(dr, cr) | 0, ft = ft + Math.imul(dr, Ar) | 0, ft = ft + Math.imul(Sr, cr) | 0, yt = yt + Math.imul(Sr, Ar) | 0, pt = pt + Math.imul(lr, _r) | 0, ft = ft + Math.imul(lr, kr) | 0, ft = ft + Math.imul($r, _r) | 0, yt = yt + Math.imul($r, kr) | 0, pt = pt + Math.imul(hr, Ft) | 0, ft = ft + Math.imul(hr, kt) | 0, ft = ft + Math.imul(Yt, Ft) | 0, yt = yt + Math.imul(Yt, kt) | 0, pt = pt + Math.imul(rr, Ht) | 0, ft = ft + Math.imul(rr, Xt) | 0, ft = ft + Math.imul(ar, Ht) | 0, yt = yt + Math.imul(ar, Xt) | 0, pt = pt + Math.imul(Mt, tr) | 0, ft = ft + Math.imul(Mt, nr) | 0, ft = ft + Math.imul(Kt, tr) | 0, yt = yt + Math.imul(Kt, nr) | 0, pt = pt + Math.imul(Ut, ir) | 0, ft = ft + Math.imul(Ut, pr) | 0, ft = ft + Math.imul(Gt, ir) | 0, yt = yt + Math.imul(Gt, pr) | 0, pt = pt + Math.imul(Ot, sr) | 0, ft = ft + Math.imul(Ot, Lt) | 0, ft = ft + Math.imul(Bt, sr) | 0, yt = yt + Math.imul(Bt, Lt) | 0, pt = pt + Math.imul(Et, er) | 0, ft = ft + Math.imul(Et, or) | 0, ft = ft + Math.imul(Nt, er) | 0, yt = yt + Math.imul(Nt, or) | 0;
        var Dr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, pt = Math.imul(Rt, Vt), ft = Math.imul(Rt, yr), ft = ft + Math.imul(gt, Vt) | 0, yt = Math.imul(gt, yr), pt = pt + Math.imul(br, cr) | 0, ft = ft + Math.imul(br, Ar) | 0, ft = ft + Math.imul(Ir, cr) | 0, yt = yt + Math.imul(Ir, Ar) | 0, pt = pt + Math.imul(dr, _r) | 0, ft = ft + Math.imul(dr, kr) | 0, ft = ft + Math.imul(Sr, _r) | 0, yt = yt + Math.imul(Sr, kr) | 0, pt = pt + Math.imul(lr, Ft) | 0, ft = ft + Math.imul(lr, kt) | 0, ft = ft + Math.imul($r, Ft) | 0, yt = yt + Math.imul($r, kt) | 0, pt = pt + Math.imul(hr, Ht) | 0, ft = ft + Math.imul(hr, Xt) | 0, ft = ft + Math.imul(Yt, Ht) | 0, yt = yt + Math.imul(Yt, Xt) | 0, pt = pt + Math.imul(rr, tr) | 0, ft = ft + Math.imul(rr, nr) | 0, ft = ft + Math.imul(ar, tr) | 0, yt = yt + Math.imul(ar, nr) | 0, pt = pt + Math.imul(Mt, ir) | 0, ft = ft + Math.imul(Mt, pr) | 0, ft = ft + Math.imul(Kt, ir) | 0, yt = yt + Math.imul(Kt, pr) | 0, pt = pt + Math.imul(Ut, sr) | 0, ft = ft + Math.imul(Ut, Lt) | 0, ft = ft + Math.imul(Gt, sr) | 0, yt = yt + Math.imul(Gt, Lt) | 0, pt = pt + Math.imul(Ot, er) | 0, ft = ft + Math.imul(Ot, or) | 0, ft = ft + Math.imul(Bt, er) | 0, yt = yt + Math.imul(Bt, or) | 0;
        var Lr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, pt = Math.imul(Rt, cr), ft = Math.imul(Rt, Ar), ft = ft + Math.imul(gt, cr) | 0, yt = Math.imul(gt, Ar), pt = pt + Math.imul(br, _r) | 0, ft = ft + Math.imul(br, kr) | 0, ft = ft + Math.imul(Ir, _r) | 0, yt = yt + Math.imul(Ir, kr) | 0, pt = pt + Math.imul(dr, Ft) | 0, ft = ft + Math.imul(dr, kt) | 0, ft = ft + Math.imul(Sr, Ft) | 0, yt = yt + Math.imul(Sr, kt) | 0, pt = pt + Math.imul(lr, Ht) | 0, ft = ft + Math.imul(lr, Xt) | 0, ft = ft + Math.imul($r, Ht) | 0, yt = yt + Math.imul($r, Xt) | 0, pt = pt + Math.imul(hr, tr) | 0, ft = ft + Math.imul(hr, nr) | 0, ft = ft + Math.imul(Yt, tr) | 0, yt = yt + Math.imul(Yt, nr) | 0, pt = pt + Math.imul(rr, ir) | 0, ft = ft + Math.imul(rr, pr) | 0, ft = ft + Math.imul(ar, ir) | 0, yt = yt + Math.imul(ar, pr) | 0, pt = pt + Math.imul(Mt, sr) | 0, ft = ft + Math.imul(Mt, Lt) | 0, ft = ft + Math.imul(Kt, sr) | 0, yt = yt + Math.imul(Kt, Lt) | 0, pt = pt + Math.imul(Ut, er) | 0, ft = ft + Math.imul(Ut, or) | 0, ft = ft + Math.imul(Gt, er) | 0, yt = yt + Math.imul(Gt, or) | 0;
        var Hr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, pt = Math.imul(Rt, _r), ft = Math.imul(Rt, kr), ft = ft + Math.imul(gt, _r) | 0, yt = Math.imul(gt, kr), pt = pt + Math.imul(br, Ft) | 0, ft = ft + Math.imul(br, kt) | 0, ft = ft + Math.imul(Ir, Ft) | 0, yt = yt + Math.imul(Ir, kt) | 0, pt = pt + Math.imul(dr, Ht) | 0, ft = ft + Math.imul(dr, Xt) | 0, ft = ft + Math.imul(Sr, Ht) | 0, yt = yt + Math.imul(Sr, Xt) | 0, pt = pt + Math.imul(lr, tr) | 0, ft = ft + Math.imul(lr, nr) | 0, ft = ft + Math.imul($r, tr) | 0, yt = yt + Math.imul($r, nr) | 0, pt = pt + Math.imul(hr, ir) | 0, ft = ft + Math.imul(hr, pr) | 0, ft = ft + Math.imul(Yt, ir) | 0, yt = yt + Math.imul(Yt, pr) | 0, pt = pt + Math.imul(rr, sr) | 0, ft = ft + Math.imul(rr, Lt) | 0, ft = ft + Math.imul(ar, sr) | 0, yt = yt + Math.imul(ar, Lt) | 0, pt = pt + Math.imul(Mt, er) | 0, ft = ft + Math.imul(Mt, or) | 0, ft = ft + Math.imul(Kt, er) | 0, yt = yt + Math.imul(Kt, or) | 0;
        var Wr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, pt = Math.imul(Rt, Ft), ft = Math.imul(Rt, kt), ft = ft + Math.imul(gt, Ft) | 0, yt = Math.imul(gt, kt), pt = pt + Math.imul(br, Ht) | 0, ft = ft + Math.imul(br, Xt) | 0, ft = ft + Math.imul(Ir, Ht) | 0, yt = yt + Math.imul(Ir, Xt) | 0, pt = pt + Math.imul(dr, tr) | 0, ft = ft + Math.imul(dr, nr) | 0, ft = ft + Math.imul(Sr, tr) | 0, yt = yt + Math.imul(Sr, nr) | 0, pt = pt + Math.imul(lr, ir) | 0, ft = ft + Math.imul(lr, pr) | 0, ft = ft + Math.imul($r, ir) | 0, yt = yt + Math.imul($r, pr) | 0, pt = pt + Math.imul(hr, sr) | 0, ft = ft + Math.imul(hr, Lt) | 0, ft = ft + Math.imul(Yt, sr) | 0, yt = yt + Math.imul(Yt, Lt) | 0, pt = pt + Math.imul(rr, er) | 0, ft = ft + Math.imul(rr, or) | 0, ft = ft + Math.imul(ar, er) | 0, yt = yt + Math.imul(ar, or) | 0;
        var Gr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(Rt, Ht), ft = Math.imul(Rt, Xt), ft = ft + Math.imul(gt, Ht) | 0, yt = Math.imul(gt, Xt), pt = pt + Math.imul(br, tr) | 0, ft = ft + Math.imul(br, nr) | 0, ft = ft + Math.imul(Ir, tr) | 0, yt = yt + Math.imul(Ir, nr) | 0, pt = pt + Math.imul(dr, ir) | 0, ft = ft + Math.imul(dr, pr) | 0, ft = ft + Math.imul(Sr, ir) | 0, yt = yt + Math.imul(Sr, pr) | 0, pt = pt + Math.imul(lr, sr) | 0, ft = ft + Math.imul(lr, Lt) | 0, ft = ft + Math.imul($r, sr) | 0, yt = yt + Math.imul($r, Lt) | 0, pt = pt + Math.imul(hr, er) | 0, ft = ft + Math.imul(hr, or) | 0, ft = ft + Math.imul(Yt, er) | 0, yt = yt + Math.imul(Yt, or) | 0;
        var zr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, pt = Math.imul(Rt, tr), ft = Math.imul(Rt, nr), ft = ft + Math.imul(gt, tr) | 0, yt = Math.imul(gt, nr), pt = pt + Math.imul(br, ir) | 0, ft = ft + Math.imul(br, pr) | 0, ft = ft + Math.imul(Ir, ir) | 0, yt = yt + Math.imul(Ir, pr) | 0, pt = pt + Math.imul(dr, sr) | 0, ft = ft + Math.imul(dr, Lt) | 0, ft = ft + Math.imul(Sr, sr) | 0, yt = yt + Math.imul(Sr, Lt) | 0, pt = pt + Math.imul(lr, er) | 0, ft = ft + Math.imul(lr, or) | 0, ft = ft + Math.imul($r, er) | 0, yt = yt + Math.imul($r, or) | 0;
        var Vr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(Rt, ir), ft = Math.imul(Rt, pr), ft = ft + Math.imul(gt, ir) | 0, yt = Math.imul(gt, pr), pt = pt + Math.imul(br, sr) | 0, ft = ft + Math.imul(br, Lt) | 0, ft = ft + Math.imul(Ir, sr) | 0, yt = yt + Math.imul(Ir, Lt) | 0, pt = pt + Math.imul(dr, er) | 0, ft = ft + Math.imul(dr, or) | 0, ft = ft + Math.imul(Sr, er) | 0, yt = yt + Math.imul(Sr, or) | 0;
        var Xr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, pt = Math.imul(Rt, sr), ft = Math.imul(Rt, Lt), ft = ft + Math.imul(gt, sr) | 0, yt = Math.imul(gt, Lt), pt = pt + Math.imul(br, er) | 0, ft = ft + Math.imul(br, or) | 0, ft = ft + Math.imul(Ir, er) | 0, yt = yt + Math.imul(Ir, or) | 0;
        var Yr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, pt = Math.imul(Rt, er), ft = Math.imul(Rt, or), ft = ft + Math.imul(gt, er) | 0, yt = Math.imul(gt, or);
        var Jr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        return ut = (yt + (ft >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, st[0] = vr, st[1] = Er, st[2] = Tr, st[3] = Pr, st[4] = Nr, st[5] = qr, st[6] = Fr, st[7] = Ur, st[8] = jr, st[9] = Dr, st[10] = Lr, st[11] = Hr, st[12] = Wr, st[13] = Gr, st[14] = zr, st[15] = Vr, st[16] = Xr, st[17] = Yr, st[18] = Jr, ut !== 0 && (st[19] = ut, pe.length++), pe;
      };
      Math.imul || (at = it);
      function lt(wt, Oe, rt) {
        rt.negative = Oe.negative ^ wt.negative, rt.length = wt.length + Oe.length;
        for (var pe = 0, nt = 0, ot = 0; ot < rt.length - 1; ot++) {
          var st = nt;
          nt = 0;
          for (var ut = pe & 67108863, pt = Math.min(ot, Oe.length - 1), ft = Math.max(0, ot - wt.length + 1); ft <= pt; ft++) {
            var yt = ot - ft, ct = wt.words[yt] | 0, Et = Oe.words[ft] | 0, Nt = ct * Et, jt = Nt & 67108863;
            st = st + (Nt / 67108864 | 0) | 0, jt = jt + ut | 0, ut = jt & 67108863, st = st + (jt >>> 26) | 0, nt += st >>> 26, st &= 67108863;
          }
          rt.words[ot] = ut, pe = st, st = nt;
        }
        return pe !== 0 ? rt.words[ot] = pe : rt.length--, rt.strip();
      }
      function ht(wt, Oe, rt) {
        var pe = new dt();
        return pe.mulp(wt, Oe, rt);
      }
      W.prototype.mulTo = function(Oe, rt) {
        var pe, nt = this.length + Oe.length;
        return this.length === 10 && Oe.length === 10 ? pe = at(this, Oe, rt) : nt < 63 ? pe = it(this, Oe, rt) : nt < 1024 ? pe = lt(this, Oe, rt) : pe = ht(this, Oe, rt), pe;
      };
      function dt(wt, Oe) {
        this.x = wt, this.y = Oe;
      }
      dt.prototype.makeRBT = function(Oe) {
        for (var rt = new Array(Oe), pe = W.prototype._countBits(Oe) - 1, nt = 0; nt < Oe; nt++)
          rt[nt] = this.revBin(nt, pe, Oe);
        return rt;
      }, dt.prototype.revBin = function(Oe, rt, pe) {
        if (Oe === 0 || Oe === pe - 1) return Oe;
        for (var nt = 0, ot = 0; ot < rt; ot++)
          nt |= (Oe & 1) << rt - ot - 1, Oe >>= 1;
        return nt;
      }, dt.prototype.permute = function(Oe, rt, pe, nt, ot, st) {
        for (var ut = 0; ut < st; ut++)
          nt[ut] = rt[Oe[ut]], ot[ut] = pe[Oe[ut]];
      }, dt.prototype.transform = function(Oe, rt, pe, nt, ot, st) {
        this.permute(st, Oe, rt, pe, nt, ot);
        for (var ut = 1; ut < ot; ut <<= 1)
          for (var pt = ut << 1, ft = Math.cos(2 * Math.PI / pt), yt = Math.sin(2 * Math.PI / pt), ct = 0; ct < ot; ct += pt)
            for (var Et = ft, Nt = yt, jt = 0; jt < ut; jt++) {
              var Ot = pe[ct + jt], Bt = nt[ct + jt], Tt = pe[ct + jt + ut], Ut = nt[ct + jt + ut], Gt = Et * Tt - Nt * Ut;
              Ut = Et * Ut + Nt * Tt, Tt = Gt, pe[ct + jt] = Ot + Tt, nt[ct + jt] = Bt + Ut, pe[ct + jt + ut] = Ot - Tt, nt[ct + jt + ut] = Bt - Ut, jt !== pt && (Gt = ft * Et - yt * Nt, Nt = ft * Nt + yt * Et, Et = Gt);
            }
      }, dt.prototype.guessLen13b = function(Oe, rt) {
        var pe = Math.max(rt, Oe) | 1, nt = pe & 1, ot = 0;
        for (pe = pe / 2 | 0; pe; pe = pe >>> 1)
          ot++;
        return 1 << ot + 1 + nt;
      }, dt.prototype.conjugate = function(Oe, rt, pe) {
        if (!(pe <= 1))
          for (var nt = 0; nt < pe / 2; nt++) {
            var ot = Oe[nt];
            Oe[nt] = Oe[pe - nt - 1], Oe[pe - nt - 1] = ot, ot = rt[nt], rt[nt] = -rt[pe - nt - 1], rt[pe - nt - 1] = -ot;
          }
      }, dt.prototype.normalize13b = function(Oe, rt) {
        for (var pe = 0, nt = 0; nt < rt / 2; nt++) {
          var ot = Math.round(Oe[2 * nt + 1] / rt) * 8192 + Math.round(Oe[2 * nt] / rt) + pe;
          Oe[nt] = ot & 67108863, ot < 67108864 ? pe = 0 : pe = ot / 67108864 | 0;
        }
        return Oe;
      }, dt.prototype.convert13b = function(Oe, rt, pe, nt) {
        for (var ot = 0, st = 0; st < rt; st++)
          ot = ot + (Oe[st] | 0), pe[2 * st] = ot & 8191, ot = ot >>> 13, pe[2 * st + 1] = ot & 8191, ot = ot >>> 13;
        for (st = 2 * rt; st < nt; ++st)
          pe[st] = 0;
        K(ot === 0), K((ot & -8192) === 0);
      }, dt.prototype.stub = function(Oe) {
        for (var rt = new Array(Oe), pe = 0; pe < Oe; pe++)
          rt[pe] = 0;
        return rt;
      }, dt.prototype.mulp = function(Oe, rt, pe) {
        var nt = 2 * this.guessLen13b(Oe.length, rt.length), ot = this.makeRBT(nt), st = this.stub(nt), ut = new Array(nt), pt = new Array(nt), ft = new Array(nt), yt = new Array(nt), ct = new Array(nt), Et = new Array(nt), Nt = pe.words;
        Nt.length = nt, this.convert13b(Oe.words, Oe.length, ut, nt), this.convert13b(rt.words, rt.length, yt, nt), this.transform(ut, st, pt, ft, nt, ot), this.transform(yt, st, ct, Et, nt, ot);
        for (var jt = 0; jt < nt; jt++) {
          var Ot = pt[jt] * ct[jt] - ft[jt] * Et[jt];
          ft[jt] = pt[jt] * Et[jt] + ft[jt] * ct[jt], pt[jt] = Ot;
        }
        return this.conjugate(pt, ft, nt), this.transform(pt, ft, Nt, st, nt, ot), this.conjugate(Nt, st, nt), this.normalize13b(Nt, nt), pe.negative = Oe.negative ^ rt.negative, pe.length = Oe.length + rt.length, pe.strip();
      }, W.prototype.mul = function(Oe) {
        var rt = new W(null);
        return rt.words = new Array(this.length + Oe.length), this.mulTo(Oe, rt);
      }, W.prototype.mulf = function(Oe) {
        var rt = new W(null);
        return rt.words = new Array(this.length + Oe.length), ht(this, Oe, rt);
      }, W.prototype.imul = function(Oe) {
        return this.clone().mulTo(Oe, this);
      }, W.prototype.imuln = function(Oe) {
        K(typeof Oe == "number"), K(Oe < 67108864);
        for (var rt = 0, pe = 0; pe < this.length; pe++) {
          var nt = (this.words[pe] | 0) * Oe, ot = (nt & 67108863) + (rt & 67108863);
          rt >>= 26, rt += nt / 67108864 | 0, rt += ot >>> 26, this.words[pe] = ot & 67108863;
        }
        return rt !== 0 && (this.words[pe] = rt, this.length++), this;
      }, W.prototype.muln = function(Oe) {
        return this.clone().imuln(Oe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(Oe) {
        var rt = Ce(Oe);
        if (rt.length === 0) return new W(1);
        for (var pe = this, nt = 0; nt < rt.length && rt[nt] === 0; nt++, pe = pe.sqr())
          ;
        if (++nt < rt.length)
          for (var ot = pe.sqr(); nt < rt.length; nt++, ot = ot.sqr())
            rt[nt] !== 0 && (pe = pe.mul(ot));
        return pe;
      }, W.prototype.iushln = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 67108863 >>> 26 - rt << 26 - rt, ot;
        if (rt !== 0) {
          var st = 0;
          for (ot = 0; ot < this.length; ot++) {
            var ut = this.words[ot] & nt, pt = (this.words[ot] | 0) - ut << rt;
            this.words[ot] = pt | st, st = ut >>> 26 - rt;
          }
          st && (this.words[ot] = st, this.length++);
        }
        if (pe !== 0) {
          for (ot = this.length - 1; ot >= 0; ot--)
            this.words[ot + pe] = this.words[ot];
          for (ot = 0; ot < pe; ot++)
            this.words[ot] = 0;
          this.length += pe;
        }
        return this.strip();
      }, W.prototype.ishln = function(Oe) {
        return K(this.negative === 0), this.iushln(Oe);
      }, W.prototype.iushrn = function(Oe, rt, pe) {
        K(typeof Oe == "number" && Oe >= 0);
        var nt;
        rt ? nt = (rt - rt % 26) / 26 : nt = 0;
        var ot = Oe % 26, st = Math.min((Oe - ot) / 26, this.length), ut = 67108863 ^ 67108863 >>> ot << ot, pt = pe;
        if (nt -= st, nt = Math.max(0, nt), pt) {
          for (var ft = 0; ft < st; ft++)
            pt.words[ft] = this.words[ft];
          pt.length = st;
        }
        if (st !== 0) if (this.length > st)
          for (this.length -= st, ft = 0; ft < this.length; ft++)
            this.words[ft] = this.words[ft + st];
        else
          this.words[0] = 0, this.length = 1;
        var yt = 0;
        for (ft = this.length - 1; ft >= 0 && (yt !== 0 || ft >= nt); ft--) {
          var ct = this.words[ft] | 0;
          this.words[ft] = yt << 26 - ot | ct >>> ot, yt = ct & ut;
        }
        return pt && yt !== 0 && (pt.words[pt.length++] = yt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, W.prototype.ishrn = function(Oe, rt, pe) {
        return K(this.negative === 0), this.iushrn(Oe, rt, pe);
      }, W.prototype.shln = function(Oe) {
        return this.clone().ishln(Oe);
      }, W.prototype.ushln = function(Oe) {
        return this.clone().iushln(Oe);
      }, W.prototype.shrn = function(Oe) {
        return this.clone().ishrn(Oe);
      }, W.prototype.ushrn = function(Oe) {
        return this.clone().iushrn(Oe);
      }, W.prototype.testn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 1 << rt;
        if (this.length <= pe) return !1;
        var ot = this.words[pe];
        return !!(ot & nt);
      }, W.prototype.imaskn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= pe)
          return this;
        if (rt !== 0 && pe++, this.length = Math.min(pe, this.length), rt !== 0) {
          var nt = 67108863 ^ 67108863 >>> rt << rt;
          this.words[this.length - 1] &= nt;
        }
        return this.strip();
      }, W.prototype.maskn = function(Oe) {
        return this.clone().imaskn(Oe);
      }, W.prototype.iaddn = function(Oe) {
        return K(typeof Oe == "number"), K(Oe < 67108864), Oe < 0 ? this.isubn(-Oe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Oe ? (this.words[0] = Oe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Oe), this.negative = 1, this) : this._iaddn(Oe);
      }, W.prototype._iaddn = function(Oe) {
        this.words[0] += Oe;
        for (var rt = 0; rt < this.length && this.words[rt] >= 67108864; rt++)
          this.words[rt] -= 67108864, rt === this.length - 1 ? this.words[rt + 1] = 1 : this.words[rt + 1]++;
        return this.length = Math.max(this.length, rt + 1), this;
      }, W.prototype.isubn = function(Oe) {
        if (K(typeof Oe == "number"), K(Oe < 67108864), Oe < 0) return this.iaddn(-Oe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Oe), this.negative = 1, this;
        if (this.words[0] -= Oe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var rt = 0; rt < this.length && this.words[rt] < 0; rt++)
            this.words[rt] += 67108864, this.words[rt + 1] -= 1;
        return this.strip();
      }, W.prototype.addn = function(Oe) {
        return this.clone().iaddn(Oe);
      }, W.prototype.subn = function(Oe) {
        return this.clone().isubn(Oe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(Oe, rt, pe) {
        var nt = Oe.length + pe, ot;
        this._expand(nt);
        var st, ut = 0;
        for (ot = 0; ot < Oe.length; ot++) {
          st = (this.words[ot + pe] | 0) + ut;
          var pt = (Oe.words[ot] | 0) * rt;
          st -= pt & 67108863, ut = (st >> 26) - (pt / 67108864 | 0), this.words[ot + pe] = st & 67108863;
        }
        for (; ot < this.length - pe; ot++)
          st = (this.words[ot + pe] | 0) + ut, ut = st >> 26, this.words[ot + pe] = st & 67108863;
        if (ut === 0) return this.strip();
        for (K(ut === -1), ut = 0, ot = 0; ot < this.length; ot++)
          st = -(this.words[ot] | 0) + ut, ut = st >> 26, this.words[ot] = st & 67108863;
        return this.negative = 1, this.strip();
      }, W.prototype._wordDiv = function(Oe, rt) {
        var pe = this.length - Oe.length, nt = this.clone(), ot = Oe, st = ot.words[ot.length - 1] | 0, ut = this._countBits(st);
        pe = 26 - ut, pe !== 0 && (ot = ot.ushln(pe), nt.iushln(pe), st = ot.words[ot.length - 1] | 0);
        var pt = nt.length - ot.length, ft;
        if (rt !== "mod") {
          ft = new W(null), ft.length = pt + 1, ft.words = new Array(ft.length);
          for (var yt = 0; yt < ft.length; yt++)
            ft.words[yt] = 0;
        }
        var ct = nt.clone()._ishlnsubmul(ot, 1, pt);
        ct.negative === 0 && (nt = ct, ft && (ft.words[pt] = 1));
        for (var Et = pt - 1; Et >= 0; Et--) {
          var Nt = (nt.words[ot.length + Et] | 0) * 67108864 + (nt.words[ot.length + Et - 1] | 0);
          for (Nt = Math.min(Nt / st | 0, 67108863), nt._ishlnsubmul(ot, Nt, Et); nt.negative !== 0; )
            Nt--, nt.negative = 0, nt._ishlnsubmul(ot, 1, Et), nt.isZero() || (nt.negative ^= 1);
          ft && (ft.words[Et] = Nt);
        }
        return ft && ft.strip(), nt.strip(), rt !== "div" && pe !== 0 && nt.iushrn(pe), {
          div: ft || null,
          mod: nt
        };
      }, W.prototype.divmod = function(Oe, rt, pe) {
        if (K(!Oe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var nt, ot, st;
        return this.negative !== 0 && Oe.negative === 0 ? (st = this.neg().divmod(Oe, rt), rt !== "mod" && (nt = st.div.neg()), rt !== "div" && (ot = st.mod.neg(), pe && ot.negative !== 0 && ot.iadd(Oe)), {
          div: nt,
          mod: ot
        }) : this.negative === 0 && Oe.negative !== 0 ? (st = this.divmod(Oe.neg(), rt), rt !== "mod" && (nt = st.div.neg()), {
          div: nt,
          mod: st.mod
        }) : this.negative & Oe.negative ? (st = this.neg().divmod(Oe.neg(), rt), rt !== "div" && (ot = st.mod.neg(), pe && ot.negative !== 0 && ot.isub(Oe)), {
          div: st.div,
          mod: ot
        }) : Oe.length > this.length || this.cmp(Oe) < 0 ? {
          div: new W(0),
          mod: this
        } : Oe.length === 1 ? rt === "div" ? {
          div: this.divn(Oe.words[0]),
          mod: null
        } : rt === "mod" ? {
          div: null,
          mod: new W(this.modn(Oe.words[0]))
        } : {
          div: this.divn(Oe.words[0]),
          mod: new W(this.modn(Oe.words[0]))
        } : this._wordDiv(Oe, rt);
      }, W.prototype.div = function(Oe) {
        return this.divmod(Oe, "div", !1).div;
      }, W.prototype.mod = function(Oe) {
        return this.divmod(Oe, "mod", !1).mod;
      }, W.prototype.umod = function(Oe) {
        return this.divmod(Oe, "mod", !0).mod;
      }, W.prototype.divRound = function(Oe) {
        var rt = this.divmod(Oe);
        if (rt.mod.isZero()) return rt.div;
        var pe = rt.div.negative !== 0 ? rt.mod.isub(Oe) : rt.mod, nt = Oe.ushrn(1), ot = Oe.andln(1), st = pe.cmp(nt);
        return st < 0 || ot === 1 && st === 0 ? rt.div : rt.div.negative !== 0 ? rt.div.isubn(1) : rt.div.iaddn(1);
      }, W.prototype.modn = function(Oe) {
        K(Oe <= 67108863);
        for (var rt = (1 << 26) % Oe, pe = 0, nt = this.length - 1; nt >= 0; nt--)
          pe = (rt * pe + (this.words[nt] | 0)) % Oe;
        return pe;
      }, W.prototype.idivn = function(Oe) {
        K(Oe <= 67108863);
        for (var rt = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = (this.words[pe] | 0) + rt * 67108864;
          this.words[pe] = nt / Oe | 0, rt = nt % Oe;
        }
        return this.strip();
      }, W.prototype.divn = function(Oe) {
        return this.clone().idivn(Oe);
      }, W.prototype.egcd = function(Oe) {
        K(Oe.negative === 0), K(!Oe.isZero());
        var rt = this, pe = Oe.clone();
        rt.negative !== 0 ? rt = rt.umod(Oe) : rt = rt.clone();
        for (var nt = new W(1), ot = new W(0), st = new W(0), ut = new W(1), pt = 0; rt.isEven() && pe.isEven(); )
          rt.iushrn(1), pe.iushrn(1), ++pt;
        for (var ft = pe.clone(), yt = rt.clone(); !rt.isZero(); ) {
          for (var ct = 0, Et = 1; !(rt.words[0] & Et) && ct < 26; ++ct, Et <<= 1) ;
          if (ct > 0)
            for (rt.iushrn(ct); ct-- > 0; )
              (nt.isOdd() || ot.isOdd()) && (nt.iadd(ft), ot.isub(yt)), nt.iushrn(1), ot.iushrn(1);
          for (var Nt = 0, jt = 1; !(pe.words[0] & jt) && Nt < 26; ++Nt, jt <<= 1) ;
          if (Nt > 0)
            for (pe.iushrn(Nt); Nt-- > 0; )
              (st.isOdd() || ut.isOdd()) && (st.iadd(ft), ut.isub(yt)), st.iushrn(1), ut.iushrn(1);
          rt.cmp(pe) >= 0 ? (rt.isub(pe), nt.isub(st), ot.isub(ut)) : (pe.isub(rt), st.isub(nt), ut.isub(ot));
        }
        return {
          a: st,
          b: ut,
          gcd: pe.iushln(pt)
        };
      }, W.prototype._invmp = function(Oe) {
        K(Oe.negative === 0), K(!Oe.isZero());
        var rt = this, pe = Oe.clone();
        rt.negative !== 0 ? rt = rt.umod(Oe) : rt = rt.clone();
        for (var nt = new W(1), ot = new W(0), st = pe.clone(); rt.cmpn(1) > 0 && pe.cmpn(1) > 0; ) {
          for (var ut = 0, pt = 1; !(rt.words[0] & pt) && ut < 26; ++ut, pt <<= 1) ;
          if (ut > 0)
            for (rt.iushrn(ut); ut-- > 0; )
              nt.isOdd() && nt.iadd(st), nt.iushrn(1);
          for (var ft = 0, yt = 1; !(pe.words[0] & yt) && ft < 26; ++ft, yt <<= 1) ;
          if (ft > 0)
            for (pe.iushrn(ft); ft-- > 0; )
              ot.isOdd() && ot.iadd(st), ot.iushrn(1);
          rt.cmp(pe) >= 0 ? (rt.isub(pe), nt.isub(ot)) : (pe.isub(rt), ot.isub(nt));
        }
        var ct;
        return rt.cmpn(1) === 0 ? ct = nt : ct = ot, ct.cmpn(0) < 0 && ct.iadd(Oe), ct;
      }, W.prototype.gcd = function(Oe) {
        if (this.isZero()) return Oe.abs();
        if (Oe.isZero()) return this.abs();
        var rt = this.clone(), pe = Oe.clone();
        rt.negative = 0, pe.negative = 0;
        for (var nt = 0; rt.isEven() && pe.isEven(); nt++)
          rt.iushrn(1), pe.iushrn(1);
        do {
          for (; rt.isEven(); )
            rt.iushrn(1);
          for (; pe.isEven(); )
            pe.iushrn(1);
          var ot = rt.cmp(pe);
          if (ot < 0) {
            var st = rt;
            rt = pe, pe = st;
          } else if (ot === 0 || pe.cmpn(1) === 0)
            break;
          rt.isub(pe);
        } while (!0);
        return pe.iushln(nt);
      }, W.prototype.invm = function(Oe) {
        return this.egcd(Oe).a.umod(Oe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(Oe) {
        return this.words[0] & Oe;
      }, W.prototype.bincn = function(Oe) {
        K(typeof Oe == "number");
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 1 << rt;
        if (this.length <= pe)
          return this._expand(pe + 1), this.words[pe] |= nt, this;
        for (var ot = nt, st = pe; ot !== 0 && st < this.length; st++) {
          var ut = this.words[st] | 0;
          ut += ot, ot = ut >>> 26, ut &= 67108863, this.words[st] = ut;
        }
        return ot !== 0 && (this.words[st] = ot, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(Oe) {
        var rt = Oe < 0;
        if (this.negative !== 0 && !rt) return -1;
        if (this.negative === 0 && rt) return 1;
        this.strip();
        var pe;
        if (this.length > 1)
          pe = 1;
        else {
          rt && (Oe = -Oe), K(Oe <= 67108863, "Number is too big");
          var nt = this.words[0] | 0;
          pe = nt === Oe ? 0 : nt < Oe ? -1 : 1;
        }
        return this.negative !== 0 ? -pe | 0 : pe;
      }, W.prototype.cmp = function(Oe) {
        if (this.negative !== 0 && Oe.negative === 0) return -1;
        if (this.negative === 0 && Oe.negative !== 0) return 1;
        var rt = this.ucmp(Oe);
        return this.negative !== 0 ? -rt | 0 : rt;
      }, W.prototype.ucmp = function(Oe) {
        if (this.length > Oe.length) return 1;
        if (this.length < Oe.length) return -1;
        for (var rt = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = this.words[pe] | 0, ot = Oe.words[pe] | 0;
          if (nt !== ot) {
            nt < ot ? rt = -1 : nt > ot && (rt = 1);
            break;
          }
        }
        return rt;
      }, W.prototype.gtn = function(Oe) {
        return this.cmpn(Oe) === 1;
      }, W.prototype.gt = function(Oe) {
        return this.cmp(Oe) === 1;
      }, W.prototype.gten = function(Oe) {
        return this.cmpn(Oe) >= 0;
      }, W.prototype.gte = function(Oe) {
        return this.cmp(Oe) >= 0;
      }, W.prototype.ltn = function(Oe) {
        return this.cmpn(Oe) === -1;
      }, W.prototype.lt = function(Oe) {
        return this.cmp(Oe) === -1;
      }, W.prototype.lten = function(Oe) {
        return this.cmpn(Oe) <= 0;
      }, W.prototype.lte = function(Oe) {
        return this.cmp(Oe) <= 0;
      }, W.prototype.eqn = function(Oe) {
        return this.cmpn(Oe) === 0;
      }, W.prototype.eq = function(Oe) {
        return this.cmp(Oe) === 0;
      }, W.red = function(Oe) {
        return new bt(Oe);
      }, W.prototype.toRed = function(Oe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), Oe.convertTo(this)._forceRed(Oe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(Oe) {
        return this.red = Oe, this;
      }, W.prototype.forceRed = function(Oe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(Oe);
      }, W.prototype.redAdd = function(Oe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, Oe);
      }, W.prototype.redIAdd = function(Oe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Oe);
      }, W.prototype.redSub = function(Oe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, Oe);
      }, W.prototype.redISub = function(Oe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, Oe);
      }, W.prototype.redShl = function(Oe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, Oe);
      }, W.prototype.redMul = function(Oe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Oe), this.red.mul(this, Oe);
      }, W.prototype.redIMul = function(Oe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Oe), this.red.imul(this, Oe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(Oe) {
        return K(this.red && !Oe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Oe);
      };
      var vt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function mt(wt, Oe) {
        this.name = wt, this.p = new W(Oe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      mt.prototype._tmp = function() {
        var Oe = new W(null);
        return Oe.words = new Array(Math.ceil(this.n / 13)), Oe;
      }, mt.prototype.ireduce = function(Oe) {
        var rt = Oe, pe;
        do
          this.split(rt, this.tmp), rt = this.imulK(rt), rt = rt.iadd(this.tmp), pe = rt.bitLength();
        while (pe > this.n);
        var nt = pe < this.n ? -1 : rt.ucmp(this.p);
        return nt === 0 ? (rt.words[0] = 0, rt.length = 1) : nt > 0 ? rt.isub(this.p) : rt.strip !== void 0 ? rt.strip() : rt._strip(), rt;
      }, mt.prototype.split = function(Oe, rt) {
        Oe.iushrn(this.n, 0, rt);
      }, mt.prototype.imulK = function(Oe) {
        return Oe.imul(this.k);
      };
      function Pt() {
        mt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J(Pt, mt), Pt.prototype.split = function(Oe, rt) {
        for (var pe = 4194303, nt = Math.min(Oe.length, 9), ot = 0; ot < nt; ot++)
          rt.words[ot] = Oe.words[ot];
        if (rt.length = nt, Oe.length <= 9) {
          Oe.words[0] = 0, Oe.length = 1;
          return;
        }
        var st = Oe.words[9];
        for (rt.words[rt.length++] = st & pe, ot = 10; ot < Oe.length; ot++) {
          var ut = Oe.words[ot] | 0;
          Oe.words[ot - 10] = (ut & pe) << 4 | st >>> 22, st = ut;
        }
        st >>>= 22, Oe.words[ot - 10] = st, st === 0 && Oe.length > 10 ? Oe.length -= 10 : Oe.length -= 9;
      }, Pt.prototype.imulK = function(Oe) {
        Oe.words[Oe.length] = 0, Oe.words[Oe.length + 1] = 0, Oe.length += 2;
        for (var rt = 0, pe = 0; pe < Oe.length; pe++) {
          var nt = Oe.words[pe] | 0;
          rt += nt * 977, Oe.words[pe] = rt & 67108863, rt = nt * 64 + (rt / 67108864 | 0);
        }
        return Oe.words[Oe.length - 1] === 0 && (Oe.length--, Oe.words[Oe.length - 1] === 0 && Oe.length--), Oe;
      };
      function $t() {
        mt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J($t, mt);
      function qt() {
        mt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(qt, mt);
      function At() {
        mt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(At, mt), At.prototype.imulK = function(Oe) {
        for (var rt = 0, pe = 0; pe < Oe.length; pe++) {
          var nt = (Oe.words[pe] | 0) * 19 + rt, ot = nt & 67108863;
          nt >>>= 26, Oe.words[pe] = ot, rt = nt;
        }
        return rt !== 0 && (Oe.words[Oe.length++] = rt), Oe;
      }, W._prime = function(Oe) {
        if (vt[Oe]) return vt[Oe];
        var rt;
        if (Oe === "k256")
          rt = new Pt();
        else if (Oe === "p224")
          rt = new $t();
        else if (Oe === "p192")
          rt = new qt();
        else if (Oe === "p25519")
          rt = new At();
        else
          throw new Error("Unknown prime " + Oe);
        return vt[Oe] = rt, rt;
      };
      function bt(wt) {
        if (typeof wt == "string") {
          var Oe = W._prime(wt);
          this.m = Oe.p, this.prime = Oe;
        } else
          K(wt.gtn(1), "modulus must be greater than 1"), this.m = wt, this.prime = null;
      }
      bt.prototype._verify1 = function(Oe) {
        K(Oe.negative === 0, "red works only with positives"), K(Oe.red, "red works only with red numbers");
      }, bt.prototype._verify2 = function(Oe, rt) {
        K((Oe.negative | rt.negative) === 0, "red works only with positives"), K(
          Oe.red && Oe.red === rt.red,
          "red works only with red numbers"
        );
      }, bt.prototype.imod = function(Oe) {
        return this.prime ? this.prime.ireduce(Oe)._forceRed(this) : Oe.umod(this.m)._forceRed(this);
      }, bt.prototype.neg = function(Oe) {
        return Oe.isZero() ? Oe.clone() : this.m.sub(Oe)._forceRed(this);
      }, bt.prototype.add = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.add(rt);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe._forceRed(this);
      }, bt.prototype.iadd = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.iadd(rt);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe;
      }, bt.prototype.sub = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.sub(rt);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe._forceRed(this);
      }, bt.prototype.isub = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.isub(rt);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe;
      }, bt.prototype.shl = function(Oe, rt) {
        return this._verify1(Oe), this.imod(Oe.ushln(rt));
      }, bt.prototype.imul = function(Oe, rt) {
        return this._verify2(Oe, rt), this.imod(Oe.imul(rt));
      }, bt.prototype.mul = function(Oe, rt) {
        return this._verify2(Oe, rt), this.imod(Oe.mul(rt));
      }, bt.prototype.isqr = function(Oe) {
        return this.imul(Oe, Oe.clone());
      }, bt.prototype.sqr = function(Oe) {
        return this.mul(Oe, Oe);
      }, bt.prototype.sqrt = function(Oe) {
        if (Oe.isZero()) return Oe.clone();
        var rt = this.m.andln(3);
        if (K(rt % 2 === 1), rt === 3) {
          var pe = this.m.add(new W(1)).iushrn(2);
          return this.pow(Oe, pe);
        }
        for (var nt = this.m.subn(1), ot = 0; !nt.isZero() && nt.andln(1) === 0; )
          ot++, nt.iushrn(1);
        K(!nt.isZero());
        var st = new W(1).toRed(this), ut = st.redNeg(), pt = this.m.subn(1).iushrn(1), ft = this.m.bitLength();
        for (ft = new W(2 * ft * ft).toRed(this); this.pow(ft, pt).cmp(ut) !== 0; )
          ft.redIAdd(ut);
        for (var yt = this.pow(ft, nt), ct = this.pow(Oe, nt.addn(1).iushrn(1)), Et = this.pow(Oe, nt), Nt = ot; Et.cmp(st) !== 0; ) {
          for (var jt = Et, Ot = 0; jt.cmp(st) !== 0; Ot++)
            jt = jt.redSqr();
          K(Ot < Nt);
          var Bt = this.pow(yt, new W(1).iushln(Nt - Ot - 1));
          ct = ct.redMul(Bt), yt = Bt.redSqr(), Et = Et.redMul(yt), Nt = Ot;
        }
        return ct;
      }, bt.prototype.invm = function(Oe) {
        var rt = Oe._invmp(this.m);
        return rt.negative !== 0 ? (rt.negative = 0, this.imod(rt).redNeg()) : this.imod(rt);
      }, bt.prototype.pow = function(Oe, rt) {
        if (rt.isZero()) return new W(1).toRed(this);
        if (rt.cmpn(1) === 0) return Oe.clone();
        var pe = 4, nt = new Array(1 << pe);
        nt[0] = new W(1).toRed(this), nt[1] = Oe;
        for (var ot = 2; ot < nt.length; ot++)
          nt[ot] = this.mul(nt[ot - 1], Oe);
        var st = nt[0], ut = 0, pt = 0, ft = rt.bitLength() % 26;
        for (ft === 0 && (ft = 26), ot = rt.length - 1; ot >= 0; ot--) {
          for (var yt = rt.words[ot], ct = ft - 1; ct >= 0; ct--) {
            var Et = yt >> ct & 1;
            if (st !== nt[0] && (st = this.sqr(st)), Et === 0 && ut === 0) {
              pt = 0;
              continue;
            }
            ut <<= 1, ut |= Et, pt++, !(pt !== pe && (ot !== 0 || ct !== 0)) && (st = this.mul(st, nt[ut]), pt = 0, ut = 0);
          }
          ft = 26;
        }
        return st;
      }, bt.prototype.convertTo = function(Oe) {
        var rt = Oe.umod(this.m);
        return rt === Oe ? rt.clone() : rt;
      }, bt.prototype.convertFrom = function(Oe) {
        var rt = Oe.clone();
        return rt.red = null, rt;
      }, W.mont = function(Oe) {
        return new xt(Oe);
      };
      function xt(wt) {
        bt.call(this, wt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(xt, bt), xt.prototype.convertTo = function(Oe) {
        return this.imod(Oe.ushln(this.shift));
      }, xt.prototype.convertFrom = function(Oe) {
        var rt = this.imod(Oe.mul(this.rinv));
        return rt.red = null, rt;
      }, xt.prototype.imul = function(Oe, rt) {
        if (Oe.isZero() || rt.isZero())
          return Oe.words[0] = 0, Oe.length = 1, Oe;
        var pe = Oe.imul(rt), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = pe.isub(nt).iushrn(this.shift), st = ot;
        return ot.cmp(this.m) >= 0 ? st = ot.isub(this.m) : ot.cmpn(0) < 0 && (st = ot.iadd(this.m)), st._forceRed(this);
      }, xt.prototype.mul = function(Oe, rt) {
        if (Oe.isZero() || rt.isZero()) return new W(0)._forceRed(this);
        var pe = Oe.mul(rt), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = pe.isub(nt).iushrn(this.shift), st = ot;
        return ot.cmp(this.m) >= 0 ? st = ot.isub(this.m) : ot.cmpn(0) < 0 && (st = ot.iadd(this.m)), st._forceRed(this);
      }, xt.prototype.invm = function(Oe) {
        var rt = this.imod(Oe._invmp(this.m).mul(this.r2));
        return rt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var A;
  brorand.exports = function(J) {
    return A || (A = new B(null)), A.generate(J);
  };
  function B(K) {
    this.rand = K;
  }
  if (brorand.exports.Rand = B, B.prototype.generate = function(J) {
    return this._rand(J);
  }, B.prototype._rand = function(J) {
    if (this.rand.getBytes)
      return this.rand.getBytes(J);
    for (var W = new Uint8Array(J), V = 0; V < W.length; V++)
      W[V] = this.rand.getByte();
    return W;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? B.prototype._rand = function(J) {
      var W = new Uint8Array(J);
      return self.crypto.getRandomValues(W), W;
    } : self.msCrypto && self.msCrypto.getRandomValues ? B.prototype._rand = function(J) {
      var W = new Uint8Array(J);
      return self.msCrypto.getRandomValues(W), W;
    } : typeof window == "object" && (B.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var L = requireCryptoBrowserify();
      if (typeof L.randomBytes != "function")
        throw new Error("Not supported");
      B.prototype._rand = function(J) {
        return L.randomBytes(J);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var A = requireBn$1(), B = requireBrorand();
  function L(K) {
    this.rand = K || new B.Rand();
  }
  return mr = L, L.create = function(J) {
    return new L(J);
  }, L.prototype._randbelow = function(J) {
    var W = J.bitLength(), V = Math.ceil(W / 8);
    do
      var ne = new A(this.rand.generate(V));
    while (ne.cmp(J) >= 0);
    return ne;
  }, L.prototype._randrange = function(J, W) {
    var V = W.sub(J);
    return J.add(this._randbelow(V));
  }, L.prototype.test = function(J, W, V) {
    var ne = J.bitLength(), ie = A.mont(J), oe = new A(1).toRed(ie);
    W || (W = Math.max(1, ne / 48 | 0));
    for (var re = J.subn(1), ce = 0; !re.testn(ce); ce++)
      ;
    for (var ke = J.shrn(ce), Ce = re.toRed(ie), it = !0; W > 0; W--) {
      var at = this._randrange(new A(2), re);
      V && V(at);
      var lt = at.toRed(ie).redPow(ke);
      if (!(lt.cmp(oe) === 0 || lt.cmp(Ce) === 0)) {
        for (var ht = 1; ht < ce; ht++) {
          if (lt = lt.redSqr(), lt.cmp(oe) === 0)
            return !1;
          if (lt.cmp(Ce) === 0)
            break;
        }
        if (ht === ce)
          return !1;
      }
    }
    return it;
  }, L.prototype.getDivisor = function(J, W) {
    var V = J.bitLength(), ne = A.mont(J), ie = new A(1).toRed(ne);
    W || (W = Math.max(1, V / 48 | 0));
    for (var oe = J.subn(1), re = 0; !oe.testn(re); re++)
      ;
    for (var ce = J.shrn(re), ke = oe.toRed(ne); W > 0; W--) {
      var Ce = this._randrange(new A(2), oe), it = J.gcd(Ce);
      if (it.cmpn(1) !== 0)
        return it;
      var at = Ce.toRed(ne).redPow(ce);
      if (!(at.cmp(ie) === 0 || at.cmp(ke) === 0)) {
        for (var lt = 1; lt < re; lt++) {
          if (at = at.redSqr(), at.cmp(ie) === 0)
            return at.fromRed().subn(1).gcd(J);
          if (at.cmp(ke) === 0)
            break;
        }
        if (lt === re)
          return at = at.redSqr(), at.fromRed().subn(1).gcd(J);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var A = requireBrowser$b();
  generatePrime = lt, lt.simpleSieve = it, lt.fermatTest = at;
  var B = requireBn$1(), L = new B(24), K = requireMr(), J = new K(), W = new B(1), V = new B(2), ne = new B(5);
  new B(16), new B(8);
  var ie = new B(10), oe = new B(3);
  new B(7);
  var re = new B(11), ce = new B(4);
  new B(12);
  var ke = null;
  function Ce() {
    if (ke !== null)
      return ke;
    var ht = 1048576, dt = [];
    dt[0] = 2;
    for (var vt = 1, mt = 3; mt < ht; mt += 2) {
      for (var Pt = Math.ceil(Math.sqrt(mt)), $t = 0; $t < vt && dt[$t] <= Pt && mt % dt[$t] !== 0; $t++)
        ;
      vt !== $t && dt[$t] <= Pt || (dt[vt++] = mt);
    }
    return ke = dt, dt;
  }
  function it(ht) {
    for (var dt = Ce(), vt = 0; vt < dt.length; vt++)
      if (ht.modn(dt[vt]) === 0)
        return ht.cmpn(dt[vt]) === 0;
    return !0;
  }
  function at(ht) {
    var dt = B.mont(ht);
    return V.toRed(dt).redPow(ht.subn(1)).fromRed().cmpn(1) === 0;
  }
  function lt(ht, dt) {
    if (ht < 16)
      return dt === 2 || dt === 5 ? new B([140, 123]) : new B([140, 39]);
    dt = new B(dt);
    for (var vt, mt; ; ) {
      for (vt = new B(A(Math.ceil(ht / 8))); vt.bitLength() > ht; )
        vt.ishrn(1);
      if (vt.isEven() && vt.iadd(W), vt.testn(1) || vt.iadd(V), dt.cmp(V)) {
        if (!dt.cmp(ne))
          for (; vt.mod(ie).cmp(oe); )
            vt.iadd(ce);
      } else for (; vt.mod(L).cmp(re); )
        vt.iadd(ce);
      if (mt = vt.shrn(1), it(mt) && it(vt) && at(mt) && at(vt) && J.test(mt) && J.test(vt))
        return vt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var A = requireBn$1(), B = requireMr(), L = new B(), K = new A(24), J = new A(11), W = new A(10), V = new A(3), ne = new A(7), ie = requireGeneratePrime(), oe = requireBrowser$b();
  dh = it;
  function re(lt, ht) {
    return ht = ht || "utf8", Buffer$1.isBuffer(lt) || (lt = new Buffer$1(lt, ht)), this._pub = new A(lt), this;
  }
  function ce(lt, ht) {
    return ht = ht || "utf8", Buffer$1.isBuffer(lt) || (lt = new Buffer$1(lt, ht)), this._priv = new A(lt), this;
  }
  var ke = {};
  function Ce(lt, ht) {
    var dt = ht.toString("hex"), vt = [dt, lt.toString(16)].join("_");
    if (vt in ke)
      return ke[vt];
    var mt = 0;
    if (lt.isEven() || !ie.simpleSieve || !ie.fermatTest(lt) || !L.test(lt))
      return mt += 1, dt === "02" || dt === "05" ? mt += 8 : mt += 4, ke[vt] = mt, mt;
    L.test(lt.shrn(1)) || (mt += 2);
    var Pt;
    switch (dt) {
      case "02":
        lt.mod(K).cmp(J) && (mt += 8);
        break;
      case "05":
        Pt = lt.mod(W), Pt.cmp(V) && Pt.cmp(ne) && (mt += 8);
        break;
      default:
        mt += 4;
    }
    return ke[vt] = mt, mt;
  }
  function it(lt, ht, dt) {
    this.setGenerator(ht), this.__prime = new A(lt), this._prime = A.mont(this.__prime), this._primeLen = lt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, dt ? (this.setPublicKey = re, this.setPrivateKey = ce) : this._primeCode = 8;
  }
  Object.defineProperty(it.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ce(this.__prime, this.__gen)), this._primeCode;
    }
  }), it.prototype.generateKeys = function() {
    return this._priv || (this._priv = new A(oe(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, it.prototype.computeSecret = function(lt) {
    lt = new A(lt), lt = lt.toRed(this._prime);
    var ht = lt.redPow(this._priv).fromRed(), dt = new Buffer$1(ht.toArray()), vt = this.getPrime();
    if (dt.length < vt.length) {
      var mt = new Buffer$1(vt.length - dt.length);
      mt.fill(0), dt = Buffer$1.concat([mt, dt]);
    }
    return dt;
  }, it.prototype.getPublicKey = function(ht) {
    return at(this._pub, ht);
  }, it.prototype.getPrivateKey = function(ht) {
    return at(this._priv, ht);
  }, it.prototype.getPrime = function(lt) {
    return at(this.__prime, lt);
  }, it.prototype.getGenerator = function(lt) {
    return at(this._gen, lt);
  }, it.prototype.setGenerator = function(lt, ht) {
    return ht = ht || "utf8", Buffer$1.isBuffer(lt) || (lt = new Buffer$1(lt, ht)), this.__gen = lt, this._gen = new A(lt), this;
  };
  function at(lt, ht) {
    var dt = new Buffer$1(lt.toArray());
    return ht ? dt.toString(ht) : dt;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var A = requireGeneratePrime(), B = require$$1$1, L = requireDh();
  function K(V) {
    var ne = new Buffer$1(B[V].prime, "hex"), ie = new Buffer$1(B[V].gen, "hex");
    return new L(ne, ie);
  }
  var J = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function W(V, ne, ie, oe) {
    return Buffer$1.isBuffer(ne) || J[ne] === void 0 ? W(V, "binary", ne, ie) : (ne = ne || "binary", oe = oe || "binary", ie = ie || new Buffer$1([2]), Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, oe)), typeof V == "number" ? new L(A(V, ie), ie, !0) : (Buffer$1.isBuffer(V) || (V = new Buffer$1(V, ne)), new L(V, ie, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = K, browser$4.createDiffieHellman = browser$4.DiffieHellman = W, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: A } : processNextickArgs.exports = process$1;
  function A(B, L, K, J) {
    if (typeof B != "function")
      throw new TypeError('"callback" argument must be a function');
    var W = arguments.length, V, ne;
    switch (W) {
      case 0:
      case 1:
        return process$1.nextTick(B);
      case 2:
        return process$1.nextTick(function() {
          B.call(null, L);
        });
      case 3:
        return process$1.nextTick(function() {
          B.call(null, L, K);
        });
      case 4:
        return process$1.nextTick(function() {
          B.call(null, L, K, J);
        });
      default:
        for (V = new Array(W - 1), ne = 0; ne < V.length; )
          V[ne++] = arguments[ne];
        return process$1.nextTick(function() {
          B.apply(null, V);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var A = {}.toString;
  return isarray = Array.isArray || function(B) {
    return A.call(B) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(A, B) {
    var L = require$$0$1, K = L.Buffer;
    function J(V, ne) {
      for (var ie in V)
        ne[ie] = V[ie];
    }
    K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (J(L, B), B.Buffer = W);
    function W(V, ne, ie) {
      return K(V, ne, ie);
    }
    J(K, W), W.from = function(V, ne, ie) {
      if (typeof V == "number")
        throw new TypeError("Argument must not be a number");
      return K(V, ne, ie);
    }, W.alloc = function(V, ne, ie) {
      if (typeof V != "number")
        throw new TypeError("Argument must be a number");
      var oe = K(V);
      return ne !== void 0 ? typeof ie == "string" ? oe.fill(ne, ie) : oe.fill(ne) : oe.fill(0), oe;
    }, W.allocUnsafe = function(V) {
      if (typeof V != "number")
        throw new TypeError("Argument must be a number");
      return K(V);
    }, W.allocUnsafeSlow = function(V) {
      if (typeof V != "number")
        throw new TypeError("Argument must be a number");
      return L.SlowBuffer(V);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function A(at) {
    return Array.isArray ? Array.isArray(at) : it(at) === "[object Array]";
  }
  util.isArray = A;
  function B(at) {
    return typeof at == "boolean";
  }
  util.isBoolean = B;
  function L(at) {
    return at === null;
  }
  util.isNull = L;
  function K(at) {
    return at == null;
  }
  util.isNullOrUndefined = K;
  function J(at) {
    return typeof at == "number";
  }
  util.isNumber = J;
  function W(at) {
    return typeof at == "string";
  }
  util.isString = W;
  function V(at) {
    return typeof at == "symbol";
  }
  util.isSymbol = V;
  function ne(at) {
    return at === void 0;
  }
  util.isUndefined = ne;
  function ie(at) {
    return it(at) === "[object RegExp]";
  }
  util.isRegExp = ie;
  function oe(at) {
    return typeof at == "object" && at !== null;
  }
  util.isObject = oe;
  function re(at) {
    return it(at) === "[object Date]";
  }
  util.isDate = re;
  function ce(at) {
    return it(at) === "[object Error]" || at instanceof Error;
  }
  util.isError = ce;
  function ke(at) {
    return typeof at == "function";
  }
  util.isFunction = ke;
  function Ce(at) {
    return at === null || typeof at == "boolean" || typeof at == "number" || typeof at == "string" || typeof at == "symbol" || // ES6 symbol
    typeof at > "u";
  }
  util.isPrimitive = Ce, util.isBuffer = require$$0$1.Buffer.isBuffer;
  function it(at) {
    return Object.prototype.toString.call(at);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(A) {
    function B(W, V) {
      if (!(W instanceof V))
        throw new TypeError("Cannot call a class as a function");
    }
    var L = requireSafeBuffer().Buffer, K = requireUtil$1();
    function J(W, V, ne) {
      W.copy(V, ne);
    }
    A.exports = function() {
      function W() {
        B(this, W), this.head = null, this.tail = null, this.length = 0;
      }
      return W.prototype.push = function(ne) {
        var ie = { data: ne, next: null };
        this.length > 0 ? this.tail.next = ie : this.head = ie, this.tail = ie, ++this.length;
      }, W.prototype.unshift = function(ne) {
        var ie = { data: ne, next: this.head };
        this.length === 0 && (this.tail = ie), this.head = ie, ++this.length;
      }, W.prototype.shift = function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }, W.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, W.prototype.join = function(ne) {
        if (this.length === 0) return "";
        for (var ie = this.head, oe = "" + ie.data; ie = ie.next; )
          oe += ne + ie.data;
        return oe;
      }, W.prototype.concat = function(ne) {
        if (this.length === 0) return L.alloc(0);
        for (var ie = L.allocUnsafe(ne >>> 0), oe = this.head, re = 0; oe; )
          J(oe.data, ie, re), re += oe.data.length, oe = oe.next;
        return ie;
      }, W;
    }(), K && K.inspect && K.inspect.custom && (A.exports.prototype[K.inspect.custom] = function() {
      var W = K.inspect({ length: this.length });
      return this.constructor.name + " " + W;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var A = requireProcessNextickArgs();
  function B(J, W) {
    var V = this, ne = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
    return ne || ie ? (W ? W(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, A.nextTick(K, this, J)) : A.nextTick(K, this, J)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(oe) {
      !W && oe ? V._writableState ? V._writableState.errorEmitted || (V._writableState.errorEmitted = !0, A.nextTick(K, V, oe)) : A.nextTick(K, V, oe) : W && W(oe);
    }), this);
  }
  function L() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function K(J, W) {
    J.emit("error", W);
  }
  return destroy_1 = {
    destroy: B,
    undestroy: L
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var A = requireProcessNextickArgs();
  _stream_writable = at;
  function B(st) {
    var ut = this;
    this.next = null, this.entry = null, this.finish = function() {
      ot(ut, st);
    };
  }
  var L = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : A.nextTick, K;
  at.WritableState = Ce;
  var J = Object.create(requireUtil());
  J.inherits = requireInherits_browser();
  var W = {
    deprecate: requireBrowser$a()
  }, V = requireStreamBrowser(), ne = requireSafeBuffer().Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function oe(st) {
    return ne.from(st);
  }
  function re(st) {
    return ne.isBuffer(st) || st instanceof ie;
  }
  var ce = requireDestroy();
  J.inherits(at, V);
  function ke() {
  }
  function Ce(st, ut) {
    K = K || require_stream_duplex(), st = st || {};
    var pt = ut instanceof K;
    this.objectMode = !!st.objectMode, pt && (this.objectMode = this.objectMode || !!st.writableObjectMode);
    var ft = st.highWaterMark, yt = st.writableHighWaterMark, ct = this.objectMode ? 16 : 16 * 1024;
    ft || ft === 0 ? this.highWaterMark = ft : pt && (yt || yt === 0) ? this.highWaterMark = yt : this.highWaterMark = ct, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Et = st.decodeStrings === !1;
    this.decodeStrings = !Et, this.defaultEncoding = st.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Nt) {
      qt(ut, Nt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Ce.prototype.getBuffer = function() {
    for (var ut = this.bufferedRequest, pt = []; ut; )
      pt.push(ut), ut = ut.next;
    return pt;
  }, function() {
    try {
      Object.defineProperty(Ce.prototype, "buffer", {
        get: W.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var it;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (it = Function.prototype[Symbol.hasInstance], Object.defineProperty(at, Symbol.hasInstance, {
    value: function(st) {
      return it.call(this, st) ? !0 : this !== at ? !1 : st && st._writableState instanceof Ce;
    }
  })) : it = function(st) {
    return st instanceof this;
  };
  function at(st) {
    if (K = K || require_stream_duplex(), !it.call(at, this) && !(this instanceof K))
      return new at(st);
    this._writableState = new Ce(st, this), this.writable = !0, st && (typeof st.write == "function" && (this._write = st.write), typeof st.writev == "function" && (this._writev = st.writev), typeof st.destroy == "function" && (this._destroy = st.destroy), typeof st.final == "function" && (this._final = st.final)), V.call(this);
  }
  at.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function lt(st, ut) {
    var pt = new Error("write after end");
    st.emit("error", pt), A.nextTick(ut, pt);
  }
  function ht(st, ut, pt, ft) {
    var yt = !0, ct = !1;
    return pt === null ? ct = new TypeError("May not write null values to stream") : typeof pt != "string" && pt !== void 0 && !ut.objectMode && (ct = new TypeError("Invalid non-string/buffer chunk")), ct && (st.emit("error", ct), A.nextTick(ft, ct), yt = !1), yt;
  }
  at.prototype.write = function(st, ut, pt) {
    var ft = this._writableState, yt = !1, ct = !ft.objectMode && re(st);
    return ct && !ne.isBuffer(st) && (st = oe(st)), typeof ut == "function" && (pt = ut, ut = null), ct ? ut = "buffer" : ut || (ut = ft.defaultEncoding), typeof pt != "function" && (pt = ke), ft.ended ? lt(this, pt) : (ct || ht(this, ft, st, pt)) && (ft.pendingcb++, yt = vt(this, ft, ct, st, ut, pt)), yt;
  }, at.prototype.cork = function() {
    var st = this._writableState;
    st.corked++;
  }, at.prototype.uncork = function() {
    var st = this._writableState;
    st.corked && (st.corked--, !st.writing && !st.corked && !st.bufferProcessing && st.bufferedRequest && xt(this, st));
  }, at.prototype.setDefaultEncoding = function(ut) {
    if (typeof ut == "string" && (ut = ut.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ut + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ut);
    return this._writableState.defaultEncoding = ut, this;
  };
  function dt(st, ut, pt) {
    return !st.objectMode && st.decodeStrings !== !1 && typeof ut == "string" && (ut = ne.from(ut, pt)), ut;
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function vt(st, ut, pt, ft, yt, ct) {
    if (!pt) {
      var Et = dt(ut, ft, yt);
      ft !== Et && (pt = !0, yt = "buffer", ft = Et);
    }
    var Nt = ut.objectMode ? 1 : ft.length;
    ut.length += Nt;
    var jt = ut.length < ut.highWaterMark;
    if (jt || (ut.needDrain = !0), ut.writing || ut.corked) {
      var Ot = ut.lastBufferedRequest;
      ut.lastBufferedRequest = {
        chunk: ft,
        encoding: yt,
        isBuf: pt,
        callback: ct,
        next: null
      }, Ot ? Ot.next = ut.lastBufferedRequest : ut.bufferedRequest = ut.lastBufferedRequest, ut.bufferedRequestCount += 1;
    } else
      mt(st, ut, !1, Nt, ft, yt, ct);
    return jt;
  }
  function mt(st, ut, pt, ft, yt, ct, Et) {
    ut.writelen = ft, ut.writecb = Et, ut.writing = !0, ut.sync = !0, pt ? st._writev(yt, ut.onwrite) : st._write(yt, ct, ut.onwrite), ut.sync = !1;
  }
  function Pt(st, ut, pt, ft, yt) {
    --ut.pendingcb, pt ? (A.nextTick(yt, ft), A.nextTick(pe, st, ut), st._writableState.errorEmitted = !0, st.emit("error", ft)) : (yt(ft), st._writableState.errorEmitted = !0, st.emit("error", ft), pe(st, ut));
  }
  function $t(st) {
    st.writing = !1, st.writecb = null, st.length -= st.writelen, st.writelen = 0;
  }
  function qt(st, ut) {
    var pt = st._writableState, ft = pt.sync, yt = pt.writecb;
    if ($t(pt), ut) Pt(st, pt, ft, ut, yt);
    else {
      var ct = wt(pt);
      !ct && !pt.corked && !pt.bufferProcessing && pt.bufferedRequest && xt(st, pt), ft ? L(At, st, pt, ct, yt) : At(st, pt, ct, yt);
    }
  }
  function At(st, ut, pt, ft) {
    pt || bt(st, ut), ut.pendingcb--, ft(), pe(st, ut);
  }
  function bt(st, ut) {
    ut.length === 0 && ut.needDrain && (ut.needDrain = !1, st.emit("drain"));
  }
  function xt(st, ut) {
    ut.bufferProcessing = !0;
    var pt = ut.bufferedRequest;
    if (st._writev && pt && pt.next) {
      var ft = ut.bufferedRequestCount, yt = new Array(ft), ct = ut.corkedRequestsFree;
      ct.entry = pt;
      for (var Et = 0, Nt = !0; pt; )
        yt[Et] = pt, pt.isBuf || (Nt = !1), pt = pt.next, Et += 1;
      yt.allBuffers = Nt, mt(st, ut, !0, ut.length, yt, "", ct.finish), ut.pendingcb++, ut.lastBufferedRequest = null, ct.next ? (ut.corkedRequestsFree = ct.next, ct.next = null) : ut.corkedRequestsFree = new B(ut), ut.bufferedRequestCount = 0;
    } else {
      for (; pt; ) {
        var jt = pt.chunk, Ot = pt.encoding, Bt = pt.callback, Tt = ut.objectMode ? 1 : jt.length;
        if (mt(st, ut, !1, Tt, jt, Ot, Bt), pt = pt.next, ut.bufferedRequestCount--, ut.writing)
          break;
      }
      pt === null && (ut.lastBufferedRequest = null);
    }
    ut.bufferedRequest = pt, ut.bufferProcessing = !1;
  }
  at.prototype._write = function(st, ut, pt) {
    pt(new Error("_write() is not implemented"));
  }, at.prototype._writev = null, at.prototype.end = function(st, ut, pt) {
    var ft = this._writableState;
    typeof st == "function" ? (pt = st, st = null, ut = null) : typeof ut == "function" && (pt = ut, ut = null), st != null && this.write(st, ut), ft.corked && (ft.corked = 1, this.uncork()), ft.ending || nt(this, ft, pt);
  };
  function wt(st) {
    return st.ending && st.length === 0 && st.bufferedRequest === null && !st.finished && !st.writing;
  }
  function Oe(st, ut) {
    st._final(function(pt) {
      ut.pendingcb--, pt && st.emit("error", pt), ut.prefinished = !0, st.emit("prefinish"), pe(st, ut);
    });
  }
  function rt(st, ut) {
    !ut.prefinished && !ut.finalCalled && (typeof st._final == "function" ? (ut.pendingcb++, ut.finalCalled = !0, A.nextTick(Oe, st, ut)) : (ut.prefinished = !0, st.emit("prefinish")));
  }
  function pe(st, ut) {
    var pt = wt(ut);
    return pt && (rt(st, ut), ut.pendingcb === 0 && (ut.finished = !0, st.emit("finish"))), pt;
  }
  function nt(st, ut, pt) {
    ut.ending = !0, pe(st, ut), pt && (ut.finished ? A.nextTick(pt) : st.once("finish", pt)), ut.ended = !0, st.writable = !1;
  }
  function ot(st, ut, pt) {
    var ft = st.entry;
    for (st.entry = null; ft; ) {
      var yt = ft.callback;
      ut.pendingcb--, yt(pt), ft = ft.next;
    }
    ut.corkedRequestsFree.next = st;
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(st) {
      this._writableState && (this._writableState.destroyed = st);
    }
  }), at.prototype.destroy = ce.destroy, at.prototype._undestroy = ce.undestroy, at.prototype._destroy = function(st, ut) {
    this.end(), ut(st);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var A = requireProcessNextickArgs(), B = Object.keys || function(ce) {
    var ke = [];
    for (var Ce in ce)
      ke.push(Ce);
    return ke;
  };
  _stream_duplex = ie;
  var L = Object.create(requireUtil());
  L.inherits = requireInherits_browser();
  var K = require_stream_readable(), J = require_stream_writable();
  L.inherits(ie, K);
  for (var W = B(J.prototype), V = 0; V < W.length; V++) {
    var ne = W[V];
    ie.prototype[ne] || (ie.prototype[ne] = J.prototype[ne]);
  }
  function ie(ce) {
    if (!(this instanceof ie)) return new ie(ce);
    K.call(this, ce), J.call(this, ce), ce && ce.readable === !1 && (this.readable = !1), ce && ce.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, ce && ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", oe);
  }
  Object.defineProperty(ie.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function oe() {
    this.allowHalfOpen || this._writableState.ended || A.nextTick(re, this);
  }
  function re(ce) {
    ce.end();
  }
  return Object.defineProperty(ie.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ce) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ce, this._writableState.destroyed = ce);
    }
  }), ie.prototype._destroy = function(ce, ke) {
    this.push(null), this.end(), A.nextTick(ke, ce);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var A = requireProcessNextickArgs();
  _stream_readable = dt;
  var B = requireIsarray(), L;
  dt.ReadableState = ht, requireEvents().EventEmitter;
  var K = function(Bt, Tt) {
    return Bt.listeners(Tt).length;
  }, J = requireStreamBrowser(), W = requireSafeBuffer().Buffer, V = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ne(Bt) {
    return W.from(Bt);
  }
  function ie(Bt) {
    return W.isBuffer(Bt) || Bt instanceof V;
  }
  var oe = Object.create(requireUtil());
  oe.inherits = requireInherits_browser();
  var re = requireUtil$1(), ce = void 0;
  re && re.debuglog ? ce = re.debuglog("stream") : ce = function() {
  };
  var ke = requireBufferList(), Ce = requireDestroy(), it;
  oe.inherits(dt, J);
  var at = ["error", "close", "destroy", "pause", "resume"];
  function lt(Bt, Tt, Ut) {
    if (typeof Bt.prependListener == "function") return Bt.prependListener(Tt, Ut);
    !Bt._events || !Bt._events[Tt] ? Bt.on(Tt, Ut) : B(Bt._events[Tt]) ? Bt._events[Tt].unshift(Ut) : Bt._events[Tt] = [Ut, Bt._events[Tt]];
  }
  function ht(Bt, Tt) {
    L = L || require_stream_duplex(), Bt = Bt || {};
    var Ut = Tt instanceof L;
    this.objectMode = !!Bt.objectMode, Ut && (this.objectMode = this.objectMode || !!Bt.readableObjectMode);
    var Gt = Bt.highWaterMark, It = Bt.readableHighWaterMark, Mt = this.objectMode ? 16 : 16 * 1024;
    Gt || Gt === 0 ? this.highWaterMark = Gt : Ut && (It || It === 0) ? this.highWaterMark = It : this.highWaterMark = Mt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new ke(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Bt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Bt.encoding && (it || (it = requireString_decoder().StringDecoder), this.decoder = new it(Bt.encoding), this.encoding = Bt.encoding);
  }
  function dt(Bt) {
    if (L = L || require_stream_duplex(), !(this instanceof dt)) return new dt(Bt);
    this._readableState = new ht(Bt, this), this.readable = !0, Bt && (typeof Bt.read == "function" && (this._read = Bt.read), typeof Bt.destroy == "function" && (this._destroy = Bt.destroy)), J.call(this);
  }
  Object.defineProperty(dt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Bt) {
      this._readableState && (this._readableState.destroyed = Bt);
    }
  }), dt.prototype.destroy = Ce.destroy, dt.prototype._undestroy = Ce.undestroy, dt.prototype._destroy = function(Bt, Tt) {
    this.push(null), Tt(Bt);
  }, dt.prototype.push = function(Bt, Tt) {
    var Ut = this._readableState, Gt;
    return Ut.objectMode ? Gt = !0 : typeof Bt == "string" && (Tt = Tt || Ut.defaultEncoding, Tt !== Ut.encoding && (Bt = W.from(Bt, Tt), Tt = ""), Gt = !0), vt(this, Bt, Tt, !1, Gt);
  }, dt.prototype.unshift = function(Bt) {
    return vt(this, Bt, null, !0, !1);
  };
  function vt(Bt, Tt, Ut, Gt, It) {
    var Mt = Bt._readableState;
    if (Tt === null)
      Mt.reading = !1, xt(Bt, Mt);
    else {
      var Kt;
      It || (Kt = Pt(Mt, Tt)), Kt ? Bt.emit("error", Kt) : Mt.objectMode || Tt && Tt.length > 0 ? (typeof Tt != "string" && !Mt.objectMode && Object.getPrototypeOf(Tt) !== W.prototype && (Tt = ne(Tt)), Gt ? Mt.endEmitted ? Bt.emit("error", new Error("stream.unshift() after end event")) : mt(Bt, Mt, Tt, !0) : Mt.ended ? Bt.emit("error", new Error("stream.push() after EOF")) : (Mt.reading = !1, Mt.decoder && !Ut ? (Tt = Mt.decoder.write(Tt), Mt.objectMode || Tt.length !== 0 ? mt(Bt, Mt, Tt, !1) : rt(Bt, Mt)) : mt(Bt, Mt, Tt, !1))) : Gt || (Mt.reading = !1);
    }
    return $t(Mt);
  }
  function mt(Bt, Tt, Ut, Gt) {
    Tt.flowing && Tt.length === 0 && !Tt.sync ? (Bt.emit("data", Ut), Bt.read(0)) : (Tt.length += Tt.objectMode ? 1 : Ut.length, Gt ? Tt.buffer.unshift(Ut) : Tt.buffer.push(Ut), Tt.needReadable && wt(Bt)), rt(Bt, Tt);
  }
  function Pt(Bt, Tt) {
    var Ut;
    return !ie(Tt) && typeof Tt != "string" && Tt !== void 0 && !Bt.objectMode && (Ut = new TypeError("Invalid non-string/buffer chunk")), Ut;
  }
  function $t(Bt) {
    return !Bt.ended && (Bt.needReadable || Bt.length < Bt.highWaterMark || Bt.length === 0);
  }
  dt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, dt.prototype.setEncoding = function(Bt) {
    return it || (it = requireString_decoder().StringDecoder), this._readableState.decoder = new it(Bt), this._readableState.encoding = Bt, this;
  };
  var qt = 8388608;
  function At(Bt) {
    return Bt >= qt ? Bt = qt : (Bt--, Bt |= Bt >>> 1, Bt |= Bt >>> 2, Bt |= Bt >>> 4, Bt |= Bt >>> 8, Bt |= Bt >>> 16, Bt++), Bt;
  }
  function bt(Bt, Tt) {
    return Bt <= 0 || Tt.length === 0 && Tt.ended ? 0 : Tt.objectMode ? 1 : Bt !== Bt ? Tt.flowing && Tt.length ? Tt.buffer.head.data.length : Tt.length : (Bt > Tt.highWaterMark && (Tt.highWaterMark = At(Bt)), Bt <= Tt.length ? Bt : Tt.ended ? Tt.length : (Tt.needReadable = !0, 0));
  }
  dt.prototype.read = function(Bt) {
    ce("read", Bt), Bt = parseInt(Bt, 10);
    var Tt = this._readableState, Ut = Bt;
    if (Bt !== 0 && (Tt.emittedReadable = !1), Bt === 0 && Tt.needReadable && (Tt.length >= Tt.highWaterMark || Tt.ended))
      return ce("read: emitReadable", Tt.length, Tt.ended), Tt.length === 0 && Tt.ended ? Nt(this) : wt(this), null;
    if (Bt = bt(Bt, Tt), Bt === 0 && Tt.ended)
      return Tt.length === 0 && Nt(this), null;
    var Gt = Tt.needReadable;
    ce("need readable", Gt), (Tt.length === 0 || Tt.length - Bt < Tt.highWaterMark) && (Gt = !0, ce("length less than watermark", Gt)), Tt.ended || Tt.reading ? (Gt = !1, ce("reading or ended", Gt)) : Gt && (ce("do read"), Tt.reading = !0, Tt.sync = !0, Tt.length === 0 && (Tt.needReadable = !0), this._read(Tt.highWaterMark), Tt.sync = !1, Tt.reading || (Bt = bt(Ut, Tt)));
    var It;
    return Bt > 0 ? It = ft(Bt, Tt) : It = null, It === null ? (Tt.needReadable = !0, Bt = 0) : Tt.length -= Bt, Tt.length === 0 && (Tt.ended || (Tt.needReadable = !0), Ut !== Bt && Tt.ended && Nt(this)), It !== null && this.emit("data", It), It;
  };
  function xt(Bt, Tt) {
    if (!Tt.ended) {
      if (Tt.decoder) {
        var Ut = Tt.decoder.end();
        Ut && Ut.length && (Tt.buffer.push(Ut), Tt.length += Tt.objectMode ? 1 : Ut.length);
      }
      Tt.ended = !0, wt(Bt);
    }
  }
  function wt(Bt) {
    var Tt = Bt._readableState;
    Tt.needReadable = !1, Tt.emittedReadable || (ce("emitReadable", Tt.flowing), Tt.emittedReadable = !0, Tt.sync ? A.nextTick(Oe, Bt) : Oe(Bt));
  }
  function Oe(Bt) {
    ce("emit readable"), Bt.emit("readable"), pt(Bt);
  }
  function rt(Bt, Tt) {
    Tt.readingMore || (Tt.readingMore = !0, A.nextTick(pe, Bt, Tt));
  }
  function pe(Bt, Tt) {
    for (var Ut = Tt.length; !Tt.reading && !Tt.flowing && !Tt.ended && Tt.length < Tt.highWaterMark && (ce("maybeReadMore read 0"), Bt.read(0), Ut !== Tt.length); )
      Ut = Tt.length;
    Tt.readingMore = !1;
  }
  dt.prototype._read = function(Bt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, dt.prototype.pipe = function(Bt, Tt) {
    var Ut = this, Gt = this._readableState;
    switch (Gt.pipesCount) {
      case 0:
        Gt.pipes = Bt;
        break;
      case 1:
        Gt.pipes = [Gt.pipes, Bt];
        break;
      default:
        Gt.pipes.push(Bt);
        break;
    }
    Gt.pipesCount += 1, ce("pipe count=%d opts=%j", Gt.pipesCount, Tt);
    var It = (!Tt || Tt.end !== !1) && Bt !== process$1.stdout && Bt !== process$1.stderr, Mt = It ? Qt : Br;
    Gt.endEmitted ? A.nextTick(Mt) : Ut.once("end", Mt), Bt.on("unpipe", Kt);
    function Kt(dr, Sr) {
      ce("onunpipe"), dr === Ut && Sr && Sr.hasUnpiped === !1 && (Sr.hasUnpiped = !0, ur());
    }
    function Qt() {
      ce("onend"), Bt.end();
    }
    var rr = nt(Ut);
    Bt.on("drain", rr);
    var ar = !1;
    function ur() {
      ce("cleanup"), Bt.removeListener("close", lr), Bt.removeListener("finish", $r), Bt.removeListener("drain", rr), Bt.removeListener("error", Rr), Bt.removeListener("unpipe", Kt), Ut.removeListener("end", Qt), Ut.removeListener("end", Br), Ut.removeListener("data", Yt), ar = !0, Gt.awaitDrain && (!Bt._writableState || Bt._writableState.needDrain) && rr();
    }
    var hr = !1;
    Ut.on("data", Yt);
    function Yt(dr) {
      ce("ondata"), hr = !1;
      var Sr = Bt.write(dr);
      Sr === !1 && !hr && ((Gt.pipesCount === 1 && Gt.pipes === Bt || Gt.pipesCount > 1 && Ot(Gt.pipes, Bt) !== -1) && !ar && (ce("false write response, pause", Gt.awaitDrain), Gt.awaitDrain++, hr = !0), Ut.pause());
    }
    function Rr(dr) {
      ce("onerror", dr), Br(), Bt.removeListener("error", Rr), K(Bt, "error") === 0 && Bt.emit("error", dr);
    }
    lt(Bt, "error", Rr);
    function lr() {
      Bt.removeListener("finish", $r), Br();
    }
    Bt.once("close", lr);
    function $r() {
      ce("onfinish"), Bt.removeListener("close", lr), Br();
    }
    Bt.once("finish", $r);
    function Br() {
      ce("unpipe"), Ut.unpipe(Bt);
    }
    return Bt.emit("pipe", Ut), Gt.flowing || (ce("pipe resume"), Ut.resume()), Bt;
  };
  function nt(Bt) {
    return function() {
      var Tt = Bt._readableState;
      ce("pipeOnDrain", Tt.awaitDrain), Tt.awaitDrain && Tt.awaitDrain--, Tt.awaitDrain === 0 && K(Bt, "data") && (Tt.flowing = !0, pt(Bt));
    };
  }
  dt.prototype.unpipe = function(Bt) {
    var Tt = this._readableState, Ut = { hasUnpiped: !1 };
    if (Tt.pipesCount === 0) return this;
    if (Tt.pipesCount === 1)
      return Bt && Bt !== Tt.pipes ? this : (Bt || (Bt = Tt.pipes), Tt.pipes = null, Tt.pipesCount = 0, Tt.flowing = !1, Bt && Bt.emit("unpipe", this, Ut), this);
    if (!Bt) {
      var Gt = Tt.pipes, It = Tt.pipesCount;
      Tt.pipes = null, Tt.pipesCount = 0, Tt.flowing = !1;
      for (var Mt = 0; Mt < It; Mt++)
        Gt[Mt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Kt = Ot(Tt.pipes, Bt);
    return Kt === -1 ? this : (Tt.pipes.splice(Kt, 1), Tt.pipesCount -= 1, Tt.pipesCount === 1 && (Tt.pipes = Tt.pipes[0]), Bt.emit("unpipe", this, Ut), this);
  }, dt.prototype.on = function(Bt, Tt) {
    var Ut = J.prototype.on.call(this, Bt, Tt);
    if (Bt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Bt === "readable") {
      var Gt = this._readableState;
      !Gt.endEmitted && !Gt.readableListening && (Gt.readableListening = Gt.needReadable = !0, Gt.emittedReadable = !1, Gt.reading ? Gt.length && wt(this) : A.nextTick(ot, this));
    }
    return Ut;
  }, dt.prototype.addListener = dt.prototype.on;
  function ot(Bt) {
    ce("readable nexttick read 0"), Bt.read(0);
  }
  dt.prototype.resume = function() {
    var Bt = this._readableState;
    return Bt.flowing || (ce("resume"), Bt.flowing = !0, st(this, Bt)), this;
  };
  function st(Bt, Tt) {
    Tt.resumeScheduled || (Tt.resumeScheduled = !0, A.nextTick(ut, Bt, Tt));
  }
  function ut(Bt, Tt) {
    Tt.reading || (ce("resume read 0"), Bt.read(0)), Tt.resumeScheduled = !1, Tt.awaitDrain = 0, Bt.emit("resume"), pt(Bt), Tt.flowing && !Tt.reading && Bt.read(0);
  }
  dt.prototype.pause = function() {
    return ce("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ce("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function pt(Bt) {
    var Tt = Bt._readableState;
    for (ce("flow", Tt.flowing); Tt.flowing && Bt.read() !== null; )
      ;
  }
  dt.prototype.wrap = function(Bt) {
    var Tt = this, Ut = this._readableState, Gt = !1;
    Bt.on("end", function() {
      if (ce("wrapped end"), Ut.decoder && !Ut.ended) {
        var Kt = Ut.decoder.end();
        Kt && Kt.length && Tt.push(Kt);
      }
      Tt.push(null);
    }), Bt.on("data", function(Kt) {
      if (ce("wrapped data"), Ut.decoder && (Kt = Ut.decoder.write(Kt)), !(Ut.objectMode && Kt == null) && !(!Ut.objectMode && (!Kt || !Kt.length))) {
        var Qt = Tt.push(Kt);
        Qt || (Gt = !0, Bt.pause());
      }
    });
    for (var It in Bt)
      this[It] === void 0 && typeof Bt[It] == "function" && (this[It] = /* @__PURE__ */ function(Kt) {
        return function() {
          return Bt[Kt].apply(Bt, arguments);
        };
      }(It));
    for (var Mt = 0; Mt < at.length; Mt++)
      Bt.on(at[Mt], this.emit.bind(this, at[Mt]));
    return this._read = function(Kt) {
      ce("wrapped _read", Kt), Gt && (Gt = !1, Bt.resume());
    }, this;
  }, Object.defineProperty(dt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), dt._fromList = ft;
  function ft(Bt, Tt) {
    if (Tt.length === 0) return null;
    var Ut;
    return Tt.objectMode ? Ut = Tt.buffer.shift() : !Bt || Bt >= Tt.length ? (Tt.decoder ? Ut = Tt.buffer.join("") : Tt.buffer.length === 1 ? Ut = Tt.buffer.head.data : Ut = Tt.buffer.concat(Tt.length), Tt.buffer.clear()) : Ut = yt(Bt, Tt.buffer, Tt.decoder), Ut;
  }
  function yt(Bt, Tt, Ut) {
    var Gt;
    return Bt < Tt.head.data.length ? (Gt = Tt.head.data.slice(0, Bt), Tt.head.data = Tt.head.data.slice(Bt)) : Bt === Tt.head.data.length ? Gt = Tt.shift() : Gt = Ut ? ct(Bt, Tt) : Et(Bt, Tt), Gt;
  }
  function ct(Bt, Tt) {
    var Ut = Tt.head, Gt = 1, It = Ut.data;
    for (Bt -= It.length; Ut = Ut.next; ) {
      var Mt = Ut.data, Kt = Bt > Mt.length ? Mt.length : Bt;
      if (Kt === Mt.length ? It += Mt : It += Mt.slice(0, Bt), Bt -= Kt, Bt === 0) {
        Kt === Mt.length ? (++Gt, Ut.next ? Tt.head = Ut.next : Tt.head = Tt.tail = null) : (Tt.head = Ut, Ut.data = Mt.slice(Kt));
        break;
      }
      ++Gt;
    }
    return Tt.length -= Gt, It;
  }
  function Et(Bt, Tt) {
    var Ut = W.allocUnsafe(Bt), Gt = Tt.head, It = 1;
    for (Gt.data.copy(Ut), Bt -= Gt.data.length; Gt = Gt.next; ) {
      var Mt = Gt.data, Kt = Bt > Mt.length ? Mt.length : Bt;
      if (Mt.copy(Ut, Ut.length - Bt, 0, Kt), Bt -= Kt, Bt === 0) {
        Kt === Mt.length ? (++It, Gt.next ? Tt.head = Gt.next : Tt.head = Tt.tail = null) : (Tt.head = Gt, Gt.data = Mt.slice(Kt));
        break;
      }
      ++It;
    }
    return Tt.length -= It, Ut;
  }
  function Nt(Bt) {
    var Tt = Bt._readableState;
    if (Tt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Tt.endEmitted || (Tt.ended = !0, A.nextTick(jt, Tt, Bt));
  }
  function jt(Bt, Tt) {
    !Bt.endEmitted && Bt.length === 0 && (Bt.endEmitted = !0, Tt.readable = !1, Tt.emit("end"));
  }
  function Ot(Bt, Tt) {
    for (var Ut = 0, Gt = Bt.length; Ut < Gt; Ut++)
      if (Bt[Ut] === Tt) return Ut;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = K;
  var A = require_stream_duplex(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(K, A);
  function L(V, ne) {
    var ie = this._transformState;
    ie.transforming = !1;
    var oe = ie.writecb;
    if (!oe)
      return this.emit("error", new Error("write callback called multiple times"));
    ie.writechunk = null, ie.writecb = null, ne != null && this.push(ne), oe(V);
    var re = this._readableState;
    re.reading = !1, (re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark);
  }
  function K(V) {
    if (!(this instanceof K)) return new K(V);
    A.call(this, V), this._transformState = {
      afterTransform: L.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, V && (typeof V.transform == "function" && (this._transform = V.transform), typeof V.flush == "function" && (this._flush = V.flush)), this.on("prefinish", J);
  }
  function J() {
    var V = this;
    typeof this._flush == "function" ? this._flush(function(ne, ie) {
      W(V, ne, ie);
    }) : W(this, null, null);
  }
  K.prototype.push = function(V, ne) {
    return this._transformState.needTransform = !1, A.prototype.push.call(this, V, ne);
  }, K.prototype._transform = function(V, ne, ie) {
    throw new Error("_transform() is not implemented");
  }, K.prototype._write = function(V, ne, ie) {
    var oe = this._transformState;
    if (oe.writecb = ie, oe.writechunk = V, oe.writeencoding = ne, !oe.transforming) {
      var re = this._readableState;
      (oe.needTransform || re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark);
    }
  }, K.prototype._read = function(V) {
    var ne = this._transformState;
    ne.writechunk !== null && ne.writecb && !ne.transforming ? (ne.transforming = !0, this._transform(ne.writechunk, ne.writeencoding, ne.afterTransform)) : ne.needTransform = !0;
  }, K.prototype._destroy = function(V, ne) {
    var ie = this;
    A.prototype._destroy.call(this, V, function(oe) {
      ne(oe), ie.emit("close");
    });
  };
  function W(V, ne, ie) {
    if (ne) return V.emit("error", ne);
    if (ie != null && V.push(ie), V._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (V._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return V.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = L;
  var A = require_stream_transform(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(L, A);
  function L(K) {
    if (!(this instanceof L)) return new L(K);
    A.call(this, K);
  }
  return L.prototype._transform = function(K, J, W) {
    W(null, K);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(A, B) {
    B = A.exports = require_stream_readable(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable(), B.Duplex = require_stream_duplex(), B.Transform = require_stream_transform(), B.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(A) {
    (function(B, L) {
      function K(rt, pe) {
        if (!rt) throw new Error(pe || "Assertion failed");
      }
      function J(rt, pe) {
        rt.super_ = pe;
        var nt = function() {
        };
        nt.prototype = pe.prototype, rt.prototype = new nt(), rt.prototype.constructor = rt;
      }
      function W(rt, pe, nt) {
        if (W.isBN(rt))
          return rt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, rt !== null && ((pe === "le" || pe === "be") && (nt = pe, pe = 10), this._init(rt || 0, pe || 10, nt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var V;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? V = window.Buffer : V = require$$0$1.Buffer;
      } catch {
      }
      W.isBN = function(pe) {
        return pe instanceof W ? !0 : pe !== null && typeof pe == "object" && pe.constructor.wordSize === W.wordSize && Array.isArray(pe.words);
      }, W.max = function(pe, nt) {
        return pe.cmp(nt) > 0 ? pe : nt;
      }, W.min = function(pe, nt) {
        return pe.cmp(nt) < 0 ? pe : nt;
      }, W.prototype._init = function(pe, nt, ot) {
        if (typeof pe == "number")
          return this._initNumber(pe, nt, ot);
        if (typeof pe == "object")
          return this._initArray(pe, nt, ot);
        nt === "hex" && (nt = 16), K(nt === (nt | 0) && nt >= 2 && nt <= 36), pe = pe.toString().replace(/\s+/g, "");
        var st = 0;
        pe[0] === "-" && (st++, this.negative = 1), st < pe.length && (nt === 16 ? this._parseHex(pe, st, ot) : (this._parseBase(pe, nt, st), ot === "le" && this._initArray(this.toArray(), nt, ot)));
      }, W.prototype._initNumber = function(pe, nt, ot) {
        pe < 0 && (this.negative = 1, pe = -pe), pe < 67108864 ? (this.words = [pe & 67108863], this.length = 1) : pe < 4503599627370496 ? (this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863
        ], this.length = 2) : (K(pe < 9007199254740992), this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863,
          1
        ], this.length = 3), ot === "le" && this._initArray(this.toArray(), nt, ot);
      }, W.prototype._initArray = function(pe, nt, ot) {
        if (K(typeof pe.length == "number"), pe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(pe.length / 3), this.words = new Array(this.length);
        for (var st = 0; st < this.length; st++)
          this.words[st] = 0;
        var ut, pt, ft = 0;
        if (ot === "be")
          for (st = pe.length - 1, ut = 0; st >= 0; st -= 3)
            pt = pe[st] | pe[st - 1] << 8 | pe[st - 2] << 16, this.words[ut] |= pt << ft & 67108863, this.words[ut + 1] = pt >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, ut++);
        else if (ot === "le")
          for (st = 0, ut = 0; st < pe.length; st += 3)
            pt = pe[st] | pe[st + 1] << 8 | pe[st + 2] << 16, this.words[ut] |= pt << ft & 67108863, this.words[ut + 1] = pt >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, ut++);
        return this._strip();
      };
      function ne(rt, pe) {
        var nt = rt.charCodeAt(pe);
        if (nt >= 48 && nt <= 57)
          return nt - 48;
        if (nt >= 65 && nt <= 70)
          return nt - 55;
        if (nt >= 97 && nt <= 102)
          return nt - 87;
        K(!1, "Invalid character in " + rt);
      }
      function ie(rt, pe, nt) {
        var ot = ne(rt, nt);
        return nt - 1 >= pe && (ot |= ne(rt, nt - 1) << 4), ot;
      }
      W.prototype._parseHex = function(pe, nt, ot) {
        this.length = Math.ceil((pe.length - nt) / 6), this.words = new Array(this.length);
        for (var st = 0; st < this.length; st++)
          this.words[st] = 0;
        var ut = 0, pt = 0, ft;
        if (ot === "be")
          for (st = pe.length - 1; st >= nt; st -= 2)
            ft = ie(pe, nt, st) << ut, this.words[pt] |= ft & 67108863, ut >= 18 ? (ut -= 18, pt += 1, this.words[pt] |= ft >>> 26) : ut += 8;
        else {
          var yt = pe.length - nt;
          for (st = yt % 2 === 0 ? nt + 1 : nt; st < pe.length; st += 2)
            ft = ie(pe, nt, st) << ut, this.words[pt] |= ft & 67108863, ut >= 18 ? (ut -= 18, pt += 1, this.words[pt] |= ft >>> 26) : ut += 8;
        }
        this._strip();
      };
      function oe(rt, pe, nt, ot) {
        for (var st = 0, ut = 0, pt = Math.min(rt.length, nt), ft = pe; ft < pt; ft++) {
          var yt = rt.charCodeAt(ft) - 48;
          st *= ot, yt >= 49 ? ut = yt - 49 + 10 : yt >= 17 ? ut = yt - 17 + 10 : ut = yt, K(yt >= 0 && ut < ot, "Invalid character"), st += ut;
        }
        return st;
      }
      W.prototype._parseBase = function(pe, nt, ot) {
        this.words = [0], this.length = 1;
        for (var st = 0, ut = 1; ut <= 67108863; ut *= nt)
          st++;
        st--, ut = ut / nt | 0;
        for (var pt = pe.length - ot, ft = pt % st, yt = Math.min(pt, pt - ft) + ot, ct = 0, Et = ot; Et < yt; Et += st)
          ct = oe(pe, Et, Et + st, nt), this.imuln(ut), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
        if (ft !== 0) {
          var Nt = 1;
          for (ct = oe(pe, Et, pe.length, nt), Et = 0; Et < ft; Et++)
            Nt *= nt;
          this.imuln(Nt), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
        }
        this._strip();
      }, W.prototype.copy = function(pe) {
        pe.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          pe.words[nt] = this.words[nt];
        pe.length = this.length, pe.negative = this.negative, pe.red = this.red;
      };
      function re(rt, pe) {
        rt.words = pe.words, rt.length = pe.length, rt.negative = pe.negative, rt.red = pe.red;
      }
      if (W.prototype._move = function(pe) {
        re(pe, this);
      }, W.prototype.clone = function() {
        var pe = new W(null);
        return this.copy(pe), pe;
      }, W.prototype._expand = function(pe) {
        for (; this.length < pe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          W.prototype[Symbol.for("nodejs.util.inspect.custom")] = ce;
        } catch {
          W.prototype.inspect = ce;
        }
      else
        W.prototype.inspect = ce;
      function ce() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var ke = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ce = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], it = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(pe, nt) {
        pe = pe || 10, nt = nt | 0 || 1;
        var ot;
        if (pe === 16 || pe === "hex") {
          ot = "";
          for (var st = 0, ut = 0, pt = 0; pt < this.length; pt++) {
            var ft = this.words[pt], yt = ((ft << st | ut) & 16777215).toString(16);
            ut = ft >>> 24 - st & 16777215, st += 2, st >= 26 && (st -= 26, pt--), ut !== 0 || pt !== this.length - 1 ? ot = ke[6 - yt.length] + yt + ot : ot = yt + ot;
          }
          for (ut !== 0 && (ot = ut.toString(16) + ot); ot.length % nt !== 0; )
            ot = "0" + ot;
          return this.negative !== 0 && (ot = "-" + ot), ot;
        }
        if (pe === (pe | 0) && pe >= 2 && pe <= 36) {
          var ct = Ce[pe], Et = it[pe];
          ot = "";
          var Nt = this.clone();
          for (Nt.negative = 0; !Nt.isZero(); ) {
            var jt = Nt.modrn(Et).toString(pe);
            Nt = Nt.idivn(Et), Nt.isZero() ? ot = jt + ot : ot = ke[ct - jt.length] + jt + ot;
          }
          for (this.isZero() && (ot = "0" + ot); ot.length % nt !== 0; )
            ot = "0" + ot;
          return this.negative !== 0 && (ot = "-" + ot), ot;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var pe = this.words[0];
        return this.length === 2 ? pe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? pe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -pe : pe;
      }, W.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, V && (W.prototype.toBuffer = function(pe, nt) {
        return this.toArrayLike(V, pe, nt);
      }), W.prototype.toArray = function(pe, nt) {
        return this.toArrayLike(Array, pe, nt);
      };
      var at = function(pe, nt) {
        return pe.allocUnsafe ? pe.allocUnsafe(nt) : new pe(nt);
      };
      W.prototype.toArrayLike = function(pe, nt, ot) {
        this._strip();
        var st = this.byteLength(), ut = ot || Math.max(1, st);
        K(st <= ut, "byte array longer than desired length"), K(ut > 0, "Requested array length <= 0");
        var pt = at(pe, ut), ft = nt === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ft](pt, st), pt;
      }, W.prototype._toArrayLikeLE = function(pe, nt) {
        for (var ot = 0, st = 0, ut = 0, pt = 0; ut < this.length; ut++) {
          var ft = this.words[ut] << pt | st;
          pe[ot++] = ft & 255, ot < pe.length && (pe[ot++] = ft >> 8 & 255), ot < pe.length && (pe[ot++] = ft >> 16 & 255), pt === 6 ? (ot < pe.length && (pe[ot++] = ft >> 24 & 255), st = 0, pt = 0) : (st = ft >>> 24, pt += 2);
        }
        if (ot < pe.length)
          for (pe[ot++] = st; ot < pe.length; )
            pe[ot++] = 0;
      }, W.prototype._toArrayLikeBE = function(pe, nt) {
        for (var ot = pe.length - 1, st = 0, ut = 0, pt = 0; ut < this.length; ut++) {
          var ft = this.words[ut] << pt | st;
          pe[ot--] = ft & 255, ot >= 0 && (pe[ot--] = ft >> 8 & 255), ot >= 0 && (pe[ot--] = ft >> 16 & 255), pt === 6 ? (ot >= 0 && (pe[ot--] = ft >> 24 & 255), st = 0, pt = 0) : (st = ft >>> 24, pt += 2);
        }
        if (ot >= 0)
          for (pe[ot--] = st; ot >= 0; )
            pe[ot--] = 0;
      }, Math.clz32 ? W.prototype._countBits = function(pe) {
        return 32 - Math.clz32(pe);
      } : W.prototype._countBits = function(pe) {
        var nt = pe, ot = 0;
        return nt >= 4096 && (ot += 13, nt >>>= 13), nt >= 64 && (ot += 7, nt >>>= 7), nt >= 8 && (ot += 4, nt >>>= 4), nt >= 2 && (ot += 2, nt >>>= 2), ot + nt;
      }, W.prototype._zeroBits = function(pe) {
        if (pe === 0) return 26;
        var nt = pe, ot = 0;
        return nt & 8191 || (ot += 13, nt >>>= 13), nt & 127 || (ot += 7, nt >>>= 7), nt & 15 || (ot += 4, nt >>>= 4), nt & 3 || (ot += 2, nt >>>= 2), nt & 1 || ot++, ot;
      }, W.prototype.bitLength = function() {
        var pe = this.words[this.length - 1], nt = this._countBits(pe);
        return (this.length - 1) * 26 + nt;
      };
      function lt(rt) {
        for (var pe = new Array(rt.bitLength()), nt = 0; nt < pe.length; nt++) {
          var ot = nt / 26 | 0, st = nt % 26;
          pe[nt] = rt.words[ot] >>> st & 1;
        }
        return pe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var pe = 0, nt = 0; nt < this.length; nt++) {
          var ot = this._zeroBits(this.words[nt]);
          if (pe += ot, ot !== 26) break;
        }
        return pe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(pe) {
        return this.negative !== 0 ? this.abs().inotn(pe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(pe) {
        return this.testn(pe - 1) ? this.notn(pe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(pe) {
        for (; this.length < pe.length; )
          this.words[this.length++] = 0;
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = this.words[nt] | pe.words[nt];
        return this._strip();
      }, W.prototype.ior = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuor(pe);
      }, W.prototype.or = function(pe) {
        return this.length > pe.length ? this.clone().ior(pe) : pe.clone().ior(this);
      }, W.prototype.uor = function(pe) {
        return this.length > pe.length ? this.clone().iuor(pe) : pe.clone().iuor(this);
      }, W.prototype.iuand = function(pe) {
        var nt;
        this.length > pe.length ? nt = pe : nt = this;
        for (var ot = 0; ot < nt.length; ot++)
          this.words[ot] = this.words[ot] & pe.words[ot];
        return this.length = nt.length, this._strip();
      }, W.prototype.iand = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuand(pe);
      }, W.prototype.and = function(pe) {
        return this.length > pe.length ? this.clone().iand(pe) : pe.clone().iand(this);
      }, W.prototype.uand = function(pe) {
        return this.length > pe.length ? this.clone().iuand(pe) : pe.clone().iuand(this);
      }, W.prototype.iuxor = function(pe) {
        var nt, ot;
        this.length > pe.length ? (nt = this, ot = pe) : (nt = pe, ot = this);
        for (var st = 0; st < ot.length; st++)
          this.words[st] = nt.words[st] ^ ot.words[st];
        if (this !== nt)
          for (; st < nt.length; st++)
            this.words[st] = nt.words[st];
        return this.length = nt.length, this._strip();
      }, W.prototype.ixor = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuxor(pe);
      }, W.prototype.xor = function(pe) {
        return this.length > pe.length ? this.clone().ixor(pe) : pe.clone().ixor(this);
      }, W.prototype.uxor = function(pe) {
        return this.length > pe.length ? this.clone().iuxor(pe) : pe.clone().iuxor(this);
      }, W.prototype.inotn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = Math.ceil(pe / 26) | 0, ot = pe % 26;
        this._expand(nt), ot > 0 && nt--;
        for (var st = 0; st < nt; st++)
          this.words[st] = ~this.words[st] & 67108863;
        return ot > 0 && (this.words[st] = ~this.words[st] & 67108863 >> 26 - ot), this._strip();
      }, W.prototype.notn = function(pe) {
        return this.clone().inotn(pe);
      }, W.prototype.setn = function(pe, nt) {
        K(typeof pe == "number" && pe >= 0);
        var ot = pe / 26 | 0, st = pe % 26;
        return this._expand(ot + 1), nt ? this.words[ot] = this.words[ot] | 1 << st : this.words[ot] = this.words[ot] & ~(1 << st), this._strip();
      }, W.prototype.iadd = function(pe) {
        var nt;
        if (this.negative !== 0 && pe.negative === 0)
          return this.negative = 0, nt = this.isub(pe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && pe.negative !== 0)
          return pe.negative = 0, nt = this.isub(pe), pe.negative = 1, nt._normSign();
        var ot, st;
        this.length > pe.length ? (ot = this, st = pe) : (ot = pe, st = this);
        for (var ut = 0, pt = 0; pt < st.length; pt++)
          nt = (ot.words[pt] | 0) + (st.words[pt] | 0) + ut, this.words[pt] = nt & 67108863, ut = nt >>> 26;
        for (; ut !== 0 && pt < ot.length; pt++)
          nt = (ot.words[pt] | 0) + ut, this.words[pt] = nt & 67108863, ut = nt >>> 26;
        if (this.length = ot.length, ut !== 0)
          this.words[this.length] = ut, this.length++;
        else if (ot !== this)
          for (; pt < ot.length; pt++)
            this.words[pt] = ot.words[pt];
        return this;
      }, W.prototype.add = function(pe) {
        var nt;
        return pe.negative !== 0 && this.negative === 0 ? (pe.negative = 0, nt = this.sub(pe), pe.negative ^= 1, nt) : pe.negative === 0 && this.negative !== 0 ? (this.negative = 0, nt = pe.sub(this), this.negative = 1, nt) : this.length > pe.length ? this.clone().iadd(pe) : pe.clone().iadd(this);
      }, W.prototype.isub = function(pe) {
        if (pe.negative !== 0) {
          pe.negative = 0;
          var nt = this.iadd(pe);
          return pe.negative = 1, nt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(pe), this.negative = 1, this._normSign();
        var ot = this.cmp(pe);
        if (ot === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var st, ut;
        ot > 0 ? (st = this, ut = pe) : (st = pe, ut = this);
        for (var pt = 0, ft = 0; ft < ut.length; ft++)
          nt = (st.words[ft] | 0) - (ut.words[ft] | 0) + pt, pt = nt >> 26, this.words[ft] = nt & 67108863;
        for (; pt !== 0 && ft < st.length; ft++)
          nt = (st.words[ft] | 0) + pt, pt = nt >> 26, this.words[ft] = nt & 67108863;
        if (pt === 0 && ft < st.length && st !== this)
          for (; ft < st.length; ft++)
            this.words[ft] = st.words[ft];
        return this.length = Math.max(this.length, ft), st !== this && (this.negative = 1), this._strip();
      }, W.prototype.sub = function(pe) {
        return this.clone().isub(pe);
      };
      function ht(rt, pe, nt) {
        nt.negative = pe.negative ^ rt.negative;
        var ot = rt.length + pe.length | 0;
        nt.length = ot, ot = ot - 1 | 0;
        var st = rt.words[0] | 0, ut = pe.words[0] | 0, pt = st * ut, ft = pt & 67108863, yt = pt / 67108864 | 0;
        nt.words[0] = ft;
        for (var ct = 1; ct < ot; ct++) {
          for (var Et = yt >>> 26, Nt = yt & 67108863, jt = Math.min(ct, pe.length - 1), Ot = Math.max(0, ct - rt.length + 1); Ot <= jt; Ot++) {
            var Bt = ct - Ot | 0;
            st = rt.words[Bt] | 0, ut = pe.words[Ot] | 0, pt = st * ut + Nt, Et += pt / 67108864 | 0, Nt = pt & 67108863;
          }
          nt.words[ct] = Nt | 0, yt = Et | 0;
        }
        return yt !== 0 ? nt.words[ct] = yt | 0 : nt.length--, nt._strip();
      }
      var dt = function(pe, nt, ot) {
        var st = pe.words, ut = nt.words, pt = ot.words, ft = 0, yt, ct, Et, Nt = st[0] | 0, jt = Nt & 8191, Ot = Nt >>> 13, Bt = st[1] | 0, Tt = Bt & 8191, Ut = Bt >>> 13, Gt = st[2] | 0, It = Gt & 8191, Mt = Gt >>> 13, Kt = st[3] | 0, Qt = Kt & 8191, rr = Kt >>> 13, ar = st[4] | 0, ur = ar & 8191, hr = ar >>> 13, Yt = st[5] | 0, Rr = Yt & 8191, lr = Yt >>> 13, $r = st[6] | 0, Br = $r & 8191, dr = $r >>> 13, Sr = st[7] | 0, Mr = Sr & 8191, br = Sr >>> 13, Ir = st[8] | 0, Or = Ir & 8191, Rt = Ir >>> 13, gt = st[9] | 0, St = gt & 8191, Ct = gt >>> 13, Wt = ut[0] | 0, zt = Wt & 8191, Vt = Wt >>> 13, yr = ut[1] | 0, xr = yr & 8191, cr = yr >>> 13, Ar = ut[2] | 0, gr = Ar & 8191, _r = Ar >>> 13, kr = ut[3] | 0, Cr = kr & 8191, Ft = kr >>> 13, kt = ut[4] | 0, Dt = kt & 8191, Ht = kt >>> 13, Xt = ut[5] | 0, Zt = Xt & 8191, tr = Xt >>> 13, nr = ut[6] | 0, fr = nr & 8191, ir = nr >>> 13, pr = ut[7] | 0, wr = pr & 8191, sr = pr >>> 13, Lt = ut[8] | 0, Jt = Lt & 8191, er = Lt >>> 13, or = ut[9] | 0, vr = or & 8191, Er = or >>> 13;
        ot.negative = pe.negative ^ nt.negative, ot.length = 19, yt = Math.imul(jt, zt), ct = Math.imul(jt, Vt), ct = ct + Math.imul(Ot, zt) | 0, Et = Math.imul(Ot, Vt);
        var Tr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, yt = Math.imul(Tt, zt), ct = Math.imul(Tt, Vt), ct = ct + Math.imul(Ut, zt) | 0, Et = Math.imul(Ut, Vt), yt = yt + Math.imul(jt, xr) | 0, ct = ct + Math.imul(jt, cr) | 0, ct = ct + Math.imul(Ot, xr) | 0, Et = Et + Math.imul(Ot, cr) | 0;
        var Pr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, yt = Math.imul(It, zt), ct = Math.imul(It, Vt), ct = ct + Math.imul(Mt, zt) | 0, Et = Math.imul(Mt, Vt), yt = yt + Math.imul(Tt, xr) | 0, ct = ct + Math.imul(Tt, cr) | 0, ct = ct + Math.imul(Ut, xr) | 0, Et = Et + Math.imul(Ut, cr) | 0, yt = yt + Math.imul(jt, gr) | 0, ct = ct + Math.imul(jt, _r) | 0, ct = ct + Math.imul(Ot, gr) | 0, Et = Et + Math.imul(Ot, _r) | 0;
        var Nr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, yt = Math.imul(Qt, zt), ct = Math.imul(Qt, Vt), ct = ct + Math.imul(rr, zt) | 0, Et = Math.imul(rr, Vt), yt = yt + Math.imul(It, xr) | 0, ct = ct + Math.imul(It, cr) | 0, ct = ct + Math.imul(Mt, xr) | 0, Et = Et + Math.imul(Mt, cr) | 0, yt = yt + Math.imul(Tt, gr) | 0, ct = ct + Math.imul(Tt, _r) | 0, ct = ct + Math.imul(Ut, gr) | 0, Et = Et + Math.imul(Ut, _r) | 0, yt = yt + Math.imul(jt, Cr) | 0, ct = ct + Math.imul(jt, Ft) | 0, ct = ct + Math.imul(Ot, Cr) | 0, Et = Et + Math.imul(Ot, Ft) | 0;
        var qr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, yt = Math.imul(ur, zt), ct = Math.imul(ur, Vt), ct = ct + Math.imul(hr, zt) | 0, Et = Math.imul(hr, Vt), yt = yt + Math.imul(Qt, xr) | 0, ct = ct + Math.imul(Qt, cr) | 0, ct = ct + Math.imul(rr, xr) | 0, Et = Et + Math.imul(rr, cr) | 0, yt = yt + Math.imul(It, gr) | 0, ct = ct + Math.imul(It, _r) | 0, ct = ct + Math.imul(Mt, gr) | 0, Et = Et + Math.imul(Mt, _r) | 0, yt = yt + Math.imul(Tt, Cr) | 0, ct = ct + Math.imul(Tt, Ft) | 0, ct = ct + Math.imul(Ut, Cr) | 0, Et = Et + Math.imul(Ut, Ft) | 0, yt = yt + Math.imul(jt, Dt) | 0, ct = ct + Math.imul(jt, Ht) | 0, ct = ct + Math.imul(Ot, Dt) | 0, Et = Et + Math.imul(Ot, Ht) | 0;
        var Fr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, yt = Math.imul(Rr, zt), ct = Math.imul(Rr, Vt), ct = ct + Math.imul(lr, zt) | 0, Et = Math.imul(lr, Vt), yt = yt + Math.imul(ur, xr) | 0, ct = ct + Math.imul(ur, cr) | 0, ct = ct + Math.imul(hr, xr) | 0, Et = Et + Math.imul(hr, cr) | 0, yt = yt + Math.imul(Qt, gr) | 0, ct = ct + Math.imul(Qt, _r) | 0, ct = ct + Math.imul(rr, gr) | 0, Et = Et + Math.imul(rr, _r) | 0, yt = yt + Math.imul(It, Cr) | 0, ct = ct + Math.imul(It, Ft) | 0, ct = ct + Math.imul(Mt, Cr) | 0, Et = Et + Math.imul(Mt, Ft) | 0, yt = yt + Math.imul(Tt, Dt) | 0, ct = ct + Math.imul(Tt, Ht) | 0, ct = ct + Math.imul(Ut, Dt) | 0, Et = Et + Math.imul(Ut, Ht) | 0, yt = yt + Math.imul(jt, Zt) | 0, ct = ct + Math.imul(jt, tr) | 0, ct = ct + Math.imul(Ot, Zt) | 0, Et = Et + Math.imul(Ot, tr) | 0;
        var Ur = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, yt = Math.imul(Br, zt), ct = Math.imul(Br, Vt), ct = ct + Math.imul(dr, zt) | 0, Et = Math.imul(dr, Vt), yt = yt + Math.imul(Rr, xr) | 0, ct = ct + Math.imul(Rr, cr) | 0, ct = ct + Math.imul(lr, xr) | 0, Et = Et + Math.imul(lr, cr) | 0, yt = yt + Math.imul(ur, gr) | 0, ct = ct + Math.imul(ur, _r) | 0, ct = ct + Math.imul(hr, gr) | 0, Et = Et + Math.imul(hr, _r) | 0, yt = yt + Math.imul(Qt, Cr) | 0, ct = ct + Math.imul(Qt, Ft) | 0, ct = ct + Math.imul(rr, Cr) | 0, Et = Et + Math.imul(rr, Ft) | 0, yt = yt + Math.imul(It, Dt) | 0, ct = ct + Math.imul(It, Ht) | 0, ct = ct + Math.imul(Mt, Dt) | 0, Et = Et + Math.imul(Mt, Ht) | 0, yt = yt + Math.imul(Tt, Zt) | 0, ct = ct + Math.imul(Tt, tr) | 0, ct = ct + Math.imul(Ut, Zt) | 0, Et = Et + Math.imul(Ut, tr) | 0, yt = yt + Math.imul(jt, fr) | 0, ct = ct + Math.imul(jt, ir) | 0, ct = ct + Math.imul(Ot, fr) | 0, Et = Et + Math.imul(Ot, ir) | 0;
        var jr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, yt = Math.imul(Mr, zt), ct = Math.imul(Mr, Vt), ct = ct + Math.imul(br, zt) | 0, Et = Math.imul(br, Vt), yt = yt + Math.imul(Br, xr) | 0, ct = ct + Math.imul(Br, cr) | 0, ct = ct + Math.imul(dr, xr) | 0, Et = Et + Math.imul(dr, cr) | 0, yt = yt + Math.imul(Rr, gr) | 0, ct = ct + Math.imul(Rr, _r) | 0, ct = ct + Math.imul(lr, gr) | 0, Et = Et + Math.imul(lr, _r) | 0, yt = yt + Math.imul(ur, Cr) | 0, ct = ct + Math.imul(ur, Ft) | 0, ct = ct + Math.imul(hr, Cr) | 0, Et = Et + Math.imul(hr, Ft) | 0, yt = yt + Math.imul(Qt, Dt) | 0, ct = ct + Math.imul(Qt, Ht) | 0, ct = ct + Math.imul(rr, Dt) | 0, Et = Et + Math.imul(rr, Ht) | 0, yt = yt + Math.imul(It, Zt) | 0, ct = ct + Math.imul(It, tr) | 0, ct = ct + Math.imul(Mt, Zt) | 0, Et = Et + Math.imul(Mt, tr) | 0, yt = yt + Math.imul(Tt, fr) | 0, ct = ct + Math.imul(Tt, ir) | 0, ct = ct + Math.imul(Ut, fr) | 0, Et = Et + Math.imul(Ut, ir) | 0, yt = yt + Math.imul(jt, wr) | 0, ct = ct + Math.imul(jt, sr) | 0, ct = ct + Math.imul(Ot, wr) | 0, Et = Et + Math.imul(Ot, sr) | 0;
        var Dr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, yt = Math.imul(Or, zt), ct = Math.imul(Or, Vt), ct = ct + Math.imul(Rt, zt) | 0, Et = Math.imul(Rt, Vt), yt = yt + Math.imul(Mr, xr) | 0, ct = ct + Math.imul(Mr, cr) | 0, ct = ct + Math.imul(br, xr) | 0, Et = Et + Math.imul(br, cr) | 0, yt = yt + Math.imul(Br, gr) | 0, ct = ct + Math.imul(Br, _r) | 0, ct = ct + Math.imul(dr, gr) | 0, Et = Et + Math.imul(dr, _r) | 0, yt = yt + Math.imul(Rr, Cr) | 0, ct = ct + Math.imul(Rr, Ft) | 0, ct = ct + Math.imul(lr, Cr) | 0, Et = Et + Math.imul(lr, Ft) | 0, yt = yt + Math.imul(ur, Dt) | 0, ct = ct + Math.imul(ur, Ht) | 0, ct = ct + Math.imul(hr, Dt) | 0, Et = Et + Math.imul(hr, Ht) | 0, yt = yt + Math.imul(Qt, Zt) | 0, ct = ct + Math.imul(Qt, tr) | 0, ct = ct + Math.imul(rr, Zt) | 0, Et = Et + Math.imul(rr, tr) | 0, yt = yt + Math.imul(It, fr) | 0, ct = ct + Math.imul(It, ir) | 0, ct = ct + Math.imul(Mt, fr) | 0, Et = Et + Math.imul(Mt, ir) | 0, yt = yt + Math.imul(Tt, wr) | 0, ct = ct + Math.imul(Tt, sr) | 0, ct = ct + Math.imul(Ut, wr) | 0, Et = Et + Math.imul(Ut, sr) | 0, yt = yt + Math.imul(jt, Jt) | 0, ct = ct + Math.imul(jt, er) | 0, ct = ct + Math.imul(Ot, Jt) | 0, Et = Et + Math.imul(Ot, er) | 0;
        var Lr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, yt = Math.imul(St, zt), ct = Math.imul(St, Vt), ct = ct + Math.imul(Ct, zt) | 0, Et = Math.imul(Ct, Vt), yt = yt + Math.imul(Or, xr) | 0, ct = ct + Math.imul(Or, cr) | 0, ct = ct + Math.imul(Rt, xr) | 0, Et = Et + Math.imul(Rt, cr) | 0, yt = yt + Math.imul(Mr, gr) | 0, ct = ct + Math.imul(Mr, _r) | 0, ct = ct + Math.imul(br, gr) | 0, Et = Et + Math.imul(br, _r) | 0, yt = yt + Math.imul(Br, Cr) | 0, ct = ct + Math.imul(Br, Ft) | 0, ct = ct + Math.imul(dr, Cr) | 0, Et = Et + Math.imul(dr, Ft) | 0, yt = yt + Math.imul(Rr, Dt) | 0, ct = ct + Math.imul(Rr, Ht) | 0, ct = ct + Math.imul(lr, Dt) | 0, Et = Et + Math.imul(lr, Ht) | 0, yt = yt + Math.imul(ur, Zt) | 0, ct = ct + Math.imul(ur, tr) | 0, ct = ct + Math.imul(hr, Zt) | 0, Et = Et + Math.imul(hr, tr) | 0, yt = yt + Math.imul(Qt, fr) | 0, ct = ct + Math.imul(Qt, ir) | 0, ct = ct + Math.imul(rr, fr) | 0, Et = Et + Math.imul(rr, ir) | 0, yt = yt + Math.imul(It, wr) | 0, ct = ct + Math.imul(It, sr) | 0, ct = ct + Math.imul(Mt, wr) | 0, Et = Et + Math.imul(Mt, sr) | 0, yt = yt + Math.imul(Tt, Jt) | 0, ct = ct + Math.imul(Tt, er) | 0, ct = ct + Math.imul(Ut, Jt) | 0, Et = Et + Math.imul(Ut, er) | 0, yt = yt + Math.imul(jt, vr) | 0, ct = ct + Math.imul(jt, Er) | 0, ct = ct + Math.imul(Ot, vr) | 0, Et = Et + Math.imul(Ot, Er) | 0;
        var Hr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, yt = Math.imul(St, xr), ct = Math.imul(St, cr), ct = ct + Math.imul(Ct, xr) | 0, Et = Math.imul(Ct, cr), yt = yt + Math.imul(Or, gr) | 0, ct = ct + Math.imul(Or, _r) | 0, ct = ct + Math.imul(Rt, gr) | 0, Et = Et + Math.imul(Rt, _r) | 0, yt = yt + Math.imul(Mr, Cr) | 0, ct = ct + Math.imul(Mr, Ft) | 0, ct = ct + Math.imul(br, Cr) | 0, Et = Et + Math.imul(br, Ft) | 0, yt = yt + Math.imul(Br, Dt) | 0, ct = ct + Math.imul(Br, Ht) | 0, ct = ct + Math.imul(dr, Dt) | 0, Et = Et + Math.imul(dr, Ht) | 0, yt = yt + Math.imul(Rr, Zt) | 0, ct = ct + Math.imul(Rr, tr) | 0, ct = ct + Math.imul(lr, Zt) | 0, Et = Et + Math.imul(lr, tr) | 0, yt = yt + Math.imul(ur, fr) | 0, ct = ct + Math.imul(ur, ir) | 0, ct = ct + Math.imul(hr, fr) | 0, Et = Et + Math.imul(hr, ir) | 0, yt = yt + Math.imul(Qt, wr) | 0, ct = ct + Math.imul(Qt, sr) | 0, ct = ct + Math.imul(rr, wr) | 0, Et = Et + Math.imul(rr, sr) | 0, yt = yt + Math.imul(It, Jt) | 0, ct = ct + Math.imul(It, er) | 0, ct = ct + Math.imul(Mt, Jt) | 0, Et = Et + Math.imul(Mt, er) | 0, yt = yt + Math.imul(Tt, vr) | 0, ct = ct + Math.imul(Tt, Er) | 0, ct = ct + Math.imul(Ut, vr) | 0, Et = Et + Math.imul(Ut, Er) | 0;
        var Wr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, yt = Math.imul(St, gr), ct = Math.imul(St, _r), ct = ct + Math.imul(Ct, gr) | 0, Et = Math.imul(Ct, _r), yt = yt + Math.imul(Or, Cr) | 0, ct = ct + Math.imul(Or, Ft) | 0, ct = ct + Math.imul(Rt, Cr) | 0, Et = Et + Math.imul(Rt, Ft) | 0, yt = yt + Math.imul(Mr, Dt) | 0, ct = ct + Math.imul(Mr, Ht) | 0, ct = ct + Math.imul(br, Dt) | 0, Et = Et + Math.imul(br, Ht) | 0, yt = yt + Math.imul(Br, Zt) | 0, ct = ct + Math.imul(Br, tr) | 0, ct = ct + Math.imul(dr, Zt) | 0, Et = Et + Math.imul(dr, tr) | 0, yt = yt + Math.imul(Rr, fr) | 0, ct = ct + Math.imul(Rr, ir) | 0, ct = ct + Math.imul(lr, fr) | 0, Et = Et + Math.imul(lr, ir) | 0, yt = yt + Math.imul(ur, wr) | 0, ct = ct + Math.imul(ur, sr) | 0, ct = ct + Math.imul(hr, wr) | 0, Et = Et + Math.imul(hr, sr) | 0, yt = yt + Math.imul(Qt, Jt) | 0, ct = ct + Math.imul(Qt, er) | 0, ct = ct + Math.imul(rr, Jt) | 0, Et = Et + Math.imul(rr, er) | 0, yt = yt + Math.imul(It, vr) | 0, ct = ct + Math.imul(It, Er) | 0, ct = ct + Math.imul(Mt, vr) | 0, Et = Et + Math.imul(Mt, Er) | 0;
        var Gr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, yt = Math.imul(St, Cr), ct = Math.imul(St, Ft), ct = ct + Math.imul(Ct, Cr) | 0, Et = Math.imul(Ct, Ft), yt = yt + Math.imul(Or, Dt) | 0, ct = ct + Math.imul(Or, Ht) | 0, ct = ct + Math.imul(Rt, Dt) | 0, Et = Et + Math.imul(Rt, Ht) | 0, yt = yt + Math.imul(Mr, Zt) | 0, ct = ct + Math.imul(Mr, tr) | 0, ct = ct + Math.imul(br, Zt) | 0, Et = Et + Math.imul(br, tr) | 0, yt = yt + Math.imul(Br, fr) | 0, ct = ct + Math.imul(Br, ir) | 0, ct = ct + Math.imul(dr, fr) | 0, Et = Et + Math.imul(dr, ir) | 0, yt = yt + Math.imul(Rr, wr) | 0, ct = ct + Math.imul(Rr, sr) | 0, ct = ct + Math.imul(lr, wr) | 0, Et = Et + Math.imul(lr, sr) | 0, yt = yt + Math.imul(ur, Jt) | 0, ct = ct + Math.imul(ur, er) | 0, ct = ct + Math.imul(hr, Jt) | 0, Et = Et + Math.imul(hr, er) | 0, yt = yt + Math.imul(Qt, vr) | 0, ct = ct + Math.imul(Qt, Er) | 0, ct = ct + Math.imul(rr, vr) | 0, Et = Et + Math.imul(rr, Er) | 0;
        var zr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, yt = Math.imul(St, Dt), ct = Math.imul(St, Ht), ct = ct + Math.imul(Ct, Dt) | 0, Et = Math.imul(Ct, Ht), yt = yt + Math.imul(Or, Zt) | 0, ct = ct + Math.imul(Or, tr) | 0, ct = ct + Math.imul(Rt, Zt) | 0, Et = Et + Math.imul(Rt, tr) | 0, yt = yt + Math.imul(Mr, fr) | 0, ct = ct + Math.imul(Mr, ir) | 0, ct = ct + Math.imul(br, fr) | 0, Et = Et + Math.imul(br, ir) | 0, yt = yt + Math.imul(Br, wr) | 0, ct = ct + Math.imul(Br, sr) | 0, ct = ct + Math.imul(dr, wr) | 0, Et = Et + Math.imul(dr, sr) | 0, yt = yt + Math.imul(Rr, Jt) | 0, ct = ct + Math.imul(Rr, er) | 0, ct = ct + Math.imul(lr, Jt) | 0, Et = Et + Math.imul(lr, er) | 0, yt = yt + Math.imul(ur, vr) | 0, ct = ct + Math.imul(ur, Er) | 0, ct = ct + Math.imul(hr, vr) | 0, Et = Et + Math.imul(hr, Er) | 0;
        var Vr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, yt = Math.imul(St, Zt), ct = Math.imul(St, tr), ct = ct + Math.imul(Ct, Zt) | 0, Et = Math.imul(Ct, tr), yt = yt + Math.imul(Or, fr) | 0, ct = ct + Math.imul(Or, ir) | 0, ct = ct + Math.imul(Rt, fr) | 0, Et = Et + Math.imul(Rt, ir) | 0, yt = yt + Math.imul(Mr, wr) | 0, ct = ct + Math.imul(Mr, sr) | 0, ct = ct + Math.imul(br, wr) | 0, Et = Et + Math.imul(br, sr) | 0, yt = yt + Math.imul(Br, Jt) | 0, ct = ct + Math.imul(Br, er) | 0, ct = ct + Math.imul(dr, Jt) | 0, Et = Et + Math.imul(dr, er) | 0, yt = yt + Math.imul(Rr, vr) | 0, ct = ct + Math.imul(Rr, Er) | 0, ct = ct + Math.imul(lr, vr) | 0, Et = Et + Math.imul(lr, Er) | 0;
        var Xr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, yt = Math.imul(St, fr), ct = Math.imul(St, ir), ct = ct + Math.imul(Ct, fr) | 0, Et = Math.imul(Ct, ir), yt = yt + Math.imul(Or, wr) | 0, ct = ct + Math.imul(Or, sr) | 0, ct = ct + Math.imul(Rt, wr) | 0, Et = Et + Math.imul(Rt, sr) | 0, yt = yt + Math.imul(Mr, Jt) | 0, ct = ct + Math.imul(Mr, er) | 0, ct = ct + Math.imul(br, Jt) | 0, Et = Et + Math.imul(br, er) | 0, yt = yt + Math.imul(Br, vr) | 0, ct = ct + Math.imul(Br, Er) | 0, ct = ct + Math.imul(dr, vr) | 0, Et = Et + Math.imul(dr, Er) | 0;
        var Yr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, yt = Math.imul(St, wr), ct = Math.imul(St, sr), ct = ct + Math.imul(Ct, wr) | 0, Et = Math.imul(Ct, sr), yt = yt + Math.imul(Or, Jt) | 0, ct = ct + Math.imul(Or, er) | 0, ct = ct + Math.imul(Rt, Jt) | 0, Et = Et + Math.imul(Rt, er) | 0, yt = yt + Math.imul(Mr, vr) | 0, ct = ct + Math.imul(Mr, Er) | 0, ct = ct + Math.imul(br, vr) | 0, Et = Et + Math.imul(br, Er) | 0;
        var Jr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, yt = Math.imul(St, Jt), ct = Math.imul(St, er), ct = ct + Math.imul(Ct, Jt) | 0, Et = Math.imul(Ct, er), yt = yt + Math.imul(Or, vr) | 0, ct = ct + Math.imul(Or, Er) | 0, ct = ct + Math.imul(Rt, vr) | 0, Et = Et + Math.imul(Rt, Er) | 0;
        var Qr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (Et + (ct >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, yt = Math.imul(St, vr), ct = Math.imul(St, Er), ct = ct + Math.imul(Ct, vr) | 0, Et = Math.imul(Ct, Er);
        var Zr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        return ft = (Et + (ct >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, pt[0] = Tr, pt[1] = Pr, pt[2] = Nr, pt[3] = qr, pt[4] = Fr, pt[5] = Ur, pt[6] = jr, pt[7] = Dr, pt[8] = Lr, pt[9] = Hr, pt[10] = Wr, pt[11] = Gr, pt[12] = zr, pt[13] = Vr, pt[14] = Xr, pt[15] = Yr, pt[16] = Jr, pt[17] = Qr, pt[18] = Zr, ft !== 0 && (pt[19] = ft, ot.length++), ot;
      };
      Math.imul || (dt = ht);
      function vt(rt, pe, nt) {
        nt.negative = pe.negative ^ rt.negative, nt.length = rt.length + pe.length;
        for (var ot = 0, st = 0, ut = 0; ut < nt.length - 1; ut++) {
          var pt = st;
          st = 0;
          for (var ft = ot & 67108863, yt = Math.min(ut, pe.length - 1), ct = Math.max(0, ut - rt.length + 1); ct <= yt; ct++) {
            var Et = ut - ct, Nt = rt.words[Et] | 0, jt = pe.words[ct] | 0, Ot = Nt * jt, Bt = Ot & 67108863;
            pt = pt + (Ot / 67108864 | 0) | 0, Bt = Bt + ft | 0, ft = Bt & 67108863, pt = pt + (Bt >>> 26) | 0, st += pt >>> 26, pt &= 67108863;
          }
          nt.words[ut] = ft, ot = pt, pt = st;
        }
        return ot !== 0 ? nt.words[ut] = ot : nt.length--, nt._strip();
      }
      function mt(rt, pe, nt) {
        return vt(rt, pe, nt);
      }
      W.prototype.mulTo = function(pe, nt) {
        var ot, st = this.length + pe.length;
        return this.length === 10 && pe.length === 10 ? ot = dt(this, pe, nt) : st < 63 ? ot = ht(this, pe, nt) : st < 1024 ? ot = vt(this, pe, nt) : ot = mt(this, pe, nt), ot;
      }, W.prototype.mul = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), this.mulTo(pe, nt);
      }, W.prototype.mulf = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), mt(this, pe, nt);
      }, W.prototype.imul = function(pe) {
        return this.clone().mulTo(pe, this);
      }, W.prototype.imuln = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(typeof pe == "number"), K(pe < 67108864);
        for (var ot = 0, st = 0; st < this.length; st++) {
          var ut = (this.words[st] | 0) * pe, pt = (ut & 67108863) + (ot & 67108863);
          ot >>= 26, ot += ut / 67108864 | 0, ot += pt >>> 26, this.words[st] = pt & 67108863;
        }
        return ot !== 0 && (this.words[st] = ot, this.length++), nt ? this.ineg() : this;
      }, W.prototype.muln = function(pe) {
        return this.clone().imuln(pe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(pe) {
        var nt = lt(pe);
        if (nt.length === 0) return new W(1);
        for (var ot = this, st = 0; st < nt.length && nt[st] === 0; st++, ot = ot.sqr())
          ;
        if (++st < nt.length)
          for (var ut = ot.sqr(); st < nt.length; st++, ut = ut.sqr())
            nt[st] !== 0 && (ot = ot.mul(ut));
        return ot;
      }, W.prototype.iushln = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, ot = (pe - nt) / 26, st = 67108863 >>> 26 - nt << 26 - nt, ut;
        if (nt !== 0) {
          var pt = 0;
          for (ut = 0; ut < this.length; ut++) {
            var ft = this.words[ut] & st, yt = (this.words[ut] | 0) - ft << nt;
            this.words[ut] = yt | pt, pt = ft >>> 26 - nt;
          }
          pt && (this.words[ut] = pt, this.length++);
        }
        if (ot !== 0) {
          for (ut = this.length - 1; ut >= 0; ut--)
            this.words[ut + ot] = this.words[ut];
          for (ut = 0; ut < ot; ut++)
            this.words[ut] = 0;
          this.length += ot;
        }
        return this._strip();
      }, W.prototype.ishln = function(pe) {
        return K(this.negative === 0), this.iushln(pe);
      }, W.prototype.iushrn = function(pe, nt, ot) {
        K(typeof pe == "number" && pe >= 0);
        var st;
        nt ? st = (nt - nt % 26) / 26 : st = 0;
        var ut = pe % 26, pt = Math.min((pe - ut) / 26, this.length), ft = 67108863 ^ 67108863 >>> ut << ut, yt = ot;
        if (st -= pt, st = Math.max(0, st), yt) {
          for (var ct = 0; ct < pt; ct++)
            yt.words[ct] = this.words[ct];
          yt.length = pt;
        }
        if (pt !== 0) if (this.length > pt)
          for (this.length -= pt, ct = 0; ct < this.length; ct++)
            this.words[ct] = this.words[ct + pt];
        else
          this.words[0] = 0, this.length = 1;
        var Et = 0;
        for (ct = this.length - 1; ct >= 0 && (Et !== 0 || ct >= st); ct--) {
          var Nt = this.words[ct] | 0;
          this.words[ct] = Et << 26 - ut | Nt >>> ut, Et = Nt & ft;
        }
        return yt && Et !== 0 && (yt.words[yt.length++] = Et), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, W.prototype.ishrn = function(pe, nt, ot) {
        return K(this.negative === 0), this.iushrn(pe, nt, ot);
      }, W.prototype.shln = function(pe) {
        return this.clone().ishln(pe);
      }, W.prototype.ushln = function(pe) {
        return this.clone().iushln(pe);
      }, W.prototype.shrn = function(pe) {
        return this.clone().ishrn(pe);
      }, W.prototype.ushrn = function(pe) {
        return this.clone().iushrn(pe);
      }, W.prototype.testn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, ot = (pe - nt) / 26, st = 1 << nt;
        if (this.length <= ot) return !1;
        var ut = this.words[ot];
        return !!(ut & st);
      }, W.prototype.imaskn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, ot = (pe - nt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ot)
          return this;
        if (nt !== 0 && ot++, this.length = Math.min(ot, this.length), nt !== 0) {
          var st = 67108863 ^ 67108863 >>> nt << nt;
          this.words[this.length - 1] &= st;
        }
        return this._strip();
      }, W.prototype.maskn = function(pe) {
        return this.clone().imaskn(pe);
      }, W.prototype.iaddn = function(pe) {
        return K(typeof pe == "number"), K(pe < 67108864), pe < 0 ? this.isubn(-pe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= pe ? (this.words[0] = pe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(pe), this.negative = 1, this) : this._iaddn(pe);
      }, W.prototype._iaddn = function(pe) {
        this.words[0] += pe;
        for (var nt = 0; nt < this.length && this.words[nt] >= 67108864; nt++)
          this.words[nt] -= 67108864, nt === this.length - 1 ? this.words[nt + 1] = 1 : this.words[nt + 1]++;
        return this.length = Math.max(this.length, nt + 1), this;
      }, W.prototype.isubn = function(pe) {
        if (K(typeof pe == "number"), K(pe < 67108864), pe < 0) return this.iaddn(-pe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(pe), this.negative = 1, this;
        if (this.words[0] -= pe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var nt = 0; nt < this.length && this.words[nt] < 0; nt++)
            this.words[nt] += 67108864, this.words[nt + 1] -= 1;
        return this._strip();
      }, W.prototype.addn = function(pe) {
        return this.clone().iaddn(pe);
      }, W.prototype.subn = function(pe) {
        return this.clone().isubn(pe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(pe, nt, ot) {
        var st = pe.length + ot, ut;
        this._expand(st);
        var pt, ft = 0;
        for (ut = 0; ut < pe.length; ut++) {
          pt = (this.words[ut + ot] | 0) + ft;
          var yt = (pe.words[ut] | 0) * nt;
          pt -= yt & 67108863, ft = (pt >> 26) - (yt / 67108864 | 0), this.words[ut + ot] = pt & 67108863;
        }
        for (; ut < this.length - ot; ut++)
          pt = (this.words[ut + ot] | 0) + ft, ft = pt >> 26, this.words[ut + ot] = pt & 67108863;
        if (ft === 0) return this._strip();
        for (K(ft === -1), ft = 0, ut = 0; ut < this.length; ut++)
          pt = -(this.words[ut] | 0) + ft, ft = pt >> 26, this.words[ut] = pt & 67108863;
        return this.negative = 1, this._strip();
      }, W.prototype._wordDiv = function(pe, nt) {
        var ot = this.length - pe.length, st = this.clone(), ut = pe, pt = ut.words[ut.length - 1] | 0, ft = this._countBits(pt);
        ot = 26 - ft, ot !== 0 && (ut = ut.ushln(ot), st.iushln(ot), pt = ut.words[ut.length - 1] | 0);
        var yt = st.length - ut.length, ct;
        if (nt !== "mod") {
          ct = new W(null), ct.length = yt + 1, ct.words = new Array(ct.length);
          for (var Et = 0; Et < ct.length; Et++)
            ct.words[Et] = 0;
        }
        var Nt = st.clone()._ishlnsubmul(ut, 1, yt);
        Nt.negative === 0 && (st = Nt, ct && (ct.words[yt] = 1));
        for (var jt = yt - 1; jt >= 0; jt--) {
          var Ot = (st.words[ut.length + jt] | 0) * 67108864 + (st.words[ut.length + jt - 1] | 0);
          for (Ot = Math.min(Ot / pt | 0, 67108863), st._ishlnsubmul(ut, Ot, jt); st.negative !== 0; )
            Ot--, st.negative = 0, st._ishlnsubmul(ut, 1, jt), st.isZero() || (st.negative ^= 1);
          ct && (ct.words[jt] = Ot);
        }
        return ct && ct._strip(), st._strip(), nt !== "div" && ot !== 0 && st.iushrn(ot), {
          div: ct || null,
          mod: st
        };
      }, W.prototype.divmod = function(pe, nt, ot) {
        if (K(!pe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var st, ut, pt;
        return this.negative !== 0 && pe.negative === 0 ? (pt = this.neg().divmod(pe, nt), nt !== "mod" && (st = pt.div.neg()), nt !== "div" && (ut = pt.mod.neg(), ot && ut.negative !== 0 && ut.iadd(pe)), {
          div: st,
          mod: ut
        }) : this.negative === 0 && pe.negative !== 0 ? (pt = this.divmod(pe.neg(), nt), nt !== "mod" && (st = pt.div.neg()), {
          div: st,
          mod: pt.mod
        }) : this.negative & pe.negative ? (pt = this.neg().divmod(pe.neg(), nt), nt !== "div" && (ut = pt.mod.neg(), ot && ut.negative !== 0 && ut.isub(pe)), {
          div: pt.div,
          mod: ut
        }) : pe.length > this.length || this.cmp(pe) < 0 ? {
          div: new W(0),
          mod: this
        } : pe.length === 1 ? nt === "div" ? {
          div: this.divn(pe.words[0]),
          mod: null
        } : nt === "mod" ? {
          div: null,
          mod: new W(this.modrn(pe.words[0]))
        } : {
          div: this.divn(pe.words[0]),
          mod: new W(this.modrn(pe.words[0]))
        } : this._wordDiv(pe, nt);
      }, W.prototype.div = function(pe) {
        return this.divmod(pe, "div", !1).div;
      }, W.prototype.mod = function(pe) {
        return this.divmod(pe, "mod", !1).mod;
      }, W.prototype.umod = function(pe) {
        return this.divmod(pe, "mod", !0).mod;
      }, W.prototype.divRound = function(pe) {
        var nt = this.divmod(pe);
        if (nt.mod.isZero()) return nt.div;
        var ot = nt.div.negative !== 0 ? nt.mod.isub(pe) : nt.mod, st = pe.ushrn(1), ut = pe.andln(1), pt = ot.cmp(st);
        return pt < 0 || ut === 1 && pt === 0 ? nt.div : nt.div.negative !== 0 ? nt.div.isubn(1) : nt.div.iaddn(1);
      }, W.prototype.modrn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var ot = (1 << 26) % pe, st = 0, ut = this.length - 1; ut >= 0; ut--)
          st = (ot * st + (this.words[ut] | 0)) % pe;
        return nt ? -st : st;
      }, W.prototype.modn = function(pe) {
        return this.modrn(pe);
      }, W.prototype.idivn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var ot = 0, st = this.length - 1; st >= 0; st--) {
          var ut = (this.words[st] | 0) + ot * 67108864;
          this.words[st] = ut / pe | 0, ot = ut % pe;
        }
        return this._strip(), nt ? this.ineg() : this;
      }, W.prototype.divn = function(pe) {
        return this.clone().idivn(pe);
      }, W.prototype.egcd = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, ot = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var st = new W(1), ut = new W(0), pt = new W(0), ft = new W(1), yt = 0; nt.isEven() && ot.isEven(); )
          nt.iushrn(1), ot.iushrn(1), ++yt;
        for (var ct = ot.clone(), Et = nt.clone(); !nt.isZero(); ) {
          for (var Nt = 0, jt = 1; !(nt.words[0] & jt) && Nt < 26; ++Nt, jt <<= 1) ;
          if (Nt > 0)
            for (nt.iushrn(Nt); Nt-- > 0; )
              (st.isOdd() || ut.isOdd()) && (st.iadd(ct), ut.isub(Et)), st.iushrn(1), ut.iushrn(1);
          for (var Ot = 0, Bt = 1; !(ot.words[0] & Bt) && Ot < 26; ++Ot, Bt <<= 1) ;
          if (Ot > 0)
            for (ot.iushrn(Ot); Ot-- > 0; )
              (pt.isOdd() || ft.isOdd()) && (pt.iadd(ct), ft.isub(Et)), pt.iushrn(1), ft.iushrn(1);
          nt.cmp(ot) >= 0 ? (nt.isub(ot), st.isub(pt), ut.isub(ft)) : (ot.isub(nt), pt.isub(st), ft.isub(ut));
        }
        return {
          a: pt,
          b: ft,
          gcd: ot.iushln(yt)
        };
      }, W.prototype._invmp = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, ot = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var st = new W(1), ut = new W(0), pt = ot.clone(); nt.cmpn(1) > 0 && ot.cmpn(1) > 0; ) {
          for (var ft = 0, yt = 1; !(nt.words[0] & yt) && ft < 26; ++ft, yt <<= 1) ;
          if (ft > 0)
            for (nt.iushrn(ft); ft-- > 0; )
              st.isOdd() && st.iadd(pt), st.iushrn(1);
          for (var ct = 0, Et = 1; !(ot.words[0] & Et) && ct < 26; ++ct, Et <<= 1) ;
          if (ct > 0)
            for (ot.iushrn(ct); ct-- > 0; )
              ut.isOdd() && ut.iadd(pt), ut.iushrn(1);
          nt.cmp(ot) >= 0 ? (nt.isub(ot), st.isub(ut)) : (ot.isub(nt), ut.isub(st));
        }
        var Nt;
        return nt.cmpn(1) === 0 ? Nt = st : Nt = ut, Nt.cmpn(0) < 0 && Nt.iadd(pe), Nt;
      }, W.prototype.gcd = function(pe) {
        if (this.isZero()) return pe.abs();
        if (pe.isZero()) return this.abs();
        var nt = this.clone(), ot = pe.clone();
        nt.negative = 0, ot.negative = 0;
        for (var st = 0; nt.isEven() && ot.isEven(); st++)
          nt.iushrn(1), ot.iushrn(1);
        do {
          for (; nt.isEven(); )
            nt.iushrn(1);
          for (; ot.isEven(); )
            ot.iushrn(1);
          var ut = nt.cmp(ot);
          if (ut < 0) {
            var pt = nt;
            nt = ot, ot = pt;
          } else if (ut === 0 || ot.cmpn(1) === 0)
            break;
          nt.isub(ot);
        } while (!0);
        return ot.iushln(st);
      }, W.prototype.invm = function(pe) {
        return this.egcd(pe).a.umod(pe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(pe) {
        return this.words[0] & pe;
      }, W.prototype.bincn = function(pe) {
        K(typeof pe == "number");
        var nt = pe % 26, ot = (pe - nt) / 26, st = 1 << nt;
        if (this.length <= ot)
          return this._expand(ot + 1), this.words[ot] |= st, this;
        for (var ut = st, pt = ot; ut !== 0 && pt < this.length; pt++) {
          var ft = this.words[pt] | 0;
          ft += ut, ut = ft >>> 26, ft &= 67108863, this.words[pt] = ft;
        }
        return ut !== 0 && (this.words[pt] = ut, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(pe) {
        var nt = pe < 0;
        if (this.negative !== 0 && !nt) return -1;
        if (this.negative === 0 && nt) return 1;
        this._strip();
        var ot;
        if (this.length > 1)
          ot = 1;
        else {
          nt && (pe = -pe), K(pe <= 67108863, "Number is too big");
          var st = this.words[0] | 0;
          ot = st === pe ? 0 : st < pe ? -1 : 1;
        }
        return this.negative !== 0 ? -ot | 0 : ot;
      }, W.prototype.cmp = function(pe) {
        if (this.negative !== 0 && pe.negative === 0) return -1;
        if (this.negative === 0 && pe.negative !== 0) return 1;
        var nt = this.ucmp(pe);
        return this.negative !== 0 ? -nt | 0 : nt;
      }, W.prototype.ucmp = function(pe) {
        if (this.length > pe.length) return 1;
        if (this.length < pe.length) return -1;
        for (var nt = 0, ot = this.length - 1; ot >= 0; ot--) {
          var st = this.words[ot] | 0, ut = pe.words[ot] | 0;
          if (st !== ut) {
            st < ut ? nt = -1 : st > ut && (nt = 1);
            break;
          }
        }
        return nt;
      }, W.prototype.gtn = function(pe) {
        return this.cmpn(pe) === 1;
      }, W.prototype.gt = function(pe) {
        return this.cmp(pe) === 1;
      }, W.prototype.gten = function(pe) {
        return this.cmpn(pe) >= 0;
      }, W.prototype.gte = function(pe) {
        return this.cmp(pe) >= 0;
      }, W.prototype.ltn = function(pe) {
        return this.cmpn(pe) === -1;
      }, W.prototype.lt = function(pe) {
        return this.cmp(pe) === -1;
      }, W.prototype.lten = function(pe) {
        return this.cmpn(pe) <= 0;
      }, W.prototype.lte = function(pe) {
        return this.cmp(pe) <= 0;
      }, W.prototype.eqn = function(pe) {
        return this.cmpn(pe) === 0;
      }, W.prototype.eq = function(pe) {
        return this.cmp(pe) === 0;
      }, W.red = function(pe) {
        return new wt(pe);
      }, W.prototype.toRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), pe.convertTo(this)._forceRed(pe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(pe) {
        return this.red = pe, this;
      }, W.prototype.forceRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(pe);
      }, W.prototype.redAdd = function(pe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, pe);
      }, W.prototype.redIAdd = function(pe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, pe);
      }, W.prototype.redSub = function(pe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, pe);
      }, W.prototype.redISub = function(pe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, pe);
      }, W.prototype.redShl = function(pe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, pe);
      }, W.prototype.redMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.mul(this, pe);
      }, W.prototype.redIMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.imul(this, pe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(pe) {
        return K(this.red && !pe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, pe);
      };
      var Pt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function $t(rt, pe) {
        this.name = rt, this.p = new W(pe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      $t.prototype._tmp = function() {
        var pe = new W(null);
        return pe.words = new Array(Math.ceil(this.n / 13)), pe;
      }, $t.prototype.ireduce = function(pe) {
        var nt = pe, ot;
        do
          this.split(nt, this.tmp), nt = this.imulK(nt), nt = nt.iadd(this.tmp), ot = nt.bitLength();
        while (ot > this.n);
        var st = ot < this.n ? -1 : nt.ucmp(this.p);
        return st === 0 ? (nt.words[0] = 0, nt.length = 1) : st > 0 ? nt.isub(this.p) : nt.strip !== void 0 ? nt.strip() : nt._strip(), nt;
      }, $t.prototype.split = function(pe, nt) {
        pe.iushrn(this.n, 0, nt);
      }, $t.prototype.imulK = function(pe) {
        return pe.imul(this.k);
      };
      function qt() {
        $t.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      J(qt, $t), qt.prototype.split = function(pe, nt) {
        for (var ot = 4194303, st = Math.min(pe.length, 9), ut = 0; ut < st; ut++)
          nt.words[ut] = pe.words[ut];
        if (nt.length = st, pe.length <= 9) {
          pe.words[0] = 0, pe.length = 1;
          return;
        }
        var pt = pe.words[9];
        for (nt.words[nt.length++] = pt & ot, ut = 10; ut < pe.length; ut++) {
          var ft = pe.words[ut] | 0;
          pe.words[ut - 10] = (ft & ot) << 4 | pt >>> 22, pt = ft;
        }
        pt >>>= 22, pe.words[ut - 10] = pt, pt === 0 && pe.length > 10 ? pe.length -= 10 : pe.length -= 9;
      }, qt.prototype.imulK = function(pe) {
        pe.words[pe.length] = 0, pe.words[pe.length + 1] = 0, pe.length += 2;
        for (var nt = 0, ot = 0; ot < pe.length; ot++) {
          var st = pe.words[ot] | 0;
          nt += st * 977, pe.words[ot] = nt & 67108863, nt = st * 64 + (nt / 67108864 | 0);
        }
        return pe.words[pe.length - 1] === 0 && (pe.length--, pe.words[pe.length - 1] === 0 && pe.length--), pe;
      };
      function At() {
        $t.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      J(At, $t);
      function bt() {
        $t.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      J(bt, $t);
      function xt() {
        $t.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      J(xt, $t), xt.prototype.imulK = function(pe) {
        for (var nt = 0, ot = 0; ot < pe.length; ot++) {
          var st = (pe.words[ot] | 0) * 19 + nt, ut = st & 67108863;
          st >>>= 26, pe.words[ot] = ut, nt = st;
        }
        return nt !== 0 && (pe.words[pe.length++] = nt), pe;
      }, W._prime = function(pe) {
        if (Pt[pe]) return Pt[pe];
        var nt;
        if (pe === "k256")
          nt = new qt();
        else if (pe === "p224")
          nt = new At();
        else if (pe === "p192")
          nt = new bt();
        else if (pe === "p25519")
          nt = new xt();
        else
          throw new Error("Unknown prime " + pe);
        return Pt[pe] = nt, nt;
      };
      function wt(rt) {
        if (typeof rt == "string") {
          var pe = W._prime(rt);
          this.m = pe.p, this.prime = pe;
        } else
          K(rt.gtn(1), "modulus must be greater than 1"), this.m = rt, this.prime = null;
      }
      wt.prototype._verify1 = function(pe) {
        K(pe.negative === 0, "red works only with positives"), K(pe.red, "red works only with red numbers");
      }, wt.prototype._verify2 = function(pe, nt) {
        K((pe.negative | nt.negative) === 0, "red works only with positives"), K(
          pe.red && pe.red === nt.red,
          "red works only with red numbers"
        );
      }, wt.prototype.imod = function(pe) {
        return this.prime ? this.prime.ireduce(pe)._forceRed(this) : (re(pe, pe.umod(this.m)._forceRed(this)), pe);
      }, wt.prototype.neg = function(pe) {
        return pe.isZero() ? pe.clone() : this.m.sub(pe)._forceRed(this);
      }, wt.prototype.add = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.add(nt);
        return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot._forceRed(this);
      }, wt.prototype.iadd = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.iadd(nt);
        return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot;
      }, wt.prototype.sub = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.sub(nt);
        return ot.cmpn(0) < 0 && ot.iadd(this.m), ot._forceRed(this);
      }, wt.prototype.isub = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.isub(nt);
        return ot.cmpn(0) < 0 && ot.iadd(this.m), ot;
      }, wt.prototype.shl = function(pe, nt) {
        return this._verify1(pe), this.imod(pe.ushln(nt));
      }, wt.prototype.imul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.imul(nt));
      }, wt.prototype.mul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.mul(nt));
      }, wt.prototype.isqr = function(pe) {
        return this.imul(pe, pe.clone());
      }, wt.prototype.sqr = function(pe) {
        return this.mul(pe, pe);
      }, wt.prototype.sqrt = function(pe) {
        if (pe.isZero()) return pe.clone();
        var nt = this.m.andln(3);
        if (K(nt % 2 === 1), nt === 3) {
          var ot = this.m.add(new W(1)).iushrn(2);
          return this.pow(pe, ot);
        }
        for (var st = this.m.subn(1), ut = 0; !st.isZero() && st.andln(1) === 0; )
          ut++, st.iushrn(1);
        K(!st.isZero());
        var pt = new W(1).toRed(this), ft = pt.redNeg(), yt = this.m.subn(1).iushrn(1), ct = this.m.bitLength();
        for (ct = new W(2 * ct * ct).toRed(this); this.pow(ct, yt).cmp(ft) !== 0; )
          ct.redIAdd(ft);
        for (var Et = this.pow(ct, st), Nt = this.pow(pe, st.addn(1).iushrn(1)), jt = this.pow(pe, st), Ot = ut; jt.cmp(pt) !== 0; ) {
          for (var Bt = jt, Tt = 0; Bt.cmp(pt) !== 0; Tt++)
            Bt = Bt.redSqr();
          K(Tt < Ot);
          var Ut = this.pow(Et, new W(1).iushln(Ot - Tt - 1));
          Nt = Nt.redMul(Ut), Et = Ut.redSqr(), jt = jt.redMul(Et), Ot = Tt;
        }
        return Nt;
      }, wt.prototype.invm = function(pe) {
        var nt = pe._invmp(this.m);
        return nt.negative !== 0 ? (nt.negative = 0, this.imod(nt).redNeg()) : this.imod(nt);
      }, wt.prototype.pow = function(pe, nt) {
        if (nt.isZero()) return new W(1).toRed(this);
        if (nt.cmpn(1) === 0) return pe.clone();
        var ot = 4, st = new Array(1 << ot);
        st[0] = new W(1).toRed(this), st[1] = pe;
        for (var ut = 2; ut < st.length; ut++)
          st[ut] = this.mul(st[ut - 1], pe);
        var pt = st[0], ft = 0, yt = 0, ct = nt.bitLength() % 26;
        for (ct === 0 && (ct = 26), ut = nt.length - 1; ut >= 0; ut--) {
          for (var Et = nt.words[ut], Nt = ct - 1; Nt >= 0; Nt--) {
            var jt = Et >> Nt & 1;
            if (pt !== st[0] && (pt = this.sqr(pt)), jt === 0 && ft === 0) {
              yt = 0;
              continue;
            }
            ft <<= 1, ft |= jt, yt++, !(yt !== ot && (ut !== 0 || Nt !== 0)) && (pt = this.mul(pt, st[ft]), yt = 0, ft = 0);
          }
          ct = 26;
        }
        return pt;
      }, wt.prototype.convertTo = function(pe) {
        var nt = pe.umod(this.m);
        return nt === pe ? nt.clone() : nt;
      }, wt.prototype.convertFrom = function(pe) {
        var nt = pe.clone();
        return nt.red = null, nt;
      }, W.mont = function(pe) {
        return new Oe(pe);
      };
      function Oe(rt) {
        wt.call(this, rt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      J(Oe, wt), Oe.prototype.convertTo = function(pe) {
        return this.imod(pe.ushln(this.shift));
      }, Oe.prototype.convertFrom = function(pe) {
        var nt = this.imod(pe.mul(this.rinv));
        return nt.red = null, nt;
      }, Oe.prototype.imul = function(pe, nt) {
        if (pe.isZero() || nt.isZero())
          return pe.words[0] = 0, pe.length = 1, pe;
        var ot = pe.imul(nt), st = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ut = ot.isub(st).iushrn(this.shift), pt = ut;
        return ut.cmp(this.m) >= 0 ? pt = ut.isub(this.m) : ut.cmpn(0) < 0 && (pt = ut.iadd(this.m)), pt._forceRed(this);
      }, Oe.prototype.mul = function(pe, nt) {
        if (pe.isZero() || nt.isZero()) return new W(0)._forceRed(this);
        var ot = pe.mul(nt), st = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ut = ot.isub(st).iushrn(this.shift), pt = ut;
        return ut.cmp(this.m) >= 0 ? pt = ut.isub(this.m) : ut.cmpn(0) < 0 && (pt = ut.iadd(this.m)), pt._forceRed(this);
      }, Oe.prototype.invm = function(pe) {
        var nt = this.imod(pe._invmp(this.m).mul(this.r2));
        return nt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var A = requireBn(), B = requireBrowser$b();
  function L(W) {
    var V = K(W), ne = V.toRed(A.mont(W.modulus)).redPow(new A(W.publicExponent)).fromRed();
    return { blinder: ne, unblinder: V.invm(W.modulus) };
  }
  function K(W) {
    var V = W.modulus.byteLength(), ne;
    do
      ne = new A(B(V));
    while (ne.cmp(W.modulus) >= 0 || !ne.umod(W.prime1) || !ne.umod(W.prime2));
    return ne;
  }
  function J(W, V) {
    var ne = L(V), ie = V.modulus.byteLength(), oe = new A(W).mul(ne.blinder).umod(V.modulus), re = oe.toRed(A.mont(V.prime1)), ce = oe.toRed(A.mont(V.prime2)), ke = V.coefficient, Ce = V.prime1, it = V.prime2, at = re.redPow(V.exponent1).fromRed(), lt = ce.redPow(V.exponent2).fromRed(), ht = at.isub(lt).imul(ke).umod(Ce).imul(it);
    return lt.iadd(ht).imul(ne.unblinder).umod(V.modulus).toArrayLike(Buffer$1, "be", ie);
  }
  return J.getr = K, browserifyRsa = J, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(A) {
    var B = A;
    function L(W, V) {
      if (Array.isArray(W))
        return W.slice();
      if (!W)
        return [];
      var ne = [];
      if (typeof W != "string") {
        for (var ie = 0; ie < W.length; ie++)
          ne[ie] = W[ie] | 0;
        return ne;
      }
      if (V === "hex") {
        W = W.replace(/[^a-z0-9]+/ig, ""), W.length % 2 !== 0 && (W = "0" + W);
        for (var ie = 0; ie < W.length; ie += 2)
          ne.push(parseInt(W[ie] + W[ie + 1], 16));
      } else
        for (var ie = 0; ie < W.length; ie++) {
          var oe = W.charCodeAt(ie), re = oe >> 8, ce = oe & 255;
          re ? ne.push(re, ce) : ne.push(ce);
        }
      return ne;
    }
    B.toArray = L;
    function K(W) {
      return W.length === 1 ? "0" + W : W;
    }
    B.zero2 = K;
    function J(W) {
      for (var V = "", ne = 0; ne < W.length; ne++)
        V += K(W[ne].toString(16));
      return V;
    }
    B.toHex = J, B.encode = function(V, ne) {
      return ne === "hex" ? J(V) : V;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(A) {
    var B = A, L = requireBn$1(), K = requireMinimalisticAssert(), J = requireUtils$2();
    B.assert = K, B.toArray = J.toArray, B.zero2 = J.zero2, B.toHex = J.toHex, B.encode = J.encode;
    function W(re, ce, ke) {
      var Ce = new Array(Math.max(re.bitLength(), ke) + 1), it;
      for (it = 0; it < Ce.length; it += 1)
        Ce[it] = 0;
      var at = 1 << ce + 1, lt = re.clone();
      for (it = 0; it < Ce.length; it++) {
        var ht, dt = lt.andln(at - 1);
        lt.isOdd() ? (dt > (at >> 1) - 1 ? ht = (at >> 1) - dt : ht = dt, lt.isubn(ht)) : ht = 0, Ce[it] = ht, lt.iushrn(1);
      }
      return Ce;
    }
    B.getNAF = W;
    function V(re, ce) {
      var ke = [
        [],
        []
      ];
      re = re.clone(), ce = ce.clone();
      for (var Ce = 0, it = 0, at; re.cmpn(-Ce) > 0 || ce.cmpn(-it) > 0; ) {
        var lt = re.andln(3) + Ce & 3, ht = ce.andln(3) + it & 3;
        lt === 3 && (lt = -1), ht === 3 && (ht = -1);
        var dt;
        lt & 1 ? (at = re.andln(7) + Ce & 7, (at === 3 || at === 5) && ht === 2 ? dt = -lt : dt = lt) : dt = 0, ke[0].push(dt);
        var vt;
        ht & 1 ? (at = ce.andln(7) + it & 7, (at === 3 || at === 5) && lt === 2 ? vt = -ht : vt = ht) : vt = 0, ke[1].push(vt), 2 * Ce === dt + 1 && (Ce = 1 - Ce), 2 * it === vt + 1 && (it = 1 - it), re.iushrn(1), ce.iushrn(1);
      }
      return ke;
    }
    B.getJSF = V;
    function ne(re, ce, ke) {
      var Ce = "_" + ce;
      re.prototype[ce] = function() {
        return this[Ce] !== void 0 ? this[Ce] : this[Ce] = ke.call(this);
      };
    }
    B.cachedProperty = ne;
    function ie(re) {
      return typeof re == "string" ? B.toArray(re, "hex") : re;
    }
    B.parseBytes = ie;
    function oe(re) {
      return new L(re, "hex", "le");
    }
    B.intFromLE = oe;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.getNAF, K = B.getJSF, J = B.assert;
  function W(ne, ie) {
    this.type = ne, this.p = new A(ie.p, 16), this.red = ie.prime ? A.red(ie.prime) : A.mont(this.p), this.zero = new A(0).toRed(this.red), this.one = new A(1).toRed(this.red), this.two = new A(2).toRed(this.red), this.n = ie.n && new A(ie.n, 16), this.g = ie.g && this.pointFromJSON(ie.g, ie.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var oe = this.n && this.p.div(this.n);
    !oe || oe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = W, W.prototype.point = function() {
    throw new Error("Not implemented");
  }, W.prototype.validate = function() {
    throw new Error("Not implemented");
  }, W.prototype._fixedNafMul = function(ie, oe) {
    J(ie.precomputed);
    var re = ie._getDoubles(), ce = L(oe, 1, this._bitLength), ke = (1 << re.step + 1) - (re.step % 2 === 0 ? 2 : 1);
    ke /= 3;
    var Ce = [], it, at;
    for (it = 0; it < ce.length; it += re.step) {
      at = 0;
      for (var lt = it + re.step - 1; lt >= it; lt--)
        at = (at << 1) + ce[lt];
      Ce.push(at);
    }
    for (var ht = this.jpoint(null, null, null), dt = this.jpoint(null, null, null), vt = ke; vt > 0; vt--) {
      for (it = 0; it < Ce.length; it++)
        at = Ce[it], at === vt ? dt = dt.mixedAdd(re.points[it]) : at === -vt && (dt = dt.mixedAdd(re.points[it].neg()));
      ht = ht.add(dt);
    }
    return ht.toP();
  }, W.prototype._wnafMul = function(ie, oe) {
    var re = 4, ce = ie._getNAFPoints(re);
    re = ce.wnd;
    for (var ke = ce.points, Ce = L(oe, re, this._bitLength), it = this.jpoint(null, null, null), at = Ce.length - 1; at >= 0; at--) {
      for (var lt = 0; at >= 0 && Ce[at] === 0; at--)
        lt++;
      if (at >= 0 && lt++, it = it.dblp(lt), at < 0)
        break;
      var ht = Ce[at];
      J(ht !== 0), ie.type === "affine" ? ht > 0 ? it = it.mixedAdd(ke[ht - 1 >> 1]) : it = it.mixedAdd(ke[-ht - 1 >> 1].neg()) : ht > 0 ? it = it.add(ke[ht - 1 >> 1]) : it = it.add(ke[-ht - 1 >> 1].neg());
    }
    return ie.type === "affine" ? it.toP() : it;
  }, W.prototype._wnafMulAdd = function(ie, oe, re, ce, ke) {
    var Ce = this._wnafT1, it = this._wnafT2, at = this._wnafT3, lt = 0, ht, dt, vt;
    for (ht = 0; ht < ce; ht++) {
      vt = oe[ht];
      var mt = vt._getNAFPoints(ie);
      Ce[ht] = mt.wnd, it[ht] = mt.points;
    }
    for (ht = ce - 1; ht >= 1; ht -= 2) {
      var Pt = ht - 1, $t = ht;
      if (Ce[Pt] !== 1 || Ce[$t] !== 1) {
        at[Pt] = L(re[Pt], Ce[Pt], this._bitLength), at[$t] = L(re[$t], Ce[$t], this._bitLength), lt = Math.max(at[Pt].length, lt), lt = Math.max(at[$t].length, lt);
        continue;
      }
      var qt = [
        oe[Pt],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        oe[$t]
        /* 7 */
      ];
      oe[Pt].y.cmp(oe[$t].y) === 0 ? (qt[1] = oe[Pt].add(oe[$t]), qt[2] = oe[Pt].toJ().mixedAdd(oe[$t].neg())) : oe[Pt].y.cmp(oe[$t].y.redNeg()) === 0 ? (qt[1] = oe[Pt].toJ().mixedAdd(oe[$t]), qt[2] = oe[Pt].add(oe[$t].neg())) : (qt[1] = oe[Pt].toJ().mixedAdd(oe[$t]), qt[2] = oe[Pt].toJ().mixedAdd(oe[$t].neg()));
      var At = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], bt = K(re[Pt], re[$t]);
      for (lt = Math.max(bt[0].length, lt), at[Pt] = new Array(lt), at[$t] = new Array(lt), dt = 0; dt < lt; dt++) {
        var xt = bt[0][dt] | 0, wt = bt[1][dt] | 0;
        at[Pt][dt] = At[(xt + 1) * 3 + (wt + 1)], at[$t][dt] = 0, it[Pt] = qt;
      }
    }
    var Oe = this.jpoint(null, null, null), rt = this._wnafT4;
    for (ht = lt; ht >= 0; ht--) {
      for (var pe = 0; ht >= 0; ) {
        var nt = !0;
        for (dt = 0; dt < ce; dt++)
          rt[dt] = at[dt][ht] | 0, rt[dt] !== 0 && (nt = !1);
        if (!nt)
          break;
        pe++, ht--;
      }
      if (ht >= 0 && pe++, Oe = Oe.dblp(pe), ht < 0)
        break;
      for (dt = 0; dt < ce; dt++) {
        var ot = rt[dt];
        ot !== 0 && (ot > 0 ? vt = it[dt][ot - 1 >> 1] : ot < 0 && (vt = it[dt][-ot - 1 >> 1].neg()), vt.type === "affine" ? Oe = Oe.mixedAdd(vt) : Oe = Oe.add(vt));
      }
    }
    for (ht = 0; ht < ce; ht++)
      it[ht] = null;
    return ke ? Oe : Oe.toP();
  };
  function V(ne, ie) {
    this.curve = ne, this.type = ie, this.precomputed = null;
  }
  return W.BasePoint = V, V.prototype.eq = function() {
    throw new Error("Not implemented");
  }, V.prototype.validate = function() {
    return this.curve.validate(this);
  }, W.prototype.decodePoint = function(ie, oe) {
    ie = B.toArray(ie, oe);
    var re = this.p.byteLength();
    if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 === 2 * re) {
      ie[0] === 6 ? J(ie[ie.length - 1] % 2 === 0) : ie[0] === 7 && J(ie[ie.length - 1] % 2 === 1);
      var ce = this.point(
        ie.slice(1, 1 + re),
        ie.slice(1 + re, 1 + 2 * re)
      );
      return ce;
    } else if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === re)
      return this.pointFromX(ie.slice(1, 1 + re), ie[0] === 3);
    throw new Error("Unknown point format");
  }, V.prototype.encodeCompressed = function(ie) {
    return this.encode(ie, !0);
  }, V.prototype._encode = function(ie) {
    var oe = this.curve.p.byteLength(), re = this.getX().toArray("be", oe);
    return ie ? [this.getY().isEven() ? 2 : 3].concat(re) : [4].concat(re, this.getY().toArray("be", oe));
  }, V.prototype.encode = function(ie, oe) {
    return B.encode(this._encode(oe), ie);
  }, V.prototype.precompute = function(ie) {
    if (this.precomputed)
      return this;
    var oe = {
      doubles: null,
      naf: null,
      beta: null
    };
    return oe.naf = this._getNAFPoints(8), oe.doubles = this._getDoubles(4, ie), oe.beta = this._getBeta(), this.precomputed = oe, this;
  }, V.prototype._hasDoubles = function(ie) {
    if (!this.precomputed)
      return !1;
    var oe = this.precomputed.doubles;
    return oe ? oe.points.length >= Math.ceil((ie.bitLength() + 1) / oe.step) : !1;
  }, V.prototype._getDoubles = function(ie, oe) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var re = [this], ce = this, ke = 0; ke < oe; ke += ie) {
      for (var Ce = 0; Ce < ie; Ce++)
        ce = ce.dbl();
      re.push(ce);
    }
    return {
      step: ie,
      points: re
    };
  }, V.prototype._getNAFPoints = function(ie) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var oe = [this], re = (1 << ie) - 1, ce = re === 1 ? null : this.dbl(), ke = 1; ke < re; ke++)
      oe[ke] = oe[ke - 1].add(ce);
    return {
      wnd: ie,
      points: oe
    };
  }, V.prototype._getBeta = function() {
    return null;
  }, V.prototype.dblp = function(ie) {
    for (var oe = this, re = 0; re < ie; re++)
      oe = oe.dbl();
    return oe;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), J = A.assert;
  function W(ie) {
    K.call(this, "short", ie), this.a = new B(ie.a, 16).toRed(this.red), this.b = new B(ie.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ie), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  L(W, K), short = W, W.prototype._getEndomorphism = function(oe) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var re, ce;
      if (oe.beta)
        re = new B(oe.beta, 16).toRed(this.red);
      else {
        var ke = this._getEndoRoots(this.p);
        re = ke[0].cmp(ke[1]) < 0 ? ke[0] : ke[1], re = re.toRed(this.red);
      }
      if (oe.lambda)
        ce = new B(oe.lambda, 16);
      else {
        var Ce = this._getEndoRoots(this.n);
        this.g.mul(Ce[0]).x.cmp(this.g.x.redMul(re)) === 0 ? ce = Ce[0] : (ce = Ce[1], J(this.g.mul(ce).x.cmp(this.g.x.redMul(re)) === 0));
      }
      var it;
      return oe.basis ? it = oe.basis.map(function(at) {
        return {
          a: new B(at.a, 16),
          b: new B(at.b, 16)
        };
      }) : it = this._getEndoBasis(ce), {
        beta: re,
        lambda: ce,
        basis: it
      };
    }
  }, W.prototype._getEndoRoots = function(oe) {
    var re = oe === this.p ? this.red : B.mont(oe), ce = new B(2).toRed(re).redInvm(), ke = ce.redNeg(), Ce = new B(3).toRed(re).redNeg().redSqrt().redMul(ce), it = ke.redAdd(Ce).fromRed(), at = ke.redSub(Ce).fromRed();
    return [it, at];
  }, W.prototype._getEndoBasis = function(oe) {
    for (var re = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ce = oe, ke = this.n.clone(), Ce = new B(1), it = new B(0), at = new B(0), lt = new B(1), ht, dt, vt, mt, Pt, $t, qt, At = 0, bt, xt; ce.cmpn(0) !== 0; ) {
      var wt = ke.div(ce);
      bt = ke.sub(wt.mul(ce)), xt = at.sub(wt.mul(Ce));
      var Oe = lt.sub(wt.mul(it));
      if (!vt && bt.cmp(re) < 0)
        ht = qt.neg(), dt = Ce, vt = bt.neg(), mt = xt;
      else if (vt && ++At === 2)
        break;
      qt = bt, ke = ce, ce = bt, at = Ce, Ce = xt, lt = it, it = Oe;
    }
    Pt = bt.neg(), $t = xt;
    var rt = vt.sqr().add(mt.sqr()), pe = Pt.sqr().add($t.sqr());
    return pe.cmp(rt) >= 0 && (Pt = ht, $t = dt), vt.negative && (vt = vt.neg(), mt = mt.neg()), Pt.negative && (Pt = Pt.neg(), $t = $t.neg()), [
      { a: vt, b: mt },
      { a: Pt, b: $t }
    ];
  }, W.prototype._endoSplit = function(oe) {
    var re = this.endo.basis, ce = re[0], ke = re[1], Ce = ke.b.mul(oe).divRound(this.n), it = ce.b.neg().mul(oe).divRound(this.n), at = Ce.mul(ce.a), lt = it.mul(ke.a), ht = Ce.mul(ce.b), dt = it.mul(ke.b), vt = oe.sub(at).sub(lt), mt = ht.add(dt).neg();
    return { k1: vt, k2: mt };
  }, W.prototype.pointFromX = function(oe, re) {
    oe = new B(oe, 16), oe.red || (oe = oe.toRed(this.red));
    var ce = oe.redSqr().redMul(oe).redIAdd(oe.redMul(this.a)).redIAdd(this.b), ke = ce.redSqrt();
    if (ke.redSqr().redSub(ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Ce = ke.fromRed().isOdd();
    return (re && !Ce || !re && Ce) && (ke = ke.redNeg()), this.point(oe, ke);
  }, W.prototype.validate = function(oe) {
    if (oe.inf)
      return !0;
    var re = oe.x, ce = oe.y, ke = this.a.redMul(re), Ce = re.redSqr().redMul(re).redIAdd(ke).redIAdd(this.b);
    return ce.redSqr().redISub(Ce).cmpn(0) === 0;
  }, W.prototype._endoWnafMulAdd = function(oe, re, ce) {
    for (var ke = this._endoWnafT1, Ce = this._endoWnafT2, it = 0; it < oe.length; it++) {
      var at = this._endoSplit(re[it]), lt = oe[it], ht = lt._getBeta();
      at.k1.negative && (at.k1.ineg(), lt = lt.neg(!0)), at.k2.negative && (at.k2.ineg(), ht = ht.neg(!0)), ke[it * 2] = lt, ke[it * 2 + 1] = ht, Ce[it * 2] = at.k1, Ce[it * 2 + 1] = at.k2;
    }
    for (var dt = this._wnafMulAdd(1, ke, Ce, it * 2, ce), vt = 0; vt < it * 2; vt++)
      ke[vt] = null, Ce[vt] = null;
    return dt;
  };
  function V(ie, oe, re, ce) {
    K.BasePoint.call(this, ie, "affine"), oe === null && re === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new B(oe, 16), this.y = new B(re, 16), ce && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  L(V, K.BasePoint), W.prototype.point = function(oe, re, ce) {
    return new V(this, oe, re, ce);
  }, W.prototype.pointFromJSON = function(oe, re) {
    return V.fromJSON(this, oe, re);
  }, V.prototype._getBeta = function() {
    if (this.curve.endo) {
      var oe = this.precomputed;
      if (oe && oe.beta)
        return oe.beta;
      var re = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (oe) {
        var ce = this.curve, ke = function(Ce) {
          return ce.point(Ce.x.redMul(ce.endo.beta), Ce.y);
        };
        oe.beta = re, re.precomputed = {
          beta: null,
          naf: oe.naf && {
            wnd: oe.naf.wnd,
            points: oe.naf.points.map(ke)
          },
          doubles: oe.doubles && {
            step: oe.doubles.step,
            points: oe.doubles.points.map(ke)
          }
        };
      }
      return re;
    }
  }, V.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, V.fromJSON = function(oe, re, ce) {
    typeof re == "string" && (re = JSON.parse(re));
    var ke = oe.point(re[0], re[1], ce);
    if (!re[2])
      return ke;
    function Ce(at) {
      return oe.point(at[0], at[1], ce);
    }
    var it = re[2];
    return ke.precomputed = {
      beta: null,
      doubles: it.doubles && {
        step: it.doubles.step,
        points: [ke].concat(it.doubles.points.map(Ce))
      },
      naf: it.naf && {
        wnd: it.naf.wnd,
        points: [ke].concat(it.naf.points.map(Ce))
      }
    }, ke;
  }, V.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, V.prototype.isInfinity = function() {
    return this.inf;
  }, V.prototype.add = function(oe) {
    if (this.inf)
      return oe;
    if (oe.inf)
      return this;
    if (this.eq(oe))
      return this.dbl();
    if (this.neg().eq(oe))
      return this.curve.point(null, null);
    if (this.x.cmp(oe.x) === 0)
      return this.curve.point(null, null);
    var re = this.y.redSub(oe.y);
    re.cmpn(0) !== 0 && (re = re.redMul(this.x.redSub(oe.x).redInvm()));
    var ce = re.redSqr().redISub(this.x).redISub(oe.x), ke = re.redMul(this.x.redSub(ce)).redISub(this.y);
    return this.curve.point(ce, ke);
  }, V.prototype.dbl = function() {
    if (this.inf)
      return this;
    var oe = this.y.redAdd(this.y);
    if (oe.cmpn(0) === 0)
      return this.curve.point(null, null);
    var re = this.curve.a, ce = this.x.redSqr(), ke = oe.redInvm(), Ce = ce.redAdd(ce).redIAdd(ce).redIAdd(re).redMul(ke), it = Ce.redSqr().redISub(this.x.redAdd(this.x)), at = Ce.redMul(this.x.redSub(it)).redISub(this.y);
    return this.curve.point(it, at);
  }, V.prototype.getX = function() {
    return this.x.fromRed();
  }, V.prototype.getY = function() {
    return this.y.fromRed();
  }, V.prototype.mul = function(oe) {
    return oe = new B(oe, 16), this.isInfinity() ? this : this._hasDoubles(oe) ? this.curve._fixedNafMul(this, oe) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [oe]) : this.curve._wnafMul(this, oe);
  }, V.prototype.mulAdd = function(oe, re, ce) {
    var ke = [this, re], Ce = [oe, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Ce) : this.curve._wnafMulAdd(1, ke, Ce, 2);
  }, V.prototype.jmulAdd = function(oe, re, ce) {
    var ke = [this, re], Ce = [oe, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Ce, !0) : this.curve._wnafMulAdd(1, ke, Ce, 2, !0);
  }, V.prototype.eq = function(oe) {
    return this === oe || this.inf === oe.inf && (this.inf || this.x.cmp(oe.x) === 0 && this.y.cmp(oe.y) === 0);
  }, V.prototype.neg = function(oe) {
    if (this.inf)
      return this;
    var re = this.curve.point(this.x, this.y.redNeg());
    if (oe && this.precomputed) {
      var ce = this.precomputed, ke = function(Ce) {
        return Ce.neg();
      };
      re.precomputed = {
        naf: ce.naf && {
          wnd: ce.naf.wnd,
          points: ce.naf.points.map(ke)
        },
        doubles: ce.doubles && {
          step: ce.doubles.step,
          points: ce.doubles.points.map(ke)
        }
      };
    }
    return re;
  }, V.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var oe = this.curve.jpoint(this.x, this.y, this.curve.one);
    return oe;
  };
  function ne(ie, oe, re, ce) {
    K.BasePoint.call(this, ie, "jacobian"), oe === null && re === null && ce === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new B(0)) : (this.x = new B(oe, 16), this.y = new B(re, 16), this.z = new B(ce, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return L(ne, K.BasePoint), W.prototype.jpoint = function(oe, re, ce) {
    return new ne(this, oe, re, ce);
  }, ne.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var oe = this.z.redInvm(), re = oe.redSqr(), ce = this.x.redMul(re), ke = this.y.redMul(re).redMul(oe);
    return this.curve.point(ce, ke);
  }, ne.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ne.prototype.add = function(oe) {
    if (this.isInfinity())
      return oe;
    if (oe.isInfinity())
      return this;
    var re = oe.z.redSqr(), ce = this.z.redSqr(), ke = this.x.redMul(re), Ce = oe.x.redMul(ce), it = this.y.redMul(re.redMul(oe.z)), at = oe.y.redMul(ce.redMul(this.z)), lt = ke.redSub(Ce), ht = it.redSub(at);
    if (lt.cmpn(0) === 0)
      return ht.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var dt = lt.redSqr(), vt = dt.redMul(lt), mt = ke.redMul(dt), Pt = ht.redSqr().redIAdd(vt).redISub(mt).redISub(mt), $t = ht.redMul(mt.redISub(Pt)).redISub(it.redMul(vt)), qt = this.z.redMul(oe.z).redMul(lt);
    return this.curve.jpoint(Pt, $t, qt);
  }, ne.prototype.mixedAdd = function(oe) {
    if (this.isInfinity())
      return oe.toJ();
    if (oe.isInfinity())
      return this;
    var re = this.z.redSqr(), ce = this.x, ke = oe.x.redMul(re), Ce = this.y, it = oe.y.redMul(re).redMul(this.z), at = ce.redSub(ke), lt = Ce.redSub(it);
    if (at.cmpn(0) === 0)
      return lt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var ht = at.redSqr(), dt = ht.redMul(at), vt = ce.redMul(ht), mt = lt.redSqr().redIAdd(dt).redISub(vt).redISub(vt), Pt = lt.redMul(vt.redISub(mt)).redISub(Ce.redMul(dt)), $t = this.z.redMul(at);
    return this.curve.jpoint(mt, Pt, $t);
  }, ne.prototype.dblp = function(oe) {
    if (oe === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!oe)
      return this.dbl();
    var re;
    if (this.curve.zeroA || this.curve.threeA) {
      var ce = this;
      for (re = 0; re < oe; re++)
        ce = ce.dbl();
      return ce;
    }
    var ke = this.curve.a, Ce = this.curve.tinv, it = this.x, at = this.y, lt = this.z, ht = lt.redSqr().redSqr(), dt = at.redAdd(at);
    for (re = 0; re < oe; re++) {
      var vt = it.redSqr(), mt = dt.redSqr(), Pt = mt.redSqr(), $t = vt.redAdd(vt).redIAdd(vt).redIAdd(ke.redMul(ht)), qt = it.redMul(mt), At = $t.redSqr().redISub(qt.redAdd(qt)), bt = qt.redISub(At), xt = $t.redMul(bt);
      xt = xt.redIAdd(xt).redISub(Pt);
      var wt = dt.redMul(lt);
      re + 1 < oe && (ht = ht.redMul(Pt)), it = At, lt = wt, dt = xt;
    }
    return this.curve.jpoint(it, dt.redMul(Ce), lt);
  }, ne.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ne.prototype._zeroDbl = function() {
    var oe, re, ce;
    if (this.zOne) {
      var ke = this.x.redSqr(), Ce = this.y.redSqr(), it = Ce.redSqr(), at = this.x.redAdd(Ce).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var lt = ke.redAdd(ke).redIAdd(ke), ht = lt.redSqr().redISub(at).redISub(at), dt = it.redIAdd(it);
      dt = dt.redIAdd(dt), dt = dt.redIAdd(dt), oe = ht, re = lt.redMul(at.redISub(ht)).redISub(dt), ce = this.y.redAdd(this.y);
    } else {
      var vt = this.x.redSqr(), mt = this.y.redSqr(), Pt = mt.redSqr(), $t = this.x.redAdd(mt).redSqr().redISub(vt).redISub(Pt);
      $t = $t.redIAdd($t);
      var qt = vt.redAdd(vt).redIAdd(vt), At = qt.redSqr(), bt = Pt.redIAdd(Pt);
      bt = bt.redIAdd(bt), bt = bt.redIAdd(bt), oe = At.redISub($t).redISub($t), re = qt.redMul($t.redISub(oe)).redISub(bt), ce = this.y.redMul(this.z), ce = ce.redIAdd(ce);
    }
    return this.curve.jpoint(oe, re, ce);
  }, ne.prototype._threeDbl = function() {
    var oe, re, ce;
    if (this.zOne) {
      var ke = this.x.redSqr(), Ce = this.y.redSqr(), it = Ce.redSqr(), at = this.x.redAdd(Ce).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var lt = ke.redAdd(ke).redIAdd(ke).redIAdd(this.curve.a), ht = lt.redSqr().redISub(at).redISub(at);
      oe = ht;
      var dt = it.redIAdd(it);
      dt = dt.redIAdd(dt), dt = dt.redIAdd(dt), re = lt.redMul(at.redISub(ht)).redISub(dt), ce = this.y.redAdd(this.y);
    } else {
      var vt = this.z.redSqr(), mt = this.y.redSqr(), Pt = this.x.redMul(mt), $t = this.x.redSub(vt).redMul(this.x.redAdd(vt));
      $t = $t.redAdd($t).redIAdd($t);
      var qt = Pt.redIAdd(Pt);
      qt = qt.redIAdd(qt);
      var At = qt.redAdd(qt);
      oe = $t.redSqr().redISub(At), ce = this.y.redAdd(this.z).redSqr().redISub(mt).redISub(vt);
      var bt = mt.redSqr();
      bt = bt.redIAdd(bt), bt = bt.redIAdd(bt), bt = bt.redIAdd(bt), re = $t.redMul(qt.redISub(oe)).redISub(bt);
    }
    return this.curve.jpoint(oe, re, ce);
  }, ne.prototype._dbl = function() {
    var oe = this.curve.a, re = this.x, ce = this.y, ke = this.z, Ce = ke.redSqr().redSqr(), it = re.redSqr(), at = ce.redSqr(), lt = it.redAdd(it).redIAdd(it).redIAdd(oe.redMul(Ce)), ht = re.redAdd(re);
    ht = ht.redIAdd(ht);
    var dt = ht.redMul(at), vt = lt.redSqr().redISub(dt.redAdd(dt)), mt = dt.redISub(vt), Pt = at.redSqr();
    Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt);
    var $t = lt.redMul(mt).redISub(Pt), qt = ce.redAdd(ce).redMul(ke);
    return this.curve.jpoint(vt, $t, qt);
  }, ne.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var oe = this.x.redSqr(), re = this.y.redSqr(), ce = this.z.redSqr(), ke = re.redSqr(), Ce = oe.redAdd(oe).redIAdd(oe), it = Ce.redSqr(), at = this.x.redAdd(re).redSqr().redISub(oe).redISub(ke);
    at = at.redIAdd(at), at = at.redAdd(at).redIAdd(at), at = at.redISub(it);
    var lt = at.redSqr(), ht = ke.redIAdd(ke);
    ht = ht.redIAdd(ht), ht = ht.redIAdd(ht), ht = ht.redIAdd(ht);
    var dt = Ce.redIAdd(at).redSqr().redISub(it).redISub(lt).redISub(ht), vt = re.redMul(dt);
    vt = vt.redIAdd(vt), vt = vt.redIAdd(vt);
    var mt = this.x.redMul(lt).redISub(vt);
    mt = mt.redIAdd(mt), mt = mt.redIAdd(mt);
    var Pt = this.y.redMul(dt.redMul(ht.redISub(dt)).redISub(at.redMul(lt)));
    Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt);
    var $t = this.z.redAdd(at).redSqr().redISub(ce).redISub(lt);
    return this.curve.jpoint(mt, Pt, $t);
  }, ne.prototype.mul = function(oe, re) {
    return oe = new B(oe, re), this.curve._wnafMul(this, oe);
  }, ne.prototype.eq = function(oe) {
    if (oe.type === "affine")
      return this.eq(oe.toJ());
    if (this === oe)
      return !0;
    var re = this.z.redSqr(), ce = oe.z.redSqr();
    if (this.x.redMul(ce).redISub(oe.x.redMul(re)).cmpn(0) !== 0)
      return !1;
    var ke = re.redMul(this.z), Ce = ce.redMul(oe.z);
    return this.y.redMul(Ce).redISub(oe.y.redMul(ke)).cmpn(0) === 0;
  }, ne.prototype.eqXToP = function(oe) {
    var re = this.z.redSqr(), ce = oe.toRed(this.curve.red).redMul(re);
    if (this.x.cmp(ce) === 0)
      return !0;
    for (var ke = oe.clone(), Ce = this.curve.redN.redMul(re); ; ) {
      if (ke.iadd(this.curve.n), ke.cmp(this.curve.p) >= 0)
        return !1;
      if (ce.redIAdd(Ce), this.x.cmp(ce) === 0)
        return !0;
    }
  }, ne.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ne.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var A = requireBn$1(), B = requireInherits_browser(), L = requireBase$1(), K = requireUtils$1();
  function J(V) {
    L.call(this, "mont", V), this.a = new A(V.a, 16).toRed(this.red), this.b = new A(V.b, 16).toRed(this.red), this.i4 = new A(4).toRed(this.red).redInvm(), this.two = new A(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  B(J, L), mont = J, J.prototype.validate = function(ne) {
    var ie = ne.normalize().x, oe = ie.redSqr(), re = oe.redMul(ie).redAdd(oe.redMul(this.a)).redAdd(ie), ce = re.redSqrt();
    return ce.redSqr().cmp(re) === 0;
  };
  function W(V, ne, ie) {
    L.BasePoint.call(this, V, "projective"), ne === null && ie === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new A(ne, 16), this.z = new A(ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return B(W, L.BasePoint), J.prototype.decodePoint = function(ne, ie) {
    return this.point(K.toArray(ne, ie), 1);
  }, J.prototype.point = function(ne, ie) {
    return new W(this, ne, ie);
  }, J.prototype.pointFromJSON = function(ne) {
    return W.fromJSON(this, ne);
  }, W.prototype.precompute = function() {
  }, W.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, W.fromJSON = function(ne, ie) {
    return new W(ne, ie[0], ie[1] || ne.one);
  }, W.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, W.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, W.prototype.dbl = function() {
    var ne = this.x.redAdd(this.z), ie = ne.redSqr(), oe = this.x.redSub(this.z), re = oe.redSqr(), ce = ie.redSub(re), ke = ie.redMul(re), Ce = ce.redMul(re.redAdd(this.curve.a24.redMul(ce)));
    return this.curve.point(ke, Ce);
  }, W.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.diffAdd = function(ne, ie) {
    var oe = this.x.redAdd(this.z), re = this.x.redSub(this.z), ce = ne.x.redAdd(ne.z), ke = ne.x.redSub(ne.z), Ce = ke.redMul(oe), it = ce.redMul(re), at = ie.z.redMul(Ce.redAdd(it).redSqr()), lt = ie.x.redMul(Ce.redISub(it).redSqr());
    return this.curve.point(at, lt);
  }, W.prototype.mul = function(ne) {
    for (var ie = ne.clone(), oe = this, re = this.curve.point(null, null), ce = this, ke = []; ie.cmpn(0) !== 0; ie.iushrn(1))
      ke.push(ie.andln(1));
    for (var Ce = ke.length - 1; Ce >= 0; Ce--)
      ke[Ce] === 0 ? (oe = oe.diffAdd(re, ce), re = re.dbl()) : (re = oe.diffAdd(re, ce), oe = oe.dbl());
    return re;
  }, W.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.eq = function(ne) {
    return this.getX().cmp(ne.getX()) === 0;
  }, W.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, W.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), J = A.assert;
  function W(ne) {
    this.twisted = (ne.a | 0) !== 1, this.mOneA = this.twisted && (ne.a | 0) === -1, this.extended = this.mOneA, K.call(this, "edwards", ne), this.a = new B(ne.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new B(ne.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new B(ne.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), J(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ne.c | 0) === 1;
  }
  L(W, K), edwards = W, W.prototype._mulA = function(ie) {
    return this.mOneA ? ie.redNeg() : this.a.redMul(ie);
  }, W.prototype._mulC = function(ie) {
    return this.oneC ? ie : this.c.redMul(ie);
  }, W.prototype.jpoint = function(ie, oe, re, ce) {
    return this.point(ie, oe, re, ce);
  }, W.prototype.pointFromX = function(ie, oe) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var re = ie.redSqr(), ce = this.c2.redSub(this.a.redMul(re)), ke = this.one.redSub(this.c2.redMul(this.d).redMul(re)), Ce = ce.redMul(ke.redInvm()), it = Ce.redSqrt();
    if (it.redSqr().redSub(Ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var at = it.fromRed().isOdd();
    return (oe && !at || !oe && at) && (it = it.redNeg()), this.point(ie, it);
  }, W.prototype.pointFromY = function(ie, oe) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var re = ie.redSqr(), ce = re.redSub(this.c2), ke = re.redMul(this.d).redMul(this.c2).redSub(this.a), Ce = ce.redMul(ke.redInvm());
    if (Ce.cmp(this.zero) === 0) {
      if (oe)
        throw new Error("invalid point");
      return this.point(this.zero, ie);
    }
    var it = Ce.redSqrt();
    if (it.redSqr().redSub(Ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return it.fromRed().isOdd() !== oe && (it = it.redNeg()), this.point(it, ie);
  }, W.prototype.validate = function(ie) {
    if (ie.isInfinity())
      return !0;
    ie.normalize();
    var oe = ie.x.redSqr(), re = ie.y.redSqr(), ce = oe.redMul(this.a).redAdd(re), ke = this.c2.redMul(this.one.redAdd(this.d.redMul(oe).redMul(re)));
    return ce.cmp(ke) === 0;
  };
  function V(ne, ie, oe, re, ce) {
    K.BasePoint.call(this, ne, "projective"), ie === null && oe === null && re === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new B(ie, 16), this.y = new B(oe, 16), this.z = re ? new B(re, 16) : this.curve.one, this.t = ce && new B(ce, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return L(V, K.BasePoint), W.prototype.pointFromJSON = function(ie) {
    return V.fromJSON(this, ie);
  }, W.prototype.point = function(ie, oe, re, ce) {
    return new V(this, ie, oe, re, ce);
  }, V.fromJSON = function(ie, oe) {
    return new V(ie, oe[0], oe[1], oe[2]);
  }, V.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, V.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, V.prototype._extDbl = function() {
    var ie = this.x.redSqr(), oe = this.y.redSqr(), re = this.z.redSqr();
    re = re.redIAdd(re);
    var ce = this.curve._mulA(ie), ke = this.x.redAdd(this.y).redSqr().redISub(ie).redISub(oe), Ce = ce.redAdd(oe), it = Ce.redSub(re), at = ce.redSub(oe), lt = ke.redMul(it), ht = Ce.redMul(at), dt = ke.redMul(at), vt = it.redMul(Ce);
    return this.curve.point(lt, ht, vt, dt);
  }, V.prototype._projDbl = function() {
    var ie = this.x.redAdd(this.y).redSqr(), oe = this.x.redSqr(), re = this.y.redSqr(), ce, ke, Ce, it, at, lt;
    if (this.curve.twisted) {
      it = this.curve._mulA(oe);
      var ht = it.redAdd(re);
      this.zOne ? (ce = ie.redSub(oe).redSub(re).redMul(ht.redSub(this.curve.two)), ke = ht.redMul(it.redSub(re)), Ce = ht.redSqr().redSub(ht).redSub(ht)) : (at = this.z.redSqr(), lt = ht.redSub(at).redISub(at), ce = ie.redSub(oe).redISub(re).redMul(lt), ke = ht.redMul(it.redSub(re)), Ce = ht.redMul(lt));
    } else
      it = oe.redAdd(re), at = this.curve._mulC(this.z).redSqr(), lt = it.redSub(at).redSub(at), ce = this.curve._mulC(ie.redISub(it)).redMul(lt), ke = this.curve._mulC(it).redMul(oe.redISub(re)), Ce = it.redMul(lt);
    return this.curve.point(ce, ke, Ce);
  }, V.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, V.prototype._extAdd = function(ie) {
    var oe = this.y.redSub(this.x).redMul(ie.y.redSub(ie.x)), re = this.y.redAdd(this.x).redMul(ie.y.redAdd(ie.x)), ce = this.t.redMul(this.curve.dd).redMul(ie.t), ke = this.z.redMul(ie.z.redAdd(ie.z)), Ce = re.redSub(oe), it = ke.redSub(ce), at = ke.redAdd(ce), lt = re.redAdd(oe), ht = Ce.redMul(it), dt = at.redMul(lt), vt = Ce.redMul(lt), mt = it.redMul(at);
    return this.curve.point(ht, dt, mt, vt);
  }, V.prototype._projAdd = function(ie) {
    var oe = this.z.redMul(ie.z), re = oe.redSqr(), ce = this.x.redMul(ie.x), ke = this.y.redMul(ie.y), Ce = this.curve.d.redMul(ce).redMul(ke), it = re.redSub(Ce), at = re.redAdd(Ce), lt = this.x.redAdd(this.y).redMul(ie.x.redAdd(ie.y)).redISub(ce).redISub(ke), ht = oe.redMul(it).redMul(lt), dt, vt;
    return this.curve.twisted ? (dt = oe.redMul(at).redMul(ke.redSub(this.curve._mulA(ce))), vt = it.redMul(at)) : (dt = oe.redMul(at).redMul(ke.redSub(ce)), vt = this.curve._mulC(it).redMul(at)), this.curve.point(ht, dt, vt);
  }, V.prototype.add = function(ie) {
    return this.isInfinity() ? ie : ie.isInfinity() ? this : this.curve.extended ? this._extAdd(ie) : this._projAdd(ie);
  }, V.prototype.mul = function(ie) {
    return this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve._wnafMul(this, ie);
  }, V.prototype.mulAdd = function(ie, oe, re) {
    return this.curve._wnafMulAdd(1, [this, oe], [ie, re], 2, !1);
  }, V.prototype.jmulAdd = function(ie, oe, re) {
    return this.curve._wnafMulAdd(1, [this, oe], [ie, re], 2, !0);
  }, V.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ie = this.z.redInvm();
    return this.x = this.x.redMul(ie), this.y = this.y.redMul(ie), this.t && (this.t = this.t.redMul(ie)), this.z = this.curve.one, this.zOne = !0, this;
  }, V.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, V.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, V.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, V.prototype.eq = function(ie) {
    return this === ie || this.getX().cmp(ie.getX()) === 0 && this.getY().cmp(ie.getY()) === 0;
  }, V.prototype.eqXToP = function(ie) {
    var oe = ie.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(oe) === 0)
      return !0;
    for (var re = ie.clone(), ce = this.curve.redN.redMul(this.z); ; ) {
      if (re.iadd(this.curve.n), re.cmp(this.curve.p) >= 0)
        return !1;
      if (oe.redIAdd(ce), this.x.cmp(oe) === 0)
        return !0;
    }
  }, V.prototype.toP = V.prototype.normalize, V.prototype.mixedAdd = V.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(A) {
    var B = A;
    B.base = requireBase$1(), B.short = requireShort(), B.mont = requireMont(), B.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser();
  utils$1.inherits = B;
  function L(Oe, rt) {
    return (Oe.charCodeAt(rt) & 64512) !== 55296 || rt < 0 || rt + 1 >= Oe.length ? !1 : (Oe.charCodeAt(rt + 1) & 64512) === 56320;
  }
  function K(Oe, rt) {
    if (Array.isArray(Oe))
      return Oe.slice();
    if (!Oe)
      return [];
    var pe = [];
    if (typeof Oe == "string")
      if (rt) {
        if (rt === "hex")
          for (Oe = Oe.replace(/[^a-z0-9]+/ig, ""), Oe.length % 2 !== 0 && (Oe = "0" + Oe), ot = 0; ot < Oe.length; ot += 2)
            pe.push(parseInt(Oe[ot] + Oe[ot + 1], 16));
      } else for (var nt = 0, ot = 0; ot < Oe.length; ot++) {
        var st = Oe.charCodeAt(ot);
        st < 128 ? pe[nt++] = st : st < 2048 ? (pe[nt++] = st >> 6 | 192, pe[nt++] = st & 63 | 128) : L(Oe, ot) ? (st = 65536 + ((st & 1023) << 10) + (Oe.charCodeAt(++ot) & 1023), pe[nt++] = st >> 18 | 240, pe[nt++] = st >> 12 & 63 | 128, pe[nt++] = st >> 6 & 63 | 128, pe[nt++] = st & 63 | 128) : (pe[nt++] = st >> 12 | 224, pe[nt++] = st >> 6 & 63 | 128, pe[nt++] = st & 63 | 128);
      }
    else
      for (ot = 0; ot < Oe.length; ot++)
        pe[ot] = Oe[ot] | 0;
    return pe;
  }
  utils$1.toArray = K;
  function J(Oe) {
    for (var rt = "", pe = 0; pe < Oe.length; pe++)
      rt += ne(Oe[pe].toString(16));
    return rt;
  }
  utils$1.toHex = J;
  function W(Oe) {
    var rt = Oe >>> 24 | Oe >>> 8 & 65280 | Oe << 8 & 16711680 | (Oe & 255) << 24;
    return rt >>> 0;
  }
  utils$1.htonl = W;
  function V(Oe, rt) {
    for (var pe = "", nt = 0; nt < Oe.length; nt++) {
      var ot = Oe[nt];
      rt === "little" && (ot = W(ot)), pe += ie(ot.toString(16));
    }
    return pe;
  }
  utils$1.toHex32 = V;
  function ne(Oe) {
    return Oe.length === 1 ? "0" + Oe : Oe;
  }
  utils$1.zero2 = ne;
  function ie(Oe) {
    return Oe.length === 7 ? "0" + Oe : Oe.length === 6 ? "00" + Oe : Oe.length === 5 ? "000" + Oe : Oe.length === 4 ? "0000" + Oe : Oe.length === 3 ? "00000" + Oe : Oe.length === 2 ? "000000" + Oe : Oe.length === 1 ? "0000000" + Oe : Oe;
  }
  utils$1.zero8 = ie;
  function oe(Oe, rt, pe, nt) {
    var ot = pe - rt;
    A(ot % 4 === 0);
    for (var st = new Array(ot / 4), ut = 0, pt = rt; ut < st.length; ut++, pt += 4) {
      var ft;
      nt === "big" ? ft = Oe[pt] << 24 | Oe[pt + 1] << 16 | Oe[pt + 2] << 8 | Oe[pt + 3] : ft = Oe[pt + 3] << 24 | Oe[pt + 2] << 16 | Oe[pt + 1] << 8 | Oe[pt], st[ut] = ft >>> 0;
    }
    return st;
  }
  utils$1.join32 = oe;
  function re(Oe, rt) {
    for (var pe = new Array(Oe.length * 4), nt = 0, ot = 0; nt < Oe.length; nt++, ot += 4) {
      var st = Oe[nt];
      rt === "big" ? (pe[ot] = st >>> 24, pe[ot + 1] = st >>> 16 & 255, pe[ot + 2] = st >>> 8 & 255, pe[ot + 3] = st & 255) : (pe[ot + 3] = st >>> 24, pe[ot + 2] = st >>> 16 & 255, pe[ot + 1] = st >>> 8 & 255, pe[ot] = st & 255);
    }
    return pe;
  }
  utils$1.split32 = re;
  function ce(Oe, rt) {
    return Oe >>> rt | Oe << 32 - rt;
  }
  utils$1.rotr32 = ce;
  function ke(Oe, rt) {
    return Oe << rt | Oe >>> 32 - rt;
  }
  utils$1.rotl32 = ke;
  function Ce(Oe, rt) {
    return Oe + rt >>> 0;
  }
  utils$1.sum32 = Ce;
  function it(Oe, rt, pe) {
    return Oe + rt + pe >>> 0;
  }
  utils$1.sum32_3 = it;
  function at(Oe, rt, pe, nt) {
    return Oe + rt + pe + nt >>> 0;
  }
  utils$1.sum32_4 = at;
  function lt(Oe, rt, pe, nt, ot) {
    return Oe + rt + pe + nt + ot >>> 0;
  }
  utils$1.sum32_5 = lt;
  function ht(Oe, rt, pe, nt) {
    var ot = Oe[rt], st = Oe[rt + 1], ut = nt + st >>> 0, pt = (ut < nt ? 1 : 0) + pe + ot;
    Oe[rt] = pt >>> 0, Oe[rt + 1] = ut;
  }
  utils$1.sum64 = ht;
  function dt(Oe, rt, pe, nt) {
    var ot = rt + nt >>> 0, st = (ot < rt ? 1 : 0) + Oe + pe;
    return st >>> 0;
  }
  utils$1.sum64_hi = dt;
  function vt(Oe, rt, pe, nt) {
    var ot = rt + nt;
    return ot >>> 0;
  }
  utils$1.sum64_lo = vt;
  function mt(Oe, rt, pe, nt, ot, st, ut, pt) {
    var ft = 0, yt = rt;
    yt = yt + nt >>> 0, ft += yt < rt ? 1 : 0, yt = yt + st >>> 0, ft += yt < st ? 1 : 0, yt = yt + pt >>> 0, ft += yt < pt ? 1 : 0;
    var ct = Oe + pe + ot + ut + ft;
    return ct >>> 0;
  }
  utils$1.sum64_4_hi = mt;
  function Pt(Oe, rt, pe, nt, ot, st, ut, pt) {
    var ft = rt + nt + st + pt;
    return ft >>> 0;
  }
  utils$1.sum64_4_lo = Pt;
  function $t(Oe, rt, pe, nt, ot, st, ut, pt, ft, yt) {
    var ct = 0, Et = rt;
    Et = Et + nt >>> 0, ct += Et < rt ? 1 : 0, Et = Et + st >>> 0, ct += Et < st ? 1 : 0, Et = Et + pt >>> 0, ct += Et < pt ? 1 : 0, Et = Et + yt >>> 0, ct += Et < yt ? 1 : 0;
    var Nt = Oe + pe + ot + ut + ft + ct;
    return Nt >>> 0;
  }
  utils$1.sum64_5_hi = $t;
  function qt(Oe, rt, pe, nt, ot, st, ut, pt, ft, yt) {
    var ct = rt + nt + st + pt + yt;
    return ct >>> 0;
  }
  utils$1.sum64_5_lo = qt;
  function At(Oe, rt, pe) {
    var nt = rt << 32 - pe | Oe >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_hi = At;
  function bt(Oe, rt, pe) {
    var nt = Oe << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_lo = bt;
  function xt(Oe, rt, pe) {
    return Oe >>> pe;
  }
  utils$1.shr64_hi = xt;
  function wt(Oe, rt, pe) {
    var nt = Oe << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  return utils$1.shr64_lo = wt, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = L, L.prototype.update = function(J, W) {
    if (J = A.toArray(J, W), this.pending ? this.pending = this.pending.concat(J) : this.pending = J, this.pendingTotal += J.length, this.pending.length >= this._delta8) {
      J = this.pending;
      var V = J.length % this._delta8;
      this.pending = J.slice(J.length - V, J.length), this.pending.length === 0 && (this.pending = null), J = A.join32(J, 0, J.length - V, this.endian);
      for (var ne = 0; ne < J.length; ne += this._delta32)
        this._update(J, ne, ne + this._delta32);
    }
    return this;
  }, L.prototype.digest = function(J) {
    return this.update(this._pad()), B(this.pending === null), this._digest(J);
  }, L.prototype._pad = function() {
    var J = this.pendingTotal, W = this._delta8, V = W - (J + this.padLength) % W, ne = new Array(V + this.padLength);
    ne[0] = 128;
    for (var ie = 1; ie < V; ie++)
      ne[ie] = 0;
    if (J <<= 3, this.endian === "big") {
      for (var oe = 8; oe < this.padLength; oe++)
        ne[ie++] = 0;
      ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = J >>> 24 & 255, ne[ie++] = J >>> 16 & 255, ne[ie++] = J >>> 8 & 255, ne[ie++] = J & 255;
    } else
      for (ne[ie++] = J & 255, ne[ie++] = J >>> 8 & 255, ne[ie++] = J >>> 16 & 255, ne[ie++] = J >>> 24 & 255, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, oe = 8; oe < this.padLength; oe++)
        ne[ie++] = 0;
    return ne;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var A = requireUtils(), B = A.rotr32;
  function L(re, ce, ke, Ce) {
    if (re === 0)
      return K(ce, ke, Ce);
    if (re === 1 || re === 3)
      return W(ce, ke, Ce);
    if (re === 2)
      return J(ce, ke, Ce);
  }
  common.ft_1 = L;
  function K(re, ce, ke) {
    return re & ce ^ ~re & ke;
  }
  common.ch32 = K;
  function J(re, ce, ke) {
    return re & ce ^ re & ke ^ ce & ke;
  }
  common.maj32 = J;
  function W(re, ce, ke) {
    return re ^ ce ^ ke;
  }
  common.p32 = W;
  function V(re) {
    return B(re, 2) ^ B(re, 13) ^ B(re, 22);
  }
  common.s0_256 = V;
  function ne(re) {
    return B(re, 6) ^ B(re, 11) ^ B(re, 25);
  }
  common.s1_256 = ne;
  function ie(re) {
    return B(re, 7) ^ B(re, 18) ^ re >>> 3;
  }
  common.g0_256 = ie;
  function oe(re) {
    return B(re, 17) ^ B(re, 19) ^ re >>> 10;
  }
  return common.g1_256 = oe, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = A.rotl32, J = A.sum32, W = A.sum32_5, V = L.ft_1, ne = B.BlockHash, ie = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function oe() {
    if (!(this instanceof oe))
      return new oe();
    ne.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return A.inherits(oe, ne), _1 = oe, oe.blockSize = 512, oe.outSize = 160, oe.hmacStrength = 80, oe.padLength = 64, oe.prototype._update = function(ce, ke) {
    for (var Ce = this.W, it = 0; it < 16; it++)
      Ce[it] = ce[ke + it];
    for (; it < Ce.length; it++)
      Ce[it] = K(Ce[it - 3] ^ Ce[it - 8] ^ Ce[it - 14] ^ Ce[it - 16], 1);
    var at = this.h[0], lt = this.h[1], ht = this.h[2], dt = this.h[3], vt = this.h[4];
    for (it = 0; it < Ce.length; it++) {
      var mt = ~~(it / 20), Pt = W(K(at, 5), V(mt, lt, ht, dt), vt, Ce[it], ie[mt]);
      vt = dt, dt = ht, ht = K(lt, 30), lt = at, at = Pt;
    }
    this.h[0] = J(this.h[0], at), this.h[1] = J(this.h[1], lt), this.h[2] = J(this.h[2], ht), this.h[3] = J(this.h[3], dt), this.h[4] = J(this.h[4], vt);
  }, oe.prototype._digest = function(ce) {
    return ce === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = requireMinimalisticAssert(), J = A.sum32, W = A.sum32_4, V = A.sum32_5, ne = L.ch32, ie = L.maj32, oe = L.s0_256, re = L.s1_256, ce = L.g0_256, ke = L.g1_256, Ce = B.BlockHash, it = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function at() {
    if (!(this instanceof at))
      return new at();
    Ce.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = it, this.W = new Array(64);
  }
  return A.inherits(at, Ce), _256 = at, at.blockSize = 512, at.outSize = 256, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(ht, dt) {
    for (var vt = this.W, mt = 0; mt < 16; mt++)
      vt[mt] = ht[dt + mt];
    for (; mt < vt.length; mt++)
      vt[mt] = W(ke(vt[mt - 2]), vt[mt - 7], ce(vt[mt - 15]), vt[mt - 16]);
    var Pt = this.h[0], $t = this.h[1], qt = this.h[2], At = this.h[3], bt = this.h[4], xt = this.h[5], wt = this.h[6], Oe = this.h[7];
    for (K(this.k.length === vt.length), mt = 0; mt < vt.length; mt++) {
      var rt = V(Oe, re(bt), ne(bt, xt, wt), this.k[mt], vt[mt]), pe = J(oe(Pt), ie(Pt, $t, qt));
      Oe = wt, wt = xt, xt = bt, bt = J(At, rt), At = qt, qt = $t, $t = Pt, Pt = J(rt, pe);
    }
    this.h[0] = J(this.h[0], Pt), this.h[1] = J(this.h[1], $t), this.h[2] = J(this.h[2], qt), this.h[3] = J(this.h[3], At), this.h[4] = J(this.h[4], bt), this.h[5] = J(this.h[5], xt), this.h[6] = J(this.h[6], wt), this.h[7] = J(this.h[7], Oe);
  }, at.prototype._digest = function(ht) {
    return ht === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var A = requireUtils(), B = require_256();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return A.inherits(L, B), _224 = L, L.blockSize = 512, L.outSize = 224, L.hmacStrength = 192, L.padLength = 64, L.prototype._digest = function(J) {
    return J === "hex" ? A.toHex32(this.h.slice(0, 7), "big") : A.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireMinimalisticAssert(), K = A.rotr64_hi, J = A.rotr64_lo, W = A.shr64_hi, V = A.shr64_lo, ne = A.sum64, ie = A.sum64_hi, oe = A.sum64_lo, re = A.sum64_4_hi, ce = A.sum64_4_lo, ke = A.sum64_5_hi, Ce = A.sum64_5_lo, it = B.BlockHash, at = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function lt() {
    if (!(this instanceof lt))
      return new lt();
    it.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = at, this.W = new Array(160);
  }
  A.inherits(lt, it), _512 = lt, lt.blockSize = 1024, lt.outSize = 512, lt.hmacStrength = 192, lt.padLength = 128, lt.prototype._prepareBlock = function(pe, nt) {
    for (var ot = this.W, st = 0; st < 32; st++)
      ot[st] = pe[nt + st];
    for (; st < ot.length; st += 2) {
      var ut = wt(ot[st - 4], ot[st - 3]), pt = Oe(ot[st - 4], ot[st - 3]), ft = ot[st - 14], yt = ot[st - 13], ct = bt(ot[st - 30], ot[st - 29]), Et = xt(ot[st - 30], ot[st - 29]), Nt = ot[st - 32], jt = ot[st - 31];
      ot[st] = re(
        ut,
        pt,
        ft,
        yt,
        ct,
        Et,
        Nt,
        jt
      ), ot[st + 1] = ce(
        ut,
        pt,
        ft,
        yt,
        ct,
        Et,
        Nt,
        jt
      );
    }
  }, lt.prototype._update = function(pe, nt) {
    this._prepareBlock(pe, nt);
    var ot = this.W, st = this.h[0], ut = this.h[1], pt = this.h[2], ft = this.h[3], yt = this.h[4], ct = this.h[5], Et = this.h[6], Nt = this.h[7], jt = this.h[8], Ot = this.h[9], Bt = this.h[10], Tt = this.h[11], Ut = this.h[12], Gt = this.h[13], It = this.h[14], Mt = this.h[15];
    L(this.k.length === ot.length);
    for (var Kt = 0; Kt < ot.length; Kt += 2) {
      var Qt = It, rr = Mt, ar = qt(jt, Ot), ur = At(jt, Ot), hr = ht(jt, Ot, Bt, Tt, Ut), Yt = dt(jt, Ot, Bt, Tt, Ut, Gt), Rr = this.k[Kt], lr = this.k[Kt + 1], $r = ot[Kt], Br = ot[Kt + 1], dr = ke(
        Qt,
        rr,
        ar,
        ur,
        hr,
        Yt,
        Rr,
        lr,
        $r,
        Br
      ), Sr = Ce(
        Qt,
        rr,
        ar,
        ur,
        hr,
        Yt,
        Rr,
        lr,
        $r,
        Br
      );
      Qt = Pt(st, ut), rr = $t(st, ut), ar = vt(st, ut, pt, ft, yt), ur = mt(st, ut, pt, ft, yt, ct);
      var Mr = ie(Qt, rr, ar, ur), br = oe(Qt, rr, ar, ur);
      It = Ut, Mt = Gt, Ut = Bt, Gt = Tt, Bt = jt, Tt = Ot, jt = ie(Et, Nt, dr, Sr), Ot = oe(Nt, Nt, dr, Sr), Et = yt, Nt = ct, yt = pt, ct = ft, pt = st, ft = ut, st = ie(dr, Sr, Mr, br), ut = oe(dr, Sr, Mr, br);
    }
    ne(this.h, 0, st, ut), ne(this.h, 2, pt, ft), ne(this.h, 4, yt, ct), ne(this.h, 6, Et, Nt), ne(this.h, 8, jt, Ot), ne(this.h, 10, Bt, Tt), ne(this.h, 12, Ut, Gt), ne(this.h, 14, It, Mt);
  }, lt.prototype._digest = function(pe) {
    return pe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  };
  function ht(rt, pe, nt, ot, st) {
    var ut = rt & nt ^ ~rt & st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function dt(rt, pe, nt, ot, st, ut) {
    var pt = pe & ot ^ ~pe & ut;
    return pt < 0 && (pt += 4294967296), pt;
  }
  function vt(rt, pe, nt, ot, st) {
    var ut = rt & nt ^ rt & st ^ nt & st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function mt(rt, pe, nt, ot, st, ut) {
    var pt = pe & ot ^ pe & ut ^ ot & ut;
    return pt < 0 && (pt += 4294967296), pt;
  }
  function Pt(rt, pe) {
    var nt = K(rt, pe, 28), ot = K(pe, rt, 2), st = K(pe, rt, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function $t(rt, pe) {
    var nt = J(rt, pe, 28), ot = J(pe, rt, 2), st = J(pe, rt, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function qt(rt, pe) {
    var nt = K(rt, pe, 14), ot = K(rt, pe, 18), st = K(pe, rt, 9), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function At(rt, pe) {
    var nt = J(rt, pe, 14), ot = J(rt, pe, 18), st = J(pe, rt, 9), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function bt(rt, pe) {
    var nt = K(rt, pe, 1), ot = K(rt, pe, 8), st = W(rt, pe, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function xt(rt, pe) {
    var nt = J(rt, pe, 1), ot = J(rt, pe, 8), st = V(rt, pe, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function wt(rt, pe) {
    var nt = K(rt, pe, 19), ot = K(pe, rt, 29), st = W(rt, pe, 6), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function Oe(rt, pe) {
    var nt = J(rt, pe, 19), ot = J(pe, rt, 29), st = V(rt, pe, 6), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var A = requireUtils(), B = require_512();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return A.inherits(L, B), _384 = L, L.blockSize = 1024, L.outSize = 384, L.hmacStrength = 192, L.padLength = 128, L.prototype._digest = function(J) {
    return J === "hex" ? A.toHex32(this.h.slice(0, 12), "big") : A.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var A = requireUtils(), B = requireCommon$1(), L = A.rotl32, K = A.sum32, J = A.sum32_3, W = A.sum32_4, V = B.BlockHash;
  function ne() {
    if (!(this instanceof ne))
      return new ne();
    V.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  A.inherits(ne, V), ripemd.ripemd160 = ne, ne.blockSize = 512, ne.outSize = 160, ne.hmacStrength = 192, ne.padLength = 64, ne.prototype._update = function(lt, ht) {
    for (var dt = this.h[0], vt = this.h[1], mt = this.h[2], Pt = this.h[3], $t = this.h[4], qt = dt, At = vt, bt = mt, xt = Pt, wt = $t, Oe = 0; Oe < 80; Oe++) {
      var rt = K(
        L(
          W(dt, ie(Oe, vt, mt, Pt), lt[ce[Oe] + ht], oe(Oe)),
          Ce[Oe]
        ),
        $t
      );
      dt = $t, $t = Pt, Pt = L(mt, 10), mt = vt, vt = rt, rt = K(
        L(
          W(qt, ie(79 - Oe, At, bt, xt), lt[ke[Oe] + ht], re(Oe)),
          it[Oe]
        ),
        wt
      ), qt = wt, wt = xt, xt = L(bt, 10), bt = At, At = rt;
    }
    rt = J(this.h[1], mt, xt), this.h[1] = J(this.h[2], Pt, wt), this.h[2] = J(this.h[3], $t, qt), this.h[3] = J(this.h[4], dt, At), this.h[4] = J(this.h[0], vt, bt), this.h[0] = rt;
  }, ne.prototype._digest = function(lt) {
    return lt === "hex" ? A.toHex32(this.h, "little") : A.split32(this.h, "little");
  };
  function ie(at, lt, ht, dt) {
    return at <= 15 ? lt ^ ht ^ dt : at <= 31 ? lt & ht | ~lt & dt : at <= 47 ? (lt | ~ht) ^ dt : at <= 63 ? lt & dt | ht & ~dt : lt ^ (ht | ~dt);
  }
  function oe(at) {
    return at <= 15 ? 0 : at <= 31 ? 1518500249 : at <= 47 ? 1859775393 : at <= 63 ? 2400959708 : 2840853838;
  }
  function re(at) {
    return at <= 15 ? 1352829926 : at <= 31 ? 1548603684 : at <= 47 ? 1836072691 : at <= 63 ? 2053994217 : 0;
  }
  var ce = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ke = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Ce = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], it = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L(K, J, W) {
    if (!(this instanceof L))
      return new L(K, J, W);
    this.Hash = K, this.blockSize = K.blockSize / 8, this.outSize = K.outSize / 8, this.inner = null, this.outer = null, this._init(A.toArray(J, W));
  }
  return hmac = L, L.prototype._init = function(J) {
    J.length > this.blockSize && (J = new this.Hash().update(J).digest()), B(J.length <= this.blockSize);
    for (var W = J.length; W < this.blockSize; W++)
      J.push(0);
    for (W = 0; W < J.length; W++)
      J[W] ^= 54;
    for (this.inner = new this.Hash().update(J), W = 0; W < J.length; W++)
      J[W] ^= 106;
    this.outer = new this.Hash().update(J);
  }, L.prototype.update = function(J, W) {
    return this.inner.update(J, W), this;
  }, L.prototype.digest = function(J) {
    return this.outer.update(this.inner.digest()), this.outer.digest(J);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(A) {
    var B = A;
    B.utils = requireUtils(), B.common = requireCommon$1(), B.sha = requireSha(), B.ripemd = requireRipemd(), B.hmac = requireHmac(), B.sha1 = B.sha.sha1, B.sha256 = B.sha.sha256, B.sha224 = B.sha.sha224, B.sha384 = B.sha.sha384, B.sha512 = B.sha.sha512, B.ripemd160 = B.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(A) {
    var B = A, L = requireHash(), K = requireCurve(), J = requireUtils$1(), W = J.assert;
    function V(oe) {
      oe.type === "short" ? this.curve = new K.short(oe) : oe.type === "edwards" ? this.curve = new K.edwards(oe) : this.curve = new K.mont(oe), this.g = this.curve.g, this.n = this.curve.n, this.hash = oe.hash, W(this.g.validate(), "Invalid curve"), W(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    B.PresetCurve = V;
    function ne(oe, re) {
      Object.defineProperty(B, oe, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var ce = new V(re);
          return Object.defineProperty(B, oe, {
            configurable: !0,
            enumerable: !0,
            value: ce
          }), ce;
        }
      });
    }
    ne("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: L.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), ne("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: L.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), ne("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: L.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), ne("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: L.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), ne("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: L.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), ne("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), ne("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ie;
    try {
      ie = requireSecp256k1();
    } catch {
      ie = void 0;
    }
    ne("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: L.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ie
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var A = requireHash(), B = requireUtils$2(), L = requireMinimalisticAssert();
  function K(J) {
    if (!(this instanceof K))
      return new K(J);
    this.hash = J.hash, this.predResist = !!J.predResist, this.outLen = this.hash.outSize, this.minEntropy = J.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var W = B.toArray(J.entropy, J.entropyEnc || "hex"), V = B.toArray(J.nonce, J.nonceEnc || "hex"), ne = B.toArray(J.pers, J.persEnc || "hex");
    L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(W, V, ne);
  }
  return hmacDrbg = K, K.prototype._init = function(W, V, ne) {
    var ie = W.concat(V).concat(ne);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var oe = 0; oe < this.V.length; oe++)
      this.K[oe] = 0, this.V[oe] = 1;
    this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, K.prototype._hmac = function() {
    return new A.hmac(this.hash, this.K);
  }, K.prototype._update = function(W) {
    var V = this._hmac().update(this.V).update([0]);
    W && (V = V.update(W)), this.K = V.digest(), this.V = this._hmac().update(this.V).digest(), W && (this.K = this._hmac().update(this.V).update([1]).update(W).digest(), this.V = this._hmac().update(this.V).digest());
  }, K.prototype.reseed = function(W, V, ne, ie) {
    typeof V != "string" && (ie = ne, ne = V, V = null), W = B.toArray(W, V), ne = B.toArray(ne, ie), L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(W.concat(ne || [])), this._reseed = 1;
  }, K.prototype.generate = function(W, V, ne, ie) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof V != "string" && (ie = ne, ne = V, V = null), ne && (ne = B.toArray(ne, ie || "hex"), this._update(ne));
    for (var oe = []; oe.length < W; )
      this.V = this._hmac().update(this.V).digest(), oe = oe.concat(this.V);
    var re = oe.slice(0, W);
    return this._update(ne), this._reseed++, B.encode(re, V);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(J, W) {
    this.ec = J, this.priv = null, this.pub = null, W.priv && this._importPrivate(W.priv, W.privEnc), W.pub && this._importPublic(W.pub, W.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(W, V, ne) {
    return V instanceof K ? V : new K(W, {
      pub: V,
      pubEnc: ne
    });
  }, K.fromPrivate = function(W, V, ne) {
    return V instanceof K ? V : new K(W, {
      priv: V,
      privEnc: ne
    });
  }, K.prototype.validate = function() {
    var W = this.getPublic();
    return W.isInfinity() ? { result: !1, reason: "Invalid public key" } : W.validate() ? W.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(W, V) {
    return typeof W == "string" && (V = W, W = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), V ? this.pub.encode(V, W) : this.pub;
  }, K.prototype.getPrivate = function(W) {
    return W === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(W, V) {
    this.priv = new A(W, V || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(W, V) {
    if (W.x || W.y) {
      this.ec.curve.type === "mont" ? L(W.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && L(W.x && W.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(W.x, W.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(W, V);
  }, K.prototype.derive = function(W) {
    return W.validate() || L(W.validate(), "public point not validated"), W.mul(this.priv).getX();
  }, K.prototype.sign = function(W, V, ne) {
    return this.ec.sign(W, this, V, ne);
  }, K.prototype.verify = function(W, V) {
    return this.ec.verify(W, V, this);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(ie, oe) {
    if (ie instanceof K)
      return ie;
    this._importDER(ie, oe) || (L(ie.r && ie.s, "Signature without r or s"), this.r = new A(ie.r, 16), this.s = new A(ie.s, 16), ie.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ie.recoveryParam);
  }
  signature$1 = K;
  function J() {
    this.place = 0;
  }
  function W(ie, oe) {
    var re = ie[oe.place++];
    if (!(re & 128))
      return re;
    var ce = re & 15;
    if (ce === 0 || ce > 4 || ie[oe.place] === 0)
      return !1;
    for (var ke = 0, Ce = 0, it = oe.place; Ce < ce; Ce++, it++)
      ke <<= 8, ke |= ie[it], ke >>>= 0;
    return ke <= 127 ? !1 : (oe.place = it, ke);
  }
  function V(ie) {
    for (var oe = 0, re = ie.length - 1; !ie[oe] && !(ie[oe + 1] & 128) && oe < re; )
      oe++;
    return oe === 0 ? ie : ie.slice(oe);
  }
  K.prototype._importDER = function(oe, re) {
    oe = B.toArray(oe, re);
    var ce = new J();
    if (oe[ce.place++] !== 48)
      return !1;
    var ke = W(oe, ce);
    if (ke === !1 || ke + ce.place !== oe.length || oe[ce.place++] !== 2)
      return !1;
    var Ce = W(oe, ce);
    if (Ce === !1 || oe[ce.place] & 128)
      return !1;
    var it = oe.slice(ce.place, Ce + ce.place);
    if (ce.place += Ce, oe[ce.place++] !== 2)
      return !1;
    var at = W(oe, ce);
    if (at === !1 || oe.length !== at + ce.place || oe[ce.place] & 128)
      return !1;
    var lt = oe.slice(ce.place, at + ce.place);
    if (it[0] === 0)
      if (it[1] & 128)
        it = it.slice(1);
      else
        return !1;
    if (lt[0] === 0)
      if (lt[1] & 128)
        lt = lt.slice(1);
      else
        return !1;
    return this.r = new A(it), this.s = new A(lt), this.recoveryParam = null, !0;
  };
  function ne(ie, oe) {
    if (oe < 128) {
      ie.push(oe);
      return;
    }
    var re = 1 + (Math.log(oe) / Math.LN2 >>> 3);
    for (ie.push(re | 128); --re; )
      ie.push(oe >>> (re << 3) & 255);
    ie.push(oe);
  }
  return K.prototype.toDER = function(oe) {
    var re = this.r.toArray(), ce = this.s.toArray();
    for (re[0] & 128 && (re = [0].concat(re)), ce[0] & 128 && (ce = [0].concat(ce)), re = V(re), ce = V(ce); !ce[0] && !(ce[1] & 128); )
      ce = ce.slice(1);
    var ke = [2];
    ne(ke, re.length), ke = ke.concat(re), ke.push(2), ne(ke, ce.length);
    var Ce = ke.concat(ce), it = [48];
    return ne(it, Ce.length), it = it.concat(Ce), B.encode(it, oe);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var A = requireBn$1(), B = requireHmacDrbg(), L = requireUtils$1(), K = requireCurves(), J = requireBrorand(), W = L.assert, V = requireKey$1(), ne = requireSignature$1();
  function ie(oe) {
    if (!(this instanceof ie))
      return new ie(oe);
    typeof oe == "string" && (W(
      Object.prototype.hasOwnProperty.call(K, oe),
      "Unknown curve " + oe
    ), oe = K[oe]), oe instanceof K.PresetCurve && (oe = { curve: oe }), this.curve = oe.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = oe.curve.g, this.g.precompute(oe.curve.n.bitLength() + 1), this.hash = oe.hash || oe.curve.hash;
  }
  return ec = ie, ie.prototype.keyPair = function(re) {
    return new V(this, re);
  }, ie.prototype.keyFromPrivate = function(re, ce) {
    return V.fromPrivate(this, re, ce);
  }, ie.prototype.keyFromPublic = function(re, ce) {
    return V.fromPublic(this, re, ce);
  }, ie.prototype.genKeyPair = function(re) {
    re || (re = {});
    for (var ce = new B({
      hash: this.hash,
      pers: re.pers,
      persEnc: re.persEnc || "utf8",
      entropy: re.entropy || J(this.hash.hmacStrength),
      entropyEnc: re.entropy && re.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), ke = this.n.byteLength(), Ce = this.n.sub(new A(2)); ; ) {
      var it = new A(ce.generate(ke));
      if (!(it.cmp(Ce) > 0))
        return it.iaddn(1), this.keyFromPrivate(it);
    }
  }, ie.prototype._truncateToN = function(re, ce) {
    var ke = re.byteLength() * 8 - this.n.bitLength();
    return ke > 0 && (re = re.ushrn(ke)), !ce && re.cmp(this.n) >= 0 ? re.sub(this.n) : re;
  }, ie.prototype.sign = function(re, ce, ke, Ce) {
    typeof ke == "object" && (Ce = ke, ke = null), Ce || (Ce = {}), ce = this.keyFromPrivate(ce, ke), re = this._truncateToN(new A(re, 16));
    for (var it = this.n.byteLength(), at = ce.getPrivate().toArray("be", it), lt = re.toArray("be", it), ht = new B({
      hash: this.hash,
      entropy: at,
      nonce: lt,
      pers: Ce.pers,
      persEnc: Ce.persEnc || "utf8"
    }), dt = this.n.sub(new A(1)), vt = 0; ; vt++) {
      var mt = Ce.k ? Ce.k(vt) : new A(ht.generate(this.n.byteLength()));
      if (mt = this._truncateToN(mt, !0), !(mt.cmpn(1) <= 0 || mt.cmp(dt) >= 0)) {
        var Pt = this.g.mul(mt);
        if (!Pt.isInfinity()) {
          var $t = Pt.getX(), qt = $t.umod(this.n);
          if (qt.cmpn(0) !== 0) {
            var At = mt.invm(this.n).mul(qt.mul(ce.getPrivate()).iadd(re));
            if (At = At.umod(this.n), At.cmpn(0) !== 0) {
              var bt = (Pt.getY().isOdd() ? 1 : 0) | ($t.cmp(qt) !== 0 ? 2 : 0);
              return Ce.canonical && At.cmp(this.nh) > 0 && (At = this.n.sub(At), bt ^= 1), new ne({ r: qt, s: At, recoveryParam: bt });
            }
          }
        }
      }
    }
  }, ie.prototype.verify = function(re, ce, ke, Ce) {
    re = this._truncateToN(new A(re, 16)), ke = this.keyFromPublic(ke, Ce), ce = new ne(ce, "hex");
    var it = ce.r, at = ce.s;
    if (it.cmpn(1) < 0 || it.cmp(this.n) >= 0 || at.cmpn(1) < 0 || at.cmp(this.n) >= 0)
      return !1;
    var lt = at.invm(this.n), ht = lt.mul(re).umod(this.n), dt = lt.mul(it).umod(this.n), vt;
    return this.curve._maxwellTrick ? (vt = this.g.jmulAdd(ht, ke.getPublic(), dt), vt.isInfinity() ? !1 : vt.eqXToP(it)) : (vt = this.g.mulAdd(ht, ke.getPublic(), dt), vt.isInfinity() ? !1 : vt.getX().umod(this.n).cmp(it) === 0);
  }, ie.prototype.recoverPubKey = function(oe, re, ce, ke) {
    W((3 & ce) === ce, "The recovery param is more than two bits"), re = new ne(re, ke);
    var Ce = this.n, it = new A(oe), at = re.r, lt = re.s, ht = ce & 1, dt = ce >> 1;
    if (at.cmp(this.curve.p.umod(this.curve.n)) >= 0 && dt)
      throw new Error("Unable to find sencond key candinate");
    dt ? at = this.curve.pointFromX(at.add(this.curve.n), ht) : at = this.curve.pointFromX(at, ht);
    var vt = re.r.invm(Ce), mt = Ce.sub(it).mul(vt).umod(Ce), Pt = lt.mul(vt).umod(Ce);
    return this.g.mulAdd(mt, at, Pt);
  }, ie.prototype.getKeyRecoveryParam = function(oe, re, ce, ke) {
    if (re = new ne(re, ke), re.recoveryParam !== null)
      return re.recoveryParam;
    for (var Ce = 0; Ce < 4; Ce++) {
      var it;
      try {
        it = this.recoverPubKey(oe, re, Ce);
      } catch {
        continue;
      }
      if (it.eq(ce))
        return Ce;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var A = requireUtils$1(), B = A.assert, L = A.parseBytes, K = A.cachedProperty;
  function J(W, V) {
    this.eddsa = W, this._secret = L(V.secret), W.isPoint(V.pub) ? this._pub = V.pub : this._pubBytes = L(V.pub);
  }
  return J.fromPublic = function(V, ne) {
    return ne instanceof J ? ne : new J(V, { pub: ne });
  }, J.fromSecret = function(V, ne) {
    return ne instanceof J ? ne : new J(V, { secret: ne });
  }, J.prototype.secret = function() {
    return this._secret;
  }, K(J, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), K(J, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), K(J, "privBytes", function() {
    var V = this.eddsa, ne = this.hash(), ie = V.encodingLength - 1, oe = ne.slice(0, V.encodingLength);
    return oe[0] &= 248, oe[ie] &= 127, oe[ie] |= 64, oe;
  }), K(J, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), K(J, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), K(J, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), J.prototype.sign = function(V) {
    return B(this._secret, "KeyPair can only verify"), this.eddsa.sign(V, this);
  }, J.prototype.verify = function(V, ne) {
    return this.eddsa.verify(V, ne, this);
  }, J.prototype.getSecret = function(V) {
    return B(this._secret, "KeyPair is public only"), A.encode(this.secret(), V);
  }, J.prototype.getPublic = function(V) {
    return A.encode(this.pubBytes(), V);
  }, key = J, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert, K = B.cachedProperty, J = B.parseBytes;
  function W(V, ne) {
    this.eddsa = V, typeof ne != "object" && (ne = J(ne)), Array.isArray(ne) && (L(ne.length === V.encodingLength * 2, "Signature has invalid size"), ne = {
      R: ne.slice(0, V.encodingLength),
      S: ne.slice(V.encodingLength)
    }), L(ne.R && ne.S, "Signature without R or S"), V.isPoint(ne.R) && (this._R = ne.R), ne.S instanceof A && (this._S = ne.S), this._Rencoded = Array.isArray(ne.R) ? ne.R : ne.Rencoded, this._Sencoded = Array.isArray(ne.S) ? ne.S : ne.Sencoded;
  }
  return K(W, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), K(W, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), K(W, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), K(W, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), W.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, W.prototype.toHex = function() {
    return B.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = W, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var A = requireHash(), B = requireCurves(), L = requireUtils$1(), K = L.assert, J = L.parseBytes, W = requireKey(), V = requireSignature();
  function ne(ie) {
    if (K(ie === "ed25519", "only tested with ed25519 so far"), !(this instanceof ne))
      return new ne(ie);
    ie = B[ie].curve, this.curve = ie, this.g = ie.g, this.g.precompute(ie.n.bitLength() + 1), this.pointClass = ie.point().constructor, this.encodingLength = Math.ceil(ie.n.bitLength() / 8), this.hash = A.sha512;
  }
  return eddsa = ne, ne.prototype.sign = function(oe, re) {
    oe = J(oe);
    var ce = this.keyFromSecret(re), ke = this.hashInt(ce.messagePrefix(), oe), Ce = this.g.mul(ke), it = this.encodePoint(Ce), at = this.hashInt(it, ce.pubBytes(), oe).mul(ce.priv()), lt = ke.add(at).umod(this.curve.n);
    return this.makeSignature({ R: Ce, S: lt, Rencoded: it });
  }, ne.prototype.verify = function(oe, re, ce) {
    if (oe = J(oe), re = this.makeSignature(re), re.S().gte(re.eddsa.curve.n) || re.S().isNeg())
      return !1;
    var ke = this.keyFromPublic(ce), Ce = this.hashInt(re.Rencoded(), ke.pubBytes(), oe), it = this.g.mul(re.S()), at = re.R().add(ke.pub().mul(Ce));
    return at.eq(it);
  }, ne.prototype.hashInt = function() {
    for (var oe = this.hash(), re = 0; re < arguments.length; re++)
      oe.update(arguments[re]);
    return L.intFromLE(oe.digest()).umod(this.curve.n);
  }, ne.prototype.keyFromPublic = function(oe) {
    return W.fromPublic(this, oe);
  }, ne.prototype.keyFromSecret = function(oe) {
    return W.fromSecret(this, oe);
  }, ne.prototype.makeSignature = function(oe) {
    return oe instanceof V ? oe : new V(this, oe);
  }, ne.prototype.encodePoint = function(oe) {
    var re = oe.getY().toArray("le", this.encodingLength);
    return re[this.encodingLength - 1] |= oe.getX().isOdd() ? 128 : 0, re;
  }, ne.prototype.decodePoint = function(oe) {
    oe = L.parseBytes(oe);
    var re = oe.length - 1, ce = oe.slice(0, re).concat(oe[re] & -129), ke = (oe[re] & 128) !== 0, Ce = L.intFromLE(ce);
    return this.curve.pointFromY(Ce, ke);
  }, ne.prototype.encodeInt = function(oe) {
    return oe.toArray("le", this.encodingLength);
  }, ne.prototype.decodeInt = function(oe) {
    return L.intFromLE(oe);
  }, ne.prototype.isPoint = function(oe) {
    return oe instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(A) {
    var B = A;
    B.version = require$$0.version, B.utils = requireUtils$1(), B.rand = requireBrorand(), B.curve = requireCurve(), B.curves = requireCurves(), B.ec = requireEc(), B.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(A, B) {
      if (A.indexOf) return A.indexOf(B);
      for (var L = 0; L < A.length; L++)
        if (A[L] === B) return L;
      return -1;
    }, Object_keys = function(A) {
      if (Object.keys) return Object.keys(A);
      var B = [];
      for (var L in A) B.push(L);
      return B;
    }, forEach = function(A, B) {
      if (A.forEach) return A.forEach(B);
      for (var L = 0; L < A.length; L++)
        B(A[L], L, A);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(A, B, L) {
          Object.defineProperty(A, B, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: L
          });
        };
      } catch {
        return function(B, L, K) {
          B[L] = K;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(A) {
      if (!(A instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var B = document.createElement("iframe");
      B.style || (B.style = {}), B.style.display = "none", document.body.appendChild(B);
      var L = B.contentWindow, K = L.eval, J = L.execScript;
      !K && J && (J.call(L, "null"), K = L.eval), forEach(Object_keys(A), function(ne) {
        L[ne] = A[ne];
      }), forEach(globals, function(ne) {
        A[ne] && (L[ne] = A[ne]);
      });
      var W = Object_keys(L), V = K.call(L, this.code);
      return forEach(Object_keys(L), function(ne) {
        (ne in A || indexOf(W, ne) === -1) && (A[ne] = L[ne]);
      }), forEach(globals, function(ne) {
        ne in A || defineProp(A, ne, L[ne]);
      }), document.body.removeChild(B), V;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(A) {
      var B = Script.createContext(A), L = this.runInContext(B);
      return A && forEach(Object_keys(B), function(K) {
        A[K] = B[K];
      }), L;
    }, forEach(Object_keys(Script.prototype), function(A) {
      exports[A] = Script[A] = function(B) {
        var L = Script(B);
        return L[A].apply(L, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(A) {
      return A instanceof Context;
    }, exports.createScript = function(A) {
      return exports.Script(A);
    }, exports.createContext = Script.createContext = function(A) {
      var B = new Context();
      return typeof A == "object" && forEach(Object_keys(A), function(L) {
        B[L] = A[L];
      }), B;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(A) {
    var B = requireAsn1$1(), L = requireInherits_browser(), K = A;
    K.define = function(V, ne) {
      return new J(V, ne);
    };
    function J(W, V) {
      this.name = W, this.body = V, this.decoders = {}, this.encoders = {};
    }
    J.prototype._createNamed = function(V) {
      var ne;
      try {
        ne = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ne = function(oe) {
          this._initNamed(oe);
        };
      }
      return L(ne, V), ne.prototype._initNamed = function(oe) {
        V.call(this, oe);
      }, new ne(this);
    }, J.prototype._getDecoder = function(V) {
      return V = V || "der", this.decoders.hasOwnProperty(V) || (this.decoders[V] = this._createNamed(B.decoders[V])), this.decoders[V];
    }, J.prototype.decode = function(V, ne, ie) {
      return this._getDecoder(ne).decode(V, ie);
    }, J.prototype._getEncoder = function(V) {
      return V = V || "der", this.encoders.hasOwnProperty(V) || (this.encoders[V] = this._createNamed(B.encoders[V])), this.encoders[V];
    }, J.prototype.encode = function(V, ne, ie) {
      return this._getEncoder(ne).encode(V, ie);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var A = requireInherits_browser();
  function B(K) {
    this._reporterState = {
      obj: null,
      path: [],
      options: K || {},
      errors: []
    };
  }
  reporter.Reporter = B, B.prototype.isError = function(J) {
    return J instanceof L;
  }, B.prototype.save = function() {
    var J = this._reporterState;
    return { obj: J.obj, pathLen: J.path.length };
  }, B.prototype.restore = function(J) {
    var W = this._reporterState;
    W.obj = J.obj, W.path = W.path.slice(0, J.pathLen);
  }, B.prototype.enterKey = function(J) {
    return this._reporterState.path.push(J);
  }, B.prototype.exitKey = function(J) {
    var W = this._reporterState;
    W.path = W.path.slice(0, J - 1);
  }, B.prototype.leaveKey = function(J, W, V) {
    var ne = this._reporterState;
    this.exitKey(J), ne.obj !== null && (ne.obj[W] = V);
  }, B.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, B.prototype.enterObject = function() {
    var J = this._reporterState, W = J.obj;
    return J.obj = {}, W;
  }, B.prototype.leaveObject = function(J) {
    var W = this._reporterState, V = W.obj;
    return W.obj = J, V;
  }, B.prototype.error = function(J) {
    var W, V = this._reporterState, ne = J instanceof L;
    if (ne ? W = J : W = new L(V.path.map(function(ie) {
      return "[" + JSON.stringify(ie) + "]";
    }).join(""), J.message || J, J.stack), !V.options.partial)
      throw W;
    return ne || V.errors.push(W), W;
  }, B.prototype.wrapResult = function(J) {
    var W = this._reporterState;
    return W.options.partial ? {
      result: this.isError(J) ? null : J,
      errors: W.errors
    } : J;
  };
  function L(K, J) {
    this.path = K, this.rethrow(J);
  }
  return A(L, Error), L.prototype.rethrow = function(J) {
    if (this.message = J + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, L), !this.stack)
      try {
        throw new Error(this.message);
      } catch (W) {
        this.stack = W.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var A = requireInherits_browser(), B = requireBase().Reporter, L = require$$0$1.Buffer;
  function K(W, V) {
    if (B.call(this, V), !L.isBuffer(W)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = W, this.offset = 0, this.length = W.length;
  }
  A(K, B), buffer.DecoderBuffer = K, K.prototype.save = function() {
    return { offset: this.offset, reporter: B.prototype.save.call(this) };
  }, K.prototype.restore = function(V) {
    var ne = new K(this.base);
    return ne.offset = V.offset, ne.length = this.offset, this.offset = V.offset, B.prototype.restore.call(this, V.reporter), ne;
  }, K.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, K.prototype.readUInt8 = function(V) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(V || "DecoderBuffer overrun");
  }, K.prototype.skip = function(V, ne) {
    if (!(this.offset + V <= this.length))
      return this.error(ne || "DecoderBuffer overrun");
    var ie = new K(this.base);
    return ie._reporterState = this._reporterState, ie.offset = this.offset, ie.length = this.offset + V, this.offset += V, ie;
  }, K.prototype.raw = function(V) {
    return this.base.slice(V ? V.offset : this.offset, this.length);
  };
  function J(W, V) {
    if (Array.isArray(W))
      this.length = 0, this.value = W.map(function(ne) {
        return ne instanceof J || (ne = new J(ne, V)), this.length += ne.length, ne;
      }, this);
    else if (typeof W == "number") {
      if (!(0 <= W && W <= 255))
        return V.error("non-byte EncoderBuffer value");
      this.value = W, this.length = 1;
    } else if (typeof W == "string")
      this.value = W, this.length = L.byteLength(W);
    else if (L.isBuffer(W))
      this.value = W, this.length = W.length;
    else
      return V.error("Unsupported type: " + typeof W);
  }
  return buffer.EncoderBuffer = J, J.prototype.join = function(V, ne) {
    return V || (V = new L(this.length)), ne || (ne = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ie) {
      ie.join(V, ne), ne += ie.length;
    }) : (typeof this.value == "number" ? V[ne] = this.value : typeof this.value == "string" ? V.write(this.value, ne) : L.isBuffer(this.value) && this.value.copy(V, ne), ne += this.length)), V;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var A = requireBase().Reporter, B = requireBase().EncoderBuffer, L = requireBase().DecoderBuffer, K = requireMinimalisticAssert(), J = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], W = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(J), V = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ne(oe, re) {
    var ce = {};
    this._baseState = ce, ce.enc = oe, ce.parent = re || null, ce.children = null, ce.tag = null, ce.args = null, ce.reverseArgs = null, ce.choice = null, ce.optional = !1, ce.any = !1, ce.obj = !1, ce.use = null, ce.useDecoder = null, ce.key = null, ce.default = null, ce.explicit = null, ce.implicit = null, ce.contains = null, ce.parent || (ce.children = [], this._wrap());
  }
  node = ne;
  var ie = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ne.prototype.clone = function() {
    var re = this._baseState, ce = {};
    ie.forEach(function(Ce) {
      ce[Ce] = re[Ce];
    });
    var ke = new this.constructor(ce.parent);
    return ke._baseState = ce, ke;
  }, ne.prototype._wrap = function() {
    var re = this._baseState;
    W.forEach(function(ce) {
      this[ce] = function() {
        var Ce = new this.constructor(this);
        return re.children.push(Ce), Ce[ce].apply(Ce, arguments);
      };
    }, this);
  }, ne.prototype._init = function(re) {
    var ce = this._baseState;
    K(ce.parent === null), re.call(this), ce.children = ce.children.filter(function(ke) {
      return ke._baseState.parent === this;
    }, this), K.equal(ce.children.length, 1, "Root node can have only one child");
  }, ne.prototype._useArgs = function(re) {
    var ce = this._baseState, ke = re.filter(function(Ce) {
      return Ce instanceof this.constructor;
    }, this);
    re = re.filter(function(Ce) {
      return !(Ce instanceof this.constructor);
    }, this), ke.length !== 0 && (K(ce.children === null), ce.children = ke, ke.forEach(function(Ce) {
      Ce._baseState.parent = this;
    }, this)), re.length !== 0 && (K(ce.args === null), ce.args = re, ce.reverseArgs = re.map(function(Ce) {
      if (typeof Ce != "object" || Ce.constructor !== Object)
        return Ce;
      var it = {};
      return Object.keys(Ce).forEach(function(at) {
        at == (at | 0) && (at |= 0);
        var lt = Ce[at];
        it[lt] = at;
      }), it;
    }));
  }, V.forEach(function(oe) {
    ne.prototype[oe] = function() {
      var ce = this._baseState;
      throw new Error(oe + " not implemented for encoding: " + ce.enc);
    };
  }), J.forEach(function(oe) {
    ne.prototype[oe] = function() {
      var ce = this._baseState, ke = Array.prototype.slice.call(arguments);
      return K(ce.tag === null), ce.tag = oe, this._useArgs(ke), this;
    };
  }), ne.prototype.use = function(re) {
    K(re);
    var ce = this._baseState;
    return K(ce.use === null), ce.use = re, this;
  }, ne.prototype.optional = function() {
    var re = this._baseState;
    return re.optional = !0, this;
  }, ne.prototype.def = function(re) {
    var ce = this._baseState;
    return K(ce.default === null), ce.default = re, ce.optional = !0, this;
  }, ne.prototype.explicit = function(re) {
    var ce = this._baseState;
    return K(ce.explicit === null && ce.implicit === null), ce.explicit = re, this;
  }, ne.prototype.implicit = function(re) {
    var ce = this._baseState;
    return K(ce.explicit === null && ce.implicit === null), ce.implicit = re, this;
  }, ne.prototype.obj = function() {
    var re = this._baseState, ce = Array.prototype.slice.call(arguments);
    return re.obj = !0, ce.length !== 0 && this._useArgs(ce), this;
  }, ne.prototype.key = function(re) {
    var ce = this._baseState;
    return K(ce.key === null), ce.key = re, this;
  }, ne.prototype.any = function() {
    var re = this._baseState;
    return re.any = !0, this;
  }, ne.prototype.choice = function(re) {
    var ce = this._baseState;
    return K(ce.choice === null), ce.choice = re, this._useArgs(Object.keys(re).map(function(ke) {
      return re[ke];
    })), this;
  }, ne.prototype.contains = function(re) {
    var ce = this._baseState;
    return K(ce.use === null), ce.contains = re, this;
  }, ne.prototype._decode = function(re, ce) {
    var ke = this._baseState;
    if (ke.parent === null)
      return re.wrapResult(ke.children[0]._decode(re, ce));
    var Ce = ke.default, it = !0, at = null;
    if (ke.key !== null && (at = re.enterKey(ke.key)), ke.optional) {
      var lt = null;
      if (ke.explicit !== null ? lt = ke.explicit : ke.implicit !== null ? lt = ke.implicit : ke.tag !== null && (lt = ke.tag), lt === null && !ke.any) {
        var ht = re.save();
        try {
          ke.choice === null ? this._decodeGeneric(ke.tag, re, ce) : this._decodeChoice(re, ce), it = !0;
        } catch {
          it = !1;
        }
        re.restore(ht);
      } else if (it = this._peekTag(re, lt, ke.any), re.isError(it))
        return it;
    }
    var dt;
    if (ke.obj && it && (dt = re.enterObject()), it) {
      if (ke.explicit !== null) {
        var vt = this._decodeTag(re, ke.explicit);
        if (re.isError(vt))
          return vt;
        re = vt;
      }
      var mt = re.offset;
      if (ke.use === null && ke.choice === null) {
        if (ke.any)
          var ht = re.save();
        var Pt = this._decodeTag(
          re,
          ke.implicit !== null ? ke.implicit : ke.tag,
          ke.any
        );
        if (re.isError(Pt))
          return Pt;
        ke.any ? Ce = re.raw(ht) : re = Pt;
      }
      if (ce && ce.track && ke.tag !== null && ce.track(re.path(), mt, re.length, "tagged"), ce && ce.track && ke.tag !== null && ce.track(re.path(), re.offset, re.length, "content"), ke.any ? Ce = Ce : ke.choice === null ? Ce = this._decodeGeneric(ke.tag, re, ce) : Ce = this._decodeChoice(re, ce), re.isError(Ce))
        return Ce;
      if (!ke.any && ke.choice === null && ke.children !== null && ke.children.forEach(function(At) {
        At._decode(re, ce);
      }), ke.contains && (ke.tag === "octstr" || ke.tag === "bitstr")) {
        var $t = new L(Ce);
        Ce = this._getUse(ke.contains, re._reporterState.obj)._decode($t, ce);
      }
    }
    return ke.obj && it && (Ce = re.leaveObject(dt)), ke.key !== null && (Ce !== null || it === !0) ? re.leaveKey(at, ke.key, Ce) : at !== null && re.exitKey(at), Ce;
  }, ne.prototype._decodeGeneric = function(re, ce, ke) {
    var Ce = this._baseState;
    return re === "seq" || re === "set" ? null : re === "seqof" || re === "setof" ? this._decodeList(ce, re, Ce.args[0], ke) : /str$/.test(re) ? this._decodeStr(ce, re, ke) : re === "objid" && Ce.args ? this._decodeObjid(ce, Ce.args[0], Ce.args[1], ke) : re === "objid" ? this._decodeObjid(ce, null, null, ke) : re === "gentime" || re === "utctime" ? this._decodeTime(ce, re, ke) : re === "null_" ? this._decodeNull(ce, ke) : re === "bool" ? this._decodeBool(ce, ke) : re === "objDesc" ? this._decodeStr(ce, re, ke) : re === "int" || re === "enum" ? this._decodeInt(ce, Ce.args && Ce.args[0], ke) : Ce.use !== null ? this._getUse(Ce.use, ce._reporterState.obj)._decode(ce, ke) : ce.error("unknown tag: " + re);
  }, ne.prototype._getUse = function(re, ce) {
    var ke = this._baseState;
    return ke.useDecoder = this._use(re, ce), K(ke.useDecoder._baseState.parent === null), ke.useDecoder = ke.useDecoder._baseState.children[0], ke.implicit !== ke.useDecoder._baseState.implicit && (ke.useDecoder = ke.useDecoder.clone(), ke.useDecoder._baseState.implicit = ke.implicit), ke.useDecoder;
  }, ne.prototype._decodeChoice = function(re, ce) {
    var ke = this._baseState, Ce = null, it = !1;
    return Object.keys(ke.choice).some(function(at) {
      var lt = re.save(), ht = ke.choice[at];
      try {
        var dt = ht._decode(re, ce);
        if (re.isError(dt))
          return !1;
        Ce = { type: at, value: dt }, it = !0;
      } catch {
        return re.restore(lt), !1;
      }
      return !0;
    }, this), it ? Ce : re.error("Choice not matched");
  }, ne.prototype._createEncoderBuffer = function(re) {
    return new B(re, this.reporter);
  }, ne.prototype._encode = function(re, ce, ke) {
    var Ce = this._baseState;
    if (!(Ce.default !== null && Ce.default === re)) {
      var it = this._encodeValue(re, ce, ke);
      if (it !== void 0 && !this._skipDefault(it, ce, ke))
        return it;
    }
  }, ne.prototype._encodeValue = function(re, ce, ke) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return Ce.children[0]._encode(re, ce || new A());
    var ht = null;
    if (this.reporter = ce, Ce.optional && re === void 0)
      if (Ce.default !== null)
        re = Ce.default;
      else
        return;
    var it = null, at = !1;
    if (Ce.any)
      ht = this._createEncoderBuffer(re);
    else if (Ce.choice)
      ht = this._encodeChoice(re, ce);
    else if (Ce.contains)
      it = this._getUse(Ce.contains, ke)._encode(re, ce), at = !0;
    else if (Ce.children)
      it = Ce.children.map(function(mt) {
        if (mt._baseState.tag === "null_")
          return mt._encode(null, ce, re);
        if (mt._baseState.key === null)
          return ce.error("Child should have a key");
        var Pt = ce.enterKey(mt._baseState.key);
        if (typeof re != "object")
          return ce.error("Child expected, but input is not object");
        var $t = mt._encode(re[mt._baseState.key], ce, re);
        return ce.leaveKey(Pt), $t;
      }, this).filter(function(mt) {
        return mt;
      }), it = this._createEncoderBuffer(it);
    else if (Ce.tag === "seqof" || Ce.tag === "setof") {
      if (!(Ce.args && Ce.args.length === 1))
        return ce.error("Too many args for : " + Ce.tag);
      if (!Array.isArray(re))
        return ce.error("seqof/setof, but data is not Array");
      var lt = this.clone();
      lt._baseState.implicit = null, it = this._createEncoderBuffer(re.map(function(mt) {
        var Pt = this._baseState;
        return this._getUse(Pt.args[0], re)._encode(mt, ce);
      }, lt));
    } else Ce.use !== null ? ht = this._getUse(Ce.use, ke)._encode(re, ce) : (it = this._encodePrimitive(Ce.tag, re), at = !0);
    var ht;
    if (!Ce.any && Ce.choice === null) {
      var dt = Ce.implicit !== null ? Ce.implicit : Ce.tag, vt = Ce.implicit === null ? "universal" : "context";
      dt === null ? Ce.use === null && ce.error("Tag could be omitted only for .use()") : Ce.use === null && (ht = this._encodeComposite(dt, at, vt, it));
    }
    return Ce.explicit !== null && (ht = this._encodeComposite(Ce.explicit, !1, "context", ht)), ht;
  }, ne.prototype._encodeChoice = function(re, ce) {
    var ke = this._baseState, Ce = ke.choice[re.type];
    return Ce || K(
      !1,
      re.type + " not found in " + JSON.stringify(Object.keys(ke.choice))
    ), Ce._encode(re.value, ce);
  }, ne.prototype._encodePrimitive = function(re, ce) {
    var ke = this._baseState;
    if (/str$/.test(re))
      return this._encodeStr(ce, re);
    if (re === "objid" && ke.args)
      return this._encodeObjid(ce, ke.reverseArgs[0], ke.args[1]);
    if (re === "objid")
      return this._encodeObjid(ce, null, null);
    if (re === "gentime" || re === "utctime")
      return this._encodeTime(ce, re);
    if (re === "null_")
      return this._encodeNull();
    if (re === "int" || re === "enum")
      return this._encodeInt(ce, ke.args && ke.reverseArgs[0]);
    if (re === "bool")
      return this._encodeBool(ce);
    if (re === "objDesc")
      return this._encodeStr(ce, re);
    throw new Error("Unsupported tag: " + re);
  }, ne.prototype._isNumstr = function(re) {
    return /^[0-9 ]*$/.test(re);
  }, ne.prototype._isPrintstr = function(re) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(re);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(A) {
    var B = A;
    B.Reporter = requireReporter().Reporter, B.DecoderBuffer = requireBuffer().DecoderBuffer, B.EncoderBuffer = requireBuffer().EncoderBuffer, B.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(A) {
    var B = requireConstants();
    A.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, A.tagClassByName = B._reverse(A.tagClass), A.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, A.tagByName = B._reverse(A.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(A) {
    var B = A;
    B._reverse = function(K) {
      var J = {};
      return Object.keys(K).forEach(function(W) {
        (W | 0) == W && (W = W | 0);
        var V = K[W];
        J[V] = W;
      }), J;
    }, B.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var A = requireInherits_browser(), B = requireAsn1$1(), L = B.base, K = B.bignum, J = B.constants.der;
  function W(oe) {
    this.enc = "der", this.name = oe.name, this.entity = oe, this.tree = new V(), this.tree._init(oe.body);
  }
  der_1$1 = W, W.prototype.decode = function(re, ce) {
    return re instanceof L.DecoderBuffer || (re = new L.DecoderBuffer(re, ce)), this.tree._decode(re, ce);
  };
  function V(oe) {
    L.Node.call(this, "der", oe);
  }
  A(V, L.Node), V.prototype._peekTag = function(re, ce, ke) {
    if (re.isEmpty())
      return !1;
    var Ce = re.save(), it = ne(re, 'Failed to peek tag: "' + ce + '"');
    return re.isError(it) ? it : (re.restore(Ce), it.tag === ce || it.tagStr === ce || it.tagStr + "of" === ce || ke);
  }, V.prototype._decodeTag = function(re, ce, ke) {
    var Ce = ne(
      re,
      'Failed to decode tag of "' + ce + '"'
    );
    if (re.isError(Ce))
      return Ce;
    var it = ie(
      re,
      Ce.primitive,
      'Failed to get length of "' + ce + '"'
    );
    if (re.isError(it))
      return it;
    if (!ke && Ce.tag !== ce && Ce.tagStr !== ce && Ce.tagStr + "of" !== ce)
      return re.error('Failed to match tag: "' + ce + '"');
    if (Ce.primitive || it !== null)
      return re.skip(it, 'Failed to match body of: "' + ce + '"');
    var at = re.save(), lt = this._skipUntilEnd(
      re,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return re.isError(lt) ? lt : (it = re.offset - at.offset, re.restore(at), re.skip(it, 'Failed to match body of: "' + ce + '"'));
  }, V.prototype._skipUntilEnd = function(re, ce) {
    for (; ; ) {
      var ke = ne(re, ce);
      if (re.isError(ke))
        return ke;
      var Ce = ie(re, ke.primitive, ce);
      if (re.isError(Ce))
        return Ce;
      var it;
      if (ke.primitive || Ce !== null ? it = re.skip(Ce) : it = this._skipUntilEnd(re, ce), re.isError(it))
        return it;
      if (ke.tagStr === "end")
        break;
    }
  }, V.prototype._decodeList = function(re, ce, ke, Ce) {
    for (var it = []; !re.isEmpty(); ) {
      var at = this._peekTag(re, "end");
      if (re.isError(at))
        return at;
      var lt = ke.decode(re, "der", Ce);
      if (re.isError(lt) && at)
        break;
      it.push(lt);
    }
    return it;
  }, V.prototype._decodeStr = function(re, ce) {
    if (ce === "bitstr") {
      var ke = re.readUInt8();
      return re.isError(ke) ? ke : { unused: ke, data: re.raw() };
    } else if (ce === "bmpstr") {
      var Ce = re.raw();
      if (Ce.length % 2 === 1)
        return re.error("Decoding of string type: bmpstr length mismatch");
      for (var it = "", at = 0; at < Ce.length / 2; at++)
        it += String.fromCharCode(Ce.readUInt16BE(at * 2));
      return it;
    } else if (ce === "numstr") {
      var lt = re.raw().toString("ascii");
      return this._isNumstr(lt) ? lt : re.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (ce === "octstr")
        return re.raw();
      if (ce === "objDesc")
        return re.raw();
      if (ce === "printstr") {
        var ht = re.raw().toString("ascii");
        return this._isPrintstr(ht) ? ht : re.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(ce) ? re.raw().toString() : re.error("Decoding of string type: " + ce + " unsupported");
    }
  }, V.prototype._decodeObjid = function(re, ce, ke) {
    for (var Ce, it = [], at = 0; !re.isEmpty(); ) {
      var lt = re.readUInt8();
      at <<= 7, at |= lt & 127, lt & 128 || (it.push(at), at = 0);
    }
    lt & 128 && it.push(at);
    var ht = it[0] / 40 | 0, dt = it[0] % 40;
    if (ke ? Ce = it : Ce = [ht, dt].concat(it.slice(1)), ce) {
      var vt = ce[Ce.join(" ")];
      vt === void 0 && (vt = ce[Ce.join(".")]), vt !== void 0 && (Ce = vt);
    }
    return Ce;
  }, V.prototype._decodeTime = function(re, ce) {
    var ke = re.raw().toString();
    if (ce === "gentime")
      var Ce = ke.slice(0, 4) | 0, it = ke.slice(4, 6) | 0, at = ke.slice(6, 8) | 0, lt = ke.slice(8, 10) | 0, ht = ke.slice(10, 12) | 0, dt = ke.slice(12, 14) | 0;
    else if (ce === "utctime") {
      var Ce = ke.slice(0, 2) | 0, it = ke.slice(2, 4) | 0, at = ke.slice(4, 6) | 0, lt = ke.slice(6, 8) | 0, ht = ke.slice(8, 10) | 0, dt = ke.slice(10, 12) | 0;
      Ce < 70 ? Ce = 2e3 + Ce : Ce = 1900 + Ce;
    } else
      return re.error("Decoding " + ce + " time is not supported yet");
    return Date.UTC(Ce, it - 1, at, lt, ht, dt, 0);
  }, V.prototype._decodeNull = function(re) {
    return null;
  }, V.prototype._decodeBool = function(re) {
    var ce = re.readUInt8();
    return re.isError(ce) ? ce : ce !== 0;
  }, V.prototype._decodeInt = function(re, ce) {
    var ke = re.raw(), Ce = new K(ke);
    return ce && (Ce = ce[Ce.toString(10)] || Ce), Ce;
  }, V.prototype._use = function(re, ce) {
    return typeof re == "function" && (re = re(ce)), re._getDecoder("der").tree;
  };
  function ne(oe, re) {
    var ce = oe.readUInt8(re);
    if (oe.isError(ce))
      return ce;
    var ke = J.tagClass[ce >> 6], Ce = (ce & 32) === 0;
    if ((ce & 31) === 31) {
      var it = ce;
      for (ce = 0; (it & 128) === 128; ) {
        if (it = oe.readUInt8(re), oe.isError(it))
          return it;
        ce <<= 7, ce |= it & 127;
      }
    } else
      ce &= 31;
    var at = J.tag[ce];
    return {
      cls: ke,
      primitive: Ce,
      tag: ce,
      tagStr: at
    };
  }
  function ie(oe, re, ce) {
    var ke = oe.readUInt8(ce);
    if (oe.isError(ke))
      return ke;
    if (!re && ke === 128)
      return null;
    if (!(ke & 128))
      return ke;
    var Ce = ke & 127;
    if (Ce > 4)
      return oe.error("length octect is too long");
    ke = 0;
    for (var it = 0; it < Ce; it++) {
      ke <<= 8;
      var at = oe.readUInt8(ce);
      if (oe.isError(at))
        return at;
      ke |= at;
    }
    return ke;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, L = requireDer$1();
  function K(J) {
    L.call(this, J), this.enc = "pem";
  }
  return A(K, L), pem$1 = K, K.prototype.decode = function(W, V) {
    for (var ne = W.toString().split(/[\r\n]+/g), ie = V.label.toUpperCase(), oe = /^-----(BEGIN|END) ([^-]+)-----$/, re = -1, ce = -1, ke = 0; ke < ne.length; ke++) {
      var Ce = ne[ke].match(oe);
      if (Ce !== null && Ce[2] === ie)
        if (re === -1) {
          if (Ce[1] !== "BEGIN")
            break;
          re = ke;
        } else {
          if (Ce[1] !== "END")
            break;
          ce = ke;
          break;
        }
    }
    if (re === -1 || ce === -1)
      throw new Error("PEM section not found for: " + ie);
    var it = ne.slice(re + 1, ce).join("");
    it.replace(/[^a-z0-9\+\/=]+/gi, "");
    var at = new B(it, "base64");
    return L.prototype.decode.call(this, at, V);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(A) {
    var B = A;
    B.der = requireDer$1(), B.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, L = requireAsn1$1(), K = L.base, J = L.constants.der;
  function W(oe) {
    this.enc = "der", this.name = oe.name, this.entity = oe, this.tree = new V(), this.tree._init(oe.body);
  }
  der_1 = W, W.prototype.encode = function(re, ce) {
    return this.tree._encode(re, ce).join();
  };
  function V(oe) {
    K.Node.call(this, "der", oe);
  }
  A(V, K.Node), V.prototype._encodeComposite = function(re, ce, ke, Ce) {
    var it = ie(re, ce, ke, this.reporter);
    if (Ce.length < 128) {
      var ht = new B(2);
      return ht[0] = it, ht[1] = Ce.length, this._createEncoderBuffer([ht, Ce]);
    }
    for (var at = 1, lt = Ce.length; lt >= 256; lt >>= 8)
      at++;
    var ht = new B(2 + at);
    ht[0] = it, ht[1] = 128 | at;
    for (var lt = 1 + at, dt = Ce.length; dt > 0; lt--, dt >>= 8)
      ht[lt] = dt & 255;
    return this._createEncoderBuffer([ht, Ce]);
  }, V.prototype._encodeStr = function(re, ce) {
    if (ce === "bitstr")
      return this._createEncoderBuffer([re.unused | 0, re.data]);
    if (ce === "bmpstr") {
      for (var ke = new B(re.length * 2), Ce = 0; Ce < re.length; Ce++)
        ke.writeUInt16BE(re.charCodeAt(Ce), Ce * 2);
      return this._createEncoderBuffer(ke);
    } else return ce === "numstr" ? this._isNumstr(re) ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : ce === "printstr" ? this._isPrintstr(re) ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(ce) ? this._createEncoderBuffer(re) : ce === "objDesc" ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: " + ce + " unsupported");
  }, V.prototype._encodeObjid = function(re, ce, ke) {
    if (typeof re == "string") {
      if (!ce)
        return this.reporter.error("string objid given, but no values map found");
      if (!ce.hasOwnProperty(re))
        return this.reporter.error("objid not found in values map");
      re = ce[re].split(/[\s\.]+/g);
      for (var Ce = 0; Ce < re.length; Ce++)
        re[Ce] |= 0;
    } else if (Array.isArray(re)) {
      re = re.slice();
      for (var Ce = 0; Ce < re.length; Ce++)
        re[Ce] |= 0;
    }
    if (!Array.isArray(re))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(re));
    if (!ke) {
      if (re[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      re.splice(0, 2, re[0] * 40 + re[1]);
    }
    for (var it = 0, Ce = 0; Ce < re.length; Ce++) {
      var at = re[Ce];
      for (it++; at >= 128; at >>= 7)
        it++;
    }
    for (var lt = new B(it), ht = lt.length - 1, Ce = re.length - 1; Ce >= 0; Ce--) {
      var at = re[Ce];
      for (lt[ht--] = at & 127; (at >>= 7) > 0; )
        lt[ht--] = 128 | at & 127;
    }
    return this._createEncoderBuffer(lt);
  };
  function ne(oe) {
    return oe < 10 ? "0" + oe : oe;
  }
  V.prototype._encodeTime = function(re, ce) {
    var ke, Ce = new Date(re);
    return ce === "gentime" ? ke = [
      ne(Ce.getFullYear()),
      ne(Ce.getUTCMonth() + 1),
      ne(Ce.getUTCDate()),
      ne(Ce.getUTCHours()),
      ne(Ce.getUTCMinutes()),
      ne(Ce.getUTCSeconds()),
      "Z"
    ].join("") : ce === "utctime" ? ke = [
      ne(Ce.getFullYear() % 100),
      ne(Ce.getUTCMonth() + 1),
      ne(Ce.getUTCDate()),
      ne(Ce.getUTCHours()),
      ne(Ce.getUTCMinutes()),
      ne(Ce.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + ce + " time is not supported yet"), this._encodeStr(ke, "octstr");
  }, V.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, V.prototype._encodeInt = function(re, ce) {
    if (typeof re == "string") {
      if (!ce)
        return this.reporter.error("String int or enum given, but no values map");
      if (!ce.hasOwnProperty(re))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(re));
      re = ce[re];
    }
    if (typeof re != "number" && !B.isBuffer(re)) {
      var ke = re.toArray();
      !re.sign && ke[0] & 128 && ke.unshift(0), re = new B(ke);
    }
    if (B.isBuffer(re)) {
      var Ce = re.length;
      re.length === 0 && Ce++;
      var at = new B(Ce);
      return re.copy(at), re.length === 0 && (at[0] = 0), this._createEncoderBuffer(at);
    }
    if (re < 128)
      return this._createEncoderBuffer(re);
    if (re < 256)
      return this._createEncoderBuffer([0, re]);
    for (var Ce = 1, it = re; it >= 256; it >>= 8)
      Ce++;
    for (var at = new Array(Ce), it = at.length - 1; it >= 0; it--)
      at[it] = re & 255, re >>= 8;
    return at[0] & 128 && at.unshift(0), this._createEncoderBuffer(new B(at));
  }, V.prototype._encodeBool = function(re) {
    return this._createEncoderBuffer(re ? 255 : 0);
  }, V.prototype._use = function(re, ce) {
    return typeof re == "function" && (re = re(ce)), re._getEncoder("der").tree;
  }, V.prototype._skipDefault = function(re, ce, ke) {
    var Ce = this._baseState, it;
    if (Ce.default === null)
      return !1;
    var at = re.join();
    if (Ce.defaultBuffer === void 0 && (Ce.defaultBuffer = this._encodeValue(Ce.default, ce, ke).join()), at.length !== Ce.defaultBuffer.length)
      return !1;
    for (it = 0; it < at.length; it++)
      if (at[it] !== Ce.defaultBuffer[it])
        return !1;
    return !0;
  };
  function ie(oe, re, ce, ke) {
    var Ce;
    if (oe === "seqof" ? oe = "seq" : oe === "setof" && (oe = "set"), J.tagByName.hasOwnProperty(oe))
      Ce = J.tagByName[oe];
    else if (typeof oe == "number" && (oe | 0) === oe)
      Ce = oe;
    else
      return ke.error("Unknown tag: " + oe);
    return Ce >= 31 ? ke.error("Multi-octet tag encoding unsupported") : (re || (Ce |= 32), Ce |= J.tagClassByName[ce || "universal"] << 6, Ce);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var A = requireInherits_browser(), B = requireDer();
  function L(K) {
    B.call(this, K), this.enc = "pem";
  }
  return A(L, B), pem = L, L.prototype.encode = function(J, W) {
    for (var V = B.prototype.encode.call(this, J), ne = V.toString("base64"), ie = ["-----BEGIN " + W.label + "-----"], oe = 0; oe < ne.length; oe += 64)
      ie.push(ne.slice(oe, oe + 64));
    return ie.push("-----END " + W.label + "-----"), ie.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(A) {
    var B = A;
    B.der = requireDer(), B.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(A) {
    var B = A;
    B.bignum = requireBn$1(), B.define = requireApi().define, B.base = requireBase(), B.constants = requireConstants(), B.decoders = requireDecoders(), B.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var A = requireAsn1$1(), B = A.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), L = A.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), J = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  }), W = A.define("RelativeDistinguishedName", function() {
    this.setof(L);
  }), V = A.define("RDNSequence", function() {
    this.seqof(W);
  }), ne = A.define("Name", function() {
    this.choice({
      rdnSequence: this.use(V)
    });
  }), ie = A.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(B),
      this.key("notAfter").use(B)
    );
  }), oe = A.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), re = A.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(K),
      this.key("issuer").use(ne),
      this.key("validity").use(ie),
      this.key("subject").use(ne),
      this.key("subjectPublicKeyInfo").use(J),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(oe).optional()
    );
  }), ce = A.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(re),
      this.key("signatureAlgorithm").use(K),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = ce, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var A = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var B = A.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = B;
  var L = A.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = L;
  var K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), J = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = J;
  var W = A.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(K),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = W;
  var V = A.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = V;
  var ne = A.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = ne, asn1$1.DSAparam = A.define("DSAparam", function() {
    this.int();
  });
  var ie = A.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), oe = A.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ie),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = oe, asn1$1.signature = A.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var A = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, B = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, L = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K = requireEvp_bytestokey(), J = requireBrowser$6(), W = safeBufferExports.Buffer;
  return fixProc = function(V, ne) {
    var ie = V.toString(), oe = ie.match(A), re;
    if (oe) {
      var ke = "aes" + oe[1], Ce = W.from(oe[2], "hex"), it = W.from(oe[3].replace(/[\r\n]/g, ""), "base64"), at = K(ne, Ce.slice(0, 8), parseInt(oe[1], 10)).key, lt = [], ht = J.createDecipheriv(ke, at, Ce);
      lt.push(ht.update(it)), lt.push(ht.final()), re = W.concat(lt);
    } else {
      var ce = ie.match(L);
      re = W.from(ce[2].replace(/[\r\n]/g, ""), "base64");
    }
    var dt = ie.match(B)[1];
    return {
      tag: dt,
      data: re
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var A = requireAsn1(), B = require$$1, L = requireFixProc(), K = requireBrowser$6(), J = requireBrowser$7(), W = safeBufferExports.Buffer;
  function V(ie, oe) {
    var re = ie.algorithm.decrypt.kde.kdeparams.salt, ce = parseInt(ie.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ke = B[ie.algorithm.decrypt.cipher.algo.join(".")], Ce = ie.algorithm.decrypt.cipher.iv, it = ie.subjectPrivateKey, at = parseInt(ke.split("-")[1], 10) / 8, lt = J.pbkdf2Sync(oe, re, ce, at, "sha1"), ht = K.createDecipheriv(ke, lt, Ce), dt = [];
    return dt.push(ht.update(it)), dt.push(ht.final()), W.concat(dt);
  }
  function ne(ie) {
    var oe;
    typeof ie == "object" && !W.isBuffer(ie) && (oe = ie.passphrase, ie = ie.key), typeof ie == "string" && (ie = W.from(ie));
    var re = L(ie, oe), ce = re.tag, ke = re.data, Ce, it;
    switch (ce) {
      case "CERTIFICATE":
        it = A.certificate.decode(ke, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (it || (it = A.PublicKey.decode(ke, "der")), Ce = it.algorithm.algorithm.join("."), Ce) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPublicKey.decode(it.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return it.subjectPrivateKey = it.subjectPublicKey, {
              type: "ec",
              data: it
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.pub_key = A.DSAparam.decode(it.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ce);
        }
      case "ENCRYPTED PRIVATE KEY":
        ke = A.EncryptedPrivateKey.decode(ke, "der"), ke = V(ke, oe);
      case "PRIVATE KEY":
        switch (it = A.PrivateKey.decode(ke, "der"), Ce = it.algorithm.algorithm.join("."), Ce) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPrivateKey.decode(it.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: it.algorithm.curve,
              privateKey: A.ECPrivateKey.decode(it.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.priv_key = A.DSAparam.decode(it.subjectPrivateKey, "der"), {
              type: "dsa",
              params: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ce);
        }
      case "RSA PUBLIC KEY":
        return A.RSAPublicKey.decode(ke, "der");
      case "RSA PRIVATE KEY":
        return A.RSAPrivateKey.decode(ke, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: A.DSAPrivateKey.decode(ke, "der")
        };
      case "EC PRIVATE KEY":
        return ke = A.ECPrivateKey.decode(ke, "der"), {
          curve: ke.parameters.value,
          privateKey: ke.privateKey
        };
      default:
        throw new Error("unknown key type " + ce);
    }
  }
  return ne.signature = A.signature, parseAsn1 = ne, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$8(), L = requireBrowserifyRsa(), K = requireElliptic().ec, J = requireBn(), W = requireParseAsn1(), V = require$$4, ne = 1;
  function ie(ht, dt, vt, mt, Pt) {
    var $t = W(dt);
    if ($t.curve) {
      if (mt !== "ecdsa" && mt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return oe(ht, $t);
    } else if ($t.type === "dsa") {
      if (mt !== "dsa")
        throw new Error("wrong private key type");
      return re(ht, $t, vt);
    }
    if (mt !== "rsa" && mt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (dt.padding !== void 0 && dt.padding !== ne)
      throw new Error("illegal or unsupported padding mode");
    ht = A.concat([Pt, ht]);
    for (var qt = $t.modulus.byteLength(), At = [0, 1]; ht.length + At.length + 1 < qt; )
      At.push(255);
    At.push(0);
    for (var bt = -1; ++bt < ht.length; )
      At.push(ht[bt]);
    var xt = L(At, $t);
    return xt;
  }
  function oe(ht, dt) {
    var vt = V[dt.curve.join(".")];
    if (!vt)
      throw new Error("unknown curve " + dt.curve.join("."));
    var mt = new K(vt), Pt = mt.keyFromPrivate(dt.privateKey), $t = Pt.sign(ht);
    return A.from($t.toDER());
  }
  function re(ht, dt, vt) {
    for (var mt = dt.params.priv_key, Pt = dt.params.p, $t = dt.params.q, qt = dt.params.g, At = new J(0), bt, xt = Ce(ht, $t).mod($t), wt = !1, Oe = ke(mt, $t, ht, vt); wt === !1; )
      bt = at($t, Oe, vt), At = lt(qt, bt, Pt, $t), wt = bt.invm($t).imul(xt.add(mt.mul(At))).mod($t), wt.cmpn(0) === 0 && (wt = !1, At = new J(0));
    return ce(At, wt);
  }
  function ce(ht, dt) {
    ht = ht.toArray(), dt = dt.toArray(), ht[0] & 128 && (ht = [0].concat(ht)), dt[0] & 128 && (dt = [0].concat(dt));
    var vt = ht.length + dt.length + 4, mt = [
      48,
      vt,
      2,
      ht.length
    ];
    return mt = mt.concat(ht, [2, dt.length], dt), A.from(mt);
  }
  function ke(ht, dt, vt, mt) {
    if (ht = A.from(ht.toArray()), ht.length < dt.byteLength()) {
      var Pt = A.alloc(dt.byteLength() - ht.length);
      ht = A.concat([Pt, ht]);
    }
    var $t = vt.length, qt = it(vt, dt), At = A.alloc($t);
    At.fill(1);
    var bt = A.alloc($t);
    return bt = B(mt, bt).update(At).update(A.from([0])).update(ht).update(qt).digest(), At = B(mt, bt).update(At).digest(), bt = B(mt, bt).update(At).update(A.from([1])).update(ht).update(qt).digest(), At = B(mt, bt).update(At).digest(), { k: bt, v: At };
  }
  function Ce(ht, dt) {
    var vt = new J(ht), mt = (ht.length << 3) - dt.bitLength();
    return mt > 0 && vt.ishrn(mt), vt;
  }
  function it(ht, dt) {
    ht = Ce(ht, dt), ht = ht.mod(dt);
    var vt = A.from(ht.toArray());
    if (vt.length < dt.byteLength()) {
      var mt = A.alloc(dt.byteLength() - vt.length);
      vt = A.concat([mt, vt]);
    }
    return vt;
  }
  function at(ht, dt, vt) {
    var mt, Pt;
    do {
      for (mt = A.alloc(0); mt.length * 8 < ht.bitLength(); )
        dt.v = B(vt, dt.k).update(dt.v).digest(), mt = A.concat([mt, dt.v]);
      Pt = Ce(mt, ht), dt.k = B(vt, dt.k).update(dt.v).update(A.from([0])).digest(), dt.v = B(vt, dt.k).update(dt.v).digest();
    } while (Pt.cmp(ht) !== -1);
    return Pt;
  }
  function lt(ht, dt, vt, mt) {
    return ht.toRed(J.mont(vt)).redPow(dt).fromRed().mod(mt);
  }
  return sign.exports = ie, sign.exports.getKey = ke, sign.exports.makeKey = at, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var A = safeBufferExports.Buffer, B = requireBn(), L = requireElliptic().ec, K = requireParseAsn1(), J = require$$4;
  function W(oe, re, ce, ke, Ce) {
    var it = K(ce);
    if (it.type === "ec") {
      if (ke !== "ecdsa" && ke !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return V(oe, re, it);
    } else if (it.type === "dsa") {
      if (ke !== "dsa")
        throw new Error("wrong public key type");
      return ne(oe, re, it);
    }
    if (ke !== "rsa" && ke !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    re = A.concat([Ce, re]);
    for (var at = it.modulus.byteLength(), lt = [1], ht = 0; re.length + lt.length + 2 < at; )
      lt.push(255), ht += 1;
    lt.push(0);
    for (var dt = -1; ++dt < re.length; )
      lt.push(re[dt]);
    lt = A.from(lt);
    var vt = B.mont(it.modulus);
    oe = new B(oe).toRed(vt), oe = oe.redPow(new B(it.publicExponent)), oe = A.from(oe.fromRed().toArray());
    var mt = ht < 8 ? 1 : 0;
    for (at = Math.min(oe.length, lt.length), oe.length !== lt.length && (mt = 1), dt = -1; ++dt < at; )
      mt |= oe[dt] ^ lt[dt];
    return mt === 0;
  }
  function V(oe, re, ce) {
    var ke = J[ce.data.algorithm.curve.join(".")];
    if (!ke)
      throw new Error("unknown curve " + ce.data.algorithm.curve.join("."));
    var Ce = new L(ke), it = ce.data.subjectPrivateKey.data;
    return Ce.verify(re, oe, it);
  }
  function ne(oe, re, ce) {
    var ke = ce.data.p, Ce = ce.data.q, it = ce.data.g, at = ce.data.pub_key, lt = K.signature.decode(oe, "der"), ht = lt.s, dt = lt.r;
    ie(ht, Ce), ie(dt, Ce);
    var vt = B.mont(ke), mt = ht.invm(Ce), Pt = it.toRed(vt).redPow(new B(re).mul(mt).mod(Ce)).fromRed().mul(at.toRed(vt).redPow(dt.mul(mt).mod(Ce)).fromRed()).mod(ke).mod(Ce);
    return Pt.cmp(dt) === 0;
  }
  function ie(oe, re) {
    if (oe.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (oe.cmp(re) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = W, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$9(), L = requireReadableBrowser(), K = requireInherits_browser(), J = requireSign(), W = requireVerify(), V = require$$6;
  Object.keys(V).forEach(function(ce) {
    V[ce].id = A.from(V[ce].id, "hex"), V[ce.toLowerCase()] = V[ce];
  });
  function ne(ce) {
    L.Writable.call(this);
    var ke = V[ce];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hashType = ke.hash, this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ne, L.Writable), ne.prototype._write = function(ke, Ce, it) {
    this._hash.update(ke), it();
  }, ne.prototype.update = function(ke, Ce) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Ce) : ke), this;
  }, ne.prototype.sign = function(ke, Ce) {
    this.end();
    var it = this._hash.digest(), at = J(it, ke, this._hashType, this._signType, this._tag);
    return Ce ? at.toString(Ce) : at;
  };
  function ie(ce) {
    L.Writable.call(this);
    var ke = V[ce];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ie, L.Writable), ie.prototype._write = function(ke, Ce, it) {
    this._hash.update(ke), it();
  }, ie.prototype.update = function(ke, Ce) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Ce) : ke), this;
  }, ie.prototype.verify = function(ke, Ce, it) {
    var at = typeof Ce == "string" ? A.from(Ce, it) : Ce;
    this.end();
    var lt = this._hash.digest();
    return W(at, lt, ke, this._signType, this._tag);
  };
  function oe(ce) {
    return new ne(ce);
  }
  function re(ce) {
    return new ie(ce);
  }
  return browser$3 = {
    Sign: oe,
    Verify: re,
    createSign: oe,
    createVerify: re
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var A = requireElliptic(), B = requireBn$1();
  browser$2 = function(V) {
    return new K(V);
  };
  var L = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  L.p224 = L.secp224r1, L.p256 = L.secp256r1 = L.prime256v1, L.p192 = L.secp192r1 = L.prime192v1, L.p384 = L.secp384r1, L.p521 = L.secp521r1;
  function K(W) {
    this.curveType = L[W], this.curveType || (this.curveType = {
      name: W
    }), this.curve = new A.ec(this.curveType.name), this.keys = void 0;
  }
  K.prototype.generateKeys = function(W, V) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(W, V);
  }, K.prototype.computeSecret = function(W, V, ne) {
    V = V || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, V));
    var ie = this.curve.keyFromPublic(W).getPublic(), oe = ie.mul(this.keys.getPrivate()).getX();
    return J(oe, ne, this.curveType.byteLength);
  }, K.prototype.getPublicKey = function(W, V) {
    var ne = this.keys.getPublic(V === "compressed", !0);
    return V === "hybrid" && (ne[ne.length - 1] % 2 ? ne[0] = 7 : ne[0] = 6), J(ne, W);
  }, K.prototype.getPrivateKey = function(W) {
    return J(this.keys.getPrivate(), W);
  }, K.prototype.setPublicKey = function(W, V) {
    return V = V || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, V)), this.keys._importPublic(W), this;
  }, K.prototype.setPrivateKey = function(W, V) {
    V = V || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, V));
    var ne = new B(W);
    return ne = ne.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ne), this;
  };
  function J(W, V, ne) {
    Array.isArray(W) || (W = W.toArray());
    var ie = new Buffer$1(W);
    if (ne && ie.length < ne) {
      var oe = new Buffer$1(ne - ie.length);
      oe.fill(0), ie = Buffer$1.concat([oe, ie]);
    }
    return V ? ie.toString(V) : ie;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var A = requireBrowser$9(), B = safeBufferExports.Buffer;
  mgf = function(K, J) {
    for (var W = B.alloc(0), V = 0, ne; W.length < J; )
      ne = L(V++), W = B.concat([W, A("sha1").update(K).update(ne).digest()]);
    return W.slice(0, J);
  };
  function L(K) {
    var J = B.allocUnsafe(4);
    return J.writeUInt32BE(K, 0), J;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(B, L) {
    for (var K = B.length, J = -1; ++J < K; )
      B[J] ^= L[J];
    return B;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var A = requireBn$1(), B = safeBufferExports.Buffer;
  function L(K, J) {
    return B.from(K.toRed(A.mont(J.modulus)).redPow(new A(J.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = L, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var A = requireParseAsn1(), B = requireBrowser$b(), L = requireBrowser$9(), K = requireMgf(), J = requireXor(), W = requireBn$1(), V = requireWithPublic(), ne = requireBrowserifyRsa(), ie = safeBufferExports.Buffer;
  publicEncrypt = function(Ce, it, at) {
    var lt;
    Ce.padding ? lt = Ce.padding : at ? lt = 1 : lt = 4;
    var ht = A(Ce), dt;
    if (lt === 4)
      dt = oe(ht, it);
    else if (lt === 1)
      dt = re(ht, it, at);
    else if (lt === 3) {
      if (dt = new W(it), dt.cmp(ht.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return at ? ne(dt, ht) : V(dt, ht);
  };
  function oe(ke, Ce) {
    var it = ke.modulus.byteLength(), at = Ce.length, lt = L("sha1").update(ie.alloc(0)).digest(), ht = lt.length, dt = 2 * ht;
    if (at > it - dt - 2)
      throw new Error("message too long");
    var vt = ie.alloc(it - at - dt - 2), mt = it - ht - 1, Pt = B(ht), $t = J(ie.concat([lt, vt, ie.alloc(1, 1), Ce], mt), K(Pt, mt)), qt = J(Pt, K($t, ht));
    return new W(ie.concat([ie.alloc(1), qt, $t], it));
  }
  function re(ke, Ce, it) {
    var at = Ce.length, lt = ke.modulus.byteLength();
    if (at > lt - 11)
      throw new Error("message too long");
    var ht;
    return it ? ht = ie.alloc(lt - at - 3, 255) : ht = ce(lt - at - 3), new W(ie.concat([ie.from([0, it ? 1 : 2]), ht, ie.alloc(1), Ce], lt));
  }
  function ce(ke) {
    for (var Ce = ie.allocUnsafe(ke), it = 0, at = B(ke * 2), lt = 0, ht; it < ke; )
      lt === at.length && (at = B(ke * 2), lt = 0), ht = at[lt++], ht && (Ce[it++] = ht);
    return Ce;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var A = requireParseAsn1(), B = requireMgf(), L = requireXor(), K = requireBn$1(), J = requireBrowserifyRsa(), W = requireBrowser$9(), V = requireWithPublic(), ne = safeBufferExports.Buffer;
  privateDecrypt = function(ke, Ce, it) {
    var at;
    ke.padding ? at = ke.padding : it ? at = 1 : at = 4;
    var lt = A(ke), ht = lt.modulus.byteLength();
    if (Ce.length > ht || new K(Ce).cmp(lt.modulus) >= 0)
      throw new Error("decryption error");
    var dt;
    it ? dt = V(new K(Ce), lt) : dt = J(Ce, lt);
    var vt = ne.alloc(ht - dt.length);
    if (dt = ne.concat([vt, dt], ht), at === 4)
      return ie(lt, dt);
    if (at === 1)
      return oe(lt, dt, it);
    if (at === 3)
      return dt;
    throw new Error("unknown padding");
  };
  function ie(ce, ke) {
    var Ce = ce.modulus.byteLength(), it = W("sha1").update(ne.alloc(0)).digest(), at = it.length;
    if (ke[0] !== 0)
      throw new Error("decryption error");
    var lt = ke.slice(1, at + 1), ht = ke.slice(at + 1), dt = L(lt, B(ht, at)), vt = L(ht, B(dt, Ce - at - 1));
    if (re(it, vt.slice(0, at)))
      throw new Error("decryption error");
    for (var mt = at; vt[mt] === 0; )
      mt++;
    if (vt[mt++] !== 1)
      throw new Error("decryption error");
    return vt.slice(mt);
  }
  function oe(ce, ke, Ce) {
    for (var it = ke.slice(0, 2), at = 2, lt = 0; ke[at++] !== 0; )
      if (at >= ke.length) {
        lt++;
        break;
      }
    var ht = ke.slice(2, at - 1);
    if ((it.toString("hex") !== "0002" && !Ce || it.toString("hex") !== "0001" && Ce) && lt++, ht.length < 8 && lt++, lt)
      throw new Error("decryption error");
    return ke.slice(at);
  }
  function re(ce, ke) {
    ce = ne.from(ce), ke = ne.from(ke);
    var Ce = 0, it = ce.length;
    ce.length !== ke.length && (Ce++, it = Math.min(ce.length, ke.length));
    for (var at = -1; ++at < it; )
      Ce += ce[at] ^ ke[at];
    return Ce;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(A) {
    A.publicEncrypt = requirePublicEncrypt(), A.privateDecrypt = requirePrivateDecrypt(), A.privateEncrypt = function(L, K) {
      return A.publicEncrypt(L, K, !0);
    }, A.publicDecrypt = function(L, K) {
      return A.privateDecrypt(L, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function A() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var B = safeBufferExports, L = requireBrowser$b(), K = B.Buffer, J = B.kMaxLength, W = commonjsGlobal.crypto || commonjsGlobal.msCrypto, V = Math.pow(2, 32) - 1;
  function ne(ke, Ce) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("offset must be a number");
    if (ke > V || ke < 0)
      throw new TypeError("offset must be a uint32");
    if (ke > J || ke > Ce)
      throw new RangeError("offset out of range");
  }
  function ie(ke, Ce, it) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("size must be a number");
    if (ke > V || ke < 0)
      throw new TypeError("size must be a uint32");
    if (ke + Ce > it || ke > J)
      throw new RangeError("buffer too small");
  }
  W && W.getRandomValues || !process$1.browser ? (browser.randomFill = oe, browser.randomFillSync = ce) : (browser.randomFill = A, browser.randomFillSync = A);
  function oe(ke, Ce, it, at) {
    if (!K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Ce == "function")
      at = Ce, Ce = 0, it = ke.length;
    else if (typeof it == "function")
      at = it, it = ke.length - Ce;
    else if (typeof at != "function")
      throw new TypeError('"cb" argument must be a function');
    return ne(Ce, ke.length), ie(it, Ce, ke.length), re(ke, Ce, it, at);
  }
  function re(ke, Ce, it, at) {
    if (process$1.browser) {
      var lt = ke.buffer, ht = new Uint8Array(lt, Ce, it);
      if (W.getRandomValues(ht), at) {
        process$1.nextTick(function() {
          at(null, ke);
        });
        return;
      }
      return ke;
    }
    if (at) {
      L(it, function(vt, mt) {
        if (vt)
          return at(vt);
        mt.copy(ke, Ce), at(null, ke);
      });
      return;
    }
    var dt = L(it);
    return dt.copy(ke, Ce), ke;
  }
  function ce(ke, Ce, it) {
    if (typeof Ce > "u" && (Ce = 0), !K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ne(Ce, ke.length), it === void 0 && (it = ke.length - Ce), ie(it, Ce, ke.length), re(ke, Ce, it);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var A = requireAlgos(), B = Object.keys(A), L = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(B);
  cryptoBrowserify.getHashes = function() {
    return L;
  };
  var K = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = K.pbkdf2, cryptoBrowserify.pbkdf2Sync = K.pbkdf2Sync;
  var J = requireBrowser$5();
  cryptoBrowserify.Cipher = J.Cipher, cryptoBrowserify.createCipher = J.createCipher, cryptoBrowserify.Cipheriv = J.Cipheriv, cryptoBrowserify.createCipheriv = J.createCipheriv, cryptoBrowserify.Decipher = J.Decipher, cryptoBrowserify.createDecipher = J.createDecipher, cryptoBrowserify.Decipheriv = J.Decipheriv, cryptoBrowserify.createDecipheriv = J.createDecipheriv, cryptoBrowserify.getCiphers = J.getCiphers, cryptoBrowserify.listCiphers = J.listCiphers;
  var W = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = W.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = W.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = W.getDiffieHellman, cryptoBrowserify.createDiffieHellman = W.createDiffieHellman, cryptoBrowserify.DiffieHellman = W.DiffieHellman;
  var V = requireBrowser$3();
  cryptoBrowserify.createSign = V.createSign, cryptoBrowserify.Sign = V.Sign, cryptoBrowserify.createVerify = V.createVerify, cryptoBrowserify.Verify = V.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ne = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ne.publicEncrypt, cryptoBrowserify.privateEncrypt = ne.privateEncrypt, cryptoBrowserify.publicDecrypt = ne.publicDecrypt, cryptoBrowserify.privateDecrypt = ne.privateDecrypt;
  var ie = requireBrowser();
  return cryptoBrowserify.randomFill = ie.randomFill, cryptoBrowserify.randomFillSync = ie.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(A) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.utils = A.schnorr = A.verify = A.signSync = A.sign = A.getSharedSecret = A.recoverPublicKey = A.getPublicKey = A.Signature = A.Point = A.CURVE = void 0;
  const B = requireCryptoBrowserify(), L = BigInt(0), K = BigInt(1), J = BigInt(2), W = BigInt(3), V = BigInt(8), ne = Object.freeze({
    a: L,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: K,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  A.CURVE = ne;
  const ie = (Ft, kt) => (Ft + kt / J) / kt, oe = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Ft) {
      const { n: kt } = ne, Dt = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ht = -K * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Xt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Zt = Dt, tr = BigInt("0x100000000000000000000000000000000"), nr = ie(Zt * Ft, kt), fr = ie(-Ht * Ft, kt);
      let ir = Et(Ft - nr * Dt - fr * Xt, kt), pr = Et(-nr * Ht - fr * Zt, kt);
      const wr = ir > tr, sr = pr > tr;
      if (wr && (ir = kt - ir), sr && (pr = kt - pr), ir > tr || pr > tr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Ft);
      return { k1neg: wr, k1: ir, k2neg: sr, k2: pr };
    }
  }, re = 32, ce = 32, ke = 32, Ce = re + 1, it = 2 * re + 1;
  function at(Ft) {
    const { a: kt, b: Dt } = ne, Ht = Et(Ft * Ft), Xt = Et(Ht * Ft);
    return Et(Xt + kt * Ft + Dt);
  }
  const lt = ne.a === L;
  class ht extends Error {
    constructor(kt) {
      super(kt);
    }
  }
  function dt(Ft) {
    if (!(Ft instanceof vt))
      throw new TypeError("JacobianPoint expected");
  }
  class vt {
    constructor(kt, Dt, Ht) {
      this.x = kt, this.y = Dt, this.z = Ht;
    }
    static fromAffine(kt) {
      if (!(kt instanceof $t))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return kt.equals($t.ZERO) ? vt.ZERO : new vt(kt.x, kt.y, K);
    }
    static toAffineBatch(kt) {
      const Dt = Bt(kt.map((Ht) => Ht.z));
      return kt.map((Ht, Xt) => Ht.toAffine(Dt[Xt]));
    }
    static normalizeZ(kt) {
      return vt.toAffineBatch(kt).map(vt.fromAffine);
    }
    equals(kt) {
      dt(kt);
      const { x: Dt, y: Ht, z: Xt } = this, { x: Zt, y: tr, z: nr } = kt, fr = Et(Xt * Xt), ir = Et(nr * nr), pr = Et(Dt * ir), wr = Et(Zt * fr), sr = Et(Et(Ht * nr) * ir), Lt = Et(Et(tr * Xt) * fr);
      return pr === wr && sr === Lt;
    }
    negate() {
      return new vt(this.x, Et(-this.y), this.z);
    }
    double() {
      const { x: kt, y: Dt, z: Ht } = this, Xt = Et(kt * kt), Zt = Et(Dt * Dt), tr = Et(Zt * Zt), nr = kt + Zt, fr = Et(J * (Et(nr * nr) - Xt - tr)), ir = Et(W * Xt), pr = Et(ir * ir), wr = Et(pr - J * fr), sr = Et(ir * (fr - wr) - V * tr), Lt = Et(J * Dt * Ht);
      return new vt(wr, sr, Lt);
    }
    add(kt) {
      dt(kt);
      const { x: Dt, y: Ht, z: Xt } = this, { x: Zt, y: tr, z: nr } = kt;
      if (Zt === L || tr === L)
        return this;
      if (Dt === L || Ht === L)
        return kt;
      const fr = Et(Xt * Xt), ir = Et(nr * nr), pr = Et(Dt * ir), wr = Et(Zt * fr), sr = Et(Et(Ht * nr) * ir), Lt = Et(Et(tr * Xt) * fr), Jt = Et(wr - pr), er = Et(Lt - sr);
      if (Jt === L)
        return er === L ? this.double() : vt.ZERO;
      const or = Et(Jt * Jt), vr = Et(Jt * or), Er = Et(pr * or), Tr = Et(er * er - vr - J * Er), Pr = Et(er * (Er - Tr) - sr * vr), Nr = Et(Xt * nr * Jt);
      return new vt(Tr, Pr, Nr);
    }
    subtract(kt) {
      return this.add(kt.negate());
    }
    multiplyUnsafe(kt) {
      const Dt = vt.ZERO;
      if (typeof kt == "bigint" && kt === L)
        return Dt;
      let Ht = ct(kt);
      if (Ht === K)
        return this;
      if (!lt) {
        let wr = Dt, sr = this;
        for (; Ht > L; )
          Ht & K && (wr = wr.add(sr)), sr = sr.double(), Ht >>= K;
        return wr;
      }
      let { k1neg: Xt, k1: Zt, k2neg: tr, k2: nr } = oe.splitScalar(Ht), fr = Dt, ir = Dt, pr = this;
      for (; Zt > L || nr > L; )
        Zt & K && (fr = fr.add(pr)), nr & K && (ir = ir.add(pr)), pr = pr.double(), Zt >>= K, nr >>= K;
      return Xt && (fr = fr.negate()), tr && (ir = ir.negate()), ir = new vt(Et(ir.x * oe.beta), ir.y, ir.z), fr.add(ir);
    }
    precomputeWindow(kt) {
      const Dt = lt ? 128 / kt + 1 : 256 / kt + 1, Ht = [];
      let Xt = this, Zt = Xt;
      for (let tr = 0; tr < Dt; tr++) {
        Zt = Xt, Ht.push(Zt);
        for (let nr = 1; nr < 2 ** (kt - 1); nr++)
          Zt = Zt.add(Xt), Ht.push(Zt);
        Xt = Zt.double();
      }
      return Ht;
    }
    wNAF(kt, Dt) {
      !Dt && this.equals(vt.BASE) && (Dt = $t.BASE);
      const Ht = Dt && Dt._WINDOW_SIZE || 1;
      if (256 % Ht)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Xt = Dt && Pt.get(Dt);
      Xt || (Xt = this.precomputeWindow(Ht), Dt && Ht !== 1 && (Xt = vt.normalizeZ(Xt), Pt.set(Dt, Xt)));
      let Zt = vt.ZERO, tr = vt.BASE;
      const nr = 1 + (lt ? 128 / Ht : 256 / Ht), fr = 2 ** (Ht - 1), ir = BigInt(2 ** Ht - 1), pr = 2 ** Ht, wr = BigInt(Ht);
      for (let sr = 0; sr < nr; sr++) {
        const Lt = sr * fr;
        let Jt = Number(kt & ir);
        kt >>= wr, Jt > fr && (Jt -= pr, kt += K);
        const er = Lt, or = Lt + Math.abs(Jt) - 1, vr = sr % 2 !== 0, Er = Jt < 0;
        Jt === 0 ? tr = tr.add(mt(vr, Xt[er])) : Zt = Zt.add(mt(Er, Xt[or]));
      }
      return { p: Zt, f: tr };
    }
    multiply(kt, Dt) {
      let Ht = ct(kt), Xt, Zt;
      if (lt) {
        const { k1neg: tr, k1: nr, k2neg: fr, k2: ir } = oe.splitScalar(Ht);
        let { p: pr, f: wr } = this.wNAF(nr, Dt), { p: sr, f: Lt } = this.wNAF(ir, Dt);
        pr = mt(tr, pr), sr = mt(fr, sr), sr = new vt(Et(sr.x * oe.beta), sr.y, sr.z), Xt = pr.add(sr), Zt = wr.add(Lt);
      } else {
        const { p: tr, f: nr } = this.wNAF(Ht, Dt);
        Xt = tr, Zt = nr;
      }
      return vt.normalizeZ([Xt, Zt])[0];
    }
    toAffine(kt) {
      const { x: Dt, y: Ht, z: Xt } = this, Zt = this.equals(vt.ZERO);
      kt == null && (kt = Zt ? V : Ot(Xt));
      const tr = kt, nr = Et(tr * tr), fr = Et(nr * tr), ir = Et(Dt * nr), pr = Et(Ht * fr), wr = Et(Xt * tr);
      if (Zt)
        return $t.ZERO;
      if (wr !== K)
        throw new Error("invZ was invalid");
      return new $t(ir, pr);
    }
  }
  vt.BASE = new vt(ne.Gx, ne.Gy, K), vt.ZERO = new vt(L, K, L);
  function mt(Ft, kt) {
    const Dt = kt.negate();
    return Ft ? Dt : kt;
  }
  const Pt = /* @__PURE__ */ new WeakMap();
  class $t {
    constructor(kt, Dt) {
      this.x = kt, this.y = Dt;
    }
    _setWindowSize(kt) {
      this._WINDOW_SIZE = kt, Pt.delete(this);
    }
    hasEvenY() {
      return this.y % J === L;
    }
    static fromCompressedHex(kt) {
      const Dt = kt.length === 32, Ht = ft(Dt ? kt : kt.subarray(1));
      if (!Qt(Ht))
        throw new Error("Point is not on curve");
      const Xt = at(Ht);
      let Zt = jt(Xt);
      const tr = (Zt & K) === K;
      Dt ? tr && (Zt = Et(-Zt)) : (kt[0] & 1) === 1 !== tr && (Zt = Et(-Zt));
      const nr = new $t(Ht, Zt);
      return nr.assertValidity(), nr;
    }
    static fromUncompressedHex(kt) {
      const Dt = ft(kt.subarray(1, re + 1)), Ht = ft(kt.subarray(re + 1, re * 2 + 1)), Xt = new $t(Dt, Ht);
      return Xt.assertValidity(), Xt;
    }
    static fromHex(kt) {
      const Dt = yt(kt), Ht = Dt.length, Xt = Dt[0];
      if (Ht === re)
        return this.fromCompressedHex(Dt);
      if (Ht === Ce && (Xt === 2 || Xt === 3))
        return this.fromCompressedHex(Dt);
      if (Ht === it && Xt === 4)
        return this.fromUncompressedHex(Dt);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ce} compressed bytes or ${it} uncompressed bytes, not ${Ht}`);
    }
    static fromPrivateKey(kt) {
      return $t.BASE.multiply(ar(kt));
    }
    static fromSignature(kt, Dt, Ht) {
      const { r: Xt, s: Zt } = hr(Dt);
      if (![0, 1, 2, 3].includes(Ht))
        throw new Error("Cannot recover: invalid recovery bit");
      const tr = Ut(yt(kt)), { n: nr } = ne, fr = Ht === 2 || Ht === 3 ? Xt + nr : Xt, ir = Ot(fr, nr), pr = Et(-tr * ir, nr), wr = Et(Zt * ir, nr), sr = Ht & 1 ? "03" : "02", Lt = $t.fromHex(sr + nt(fr)), Jt = $t.BASE.multiplyAndAddUnsafe(Lt, pr, wr);
      if (!Jt)
        throw new Error("Cannot recover signature: point at infinify");
      return Jt.assertValidity(), Jt;
    }
    toRawBytes(kt = !1) {
      return pt(this.toHex(kt));
    }
    toHex(kt = !1) {
      const Dt = nt(this.x);
      return kt ? `${this.hasEvenY() ? "02" : "03"}${Dt}` : `04${Dt}${nt(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const kt = "Point is not on elliptic curve", { x: Dt, y: Ht } = this;
      if (!Qt(Dt) || !Qt(Ht))
        throw new Error(kt);
      const Xt = Et(Ht * Ht), Zt = at(Dt);
      if (Et(Xt - Zt) !== L)
        throw new Error(kt);
    }
    equals(kt) {
      return this.x === kt.x && this.y === kt.y;
    }
    negate() {
      return new $t(this.x, Et(-this.y));
    }
    double() {
      return vt.fromAffine(this).double().toAffine();
    }
    add(kt) {
      return vt.fromAffine(this).add(vt.fromAffine(kt)).toAffine();
    }
    subtract(kt) {
      return this.add(kt.negate());
    }
    multiply(kt) {
      return vt.fromAffine(this).multiply(kt, this).toAffine();
    }
    multiplyAndAddUnsafe(kt, Dt, Ht) {
      const Xt = vt.fromAffine(this), Zt = Dt === L || Dt === K || this !== $t.BASE ? Xt.multiplyUnsafe(Dt) : Xt.multiply(Dt), tr = vt.fromAffine(kt).multiplyUnsafe(Ht), nr = Zt.add(tr);
      return nr.equals(vt.ZERO) ? void 0 : nr.toAffine();
    }
  }
  A.Point = $t, $t.BASE = new $t(ne.Gx, ne.Gy), $t.ZERO = new $t(L, L);
  function qt(Ft) {
    return Number.parseInt(Ft[0], 16) >= 8 ? "00" + Ft : Ft;
  }
  function At(Ft) {
    if (Ft.length < 2 || Ft[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${rt(Ft)}`);
    const kt = Ft[1], Dt = Ft.subarray(2, kt + 2);
    if (!kt || Dt.length !== kt)
      throw new Error("Invalid signature integer: wrong length");
    if (Dt[0] === 0 && Dt[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ft(Dt), left: Ft.subarray(kt + 2) };
  }
  function bt(Ft) {
    if (Ft.length < 2 || Ft[0] != 48)
      throw new Error(`Invalid signature tag: ${rt(Ft)}`);
    if (Ft[1] !== Ft.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: kt, left: Dt } = At(Ft.subarray(2)), { data: Ht, left: Xt } = At(Dt);
    if (Xt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${rt(Xt)}`);
    return { r: kt, s: Ht };
  }
  class xt {
    constructor(kt, Dt) {
      this.r = kt, this.s = Dt, this.assertValidity();
    }
    static fromCompact(kt) {
      const Dt = kt instanceof Uint8Array, Ht = "Signature.fromCompact";
      if (typeof kt != "string" && !Dt)
        throw new TypeError(`${Ht}: Expected string or Uint8Array`);
      const Xt = Dt ? rt(kt) : kt;
      if (Xt.length !== 128)
        throw new Error(`${Ht}: Expected 64-byte hex`);
      return new xt(ut(Xt.slice(0, 64)), ut(Xt.slice(64, 128)));
    }
    static fromDER(kt) {
      const Dt = kt instanceof Uint8Array;
      if (typeof kt != "string" && !Dt)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Ht, s: Xt } = bt(Dt ? kt : pt(kt));
      return new xt(Ht, Xt);
    }
    static fromHex(kt) {
      return this.fromDER(kt);
    }
    assertValidity() {
      const { r: kt, s: Dt } = this;
      if (!Kt(kt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Kt(Dt))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const kt = ne.n >> K;
      return this.s > kt;
    }
    normalizeS() {
      return this.hasHighS() ? new xt(this.r, Et(-this.s, ne.n)) : this;
    }
    toDERRawBytes() {
      return pt(this.toDERHex());
    }
    toDERHex() {
      const kt = qt(st(this.s)), Dt = qt(st(this.r)), Ht = kt.length / 2, Xt = Dt.length / 2, Zt = st(Ht), tr = st(Xt);
      return `30${st(Xt + Ht + 4)}02${tr}${Dt}02${Zt}${kt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return pt(this.toCompactHex());
    }
    toCompactHex() {
      return nt(this.r) + nt(this.s);
    }
  }
  A.Signature = xt;
  function wt(...Ft) {
    if (!Ft.every((Ht) => Ht instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Ft.length === 1)
      return Ft[0];
    const kt = Ft.reduce((Ht, Xt) => Ht + Xt.length, 0), Dt = new Uint8Array(kt);
    for (let Ht = 0, Xt = 0; Ht < Ft.length; Ht++) {
      const Zt = Ft[Ht];
      Dt.set(Zt, Xt), Xt += Zt.length;
    }
    return Dt;
  }
  const Oe = Array.from({ length: 256 }, (Ft, kt) => kt.toString(16).padStart(2, "0"));
  function rt(Ft) {
    if (!(Ft instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let kt = "";
    for (let Dt = 0; Dt < Ft.length; Dt++)
      kt += Oe[Ft[Dt]];
    return kt;
  }
  const pe = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function nt(Ft) {
    if (typeof Ft != "bigint")
      throw new Error("Expected bigint");
    if (!(L <= Ft && Ft < pe))
      throw new Error("Expected number 0 <= n < 2^256");
    return Ft.toString(16).padStart(64, "0");
  }
  function ot(Ft) {
    const kt = pt(nt(Ft));
    if (kt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return kt;
  }
  function st(Ft) {
    const kt = Ft.toString(16);
    return kt.length & 1 ? `0${kt}` : kt;
  }
  function ut(Ft) {
    if (typeof Ft != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Ft);
    return BigInt(`0x${Ft}`);
  }
  function pt(Ft) {
    if (typeof Ft != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Ft);
    if (Ft.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Ft.length);
    const kt = new Uint8Array(Ft.length / 2);
    for (let Dt = 0; Dt < kt.length; Dt++) {
      const Ht = Dt * 2, Xt = Ft.slice(Ht, Ht + 2), Zt = Number.parseInt(Xt, 16);
      if (Number.isNaN(Zt) || Zt < 0)
        throw new Error("Invalid byte sequence");
      kt[Dt] = Zt;
    }
    return kt;
  }
  function ft(Ft) {
    return ut(rt(Ft));
  }
  function yt(Ft) {
    return Ft instanceof Uint8Array ? Uint8Array.from(Ft) : pt(Ft);
  }
  function ct(Ft) {
    if (typeof Ft == "number" && Number.isSafeInteger(Ft) && Ft > 0)
      return BigInt(Ft);
    if (typeof Ft == "bigint" && Kt(Ft))
      return Ft;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Et(Ft, kt = ne.P) {
    const Dt = Ft % kt;
    return Dt >= L ? Dt : kt + Dt;
  }
  function Nt(Ft, kt) {
    const { P: Dt } = ne;
    let Ht = Ft;
    for (; kt-- > L; )
      Ht *= Ht, Ht %= Dt;
    return Ht;
  }
  function jt(Ft) {
    const { P: kt } = ne, Dt = BigInt(6), Ht = BigInt(11), Xt = BigInt(22), Zt = BigInt(23), tr = BigInt(44), nr = BigInt(88), fr = Ft * Ft * Ft % kt, ir = fr * fr * Ft % kt, pr = Nt(ir, W) * ir % kt, wr = Nt(pr, W) * ir % kt, sr = Nt(wr, J) * fr % kt, Lt = Nt(sr, Ht) * sr % kt, Jt = Nt(Lt, Xt) * Lt % kt, er = Nt(Jt, tr) * Jt % kt, or = Nt(er, nr) * er % kt, vr = Nt(or, tr) * Jt % kt, Er = Nt(vr, W) * ir % kt, Tr = Nt(Er, Zt) * Lt % kt, Pr = Nt(Tr, Dt) * fr % kt, Nr = Nt(Pr, J);
    if (Nr * Nr % kt !== Ft)
      throw new Error("Cannot find square root");
    return Nr;
  }
  function Ot(Ft, kt = ne.P) {
    if (Ft === L || kt <= L)
      throw new Error(`invert: expected positive integers, got n=${Ft} mod=${kt}`);
    let Dt = Et(Ft, kt), Ht = kt, Xt = L, Zt = K;
    for (; Dt !== L; ) {
      const nr = Ht / Dt, fr = Ht % Dt, ir = Xt - Zt * nr;
      Ht = Dt, Dt = fr, Xt = Zt, Zt = ir;
    }
    if (Ht !== K)
      throw new Error("invert: does not exist");
    return Et(Xt, kt);
  }
  function Bt(Ft, kt = ne.P) {
    const Dt = new Array(Ft.length), Ht = Ft.reduce((Zt, tr, nr) => tr === L ? Zt : (Dt[nr] = Zt, Et(Zt * tr, kt)), K), Xt = Ot(Ht, kt);
    return Ft.reduceRight((Zt, tr, nr) => tr === L ? Zt : (Dt[nr] = Et(Zt * Dt[nr], kt), Et(Zt * tr, kt)), Xt), Dt;
  }
  function Tt(Ft) {
    const kt = Ft.length * 8 - ce * 8, Dt = ft(Ft);
    return kt > 0 ? Dt >> BigInt(kt) : Dt;
  }
  function Ut(Ft, kt = !1) {
    const Dt = Tt(Ft);
    if (kt)
      return Dt;
    const { n: Ht } = ne;
    return Dt >= Ht ? Dt - Ht : Dt;
  }
  let Gt, It;
  class Mt {
    constructor(kt, Dt) {
      if (this.hashLen = kt, this.qByteLen = Dt, typeof kt != "number" || kt < 2)
        throw new Error("hashLen must be a number");
      if (typeof Dt != "number" || Dt < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(kt).fill(1), this.k = new Uint8Array(kt).fill(0), this.counter = 0;
    }
    hmac(...kt) {
      return A.utils.hmacSha256(this.k, ...kt);
    }
    hmacSync(...kt) {
      return It(this.k, ...kt);
    }
    checkSync() {
      if (typeof It != "function")
        throw new ht("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(kt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), kt), this.v = await this.hmac(this.v), kt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), kt), this.v = await this.hmac(this.v));
    }
    reseedSync(kt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), kt), this.v = this.hmacSync(this.v), kt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), kt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let kt = 0;
      const Dt = [];
      for (; kt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), kt += this.v.length;
      }
      return wt(...Dt);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let kt = 0;
      const Dt = [];
      for (; kt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), kt += this.v.length;
      }
      return wt(...Dt);
    }
  }
  function Kt(Ft) {
    return L < Ft && Ft < ne.n;
  }
  function Qt(Ft) {
    return L < Ft && Ft < ne.P;
  }
  function rr(Ft, kt, Dt, Ht = !0) {
    const { n: Xt } = ne, Zt = Ut(Ft, !0);
    if (!Kt(Zt))
      return;
    const tr = Ot(Zt, Xt), nr = $t.BASE.multiply(Zt), fr = Et(nr.x, Xt);
    if (fr === L)
      return;
    const ir = Et(tr * Et(kt + Dt * fr, Xt), Xt);
    if (ir === L)
      return;
    let pr = new xt(fr, ir), wr = (nr.x === pr.r ? 0 : 2) | Number(nr.y & K);
    return Ht && pr.hasHighS() && (pr = pr.normalizeS(), wr ^= 1), { sig: pr, recovery: wr };
  }
  function ar(Ft) {
    let kt;
    if (typeof Ft == "bigint")
      kt = Ft;
    else if (typeof Ft == "number" && Number.isSafeInteger(Ft) && Ft > 0)
      kt = BigInt(Ft);
    else if (typeof Ft == "string") {
      if (Ft.length !== 2 * ce)
        throw new Error("Expected 32 bytes of private key");
      kt = ut(Ft);
    } else if (Ft instanceof Uint8Array) {
      if (Ft.length !== ce)
        throw new Error("Expected 32 bytes of private key");
      kt = ft(Ft);
    } else
      throw new TypeError("Expected valid private key");
    if (!Kt(kt))
      throw new Error("Expected private key: 0 < key < n");
    return kt;
  }
  function ur(Ft) {
    return Ft instanceof $t ? (Ft.assertValidity(), Ft) : $t.fromHex(Ft);
  }
  function hr(Ft) {
    if (Ft instanceof xt)
      return Ft.assertValidity(), Ft;
    try {
      return xt.fromDER(Ft);
    } catch {
      return xt.fromCompact(Ft);
    }
  }
  function Yt(Ft, kt = !1) {
    return $t.fromPrivateKey(Ft).toRawBytes(kt);
  }
  A.getPublicKey = Yt;
  function Rr(Ft, kt, Dt, Ht = !1) {
    return $t.fromSignature(Ft, kt, Dt).toRawBytes(Ht);
  }
  A.recoverPublicKey = Rr;
  function lr(Ft) {
    const kt = Ft instanceof Uint8Array, Dt = typeof Ft == "string", Ht = (kt || Dt) && Ft.length;
    return kt ? Ht === Ce || Ht === it : Dt ? Ht === Ce * 2 || Ht === it * 2 : Ft instanceof $t;
  }
  function $r(Ft, kt, Dt = !1) {
    if (lr(Ft))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!lr(kt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Ht = ur(kt);
    return Ht.assertValidity(), Ht.multiply(ar(Ft)).toRawBytes(Dt);
  }
  A.getSharedSecret = $r;
  function Br(Ft) {
    const kt = Ft.length > re ? Ft.slice(0, re) : Ft;
    return ft(kt);
  }
  function dr(Ft) {
    const kt = Br(Ft), Dt = Et(kt, ne.n);
    return Sr(Dt < L ? kt : Dt);
  }
  function Sr(Ft) {
    return ot(Ft);
  }
  function Mr(Ft, kt, Dt) {
    if (Ft == null)
      throw new Error(`sign: expected valid message hash, not "${Ft}"`);
    const Ht = yt(Ft), Xt = ar(kt), Zt = [Sr(Xt), dr(Ht)];
    if (Dt != null) {
      Dt === !0 && (Dt = A.utils.randomBytes(re));
      const fr = yt(Dt);
      if (fr.length !== re)
        throw new Error(`sign: Expected ${re} bytes of extra data`);
      Zt.push(fr);
    }
    const tr = wt(...Zt), nr = Br(Ht);
    return { seed: tr, m: nr, d: Xt };
  }
  function br(Ft, kt) {
    const { sig: Dt, recovery: Ht } = Ft, { der: Xt, recovered: Zt } = Object.assign({ canonical: !0, der: !0 }, kt), tr = Xt ? Dt.toDERRawBytes() : Dt.toCompactRawBytes();
    return Zt ? [tr, Ht] : tr;
  }
  async function Ir(Ft, kt, Dt = {}) {
    const { seed: Ht, m: Xt, d: Zt } = Mr(Ft, kt, Dt.extraEntropy), tr = new Mt(ke, ce);
    await tr.reseed(Ht);
    let nr;
    for (; !(nr = rr(await tr.generate(), Xt, Zt, Dt.canonical)); )
      await tr.reseed();
    return br(nr, Dt);
  }
  A.sign = Ir;
  function Or(Ft, kt, Dt = {}) {
    const { seed: Ht, m: Xt, d: Zt } = Mr(Ft, kt, Dt.extraEntropy), tr = new Mt(ke, ce);
    tr.reseedSync(Ht);
    let nr;
    for (; !(nr = rr(tr.generateSync(), Xt, Zt, Dt.canonical)); )
      tr.reseedSync();
    return br(nr, Dt);
  }
  A.signSync = Or;
  const Rt = { strict: !0 };
  function gt(Ft, kt, Dt, Ht = Rt) {
    let Xt;
    try {
      Xt = hr(Ft), kt = yt(kt);
    } catch {
      return !1;
    }
    const { r: Zt, s: tr } = Xt;
    if (Ht.strict && Xt.hasHighS())
      return !1;
    const nr = Ut(kt);
    let fr;
    try {
      fr = ur(Dt);
    } catch {
      return !1;
    }
    const { n: ir } = ne, pr = Ot(tr, ir), wr = Et(nr * pr, ir), sr = Et(Zt * pr, ir), Lt = $t.BASE.multiplyAndAddUnsafe(fr, wr, sr);
    return Lt ? Et(Lt.x, ir) === Zt : !1;
  }
  A.verify = gt;
  function St(Ft) {
    return Et(ft(Ft), ne.n);
  }
  class Ct {
    constructor(kt, Dt) {
      this.r = kt, this.s = Dt, this.assertValidity();
    }
    static fromHex(kt) {
      const Dt = yt(kt);
      if (Dt.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Dt.length}`);
      const Ht = ft(Dt.subarray(0, 32)), Xt = ft(Dt.subarray(32, 64));
      return new Ct(Ht, Xt);
    }
    assertValidity() {
      const { r: kt, s: Dt } = this;
      if (!Qt(kt) || !Kt(Dt))
        throw new Error("Invalid signature");
    }
    toHex() {
      return nt(this.r) + nt(this.s);
    }
    toRawBytes() {
      return pt(this.toHex());
    }
  }
  function Wt(Ft) {
    return $t.fromPrivateKey(Ft).toRawX();
  }
  class zt {
    constructor(kt, Dt, Ht = A.utils.randomBytes()) {
      if (kt == null)
        throw new TypeError(`sign: Expected valid message, not "${kt}"`);
      this.m = yt(kt);
      const { x: Xt, scalar: Zt } = this.getScalar(ar(Dt));
      if (this.px = Xt, this.d = Zt, this.rand = yt(Ht), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(kt) {
      const Dt = $t.fromPrivateKey(kt), Ht = Dt.hasEvenY() ? kt : ne.n - kt;
      return { point: Dt, scalar: Ht, x: Dt.toRawX() };
    }
    initNonce(kt, Dt) {
      return ot(kt ^ ft(Dt));
    }
    finalizeNonce(kt) {
      const Dt = Et(ft(kt), ne.n);
      if (Dt === L)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Ht, x: Xt, scalar: Zt } = this.getScalar(Dt);
      return { R: Ht, rx: Xt, k: Zt };
    }
    finalizeSig(kt, Dt, Ht, Xt) {
      return new Ct(kt.x, Et(Dt + Ht * Xt, ne.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: kt, d: Dt, px: Ht, rand: Xt } = this, Zt = A.utils.taggedHash, tr = this.initNonce(Dt, await Zt(kr.aux, Xt)), { R: nr, rx: fr, k: ir } = this.finalizeNonce(await Zt(kr.nonce, tr, Ht, kt)), pr = St(await Zt(kr.challenge, fr, Ht, kt)), wr = this.finalizeSig(nr, ir, pr, Dt);
      return await Ar(wr, kt, Ht) || this.error(), wr;
    }
    calcSync() {
      const { m: kt, d: Dt, px: Ht, rand: Xt } = this, Zt = A.utils.taggedHashSync, tr = this.initNonce(Dt, Zt(kr.aux, Xt)), { R: nr, rx: fr, k: ir } = this.finalizeNonce(Zt(kr.nonce, tr, Ht, kt)), pr = St(Zt(kr.challenge, fr, Ht, kt)), wr = this.finalizeSig(nr, ir, pr, Dt);
      return gr(wr, kt, Ht) || this.error(), wr;
    }
  }
  async function Vt(Ft, kt, Dt) {
    return new zt(Ft, kt, Dt).calc();
  }
  function yr(Ft, kt, Dt) {
    return new zt(Ft, kt, Dt).calcSync();
  }
  function xr(Ft, kt, Dt) {
    const Ht = Ft instanceof Ct, Xt = Ht ? Ft : Ct.fromHex(Ft);
    return Ht && Xt.assertValidity(), {
      ...Xt,
      m: yt(kt),
      P: ur(Dt)
    };
  }
  function cr(Ft, kt, Dt, Ht) {
    const Xt = $t.BASE.multiplyAndAddUnsafe(kt, ar(Dt), Et(-Ht, ne.n));
    return !(!Xt || !Xt.hasEvenY() || Xt.x !== Ft);
  }
  async function Ar(Ft, kt, Dt) {
    try {
      const { r: Ht, s: Xt, m: Zt, P: tr } = xr(Ft, kt, Dt), nr = St(await A.utils.taggedHash(kr.challenge, ot(Ht), tr.toRawX(), Zt));
      return cr(Ht, tr, Xt, nr);
    } catch {
      return !1;
    }
  }
  function gr(Ft, kt, Dt) {
    try {
      const { r: Ht, s: Xt, m: Zt, P: tr } = xr(Ft, kt, Dt), nr = St(A.utils.taggedHashSync(kr.challenge, ot(Ht), tr.toRawX(), Zt));
      return cr(Ht, tr, Xt, nr);
    } catch (Ht) {
      if (Ht instanceof ht)
        throw Ht;
      return !1;
    }
  }
  A.schnorr = {
    Signature: Ct,
    getPublicKey: Wt,
    sign: Vt,
    verify: Ar,
    signSync: yr,
    verifySync: gr
  }, $t.BASE._setWindowSize(8);
  const _r = {
    node: B,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, kr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Cr = {};
  A.utils = {
    bytesToHex: rt,
    hexToBytes: pt,
    concatBytes: wt,
    mod: Et,
    invert: Ot,
    isValidPrivateKey(Ft) {
      try {
        return ar(Ft), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: ot,
    _normalizePrivateKey: ar,
    hashToPrivateKey: (Ft) => {
      Ft = yt(Ft);
      const kt = ce + 8;
      if (Ft.length < kt || Ft.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Dt = Et(ft(Ft), ne.n - K) + K;
      return ot(Dt);
    },
    randomBytes: (Ft = 32) => {
      if (_r.web)
        return _r.web.getRandomValues(new Uint8Array(Ft));
      if (_r.node) {
        const { randomBytes: kt } = _r.node;
        return Uint8Array.from(kt(Ft));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => A.utils.hashToPrivateKey(A.utils.randomBytes(ce + 8)),
    precompute(Ft = 8, kt = $t.BASE) {
      const Dt = kt === $t.BASE ? kt : new $t(kt.x, kt.y);
      return Dt._setWindowSize(Ft), Dt.multiply(W), Dt;
    },
    sha256: async (...Ft) => {
      if (_r.web) {
        const kt = await _r.web.subtle.digest("SHA-256", wt(...Ft));
        return new Uint8Array(kt);
      } else if (_r.node) {
        const { createHash: kt } = _r.node, Dt = kt("sha256");
        return Ft.forEach((Ht) => Dt.update(Ht)), Uint8Array.from(Dt.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Ft, ...kt) => {
      if (_r.web) {
        const Dt = await _r.web.subtle.importKey("raw", Ft, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Ht = wt(...kt), Xt = await _r.web.subtle.sign("HMAC", Dt, Ht);
        return new Uint8Array(Xt);
      } else if (_r.node) {
        const { createHmac: Dt } = _r.node, Ht = Dt("sha256", Ft);
        return kt.forEach((Xt) => Ht.update(Xt)), Uint8Array.from(Ht.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Ft, ...kt) => {
      let Dt = Cr[Ft];
      if (Dt === void 0) {
        const Ht = await A.utils.sha256(Uint8Array.from(Ft, (Xt) => Xt.charCodeAt(0)));
        Dt = wt(Ht, Ht), Cr[Ft] = Dt;
      }
      return A.utils.sha256(Dt, ...kt);
    },
    taggedHashSync: (Ft, ...kt) => {
      if (typeof Gt != "function")
        throw new ht("sha256Sync is undefined, you need to set it");
      let Dt = Cr[Ft];
      if (Dt === void 0) {
        const Ht = Gt(Uint8Array.from(Ft, (Xt) => Xt.charCodeAt(0)));
        Dt = wt(Ht, Ht), Cr[Ft] = Dt;
      }
      return Gt(Dt, ...kt);
    },
    _JacobianPoint: vt
  }, Object.defineProperties(A.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return Gt;
      },
      set(Ft) {
        Gt || (Gt = Ft);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return It;
      },
      set(Ft) {
        It || (It = Ft);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js$1, base64Url_1 = base64Url;
function getParamSize(A) {
  return (A / 8 | 0) + (A % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(A) {
  const B = paramBytesForAlg[A];
  if (B)
    return B;
  throw new Error(`Unknown algorithm "${A}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(A) {
  if (A instanceof Uint8Array)
    return A;
  if (typeof A == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(A));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(A, B) {
  const L = signatureAsBytes(A), K = getParamBytesForAlg(B), J = K + 1, W = L.length;
  let V = 0;
  if (L[V++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ne = L[V++];
  if (ne === (MAX_OCTET | 1) && (ne = L[V++]), W - V < ne)
    throw new Error(`"seq" specified length of "${ne}", only "${W - V}" remaining`);
  if (L[V++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ie = L[V++];
  if (W - V - 2 < ie)
    throw new Error(`"r" specified length of "${ie}", only "${W - V - 2}" available`);
  if (J < ie)
    throw new Error(`"r" specified length of "${ie}", max of "${J}" is acceptable`);
  const oe = V;
  if (V += ie, L[V++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const re = L[V++];
  if (W - V !== re)
    throw new Error(`"s" specified length of "${re}", expected "${W - V}"`);
  if (J < re)
    throw new Error(`"s" specified length of "${re}", max of "${J}" is acceptable`);
  const ce = V;
  if (V += re, V !== W)
    throw new Error(`Expected to consume entire array, but "${W - V}" bytes remain`);
  const ke = K - ie, Ce = K - re, it = new Uint8Array(ke + ie + Ce + re);
  for (V = 0; V < ke; ++V)
    it[V] = 0;
  it.set(L.subarray(oe + Math.max(-ke, 0), oe + ie), V), V = K;
  for (const at = V; V < at + Ce; ++V)
    it[V] = 0;
  return it.set(L.subarray(ce + Math.max(-Ce, 0), ce + re), V), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(it));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(A, B, L) {
  let K = 0;
  for (; B + K < L && A[B + K] === 0; )
    ++K;
  return A[B + K] >= MAX_OCTET && --K, K;
}
function joseToDer(A, B) {
  A = signatureAsBytes(A);
  const L = getParamBytesForAlg(B), K = A.length;
  if (K !== L * 2)
    throw new TypeError(`"${B}" signatures must be "${L * 2}" bytes, saw "${K}"`);
  const J = countPadding(A, 0, L), W = countPadding(A, L, A.length), V = L - J, ne = L - W, ie = 2 + V + 1 + 1 + ne, oe = ie < MAX_OCTET, re = new Uint8Array((oe ? 2 : 3) + ie);
  let ce = 0;
  return re[ce++] = ENCODED_TAG_SEQ, oe ? re[ce++] = ie : (re[ce++] = MAX_OCTET | 1, re[ce++] = ie & 255), re[ce++] = ENCODED_TAG_INT, re[ce++] = V, J < 0 ? (re[ce++] = 0, re.set(A.subarray(0, L), ce), ce += L) : (re.set(A.subarray(J, L), ce), ce += L - J), re[ce++] = ENCODED_TAG_INT, re[ce++] = ne, W < 0 ? (re[ce++] = 0, re.set(A.subarray(L), ce)) : re.set(A.subarray(L + W), ce), re;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(B) {
    super(), this.name = "MissingParametersError", this.message = B || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(B) {
    super(), this.name = "InvalidTokenError", this.message = B || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (A, ...B) => {
  const L = hmac_1.hmac.create(sha256_1$3.sha256, A);
  return B.forEach((K) => L.update(K)), L.digest();
};
class SECP256K1Client {
  static derivePublicKey(B, L = !0) {
    return B.length === 66 && (B = B.slice(0, 64)), B.length < 64 && (B = B.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(B, L));
  }
  static signHash(B, L, K = "jose") {
    if (!B || !L)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const J = secp.signSync(B, L.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (K === "der")
      return (0, utils_1$2.bytesToHex)(J);
    if (K === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(J, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(B) {
    return (0, ecdsaSigFormatter_1.joseToDer)(B, "ES256");
  }
  static verifyHash(B, L, K) {
    if (!B || !L || !K)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(L, B, K, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.cryptoClients = A.SECP256K1Client = void 0;
  const B = secp256k1$1;
  Object.defineProperty(A, "SECP256K1Client", { enumerable: !0, get: function() {
    return B.SECP256K1Client;
  } });
  const L = {
    ES256K: B.SECP256K1Client
  };
  A.cryptoClients = L;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function J(W) {
    return W instanceof L ? W : new L(function(V) {
      V(W);
    });
  }
  return new (L || (L = Promise))(function(W, V) {
    function ne(re) {
      try {
        oe(K.next(re));
      } catch (ce) {
        V(ce);
      }
    }
    function ie(re) {
      try {
        oe(K.throw(re));
      } catch (ce) {
        V(ce);
      }
    }
    function oe(re) {
      re.done ? W(re.value) : J(re.value).then(ne, ie);
    }
    oe((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(A) {
  return (0, sha256_1$2.sha256)(A);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(A) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const L = typeof A == "string" ? new TextEncoder().encode(A) : A, K = yield crypto.subtle.digest("SHA-256", L);
        return new Uint8Array(K);
      } else {
        const L = requireCryptoBrowserify();
        if (!L.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(L.createHash("sha256").update(A).digest());
      }
    } catch (B) {
      return console.log(B), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(A));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function J(W) {
    return W instanceof L ? W : new L(function(V) {
      V(W);
    });
  }
  return new (L || (L = Promise))(function(W, V) {
    function ne(re) {
      try {
        oe(K.next(re));
      } catch (ce) {
        V(ce);
      }
    }
    function ie(re) {
      try {
        oe(K.throw(re));
      } catch (ce) {
        V(ce);
      }
    }
    function oe(re) {
      re.done ? W(re.value) : J(re.value).then(ne, ie);
    }
    oe((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(A, B) {
  const L = [], K = base64url$2.encode(JSON.stringify(B));
  L.push(K);
  const J = base64url$2.encode(JSON.stringify(A));
  return L.push(J), L.join(".");
}
function createUnsecuredToken(A) {
  return createSigningInput(A, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof B != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (B = B.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(B))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[B], this.rawPrivateKey = L;
  }
  header(B = {}) {
    const L = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, L, B);
  }
  sign(B, L = !1, K = {}) {
    const J = this.header(K), W = createSigningInput(B, J), V = (0, sha256_1$1.hashSha256)(W);
    return this.createWithSignedHash(B, L, J, W, V);
  }
  signAsync(B, L = !1, K = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const J = this.header(K), W = createSigningInput(B, J), V = yield (0, sha256_1$1.hashSha256Async)(W);
      return this.createWithSignedHash(B, L, J, W, V);
    });
  }
  createWithSignedHash(B, L, K, J, W) {
    const V = this.cryptoClient.signHash(W, this.rawPrivateKey);
    return L ? {
      header: [base64url$2.encode(JSON.stringify(K))],
      payload: JSON.stringify(B),
      signature: [V]
    } : [J, V].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof B != "string")
      throw "signing algorithm parameter must be a string";
    if (B = B.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(B))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[B], this.rawPublicKey = L;
  }
  verify(B) {
    return typeof B == "string" ? this.verifyCompact(B, !1) : typeof B == "object" ? this.verifyExpanded(B, !1) : !1;
  }
  verifyAsync(B) {
    return typeof B == "string" ? this.verifyCompact(B, !0) : typeof B == "object" ? this.verifyExpanded(B, !0) : Promise.resolve(!1);
  }
  verifyCompact(B, L) {
    const K = B.split("."), J = K[0] + "." + K[1], W = (V) => {
      const ne = this.cryptoClient.loadSignature(K[2]);
      return this.cryptoClient.verifyHash(V, ne, this.rawPublicKey);
    };
    if (L)
      return (0, sha256_1.hashSha256Async)(J).then((V) => W(V));
    {
      const V = (0, sha256_1.hashSha256)(J);
      return W(V);
    }
  }
  verifyExpanded(B, L) {
    const K = [B.header.join("."), base64url$1.encode(B.payload)].join(".");
    let J = !0;
    const W = (V) => (B.signature.map((ne) => {
      const ie = this.cryptoClient.loadSignature(ne);
      this.cryptoClient.verifyHash(V, ie, this.rawPublicKey) || (J = !1);
    }), J);
    if (L)
      return (0, sha256_1.hashSha256Async)(K).then((V) => W(V));
    {
      const V = (0, sha256_1.hashSha256)(K);
      return W(V);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(A) {
  if (typeof A == "string") {
    const B = A.split("."), L = JSON.parse(base64url.decode(B[0])), K = JSON.parse(base64url.decode(B[1])), J = B[2];
    return {
      header: L,
      payload: K,
      signature: J
    };
  } else if (typeof A == "object") {
    if (typeof A.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let B = A.payload;
    A.payload[0] !== "{" && (B = base64url.decode(B));
    const L = [];
    return A.header.map((K) => {
      const J = JSON.parse(base64url.decode(K));
      L.push(J);
    }), {
      header: L,
      payload: JSON.parse(B),
      signature: A.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(A) {
  var B = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(K, J, W, V) {
    V === void 0 && (V = W);
    var ne = Object.getOwnPropertyDescriptor(J, W);
    (!ne || ("get" in ne ? !J.__esModule : ne.writable || ne.configurable)) && (ne = { enumerable: !0, get: function() {
      return J[W];
    } }), Object.defineProperty(K, V, ne);
  } : function(K, J, W, V) {
    V === void 0 && (V = W), K[V] = J[W];
  }), L = commonjsGlobal && commonjsGlobal.__exportStar || function(K, J) {
    for (var W in K) W !== "default" && !Object.prototype.hasOwnProperty.call(J, W) && B(J, K, W);
  };
  Object.defineProperty(A, "__esModule", { value: !0 }), L(signer, A), L(verifier, A), L(decode$i, A), L(errors$1, A), L(cryptoClients, A);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const A = Array(256).fill(-1);
  for (let B = 0; B < r.length; ++B) A[r.charCodeAt(B)] = B;
})();
var s, i, o, h$1 = (s = function(A, B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bech32m = B.bech32 = void 0;
  const L = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", K = {};
  for (let ce = 0; ce < 32; ce++) {
    const ke = L.charAt(ce);
    K[ke] = ce;
  }
  function J(ce) {
    const ke = ce >> 25;
    return (33554431 & ce) << 5 ^ 996825010 & -(ke >> 0 & 1) ^ 642813549 & -(ke >> 1 & 1) ^ 513874426 & -(ke >> 2 & 1) ^ 1027748829 & -(ke >> 3 & 1) ^ 705979059 & -(ke >> 4 & 1);
  }
  function W(ce) {
    let ke = 1;
    for (let Ce = 0; Ce < ce.length; ++Ce) {
      const it = ce.charCodeAt(Ce);
      if (it < 33 || it > 126) return "Invalid prefix (" + ce + ")";
      ke = J(ke) ^ it >> 5;
    }
    ke = J(ke);
    for (let Ce = 0; Ce < ce.length; ++Ce) {
      const it = ce.charCodeAt(Ce);
      ke = J(ke) ^ 31 & it;
    }
    return ke;
  }
  function V(ce, ke, Ce, it) {
    let at = 0, lt = 0;
    const ht = (1 << Ce) - 1, dt = [];
    for (let vt = 0; vt < ce.length; ++vt) for (at = at << ke | ce[vt], lt += ke; lt >= Ce; ) lt -= Ce, dt.push(at >> lt & ht);
    if (it) lt > 0 && dt.push(at << Ce - lt & ht);
    else {
      if (lt >= ke) return "Excess padding";
      if (at << Ce - lt & ht) return "Non-zero padding";
    }
    return dt;
  }
  function ne(ce) {
    return V(ce, 8, 5, !0);
  }
  function ie(ce) {
    const ke = V(ce, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
  }
  function oe(ce) {
    const ke = V(ce, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
    throw new Error(ke);
  }
  function re(ce) {
    let ke;
    function Ce(it, at) {
      if (at = at || 90, it.length < 8) return it + " too short";
      if (it.length > at) return "Exceeds length limit";
      const lt = it.toLowerCase(), ht = it.toUpperCase();
      if (it !== lt && it !== ht) return "Mixed-case string " + it;
      const dt = (it = lt).lastIndexOf("1");
      if (dt === -1) return "No separator character for " + it;
      if (dt === 0) return "Missing prefix for " + it;
      const vt = it.slice(0, dt), mt = it.slice(dt + 1);
      if (mt.length < 6) return "Data too short";
      let Pt = W(vt);
      if (typeof Pt == "string") return Pt;
      const $t = [];
      for (let qt = 0; qt < mt.length; ++qt) {
        const At = mt.charAt(qt), bt = K[At];
        if (bt === void 0) return "Unknown character " + At;
        Pt = J(Pt) ^ bt, qt + 6 >= mt.length || $t.push(bt);
      }
      return Pt !== ke ? "Invalid checksum for " + it : { prefix: vt, words: $t };
    }
    return ke = ce === "bech32" ? 1 : 734539939, { decodeUnsafe: function(it, at) {
      const lt = Ce(it, at);
      if (typeof lt == "object") return lt;
    }, decode: function(it, at) {
      const lt = Ce(it, at);
      if (typeof lt == "object") return lt;
      throw new Error(lt);
    }, encode: function(it, at, lt) {
      if (lt = lt || 90, it.length + 7 + at.length > lt) throw new TypeError("Exceeds length limit");
      let ht = W(it = it.toLowerCase());
      if (typeof ht == "string") throw new Error(ht);
      let dt = it + "1";
      for (let vt = 0; vt < at.length; ++vt) {
        const mt = at[vt];
        if (mt >> 5) throw new Error("Non 5-bit word");
        ht = J(ht) ^ mt, dt += L.charAt(mt);
      }
      for (let vt = 0; vt < 6; ++vt) ht = J(ht);
      ht ^= ke;
      for (let vt = 0; vt < 6; ++vt) dt += L.charAt(ht >> 5 * (5 - vt) & 31);
      return dt;
    }, toWords: ne, fromWordsUnsafe: ie, fromWords: oe };
  }
  B.bech32 = re("bech32"), B.bech32m = re("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(A) {
  A.mainnet = "mainnet", A.testnet = "testnet", A.regtest = "regtest";
})(x || (x = {})), function(A) {
  A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange";
object({
  type: literal(networkChangeEventName)
});
async function getProviderOrThrow(A) {
  var L;
  const B = await (A == null ? void 0 : A()) || ((L = window.XverseProviders) == null ? void 0 : L.BitcoinProvider) || window.BitcoinProvider;
  if (!B)
    throw new Error("No Bitcoin wallet installed");
  return B;
}
var BitcoinNetworkType = /* @__PURE__ */ ((A) => (A.Mainnet = "Mainnet", A.Testnet = "Testnet", A.Signet = "Signet", A))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number$1(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: RpcIdSchema
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var AddressPurpose = /* @__PURE__ */ ((A) => (A.Ordinals = "ordinals", A.Payment = "payment", A.Stacks = "stacks", A))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((A) => (A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr", A.stacks = "stacks", A))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType)
}), stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((A) => (A.ECDSA = "ECDSA", A.BIP322 = "BIP322", A))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    id: string()
  }).entries
});
var getRunesBalanceMethodName = "runes_getBalance", getRunesBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number$1(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getRunesBalanceMethodName),
    params: getRunesBalanceParamsSchema,
    id: string()
  }).entries
});
var transferRunesMethodName = "runes_transfer", transferRunesParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(transferRunesMethodName),
    params: transferRunesParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number$1(),
  limit: number$1()
});
object({
  total: number$1(),
  limit: number$1(),
  offset: number$1(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number$1(),
      offset: number$1(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var serializer = (A) => A.map((B) => {
  const { address: L, amountSats: K } = B;
  return {
    address: L,
    amountSats: K.toString()
  };
}), sendBtcTransaction = async (A) => {
  var V, ne;
  const B = await getProviderOrThrow(A.getProvider), { recipients: L, senderAddress: K, network: J, message: W } = A.payload;
  if (!L || L.length === 0)
    throw new Error("At least one recipient is required");
  if (L.some(
    (ie) => typeof ie.address != "string" || typeof ie.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!K)
    throw new Error("The sender address is required");
  try {
    const ie = serializer(L), oe = {
      network: J,
      senderAddress: K,
      message: W,
      recipients: ie
    }, re = lib$1.createUnsecuredToken(oe), ce = await B.sendBtcTransaction(re);
    (V = A.onFinish) == null || V.call(A, ce);
  } catch (ie) {
    console.error("[Connect] Error during send BTC transaction request", ie), (ne = A.onCancel) == null || ne.call(A);
  }
};
async function leatherRequest(A, B) {
  if (typeof window < "u" && window.LeatherProvider)
    try {
      return (await window.LeatherProvider.request(
        A,
        B
      )).result;
    } catch (L) {
      const K = L, { message: J } = K.error;
      throw K.error.code === 4001 ? new Error(J) : new Error(`Leather error: ${J}`);
    }
  else
    throw new Error("LeatherProvider not found");
}
var __classPrivateFieldGet = function(A, B, L, K) {
  if (L === "a" && !K) throw new TypeError("Private accessor was defined without a getter");
  if (typeof B == "function" ? A !== B || !K : !B.has(A)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return L === "m" ? K : L === "a" ? K.call(A) : K ? K.value : B.get(A);
}, __classPrivateFieldSet = function(A, B, L, K, J) {
  if (K === "m") throw new TypeError("Private method is not writable");
  if (K === "a" && !J) throw new TypeError("Private accessor was defined without a setter");
  if (typeof B == "function" ? A !== B || !J : !B.has(A)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return K === "a" ? J.call(A, L) : J ? J.value = L : B.set(A, L), L;
}, _AppReadyEvent_detail;
let wallets;
const registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(A) {
  cachedWalletsArray = void 0, registeredWalletsSet.add(A);
}
function removeRegisteredWallet(A) {
  cachedWalletsArray = void 0, registeredWalletsSet.delete(A);
}
const listeners = {};
function getWallets() {
  if (wallets || (wallets = Object.freeze({ register, get, on }), typeof window > "u"))
    return wallets;
  const A = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: B }) => B(A));
  } catch (B) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, B);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(A));
  } catch (B) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, B);
  }
  return wallets;
}
function register(...A) {
  var B;
  return A = A.filter((L) => !registeredWalletsSet.has(L)), A.length ? (A.forEach((L) => addRegisteredWallet(L)), (B = listeners.register) == null || B.forEach((L) => guard(() => L(...A))), function() {
    var K;
    A.forEach((J) => removeRegisteredWallet(J)), (K = listeners.unregister) == null || K.forEach((J) => guard(() => J(...A)));
  }) : () => {
  };
}
let cachedWalletsArray;
function get() {
  return cachedWalletsArray || (cachedWalletsArray = [...registeredWalletsSet]), cachedWalletsArray;
}
function on(A, B) {
  var L;
  return (L = listeners[A]) != null && L.push(B) || (listeners[A] = [B]), function() {
    var J;
    listeners[A] = (J = listeners[A]) == null ? void 0 : J.filter((W) => B !== W);
  };
}
function guard(A) {
  try {
    A();
  } catch (B) {
    console.error(B);
  }
}
class AppReadyEvent extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(B) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), _AppReadyEvent_detail.set(this, void 0), __classPrivateFieldSet(this, _AppReadyEvent_detail, B, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();
async function walletProvider() {
  const { get: A } = getWallets(), L = A().find(
    (K) => {
      var J, W;
      return K.name === "Magic Eden" && ((W = (J = K.features["sats-connect:"]) == null ? void 0 : J.provider) == null ? void 0 : W.isMagicEden) === !0;
    }
  );
  if (!L)
    throw new Error("Magic Eden wallet not found");
  return L.features["sats-connect:"].provider;
}
function useSendBtc() {
  const { wallet: A, network: B, address: L, publicKey: K } = useWallie(), [J, W] = useState(null), [V, ne] = useState(!1);
  return { send: useCallback(
    async (oe, re) => {
      ne(!0);
      try {
        if (W(null), !L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        if (A === "magiceden" || A === "xverse") {
          const ce = A === "magiceden" ? await walletProvider() : void 0;
          let ke = null;
          return ke = await new Promise((Ce, it) => {
            sendBtcTransaction({
              payload: {
                network: {
                  type: B === "mainnet" ? BitcoinNetworkType.Mainnet : BitcoinNetworkType.Testnet
                },
                message: "Sign Transaction",
                recipients: [
                  {
                    address: oe,
                    amountSats: BigInt(re)
                  }
                ],
                senderAddress: L.payments
              },
              getProvider: async () => ce,
              onFinish: (at) => {
                Ce(at);
              },
              onCancel: () => {
                it(new Error("Transaction canceled"));
              }
            });
          }), ne(!1), ke;
        }
        if (A === "unisat") {
          let ce = "";
          return ce = await window.unisat.sendBitcoin(oe, re, {}), ne(!1), ce;
        }
        if (A === "leather") {
          let ce = "";
          return ce = (await leatherRequest(
            "sendTransfer",
            {
              recipients: [
                {
                  address: oe,
                  amount: re
                }
              ],
              network: B
            }
          )).txid, ne(!1), ce;
        }
        if (A === "okx") {
          let ce = "";
          if (B === "mainnet")
            return ce = await window.okxwallet.bitcoin.sendBitcoin(
              oe,
              re,
              {}
            ), ne(!1), ce;
          if (B === "testnet")
            return ce = await window.okxwallet.bitcoinTestnet.sendBitcoin(
              oe,
              re,
              {}
            ), ne(!1), ce;
        }
        return ne(!1), null;
      } catch (ce) {
        return W(ce.message), ne(!1), null;
      }
    },
    [L, B, K, A]
  ), error: J, loading: V };
}
function useSendV2() {
  const { wallet: A, network: B, address: L, publicKey: K } = useWallie(), [J, W] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ne,
      satoshis: ie,
      feeRate: oe,
      relay: re = !0,
      rbf: ce = !1
    }) => {
      W(!0);
      try {
        if (!L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const ke = new PSBTBuilder({
          address: L.payments,
          feeRate: oe,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ne,
              value: ie
            }
          ]
        });
        ke.setRBF(ce), await ke.prepare();
        const Ce = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: ke.toPSBT()
        });
        if (re) {
          const at = await new JsonRpcDatasource({ network: B }).relay({ hex: Ce.hex });
          return W(!1), {
            txId: at
          };
        }
        return W(!1), {
          signedPsbtHex: Ce.hex
        };
      } catch (ke) {
        return W(!1), {
          error: ke.message
        };
      }
    },
    [L, B, K, A]
  ), isLoading: J };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(A) {
  if (A.length < 8 || A.length > 72 || A[0] !== 48 || A[1] !== A.length - 2 || A[2] !== 2) return !1;
  const B = A[3];
  if (B === 0 || 5 + B >= A.length || A[4 + B] !== 2) return !1;
  const L = A[5 + B];
  return !(L === 0 || 6 + B + L !== A.length || A[4] & 128 || B > 1 && A[4] === 0 && !(A[5] & 128) || A[B + 6] & 128 || L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128));
}
bip66.check = check$d;
function decode$h(A) {
  if (A.length < 8) throw new Error("DER sequence length is too short");
  if (A.length > 72) throw new Error("DER sequence length is too long");
  if (A[0] !== 48) throw new Error("Expected DER sequence");
  if (A[1] !== A.length - 2)
    throw new Error("DER sequence length is invalid");
  if (A[2] !== 2) throw new Error("Expected DER integer");
  const B = A[3];
  if (B === 0) throw new Error("R length is zero");
  if (5 + B >= A.length) throw new Error("R length is too long");
  if (A[4 + B] !== 2) throw new Error("Expected DER integer (2)");
  const L = A[5 + B];
  if (L === 0) throw new Error("S length is zero");
  if (6 + B + L !== A.length) throw new Error("S length is invalid");
  if (A[4] & 128) throw new Error("R value is negative");
  if (B > 1 && A[4] === 0 && !(A[5] & 128))
    throw new Error("R value excessively padded");
  if (A[B + 6] & 128) throw new Error("S value is negative");
  if (L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: A.slice(4, 4 + B),
    s: A.slice(6 + B)
  };
}
bip66.decode = decode$h;
function encode$i(A, B) {
  const L = A.length, K = B.length;
  if (L === 0) throw new Error("R length is zero");
  if (K === 0) throw new Error("S length is zero");
  if (L > 33) throw new Error("R length is too long");
  if (K > 33) throw new Error("S length is too long");
  if (A[0] & 128) throw new Error("R value is negative");
  if (B[0] & 128) throw new Error("S value is negative");
  if (L > 1 && A[0] === 0 && !(A[1] & 128))
    throw new Error("R value excessively padded");
  if (K > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("S value excessively padded");
  const J = Buffer$1.allocUnsafe(6 + L + K);
  return J[0] = 48, J[1] = J.length - 2, J[2] = 2, J[3] = A.length, A.copy(J, 4), J[4 + L] = 2, J[5 + L] = B.length, B.copy(J, 6 + L), J;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const A of Object.keys(OPS$7)) {
  const B = OPS$7[A];
  REVERSE_OPS[B] = A;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(A) {
  return A < ops_1.OPS.OP_PUSHDATA1 ? 1 : A <= 255 ? 2 : A <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(A, B, L) {
  const K = encodingLength$2(B);
  return K === 1 ? A.writeUInt8(B, L) : K === 2 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA1, L), A.writeUInt8(B, L + 1)) : K === 3 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA2, L), A.writeUInt16LE(B, L + 1)) : (A.writeUInt8(ops_1.OPS.OP_PUSHDATA4, L), A.writeUInt32LE(B, L + 1)), K;
}
push_data.encode = encode$h;
function decode$g(A, B) {
  const L = A.readUInt8(B);
  let K, J;
  if (L < ops_1.OPS.OP_PUSHDATA1)
    K = L, J = 1;
  else if (L === ops_1.OPS.OP_PUSHDATA1) {
    if (B + 2 > A.length) return null;
    K = A.readUInt8(B + 1), J = 2;
  } else if (L === ops_1.OPS.OP_PUSHDATA2) {
    if (B + 3 > A.length) return null;
    K = A.readUInt16LE(B + 1), J = 3;
  } else {
    if (B + 5 > A.length) return null;
    if (L !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    K = A.readUInt32LE(B + 1), J = 5;
  }
  return {
    opcode: L,
    number: K,
    size: J
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(A, B, L) {
  B = B || 4, L = L === void 0 ? !0 : L;
  const K = A.length;
  if (K === 0) return 0;
  if (K > B) throw new TypeError("Script number overflow");
  if (L && !(A[K - 1] & 127) && (K <= 1 || !(A[K - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (K === 5) {
    const W = A.readUInt32LE(0), V = A.readUInt8(4);
    return V & 128 ? -((V & -129) * 4294967296 + W) : V * 4294967296 + W;
  }
  let J = 0;
  for (let W = 0; W < K; ++W)
    J |= A[W] << 8 * W;
  return A[K - 1] & 128 ? -(J & ~(128 << 8 * (K - 1))) : J;
}
script_number.decode = decode$f;
function scriptNumSize(A) {
  return A > 2147483647 ? 5 : A > 8388607 ? 4 : A > 32767 ? 3 : A > 127 ? 2 : A > 0 ? 1 : 0;
}
function encode$g(A) {
  let B = Math.abs(A);
  const L = scriptNumSize(B), K = Buffer$1.allocUnsafe(L), J = A < 0;
  for (let W = 0; W < L; ++W)
    K.writeUInt8(B & 255, W), B >>= 8;
  return K[L - 1] & 128 ? K.writeUInt8(J ? 128 : 0, L - 1) : J && (K[L - 1] |= 128), K;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(A) {
    return A != null && A.constructor === Array;
  },
  Boolean: function(A) {
    return typeof A == "boolean";
  },
  Function: function(A) {
    return typeof A == "function";
  },
  Nil: function(A) {
    return A == null;
  },
  Number: function(A) {
    return typeof A == "number";
  },
  Object: function(A) {
    return typeof A == "object";
  },
  String: function(A) {
    return typeof A == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(A) {
    return A;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(A) {
  return A.name || A.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(A) {
  return native.Nil(A) ? "" : getTypeName(A.constructor);
}
function getValue(A) {
  return native.Function(A) ? "" : native.String(A) ? JSON.stringify(A) : A && native.Object(A) ? "" : A;
}
function captureStackTrace(A, B) {
  Error.captureStackTrace && Error.captureStackTrace(A, B);
}
function tfJSON$1(A) {
  return native.Function(A) ? A.toJSON ? A.toJSON() : getTypeName(A) : native.Array(A) ? "Array" : A && native.Object(A) ? "Object" : A !== void 0 ? A : "";
}
function tfErrorString(A, B, L) {
  var K = getValue(B);
  return "Expected " + tfJSON$1(A) + ", got" + (L !== "" ? " " + L : "") + (K !== "" ? " " + K : "");
}
function TfTypeError$1(A, B, L) {
  L = L || getValueTypeName$1(B), this.message = tfErrorString(A, B, L), captureStackTrace(this, TfTypeError$1), this.__type = A, this.__value = B, this.__valueTypeName = L;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(A, B, L, K, J) {
  var W = '" of type ';
  return B === "key" && (W = '" with key type '), tfErrorString('property "' + tfJSON$1(L) + W + tfJSON$1(A), K, J);
}
function TfPropertyTypeError$1(A, B, L, K, J) {
  A ? (J = J || getValueTypeName$1(K), this.message = tfPropertyErrorString(A, L, B, K, J)) : this.message = 'Unexpected property "' + B + '"', captureStackTrace(this, TfTypeError$1), this.__label = L, this.__property = B, this.__type = A, this.__value = K, this.__valueTypeName = J;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(A, B) {
  return new TfTypeError$1(A, {}, B);
}
function tfSubError$1(A, B, L) {
  return A instanceof TfPropertyTypeError$1 ? (B = B + "." + A.__property, A = new TfPropertyTypeError$1(
    A.__type,
    B,
    A.__label,
    A.__value,
    A.__valueTypeName
  )) : A instanceof TfTypeError$1 && (A = new TfPropertyTypeError$1(
    A.__type,
    B,
    L,
    A.__value,
    A.__valueTypeName
  )), captureStackTrace(A), A;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var A = native$1, B = errors;
  function L($t) {
    return Buffer$1.isBuffer($t);
  }
  function K($t) {
    return typeof $t == "string" && /^([0-9a-f]{2})+$/i.test($t);
  }
  function J($t, qt) {
    var At = $t.toJSON();
    function bt(xt) {
      if (!$t(xt)) return !1;
      if (xt.length === qt) return !0;
      throw B.tfCustomError(At + "(Length: " + qt + ")", At + "(Length: " + xt.length + ")");
    }
    return bt.toJSON = function() {
      return At;
    }, bt;
  }
  var W = J.bind(null, A.Array), V = J.bind(null, L), ne = J.bind(null, K), ie = J.bind(null, A.String);
  function oe($t, qt, At) {
    At = At || A.Number;
    function bt(xt, wt) {
      return At(xt, wt) && xt > $t && xt < qt;
    }
    return bt.toJSON = function() {
      return `${At.toJSON()} between [${$t}, ${qt}]`;
    }, bt;
  }
  var re = Math.pow(2, 53) - 1;
  function ce($t) {
    return typeof $t == "number" && isFinite($t);
  }
  function ke($t) {
    return $t << 24 >> 24 === $t;
  }
  function Ce($t) {
    return $t << 16 >> 16 === $t;
  }
  function it($t) {
    return ($t | 0) === $t;
  }
  function at($t) {
    return typeof $t == "number" && $t >= -re && $t <= re && Math.floor($t) === $t;
  }
  function lt($t) {
    return ($t & 255) === $t;
  }
  function ht($t) {
    return ($t & 65535) === $t;
  }
  function dt($t) {
    return $t >>> 0 === $t;
  }
  function vt($t) {
    return typeof $t == "number" && $t >= 0 && $t <= re && Math.floor($t) === $t;
  }
  var mt = {
    ArrayN: W,
    Buffer: L,
    BufferN: V,
    Finite: ce,
    Hex: K,
    HexN: ne,
    Int8: ke,
    Int16: Ce,
    Int32: it,
    Int53: at,
    Range: oe,
    StringN: ie,
    UInt8: lt,
    UInt16: ht,
    UInt32: dt,
    UInt53: vt
  };
  for (var Pt in mt)
    mt[Pt].toJSON = (function($t) {
      return $t;
    }).bind(null, Pt);
  return extra = mt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function A(B, L) {
    B = compile(B), L = L || {};
    function K(J, W) {
      return !NATIVE.Array(J) || NATIVE.Nil(J) || L.minLength !== void 0 && J.length < L.minLength || L.maxLength !== void 0 && J.length > L.maxLength || L.length !== void 0 && J.length !== L.length ? !1 : J.every(function(V, ne) {
        try {
          return typeforce$3(B, V, W);
        } catch (ie) {
          throw tfSubError(ie, ne);
        }
      });
    }
    return K.toJSON = function() {
      var J = "[" + tfJSON(B) + "]";
      return L.length !== void 0 ? J += "{" + L.length + "}" : (L.minLength !== void 0 || L.maxLength !== void 0) && (J += "{" + (L.minLength === void 0 ? 0 : L.minLength) + "," + (L.maxLength === void 0 ? 1 / 0 : L.maxLength) + "}"), J;
    }, K;
  },
  maybe: function A(B) {
    B = compile(B);
    function L(K, J) {
      return NATIVE.Nil(K) || B(K, J, A);
    }
    return L.toJSON = function() {
      return "?" + tfJSON(B);
    }, L;
  },
  map: function A(B, L) {
    B = compile(B), L && (L = compile(L));
    function K(J, W) {
      if (!NATIVE.Object(J) || NATIVE.Nil(J)) return !1;
      for (var V in J) {
        try {
          L && typeforce$3(L, V, W);
        } catch (ie) {
          throw tfSubError(ie, V, "key");
        }
        try {
          var ne = J[V];
          typeforce$3(B, ne, W);
        } catch (ie) {
          throw tfSubError(ie, V);
        }
      }
      return !0;
    }
    return L ? K.toJSON = function() {
      return "{" + tfJSON(L) + ": " + tfJSON(B) + "}";
    } : K.toJSON = function() {
      return "{" + tfJSON(B) + "}";
    }, K;
  },
  object: function A(B) {
    var L = {};
    for (var K in B)
      L[K] = compile(B[K]);
    function J(W, V) {
      if (!NATIVE.Object(W) || NATIVE.Nil(W)) return !1;
      var ne;
      try {
        for (ne in L) {
          var ie = L[ne], oe = W[ne];
          typeforce$3(ie, oe, V);
        }
      } catch (re) {
        throw tfSubError(re, ne);
      }
      if (V) {
        for (ne in W)
          if (!L[ne])
            throw new TfPropertyTypeError(void 0, ne);
      }
      return !0;
    }
    return J.toJSON = function() {
      return tfJSON(L);
    }, J;
  },
  anyOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, J) {
      return B.some(function(W) {
        try {
          return typeforce$3(W, K, J);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join("|");
    }, L;
  },
  allOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, J) {
      return B.every(function(W) {
        try {
          return typeforce$3(W, K, J);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join(" & ");
    }, L;
  },
  quacksLike: function A(B) {
    function L(K) {
      return B === getValueTypeName(K);
    }
    return L.toJSON = function() {
      return B;
    }, L;
  },
  tuple: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, J) {
      return NATIVE.Nil(K) || NATIVE.Nil(K.length) || J && K.length !== B.length ? !1 : B.every(function(W, V) {
        try {
          return typeforce$3(W, K[V], J);
        } catch (ne) {
          throw tfSubError(ne, V);
        }
      });
    }
    return L.toJSON = function() {
      return "(" + B.map(tfJSON).join(", ") + ")";
    }, L;
  },
  value: function A(B) {
    function L(K) {
      return K === B;
    }
    return L.toJSON = function() {
      return B;
    }, L;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(A) {
  if (NATIVE.String(A))
    return A[0] === "?" ? TYPES.maybe(A.slice(1)) : NATIVE[A] || TYPES.quacksLike(A);
  if (A && NATIVE.Object(A)) {
    if (NATIVE.Array(A)) {
      if (A.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(A[0]);
    }
    return TYPES.object(A);
  } else if (NATIVE.Function(A))
    return A;
  return TYPES.value(A);
}
function typeforce$3(A, B, L, K) {
  if (NATIVE.Function(A)) {
    if (A(B, L)) return !0;
    throw new TfTypeError(K || A, B);
  }
  return typeforce$3(compile(A), B, L);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.oneOf = A.Null = A.BufferN = A.Function = A.UInt32 = A.UInt8 = A.tuple = A.maybe = A.Hex = A.Buffer = A.String = A.Boolean = A.Array = A.Number = A.Hash256bit = A.Hash160bit = A.Buffer256bit = A.isTaptree = A.isTapleaf = A.TAPLEAF_VERSION_MASK = A.Satoshi = A.isPoint = A.stacksEqual = A.typeforce = void 0;
  const B = require$$0$1;
  A.typeforce = typeforce_1;
  const L = B.Buffer.alloc(32, 0), K = B.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function J(re, ce) {
    return re.length !== ce.length ? !1 : re.every((ke, Ce) => ke.equals(ce[Ce]));
  }
  A.stacksEqual = J;
  function W(re) {
    if (!B.Buffer.isBuffer(re) || re.length < 33) return !1;
    const ce = re[0], ke = re.slice(1, 33);
    if (ke.compare(L) === 0 || ke.compare(K) >= 0) return !1;
    if ((ce === 2 || ce === 3) && re.length === 33)
      return !0;
    const Ce = re.slice(33);
    return Ce.compare(L) === 0 || Ce.compare(K) >= 0 ? !1 : ce === 4 && re.length === 65;
  }
  A.isPoint = W;
  const V = 21 * 1e14;
  function ne(re) {
    return A.typeforce.UInt53(re) && re <= V;
  }
  A.Satoshi = ne, A.TAPLEAF_VERSION_MASK = 254;
  function ie(re) {
    return !re || !("output" in re) || !B.Buffer.isBuffer(re.output) ? !1 : re.version !== void 0 ? (re.version & A.TAPLEAF_VERSION_MASK) === re.version : !0;
  }
  A.isTapleaf = ie;
  function oe(re) {
    return (0, A.Array)(re) ? re.length !== 2 ? !1 : re.every((ce) => oe(ce)) : ie(re);
  }
  A.isTaptree = oe, A.Buffer256bit = A.typeforce.BufferN(32), A.Hash160bit = A.typeforce.BufferN(20), A.Hash256bit = A.typeforce.BufferN(32), A.Number = A.typeforce.Number, A.Array = A.typeforce.Array, A.Boolean = A.typeforce.Boolean, A.String = A.typeforce.String, A.Buffer = A.typeforce.Buffer, A.Hex = A.typeforce.Hex, A.maybe = A.typeforce.maybe, A.tuple = A.typeforce.tuple, A.UInt8 = A.typeforce.UInt8, A.UInt32 = A.typeforce.UInt32, A.Function = A.typeforce.Function, A.BufferN = A.typeforce.BufferN, A.Null = A.typeforce.Null, A.oneOf = A.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const A = bip66, B = requireScript(), L = types$4, { typeforce: K } = L, J = Buffer$1.alloc(1, 0);
  function W(oe) {
    let re = 0;
    for (; oe[re] === 0; ) ++re;
    return re === oe.length ? J : (oe = oe.slice(re), oe[0] & 128 ? Buffer$1.concat([J, oe], 1 + oe.length) : oe);
  }
  function V(oe) {
    oe[0] === 0 && (oe = oe.slice(1));
    const re = Buffer$1.alloc(32, 0), ce = Math.max(0, 32 - oe.length);
    return oe.copy(re, ce), re;
  }
  function ne(oe) {
    const re = oe.readUInt8(oe.length - 1);
    if (!(0, B.isDefinedHashType)(re))
      throw new Error("Invalid hashType " + re);
    const ce = A.decode(oe.slice(0, -1)), ke = V(ce.r), Ce = V(ce.s);
    return { signature: Buffer$1.concat([ke, Ce], 64), hashType: re };
  }
  script_signature.decode = ne;
  function ie(oe, re) {
    if (K(
      {
        signature: L.BufferN(64),
        hashType: L.UInt8
      },
      { signature: oe, hashType: re }
    ), !(0, B.isDefinedHashType)(re))
      throw new Error("Invalid hashType " + re);
    const ce = Buffer$1.allocUnsafe(1);
    ce.writeUInt8(re, 0);
    const ke = W(oe.slice(0, 32)), Ce = W(oe.slice(32, 64));
    return Buffer$1.concat([A.encode(ke, Ce), ce]);
  }
  return script_signature.encode = ie, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.signature = A.number = A.isCanonicalScriptSignature = A.isDefinedHashType = A.isCanonicalPubKey = A.toStack = A.fromASM = A.toASM = A.decompile = A.compile = A.countNonPushOnlyOPs = A.isPushOnly = A.OPS = void 0;
    const B = bip66, L = ops;
    Object.defineProperty(A, "OPS", {
      enumerable: !0,
      get: function() {
        return L.OPS;
      }
    });
    const K = push_data, J = script_number, W = requireScript_signature(), V = types$4, { typeforce: ne } = V, ie = L.OPS.OP_RESERVED;
    function oe(bt) {
      return V.Number(bt) && (bt === L.OPS.OP_0 || bt >= L.OPS.OP_1 && bt <= L.OPS.OP_16 || bt === L.OPS.OP_1NEGATE);
    }
    function re(bt) {
      return V.Buffer(bt) || oe(bt);
    }
    function ce(bt) {
      return V.Array(bt) && bt.every(re);
    }
    A.isPushOnly = ce;
    function ke(bt) {
      return bt.length - bt.filter(re).length;
    }
    A.countNonPushOnlyOPs = ke;
    function Ce(bt) {
      if (bt.length === 0) return L.OPS.OP_0;
      if (bt.length === 1) {
        if (bt[0] >= 1 && bt[0] <= 16) return ie + bt[0];
        if (bt[0] === 129) return L.OPS.OP_1NEGATE;
      }
    }
    function it(bt) {
      return Buffer$1.isBuffer(bt);
    }
    function at(bt) {
      return V.Array(bt);
    }
    function lt(bt) {
      return Buffer$1.isBuffer(bt);
    }
    function ht(bt) {
      if (it(bt)) return bt;
      ne(V.Array, bt);
      const xt = bt.reduce((rt, pe) => lt(pe) ? pe.length === 1 && Ce(pe) !== void 0 ? rt + 1 : rt + K.encodingLength(pe.length) + pe.length : rt + 1, 0), wt = Buffer$1.allocUnsafe(xt);
      let Oe = 0;
      if (bt.forEach((rt) => {
        if (lt(rt)) {
          const pe = Ce(rt);
          if (pe !== void 0) {
            wt.writeUInt8(pe, Oe), Oe += 1;
            return;
          }
          Oe += K.encode(wt, rt.length, Oe), rt.copy(wt, Oe), Oe += rt.length;
        } else
          wt.writeUInt8(rt, Oe), Oe += 1;
      }), Oe !== wt.length) throw new Error("Could not decode chunks");
      return wt;
    }
    A.compile = ht;
    function dt(bt) {
      if (at(bt)) return bt;
      ne(V.Buffer, bt);
      const xt = [];
      let wt = 0;
      for (; wt < bt.length; ) {
        const Oe = bt[wt];
        if (Oe > L.OPS.OP_0 && Oe <= L.OPS.OP_PUSHDATA4) {
          const rt = K.decode(bt, wt);
          if (rt === null || (wt += rt.size, wt + rt.number > bt.length)) return null;
          const pe = bt.slice(wt, wt + rt.number);
          wt += rt.number;
          const nt = Ce(pe);
          nt !== void 0 ? xt.push(nt) : xt.push(pe);
        } else
          xt.push(Oe), wt += 1;
      }
      return xt;
    }
    A.decompile = dt;
    function vt(bt) {
      if (it(bt) && (bt = dt(bt)), !bt)
        throw new Error("Could not convert invalid chunks to ASM");
      return bt.map((xt) => {
        if (lt(xt)) {
          const wt = Ce(xt);
          if (wt === void 0) return xt.toString("hex");
          xt = wt;
        }
        return L.REVERSE_OPS[xt];
      }).join(" ");
    }
    A.toASM = vt;
    function mt(bt) {
      return ne(V.String, bt), ht(
        bt.split(" ").map((xt) => L.OPS[xt] !== void 0 ? L.OPS[xt] : (ne(V.Hex, xt), Buffer$1.from(xt, "hex")))
      );
    }
    A.fromASM = mt;
    function Pt(bt) {
      return bt = dt(bt), ne(ce, bt), bt.map((xt) => lt(xt) ? xt : xt === L.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : J.encode(xt - ie));
    }
    A.toStack = Pt;
    function $t(bt) {
      return V.isPoint(bt);
    }
    A.isCanonicalPubKey = $t;
    function qt(bt) {
      const xt = bt & -129;
      return xt > 0 && xt < 4;
    }
    A.isDefinedHashType = qt;
    function At(bt) {
      return !Buffer$1.isBuffer(bt) || !qt(bt[bt.length - 1]) ? !1 : B.check(bt.slice(0, -1));
    }
    A.isCanonicalScriptSignature = At, A.number = J, A.signature = W;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(A, B, L) {
  Object.defineProperty(A, B, {
    configurable: !0,
    enumerable: !0,
    get() {
      const K = L.call(this);
      return this[B] = K, K;
    },
    set(K) {
      Object.defineProperty(this, B, {
        configurable: !0,
        enumerable: !0,
        value: K,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(A) {
  let B;
  return () => (B !== void 0 || (B = A()), B);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(A, B) {
  if (!A.data && !A.output) throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    A
  );
  const K = { name: "embed", network: A.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (A.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(A.data));
  }), lazy$6.prop(K, "data", () => {
    if (A.output)
      return bscript$9.decompile(A.output).slice(1);
  }), B.validate && A.output) {
    const J = bscript$9.decompile(A.output);
    if (J[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!J.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (A.data && !(0, types_1$7.stacksEqual)(A.data, K.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(K, A);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(A, B) {
  if (!A.input && !A.output && !(A.pubkeys && A.m !== void 0) && !A.signatures)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {});
  function L(ie) {
    return bscript$8.isCanonicalScriptSignature(ie) || (B.allowIncomplete && ie === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(L)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    A
  );
  const J = { network: A.network || networks_1$6.bitcoin };
  let W = [], V = !1;
  function ne(ie) {
    V || (V = !0, W = bscript$8.decompile(ie), J.m = W[0] - OP_INT_BASE, J.n = W[W.length - 2] - OP_INT_BASE, J.pubkeys = W.slice(1, -2));
  }
  if (lazy$5.prop(J, "output", () => {
    if (A.m && J.n && A.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + A.m,
          A.pubkeys,
          OP_INT_BASE + J.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(J, "m", () => {
    if (J.output)
      return ne(J.output), J.m;
  }), lazy$5.prop(J, "n", () => {
    if (J.pubkeys)
      return J.pubkeys.length;
  }), lazy$5.prop(J, "pubkeys", () => {
    if (A.output)
      return ne(A.output), J.pubkeys;
  }), lazy$5.prop(J, "signatures", () => {
    if (A.input)
      return bscript$8.decompile(A.input).slice(1);
  }), lazy$5.prop(J, "input", () => {
    if (A.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(A.signatures));
  }), lazy$5.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), lazy$5.prop(J, "name", () => {
    if (!(!J.m || !J.n))
      return `p2ms(${J.m} of ${J.n})`;
  }), B.validate) {
    if (A.output) {
      if (ne(A.output), !types_1$6.typeforce.Number(W[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(W[W.length - 2]))
        throw new TypeError("Output is invalid");
      if (W[W.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (J.m <= 0 || J.n > 16 || J.m > J.n || J.n !== W.length - 3)
        throw new TypeError("Output is invalid");
      if (!J.pubkeys.every((ie) => (0, types_1$6.isPoint)(ie)))
        throw new TypeError("Output is invalid");
      if (A.m !== void 0 && A.m !== J.m) throw new TypeError("m mismatch");
      if (A.n !== void 0 && A.n !== J.n) throw new TypeError("n mismatch");
      if (A.pubkeys && !(0, types_1$6.stacksEqual)(A.pubkeys, J.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (A.pubkeys) {
      if (A.n !== void 0 && A.n !== A.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (J.n = A.pubkeys.length, J.n < J.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (A.signatures) {
      if (A.signatures.length < J.m)
        throw new TypeError("Not enough signatures provided");
      if (A.signatures.length > J.m)
        throw new TypeError("Too many signatures provided");
    }
    if (A.input) {
      if (A.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (J.signatures.length === 0 || !J.signatures.every(L))
        throw new TypeError("Input has invalid signature(s)");
      if (A.signatures && !(0, types_1$6.stacksEqual)(A.signatures, J.signatures))
        throw new TypeError("Signature mismatch");
      if (A.m !== void 0 && A.m !== A.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(J, A);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(A, B) {
  if (!A.input && !A.output && !A.pubkey && !A.input && !A.signature)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    A
  );
  const L = lazy$4.value(() => bscript$7.decompile(A.input)), J = { name: "p2pk", network: A.network || networks_1$5.bitcoin };
  if (lazy$4.prop(J, "output", () => {
    if (A.pubkey)
      return bscript$7.compile([A.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(J, "pubkey", () => {
    if (A.output)
      return A.output.slice(1, -1);
  }), lazy$4.prop(J, "signature", () => {
    if (A.input)
      return L()[0];
  }), lazy$4.prop(J, "input", () => {
    if (A.signature)
      return bscript$7.compile([A.signature]);
  }), lazy$4.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), B.validate) {
    if (A.output) {
      if (A.output[A.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(J.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (A.pubkey && !A.pubkey.equals(J.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (A.signature && A.input && !A.input.equals(J.input))
      throw new TypeError("Signature mismatch");
    if (A.input) {
      if (L().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(J.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(J, A);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((A, B) => B)), Pi = /* @__PURE__ */ Id.map((A) => (9 * A + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let A = 0; A < 4; A++)
  for (let B of [idxL, idxR])
    B.push(B[A].map((L) => Rho[L]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((A) => new Uint8Array(A)), shiftsL = /* @__PURE__ */ idxL.map((A, B) => A.map((L) => shifts[B][L])), shiftsR = /* @__PURE__ */ idxR.map((A, B) => A.map((L) => shifts[B][L])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(A, B, L, K) {
  return A === 0 ? B ^ L ^ K : A === 1 ? B & L | ~B & K : A === 2 ? (B | ~L) ^ K : A === 3 ? B & K | L & ~K : B ^ (L | ~K);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: B, h1: L, h2: K, h3: J, h4: W } = this;
    return [B, L, K, J, W];
  }
  set(B, L, K, J, W) {
    this.h0 = B | 0, this.h1 = L | 0, this.h2 = K | 0, this.h3 = J | 0, this.h4 = W | 0;
  }
  process(B, L) {
    for (let Ce = 0; Ce < 16; Ce++, L += 4)
      R_BUF[Ce] = B.getUint32(L, !0);
    let K = this.h0 | 0, J = K, W = this.h1 | 0, V = W, ne = this.h2 | 0, ie = ne, oe = this.h3 | 0, re = oe, ce = this.h4 | 0, ke = ce;
    for (let Ce = 0; Ce < 5; Ce++) {
      const it = 4 - Ce, at = Kl[Ce], lt = Kr[Ce], ht = idxL[Ce], dt = idxR[Ce], vt = shiftsL[Ce], mt = shiftsR[Ce];
      for (let Pt = 0; Pt < 16; Pt++) {
        const $t = (0, utils_js_1$1.rotl)(K + f(Ce, W, ne, oe) + R_BUF[ht[Pt]] + at, vt[Pt]) + ce | 0;
        K = ce, ce = oe, oe = (0, utils_js_1$1.rotl)(ne, 10) | 0, ne = W, W = $t;
      }
      for (let Pt = 0; Pt < 16; Pt++) {
        const $t = (0, utils_js_1$1.rotl)(J + f(it, V, ie, re) + R_BUF[dt[Pt]] + lt, mt[Pt]) + ke | 0;
        J = ke, ke = re, re = (0, utils_js_1$1.rotl)(ie, 10) | 0, ie = V, V = $t;
      }
    }
    this.set(this.h1 + ne + re | 0, this.h2 + oe + ke | 0, this.h3 + ce + J | 0, this.h4 + K + V | 0, this.h0 + W + ie | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: J, E: W } = this;
    return [B, L, K, J, W];
  }
  set(B, L, K, J, W) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = J | 0, this.E = W | 0;
  }
  process(B, L) {
    for (let ie = 0; ie < 16; ie++, L += 4)
      SHA1_W[ie] = B.getUint32(L, !1);
    for (let ie = 16; ie < 80; ie++)
      SHA1_W[ie] = (0, utils_js_1.rotl)(SHA1_W[ie - 3] ^ SHA1_W[ie - 8] ^ SHA1_W[ie - 14] ^ SHA1_W[ie - 16], 1);
    let { A: K, B: J, C: W, D: V, E: ne } = this;
    for (let ie = 0; ie < 80; ie++) {
      let oe, re;
      ie < 20 ? (oe = (0, _md_js_1.Chi)(J, W, V), re = 1518500249) : ie < 40 ? (oe = J ^ W ^ V, re = 1859775393) : ie < 60 ? (oe = (0, _md_js_1.Maj)(J, W, V), re = 2400959708) : (oe = J ^ W ^ V, re = 3395469782);
      const ce = (0, utils_js_1.rotl)(K, 5) + oe + ne + re + SHA1_W[ie] | 0;
      ne = V, V = W, W = (0, utils_js_1.rotl)(J, 30), J = K, K = ce;
    }
    K = K + this.A | 0, J = J + this.B | 0, W = W + this.C | 0, V = V + this.D | 0, ne = ne + this.E | 0, this.set(K, J, W, V, ne);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.taggedHash = A.TAGGED_HASH_PREFIXES = A.TAGS = A.hash256 = A.hash160 = A.sha256 = A.sha1 = A.ripemd160 = void 0;
  const B = ripemd160, L = sha1, K = sha256$4;
  function J(re) {
    return Buffer$1.from((0, B.ripemd160)(Uint8Array.from(re)));
  }
  A.ripemd160 = J;
  function W(re) {
    return Buffer$1.from((0, L.sha1)(Uint8Array.from(re)));
  }
  A.sha1 = W;
  function V(re) {
    return Buffer$1.from((0, K.sha256)(Uint8Array.from(re)));
  }
  A.sha256 = V;
  function ne(re) {
    return Buffer$1.from(
      (0, B.ripemd160)((0, K.sha256)(Uint8Array.from(re)))
    );
  }
  A.hash160 = ne;
  function ie(re) {
    return Buffer$1.from(
      (0, K.sha256)((0, K.sha256)(Uint8Array.from(re)))
    );
  }
  A.hash256 = ie, A.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], A.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function oe(re, ce) {
    return V(Buffer$1.concat([A.TAGGED_HASH_PREFIXES[re], ce]));
  }
  A.taggedHash = oe;
})(crypto$1);
function base$1(A) {
  if (A.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var B = new Uint8Array(256), L = 0; L < B.length; L++)
    B[L] = 255;
  for (var K = 0; K < A.length; K++) {
    var J = A.charAt(K), W = J.charCodeAt(0);
    if (B[W] !== 255)
      throw new TypeError(J + " is ambiguous");
    B[W] = K;
  }
  var V = A.length, ne = A.charAt(0), ie = Math.log(V) / Math.log(256), oe = Math.log(256) / Math.log(V);
  function re(Ce) {
    if (Ce instanceof Uint8Array || (ArrayBuffer.isView(Ce) ? Ce = new Uint8Array(Ce.buffer, Ce.byteOffset, Ce.byteLength) : Array.isArray(Ce) && (Ce = Uint8Array.from(Ce))), !(Ce instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ce.length === 0)
      return "";
    for (var it = 0, at = 0, lt = 0, ht = Ce.length; lt !== ht && Ce[lt] === 0; )
      lt++, it++;
    for (var dt = (ht - lt) * oe + 1 >>> 0, vt = new Uint8Array(dt); lt !== ht; ) {
      for (var mt = Ce[lt], Pt = 0, $t = dt - 1; (mt !== 0 || Pt < at) && $t !== -1; $t--, Pt++)
        mt += 256 * vt[$t] >>> 0, vt[$t] = mt % V >>> 0, mt = mt / V >>> 0;
      if (mt !== 0)
        throw new Error("Non-zero carry");
      at = Pt, lt++;
    }
    for (var qt = dt - at; qt !== dt && vt[qt] === 0; )
      qt++;
    for (var At = ne.repeat(it); qt < dt; ++qt)
      At += A.charAt(vt[qt]);
    return At;
  }
  function ce(Ce) {
    if (typeof Ce != "string")
      throw new TypeError("Expected String");
    if (Ce.length === 0)
      return new Uint8Array();
    for (var it = 0, at = 0, lt = 0; Ce[it] === ne; )
      at++, it++;
    for (var ht = (Ce.length - it) * ie + 1 >>> 0, dt = new Uint8Array(ht); Ce[it]; ) {
      var vt = B[Ce.charCodeAt(it)];
      if (vt === 255)
        return;
      for (var mt = 0, Pt = ht - 1; (vt !== 0 || mt < lt) && Pt !== -1; Pt--, mt++)
        vt += V * dt[Pt] >>> 0, dt[Pt] = vt % 256 >>> 0, vt = vt / 256 >>> 0;
      if (vt !== 0)
        throw new Error("Non-zero carry");
      lt = mt, it++;
    }
    for (var $t = ht - lt; $t !== ht && dt[$t] === 0; )
      $t++;
    for (var qt = new Uint8Array(at + (ht - $t)), At = at; $t !== ht; )
      qt[At++] = dt[$t++];
    return qt;
  }
  function ke(Ce) {
    var it = ce(Ce);
    if (it)
      return it;
    throw new Error("Non-base" + V + " character");
  }
  return {
    encode: re,
    decodeUnsafe: ce,
    decode: ke
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(A) {
  function B(W) {
    var V = Uint8Array.from(W), ne = A(V), ie = V.length + 4, oe = new Uint8Array(ie);
    return oe.set(V, 0), oe.set(ne.subarray(0, 4), V.length), base58.encode(oe, ie);
  }
  function L(W) {
    var V = W.slice(0, -4), ne = W.slice(-4), ie = A(V);
    if (!(ne[0] ^ ie[0] | ne[1] ^ ie[1] | ne[2] ^ ie[2] | ne[3] ^ ie[3]))
      return V;
  }
  function K(W) {
    var V = base58.decodeUnsafe(W);
    if (V)
      return L(V);
  }
  function J(W) {
    var V = base58.decode(W), ne = L(V);
    if (!ne) throw new Error("Invalid checksum");
    return ne;
  }
  return {
    encode: B,
    decode: J,
    decodeUnsafe: K
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(A) {
  return sha256(sha256(A));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    A
  );
  const L = lazy$3.value(() => {
    const V = Buffer$1.from(bs58check$1.decode(A.address)), ne = V.readUInt8(0), ie = V.slice(1);
    return { version: ne, hash: ie };
  }), K = lazy$3.value(() => bscript$6.decompile(A.input)), J = A.network || networks_1$4.bitcoin, W = { name: "p2pkh", network: J };
  if (lazy$3.prop(W, "address", () => {
    if (!W.hash) return;
    const V = Buffer$1.allocUnsafe(21);
    return V.writeUInt8(J.pubKeyHash, 0), W.hash.copy(V, 1), bs58check$1.encode(V);
  }), lazy$3.prop(W, "hash", () => {
    if (A.output) return A.output.slice(3, 23);
    if (A.address) return L().hash;
    if (A.pubkey || W.pubkey) return bcrypto$5.hash160(A.pubkey || W.pubkey);
  }), lazy$3.prop(W, "output", () => {
    if (W.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        W.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(W, "pubkey", () => {
    if (A.input)
      return K()[1];
  }), lazy$3.prop(W, "signature", () => {
    if (A.input)
      return K()[0];
  }), lazy$3.prop(W, "input", () => {
    if (A.pubkey && A.signature)
      return bscript$6.compile([A.signature, A.pubkey]);
  }), lazy$3.prop(W, "witness", () => {
    if (W.input)
      return [];
  }), B.validate) {
    let V = Buffer$1.from([]);
    if (A.address) {
      if (L().version !== J.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (L().hash.length !== 20) throw new TypeError("Invalid address");
      V = L().hash;
    }
    if (A.hash) {
      if (V.length > 0 && !V.equals(A.hash))
        throw new TypeError("Hash mismatch");
      V = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 25 || A.output[0] !== OPS$3.OP_DUP || A.output[1] !== OPS$3.OP_HASH160 || A.output[2] !== 20 || A.output[23] !== OPS$3.OP_EQUALVERIFY || A.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(3, 23);
      if (V.length > 0 && !V.equals(ne))
        throw new TypeError("Hash mismatch");
      V = ne;
    }
    if (A.pubkey) {
      const ne = bcrypto$5.hash160(A.pubkey);
      if (V.length > 0 && !V.equals(ne))
        throw new TypeError("Hash mismatch");
      V = ne;
    }
    if (A.input) {
      const ne = K();
      if (ne.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ne[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ne[1]))
        throw new TypeError("Input has invalid pubkey");
      if (A.signature && !A.signature.equals(ne[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(ne[1]))
        throw new TypeError("Pubkey mismatch");
      const ie = bcrypto$5.hash160(ne[1]);
      if (V.length > 0 && !V.equals(ie))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(W, A);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    A
  );
  let L = A.network;
  L || (L = A.redeem && A.redeem.network || networks_1$3.bitcoin);
  const K = { network: L }, J = lazy$2.value(() => {
    const ne = Buffer$1.from(bs58check.decode(A.address)), ie = ne.readUInt8(0), oe = ne.slice(1);
    return { version: ie, hash: oe };
  }), W = lazy$2.value(() => bscript$5.decompile(A.input)), V = lazy$2.value(() => {
    const ne = W(), ie = ne[ne.length - 1];
    return {
      network: L,
      output: ie === OPS$2.OP_FALSE ? Buffer$1.from([]) : ie,
      input: bscript$5.compile(ne.slice(0, -1)),
      witness: A.witness || []
    };
  });
  if (lazy$2.prop(K, "address", () => {
    if (!K.hash) return;
    const ne = Buffer$1.allocUnsafe(21);
    return ne.writeUInt8(K.network.scriptHash, 0), K.hash.copy(ne, 1), bs58check.encode(ne);
  }), lazy$2.prop(K, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return J().hash;
    if (K.redeem && K.redeem.output) return bcrypto$4.hash160(K.redeem.output);
  }), lazy$2.prop(K, "output", () => {
    if (K.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, K.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(K, "redeem", () => {
    if (A.input)
      return V();
  }), lazy$2.prop(K, "input", () => {
    if (!(!A.redeem || !A.redeem.input || !A.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(A.redeem.input), A.redeem.output)
      );
  }), lazy$2.prop(K, "witness", () => {
    if (K.redeem && K.redeem.witness) return K.redeem.witness;
    if (K.input) return [];
  }), lazy$2.prop(K, "name", () => {
    const ne = ["p2sh"];
    return K.redeem !== void 0 && K.redeem.name !== void 0 && ne.push(K.redeem.name), ne.join("-");
  }), B.validate) {
    let ne = Buffer$1.from([]);
    if (A.address) {
      if (J().version !== L.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (J().hash.length !== 20) throw new TypeError("Invalid address");
      ne = J().hash;
    }
    if (A.hash) {
      if (ne.length > 0 && !ne.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ne = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 23 || A.output[0] !== OPS$2.OP_HASH160 || A.output[1] !== 20 || A.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const oe = A.output.slice(2, 22);
      if (ne.length > 0 && !ne.equals(oe))
        throw new TypeError("Hash mismatch");
      ne = oe;
    }
    const ie = (oe) => {
      if (oe.output) {
        const re = bscript$5.decompile(oe.output);
        if (!re || re.length < 1)
          throw new TypeError("Redeem.output too short");
        if (oe.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(re) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ce = bcrypto$4.hash160(oe.output);
        if (ne.length > 0 && !ne.equals(ce))
          throw new TypeError("Hash mismatch");
        ne = ce;
      }
      if (oe.input) {
        const re = oe.input.length > 0, ce = oe.witness && oe.witness.length > 0;
        if (!re && !ce) throw new TypeError("Empty input");
        if (re && ce)
          throw new TypeError("Input and witness provided");
        if (re) {
          const ke = bscript$5.decompile(oe.input);
          if (!bscript$5.isPushOnly(ke))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (A.input) {
      const oe = W();
      if (!oe || oe.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(V().output))
        throw new TypeError("Input is invalid");
      ie(V());
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== L)
        throw new TypeError("Network mismatch");
      if (A.input) {
        const oe = V();
        if (A.redeem.output && !A.redeem.output.equals(oe.output))
          throw new TypeError("Redeem.output mismatch");
        if (A.redeem.input && !A.redeem.input.equals(oe.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ie(A.redeem);
    }
    if (A.witness && A.redeem && A.redeem.witness && !(0, types_1$3.stacksEqual)(A.redeem.witness, A.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(K, A);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let A = 0; A < ALPHABET.length; A++) {
  const B = ALPHABET.charAt(A);
  ALPHABET_MAP[B] = A;
}
function polymodStep(A) {
  const B = A >> 25;
  return (A & 33554431) << 5 ^ -(B >> 0 & 1) & 996825010 ^ -(B >> 1 & 1) & 642813549 ^ -(B >> 2 & 1) & 513874426 ^ -(B >> 3 & 1) & 1027748829 ^ -(B >> 4 & 1) & 705979059;
}
function prefixChk(A) {
  let B = 1;
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    if (K < 33 || K > 126)
      return "Invalid prefix (" + A + ")";
    B = polymodStep(B) ^ K >> 5;
  }
  B = polymodStep(B);
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    B = polymodStep(B) ^ K & 31;
  }
  return B;
}
function convert$2(A, B, L, K) {
  let J = 0, W = 0;
  const V = (1 << L) - 1, ne = [];
  for (let ie = 0; ie < A.length; ++ie)
    for (J = J << B | A[ie], W += B; W >= L; )
      W -= L, ne.push(J >> W & V);
  if (K)
    W > 0 && ne.push(J << L - W & V);
  else {
    if (W >= B)
      return "Excess padding";
    if (J << L - W & V)
      return "Non-zero padding";
  }
  return ne;
}
function toWords(A) {
  return convert$2(A, 8, 5, !0);
}
function fromWordsUnsafe(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
}
function fromWords(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
  throw new Error(B);
}
function getLibraryFromEncoding(A) {
  let B;
  A === "bech32" ? B = 1 : B = 734539939;
  function L(V, ne, ie) {
    if (ie = ie || 90, V.length + 7 + ne.length > ie)
      throw new TypeError("Exceeds length limit");
    V = V.toLowerCase();
    let oe = prefixChk(V);
    if (typeof oe == "string")
      throw new Error(oe);
    let re = V + "1";
    for (let ce = 0; ce < ne.length; ++ce) {
      const ke = ne[ce];
      if (ke >> 5)
        throw new Error("Non 5-bit word");
      oe = polymodStep(oe) ^ ke, re += ALPHABET.charAt(ke);
    }
    for (let ce = 0; ce < 6; ++ce)
      oe = polymodStep(oe);
    oe ^= B;
    for (let ce = 0; ce < 6; ++ce) {
      const ke = oe >> (5 - ce) * 5 & 31;
      re += ALPHABET.charAt(ke);
    }
    return re;
  }
  function K(V, ne) {
    if (ne = ne || 90, V.length < 8)
      return V + " too short";
    if (V.length > ne)
      return "Exceeds length limit";
    const ie = V.toLowerCase(), oe = V.toUpperCase();
    if (V !== ie && V !== oe)
      return "Mixed-case string " + V;
    V = ie;
    const re = V.lastIndexOf("1");
    if (re === -1)
      return "No separator character for " + V;
    if (re === 0)
      return "Missing prefix for " + V;
    const ce = V.slice(0, re), ke = V.slice(re + 1);
    if (ke.length < 6)
      return "Data too short";
    let Ce = prefixChk(ce);
    if (typeof Ce == "string")
      return Ce;
    const it = [];
    for (let at = 0; at < ke.length; ++at) {
      const lt = ke.charAt(at), ht = ALPHABET_MAP[lt];
      if (ht === void 0)
        return "Unknown character " + lt;
      Ce = polymodStep(Ce) ^ ht, !(at + 6 >= ke.length) && it.push(ht);
    }
    return Ce !== B ? "Invalid checksum for " + V : { prefix: ce, words: it };
  }
  function J(V, ne) {
    const ie = K(V, ne);
    if (typeof ie == "object")
      return ie;
  }
  function W(V, ne) {
    const ie = K(V, ne);
    if (typeof ie == "object")
      return ie;
    throw new Error(ie);
  }
  return {
    decodeUnsafe: J,
    decode: W,
    encode: L,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy$1.value(() => {
    const W = bech32_1$1.bech32.decode(A.address), V = W.words.shift(), ne = bech32_1$1.bech32.fromWords(W.words);
    return {
      version: V,
      prefix: W.prefix,
      data: Buffer$1.from(ne)
    };
  }), K = A.network || networks_1$2.bitcoin, J = { name: "p2wpkh", network: K };
  if (lazy$1.prop(J, "address", () => {
    if (!J.hash) return;
    const W = bech32_1$1.bech32.toWords(J.hash);
    return W.unshift(0), bech32_1$1.bech32.encode(K.bech32, W);
  }), lazy$1.prop(J, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return L().data;
    if (A.pubkey || J.pubkey) return bcrypto$3.hash160(A.pubkey || J.pubkey);
  }), lazy$1.prop(J, "output", () => {
    if (J.hash)
      return bscript$4.compile([OPS$1.OP_0, J.hash]);
  }), lazy$1.prop(J, "pubkey", () => {
    if (A.pubkey) return A.pubkey;
    if (A.witness)
      return A.witness[1];
  }), lazy$1.prop(J, "signature", () => {
    if (A.witness)
      return A.witness[0];
  }), lazy$1.prop(J, "input", () => {
    if (J.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(J, "witness", () => {
    if (A.pubkey && A.signature)
      return [A.signature, A.pubkey];
  }), B.validate) {
    let W = Buffer$1.from([]);
    if (A.address) {
      if (K && K.bech32 !== L().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 20)
        throw new TypeError("Invalid address data");
      W = L().data;
    }
    if (A.hash) {
      if (W.length > 0 && !W.equals(A.hash))
        throw new TypeError("Hash mismatch");
      W = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 22 || A.output[0] !== OPS$1.OP_0 || A.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (W.length > 0 && !W.equals(A.output.slice(2)))
        throw new TypeError("Hash mismatch");
      W = A.output.slice(2);
    }
    if (A.pubkey) {
      const V = bcrypto$3.hash160(A.pubkey);
      if (W.length > 0 && !W.equals(V))
        throw new TypeError("Hash mismatch");
      if (W = V, !(0, types_1$2.isPoint)(A.pubkey) || A.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (A.witness) {
      if (A.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(A.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(A.witness[1]) || A.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (A.signature && !A.signature.equals(A.witness[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(A.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const V = bcrypto$3.hash160(A.witness[1]);
      if (W.length > 0 && !W.equals(V))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(J, A);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(A) {
  return !!(Buffer$1.isBuffer(A) && A.length === 65 && A[0] === 4 && (0, types_1$1.isPoint)(A));
}
function p2wsh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy.value(() => {
    const V = bech32_1.bech32.decode(A.address), ne = V.words.shift(), ie = bech32_1.bech32.fromWords(V.words);
    return {
      version: ne,
      prefix: V.prefix,
      data: Buffer$1.from(ie)
    };
  }), K = lazy.value(() => bscript$3.decompile(A.redeem.input));
  let J = A.network;
  J || (J = A.redeem && A.redeem.network || networks_1$1.bitcoin);
  const W = { network: J };
  if (lazy.prop(W, "address", () => {
    if (!W.hash) return;
    const V = bech32_1.bech32.toWords(W.hash);
    return V.unshift(0), bech32_1.bech32.encode(J.bech32, V);
  }), lazy.prop(W, "hash", () => {
    if (A.output) return A.output.slice(2);
    if (A.address) return L().data;
    if (W.redeem && W.redeem.output) return bcrypto$2.sha256(W.redeem.output);
  }), lazy.prop(W, "output", () => {
    if (W.hash)
      return bscript$3.compile([OPS.OP_0, W.hash]);
  }), lazy.prop(W, "redeem", () => {
    if (A.witness)
      return {
        output: A.witness[A.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: A.witness.slice(0, -1)
      };
  }), lazy.prop(W, "input", () => {
    if (W.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(W, "witness", () => {
    if (A.redeem && A.redeem.input && A.redeem.input.length > 0 && A.redeem.output && A.redeem.output.length > 0) {
      const V = bscript$3.toStack(K());
      return W.redeem = Object.assign({ witness: V }, A.redeem), W.redeem.input = EMPTY_BUFFER$1, [].concat(V, A.redeem.output);
    }
    if (A.redeem && A.redeem.output && A.redeem.witness)
      return [].concat(A.redeem.witness, A.redeem.output);
  }), lazy.prop(W, "name", () => {
    const V = ["p2wsh"];
    return W.redeem !== void 0 && W.redeem.name !== void 0 && V.push(W.redeem.name), V.join("-");
  }), B.validate) {
    let V = Buffer$1.from([]);
    if (A.address) {
      if (L().prefix !== J.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 32)
        throw new TypeError("Invalid address data");
      V = L().data;
    }
    if (A.hash) {
      if (V.length > 0 && !V.equals(A.hash))
        throw new TypeError("Hash mismatch");
      V = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 34 || A.output[0] !== OPS.OP_0 || A.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(2);
      if (V.length > 0 && !V.equals(ne))
        throw new TypeError("Hash mismatch");
      V = ne;
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== J)
        throw new TypeError("Network mismatch");
      if (A.redeem.input && A.redeem.input.length > 0 && A.redeem.witness && A.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (A.redeem.output) {
        const ne = bscript$3.decompile(A.redeem.output);
        if (!ne || ne.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (A.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ne) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ie = bcrypto$2.sha256(A.redeem.output);
        if (V.length > 0 && !V.equals(ie))
          throw new TypeError("Hash mismatch");
        V = ie;
      }
      if (A.redeem.input && !bscript$3.isPushOnly(K()))
        throw new TypeError("Non push-only scriptSig");
      if (A.witness && A.redeem.witness && !(0, types_1$1.stacksEqual)(A.witness, A.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (A.redeem.input && K().some(chunkHasUncompressedPubkey) || A.redeem.output && (bscript$3.decompile(A.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (A.witness && A.witness.length > 0) {
      const ne = A.witness[A.witness.length - 1];
      if (A.redeem && A.redeem.output && !A.redeem.output.equals(ne))
        throw new TypeError("Witness and redeem.output mismatch");
      if (A.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ne) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(W, A);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(A) {
  A ? A !== _ECCLIB_CACHE.eccLib && (verifyEcc(A), _ECCLIB_CACHE.eccLib = A) : _ECCLIB_CACHE.eccLib = A;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (A) => Buffer$1.from(A, "hex");
function verifyEcc(A) {
  assert(typeof A.isXOnlyPoint == "function"), assert(
    A.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    A.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof A.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((B) => {
    const L = A.xOnlyPointAddTweak(h(B.pubkey), h(B.tweak));
    B.result === null ? assert(L === null) : (assert(L !== null), assert(L.parity === B.parity), assert(Buffer$1.from(L.xOnlyPubkey).equals(h(B.result))));
  });
}
function assert(A) {
  if (!A) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER$1 || A % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(A, B, L) {
  if (checkUInt53$1(A), B || (B = Buffer.allocUnsafe(encodingLength$1(A))), !Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), encode$f.bytes = 1) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), encode$f.bytes = 3) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), encode$f.bytes = 5) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), encode$f.bytes = 9), B;
}
function decode$e(A, B) {
  if (!Buffer.isBuffer(A)) throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  var L = A.readUInt8(B);
  if (L < 253)
    return decode$e.bytes = 1, L;
  if (L === 253)
    return decode$e.bytes = 3, A.readUInt16LE(B + 1);
  if (L === 254)
    return decode$e.bytes = 5, A.readUInt32LE(B + 1);
  decode$e.bytes = 9;
  var K = A.readUInt32LE(B + 1), J = A.readUInt32LE(B + 5), W = J * 4294967296 + K;
  return checkUInt53$1(W), W;
}
function encodingLength$1(A) {
  return checkUInt53$1(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint$1(K + L, 9007199254740991), K + L;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(A, B, L) {
  return verifuint$1(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(A) {
  const B = Buffer$1.allocUnsafe(A.length);
  return A.copy(B), B;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(B) {
    return new BufferWriter(Buffer$1.alloc(B));
  }
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  writeUInt8(B) {
    this.offset = this.buffer.writeUInt8(B, this.offset);
  }
  writeInt32(B) {
    this.offset = this.buffer.writeInt32LE(B, this.offset);
  }
  writeUInt32(B) {
    this.offset = this.buffer.writeUInt32LE(B, this.offset);
  }
  writeUInt64(B) {
    this.offset = writeUInt64LE$1(this.buffer, B, this.offset);
  }
  writeVarInt(B) {
    varuint$7.encode(B, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(B) {
    if (this.buffer.length < this.offset + B.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += B.copy(this.buffer, this.offset);
  }
  writeVarSlice(B) {
    this.writeVarInt(B.length), this.writeSlice(B);
  }
  writeVector(B) {
    this.writeVarInt(B.length), B.forEach((L) => this.writeVarSlice(L));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  readUInt8() {
    const B = this.buffer.readUInt8(this.offset);
    return this.offset++, B;
  }
  readInt32() {
    const B = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt32() {
    const B = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt64() {
    const B = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, B;
  }
  readVarInt() {
    const B = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, B;
  }
  readSlice(B) {
    if (this.buffer.length < this.offset + B)
      throw new Error("Cannot read slice out of bounds");
    const L = this.buffer.slice(this.offset, this.offset + B);
    return this.offset += B, L;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const B = this.readVarInt(), L = [];
    for (let K = 0; K < B; K++) L.push(this.readVarSlice());
    return L;
  }
}
bufferutils.BufferReader = BufferReader;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.tweakKey = A.tapTweakHash = A.tapleafHash = A.findScriptPath = A.toHashTree = A.rootHashFromPath = A.MAX_TAPTREE_DEPTH = A.LEAF_VERSION_TAPSCRIPT = void 0;
  const B = require$$0$1, L = ecc_lib, K = crypto$1, J = bufferutils, W = types$4;
  A.LEAF_VERSION_TAPSCRIPT = 192, A.MAX_TAPTREE_DEPTH = 128;
  const V = (at) => "left" in at && "right" in at;
  function ne(at, lt) {
    if (at.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${at.length}, expected min 33.`
      );
    const ht = (at.length - 33) / 32;
    let dt = lt;
    for (let vt = 0; vt < ht; vt++) {
      const mt = at.slice(33 + 32 * vt, 65 + 32 * vt);
      dt.compare(mt) < 0 ? dt = Ce(dt, mt) : dt = Ce(mt, dt);
    }
    return dt;
  }
  A.rootHashFromPath = ne;
  function ie(at) {
    if ((0, W.isTapleaf)(at))
      return { hash: re(at) };
    const lt = [ie(at[0]), ie(at[1])];
    lt.sort((vt, mt) => vt.hash.compare(mt.hash));
    const [ht, dt] = lt;
    return {
      hash: Ce(ht.hash, dt.hash),
      left: ht,
      right: dt
    };
  }
  A.toHashTree = ie;
  function oe(at, lt) {
    if (V(at)) {
      const ht = oe(at.left, lt);
      if (ht !== void 0) return [...ht, at.right.hash];
      const dt = oe(at.right, lt);
      if (dt !== void 0) return [...dt, at.left.hash];
    } else if (at.hash.equals(lt))
      return [];
  }
  A.findScriptPath = oe;
  function re(at) {
    const lt = at.version || A.LEAF_VERSION_TAPSCRIPT;
    return K.taggedHash(
      "TapLeaf",
      B.Buffer.concat([
        B.Buffer.from([lt]),
        it(at.output)
      ])
    );
  }
  A.tapleafHash = re;
  function ce(at, lt) {
    return K.taggedHash(
      "TapTweak",
      B.Buffer.concat(lt ? [at, lt] : [at])
    );
  }
  A.tapTweakHash = ce;
  function ke(at, lt) {
    if (!B.Buffer.isBuffer(at) || at.length !== 32 || lt && lt.length !== 32) return null;
    const ht = ce(at, lt), dt = (0, L.getEccLib)().xOnlyPointAddTweak(at, ht);
    return !dt || dt.xOnlyPubkey === null ? null : {
      parity: dt.parity,
      x: B.Buffer.from(dt.xOnlyPubkey)
    };
  }
  A.tweakKey = ke;
  function Ce(at, lt) {
    return K.taggedHash("TapBranch", B.Buffer.concat([at, lt]));
  }
  function it(at) {
    const lt = J.varuint.encodingLength(at.length), ht = B.Buffer.allocUnsafe(lt);
    return J.varuint.encode(at.length, ht), B.Buffer.concat([ht, at]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const A = require$$0$1, B = networks, L = requireScript(), K = types$4, J = ecc_lib, W = bip341, V = lazy$7, ne = dist, ie = requireAddress(), oe = L.OPS, re = 1, ce = 80;
  function ke(Ce, it) {
    if (!Ce.address && !Ce.output && !Ce.pubkey && !Ce.internalPubkey && !(Ce.witness && Ce.witness.length > 1))
      throw new TypeError("Not enough data");
    it = Object.assign({ validate: !0 }, it || {}), (0, K.typeforce)(
      {
        address: K.typeforce.maybe(K.typeforce.String),
        input: K.typeforce.maybe(K.typeforce.BufferN(0)),
        network: K.typeforce.maybe(K.typeforce.Object),
        output: K.typeforce.maybe(K.typeforce.BufferN(34)),
        internalPubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        hash: K.typeforce.maybe(K.typeforce.BufferN(32)),
        pubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        signature: K.typeforce.maybe(
          K.typeforce.anyOf(
            K.typeforce.BufferN(64),
            K.typeforce.BufferN(65)
          )
        ),
        witness: K.typeforce.maybe(
          K.typeforce.arrayOf(K.typeforce.Buffer)
        ),
        scriptTree: K.typeforce.maybe(K.isTaptree),
        redeem: K.typeforce.maybe({
          output: K.typeforce.maybe(K.typeforce.Buffer),
          redeemVersion: K.typeforce.maybe(K.typeforce.Number),
          witness: K.typeforce.maybe(
            K.typeforce.arrayOf(K.typeforce.Buffer)
          )
        }),
        redeemVersion: K.typeforce.maybe(K.typeforce.Number)
      },
      Ce
    );
    const at = V.value(() => (0, ie.fromBech32)(Ce.address)), lt = V.value(() => {
      if (!(!Ce.witness || !Ce.witness.length))
        return Ce.witness.length >= 2 && Ce.witness[Ce.witness.length - 1][0] === ce ? Ce.witness.slice(0, -1) : Ce.witness.slice();
    }), ht = V.value(() => {
      if (Ce.scriptTree) return (0, W.toHashTree)(Ce.scriptTree);
      if (Ce.hash) return { hash: Ce.hash };
    }), dt = Ce.network || B.bitcoin, vt = { name: "p2tr", network: dt };
    if (V.prop(vt, "address", () => {
      if (!vt.pubkey) return;
      const mt = ne.bech32m.toWords(vt.pubkey);
      return mt.unshift(re), ne.bech32m.encode(dt.bech32, mt);
    }), V.prop(vt, "hash", () => {
      const mt = ht();
      if (mt) return mt.hash;
      const Pt = lt();
      if (Pt && Pt.length > 1) {
        const $t = Pt[Pt.length - 1], qt = $t[0] & K.TAPLEAF_VERSION_MASK, At = Pt[Pt.length - 2], bt = (0, W.tapleafHash)({
          output: At,
          version: qt
        });
        return (0, W.rootHashFromPath)($t, bt);
      }
      return null;
    }), V.prop(vt, "output", () => {
      if (vt.pubkey)
        return L.compile([oe.OP_1, vt.pubkey]);
    }), V.prop(vt, "redeemVersion", () => Ce.redeemVersion ? Ce.redeemVersion : Ce.redeem && Ce.redeem.redeemVersion !== void 0 && Ce.redeem.redeemVersion !== null ? Ce.redeem.redeemVersion : W.LEAF_VERSION_TAPSCRIPT), V.prop(vt, "redeem", () => {
      const mt = lt();
      if (!(!mt || mt.length < 2))
        return {
          output: mt[mt.length - 2],
          witness: mt.slice(0, -2),
          redeemVersion: mt[mt.length - 1][0] & K.TAPLEAF_VERSION_MASK
        };
    }), V.prop(vt, "pubkey", () => {
      if (Ce.pubkey) return Ce.pubkey;
      if (Ce.output) return Ce.output.slice(2);
      if (Ce.address) return at().data;
      if (vt.internalPubkey) {
        const mt = (0, W.tweakKey)(vt.internalPubkey, vt.hash);
        if (mt) return mt.x;
      }
    }), V.prop(vt, "internalPubkey", () => {
      if (Ce.internalPubkey) return Ce.internalPubkey;
      const mt = lt();
      if (mt && mt.length > 1)
        return mt[mt.length - 1].slice(1, 33);
    }), V.prop(vt, "signature", () => {
      if (Ce.signature) return Ce.signature;
      const mt = lt();
      if (!(!mt || mt.length !== 1))
        return mt[0];
    }), V.prop(vt, "witness", () => {
      if (Ce.witness) return Ce.witness;
      const mt = ht();
      if (mt && Ce.redeem && Ce.redeem.output && Ce.internalPubkey) {
        const Pt = (0, W.tapleafHash)({
          output: Ce.redeem.output,
          version: vt.redeemVersion
        }), $t = (0, W.findScriptPath)(mt, Pt);
        if (!$t) return;
        const qt = (0, W.tweakKey)(Ce.internalPubkey, mt.hash);
        if (!qt) return;
        const At = A.Buffer.concat(
          [
            A.Buffer.from([vt.redeemVersion | qt.parity]),
            Ce.internalPubkey
          ].concat($t)
        );
        return [Ce.redeem.output, At];
      }
      if (Ce.signature) return [Ce.signature];
    }), it.validate) {
      let mt = A.Buffer.from([]);
      if (Ce.address) {
        if (dt && dt.bech32 !== at().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (at().version !== re)
          throw new TypeError("Invalid address version");
        if (at().data.length !== 32)
          throw new TypeError("Invalid address data");
        mt = at().data;
      }
      if (Ce.pubkey) {
        if (mt.length > 0 && !mt.equals(Ce.pubkey))
          throw new TypeError("Pubkey mismatch");
        mt = Ce.pubkey;
      }
      if (Ce.output) {
        if (Ce.output.length !== 34 || Ce.output[0] !== oe.OP_1 || Ce.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (mt.length > 0 && !mt.equals(Ce.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        mt = Ce.output.slice(2);
      }
      if (Ce.internalPubkey) {
        const qt = (0, W.tweakKey)(Ce.internalPubkey, vt.hash);
        if (mt.length > 0 && !mt.equals(qt.x))
          throw new TypeError("Pubkey mismatch");
        mt = qt.x;
      }
      if (mt && mt.length && !(0, J.getEccLib)().isXOnlyPoint(mt))
        throw new TypeError("Invalid pubkey for p2tr");
      const Pt = ht();
      if (Ce.hash && Pt && !Ce.hash.equals(Pt.hash))
        throw new TypeError("Hash mismatch");
      if (Ce.redeem && Ce.redeem.output && Pt) {
        const qt = (0, W.tapleafHash)({
          output: Ce.redeem.output,
          version: vt.redeemVersion
        });
        if (!(0, W.findScriptPath)(Pt, qt))
          throw new TypeError("Redeem script not in tree");
      }
      const $t = lt();
      if (Ce.redeem && vt.redeem) {
        if (Ce.redeem.redeemVersion && Ce.redeem.redeemVersion !== vt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Ce.redeem.output) {
          if (L.decompile(Ce.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (vt.redeem.output && !Ce.redeem.output.equals(vt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Ce.redeem.witness && vt.redeem.witness && !(0, K.stacksEqual)(Ce.redeem.witness, vt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if ($t && $t.length)
        if ($t.length === 1) {
          if (Ce.signature && !Ce.signature.equals($t[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const qt = $t[$t.length - 1];
          if (qt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${qt.length}, expected min 33.`
            );
          if ((qt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${qt.length} is incorrect!`
            );
          const At = (qt.length - 33) / 32;
          if (At > 128)
            throw new TypeError(
              `The script path is too long. Got ${At}, expected max 128.`
            );
          const bt = qt.slice(1, 33);
          if (Ce.internalPubkey && !Ce.internalPubkey.equals(bt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, J.getEccLib)().isXOnlyPoint(bt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const xt = qt[0] & K.TAPLEAF_VERSION_MASK, wt = $t[$t.length - 2], Oe = (0, W.tapleafHash)({
            output: wt,
            version: xt
          }), rt = (0, W.rootHashFromPath)(qt, Oe), pe = (0, W.tweakKey)(bt, rt);
          if (!pe)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (mt.length && !mt.equals(pe.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (pe.parity !== (qt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(vt, Ce);
  }
  return p2tr.p2tr = ke, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.p2tr = A.p2wsh = A.p2wpkh = A.p2sh = A.p2pkh = A.p2pk = A.p2ms = A.embed = void 0;
    const B = embed;
    Object.defineProperty(A, "embed", {
      enumerable: !0,
      get: function() {
        return B.p2data;
      }
    });
    const L = p2ms$1;
    Object.defineProperty(A, "p2ms", {
      enumerable: !0,
      get: function() {
        return L.p2ms;
      }
    });
    const K = p2pk$1;
    Object.defineProperty(A, "p2pk", {
      enumerable: !0,
      get: function() {
        return K.p2pk;
      }
    });
    const J = p2pkh$1;
    Object.defineProperty(A, "p2pkh", {
      enumerable: !0,
      get: function() {
        return J.p2pkh;
      }
    });
    const W = p2sh$1;
    Object.defineProperty(A, "p2sh", {
      enumerable: !0,
      get: function() {
        return W.p2sh;
      }
    });
    const V = p2wpkh$1;
    Object.defineProperty(A, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return V.p2wpkh;
      }
    });
    const ne = p2wsh$1;
    Object.defineProperty(A, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ne.p2wsh;
      }
    });
    const ie = requireP2tr();
    Object.defineProperty(A, "p2tr", {
      enumerable: !0,
      get: function() {
        return ie.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const A = networks, B = requirePayments(), L = requireScript(), K = types$4, J = dist, W = bs58check$2, V = 40, ne = 2, ie = 16, oe = 2, re = 80, ce = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function ke(vt, mt) {
    const Pt = vt.slice(2);
    if (Pt.length < ne || Pt.length > V)
      throw new TypeError("Invalid program length for segwit address");
    const $t = vt[0] - re;
    if ($t < oe || $t > ie)
      throw new TypeError("Invalid version for segwit address");
    if (vt[1] !== Pt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(ce), lt(Pt, $t, mt.bech32);
  }
  function Ce(vt) {
    const mt = Buffer$1.from(W.decode(vt));
    if (mt.length < 21) throw new TypeError(vt + " is too short");
    if (mt.length > 21) throw new TypeError(vt + " is too long");
    const Pt = mt.readUInt8(0), $t = mt.slice(1);
    return { version: Pt, hash: $t };
  }
  address.fromBase58Check = Ce;
  function it(vt) {
    let mt, Pt;
    try {
      mt = J.bech32.decode(vt);
    } catch {
    }
    if (mt) {
      if (Pt = mt.words[0], Pt !== 0) throw new TypeError(vt + " uses wrong encoding");
    } else if (mt = J.bech32m.decode(vt), Pt = mt.words[0], Pt === 0) throw new TypeError(vt + " uses wrong encoding");
    const $t = J.bech32.fromWords(mt.words.slice(1));
    return {
      version: Pt,
      prefix: mt.prefix,
      data: Buffer$1.from($t)
    };
  }
  address.fromBech32 = it;
  function at(vt, mt) {
    (0, K.typeforce)(
      (0, K.tuple)(K.Hash160bit, K.UInt8),
      arguments
    );
    const Pt = Buffer$1.allocUnsafe(21);
    return Pt.writeUInt8(mt, 0), vt.copy(Pt, 1), W.encode(Pt);
  }
  address.toBase58Check = at;
  function lt(vt, mt, Pt) {
    const $t = J.bech32.toWords(vt);
    return $t.unshift(mt), mt === 0 ? J.bech32.encode(Pt, $t) : J.bech32m.encode(Pt, $t);
  }
  address.toBech32 = lt;
  function ht(vt, mt) {
    mt = mt || A.bitcoin;
    try {
      return B.p2pkh({ output: vt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2sh({ output: vt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2wpkh({ output: vt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2wsh({ output: vt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2tr({ output: vt, network: mt }).address;
    } catch {
    }
    try {
      return ke(vt, mt);
    } catch {
    }
    throw new Error(L.toASM(vt) + " has no matching Address");
  }
  address.fromOutputScript = ht;
  function dt(vt, mt) {
    mt = mt || A.bitcoin;
    let Pt, $t;
    try {
      Pt = Ce(vt);
    } catch {
    }
    if (Pt) {
      if (Pt.version === mt.pubKeyHash)
        return B.p2pkh({ hash: Pt.hash }).output;
      if (Pt.version === mt.scriptHash)
        return B.p2sh({ hash: Pt.hash }).output;
    } else {
      try {
        $t = it(vt);
      } catch {
      }
      if ($t) {
        if ($t.prefix !== mt.bech32)
          throw new Error(vt + " has an invalid prefix");
        if ($t.version === 0) {
          if ($t.data.length === 20)
            return B.p2wpkh({ hash: $t.data }).output;
          if ($t.data.length === 32)
            return B.p2wsh({ hash: $t.data }).output;
        } else if ($t.version === 1) {
          if ($t.data.length === 32)
            return B.p2tr({ pubkey: $t.data }).output;
        } else if ($t.version >= oe && $t.version <= ie && $t.data.length >= ne && $t.data.length <= V)
          return console.warn(ce), L.compile([
            $t.version + re,
            $t.data
          ]);
      }
    }
    throw new Error(vt + " has no matching Script");
  }
  return address.toOutputScript = dt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(A, B) {
  if (!Array.isArray(A)) throw TypeError("Expected values Array");
  if (typeof B != "function")
    throw TypeError("Expected digest Function");
  let L = A.length;
  const K = A.concat();
  for (; L > 1; ) {
    let J = 0;
    for (let W = 0; W < L; W += 2, ++J) {
      const V = K[W], ne = W + 1 === L ? V : K[W + 1], ie = Buffer$1.concat([V, ne]);
      K[J] = B(ie);
    }
    L = J;
  }
  return K[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + B;
}
function vectorSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + A.reduce((L, K) => L + varSliceSize(K), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(A) {
  return A.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(B, L) {
    const K = new bufferutils_1$2.BufferReader(B), J = new Transaction();
    J.version = K.readInt32();
    const W = K.readUInt8(), V = K.readUInt8();
    let ne = !1;
    W === Transaction.ADVANCED_TRANSACTION_MARKER && V === Transaction.ADVANCED_TRANSACTION_FLAG ? ne = !0 : K.offset -= 2;
    const ie = K.readVarInt();
    for (let re = 0; re < ie; ++re)
      J.ins.push({
        hash: K.readSlice(32),
        index: K.readUInt32(),
        script: K.readVarSlice(),
        sequence: K.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const oe = K.readVarInt();
    for (let re = 0; re < oe; ++re)
      J.outs.push({
        value: K.readUInt64(),
        script: K.readVarSlice()
      });
    if (ne) {
      for (let re = 0; re < ie; ++re)
        J.ins[re].witness = K.readVector();
      if (!J.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (J.locktime = K.readUInt32(), L) return J;
    if (K.offset !== B.length)
      throw new Error("Transaction has unexpected data");
    return J;
  }
  static fromHex(B) {
    return Transaction.fromBuffer(Buffer$1.from(B, "hex"), !1);
  }
  static isCoinbaseHash(B) {
    typeforce$1(types$1.Hash256bit, B);
    for (let L = 0; L < 32; ++L)
      if (B[L] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(B, L, K, J) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(K) && (K = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: B,
      index: L,
      script: J || EMPTY_BUFFER,
      sequence: K,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(B, L) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: B,
      value: L
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((B) => B.witness.length !== 0);
  }
  weight() {
    const B = this.byteLength(!1), L = this.byteLength(!0);
    return B * 3 + L;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(B = !0) {
    const L = B && this.hasWitnesses();
    return (L ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((K, J) => K + 40 + varSliceSize(J.script), 0) + this.outs.reduce((K, J) => K + 8 + varSliceSize(J.script), 0) + (L ? this.ins.reduce((K, J) => K + vectorSize(J.witness), 0) : 0);
  }
  clone() {
    const B = new Transaction();
    return B.version = this.version, B.locktime = this.locktime, B.ins = this.ins.map((L) => ({
      hash: L.hash,
      index: L.index,
      script: L.script,
      sequence: L.sequence,
      witness: L.witness
    })), B.outs = this.outs.map((L) => ({
      script: L.script,
      value: L.value
    })), B;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(B, L, K) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), B >= this.ins.length) return ONE;
    const J = bscript$2.compile(
      bscript$2.decompile(L).filter((ne) => ne !== script_1.OPS.OP_CODESEPARATOR)
    ), W = this.clone();
    if ((K & 31) === Transaction.SIGHASH_NONE)
      W.outs = [], W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    else if ((K & 31) === Transaction.SIGHASH_SINGLE) {
      if (B >= this.outs.length) return ONE;
      W.outs.length = B + 1;
      for (let ne = 0; ne < B; ne++)
        W.outs[ne] = BLANK_OUTPUT;
      W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    }
    K & Transaction.SIGHASH_ANYONECANPAY ? (W.ins = [W.ins[B]], W.ins[0].script = J) : (W.ins.forEach((ne) => {
      ne.script = EMPTY_BUFFER;
    }), W.ins[B].script = J);
    const V = Buffer$1.allocUnsafe(W.byteLength(!1) + 4);
    return V.writeInt32LE(K, V.length - 4), W.__toBuffer(V, 0, !1), bcrypto$1.hash256(V);
  }
  hashForWitnessV1(B, L, K, J, W, V) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), K.length !== this.ins.length || L.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ne = J === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : J & Transaction.SIGHASH_OUTPUT_MASK, oe = (J & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, re = ne === Transaction.SIGHASH_NONE, ce = ne === Transaction.SIGHASH_SINGLE;
    let ke = EMPTY_BUFFER, Ce = EMPTY_BUFFER, it = EMPTY_BUFFER, at = EMPTY_BUFFER, lt = EMPTY_BUFFER;
    if (!oe) {
      let mt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Pt) => {
        mt.writeSlice(Pt.hash), mt.writeUInt32(Pt.index);
      }), ke = bcrypto$1.sha256(mt.end()), mt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), K.forEach((Pt) => mt.writeUInt64(Pt)), Ce = bcrypto$1.sha256(mt.end()), mt = bufferutils_1$2.BufferWriter.withCapacity(
        L.map(varSliceSize).reduce((Pt, $t) => Pt + $t)
      ), L.forEach(
        (Pt) => mt.writeVarSlice(Pt)
      ), it = bcrypto$1.sha256(mt.end()), mt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Pt) => mt.writeUInt32(Pt.sequence)), at = bcrypto$1.sha256(mt.end());
    }
    if (re || ce) {
      if (ce && B < this.outs.length) {
        const mt = this.outs[B], Pt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(mt.script)
        );
        Pt.writeUInt64(mt.value), Pt.writeVarSlice(mt.script), lt = bcrypto$1.sha256(Pt.end());
      }
    } else {
      const mt = this.outs.map(($t) => 8 + varSliceSize($t.script)).reduce(($t, qt) => $t + qt), Pt = bufferutils_1$2.BufferWriter.withCapacity(mt);
      this.outs.forEach(($t) => {
        Pt.writeUInt64($t.value), Pt.writeVarSlice($t.script);
      }), lt = bcrypto$1.sha256(Pt.end());
    }
    const ht = (W ? 2 : 0) + (V ? 1 : 0), dt = 174 - (oe ? 49 : 0) - (re ? 32 : 0) + (V ? 32 : 0) + (W ? 37 : 0), vt = bufferutils_1$2.BufferWriter.withCapacity(dt);
    if (vt.writeUInt8(J), vt.writeInt32(this.version), vt.writeUInt32(this.locktime), vt.writeSlice(ke), vt.writeSlice(Ce), vt.writeSlice(it), vt.writeSlice(at), re || ce || vt.writeSlice(lt), vt.writeUInt8(ht), oe) {
      const mt = this.ins[B];
      vt.writeSlice(mt.hash), vt.writeUInt32(mt.index), vt.writeUInt64(K[B]), vt.writeVarSlice(L[B]), vt.writeUInt32(mt.sequence);
    } else
      vt.writeUInt32(B);
    if (V) {
      const mt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(V)
      );
      mt.writeVarSlice(V), vt.writeSlice(bcrypto$1.sha256(mt.end()));
    }
    return ce && vt.writeSlice(lt), W && (vt.writeSlice(W), vt.writeUInt8(0), vt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), vt.end()])
    );
  }
  hashForWitnessV0(B, L, K, J) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let W = Buffer$1.from([]), V, ne = ZERO, ie = ZERO, oe = ZERO;
    if (J & Transaction.SIGHASH_ANYONECANPAY || (W = Buffer$1.allocUnsafe(36 * this.ins.length), V = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((ce) => {
      V.writeSlice(ce.hash), V.writeUInt32(ce.index);
    }), ie = bcrypto$1.hash256(W)), !(J & Transaction.SIGHASH_ANYONECANPAY) && (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE && (W = Buffer$1.allocUnsafe(4 * this.ins.length), V = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((ce) => {
      V.writeUInt32(ce.sequence);
    }), oe = bcrypto$1.hash256(W)), (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE) {
      const ce = this.outs.reduce((ke, Ce) => ke + 8 + varSliceSize(Ce.script), 0);
      W = Buffer$1.allocUnsafe(ce), V = new bufferutils_1$2.BufferWriter(W, 0), this.outs.forEach((ke) => {
        V.writeUInt64(ke.value), V.writeVarSlice(ke.script);
      }), ne = bcrypto$1.hash256(W);
    } else if ((J & 31) === Transaction.SIGHASH_SINGLE && B < this.outs.length) {
      const ce = this.outs[B];
      W = Buffer$1.allocUnsafe(8 + varSliceSize(ce.script)), V = new bufferutils_1$2.BufferWriter(W, 0), V.writeUInt64(ce.value), V.writeVarSlice(ce.script), ne = bcrypto$1.hash256(W);
    }
    W = Buffer$1.allocUnsafe(156 + varSliceSize(L)), V = new bufferutils_1$2.BufferWriter(W, 0);
    const re = this.ins[B];
    return V.writeInt32(this.version), V.writeSlice(ie), V.writeSlice(oe), V.writeSlice(re.hash), V.writeUInt32(re.index), V.writeVarSlice(L), V.writeUInt64(K), V.writeUInt32(re.sequence), V.writeSlice(ne), V.writeUInt32(this.locktime), V.writeUInt32(J), bcrypto$1.hash256(W);
  }
  getHash(B) {
    return B && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, B));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(B, L) {
    return this.__toBuffer(B, L, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[B].script = L;
  }
  setWitness(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[B].witness = L;
  }
  __toBuffer(B, L, K = !1) {
    B || (B = Buffer$1.allocUnsafe(this.byteLength(K)));
    const J = new bufferutils_1$2.BufferWriter(
      B,
      L || 0
    );
    J.writeInt32(this.version);
    const W = K && this.hasWitnesses();
    return W && (J.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), J.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), J.writeVarInt(this.ins.length), this.ins.forEach((V) => {
      J.writeSlice(V.hash), J.writeUInt32(V.index), J.writeVarSlice(V.script), J.writeUInt32(V.sequence);
    }), J.writeVarInt(this.outs.length), this.outs.forEach((V) => {
      isOutput(V) ? J.writeUInt64(V.value) : J.writeSlice(V.valueBuffer), J.writeVarSlice(V.script);
    }), W && this.ins.forEach((V) => {
      J.writeVector(V.witness);
    }), J.writeUInt32(this.locktime), L !== void 0 ? B.slice(L, J.offset) : B;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(B) {
    if (B.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const L = new bufferutils_1$1.BufferReader(B), K = new Block();
    if (K.version = L.readInt32(), K.prevHash = L.readSlice(32), K.merkleRoot = L.readSlice(32), K.timestamp = L.readUInt32(), K.bits = L.readUInt32(), K.nonce = L.readUInt32(), B.length === 80) return K;
    const J = () => {
      const ne = transaction_1$3.Transaction.fromBuffer(
        L.buffer.slice(L.offset),
        !0
      );
      return L.offset += ne.byteLength(), ne;
    }, W = L.readVarInt();
    K.transactions = [];
    for (let ne = 0; ne < W; ++ne) {
      const ie = J();
      K.transactions.push(ie);
    }
    const V = K.getWitnessCommit();
    return V && (K.witnessCommit = V), K;
  }
  static fromHex(B) {
    return Block.fromBuffer(Buffer$1.from(B, "hex"));
  }
  static calculateTarget(B) {
    const L = ((B & 4278190080) >> 24) - 3, K = B & 8388607, J = Buffer$1.alloc(32, 0);
    return J.writeUIntBE(K, 29 - L, 3), J;
  }
  static calculateMerkleRoot(B, L) {
    if (typeforce([{ getHash: types.Function }], B), B.length === 0) throw errorMerkleNoTxes;
    if (L && !txesHaveWitnessCommit(B))
      throw errorWitnessNotSegwit;
    const K = B.map(
      (W) => W.getHash(L)
    ), J = (0, merkle_1.fastMerkleRoot)(K, bcrypto.hash256);
    return L ? bcrypto.hash256(
      Buffer$1.concat([J, B[0].ins[0].witness[0]])
    ) : J;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const B = this.transactions[0].outs.filter(
      (K) => K.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((K) => K.script.slice(6, 38));
    if (B.length === 0) return null;
    const L = B[B.length - 1];
    return L instanceof Buffer$1 && L.length === 32 ? L : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const B = this.byteLength(!1, !1), L = this.byteLength(!1, !0);
    return B * 3 + L;
  }
  byteLength(B, L = !0) {
    return B || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((K, J) => K + J.byteLength(L), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const B = /* @__PURE__ */ new Date(0);
    return B.setUTCSeconds(this.timestamp), B;
  }
  // TODO: buffer, offset compatibility
  toBuffer(B) {
    const L = Buffer$1.allocUnsafe(this.byteLength(B)), K = new bufferutils_1$1.BufferWriter(L);
    return K.writeInt32(this.version), K.writeSlice(this.prevHash), K.writeSlice(this.merkleRoot), K.writeUInt32(this.timestamp), K.writeUInt32(this.bits), K.writeUInt32(this.nonce), B || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      L,
      K.offset
    ), K.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((J) => {
      const W = J.byteLength();
      J.toBuffer(L, K.offset), K.offset += W;
    })), L;
  }
  toHex(B) {
    return this.toBuffer(B).toString("hex");
  }
  checkTxRoots() {
    const B = this.hasWitnessCommit();
    return !B && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (B ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const B = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), L = Block.calculateTarget(this.bits);
    return B.compare(L) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const B = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(B) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const B = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(B) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(A) {
  return A instanceof Array && A[0] && A[0].ins && A[0].ins instanceof Array && A[0].ins[0] && A[0].ins[0].witness && A[0].ins[0].witness instanceof Array && A[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(A) {
  return A instanceof Array && A.some(
    (B) => typeof B == "object" && B.ins instanceof Array && B.ins.some(
      (L) => typeof L == "object" && L.witness instanceof Array && L.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), function(B) {
    B[B.UNSIGNED_TX = 0] = "UNSIGNED_TX", B[B.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(A.GlobalTypes || (A.GlobalTypes = {})), A.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(B) {
    B[B.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", B[B.WITNESS_UTXO = 1] = "WITNESS_UTXO", B[B.PARTIAL_SIG = 2] = "PARTIAL_SIG", B[B.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", B[B.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", B[B.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", B[B.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", B[B.POR_COMMITMENT = 9] = "POR_COMMITMENT", B[B.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", B[B.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", B[B.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", B[B.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", B[B.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(A.InputTypes || (A.InputTypes = {})), A.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(B) {
    B[B.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", B[B.TAP_TREE = 6] = "TAP_TREE", B[B.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(A.OutputTypes || (A.OutputTypes = {})), A.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (A) => [...Array(A).keys()];
function decode$d(A) {
  if (A.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 79 || ![2, 3].includes(A.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + A.key.toString("hex")
    );
  if (A.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const B = A.key.slice(1), L = {
    masterFingerprint: A.value.slice(0, 4),
    extendedPubkey: B,
    path: "m"
  };
  for (const K of range$2(A.value.length / 4 - 1)) {
    const J = A.value.readUInt32LE(K * 4 + 4), W = !!(J & 2147483648), V = J & 2147483647;
    L.path += "/" + V.toString(10) + (W ? "'" : "");
  }
  return L;
}
globalXpub$1.decode = decode$d;
function encode$e(A) {
  const B = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), L = Buffer$1.concat([B, A.extendedPubkey]), K = A.path.split("/"), J = Buffer$1.allocUnsafe(K.length * 4);
  A.masterFingerprint.copy(J, 0);
  let W = 4;
  return K.slice(1).forEach((V) => {
    const ne = V.slice(-1) === "'";
    let ie = 2147483647 & parseInt(ne ? V.slice(0, -1) : V, 10);
    ne && (ie += 2147483648), J.writeUInt32LE(ie, W), W += 4;
  }), {
    key: L,
    value: J
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(A) {
  const B = A.extendedPubkey, L = A.masterFingerprint, K = A.path;
  return Buffer$1.isBuffer(B) && B.length === 78 && [2, 3].indexOf(B[45]) > -1 && Buffer$1.isBuffer(L) && L.length === 4 && typeof K == "string" && !!K.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(A, B, L) {
  const K = B.extendedPubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((J) => J.extendedPubkey.equals(B.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(A) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: A.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(A) {
  if (A.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(A) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: A
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptSig$1.check = check$b;
function canAdd$8(A, B) {
  return !!A && !!B && A.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(A) {
  if (A.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(A) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: A
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(A, B) {
  return !!A && !!B && A.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(A) {
  if (A.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(A) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: A
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(A) {
  return Buffer$1.isBuffer(A);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(A, B) {
  return !!A && !!B && A.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(A) {
  if (A.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + A.key.toString("hex")
    );
  if (!(A.key.length === 34 || A.key.length === 66) || ![2, 3, 4].includes(A.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + A.key.toString("hex")
    );
  return {
    pubkey: A.key.slice(1),
    signature: A.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(A) {
  const B = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey]),
    value: A.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.signature) && [33, 65].includes(A.pubkey.length) && [2, 3, 4].includes(A.pubkey[0]) && isDerSigWithSighash(A.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(A) {
  if (!Buffer$1.isBuffer(A) || A.length < 9 || A[0] !== 48 || A.length !== A[1] + 3 || A[2] !== 2) return !1;
  const B = A[3];
  if (B > 33 || B < 1 || A[3 + B + 1] !== 2) return !1;
  const L = A[3 + B + 2];
  return !(L > 33 || L < 1 || A.length !== 3 + B + 2 + L + 2);
}
function canAddToArray$2(A, B, L) {
  const K = B.pubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((J) => J.pubkey.equals(B.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(A) {
  if (A.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + A.key.toString("hex")
    );
  return A.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(A) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(A, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(A) {
  return typeof A == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(A, B) {
  return !!A && !!B && A.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(A) {
  if (A.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + A.key.toString("hex")
    );
  return A.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(A) {
  const B = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), L = Buffer$1.allocUnsafe(4);
  return L.writeUInt32LE(A, 0), {
    key: B,
    value: L
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(A) {
  return typeof A == "number";
}
sighashType$1.check = check$6;
function canAdd$4(A, B) {
  return !!A && !!B && A.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(A) {
  if (A.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + A.key.toString("hex")
    );
  if (!check$5(A.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return A.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(A) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: A };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(A) {
  return Buffer$1.isBuffer(A) && (A.length === 64 || A.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(A, B) {
  return !!A && !!B && A.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(A) {
  if (A.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + A.key.toString("hex")
    );
  if ((A.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + A.key.toString("hex")
    );
  const B = A.value[A.value.length - 1];
  if ((A.key[1] & 254) !== B)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + A.key.toString("hex")
    );
  const L = A.value.slice(0, -1);
  return { controlBlock: A.key.slice(1), script: L, leafVersion: B };
}
tapLeafScript$1.decode = decode$5;
function encode$5(A) {
  const B = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), L = Buffer$1.from([A.leafVersion]);
  return {
    key: Buffer$1.concat([B, A.controlBlock]),
    value: Buffer$1.concat([A.script, L])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(A) {
  return Buffer$1.isBuffer(A.controlBlock) && (A.controlBlock.length - 1) % 32 === 0 && (A.controlBlock[0] & 254) === A.leafVersion && Buffer$1.isBuffer(A.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(A, B, L) {
  const K = B.controlBlock.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((J) => J.controlBlock.equals(B.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(A) {
  if (A.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + A.key.toString("hex")
    );
  if (!check$3(A.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return A.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(A) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: A };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(A) {
  return Buffer$1.isBuffer(A) && A.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(A, B) {
  return !!A && !!B && A.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(A) {
  if (A.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + A.key.toString("hex")
    );
  if (A.value.length !== 64 && A.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + A.key.toString("hex")
    );
  const B = A.key.slice(1, 33), L = A.key.slice(33);
  return {
    pubkey: B,
    leafHash: L,
    signature: A.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(A) {
  const B = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey, A.leafHash]),
    value: A.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.leafHash) && Buffer$1.isBuffer(A.signature) && A.pubkey.length === 32 && A.leafHash.length === 32 && (A.signature.length === 64 || A.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(A, B, L) {
  const K = B.pubkey.toString("hex") + B.leafHash.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter(
    (J) => J.pubkey.equals(B.pubkey) && J.leafHash.equals(B.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER || A % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(A, B, L) {
  if (checkUInt53(A), B || (B = Buffer$1.allocUnsafe(encodingLength(A))), !Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), Object.assign(encode$2, { bytes: 1 })) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), Object.assign(encode$2, { bytes: 3 })) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), Object.assign(encode$2, { bytes: 5 })) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), Object.assign(encode$2, { bytes: 9 })), B;
}
varint.encode = encode$2;
function decode$2(A, B) {
  if (!Buffer$1.isBuffer(A))
    throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  const L = A.readUInt8(B);
  if (L < 253)
    return Object.assign(decode$2, { bytes: 1 }), L;
  if (L === 253)
    return Object.assign(decode$2, { bytes: 3 }), A.readUInt16LE(B + 1);
  if (L === 254)
    return Object.assign(decode$2, { bytes: 5 }), A.readUInt32LE(B + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const K = A.readUInt32LE(B + 1), W = A.readUInt32LE(B + 5) * 4294967296 + K;
    return checkUInt53(W), W;
  }
}
varint.decode = decode$2;
function encodingLength(A) {
  return checkUInt53(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (A) => [...Array(A).keys()];
function reverseBuffer(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(A) {
  const B = A.map(keyValToBuffer);
  return B.push(Buffer$1.from([0])), Buffer$1.concat(B);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(A) {
  const B = A.key.length, L = A.value.length, K = varuint$6.encodingLength(B), J = varuint$6.encodingLength(L), W = Buffer$1.allocUnsafe(
    K + B + J + L
  );
  return varuint$6.encode(B, W, 0), A.key.copy(W, K), varuint$6.encode(L, W, K + B), A.value.copy(W, K + B + J), W;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint(K + L, 9007199254740991), K + L;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(A, B, L) {
  return verifuint(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(A) {
  if (A.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + A.key.toString("hex")
    );
  const B = tools_1$2.readUInt64LE(A.value, 0);
  let L = 8;
  const K = varuint$5.decode(A.value, L);
  L += varuint$5.encodingLength(K);
  const J = A.value.slice(L);
  if (J.length !== K)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: J,
    value: B
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(A) {
  const { script: B, value: L } = A, K = varuint$5.encodingLength(B.length), J = Buffer$1.allocUnsafe(8 + K + B.length);
  return tools_1$2.writeUInt64LE(J, L, 0), varuint$5.encode(B.length, J, 8), B.copy(J, 8 + K), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: J
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(A) {
  return Buffer$1.isBuffer(A.script) && typeof A.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(A, B) {
  return !!A && !!B && A.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(A) {
  if (A.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + A.key.toString("hex")
    );
  let B = 0;
  const L = [];
  for (; B < A.value.length; ) {
    const K = A.value[B++], J = A.value[B++], W = varuint$4.decode(A.value, B);
    B += varuint$4.encodingLength(W), L.push({
      depth: K,
      leafVersion: J,
      script: A.value.slice(B, B + W)
    }), B += W;
  }
  return { leaves: L };
}
tapTree$1.decode = decode;
function encode(A) {
  const B = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), L = [].concat(
    ...A.leaves.map((K) => [
      Buffer$1.of(K.depth, K.leafVersion),
      varuint$4.encode(K.script.length),
      K.script
    ])
  );
  return {
    key: B,
    value: Buffer$1.concat(L)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(A) {
  return Array.isArray(A.leaves) && A.leaves.every(
    (B) => B.depth >= 0 && B.depth <= 128 && (B.leafVersion & 254) === B.leafVersion && Buffer$1.isBuffer(B.script)
  );
}
tapTree$1.check = check;
function canAdd(A, B) {
  return !!A && !!B && A.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (A) => [...Array(A).keys()], isValidDERKey = (A) => A.length === 33 && [2, 3].includes(A[0]) || A.length === 65 && A[0] === 4;
function makeConverter$4(A, B = isValidDERKey) {
  function L(ne) {
    if (ne.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ne.key.toString("hex")
      );
    const ie = ne.key.slice(1);
    if (!B(ie))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ne.key.toString("hex")
      );
    if (ne.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const oe = {
      masterFingerprint: ne.value.slice(0, 4),
      pubkey: ie,
      path: "m"
    };
    for (const re of range$1(ne.value.length / 4 - 1)) {
      const ce = ne.value.readUInt32LE(re * 4 + 4), ke = !!(ce & 2147483648), Ce = ce & 2147483647;
      oe.path += "/" + Ce.toString(10) + (ke ? "'" : "");
    }
    return oe;
  }
  function K(ne) {
    const ie = Buffer$1.from([A]), oe = Buffer$1.concat([ie, ne.pubkey]), re = ne.path.split("/"), ce = Buffer$1.allocUnsafe(re.length * 4);
    ne.masterFingerprint.copy(ce, 0);
    let ke = 4;
    return re.slice(1).forEach((Ce) => {
      const it = Ce.slice(-1) === "'";
      let at = 2147483647 & parseInt(it ? Ce.slice(0, -1) : Ce, 10);
      it && (at += 2147483648), ce.writeUInt32LE(at, ke), ke += 4;
    }), {
      key: oe,
      value: ce
    };
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function W(ne) {
    return Buffer$1.isBuffer(ne.pubkey) && Buffer$1.isBuffer(ne.masterFingerprint) && typeof ne.path == "string" && B(ne.pubkey) && ne.masterFingerprint.length === 4;
  }
  function V(ne, ie, oe) {
    const re = ie.pubkey.toString("hex");
    return oe.has(re) ? !1 : (oe.add(re), ne.filter((ce) => ce.pubkey.equals(ie.pubkey)).length === 0);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: J,
    canAddToArray: V
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(A) {
  return B;
  function B(L) {
    let K;
    if (A.includes(L.key[0]) && (K = L.key.slice(1), !(K.length === 33 || K.length === 65) || ![2, 3, 4].includes(K[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + L.key.toString("hex")
      );
    return K;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(A) {
  function B(V) {
    if (V.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + V.key.toString("hex")
      );
    return V.value;
  }
  function L(V) {
    return {
      key: Buffer$1.from([A]),
      value: V
    };
  }
  const K = "Buffer";
  function J(V) {
    return Buffer$1.isBuffer(V);
  }
  function W(V, ne) {
    return !!V && !!ne && V.redeemScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: J,
    expected: K,
    canAdd: W
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (A) => A.length === 32;
function makeConverter$2(A) {
  const B = bip32Derivation$1.makeConverter(A, isValidBIP340Key);
  function L(V) {
    const ne = varuint$3.decode(V.value), ie = varuint$3.encodingLength(ne), oe = B.decode({
      key: V.key,
      value: V.value.slice(ie + ne * 32)
    }), re = new Array(ne);
    for (let ce = 0, ke = ie; ce < ne; ce++, ke += 32)
      re[ce] = V.value.slice(ke, ke + 32);
    return Object.assign({}, oe, { leafHashes: re });
  }
  function K(V) {
    const ne = B.encode(V), ie = varuint$3.encodingLength(V.leafHashes.length), oe = Buffer$1.allocUnsafe(ie);
    varuint$3.encode(V.leafHashes.length, oe);
    const re = Buffer$1.concat([oe, ...V.leafHashes, ne.value]);
    return Object.assign({}, ne, { value: re });
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function W(V) {
    return Array.isArray(V.leafHashes) && V.leafHashes.every(
      (ne) => Buffer$1.isBuffer(ne) && ne.length === 32
    ) && B.check(V);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: J,
    canAddToArray: B.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(A) {
  function B(V) {
    if (V.key[0] !== A || V.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + V.key.toString("hex")
      );
    if (V.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return V.value;
  }
  function L(V) {
    return { key: Buffer$1.from([A]), value: V };
  }
  const K = "Buffer";
  function J(V) {
    return Buffer$1.isBuffer(V) && V.length === 32;
  }
  function W(V, ne) {
    return !!V && !!ne && V.tapInternalKey === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: J,
    expected: K,
    canAdd: W
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(A) {
  function B(V) {
    if (V.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + V.key.toString("hex")
      );
    return V.value;
  }
  function L(V) {
    return {
      key: Buffer$1.from([A]),
      value: V
    };
  }
  const K = "Buffer";
  function J(V) {
    return Buffer$1.isBuffer(V);
  }
  function W(V, ne) {
    return !!V && !!ne && V.witnessScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: J,
    expected: K,
    canAdd: W
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(A, B) {
  let L = 0;
  function K() {
    const lt = varuint$2.decode(A, L);
    L += varuint$2.encodingLength(lt);
    const ht = A.slice(L, L + lt);
    return L += lt, ht;
  }
  function J() {
    const lt = A.readUInt32BE(L);
    return L += 4, lt;
  }
  function W() {
    const lt = A.readUInt8(L);
    return L += 1, lt;
  }
  function V() {
    const lt = K(), ht = K();
    return {
      key: lt,
      value: ht
    };
  }
  function ne() {
    if (L >= A.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const lt = A.readUInt8(L) === 0;
    return lt && L++, lt;
  }
  if (J() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (W() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ie = [], oe = {};
  for (; !ne(); ) {
    const lt = V(), ht = lt.key.toString("hex");
    if (oe[ht])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + ht
      );
    oe[ht] = 1, ie.push(lt);
  }
  const re = ie.filter(
    (lt) => lt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (re.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const ce = B(re[0].value), { inputCount: ke, outputCount: Ce } = ce.getInputOutputCounts(), it = [], at = [];
  for (const lt of tools_1$1.range(ke)) {
    const ht = {}, dt = [];
    for (; !ne(); ) {
      const vt = V(), mt = vt.key.toString("hex");
      if (ht[mt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + lt + " key " + mt
        );
      ht[mt] = 1, dt.push(vt);
    }
    it.push(dt);
  }
  for (const lt of tools_1$1.range(Ce)) {
    const ht = {}, dt = [];
    for (; !ne(); ) {
      const vt = V(), mt = vt.key.toString("hex");
      if (ht[mt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + lt + " key " + mt
        );
      ht[mt] = 1, dt.push(vt);
    }
    at.push(dt);
  }
  return psbtFromKeyVals(ce, {
    globalMapKeyVals: ie,
    inputKeyVals: it,
    outputKeyVals: at
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(A, B, L) {
  if (!B.equals(Buffer$1.from([L])))
    throw new Error(
      `Format Error: Invalid ${A} key: ${B.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(A, { globalMapKeyVals: B, inputKeyVals: L, outputKeyVals: K }) {
  const J = {
    unsignedTx: A
  };
  let W = 0;
  for (const re of B)
    switch (re.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          re.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), W > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        W++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        J.globalXpub === void 0 && (J.globalXpub = []), J.globalXpub.push(convert$1.globals.globalXpub.decode(re));
        break;
      default:
        J.unknownKeyVals || (J.unknownKeyVals = []), J.unknownKeyVals.push(re);
    }
  const V = L.length, ne = K.length, ie = [], oe = [];
  for (const re of tools_1$1.range(V)) {
    const ce = {};
    for (const ke of L[re])
      switch (convert$1.inputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), ce.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          ce.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), ce.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          ce.witnessUtxo = convert$1.inputs.witnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          ce.partialSig === void 0 && (ce.partialSig = []), ce.partialSig.push(convert$1.inputs.partialSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), ce.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          ce.sighashType = convert$1.inputs.sighashType.decode(ke);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), ce.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          ce.redeemScript = convert$1.inputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), ce.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          ce.witnessScript = convert$1.inputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          ce.bip32Derivation === void 0 && (ce.bip32Derivation = []), ce.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), ce.finalScriptSig = convert$1.inputs.finalScriptSig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), ce.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            ke
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), ce.porCommitment = convert$1.inputs.porCommitment.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), ce.tapKeySig = convert$1.inputs.tapKeySig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          ce.tapScriptSig === void 0 && (ce.tapScriptSig = []), ce.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          ce.tapLeafScript === void 0 && (ce.tapLeafScript = []), ce.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          ce.tapBip32Derivation === void 0 && (ce.tapBip32Derivation = []), ce.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), ce.tapInternalKey = convert$1.inputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), ce.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(ke);
          break;
        default:
          ce.unknownKeyVals || (ce.unknownKeyVals = []), ce.unknownKeyVals.push(ke);
      }
    ie.push(ce);
  }
  for (const re of tools_1$1.range(ne)) {
    const ce = {};
    for (const ke of K[re])
      switch (convert$1.outputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), ce.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          ce.redeemScript = convert$1.outputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), ce.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          ce.witnessScript = convert$1.outputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          ce.bip32Derivation === void 0 && (ce.bip32Derivation = []), ce.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), ce.tapInternalKey = convert$1.outputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), ce.tapTree = convert$1.outputs.tapTree.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          ce.tapBip32Derivation === void 0 && (ce.tapBip32Derivation = []), ce.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(ke)
          );
          break;
        default:
          ce.unknownKeyVals || (ce.unknownKeyVals = []), ce.unknownKeyVals.push(ke);
      }
    oe.push(ce);
  }
  return { globalMap: J, inputs: ie, outputs: oe };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: A, inputs: B, outputs: L }) {
  const { globalKeyVals: K, inputKeyVals: J, outputKeyVals: W } = psbtToKeyVals({
    globalMap: A,
    inputs: B,
    outputs: L
  }), V = tools_1.keyValsToBuffer(K), ne = (ce) => ce.length === 0 ? [Buffer$1.from([0])] : ce.map(tools_1.keyValsToBuffer), ie = ne(J), oe = ne(W), re = Buffer$1.allocUnsafe(5);
  return re.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [re, V].concat(ie, oe)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (A, B) => A.key.compare(B.key);
function keyValsFromMap(A, B) {
  const L = /* @__PURE__ */ new Set(), K = Object.entries(A).reduce((W, [V, ne]) => {
    if (V === "unknownKeyVals") return W;
    const ie = B[V];
    if (ie === void 0) return W;
    const oe = (Array.isArray(ne) ? ne : [ne]).map(
      ie.encode
    );
    return oe.map((ce) => ce.key.toString("hex")).forEach((ce) => {
      if (L.has(ce))
        throw new Error("Serialize Error: Duplicate key: " + ce);
      L.add(ce);
    }), W.concat(oe);
  }, []), J = A.unknownKeyVals ? A.unknownKeyVals.filter((W) => !L.has(W.key.toString("hex"))) : [];
  return K.concat(J).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: A, inputs: B, outputs: L }) {
  return {
    globalKeyVals: keyValsFromMap(A, convert.globals),
    inputKeyVals: B.map((K) => keyValsFromMap(K, convert.inputs)),
    outputKeyVals: L.map((K) => keyValsFromMap(K, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(A) {
  function B(L) {
    for (var K in L) A.hasOwnProperty(K) || (A[K] = L[K]);
  }
  Object.defineProperty(A, "__esModule", { value: !0 }), B(fromBuffer), B(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(A) {
  const B = A[0], L = parser_1$1.psbtToKeyVals(B), K = A.slice(1);
  if (K.length === 0) throw new Error("Combine: Nothing to combine");
  const J = getTx(B);
  if (J === void 0)
    throw new Error("Combine: Self missing transaction");
  const W = getKeySet(L.globalKeyVals), V = L.inputKeyVals.map(getKeySet), ne = L.outputKeyVals.map(getKeySet);
  for (const ie of K) {
    const oe = getTx(ie);
    if (oe === void 0 || !oe.toBuffer().equals(J.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const re = parser_1$1.psbtToKeyVals(ie);
    getKeySet(re.globalKeyVals).forEach(
      keyPusher(
        W,
        L.globalKeyVals,
        re.globalKeyVals
      )
    ), re.inputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          V[at],
          L.inputKeyVals[at],
          re.inputKeyVals[at]
        )
      )
    ), re.outputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          ne[at],
          L.outputKeyVals[at],
          re.outputKeyVals[at]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(J, {
    globalMapKeyVals: L.globalKeyVals,
    inputKeyVals: L.inputKeyVals,
    outputKeyVals: L.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(A, B, L) {
  return (K) => {
    if (A.has(K)) return;
    const J = L.filter((W) => W.key.toString("hex") === K)[0];
    B.push(J), A.add(K);
  };
}
function getTx(A) {
  return A.globalMap.unsignedTx;
}
function getKeySet(A) {
  const B = /* @__PURE__ */ new Set();
  return A.forEach((L) => {
    const K = L.key.toString("hex");
    if (B.has(K))
      throw new Error("Combine: KeyValue Map keys should be unique");
    B.add(K);
  }), B;
}
var utils = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 });
  const B = converter;
  function L(Ce, it) {
    const at = Ce[it];
    if (at === void 0) throw new Error(`No input #${it}`);
    return at;
  }
  A.checkForInput = L;
  function K(Ce, it) {
    const at = Ce[it];
    if (at === void 0) throw new Error(`No output #${it}`);
    return at;
  }
  A.checkForOutput = K;
  function J(Ce, it, at) {
    if (Ce.key[0] < at)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (it && it.filter((lt) => lt.key.equals(Ce.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Ce.key.toString("hex")}`);
  }
  A.checkHasKey = J;
  function W(Ce) {
    let it = 0;
    return Object.keys(Ce).forEach((at) => {
      Number(isNaN(Number(at))) && it++;
    }), it;
  }
  A.getEnumLength = W;
  function V(Ce, it) {
    let at = !1;
    if (it.nonWitnessUtxo || it.witnessUtxo) {
      const lt = !!it.redeemScript, ht = !!it.witnessScript, dt = !lt || !!it.finalScriptSig, vt = !ht || !!it.finalScriptWitness, mt = !!it.finalScriptSig || !!it.finalScriptWitness;
      at = dt && vt && mt;
    }
    if (at === !1)
      throw new Error(
        `Input #${Ce} has too much or too little data to clean`
      );
  }
  A.inputCheckUncleanFinalized = V;
  function ne(Ce, it, at, lt) {
    throw new Error(
      `Data for ${Ce} key ${it} is incorrect: Expected ${at} and got ${JSON.stringify(lt)}`
    );
  }
  function ie(Ce) {
    return (it, at) => {
      for (const lt of Object.keys(it)) {
        const ht = it[lt], { canAdd: dt, canAddToArray: vt, check: mt, expected: Pt } = (
          // @ts-ignore
          B[Ce + "s"][lt] || {}
        ), $t = !!vt;
        if (mt)
          if ($t) {
            if (!Array.isArray(ht) || // @ts-ignore
            at[lt] && !Array.isArray(at[lt]))
              throw new Error(`Key type ${lt} must be an array`);
            ht.every(mt) || ne(Ce, lt, Pt, ht);
            const qt = at[lt] || [], At = /* @__PURE__ */ new Set();
            if (!ht.every((bt) => vt(qt, bt, At)))
              throw new Error("Can not add duplicate data to array");
            at[lt] = qt.concat(ht);
          } else {
            if (mt(ht) || ne(Ce, lt, Pt, ht), !dt(at, ht))
              throw new Error(`Can not add duplicate data to ${Ce}`);
            at[lt] = ht;
          }
      }
    };
  }
  A.updateGlobal = ie("global"), A.updateInput = ie("input"), A.updateOutput = ie("output");
  function oe(Ce, it) {
    const at = Ce.length - 1, lt = L(Ce, at);
    A.updateInput(it, lt);
  }
  A.addInputAttributes = oe;
  function re(Ce, it) {
    const at = Ce.length - 1, lt = K(Ce, at);
    A.updateOutput(it, lt);
  }
  A.addOutputAttributes = re;
  function ce(Ce, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return it.writeUInt32LE(Ce, 0), it;
  }
  A.defaultVersionSetter = ce;
  function ke(Ce, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return it.writeUInt32LE(Ce, it.length - 4), it;
  }
  A.defaultLocktimeSetter = ke;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: B
    };
  }
  static fromBase64(B, L) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L) {
    const K = parser_1.psbtFromBuffer(B, L), J = new this(K.globalMap.unsignedTx);
    return Object.assign(J, K), J;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$1.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.updateInput(L, K), this;
  }
  updateOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.updateOutput(L, K), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$1.checkHasKey(
      B,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (J) => this.addUnknownKeyValToInput(K, J)
    ), utils_1$1.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (J) => this.addUnknownKeyValToOutput(K, J)
    ), utils_1$1.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const L = utils_1$1.checkForInput(this.inputs, B);
    utils_1$1.inputCheckUncleanFinalized(B, L);
    for (const K of Object.keys(L))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(K) || delete L[K];
    return this;
  }
  combine(...B) {
    const L = combiner_1.combine([this].concat(B));
    return Object.assign(this, L), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(A) {
  return (B) => {
    try {
      return A({ output: B }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(A) {
  let B = Buffer$1.allocUnsafe(0);
  function L(V) {
    B = Buffer$1.concat([B, Buffer$1.from(V)]);
  }
  function K(V) {
    const ne = B.length, ie = varuint$1.encodingLength(V);
    B = Buffer$1.concat([B, Buffer$1.allocUnsafe(ie)]), varuint$1.encode(V, B, ne);
  }
  function J(V) {
    K(V.length), L(V);
  }
  function W(V) {
    K(V.length), V.forEach(J);
  }
  return W(A), B;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(A, B) {
  const L = (0, crypto_1.hash160)(A), K = A.slice(1, 33), J = bscript$1.decompile(B);
  if (J === null) throw new Error("Unknown script error");
  return J.findIndex((W) => typeof W == "number" ? !1 : W.equals(A) || W.equals(L) || W.equals(K));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(A, B) {
  return pubkeyPositionInScript(A, B) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(A, B) {
  return extractPartialSigs(A).some(
    (K) => signatureBlocksAction(K, bscript$1.signature.decode, B)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(A, B, L) {
  const { hashType: K } = B(A), J = [];
  switch (K & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && J.push("addInput"), K & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      J.push("addOutput"), J.push("setInputSequence");
      break;
  }
  return J.indexOf(L) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(A) {
  let B = [];
  if ((A.partialSig || []).length === 0) {
    if (!A.finalScriptSig && !A.finalScriptWitness) return [];
    B = getPsigsFromInputFinalScripts(A);
  } else
    B = A.partialSig;
  return B.map((L) => L.signature);
}
function getPsigsFromInputFinalScripts(A) {
  const B = A.finalScriptSig ? bscript$1.decompile(A.finalScriptSig) || [] : [], L = A.finalScriptWitness ? bscript$1.decompile(A.finalScriptWitness) || [] : [];
  return B.concat(L).filter((K) => Buffer$1.isBuffer(K) && bscript$1.isCanonicalScriptSignature(K)).map((K) => ({ signature: K }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (A) => A.length === 32 ? A : A.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(A, B, L) {
  const K = findTapLeafToFinalize(
    B,
    A,
    L
  );
  try {
    const W = sortSignatures(B, K).concat(K.script).concat(K.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(W)
    };
  } catch (J) {
    throw new Error(`Can not finalize taproot input #${A}: ${J}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(A, B) {
  const L = B ? Buffer$1.from([B]) : Buffer$1.from([]);
  return Buffer$1.concat([A, L]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(A) {
  return A && !!(A.tapInternalKey || A.tapMerkleRoot || A.tapLeafScript && A.tapLeafScript.length || A.tapBip32Derivation && A.tapBip32Derivation.length || A.witnessUtxo && (0, psbtutils_1$1.isP2TR)(A.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(A, B) {
  return A && !!(A.tapInternalKey || A.tapTree || A.tapBip32Derivation && A.tapBip32Derivation.length || B && (0, psbtutils_1$1.isP2TR)(B));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootInputFields(A, B, L), checkIfTapLeafInTree(A, B, L);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootOutputFields(A, B, L), checkTaprootScriptPubkey(A, B);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(A, B) {
  if (!B.tapTree && !B.tapInternalKey) return;
  const L = B.tapInternalKey || A.tapInternalKey, K = B.tapTree || A.tapTree;
  if (L) {
    const { script: J } = A, W = getTaprootScripPubkey(L, K);
    if (J && !J.equals(W))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(A, B) {
  const L = B && tapTreeFromList(B.leaves), { output: K } = (0, payments_1.p2tr)({
    internalPubkey: A,
    scriptTree: L
  });
  return K;
}
function tweakInternalPubKey(A, B) {
  const L = B.tapInternalKey, K = L && (0, bip341_1$1.tweakKey)(L, B.tapMerkleRoot);
  if (!K)
    throw new Error(
      `Cannot tweak tap internal key for input #${A}. Public key: ${L && L.toString("hex")}`
    );
  return K.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(A) {
  if (!(0, types_1.isTaptree)(A))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(A);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(A = []) {
  return A.length === 1 && A[0].depth === 0 ? {
    output: A[0].script,
    version: A[0].leafVersion
  } : instertLeavesInTree(A);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(A, B) {
  return extractTaprootSigs(A).some(
    (K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, B)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(A) {
  return {
    signature: A.slice(0, 64),
    hashType: A.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(A) {
  const B = [];
  if (A.tapKeySig && B.push(A.tapKeySig), A.tapScriptSig && B.push(...A.tapScriptSig.map((L) => L.signature)), !B.length) {
    const L = getTapKeySigFromWithness(A.finalScriptWitness);
    L && B.push(L);
  }
  return B;
}
function getTapKeySigFromWithness(A) {
  if (!A) return;
  const B = A.slice(2);
  if (B.length === 64 || B.length === 65) return B;
}
function _tapTreeToList(A, B = [], L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return A ? (0, types_1.isTapleaf)(A) ? (B.push({
    depth: L,
    leafVersion: A.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: A.output
  }), B) : (A[0] && _tapTreeToList(A[0], B, L + 1), A[1] && _tapTreeToList(A[1], B, L + 1), B) : [];
}
function instertLeavesInTree(A) {
  let B;
  for (const L of A)
    if (B = instertLeafInTree(L, B), !B) throw new Error("No room left to insert tapleaf in tree");
  return B;
}
function instertLeafInTree(A, B, L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (A.depth === L)
    return B ? void 0 : {
      output: A.script,
      version: A.leafVersion
    };
  if ((0, types_1.isTapleaf)(B)) return;
  const K = instertLeafInTree(A, B && B[0], L + 1);
  if (K) return [K, B && B[1]];
  const J = instertLeafInTree(A, B && B[1], L + 1);
  if (J) return [B && B[0], J];
}
function checkMixedTaprootAndNonTaprootInputFields(A, B, L) {
  const K = isTaprootInput(A) && hasNonTaprootFields(B), J = hasNonTaprootFields(A) && isTaprootInput(B), W = A === B && isTaprootInput(B) && hasNonTaprootFields(B);
  if (K || J || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(A, B, L) {
  const K = isTaprootOutput(A) && hasNonTaprootFields(B), J = hasNonTaprootFields(A) && isTaprootOutput(B), W = A === B && isTaprootOutput(B) && hasNonTaprootFields(B);
  if (K || J || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(A, B, L) {
  if (B.tapMerkleRoot) {
    const K = (B.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    ), J = (A.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    );
    if (!K || !J)
      throw new Error(
        `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
      );
  } else if (A.tapMerkleRoot && !(B.tapLeafScript || []).every(
    (J) => isTapLeafInTree(J, A.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(A, B) {
  if (!B) return !0;
  const L = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    A.controlBlock,
    L
  ).equals(B);
}
function sortSignatures(A, B) {
  const L = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (A.tapScriptSig || []).filter((K) => K.leafHash.equals(L)).map((K) => addPubkeyPositionInScript(B.script, K)).sort((K, J) => J.positionInScript - K.positionInScript).map((K) => K.signature);
}
function addPubkeyPositionInScript(A, B) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        B.pubkey,
        A
      )
    },
    B
  );
}
function findTapLeafToFinalize(A, B, L) {
  if (!A.tapScriptSig || !A.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${B}. No tapleaf script signature provided.`
    );
  const K = (A.tapLeafScript || []).sort((J, W) => J.controlBlock.length - W.controlBlock.length).find(
    (J) => canFinalizeLeaf(J, A.tapScriptSig, L)
  );
  if (!K)
    throw new Error(
      `Can not finalize taproot input #${B}. Signature for tapleaf script not found.`
    );
  return K;
}
function canFinalizeLeaf(A, B, L) {
  const K = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (!L || L.equals(K)) && B.find((W) => W.leafHash.equals(K)) !== void 0;
}
function hasNonTaprootFields(A) {
  return A && !!(A.redeemScript || A.witnessScript || A.bip32Derivation && A.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(B, L = {}) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L = {}) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L = {}) {
    const K = bip174_1.Psbt.fromBuffer(B, transactionFromBuffer), J = new Psbt(L, K);
    return checkTxForDupeIns(J.__CACHE.__TX, J.__CACHE), J;
  }
  constructor(B = {}, L = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = L, this.opts = Object.assign({}, DEFAULT_OPTS, B), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const K = (J, W, V, ne) => Object.defineProperty(J, W, {
      enumerable: V,
      writable: ne
    });
    K(this, "__CACHE", !1, !0), K(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(B) {
    this.setVersion(B);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(B) {
    this.setLocktime(B);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((B) => ({
      hash: (0, bufferutils_1.cloneBuffer)(B.hash),
      index: B.index,
      sequence: B.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((B) => {
      let L;
      try {
        L = (0, address_1.fromOutputScript)(
          B.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(B.script),
        value: B.value,
        address: L
      };
    });
  }
  combine(...B) {
    return this.data.combine(...B.map((L) => L.data)), this;
  }
  clone() {
    const B = Psbt.fromBuffer(this.data.toBuffer());
    return B.opts = JSON.parse(JSON.stringify(this.opts)), B;
  }
  setMaximumFeeRate(B) {
    check32Bit(B), this.opts.maximumFeeRate = B;
  }
  setVersion(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const L = this.__CACHE;
    return L.__TX.version = B, L.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const L = this.__CACHE;
    return L.__TX.locktime = B, L.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(B, L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const K = this.__CACHE;
    if (K.__TX.ins.length <= B)
      throw new Error("Input index too high");
    return K.__TX.ins[B].sequence = L, K.__EXTRACTED_TX = void 0, this;
  }
  addInputs(B) {
    return B.forEach((L) => this.addInput(L)), this;
  }
  addInput(B) {
    if (arguments.length > 1 || !B || B.hash === void 0 || B.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(B, B, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), B.witnessScript && checkInvalidP2WSH(B.witnessScript);
    const L = this.__CACHE;
    this.data.addInput(B);
    const K = L.__TX.ins[L.__TX.ins.length - 1];
    checkTxInputCache(L, K);
    const J = this.data.inputs.length - 1, W = this.data.inputs[J];
    return W.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, W, J), L.__FEE = void 0, L.__FEE_RATE = void 0, L.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(B) {
    return B.forEach((L) => this.addOutput(L)), this;
  }
  addOutput(B) {
    if (arguments.length > 1 || !B || B.value === void 0 || B.address === void 0 && B.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: L } = B;
    if (typeof L == "string") {
      const { network: J } = this.opts, W = (0, address_1.toOutputScript)(L, J);
      B = Object.assign({}, B, { script: W });
    }
    (0, bip371_1.checkTaprootOutputFields)(B, B, "addOutput");
    const K = this.__CACHE;
    return this.data.addOutput(B), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(B) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const L = this.__CACHE;
    if (B || checkFees(this, L, this.opts), L.__EXTRACTED_TX) return L.__EXTRACTED_TX;
    const K = L.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, K, L, !0), K;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((B) => this.finalizeInput(B)), this;
  }
  finalizeInput(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(K) ? this._finalizeTaprootInput(
      B,
      K,
      void 0,
      L
    ) : this._finalizeInput(B, K, L);
  }
  finalizeTaprootInput(B, L, K = bip371_1.tapScriptFinalizer) {
    const J = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(J))
      return this._finalizeTaprootInput(
        B,
        J,
        L,
        K
      );
    throw new Error(`Cannot finalize input #${B}. Not Taproot.`);
  }
  _finalizeInput(B, L, K = getFinalScripts) {
    const { script: J, isP2SH: W, isP2WSH: V, isSegwit: ne } = getScriptFromInput(
      B,
      L,
      this.__CACHE
    );
    if (!J) throw new Error(`No script found for input #${B}`);
    checkPartialSigSighashes(L);
    const { finalScriptSig: ie, finalScriptWitness: oe } = K(
      B,
      L,
      J,
      ne,
      W,
      V
    );
    if (ie && this.data.updateInput(B, { finalScriptSig: ie }), oe && this.data.updateInput(B, { finalScriptWitness: oe }), !ie && !oe)
      throw new Error(`Unknown error finalizing input #${B}`);
    return this.data.clearFinalizedInput(B), this;
  }
  _finalizeTaprootInput(B, L, K, J = bip371_1.tapScriptFinalizer) {
    if (!L.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${B}. Missing withness utxo.`
      );
    if (L.tapKeySig) {
      const W = payments.p2tr({
        output: L.witnessUtxo.script,
        signature: L.tapKeySig
      }), V = (0, psbtutils_1.witnessStackToScriptWitness)(
        W.witness
      );
      this.data.updateInput(B, { finalScriptWitness: V });
    } else {
      const { finalScriptWitness: W } = J(
        B,
        L,
        K
      );
      this.data.updateInput(B, { finalScriptWitness: W });
    }
    return this.data.clearFinalizedInput(B), this;
  }
  getInputType(B) {
    const L = (0, utils_1.checkForInput)(this.data.inputs, B), K = getScriptFromUtxo(B, L, this.__CACHE), J = getMeaningfulScript(
      K,
      B,
      "input",
      L.redeemScript || redeemFromFinalScriptSig(L.finalScriptSig),
      L.witnessScript || redeemFromFinalWitnessScript(L.finalScriptWitness)
    ), W = J.type === "raw" ? "" : J.type + "-", V = classifyScript(J.meaningfulScript);
    return W + V;
  }
  inputHasPubkey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return pubkeyInInput(L, K, B, this.__CACHE);
  }
  inputHasHDKey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B), J = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(J);
  }
  outputHasPubkey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B);
    return pubkeyInOutput(L, K, B, this.__CACHE);
  }
  outputHasHDKey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B), J = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(J);
  }
  validateSignaturesOfAllInputs(B) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (K) => this.validateSignaturesOfInput(K, B)
    ).reduce((K, J) => J === !0 && K, !0);
  }
  validateSignaturesOfInput(B, L, K) {
    const J = this.data.inputs[B];
    return (0, bip371_1.isTaprootInput)(J) ? this.validateSignaturesOfTaprootInput(
      B,
      L,
      K
    ) : this._validateSignaturesOfInput(B, L, K);
  }
  _validateSignaturesOfInput(B, L, K) {
    const J = this.data.inputs[B], W = (J || {}).partialSig;
    if (!J || !W || W.length < 1)
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    const V = K ? W.filter((ce) => ce.pubkey.equals(K)) : W;
    if (V.length < 1) throw new Error("No signatures for this pubkey");
    const ne = [];
    let ie, oe, re;
    for (const ce of V) {
      const ke = bscript.signature.decode(ce.signature), { hash: Ce, script: it } = re !== ke.hashType ? getHashForSig(
        B,
        Object.assign({}, J, { sighashType: ke.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ie, script: oe };
      re = ke.hashType, ie = Ce, oe = it, checkScriptForPubkey(ce.pubkey, it, "verify"), ne.push(L(ce.pubkey, Ce, ke.signature));
    }
    return ne.every((ce) => ce === !0);
  }
  validateSignaturesOfTaprootInput(B, L, K) {
    const J = this.data.inputs[B], W = (J || {}).tapKeySig, V = (J || {}).tapScriptSig;
    if (!J && !W && !(V && !V.length))
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    K = K && (0, bip371_1.toXOnly)(K);
    const ne = K ? getTaprootHashesForSig(
      B,
      J,
      this.data.inputs,
      K,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      B,
      J,
      this.data.inputs,
      this.__CACHE
    );
    if (!ne.length) throw new Error("No signatures for this pubkey");
    const ie = ne.find((re) => !re.leafHash);
    let oe = 0;
    if (W && ie) {
      if (!L(
        ie.pubkey,
        ie.hash,
        trimTaprootSig(W)
      )) return !1;
      oe++;
    }
    if (V)
      for (const re of V) {
        const ce = ne.find((ke) => re.pubkey.equals(ke.pubkey));
        if (ce) {
          if (!L(
            re.pubkey,
            ce.hash,
            trimTaprootSig(re.signature)
          )) return !1;
          oe++;
        }
      }
    return oe > 0;
  }
  signAllInputsHD(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!B || !B.publicKey || !B.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const K = [];
    for (const J of range(this.data.inputs.length))
      try {
        this.signInputHD(J, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((K, J) => {
      if (!B || !B.publicKey || !B.fingerprint)
        return J(new Error("Need HDSigner to sign input"));
      const W = [], V = [];
      for (const ne of range(this.data.inputs.length))
        V.push(
          this.signInputHDAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(V).then(() => {
        if (W.every((ne) => ne === !1))
          return J(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInputHD(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(B, this.data.inputs, L).forEach((W) => this.signInput(B, W, K)), this;
  }
  signInputHDAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((J, W) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return W(new Error("Need HDSigner to sign input"));
      const ne = getSignersFromHD(B, this.data.inputs, L).map(
        (ie) => this.signInputAsync(B, ie, K)
      );
      return Promise.all(ne).then(() => {
        J();
      }).catch(W);
    });
  }
  signAllInputs(B, L) {
    if (!B || !B.publicKey)
      throw new Error("Need Signer to sign input");
    const K = [];
    for (const J of range(this.data.inputs.length))
      try {
        this.signInput(J, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(B, L) {
    return new Promise((K, J) => {
      if (!B || !B.publicKey)
        return J(new Error("Need Signer to sign input"));
      const W = [], V = [];
      for (const [ne] of this.data.inputs.entries())
        V.push(
          this.signInputAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(V).then(() => {
        if (W.every((ne) => ne === !1))
          return J(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInput(B, L, K) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const J = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInput(
      B,
      J,
      L,
      void 0,
      K
    ) : this._signInput(B, L, K);
  }
  signTaprootInput(B, L, K, J) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const W = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(W))
      return this._signTaprootInput(
        B,
        W,
        L,
        K,
        J
      );
    throw new Error(`Input #${B} is not of type Taproot.`);
  }
  _signInput(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    ), V = [
      {
        pubkey: L.publicKey,
        signature: bscript.signature.encode(L.sign(J), W)
      }
    ];
    return this.data.updateInput(B, { partialSig: V }), this;
  }
  _signTaprootInput(B, L, K, J, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const V = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      J,
      W
    ), ne = V.filter((oe) => !oe.leafHash).map(
      (oe) => (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(oe.hash),
        L.sighashType
      )
    )[0], ie = V.filter((oe) => !!oe.leafHash).map((oe) => ({
      pubkey: (0, bip371_1.toXOnly)(K.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(oe.hash),
        L.sighashType
      ),
      leafHash: oe.leafHash
    }));
    return ne && this.data.updateInput(B, { tapKeySig: ne }), ie.length && this.data.updateInput(B, { tapScriptSig: ie }), this;
  }
  signInputAsync(B, L, K) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const J = (0, utils_1.checkForInput)(this.data.inputs, B);
      return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInputAsync(
        B,
        J,
        L,
        void 0,
        K
      ) : this._signInputAsync(B, L, K);
    });
  }
  signTaprootInputAsync(B, L, K, J) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const W = (0, utils_1.checkForInput)(this.data.inputs, B);
      if ((0, bip371_1.isTaprootInput)(W))
        return this._signTaprootInputAsync(
          B,
          W,
          L,
          K,
          J
        );
      throw new Error(`Input #${B} is not of type Taproot.`);
    });
  }
  _signInputAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    );
    return Promise.resolve(L.sign(J)).then((V) => {
      const ne = [
        {
          pubkey: L.publicKey,
          signature: bscript.signature.encode(V, W)
        }
      ];
      this.data.updateInput(B, { partialSig: ne });
    });
  }
  async _signTaprootInputAsync(B, L, K, J, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const V = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      J,
      W
    ), ne = [], ie = V.filter((re) => !re.leafHash)[0];
    if (ie) {
      const re = Promise.resolve(
        K.signSchnorr(ie.hash)
      ).then((ce) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          ce,
          L.sighashType
        )
      }));
      ne.push(re);
    }
    const oe = V.filter((re) => !!re.leafHash);
    if (oe.length) {
      const re = oe.map((ce) => Promise.resolve(K.signSchnorr(ce.hash)).then(
        (ke) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(K.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              ke,
              L.sighashType
            ),
            leafHash: ce.leafHash
          }
        ] })
      ));
      ne.push(...re);
    }
    return Promise.all(ne).then((re) => {
      re.forEach((ce) => this.data.updateInput(B, ce));
    });
  }
  checkTaprootHashesForSig(B, L, K, J, W) {
    if (typeof K.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${B}.`
      );
    const V = getTaprootHashesForSig(
      B,
      L,
      this.data.inputs,
      K.publicKey,
      this.__CACHE,
      J,
      W
    );
    if (!V || !V.length)
      throw new Error(
        `Can not sign for input #${B} with the key ${K.publicKey.toString(
          "hex"
        )}`
      );
    return V;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(B) {
    return this.data.updateGlobal(B), this;
  }
  updateInput(B, L) {
    return L.witnessScript && checkInvalidP2WSH(L.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[B],
      L,
      "updateInput"
    ), this.data.updateInput(B, L), L.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[B],
      B
    ), this;
  }
  updateOutput(B, L) {
    const K = this.data.outputs[B];
    return (0, bip371_1.checkTaprootOutputFields)(
      K,
      L,
      "updateOutput"
    ), this.data.updateOutput(B, L), this;
  }
  addUnknownKeyValToGlobal(B) {
    return this.data.addUnknownKeyValToGlobal(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    return this.data.addUnknownKeyValToInput(B, L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    return this.data.addUnknownKeyValToOutput(B, L), this;
  }
  clearFinalizedInput(B) {
    return this.data.clearFinalizedInput(B), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (A) => new PsbtTransaction(A);
class PsbtTransaction {
  constructor(B = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(B), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(B) {
    if (B.hash === void 0 || B.index === void 0 || !Buffer$1.isBuffer(B.hash) && typeof B.hash != "string" || typeof B.index != "number")
      throw new Error("Error adding input.");
    const L = typeof B.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash, "hex")) : B.hash;
    this.tx.addInput(L, B.index, B.sequence);
  }
  addOutput(B) {
    if (B.script === void 0 || B.value === void 0 || !Buffer$1.isBuffer(B.script) || typeof B.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(B.script, B.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(A, B, L) {
  switch (L) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, A.partialSig);
    case "multisig":
      const K = payments.p2ms({ output: B });
      return hasSigs(K.m, A.partialSig, K.pubkeys);
    default:
      return !1;
  }
}
function checkCache(A) {
  if (A.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(A, B, L) {
  if (!B) return !1;
  let K;
  if (L ? K = L.map((J) => {
    const W = compressPubkey(J);
    return B.find((V) => V.pubkey.equals(W));
  }).filter((J) => !!J) : K = B, K.length > A) throw new Error("Too many signatures");
  return K.length === A;
}
function isFinalized(A) {
  return !!A.finalScriptSig || !!A.finalScriptWitness;
}
function bip32DerivationIsMine(A) {
  return (B) => !(!B.masterFingerprint.equals(A.fingerprint) || !A.derivePath(B.path).publicKey.equals(B.pubkey));
}
function check32Bit(A) {
  if (typeof A != "number" || A !== Math.floor(A) || A > 4294967295 || A < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(A, B, L) {
  const K = B.__FEE_RATE || A.getFeeRate(), J = B.__EXTRACTED_TX.virtualSize(), W = K * J;
  if (K >= L.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(W / 1e8).toFixed(8)} in fees, which is ${K} satoshi per byte for a transaction with a VSize of ${J} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(A, B) {
  A.forEach((L) => {
    if ((0, bip371_1.isTaprootInput)(L) ? (0, bip371_1.checkTaprootInputForSigs)(L, B) : (0, psbtutils_1.checkInputForSig)(L, B))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(A) {
  if (!A.sighashType || !A.partialSig) return;
  const { partialSig: B, sighashType: L } = A;
  B.forEach((K) => {
    const { hashType: J } = bscript.signature.decode(K.signature);
    if (L !== J)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(A, B, L) {
  if (!(0, psbtutils_1.pubkeyInScript)(A, B))
    throw new Error(
      `Can not ${L} for this input with the key ${A.toString("hex")}`
    );
}
function checkTxEmpty(A) {
  if (!A.ins.every(
    (L) => L.script && L.script.length === 0 && L.witness && L.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(A, B) {
  A.ins.forEach((L) => {
    checkTxInputCache(B, L);
  });
}
function checkTxInputCache(A, B) {
  const L = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash)).toString("hex") + ":" + B.index;
  if (A.__TX_IN_CACHE[L]) throw new Error("Duplicate input detected.");
  A.__TX_IN_CACHE[L] = 1;
}
function scriptCheckerFactory(A, B) {
  return (L, K, J, W) => {
    const V = A({
      redeem: { output: J }
    }).output;
    if (!K.equals(V))
      throw new Error(
        `${B} for ${W} #${L} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(A, B, L, K) {
  if (!L.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${B}`);
  if (A === "__FEE_RATE" && K.__FEE_RATE) return K.__FEE_RATE;
  if (A === "__FEE" && K.__FEE) return K.__FEE;
  let J, W = !0;
  if (K.__EXTRACTED_TX ? (J = K.__EXTRACTED_TX, W = !1) : J = K.__TX.clone(), inputFinalizeGetAmts(L, J, K, W), A === "__FEE_RATE") return K.__FEE_RATE;
  if (A === "__FEE") return K.__FEE;
}
function getFinalScripts(A, B, L, K, J, W) {
  const V = classifyScript(L);
  if (!canFinalize(B, L, V))
    throw new Error(`Can not finalize input #${A}`);
  return prepareFinalScripts(
    L,
    V,
    B.partialSig,
    K,
    J,
    W
  );
}
function prepareFinalScripts(A, B, L, K, J, W) {
  let V, ne;
  const ie = getPayment(A, B, L), oe = W ? payments.p2wsh({ redeem: ie }) : null, re = J ? payments.p2sh({ redeem: oe || ie }) : null;
  return K ? (oe ? ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    oe.witness
  ) : ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    ie.witness
  ), re && (V = re.input)) : re ? V = re.input : V = ie.input, {
    finalScriptSig: V,
    finalScriptWitness: ne
  };
}
function getHashAndSighashType(A, B, L, K, J) {
  const W = (0, utils_1.checkForInput)(A, B), { hash: V, sighashType: ne, script: ie } = getHashForSig(
    B,
    W,
    K,
    !1,
    J
  );
  return checkScriptForPubkey(L, ie, "sign"), {
    hash: V,
    sighashType: ne
  };
}
function getHashForSig(A, B, L, K, J) {
  const W = L.__TX, V = B.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(V, J);
  let ne, ie;
  if (B.nonWitnessUtxo) {
    const ce = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), ke = W.ins[A].hash, Ce = ce.getHash();
    if (!ke.equals(Ce))
      throw new Error(
        `Non-witness UTXO hash for input #${A} doesn't match the hash specified in the prevout`
      );
    const it = W.ins[A].index;
    ie = ce.outs[it];
  } else if (B.witnessUtxo)
    ie = B.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: oe, type: re } = getMeaningfulScript(
    ie.script,
    A,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(re) >= 0)
    ne = W.hashForWitnessV0(
      A,
      oe,
      ie.value,
      V
    );
  else if ((0, psbtutils_1.isP2WPKH)(oe)) {
    const ce = payments.p2pkh({
      hash: oe.slice(2)
    }).output;
    ne = W.hashForWitnessV0(
      A,
      ce,
      ie.value,
      V
    );
  } else {
    if (B.nonWitnessUtxo === void 0 && L.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${A} has witnessUtxo but non-segwit script: ${oe.toString("hex")}`
      );
    !K && L.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ne = W.hashForSignature(
      A,
      oe,
      V
    );
  }
  return {
    script: oe,
    sighashType: V,
    hash: ne
  };
}
function getAllTaprootHashesForSig(A, B, L, K) {
  const J = [];
  if (B.tapInternalKey) {
    const V = getPrevoutTaprootKey(A, B, K);
    V && J.push(V);
  }
  if (B.tapScriptSig) {
    const V = B.tapScriptSig.map((ne) => ne.pubkey);
    J.push(...V);
  }
  return J.map(
    (V) => getTaprootHashesForSig(A, B, L, V, K)
  ).flat();
}
function getPrevoutTaprootKey(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return (0, psbtutils_1.isP2TR)(K) ? K.subarray(2, 34) : null;
}
function trimTaprootSig(A) {
  return A.length === 64 ? A : A.subarray(0, 64);
}
function getTaprootHashesForSig(A, B, L, K, J, W, V) {
  const ne = J.__TX, ie = B.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ie, V);
  const oe = L.map(
    (it, at) => getScriptAndAmountFromUtxo(at, it, J)
  ), re = oe.map((it) => it.script), ce = oe.map((it) => it.value), ke = [];
  if (B.tapInternalKey && !W) {
    const it = getPrevoutTaprootKey(A, B, J) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(K).equals(it)) {
      const at = ne.hashForWitnessV1(
        A,
        re,
        ce,
        ie
      );
      ke.push({ pubkey: K, hash: at });
    }
  }
  const Ce = (B.tapLeafScript || []).filter((it) => (0, psbtutils_1.pubkeyInScript)(K, it.script)).map((it) => {
    const at = (0, bip341_1.tapleafHash)({
      output: it.script,
      version: it.leafVersion
    });
    return Object.assign({ hash: at }, it);
  }).filter(
    (it) => !W || W.equals(it.hash)
  ).map((it) => {
    const at = ne.hashForWitnessV1(
      A,
      re,
      ce,
      ie,
      it.hash
    );
    return {
      pubkey: K,
      hash: at,
      leafHash: it.hash
    };
  });
  return ke.concat(Ce);
}
function checkSighashTypeAllowed(A, B) {
  if (B && B.indexOf(A) < 0) {
    const L = sighashTypeToString(A);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${L}`
    );
  }
}
function getPayment(A, B, L) {
  let K;
  switch (B) {
    case "multisig":
      const J = getSortedSigs(A, L);
      K = payments.p2ms({
        output: A,
        signatures: J
      });
      break;
    case "pubkey":
      K = payments.p2pk({
        output: A,
        signature: L[0].signature
      });
      break;
    case "pubkeyhash":
      K = payments.p2pkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
    case "witnesspubkeyhash":
      K = payments.p2wpkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
  }
  return K;
}
function getScriptFromInput(A, B, L) {
  const K = L.__TX, J = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (J.isP2SH = !!B.redeemScript, J.isP2WSH = !!B.witnessScript, B.witnessScript)
    J.script = B.witnessScript;
  else if (B.redeemScript)
    J.script = B.redeemScript;
  else if (B.nonWitnessUtxo) {
    const W = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), V = K.ins[A].index;
    J.script = W.outs[V].script;
  } else B.witnessUtxo && (J.script = B.witnessUtxo.script);
  return (B.witnessScript || (0, psbtutils_1.isP2WPKH)(J.script)) && (J.isSegwit = !0), J;
}
function getSignersFromHD(A, B, L) {
  const K = (0, utils_1.checkForInput)(B, A);
  if (!K.bip32Derivation || K.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const J = K.bip32Derivation.map((V) => {
    if (V.masterFingerprint.equals(L.fingerprint))
      return V;
  }).filter((V) => !!V);
  if (J.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return J.map((V) => {
    const ne = L.derivePath(V.path);
    if (!V.pubkey.equals(ne.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ne;
  });
}
function getSortedSigs(A, B) {
  return payments.p2ms({ output: A }).pubkeys.map((K) => (B.filter((J) => J.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(A) {
  let B = 0;
  function L(V) {
    return B += V, A.slice(B - V, B);
  }
  function K() {
    const V = varuint.decode(A, B);
    return B += varuint.decode.bytes, V;
  }
  function J() {
    return L(K());
  }
  function W() {
    const V = K(), ne = [];
    for (let ie = 0; ie < V; ie++) ne.push(J());
    return ne;
  }
  return W();
}
function sighashTypeToString(A) {
  let B = A & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (A & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      B += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      B += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      B += "SIGHASH_NONE";
      break;
  }
  return B;
}
function addNonWitnessTxCache(A, B, L) {
  A.__NON_WITNESS_UTXO_BUF_CACHE[L] = B.nonWitnessUtxo;
  const K = transaction_1.Transaction.fromBuffer(B.nonWitnessUtxo);
  A.__NON_WITNESS_UTXO_TX_CACHE[L] = K;
  const J = A, W = L;
  delete B.nonWitnessUtxo, Object.defineProperty(B, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const V = J.__NON_WITNESS_UTXO_BUF_CACHE[W], ne = J.__NON_WITNESS_UTXO_TX_CACHE[W];
      if (V !== void 0)
        return V;
      {
        const ie = ne.toBuffer();
        return J.__NON_WITNESS_UTXO_BUF_CACHE[W] = ie, ie;
      }
    },
    set(V) {
      J.__NON_WITNESS_UTXO_BUF_CACHE[W] = V;
    }
  });
}
function inputFinalizeGetAmts(A, B, L, K) {
  let J = 0;
  A.forEach((ie, oe) => {
    if (K && ie.finalScriptSig && (B.ins[oe].script = ie.finalScriptSig), K && ie.finalScriptWitness && (B.ins[oe].witness = scriptWitnessToWitnessStack(
      ie.finalScriptWitness
    )), ie.witnessUtxo)
      J += ie.witnessUtxo.value;
    else if (ie.nonWitnessUtxo) {
      const re = nonWitnessUtxoTxFromCache(L, ie, oe), ce = B.ins[oe].index, ke = re.outs[ce];
      J += ke.value;
    }
  });
  const W = B.outs.reduce((ie, oe) => ie + oe.value, 0), V = J - W;
  if (V < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ne = B.virtualSize();
  L.__FEE = V, L.__EXTRACTED_TX = B, L.__FEE_RATE = Math.floor(V / ne);
}
function nonWitnessUtxoTxFromCache(A, B, L) {
  const K = A.__NON_WITNESS_UTXO_TX_CACHE;
  return K[L] || addNonWitnessTxCache(A, B, L), K[L];
}
function getScriptFromUtxo(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return K;
}
function getScriptAndAmountFromUtxo(A, B, L) {
  if (B.witnessUtxo !== void 0)
    return {
      script: B.witnessUtxo.script,
      value: B.witnessUtxo.value
    };
  if (B.nonWitnessUtxo !== void 0) {
    const J = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ).outs[L.__TX.ins[A].index];
    return { script: J.script, value: J.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(A, B, L, K) {
  const J = getScriptFromUtxo(L, B, K), { meaningfulScript: W } = getMeaningfulScript(
    J,
    L,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function pubkeyInOutput(A, B, L, K) {
  const J = K.__TX.outs[L].script, { meaningfulScript: W } = getMeaningfulScript(
    J,
    L,
    "output",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function redeemFromFinalScriptSig(A) {
  if (!A) return;
  const B = bscript.decompile(A);
  if (!B) return;
  const L = B[B.length - 1];
  if (!(!Buffer$1.isBuffer(L) || isPubkeyLike(L) || isSigLike(L) || !bscript.decompile(L)))
    return L;
}
function redeemFromFinalWitnessScript(A) {
  if (!A) return;
  const B = scriptWitnessToWitnessStack(A), L = B[B.length - 1];
  if (!(isPubkeyLike(L) || !bscript.decompile(L)))
    return L;
}
function compressPubkey(A) {
  if (A.length === 65) {
    const B = A[64] & 1, L = A.slice(0, 33);
    return L[0] = 2 | B, L;
  }
  return A.slice();
}
function isPubkeyLike(A) {
  return A.length === 33 && bscript.isCanonicalPubKey(A);
}
function isSigLike(A) {
  return bscript.isCanonicalScriptSignature(A);
}
function getMeaningfulScript(A, B, L, K, J) {
  const W = (0, psbtutils_1.isP2SHScript)(A), V = W && K && (0, psbtutils_1.isP2WSHScript)(K), ne = (0, psbtutils_1.isP2WSHScript)(A);
  if (W && K === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ne || V) && J === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ie;
  return V ? (ie = J, checkRedeemScript(B, A, K, L), checkWitnessScript(B, K, J, L), checkInvalidP2WSH(ie)) : ne ? (ie = J, checkWitnessScript(B, A, J, L), checkInvalidP2WSH(ie)) : W ? (ie = K, checkRedeemScript(B, A, K, L)) : ie = A, {
    meaningfulScript: ie,
    type: V ? "p2sh-p2wsh" : W ? "p2sh" : ne ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(A) {
  if ((0, psbtutils_1.isP2WPKH)(A) || (0, psbtutils_1.isP2SHScript)(A))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(A) {
  return (0, psbtutils_1.isP2WPKH)(A) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(A) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(A) ? "multisig" : (0, psbtutils_1.isP2PK)(A) ? "pubkey" : "nonstandard";
}
function range(A) {
  return [...Array(A).keys()];
}
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.initEccLib = A.Transaction = A.opcodes = A.Psbt = A.Block = A.script = A.payments = A.networks = A.crypto = A.address = void 0;
  const B = requireAddress();
  A.address = B;
  const L = crypto$1;
  A.crypto = L;
  const K = networks;
  A.networks = K;
  const J = requirePayments();
  A.payments = J;
  const W = requireScript();
  A.script = W;
  var V = block;
  Object.defineProperty(A, "Block", {
    enumerable: !0,
    get: function() {
      return V.Block;
    }
  });
  var ne = psbt$1;
  Object.defineProperty(A, "Psbt", {
    enumerable: !0,
    get: function() {
      return ne.Psbt;
    }
  });
  var ie = ops;
  Object.defineProperty(A, "opcodes", {
    enumerable: !0,
    get: function() {
      return ie.OPS;
    }
  });
  var oe = transaction;
  Object.defineProperty(A, "Transaction", {
    enumerable: !0,
    get: function() {
      return oe.Transaction;
    }
  });
  var re = ecc_lib;
  Object.defineProperty(A, "initEccLib", {
    enumerable: !0,
    get: function() {
      return re.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: A, publicKey: B, format: L, wallet: K } = useWallie(), [J, W] = useState(null), [V, ne] = useState(!1);
  return { sign: useCallback(
    async (oe, re, ce) => {
      ne(!0);
      try {
        if (W(null), !L || !B || !K)
          throw new Error("No wallet is connected");
        const ke = src$1.Psbt.fromBase64(re), Ce = await signPsbt({
          address: oe,
          wallet: K,
          network: A,
          psbt: ke,
          options: ce
        });
        return ne(!1), Ce;
      } catch (ke) {
        throw W(ke.message), ne(!1), ke;
      }
    },
    [L, A, B, K]
  ), error: J, loading: V };
}
function leatherPaymentTypeFromFormat(A) {
  if (A === "segwit")
    return LeatherAddressType.P2WPKH;
  if (A === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: A,
  wallet: B,
  address: L,
  network: K,
  format: J
}) {
  if (B === Wallet.MAGICEDEN) {
    const { base64: W } = await signMessage$1(A, L, K);
    return W;
  }
  if (B === Wallet.UNISAT) {
    const { base64: W } = await signMessage$2(A, "bip322-simple");
    return W;
  }
  if (B === Wallet.XVERSE) {
    const { base64: W } = await signMessage$3(A, L, K);
    return W;
  }
  if (B === Wallet.LEATHER) {
    const W = leatherPaymentTypeFromFormat(J), { base64: V } = await signMessage$4(A, {
      paymentType: W,
      network: K
    });
    return V;
  }
  if (B === Wallet.OKX) {
    const { base64: W } = await signMessage$5(A, "bip322-simple", K);
    return W;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: A,
    wallet: B,
    publicKey: L,
    format: K,
    address: J
  } = useWallie(), [W, V] = useState(null), [ne, ie] = useState(!1);
  return { signMsg: useCallback(
    async (re, ce) => {
      ie(!0);
      try {
        if (V(null), !K || !L || !B)
          throw new Error("No wallet is connected");
        if (J.ordinals !== re && J.payments !== re)
          throw new Error("Address supplied is not connected address");
        const ke = await signMessage({
          address: re,
          wallet: B,
          message: ce,
          network: A,
          format: J.ordinals === re ? K.ordinals : K.payments
        });
        return ie(!1), ke;
      } catch (ke) {
        throw V(ke.message), ie(!1), ke;
      }
    },
    [K, A, L, B, J]
  ), error: W, isLoading: ne };
}
export {
  Network,
  OrdConnectKit,
  SelectWalletModal,
  Wallet,
  WallieProvider,
  useBalance,
  useSend,
  useSendBtc,
  useSendV2,
  useSign,
  useSignMessage,
  useWallie
};
