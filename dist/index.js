(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=Poppins:wght@400;500;600;700&display=swap";/*! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.wallie-fixed{position:fixed}.wallie-relative{position:relative}.wallie-inset-0{top:0;right:0;bottom:0;left:0}.wallie-z-10{z-index:10}.wallie-z-50{z-index:50}.wallie-mx-auto{margin-left:auto;margin-right:auto}.wallie--mt-1{margin-top:-.25rem}.wallie-mb-1{margin-bottom:.25rem}.wallie-ml-auto{margin-left:auto}.wallie-block{display:block}.wallie-inline-block{display:inline-block}.wallie-flex{display:flex}.wallie-hidden{display:none}.wallie-h-\\[19px\\]{height:19px}.wallie-h-screen{height:100vh}.wallie-min-h-full{min-height:100%}.wallie-w-5{width:1.25rem}.wallie-w-6{width:1.5rem}.wallie-w-\\[19px\\]{width:19px}.wallie-w-full{width:100%}.wallie-scale-100{--tw-scale-x:1;--tw-scale-y:1}.wallie-scale-100,.wallie-scale-95{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wallie-scale-95{--tw-scale-x:.95;--tw-scale-y:.95}.wallie-transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wallie-flex-row{flex-direction:row}.wallie-flex-col{flex-direction:column}.wallie-items-end{align-items:flex-end}.wallie-items-center{align-items:center}.wallie-justify-center{justify-content:center}.wallie-justify-between{justify-content:space-between}.wallie-space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.wallie-space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(1rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(1rem*var(--tw-space-x-reverse))}.wallie-space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(1rem*var(--tw-space-y-reverse));margin-top:calc(1rem*(1 - var(--tw-space-y-reverse)))}.wallie-overflow-hidden{overflow:hidden}.wallie-overflow-y-auto{overflow-y:auto}.wallie-break-all{word-break:break-all}.wallie-rounded-full{border-radius:9999px}.wallie-rounded-lg{border-radius:.5rem}.wallie-bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.wallie-bg-ord-blue-600{--tw-bg-opacity:1;background-color:rgb(23 30 45/var(--tw-bg-opacity))}.wallie-bg-ord-light-blue{--tw-bg-opacity:1;background-color:rgb(48 55 70/var(--tw-bg-opacity))}.wallie-bg-ord-light-blue-400{--tw-bg-opacity:1;background-color:rgb(73 82 102/var(--tw-bg-opacity))}.wallie-bg-ord-orange{--tw-bg-opacity:1;background-color:rgb(255 108 58/var(--tw-bg-opacity))}.wallie-bg-opacity-90{--tw-bg-opacity:.9}.wallie-p-1{padding:.25rem}.wallie-p-2{padding:.5rem}.wallie-p-4{padding:1rem}.wallie-p-8{padding:2rem}.wallie-px-1{padding-left:.25rem;padding-right:.25rem}.wallie-py-3{padding-bottom:.75rem;padding-top:.75rem}.wallie-pb-4{padding-bottom:1rem}.wallie-pr-2{padding-right:.5rem}.wallie-pr-3{padding-right:.75rem}.wallie-pt-4{padding-top:1rem}.wallie-text-left{text-align:left}.wallie-text-\\[21px\\]{font-size:21px}.wallie-text-lg{font-size:1.125rem;line-height:1.75rem}.wallie-text-sm{font-size:.875rem;line-height:1.25rem}.wallie-font-medium{font-weight:500}.wallie-leading-8{line-height:2rem}.wallie-text-ord-alert{--tw-text-opacity:1;color:rgb(248 242 94/var(--tw-text-opacity))}.wallie-text-ord-blue{--tw-text-opacity:1;color:rgb(17 22 33/var(--tw-text-opacity))}.wallie-text-ord-gray{--tw-text-opacity:1;color:rgb(137 138 149/var(--tw-text-opacity))}.wallie-text-ord-light-blue-400{--tw-text-opacity:1;color:rgb(73 82 102/var(--tw-text-opacity))}.wallie-text-ord-light-gray{--tw-text-opacity:1;color:rgb(217 213 210/var(--tw-text-opacity))}.wallie-opacity-0{opacity:0}.wallie-opacity-100{opacity:1}.wallie-transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-duration-100{transition-duration:.1s}.wallie-duration-200{transition-duration:.2s}.wallie-duration-300{transition-duration:.3s}.wallie-ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.wallie-ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}body,html{font-family:Outfit,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;scroll-behavior:smooth}@media (min-width:640px){.sm\\:wallie-items-center{align-items:center}.sm\\:wallie-p-0{padding:0}}@media (min-width:768px){.md\\:wallie-block{display:block}.md\\:wallie-w-7{width:1.75rem}.md\\:wallie-w-8{width:2rem}.md\\:wallie-w-96{width:24rem}.md\\:wallie-space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.md\\:wallie-bg-opacity-75{--tw-bg-opacity:.75}.md\\:wallie-px-3{padding-left:.75rem}.md\\:wallie-pr-3,.md\\:wallie-px-3{padding-right:.75rem}.md\\:wallie-text-xl{font-size:1.25rem;line-height:1.75rem}}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
import * as C$2 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { BrowserWalletNotInstalledError, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
import { createPortal } from "react-dom";
import { signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
function getDefaultExportFromCjs$1(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(A) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(A, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(A, 0);
  try {
    return cachedSetTimeout(A, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, A, 0);
    } catch {
      return cachedSetTimeout.call(this, A, 0);
    }
  }
}
function runClearTimeout(A) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(A);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(A);
  try {
    return cachedClearTimeout(A);
  } catch {
    try {
      return cachedClearTimeout.call(null, A);
    } catch {
      return cachedClearTimeout.call(this, A);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var A = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var B = queue.length; B; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < B; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, B = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(A);
  }
}
process.nextTick = function(A) {
  var B = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var L = 1; L < arguments.length; L++)
      B[L - 1] = arguments[L];
  queue.push(new Item(A, B)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(A, B) {
  this.fun = A, this.array = B;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(A) {
  return [];
};
process.binding = function(A) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(A) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
function getAugmentedNamespace(A) {
  if (A.__esModule) return A;
  var B = A.default;
  if (typeof B == "function") {
    var L = function K() {
      return this instanceof K ? Reflect.construct(B, arguments, this.constructor) : B.apply(this, arguments);
    };
    L.prototype = B.prototype;
  } else L = {};
  return Object.defineProperty(L, "__esModule", { value: !0 }), Object.keys(A).forEach(function(K) {
    var re = Object.getOwnPropertyDescriptor(A, K);
    Object.defineProperty(L, K, re.get ? re : {
      enumerable: !0,
      get: function() {
        return A[K];
      }
    });
  }), L;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.fragment"), K = Object.prototype.hasOwnProperty, re = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, W = { key: !0, ref: !0, __self: !0, __source: !0 };
  function J(ne, ie, oe) {
    var V, ce = {}, ke = null, Ce = null;
    oe !== void 0 && (ke = "" + oe), ie.key !== void 0 && (ke = "" + ie.key), ie.ref !== void 0 && (Ce = ie.ref);
    for (V in ie) K.call(ie, V) && !W.hasOwnProperty(V) && (ce[V] = ie[V]);
    if (ne && ne.defaultProps) for (V in ie = ne.defaultProps, ie) ce[V] === void 0 && (ce[V] = ie[V]);
    return { $$typeof: B, type: ne, key: ke, ref: Ce, props: ce, _owner: re.current };
  }
  return reactJsxRuntime_production_min.Fragment = L, reactJsxRuntime_production_min.jsx = J, reactJsxRuntime_production_min.jsxs = J, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), re = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), J = Symbol.for("react.provider"), ne = Symbol.for("react.context"), ie = Symbol.for("react.forward_ref"), oe = Symbol.for("react.suspense"), V = Symbol.for("react.suspense_list"), ce = Symbol.for("react.memo"), ke = Symbol.for("react.lazy"), Ce = Symbol.for("react.offscreen"), it = Symbol.iterator, at = "@@iterator";
    function lt(Lt) {
      if (Lt === null || typeof Lt != "object")
        return null;
      var Jt = it && Lt[it] || Lt[at];
      return typeof Jt == "function" ? Jt : null;
    }
    var ht = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function dt(Lt) {
      {
        for (var Jt = arguments.length, er = new Array(Jt > 1 ? Jt - 1 : 0), or = 1; or < Jt; or++)
          er[or - 1] = arguments[or];
        bt("error", Lt, er);
      }
    }
    function bt(Lt, Jt, er) {
      {
        var or = ht.ReactDebugCurrentFrame, vr = or.getStackAddendum();
        vr !== "" && (Jt += "%s", er = er.concat([vr]));
        var Sr = er.map(function(Rr) {
          return String(Rr);
        });
        Sr.unshift("Warning: " + Jt), Function.prototype.apply.call(console[Lt], console, Sr);
      }
    }
    var vt = !1, Bt = !1, At = !1, Nt = !1, $t = !1, mt;
    mt = Symbol.for("react.module.reference");
    function xt(Lt) {
      return !!(typeof Lt == "string" || typeof Lt == "function" || Lt === K || Lt === W || $t || Lt === re || Lt === oe || Lt === V || Nt || Lt === Ce || vt || Bt || At || typeof Lt == "object" && Lt !== null && (Lt.$$typeof === ke || Lt.$$typeof === ce || Lt.$$typeof === J || Lt.$$typeof === ne || Lt.$$typeof === ie || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Lt.$$typeof === mt || Lt.getModuleId !== void 0));
    }
    function wt(Lt, Jt, er) {
      var or = Lt.displayName;
      if (or)
        return or;
      var vr = Jt.displayName || Jt.name || "";
      return vr !== "" ? er + "(" + vr + ")" : er;
    }
    function Oe(Lt) {
      return Lt.displayName || "Context";
    }
    function rt(Lt) {
      if (Lt == null)
        return null;
      if (typeof Lt.tag == "number" && dt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Lt == "function")
        return Lt.displayName || Lt.name || null;
      if (typeof Lt == "string")
        return Lt;
      switch (Lt) {
        case K:
          return "Fragment";
        case L:
          return "Portal";
        case W:
          return "Profiler";
        case re:
          return "StrictMode";
        case oe:
          return "Suspense";
        case V:
          return "SuspenseList";
      }
      if (typeof Lt == "object")
        switch (Lt.$$typeof) {
          case ne:
            var Jt = Lt;
            return Oe(Jt) + ".Consumer";
          case J:
            var er = Lt;
            return Oe(er._context) + ".Provider";
          case ie:
            return wt(Lt, Lt.render, "ForwardRef");
          case ce:
            var or = Lt.displayName || null;
            return or !== null ? or : rt(Lt.type) || "Memo";
          case ke: {
            var vr = Lt, Sr = vr._payload, Rr = vr._init;
            try {
              return rt(Rr(Sr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var pe = Object.assign, nt = 0, ot, st, ut, pt, ft, yt, ct;
    function St() {
    }
    St.__reactDisabledLog = !0;
    function qt() {
      {
        if (nt === 0) {
          ot = console.log, st = console.info, ut = console.warn, pt = console.error, ft = console.group, yt = console.groupCollapsed, ct = console.groupEnd;
          var Lt = {
            configurable: !0,
            enumerable: !0,
            value: St,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Lt,
            log: Lt,
            warn: Lt,
            error: Lt,
            group: Lt,
            groupCollapsed: Lt,
            groupEnd: Lt
          });
        }
        nt++;
      }
    }
    function jt() {
      {
        if (nt--, nt === 0) {
          var Lt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: pe({}, Lt, {
              value: ot
            }),
            info: pe({}, Lt, {
              value: st
            }),
            warn: pe({}, Lt, {
              value: ut
            }),
            error: pe({}, Lt, {
              value: pt
            }),
            group: pe({}, Lt, {
              value: ft
            }),
            groupCollapsed: pe({}, Lt, {
              value: yt
            }),
            groupEnd: pe({}, Lt, {
              value: ct
            })
          });
        }
        nt < 0 && dt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ot = ht.ReactCurrentDispatcher, Tt;
    function Rt(Lt, Jt, er) {
      {
        if (Tt === void 0)
          try {
            throw Error();
          } catch (vr) {
            var or = vr.stack.trim().match(/\n( *(at )?)/);
            Tt = or && or[1] || "";
          }
        return `
` + Tt + Lt;
      }
    }
    var Ut = !1, Gt;
    {
      var Mt = typeof WeakMap == "function" ? WeakMap : Map;
      Gt = new Mt();
    }
    function Pt(Lt, Jt) {
      if (!Lt || Ut)
        return "";
      {
        var er = Gt.get(Lt);
        if (er !== void 0)
          return er;
      }
      var or;
      Ut = !0;
      var vr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Sr;
      Sr = Ot.current, Ot.current = null, qt();
      try {
        if (Jt) {
          var Rr = function() {
            throw Error();
          };
          if (Object.defineProperty(Rr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Rr, []);
            } catch (Lr) {
              or = Lr;
            }
            Reflect.construct(Lt, [], Rr);
          } else {
            try {
              Rr.call();
            } catch (Lr) {
              or = Lr;
            }
            Lt.call(Rr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Lr) {
            or = Lr;
          }
          Lt();
        }
      } catch (Lr) {
        if (Lr && or && typeof Lr.stack == "string") {
          for (var Tr = Lr.stack.split(`
`), Nr = or.stack.split(`
`), qr = Tr.length - 1, Fr = Nr.length - 1; qr >= 1 && Fr >= 0 && Tr[qr] !== Nr[Fr]; )
            Fr--;
          for (; qr >= 1 && Fr >= 0; qr--, Fr--)
            if (Tr[qr] !== Nr[Fr]) {
              if (qr !== 1 || Fr !== 1)
                do
                  if (qr--, Fr--, Fr < 0 || Tr[qr] !== Nr[Fr]) {
                    var Ur = `
` + Tr[qr].replace(" at new ", " at ");
                    return Lt.displayName && Ur.includes("<anonymous>") && (Ur = Ur.replace("<anonymous>", Lt.displayName)), typeof Lt == "function" && Gt.set(Lt, Ur), Ur;
                  }
                while (qr >= 1 && Fr >= 0);
              break;
            }
        }
      } finally {
        Ut = !1, Ot.current = Sr, jt(), Error.prepareStackTrace = vr;
      }
      var jr = Lt ? Lt.displayName || Lt.name : "", Dr = jr ? Rt(jr) : "";
      return typeof Lt == "function" && Gt.set(Lt, Dr), Dr;
    }
    function Kt(Lt, Jt, er) {
      return Pt(Lt, !1);
    }
    function Zt(Lt) {
      var Jt = Lt.prototype;
      return !!(Jt && Jt.isReactComponent);
    }
    function rr(Lt, Jt, er) {
      if (Lt == null)
        return "";
      if (typeof Lt == "function")
        return Pt(Lt, Zt(Lt));
      if (typeof Lt == "string")
        return Rt(Lt);
      switch (Lt) {
        case oe:
          return Rt("Suspense");
        case V:
          return Rt("SuspenseList");
      }
      if (typeof Lt == "object")
        switch (Lt.$$typeof) {
          case ie:
            return Kt(Lt.render);
          case ce:
            return rr(Lt.type, Jt, er);
          case ke: {
            var or = Lt, vr = or._payload, Sr = or._init;
            try {
              return rr(Sr(vr), Jt, er);
            } catch {
            }
          }
        }
      return "";
    }
    var ar = Object.prototype.hasOwnProperty, ur = {}, hr = ht.ReactDebugCurrentFrame;
    function Yt(Lt) {
      if (Lt) {
        var Jt = Lt._owner, er = rr(Lt.type, Lt._source, Jt ? Jt.type : null);
        hr.setExtraStackFrame(er);
      } else
        hr.setExtraStackFrame(null);
    }
    function Ir(Lt, Jt, er, or, vr) {
      {
        var Sr = Function.call.bind(ar);
        for (var Rr in Lt)
          if (Sr(Lt, Rr)) {
            var Tr = void 0;
            try {
              if (typeof Lt[Rr] != "function") {
                var Nr = Error((or || "React class") + ": " + er + " type `" + Rr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Lt[Rr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Nr.name = "Invariant Violation", Nr;
              }
              Tr = Lt[Rr](Jt, Rr, or, er, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (qr) {
              Tr = qr;
            }
            Tr && !(Tr instanceof Error) && (Yt(vr), dt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", or || "React class", er, Rr, typeof Tr), Yt(null)), Tr instanceof Error && !(Tr.message in ur) && (ur[Tr.message] = !0, Yt(vr), dt("Failed %s type: %s", er, Tr.message), Yt(null));
          }
      }
    }
    var lr = Array.isArray;
    function Ar(Lt) {
      return lr(Lt);
    }
    function Br(Lt) {
      {
        var Jt = typeof Symbol == "function" && Symbol.toStringTag, er = Jt && Lt[Symbol.toStringTag] || Lt.constructor.name || "Object";
        return er;
      }
    }
    function dr(Lt) {
      try {
        return Er(Lt), !1;
      } catch {
        return !0;
      }
    }
    function Er(Lt) {
      return "" + Lt;
    }
    function Pr(Lt) {
      if (dr(Lt))
        return dt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Br(Lt)), Er(Lt);
    }
    var br = ht.ReactCurrentOwner, Mr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Or, It, gt;
    gt = {};
    function Et(Lt) {
      if (ar.call(Lt, "ref")) {
        var Jt = Object.getOwnPropertyDescriptor(Lt, "ref").get;
        if (Jt && Jt.isReactWarning)
          return !1;
      }
      return Lt.ref !== void 0;
    }
    function Ct(Lt) {
      if (ar.call(Lt, "key")) {
        var Jt = Object.getOwnPropertyDescriptor(Lt, "key").get;
        if (Jt && Jt.isReactWarning)
          return !1;
      }
      return Lt.key !== void 0;
    }
    function Wt(Lt, Jt) {
      if (typeof Lt.ref == "string" && br.current && Jt && br.current.stateNode !== Jt) {
        var er = rt(br.current.type);
        gt[er] || (dt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', rt(br.current.type), Lt.ref), gt[er] = !0);
      }
    }
    function zt(Lt, Jt) {
      {
        var er = function() {
          Or || (Or = !0, dt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Jt));
        };
        er.isReactWarning = !0, Object.defineProperty(Lt, "key", {
          get: er,
          configurable: !0
        });
      }
    }
    function Vt(Lt, Jt) {
      {
        var er = function() {
          It || (It = !0, dt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Jt));
        };
        er.isReactWarning = !0, Object.defineProperty(Lt, "ref", {
          get: er,
          configurable: !0
        });
      }
    }
    var yr = function(Lt, Jt, er, or, vr, Sr, Rr) {
      var Tr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: B,
        // Built-in properties that belong on the element
        type: Lt,
        key: Jt,
        ref: er,
        props: Rr,
        // Record the component responsible for creating this element.
        _owner: Sr
      };
      return Tr._store = {}, Object.defineProperty(Tr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Tr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: or
      }), Object.defineProperty(Tr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: vr
      }), Object.freeze && (Object.freeze(Tr.props), Object.freeze(Tr)), Tr;
    };
    function $r(Lt, Jt, er, or, vr) {
      {
        var Sr, Rr = {}, Tr = null, Nr = null;
        er !== void 0 && (Pr(er), Tr = "" + er), Ct(Jt) && (Pr(Jt.key), Tr = "" + Jt.key), Et(Jt) && (Nr = Jt.ref, Wt(Jt, vr));
        for (Sr in Jt)
          ar.call(Jt, Sr) && !Mr.hasOwnProperty(Sr) && (Rr[Sr] = Jt[Sr]);
        if (Lt && Lt.defaultProps) {
          var qr = Lt.defaultProps;
          for (Sr in qr)
            Rr[Sr] === void 0 && (Rr[Sr] = qr[Sr]);
        }
        if (Tr || Nr) {
          var Fr = typeof Lt == "function" ? Lt.displayName || Lt.name || "Unknown" : Lt;
          Tr && zt(Rr, Fr), Nr && Vt(Rr, Fr);
        }
        return yr(Lt, Tr, Nr, vr, or, br.current, Rr);
      }
    }
    var cr = ht.ReactCurrentOwner, xr = ht.ReactDebugCurrentFrame;
    function gr(Lt) {
      if (Lt) {
        var Jt = Lt._owner, er = rr(Lt.type, Lt._source, Jt ? Jt.type : null);
        xr.setExtraStackFrame(er);
      } else
        xr.setExtraStackFrame(null);
    }
    var _r;
    _r = !1;
    function kr(Lt) {
      return typeof Lt == "object" && Lt !== null && Lt.$$typeof === B;
    }
    function Cr() {
      {
        if (cr.current) {
          var Lt = rt(cr.current.type);
          if (Lt)
            return `

Check the render method of \`` + Lt + "`.";
        }
        return "";
      }
    }
    function Ft(Lt) {
      return "";
    }
    var kt = {};
    function Dt(Lt) {
      {
        var Jt = Cr();
        if (!Jt) {
          var er = typeof Lt == "string" ? Lt : Lt.displayName || Lt.name;
          er && (Jt = `

Check the top-level render call using <` + er + ">.");
        }
        return Jt;
      }
    }
    function Ht(Lt, Jt) {
      {
        if (!Lt._store || Lt._store.validated || Lt.key != null)
          return;
        Lt._store.validated = !0;
        var er = Dt(Jt);
        if (kt[er])
          return;
        kt[er] = !0;
        var or = "";
        Lt && Lt._owner && Lt._owner !== cr.current && (or = " It was passed a child from " + rt(Lt._owner.type) + "."), gr(Lt), dt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', er, or), gr(null);
      }
    }
    function Xt(Lt, Jt) {
      {
        if (typeof Lt != "object")
          return;
        if (Ar(Lt))
          for (var er = 0; er < Lt.length; er++) {
            var or = Lt[er];
            kr(or) && Ht(or, Jt);
          }
        else if (kr(Lt))
          Lt._store && (Lt._store.validated = !0);
        else if (Lt) {
          var vr = lt(Lt);
          if (typeof vr == "function" && vr !== Lt.entries)
            for (var Sr = vr.call(Lt), Rr; !(Rr = Sr.next()).done; )
              kr(Rr.value) && Ht(Rr.value, Jt);
        }
      }
    }
    function Qt(Lt) {
      {
        var Jt = Lt.type;
        if (Jt == null || typeof Jt == "string")
          return;
        var er;
        if (typeof Jt == "function")
          er = Jt.propTypes;
        else if (typeof Jt == "object" && (Jt.$$typeof === ie || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Jt.$$typeof === ce))
          er = Jt.propTypes;
        else
          return;
        if (er) {
          var or = rt(Jt);
          Ir(er, Lt.props, "prop", or, Lt);
        } else if (Jt.PropTypes !== void 0 && !_r) {
          _r = !0;
          var vr = rt(Jt);
          dt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", vr || "Unknown");
        }
        typeof Jt.getDefaultProps == "function" && !Jt.getDefaultProps.isReactClassApproved && dt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function tr(Lt) {
      {
        for (var Jt = Object.keys(Lt.props), er = 0; er < Jt.length; er++) {
          var or = Jt[er];
          if (or !== "children" && or !== "key") {
            gr(Lt), dt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", or), gr(null);
            break;
          }
        }
        Lt.ref !== null && (gr(Lt), dt("Invalid attribute `ref` supplied to `React.Fragment`."), gr(null));
      }
    }
    var nr = {};
    function fr(Lt, Jt, er, or, vr, Sr) {
      {
        var Rr = xt(Lt);
        if (!Rr) {
          var Tr = "";
          (Lt === void 0 || typeof Lt == "object" && Lt !== null && Object.keys(Lt).length === 0) && (Tr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Nr = Ft();
          Nr ? Tr += Nr : Tr += Cr();
          var qr;
          Lt === null ? qr = "null" : Ar(Lt) ? qr = "array" : Lt !== void 0 && Lt.$$typeof === B ? (qr = "<" + (rt(Lt.type) || "Unknown") + " />", Tr = " Did you accidentally export a JSX literal instead of a component?") : qr = typeof Lt, dt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", qr, Tr);
        }
        var Fr = $r(Lt, Jt, er, vr, Sr);
        if (Fr == null)
          return Fr;
        if (Rr) {
          var Ur = Jt.children;
          if (Ur !== void 0)
            if (or)
              if (Ar(Ur)) {
                for (var jr = 0; jr < Ur.length; jr++)
                  Xt(Ur[jr], Lt);
                Object.freeze && Object.freeze(Ur);
              } else
                dt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Xt(Ur, Lt);
        }
        if (ar.call(Jt, "key")) {
          var Dr = rt(Lt), Lr = Object.keys(Jt).filter(function(Gr) {
            return Gr !== "key";
          }), Hr = Lr.length > 0 ? "{key: someKey, " + Lr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!nr[Dr + Hr]) {
            var Wr = Lr.length > 0 ? "{" + Lr.join(": ..., ") + ": ...}" : "{}";
            dt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hr, Dr, Wr, Dr), nr[Dr + Hr] = !0;
          }
        }
        return Lt === K ? tr(Fr) : Qt(Fr), Fr;
      }
    }
    function ir(Lt, Jt, er) {
      return fr(Lt, Jt, er, !0);
    }
    function pr(Lt, Jt, er) {
      return fr(Lt, Jt, er, !1);
    }
    var wr = pr, sr = ir;
    reactJsxRuntime_development.Fragment = K, reactJsxRuntime_development.jsx = wr, reactJsxRuntime_development.jsxs = sr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [A, B] = useState(!1);
  return useEffect(() => {
    B(!0);
  }, []), A;
}
const KEY_PREFIX = "wallie";
function isBrowser() {
  return typeof window < "u";
}
function getItemFromLocalStorage(A) {
  if (!isBrowser())
    return null;
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${A} even though environment is not a browser.`
  );
  const B = `${KEY_PREFIX}_${A}`;
  try {
    const L = window.localStorage.getItem(B);
    return L != null ? JSON.parse(L) : null;
  } catch (L) {
    return console.error(`Error retrieving ${B} from localStorage`, L), null;
  }
}
function setItemToLocalStorage(A, B) {
  if (!isBrowser())
    return;
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${A} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${A}`;
  try {
    B ? window.localStorage.setItem(L, JSON.stringify(B)) : window.localStorage.removeItem(L);
  } catch (K) {
    console.error(`Error saving ${L} to localStorage`, K);
  }
}
function useLocalStorage(A, B, L = {}) {
  const { initializeWithValue: K = !0 } = L, re = useCallback(() => {
    const ie = getItemFromLocalStorage(A);
    return ie || (setItemToLocalStorage(A, B), B);
  }, [B, A]), [W, J] = useState(() => K ? re() : B), ne = useCallback(
    (ie) => {
      setItemToLocalStorage(A, ie), J(ie);
    },
    [A]
  );
  return useEffect(() => {
    J(re());
  }, [A]), [W, ne];
}
var Network = /* @__PURE__ */ ((A) => (A.MAINNET = "mainnet", A.TESTNET = "testnet", A.SIGNET = "signet", A))(Network || {}), Wallet = /* @__PURE__ */ ((A) => (A.UNISAT = "unisat", A.XVERSE = "xverse", A.MAGICEDEN = "magiceden", A.LEATHER = "leather", A.OKX = "okx", A))(Wallet || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, WallieContext = createContext(void 0), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function WallieProvider({
  children: A,
  initialNetwork: B,
  ssr: L = !1
}) {
  if (!B)
    throw new Error("Initial network cannot be empty");
  const [K, re] = useState(B), [W, J] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !L }
  ), [ne, ie] = useLocalStorage(WALLET, null, {
    initializeWithValue: !L
  }), [oe, V] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !L }
  ), [ce, ke] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !L }
  ), [Ce, it] = useState(!1), at = useCallback(() => it(!0), []), lt = useCallback(() => it(!1), []), ht = useCallback(() => {
    J(EMPTY_BIADDRESS_OBJECT), V(EMPTY_BIADDRESS_OBJECT), ke(EMPTY_BIADDRESS_OBJECT), ie(null);
  }, [J, ke, V, ie]), dt = useMemo(
    () => ({
      address: W,
      updateAddress: J,
      publicKey: oe,
      updatePublicKey: V,
      network: K,
      updateNetwork: re,
      wallet: ne,
      updateWallet: ie,
      isModalOpen: Ce,
      openModal: at,
      closeModal: lt,
      format: ce,
      updateFormat: ke,
      disconnectWallet: ht
    }),
    [
      W,
      J,
      oe,
      V,
      K,
      re,
      ne,
      ie,
      Ce,
      at,
      lt,
      ce,
      ke,
      ht
    ]
  );
  return useEffect(() => {
    re(B);
  }, [B]), /* @__PURE__ */ jsxRuntimeExports.jsx(WallieContext.Provider, { value: dt, children: A });
}
function useWallie() {
  const A = useContext(WallieContext);
  if (!A)
    throw new Error("useWallie must be used within WallieProvider");
  return A;
}
var build = { exports: {} };
(function(A, B) {
  (function(L, K) {
    A.exports = K(C__default);
  })(commonjsGlobal, function(L) {
    return function(K) {
      var re = {};
      function W(J) {
        if (re[J]) return re[J].exports;
        var ne = re[J] = { i: J, l: !1, exports: {} };
        return K[J].call(ne.exports, ne, ne.exports, W), ne.l = !0, ne.exports;
      }
      return W.m = K, W.c = re, W.d = function(J, ne, ie) {
        W.o(J, ne) || Object.defineProperty(J, ne, { enumerable: !0, get: ie });
      }, W.r = function(J) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(J, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(J, "__esModule", { value: !0 });
      }, W.t = function(J, ne) {
        if (1 & ne && (J = W(J)), 8 & ne || 4 & ne && typeof J == "object" && J && J.__esModule) return J;
        var ie = /* @__PURE__ */ Object.create(null);
        if (W.r(ie), Object.defineProperty(ie, "default", { enumerable: !0, value: J }), 2 & ne && typeof J != "string") for (var oe in J) W.d(ie, oe, (function(V) {
          return J[V];
        }).bind(null, oe));
        return ie;
      }, W.n = function(J) {
        var ne = J && J.__esModule ? function() {
          return J.default;
        } : function() {
          return J;
        };
        return W.d(ne, "a", ne), ne;
      }, W.o = function(J, ne) {
        return Object.prototype.hasOwnProperty.call(J, ne);
      }, W.p = "/", W(W.s = 1);
    }([function(K, re) {
      K.exports = L;
    }, function(K, re, W) {
      K.exports = W(2);
    }, function(K, re, W) {
      function J(mt, xt, wt) {
        return xt in mt ? Object.defineProperty(mt, xt, { value: wt, enumerable: !0, configurable: !0, writable: !0 }) : mt[xt] = wt, mt;
      }
      function ne(mt, xt) {
        var wt = Object.keys(mt);
        if (Object.getOwnPropertySymbols) {
          var Oe = Object.getOwnPropertySymbols(mt);
          xt && (Oe = Oe.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(mt, rt).enumerable;
          })), wt.push.apply(wt, Oe);
        }
        return wt;
      }
      function ie(mt, xt) {
        if (mt == null) return {};
        var wt, Oe, rt = function(nt, ot) {
          if (nt == null) return {};
          var st, ut, pt = {}, ft = Object.keys(nt);
          for (ut = 0; ut < ft.length; ut++) st = ft[ut], ot.indexOf(st) >= 0 || (pt[st] = nt[st]);
          return pt;
        }(mt, xt);
        if (Object.getOwnPropertySymbols) {
          var pe = Object.getOwnPropertySymbols(mt);
          for (Oe = 0; Oe < pe.length; Oe++) wt = pe[Oe], xt.indexOf(wt) >= 0 || Object.prototype.propertyIsEnumerable.call(mt, wt) && (rt[wt] = mt[wt]);
        }
        return rt;
      }
      W.r(re);
      var oe = W(0), V = W.n(oe), ce = function(mt) {
        for (var xt = 0, wt = 0; wt < mt.length; wt++)
          xt = (xt << 5) - xt + mt.charCodeAt(wt), xt &= xt;
        return Math.abs(xt);
      }, ke = function(mt, xt) {
        return Math.floor(mt / Math.pow(10, xt) % 10);
      }, Ce = function(mt, xt) {
        return !(ke(mt, xt) % 2);
      }, it = function(mt, xt, wt) {
        var Oe = mt % xt;
        return wt && ke(mt, wt) % 2 === 0 ? -Oe : Oe;
      }, at = function(mt, xt, wt) {
        return xt[mt % wt];
      }, lt = function(mt) {
        var xt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 4 }, function(ot, st) {
            return { color: at(pe + st, rt, nt), translateX: it(pe * (st + 1), 40 - (st + 17), 1), translateY: it(pe * (st + 1), 40 - (st + 17), 2), rotate: it(pe * (st + 1), 360), isSquare: Ce(pe, 2) };
          });
        }(mt.name, mt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: mt.size, height: mt.size }, mt.title && oe.createElement("title", null, mt.name), oe.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: mt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 80, height: 80, fill: xt[0].color }), oe.createElement("rect", { x: 10, y: 30, width: 80, height: xt[1].isSquare ? 80 : 10, fill: xt[1].color, transform: "translate(" + xt[1].translateX + " " + xt[1].translateY + ") rotate(" + xt[1].rotate + " 40 40)" }), oe.createElement("circle", { cx: 40, cy: 40, fill: xt[2].color, r: 16, transform: "translate(" + xt[2].translateX + " " + xt[2].translateY + ")" }), oe.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: xt[3].color, transform: "translate(" + xt[3].translateX + " " + xt[3].translateY + ") rotate(" + xt[3].rotate + " 40 40)" })));
      }, ht = function(mt) {
        var xt = function(Oe, rt) {
          var pe = ce(rt), nt = Oe && Oe.length, ot = Array.from({ length: 5 }, function(ut, pt) {
            return at(pe + pt, Oe, nt);
          }), st = [];
          return st[0] = ot[0], st[1] = ot[1], st[2] = ot[1], st[3] = ot[2], st[4] = ot[2], st[5] = ot[3], st[6] = ot[3], st[7] = ot[0], st[8] = ot[4], st;
        }(mt.colors, mt.name), wt = V.a.useId();
        return V.a.createElement("svg", { viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: mt.size, height: mt.size }, mt.title && V.a.createElement("title", null, mt.name), V.a.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, V.a.createElement("rect", { width: 90, height: 90, rx: mt.square ? void 0 : 180, fill: "#FFFFFF" })), V.a.createElement("g", { mask: "url(#".concat(wt, ")") }, V.a.createElement("path", { d: "M0 0h90v45H0z", fill: xt[0] }), V.a.createElement("path", { d: "M0 45h90v45H0z", fill: xt[1] }), V.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: xt[2] }), V.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: xt[3] }), V.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: xt[4] }), V.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: xt[5] }), V.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: xt[6] }), V.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: xt[7] }), V.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: xt[8] })));
      }, dt = function(mt) {
        var xt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 64 }, function(ot, st) {
            return at(pe % (st + 1), rt, nt);
          });
        }(mt.name, mt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: mt.size, height: mt.size }, mt.title && oe.createElement("title", null, mt.name), oe.createElement("mask", { id: wt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: mt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 10, height: 10, fill: xt[0] }), oe.createElement("rect", { x: 20, width: 10, height: 10, fill: xt[1] }), oe.createElement("rect", { x: 40, width: 10, height: 10, fill: xt[2] }), oe.createElement("rect", { x: 60, width: 10, height: 10, fill: xt[3] }), oe.createElement("rect", { x: 10, width: 10, height: 10, fill: xt[4] }), oe.createElement("rect", { x: 30, width: 10, height: 10, fill: xt[5] }), oe.createElement("rect", { x: 50, width: 10, height: 10, fill: xt[6] }), oe.createElement("rect", { x: 70, width: 10, height: 10, fill: xt[7] }), oe.createElement("rect", { y: 10, width: 10, height: 10, fill: xt[8] }), oe.createElement("rect", { y: 20, width: 10, height: 10, fill: xt[9] }), oe.createElement("rect", { y: 30, width: 10, height: 10, fill: xt[10] }), oe.createElement("rect", { y: 40, width: 10, height: 10, fill: xt[11] }), oe.createElement("rect", { y: 50, width: 10, height: 10, fill: xt[12] }), oe.createElement("rect", { y: 60, width: 10, height: 10, fill: xt[13] }), oe.createElement("rect", { y: 70, width: 10, height: 10, fill: xt[14] }), oe.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: xt[15] }), oe.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: xt[16] }), oe.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: xt[17] }), oe.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: xt[18] }), oe.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: xt[19] }), oe.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: xt[20] }), oe.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: xt[21] }), oe.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: xt[22] }), oe.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: xt[23] }), oe.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: xt[24] }), oe.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: xt[25] }), oe.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: xt[26] }), oe.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: xt[27] }), oe.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: xt[28] }), oe.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: xt[29] }), oe.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: xt[30] }), oe.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: xt[31] }), oe.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: xt[32] }), oe.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: xt[33] }), oe.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: xt[34] }), oe.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: xt[35] }), oe.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: xt[36] }), oe.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: xt[37] }), oe.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: xt[38] }), oe.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: xt[39] }), oe.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: xt[40] }), oe.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: xt[41] }), oe.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: xt[42] }), oe.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: xt[43] }), oe.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: xt[44] }), oe.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: xt[45] }), oe.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: xt[46] }), oe.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: xt[47] }), oe.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: xt[48] }), oe.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: xt[49] }), oe.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: xt[50] }), oe.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: xt[51] }), oe.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: xt[52] }), oe.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: xt[53] }), oe.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: xt[54] }), oe.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: xt[55] }), oe.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: xt[56] }), oe.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: xt[57] }), oe.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: xt[58] }), oe.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: xt[59] }), oe.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: xt[60] }), oe.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: xt[61] }), oe.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: xt[62] }), oe.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: xt[63] })));
      }, bt = function(mt) {
        var xt = function(Oe, rt) {
          var pe, nt = ce(Oe), ot = rt && rt.length, st = at(nt, rt, ot), ut = it(nt, 10, 1), pt = ut < 5 ? ut + 4 : ut, ft = it(nt, 10, 2), yt = ft < 5 ? ft + 4 : ft;
          return { wrapperColor: st, faceColor: (pe = st, pe.slice(0, 1) === "#" && (pe = pe.slice(1)), (299 * parseInt(pe.substr(0, 2), 16) + 587 * parseInt(pe.substr(2, 2), 16) + 114 * parseInt(pe.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: at(nt + 13, rt, ot), wrapperTranslateX: pt, wrapperTranslateY: yt, wrapperRotate: it(nt, 360), wrapperScale: 1 + it(nt, 3) / 10, isMouthOpen: Ce(nt, 2), isCircle: Ce(nt, 1), eyeSpread: it(nt, 5), mouthSpread: it(nt, 3), faceRotate: it(nt, 10, 3), faceTranslateX: pt > 6 ? pt / 2 : it(nt, 8, 1), faceTranslateY: yt > 6 ? yt / 2 : it(nt, 7, 2) };
        }(mt.name, mt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: mt.size, height: mt.size }, mt.title && oe.createElement("title", null, mt.name), oe.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, oe.createElement("rect", { width: 36, height: 36, rx: mt.square ? void 0 : 72, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 36, height: 36, fill: xt.backgroundColor }), oe.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + xt.wrapperTranslateX + " " + xt.wrapperTranslateY + ") rotate(" + xt.wrapperRotate + " 18 18) scale(" + xt.wrapperScale + ")", fill: xt.wrapperColor, rx: xt.isCircle ? 36 : 6 }), oe.createElement("g", { transform: "translate(" + xt.faceTranslateX + " " + xt.faceTranslateY + ") rotate(" + xt.faceRotate + " 18 18)" }, xt.isMouthOpen ? oe.createElement("path", { d: "M15 " + (19 + xt.mouthSpread) + "c2 1 4 1 6 0", stroke: xt.faceColor, fill: "none", strokeLinecap: "round" }) : oe.createElement("path", { d: "M13," + (19 + xt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: xt.faceColor }), oe.createElement("rect", { x: 14 - xt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: xt.faceColor }), oe.createElement("rect", { x: 20 + xt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: xt.faceColor }))));
      }, vt = function(mt) {
        var xt = function(rt, pe) {
          var nt = ce(rt), ot = pe && pe.length;
          return Array.from({ length: 4 }, function(st, ut) {
            return at(nt + ut, pe, ot);
          });
        }(mt.name, mt.colors), wt = mt.name.replace(/\s/g, ""), Oe = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: mt.size, height: mt.size }, mt.title && oe.createElement("title", null, mt.name), oe.createElement("mask", { id: Oe, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: mt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(Oe, ")") }, oe.createElement("path", { fill: "url(#gradient_paint0_linear_" + wt + ")", d: "M0 0h80v40H0z" }), oe.createElement("path", { fill: "url(#gradient_paint1_linear_" + wt + ")", d: "M0 40h80v40H0z" })), oe.createElement("defs", null, oe.createElement("linearGradient", { id: "gradient_paint0_linear_" + wt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, oe.createElement("stop", { stopColor: xt[0] }), oe.createElement("stop", { offset: 1, stopColor: xt[1] })), oe.createElement("linearGradient", { id: "gradient_paint1_linear_" + wt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, oe.createElement("stop", { stopColor: xt[2] }), oe.createElement("stop", { offset: 1, stopColor: xt[3] }))));
      }, Bt = function(mt) {
        var xt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 3 }, function(ot, st) {
            return { color: at(pe + st, rt, nt), translateX: it(pe * (st + 1), 8, 1), translateY: it(pe * (st + 1), 8, 2), scale: 1.2 + it(pe * (st + 1), 4) / 10, rotate: it(pe * (st + 1), 360, 1) };
          });
        }(mt.name, mt.colors), wt = oe.useId();
        return oe.createElement("svg", { viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: mt.size, height: mt.size }, mt.title && oe.createElement("title", null, mt.name), oe.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, oe.createElement("rect", { width: 80, height: 80, rx: mt.square ? void 0 : 160, fill: "#FFFFFF" })), oe.createElement("g", { mask: "url(#".concat(wt, ")") }, oe.createElement("rect", { width: 80, height: 80, fill: xt[0].color }), oe.createElement("path", { filter: "url(#filter_".concat(wt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: xt[1].color, transform: "translate(" + xt[1].translateX + " " + xt[1].translateY + ") rotate(" + xt[1].rotate + " 40 40) scale(" + xt[2].scale + ")" }), oe.createElement("path", { filter: "url(#filter_".concat(wt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: xt[2].color, transform: "translate(" + xt[2].translateX + " " + xt[2].translateY + ") rotate(" + xt[2].rotate + " 40 40) scale(" + xt[2].scale + ")" })), oe.createElement("defs", null, oe.createElement("filter", { id: "filter_".concat(wt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, oe.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), oe.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), oe.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, At = ["pixel", "bauhaus", "ring", "beam", "sunset", "marble"], Nt = { geometric: "beam", abstract: "bauhaus" }, $t = function(mt) {
        var xt = mt.variant, wt = xt === void 0 ? "marble" : xt, Oe = mt.colors, rt = Oe === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Oe, pe = mt.name, nt = pe === void 0 ? "Clara Barton" : pe, ot = mt.square, st = ot !== void 0 && ot, ut = mt.title, pt = ut !== void 0 && ut, ft = mt.size, yt = function(ct) {
          for (var St = 1; St < arguments.length; St++) {
            var qt = arguments[St] != null ? arguments[St] : {};
            St % 2 ? ne(Object(qt), !0).forEach(function(jt) {
              J(ct, jt, qt[jt]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ct, Object.getOwnPropertyDescriptors(qt)) : ne(Object(qt)).forEach(function(jt) {
              Object.defineProperty(ct, jt, Object.getOwnPropertyDescriptor(qt, jt));
            });
          }
          return ct;
        }({ colors: rt, name: nt, title: pt, size: ft === void 0 ? 40 : ft, square: st }, ie(mt, ["variant", "colors", "name", "square", "title", "size"]));
        return { pixel: V.a.createElement(dt, yt), bauhaus: V.a.createElement(lt, yt), ring: V.a.createElement(ht, yt), beam: V.a.createElement(bt, yt), sunset: V.a.createElement(vt, yt), marble: V.a.createElement(Bt, yt) }[Object.keys(Nt).includes(wt) ? Nt[wt] : At.includes(wt) ? wt : "marble"];
      };
      re.default = $t;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
var i$7 = Object.defineProperty, d$5 = (A, B, L) => B in A ? i$7(A, B, { enumerable: !0, configurable: !0, writable: !0, value: L }) : A[B] = L, r$4 = (A, B, L) => (d$5(A, typeof B != "symbol" ? B + "" : B, L), L);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$5 = (A, B) => {
  s$a.isServer ? useEffect(A, B) : useLayoutEffect(A, B);
};
function s$9(A) {
  let B = useRef(A);
  return l$5(() => {
    B.current = A;
  }, [A]), B;
}
let o$6 = function(A) {
  let B = s$9(A);
  return C__default.useCallback((...L) => B.current(...L), [B]);
};
function t$7(A) {
  typeof queueMicrotask == "function" ? queueMicrotask(A) : Promise.resolve().then(A).catch((B) => setTimeout(() => {
    throw B;
  }));
}
function o$5() {
  let A = [], B = { addEventListener(L, K, re, W) {
    return L.addEventListener(K, re, W), B.add(() => L.removeEventListener(K, re, W));
  }, requestAnimationFrame(...L) {
    let K = requestAnimationFrame(...L);
    return B.add(() => cancelAnimationFrame(K));
  }, nextFrame(...L) {
    return B.requestAnimationFrame(() => B.requestAnimationFrame(...L));
  }, setTimeout(...L) {
    let K = setTimeout(...L);
    return B.add(() => clearTimeout(K));
  }, microTask(...L) {
    let K = { current: !0 };
    return t$7(() => {
      K.current && L[0]();
    }), B.add(() => {
      K.current = !1;
    });
  }, style(L, K, re) {
    let W = L.style.getPropertyValue(K);
    return Object.assign(L.style, { [K]: re }), this.add(() => {
      Object.assign(L.style, { [K]: W });
    });
  }, group(L) {
    let K = o$5();
    return L(K), this.add(() => K.dispose());
  }, add(L) {
    return A.push(L), () => {
      let K = A.indexOf(L);
      if (K >= 0) for (let re of A.splice(K, 1)) re();
    };
  }, dispose() {
    for (let L of A.splice(0)) L();
  } };
  return B;
}
function p$3() {
  let [A] = useState(o$5);
  return useEffect(() => () => A.dispose(), [A]), A;
}
function s$8() {
  let A = typeof document > "u";
  return "useSyncExternalStore" in C$2 ? ((B) => B.useSyncExternalStore)(C$2)(() => () => {
  }, () => !1, () => !A) : !1;
}
function l$4() {
  let A = s$8(), [B, L] = C$2.useState(s$a.isHandoffComplete);
  return B && s$a.isHandoffComplete === !1 && L(!1), C$2.useEffect(() => {
    B !== !0 && L(!0);
  }, [B]), C$2.useEffect(() => s$a.handoff(), []), A ? !1 : B;
}
var o$4;
let I$5 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let A = l$4(), [B, L] = C__default.useState(A ? () => s$a.nextId() : null);
  return l$5(() => {
    B === null && L(s$a.nextId());
  }, [B]), B != null ? "" + B : void 0;
};
function u$7(A, B, ...L) {
  if (A in B) {
    let re = B[A];
    return typeof re == "function" ? re(...L) : re;
  }
  let K = new Error(`Tried to handle "${A}" but there is no handler defined. Only defined handlers are: ${Object.keys(B).map((re) => `"${re}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(K, u$7), K;
}
function o$3(A) {
  return s$a.isServer ? null : A instanceof Node ? A.ownerDocument : A != null && A.hasOwnProperty("current") && A.current instanceof Node ? A.current.ownerDocument : document;
}
let c$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((A) => `${A}:not([tabindex='-1'])`).join(",");
var M$2 = ((A) => (A[A.First = 1] = "First", A[A.Previous = 2] = "Previous", A[A.Next = 4] = "Next", A[A.Last = 8] = "Last", A[A.WrapAround = 16] = "WrapAround", A[A.NoScroll = 32] = "NoScroll", A))(M$2 || {}), N$2 = ((A) => (A[A.Error = 0] = "Error", A[A.Overflow = 1] = "Overflow", A[A.Success = 2] = "Success", A[A.Underflow = 3] = "Underflow", A))(N$2 || {}), F$3 = ((A) => (A[A.Previous = -1] = "Previous", A[A.Next = 1] = "Next", A))(F$3 || {});
function f$6(A = document.body) {
  return A == null ? [] : Array.from(A.querySelectorAll(c$5)).sort((B, L) => Math.sign((B.tabIndex || Number.MAX_SAFE_INTEGER) - (L.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((A) => (A[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A))(T$2 || {});
function h$4(A, B = 0) {
  var L;
  return A === ((L = o$3(A)) == null ? void 0 : L.body) ? !1 : u$7(B, { 0() {
    return A.matches(c$5);
  }, 1() {
    let K = A;
    for (; K !== null; ) {
      if (K.matches(c$5)) return !0;
      K = K.parentElement;
    }
    return !1;
  } });
}
function D$3(A) {
  let B = o$3(A);
  o$5().nextFrame(() => {
    B && !h$4(B.activeElement, 0) && y$3(A);
  });
}
var w$2 = ((A) => (A[A.Keyboard = 0] = "Keyboard", A[A.Mouse = 1] = "Mouse", A))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (A) => {
  A.metaKey || A.altKey || A.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (A) => {
  A.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : A.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(A) {
  A == null || A.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(A) {
  var B, L;
  return (L = (B = A == null ? void 0 : A.matches) == null ? void 0 : B.call(A, S$5)) != null ? L : !1;
}
function I$4(A, B = (L) => L) {
  return A.slice().sort((L, K) => {
    let re = B(L), W = B(K);
    if (re === null || W === null) return 0;
    let J = re.compareDocumentPosition(W);
    return J & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : J & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$2(A, B) {
  return O$1(f$6(), B, { relativeTo: A });
}
function O$1(A, B, { sorted: L = !0, relativeTo: K = null, skipElements: re = [] } = {}) {
  let W = Array.isArray(A) ? A.length > 0 ? A[0].ownerDocument : document : A.ownerDocument, J = Array.isArray(A) ? L ? I$4(A) : A : f$6(A);
  re.length > 0 && J.length > 1 && (J = J.filter((Ce) => !re.includes(Ce))), K = K ?? W.activeElement;
  let ne = (() => {
    if (B & 5) return 1;
    if (B & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ie = (() => {
    if (B & 1) return 0;
    if (B & 2) return Math.max(0, J.indexOf(K)) - 1;
    if (B & 4) return Math.max(0, J.indexOf(K)) + 1;
    if (B & 8) return J.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), oe = B & 32 ? { preventScroll: !0 } : {}, V = 0, ce = J.length, ke;
  do {
    if (V >= ce || V + ce <= 0) return 0;
    let Ce = ie + V;
    if (B & 16) Ce = (Ce + ce) % ce;
    else {
      if (Ce < 0) return 3;
      if (Ce >= ce) return 1;
    }
    ke = J[Ce], ke == null || ke.focus(oe), V += ne;
  } while (ke !== W.activeElement);
  return B & 6 && H(ke) && ke.select(), 2;
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$6() || i$6();
}
function d$4(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function re(W) {
      K.current(W);
    }
    return document.addEventListener(A, re, L), () => document.removeEventListener(A, re, L);
  }, [A, L]);
}
function s$7(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function re(W) {
      K.current(W);
    }
    return window.addEventListener(A, re, L), () => window.removeEventListener(A, re, L);
  }, [A, L]);
}
function y$2(A, B, L = !0) {
  let K = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      K.current = L;
    });
  }, [L]);
  function re(J, ne) {
    if (!K.current || J.defaultPrevented) return;
    let ie = ne(J);
    if (ie === null || !ie.getRootNode().contains(ie) || !ie.isConnected) return;
    let oe = function V(ce) {
      return typeof ce == "function" ? V(ce()) : Array.isArray(ce) || ce instanceof Set ? ce : [ce];
    }(A);
    for (let V of oe) {
      if (V === null) continue;
      let ce = V instanceof HTMLElement ? V : V.current;
      if (ce != null && ce.contains(ie) || J.composed && J.composedPath().includes(ce)) return;
    }
    return !h$4(ie, T$2.Loose) && ie.tabIndex !== -1 && J.preventDefault(), B(J, ie);
  }
  let W = useRef(null);
  d$4("pointerdown", (J) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = J.composedPath) == null ? void 0 : ne.call(J)) == null ? void 0 : ie[0]) || J.target);
  }, !0), d$4("mousedown", (J) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = J.composedPath) == null ? void 0 : ne.call(J)) == null ? void 0 : ie[0]) || J.target);
  }, !0), d$4("click", (J) => {
    n$3() || W.current && (re(J, () => W.current), W.current = null);
  }, !0), d$4("touchend", (J) => re(J, () => J.target instanceof HTMLElement ? J.target : null), !0), s$7("blur", (J) => re(J, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...A) {
  return useMemo(() => o$3(...A), [...A]);
}
function i$5(A) {
  var B;
  if (A.type) return A.type;
  let L = (B = A.as) != null ? B : "button";
  if (typeof L == "string" && L.toLowerCase() === "button") return "button";
}
function T$1(A, B) {
  let [L, K] = useState(() => i$5(A));
  return l$5(() => {
    K(i$5(A));
  }, [A.type, A.as]), l$5(() => {
    L || B.current && B.current instanceof HTMLButtonElement && !B.current.hasAttribute("type") && K("button");
  }, [L, B]), L;
}
let u$6 = Symbol();
function T(A, B = !0) {
  return Object.assign(A, { [u$6]: B });
}
function y$1(...A) {
  let B = useRef(A);
  useEffect(() => {
    B.current = A;
  }, [A]);
  let L = o$6((K) => {
    for (let re of B.current) re != null && (typeof re == "function" ? re(K) : re.current = K);
  });
  return A.every((K) => K == null || (K == null ? void 0 : K[u$6])) ? void 0 : L;
}
function t$5(A) {
  return [A.screenX, A.screenY];
}
function u$5() {
  let A = useRef([-1, -1]);
  return { wasMoved(B) {
    let L = t$5(B);
    return A.current[0] === L[0] && A.current[1] === L[1] ? !1 : (A.current = L, !0);
  }, update(B) {
    A.current = t$5(B);
  } };
}
function F$2({ container: A, accept: B, walk: L, enabled: K = !0 }) {
  let re = useRef(B), W = useRef(L);
  useEffect(() => {
    re.current = B, W.current = L;
  }, [B, L]), l$5(() => {
    if (!A || !K) return;
    let J = o$3(A);
    if (!J) return;
    let ne = re.current, ie = W.current, oe = Object.assign((ce) => ne(ce), { acceptNode: ne }), V = J.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, oe, !1);
    for (; V.nextNode(); ) ie(V.currentNode);
  }, [A, K, re, W]);
}
function m$2(A, B) {
  let L = useRef([]), K = o$6(A);
  useEffect(() => {
    let re = [...L.current];
    for (let [W, J] of B.entries()) if (L.current[W] !== J) {
      let ne = K(B, re);
      return L.current = B, ne;
    }
  }, [K, ...B]);
}
function t$4(...A) {
  return Array.from(new Set(A.flatMap((B) => typeof B == "string" ? B.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((A) => (A[A.None = 0] = "None", A[A.RenderStrategy = 1] = "RenderStrategy", A[A.Static = 2] = "Static", A))(O || {}), v$1 = ((A) => (A[A.Unmount = 0] = "Unmount", A[A.Hidden = 1] = "Hidden", A))(v$1 || {});
function C$1({ ourProps: A, theirProps: B, slot: L, defaultTag: K, features: re, visible: W = !0, name: J, mergeRefs: ne }) {
  ne = ne ?? k$1;
  let ie = R(B, A);
  if (W) return m$1(ie, L, K, J, ne);
  let oe = re ?? 0;
  if (oe & 2) {
    let { static: V = !1, ...ce } = ie;
    if (V) return m$1(ce, L, K, J, ne);
  }
  if (oe & 1) {
    let { unmount: V = !0, ...ce } = ie;
    return u$7(V ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...ce, hidden: !0, style: { display: "none" } }, L, K, J, ne);
    } });
  }
  return m$1(ie, L, K, J, ne);
}
function m$1(A, B = {}, L, K, re) {
  let { as: W = L, children: J, refName: ne = "ref", ...ie } = F$1(A, ["unmount", "static"]), oe = A.ref !== void 0 ? { [ne]: A.ref } : {}, V = typeof J == "function" ? J(B) : J;
  "className" in ie && ie.className && typeof ie.className == "function" && (ie.className = ie.className(B));
  let ce = {};
  if (B) {
    let ke = !1, Ce = [];
    for (let [it, at] of Object.entries(B)) typeof at == "boolean" && (ke = !0), at === !0 && Ce.push(it);
    ke && (ce["data-headlessui-state"] = Ce.join(" "));
  }
  if (W === Fragment && Object.keys(x$2(ie)).length > 0) {
    if (!isValidElement(V) || Array.isArray(V) && V.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${K} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(ie).map((at) => `  - ${at}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((at) => `  - ${at}`).join(`
`)].join(`
`));
    let ke = V.props, Ce = typeof (ke == null ? void 0 : ke.className) == "function" ? (...at) => t$4(ke == null ? void 0 : ke.className(...at), ie.className) : t$4(ke == null ? void 0 : ke.className, ie.className), it = Ce ? { className: Ce } : {};
    return cloneElement(V, Object.assign({}, R(V.props, x$2(F$1(ie, ["ref"]))), ce, oe, { ref: re(V.ref, oe.ref) }, it));
  }
  return createElement(W, Object.assign({}, F$1(ie, ["ref"]), W !== Fragment && oe, W !== Fragment && ce), V);
}
function k$1(...A) {
  return A.every((B) => B == null) ? void 0 : (B) => {
    for (let L of A) L != null && (typeof L == "function" ? L(B) : L.current = B);
  };
}
function R(...A) {
  if (A.length === 0) return {};
  if (A.length === 1) return A[0];
  let B = {}, L = {};
  for (let K of A) for (let re in K) re.startsWith("on") && typeof K[re] == "function" ? (L[re] != null || (L[re] = []), L[re].push(K[re])) : B[re] = K[re];
  if (B.disabled || B["aria-disabled"]) return Object.assign(B, Object.fromEntries(Object.keys(L).map((K) => [K, void 0])));
  for (let K in L) Object.assign(B, { [K](re, ...W) {
    let J = L[K];
    for (let ne of J) {
      if ((re instanceof Event || (re == null ? void 0 : re.nativeEvent) instanceof Event) && re.defaultPrevented) return;
      ne(re, ...W);
    }
  } });
  return B;
}
function U$3(A) {
  var B;
  return Object.assign(forwardRef(A), { displayName: (B = A.displayName) != null ? B : A.name });
}
function x$2(A) {
  let B = Object.assign({}, A);
  for (let L in B) B[L] === void 0 && delete B[L];
  return B;
}
function F$1(A, B = []) {
  let L = Object.assign({}, A);
  for (let K of B) K in L && delete L[K];
  return L;
}
let p$2 = "div";
var s$6 = ((A) => (A[A.None = 1] = "None", A[A.Focusable = 2] = "Focusable", A[A.Hidden = 4] = "Hidden", A))(s$6 || {});
function l$3(A, B) {
  var L;
  let { features: K = 1, ...re } = A, W = { ref: B, "aria-hidden": (K & 2) === 2 ? !0 : (L = re["aria-hidden"]) != null ? L : void 0, hidden: (K & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(K & 4) === 4 && (K & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: W, theirProps: re, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let u$4 = U$3(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((A) => (A[A.Open = 1] = "Open", A[A.Closed = 2] = "Closed", A[A.Closing = 4] = "Closing", A[A.Opening = 8] = "Opening", A))(d$3 || {});
function u$3() {
  return useContext(n$1);
}
function s$5({ value: A, children: B }) {
  return C__default.createElement(n$1.Provider, { value: A }, B);
}
function t$3(A) {
  function B() {
    document.readyState !== "loading" && (A(), document.removeEventListener("DOMContentLoaded", B));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", B), B());
}
let t$2 = [];
t$3(() => {
  function A(B) {
    B.target instanceof HTMLElement && B.target !== document.body && t$2[0] !== B.target && (t$2.unshift(B.target), t$2 = t$2.filter((L) => L != null && L.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", A, { capture: !0 }), window.addEventListener("mousedown", A, { capture: !0 }), window.addEventListener("focus", A, { capture: !0 }), document.body.addEventListener("click", A, { capture: !0 }), document.body.addEventListener("mousedown", A, { capture: !0 }), document.body.addEventListener("focus", A, { capture: !0 });
});
function r$3(A) {
  let B = A.parentElement, L = null;
  for (; B && !(B instanceof HTMLFieldSetElement); ) B instanceof HTMLLegendElement && (L = B), B = B.parentElement;
  let K = (B == null ? void 0 : B.getAttribute("disabled")) === "";
  return K && i$4(L) ? !1 : K;
}
function i$4(A) {
  if (!A) return !1;
  let B = A.previousElementSibling;
  for (; B !== null; ) {
    if (B instanceof HTMLLegendElement) return !1;
    B = B.previousElementSibling;
  }
  return !0;
}
function u$2(A) {
  throw new Error("Unexpected object: " + A);
}
var c$4 = ((A) => (A[A.First = 0] = "First", A[A.Previous = 1] = "Previous", A[A.Next = 2] = "Next", A[A.Last = 3] = "Last", A[A.Specific = 4] = "Specific", A[A.Nothing = 5] = "Nothing", A))(c$4 || {});
function f$5(A, B) {
  let L = B.resolveItems();
  if (L.length <= 0) return null;
  let K = B.resolveActiveIndex(), re = K ?? -1;
  switch (A.focus) {
    case 0: {
      for (let W = 0; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 1: {
      for (let W = re - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 2: {
      for (let W = re + 1; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 3: {
      for (let W = L.length - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 4: {
      for (let W = 0; W < L.length; ++W) if (B.resolveId(L[W], W, L) === A.id) return W;
      return K;
    }
    case 5:
      return null;
    default:
      u$2(A);
  }
}
var o$2 = ((A) => (A.Space = " ", A.Enter = "Enter", A.Escape = "Escape", A.Backspace = "Backspace", A.Delete = "Delete", A.ArrowLeft = "ArrowLeft", A.ArrowUp = "ArrowUp", A.ArrowRight = "ArrowRight", A.ArrowDown = "ArrowDown", A.Home = "Home", A.End = "End", A.PageUp = "PageUp", A.PageDown = "PageDown", A.Tab = "Tab", A))(o$2 || {});
function E(A, B, L, K) {
  let re = s$9(L);
  useEffect(() => {
    A = A ?? window;
    function W(J) {
      re.current(J);
    }
    return A.addEventListener(B, W, K), () => A.removeEventListener(B, W, K);
  }, [A, B, K]);
}
function f$4() {
  let A = useRef(!1);
  return l$5(() => (A.current = !0, () => {
    A.current = !1;
  }), []), A;
}
function c$3(A) {
  let B = o$6(A), L = useRef(!1);
  useEffect(() => (L.current = !1, () => {
    L.current = !0, t$7(() => {
      L.current && B();
    });
  }), [B]);
}
var s$4 = ((A) => (A[A.Forwards = 0] = "Forwards", A[A.Backwards = 1] = "Backwards", A))(s$4 || {});
function n() {
  let A = useRef(0);
  return s$7("keydown", (B) => {
    B.key === "Tab" && (A.current = B.shiftKey ? 1 : 0);
  }, !0), A;
}
function P(A) {
  if (!A) return /* @__PURE__ */ new Set();
  if (typeof A == "function") return new Set(A());
  let B = /* @__PURE__ */ new Set();
  for (let L of A.current) L.current instanceof HTMLElement && B.add(L.current);
  return B;
}
let X = "div";
var _$1 = ((A) => (A[A.None = 1] = "None", A[A.InitialFocus = 2] = "InitialFocus", A[A.TabLock = 4] = "TabLock", A[A.FocusLock = 8] = "FocusLock", A[A.RestoreFocus = 16] = "RestoreFocus", A[A.All = 30] = "All", A))(_$1 || {});
function z(A, B) {
  let L = useRef(null), K = y$1(L, B), { initialFocus: re, containers: W, features: J = 30, ...ne } = A;
  l$4() || (J = 1);
  let ie = n$2(L);
  Y({ ownerDocument: ie }, !!(J & 16));
  let oe = Z({ ownerDocument: ie, container: L, initialFocus: re }, !!(J & 2));
  $({ ownerDocument: ie, container: L, containers: W, previousActiveElement: oe }, !!(J & 8));
  let V = n(), ce = o$6((at) => {
    let lt = L.current;
    lt && ((ht) => ht())(() => {
      u$7(V.current, { [s$4.Forwards]: () => {
        O$1(lt, M$2.First, { skipElements: [at.relatedTarget] });
      }, [s$4.Backwards]: () => {
        O$1(lt, M$2.Last, { skipElements: [at.relatedTarget] });
      } });
    });
  }), ke = p$3(), Ce = useRef(!1), it = { ref: K, onKeyDown(at) {
    at.key == "Tab" && (Ce.current = !0, ke.requestAnimationFrame(() => {
      Ce.current = !1;
    }));
  }, onBlur(at) {
    let lt = P(W);
    L.current instanceof HTMLElement && lt.add(L.current);
    let ht = at.relatedTarget;
    ht instanceof HTMLElement && ht.dataset.headlessuiFocusGuard !== "true" && (S$4(lt, ht) || (Ce.current ? O$1(L.current, u$7(V.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: at.target }) : at.target instanceof HTMLElement && y$3(at.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(J & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: ce, features: s$6.Focusable }), C$1({ ourProps: it, theirProps: ne, defaultTag: X, name: "FocusTrap" }), !!(J & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: ce, features: s$6.Focusable }));
}
let D$2 = U$3(z), de$1 = Object.assign(D$2, { features: _$1 });
function Q(A = !0) {
  let B = useRef(t$2.slice());
  return m$2(([L], [K]) => {
    K === !0 && L === !1 && t$7(() => {
      B.current.splice(0);
    }), K === !1 && L === !0 && (B.current = t$2.slice());
  }, [A, t$2, B]), o$6(() => {
    var L;
    return (L = B.current.find((K) => K != null && K.isConnected)) != null ? L : null;
  });
}
function Y({ ownerDocument: A }, B) {
  let L = Q(B);
  m$2(() => {
    B || (A == null ? void 0 : A.activeElement) === (A == null ? void 0 : A.body) && y$3(L());
  }, [B]), c$3(() => {
    B && y$3(L());
  });
}
function Z({ ownerDocument: A, container: B, initialFocus: L }, K) {
  let re = useRef(null), W = f$4();
  return m$2(() => {
    if (!K) return;
    let J = B.current;
    J && t$7(() => {
      if (!W.current) return;
      let ne = A == null ? void 0 : A.activeElement;
      if (L != null && L.current) {
        if ((L == null ? void 0 : L.current) === ne) {
          re.current = ne;
          return;
        }
      } else if (J.contains(ne)) {
        re.current = ne;
        return;
      }
      L != null && L.current ? y$3(L.current) : O$1(J, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), re.current = A == null ? void 0 : A.activeElement;
    });
  }, [K]), re;
}
function $({ ownerDocument: A, container: B, containers: L, previousActiveElement: K }, re) {
  let W = f$4();
  E(A == null ? void 0 : A.defaultView, "focus", (J) => {
    if (!re || !W.current) return;
    let ne = P(L);
    B.current instanceof HTMLElement && ne.add(B.current);
    let ie = K.current;
    if (!ie) return;
    let oe = J.target;
    oe && oe instanceof HTMLElement ? S$4(ne, oe) ? (K.current = oe, y$3(oe)) : (J.preventDefault(), J.stopPropagation(), y$3(ie)) : y$3(K.current);
  }, !0);
}
function S$4(A, B) {
  for (let L of A) if (L.contains(B)) return !0;
  return !1;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function l$2(A) {
  return C__default.createElement(e.Provider, { value: A.force }, A.children);
}
function F(A) {
  let B = a$5(), L = useContext(_), K = n$2(A), [re, W] = useState(() => {
    if (!B && L !== null || s$a.isServer) return null;
    let J = K == null ? void 0 : K.getElementById("headlessui-portal-root");
    if (J) return J;
    if (K === null) return null;
    let ne = K.createElement("div");
    return ne.setAttribute("id", "headlessui-portal-root"), K.body.appendChild(ne);
  });
  return useEffect(() => {
    re !== null && (K != null && K.body.contains(re) || K == null || K.body.appendChild(re));
  }, [re, K]), useEffect(() => {
    B || L !== null && W(L.current);
  }, [L, W, B]), re;
}
let U$2 = Fragment;
function N$1(A, B) {
  let L = A, K = useRef(null), re = y$1(T((V) => {
    K.current = V;
  }), B), W = n$2(K), J = F(K), [ne] = useState(() => {
    var V;
    return s$a.isServer ? null : (V = W == null ? void 0 : W.createElement("div")) != null ? V : null;
  }), ie = useContext(f$3), oe = l$4();
  return l$5(() => {
    !J || !ne || J.contains(ne) || (ne.setAttribute("data-headlessui-portal", ""), J.appendChild(ne));
  }, [J, ne]), l$5(() => {
    if (ne && ie) return ie.register(ne);
  }, [ie, ne]), c$3(() => {
    var V;
    !J || !ne || (ne instanceof Node && J.contains(ne) && J.removeChild(ne), J.childNodes.length <= 0 && ((V = J.parentElement) == null || V.removeChild(J)));
  }), oe ? !J || !ne ? null : createPortal(C$1({ ourProps: { ref: re }, theirProps: L, defaultTag: U$2, name: "Portal" }), ne) : null;
}
let S$3 = Fragment, _ = createContext(null);
function j(A, B) {
  let { target: L, ...K } = A, re = { ref: y$1(B) };
  return C__default.createElement(_.Provider, { value: L }, C$1({ ourProps: re, theirProps: K, defaultTag: S$3, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee() {
  let A = useContext(f$3), B = useRef([]), L = o$6((W) => (B.current.push(W), A && A.register(W), () => K(W))), K = o$6((W) => {
    let J = B.current.indexOf(W);
    J !== -1 && B.current.splice(J, 1), A && A.unregister(W);
  }), re = useMemo(() => ({ register: L, unregister: K, portals: B }), [L, K, B]);
  return [B, useMemo(() => function({ children: W }) {
    return C__default.createElement(f$3.Provider, { value: re }, W);
  }, [re])];
}
let D$1 = U$3(N$1), I$3 = U$3(j), te = Object.assign(D$1, { Group: I$3 });
function i$3(A, B) {
  return A === B && (A !== 0 || 1 / A === 1 / B) || A !== A && B !== B;
}
const d$2 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$3, useLayoutEffect: f$2, useDebugValue: p$1 } = C$2;
function y(A, B, L) {
  const K = B(), [{ inst: re }, W] = u$1({ inst: { value: K, getSnapshot: B } });
  return f$2(() => {
    re.value = K, re.getSnapshot = B, r$2(re) && W({ inst: re });
  }, [A, K, B]), h$3(() => (r$2(re) && W({ inst: re }), A(() => {
    r$2(re) && W({ inst: re });
  })), [A]), p$1(K), K;
}
function r$2(A) {
  const B = A.getSnapshot, L = A.value;
  try {
    const K = B();
    return !d$2(L, K);
  } catch {
    return !0;
  }
}
function t$1(A, B, L) {
  return B();
}
const r$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$3 = !r$1, c$2 = s$3 ? t$1 : y, a$4 = "useSyncExternalStore" in C$2 ? ((A) => A.useSyncExternalStore)(C$2) : c$2;
function S$2(A) {
  return a$4(A.subscribe, A.getSnapshot, A.getSnapshot);
}
function a$3(A, B) {
  let L = A(), K = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return L;
  }, subscribe(re) {
    return K.add(re), () => K.delete(re);
  }, dispatch(re, ...W) {
    let J = B[re].call(L, ...W);
    J && (L = J, K.forEach((ne) => ne()));
  } };
}
function c$1() {
  let A;
  return { before({ doc: B }) {
    var L;
    let K = B.documentElement;
    A = ((L = B.defaultView) != null ? L : window).innerWidth - K.clientWidth;
  }, after({ doc: B, d: L }) {
    let K = B.documentElement, re = K.clientWidth - K.offsetWidth, W = A - re;
    L.style(K, "paddingRight", `${W}px`);
  } };
}
function d$1() {
  return t$6() ? { before({ doc: A, d: B, meta: L }) {
    function K(re) {
      return L.containers.flatMap((W) => W()).some((W) => W.contains(re));
    }
    B.microTask(() => {
      var re;
      if (window.getComputedStyle(A.documentElement).scrollBehavior !== "auto") {
        let ne = o$5();
        ne.style(A.documentElement, "scrollBehavior", "auto"), B.add(() => B.microTask(() => ne.dispose()));
      }
      let W = (re = window.scrollY) != null ? re : window.pageYOffset, J = null;
      B.addEventListener(A, "click", (ne) => {
        if (ne.target instanceof HTMLElement) try {
          let ie = ne.target.closest("a");
          if (!ie) return;
          let { hash: oe } = new URL(ie.href), V = A.querySelector(oe);
          V && !K(V) && (J = V);
        } catch {
        }
      }, !0), B.addEventListener(A, "touchstart", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && K(ie.parentElement); ) ie = ie.parentElement;
          B.style(ie, "overscrollBehavior", "contain");
        } else B.style(ne.target, "touchAction", "none");
      }), B.addEventListener(A, "touchmove", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && ie.dataset.headlessuiPortal !== "" && !(ie.scrollHeight > ie.clientHeight || ie.scrollWidth > ie.clientWidth); ) ie = ie.parentElement;
          ie.dataset.headlessuiPortal === "" && ne.preventDefault();
        } else ne.preventDefault();
      }, { passive: !1 }), B.add(() => {
        var ne;
        let ie = (ne = window.scrollY) != null ? ne : window.pageYOffset;
        W !== ie && window.scrollTo(0, W), J && J.isConnected && (J.scrollIntoView({ block: "nearest" }), J = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: A, d: B }) {
    B.style(A.documentElement, "overflow", "hidden");
  } };
}
function m(A) {
  let B = {};
  for (let L of A) Object.assign(B, L(B));
  return B;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(A, B) {
  var L;
  let K = (L = this.get(A)) != null ? L : { doc: A, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return K.count++, K.meta.add(B), this.set(A, K), this;
}, POP(A, B) {
  let L = this.get(A);
  return L && (L.count--, L.meta.delete(B)), this;
}, SCROLL_PREVENT({ doc: A, d: B, meta: L }) {
  let K = { doc: A, d: B, meta: m(L) }, re = [d$1(), c$1(), l$1()];
  re.forEach(({ before: W }) => W == null ? void 0 : W(K)), re.forEach(({ after: W }) => W == null ? void 0 : W(K));
}, SCROLL_ALLOW({ d: A }) {
  A.dispose();
}, TEARDOWN({ doc: A }) {
  this.delete(A);
} });
a$2.subscribe(() => {
  let A = a$2.getSnapshot(), B = /* @__PURE__ */ new Map();
  for (let [L] of A) B.set(L, L.documentElement.style.overflow);
  for (let L of A.values()) {
    let K = B.get(L.doc) === "hidden", re = L.count !== 0;
    (re && !K || !re && K) && a$2.dispatch(L.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", L), L.count === 0 && a$2.dispatch("TEARDOWN", L);
  }
});
function p(A, B, L) {
  let K = S$2(a$2), re = A ? K.get(A) : void 0, W = re ? re.count > 0 : !1;
  return l$5(() => {
    if (!(!A || !B)) return a$2.dispatch("PUSH", A, L), () => a$2.dispatch("POP", A, L);
  }, [B, A]), W;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(A, B = !0) {
  l$5(() => {
    var L;
    if (!B) return;
    let K = typeof A == "function" ? A() : A.current;
    if (!K) return;
    function re() {
      var J;
      if (!K) return;
      let ne = (J = t.get(K)) != null ? J : 1;
      if (ne === 1 ? t.delete(K) : t.set(K, ne - 1), ne !== 1) return;
      let ie = u.get(K);
      ie && (ie["aria-hidden"] === null ? K.removeAttribute("aria-hidden") : K.setAttribute("aria-hidden", ie["aria-hidden"]), K.inert = ie.inert, u.delete(K));
    }
    let W = (L = t.get(K)) != null ? L : 0;
    return t.set(K, W + 1), W !== 0 || (u.set(K, { "aria-hidden": K.getAttribute("aria-hidden"), inert: K.inert }), K.setAttribute("aria-hidden", "true"), K.inert = !0), re;
  }, [A, B]);
}
function N({ defaultContainers: A = [], portals: B, mainTreeNodeRef: L } = {}) {
  var K;
  let re = useRef((K = L == null ? void 0 : L.current) != null ? K : null), W = n$2(re), J = o$6(() => {
    var ne, ie, oe;
    let V = [];
    for (let ce of A) ce !== null && (ce instanceof HTMLElement ? V.push(ce) : "current" in ce && ce.current instanceof HTMLElement && V.push(ce.current));
    if (B != null && B.current) for (let ce of B.current) V.push(ce);
    for (let ce of (ne = W == null ? void 0 : W.querySelectorAll("html > *, body > *")) != null ? ne : []) ce !== document.body && ce !== document.head && ce instanceof HTMLElement && ce.id !== "headlessui-portal-root" && (ce.contains(re.current) || ce.contains((oe = (ie = re.current) == null ? void 0 : ie.getRootNode()) == null ? void 0 : oe.host) || V.some((ke) => ce.contains(ke)) || V.push(ce));
    return V;
  });
  return { resolveContainers: J, contains: o$6((ne) => J().some((ie) => ie.contains(ne))), mainTreeNodeRef: re, MainTreeNode: useMemo(() => function() {
    return L != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: re });
  }, [re, L]) };
}
let a$1 = createContext(() => {
});
a$1.displayName = "StackContext";
var s$2 = ((A) => (A[A.Add = 0] = "Add", A[A.Remove = 1] = "Remove", A))(s$2 || {});
function x$1() {
  return useContext(a$1);
}
function b$2({ children: A, onUpdate: B, type: L, element: K, enabled: re }) {
  let W = x$1(), J = o$6((...ne) => {
    B == null || B(...ne), W(...ne);
  });
  return l$5(() => {
    let ne = re === void 0 || re === !0;
    return ne && J(0, L, K), () => {
      ne && J(1, L, K);
    };
  }, [J, L, K, re]), C__default.createElement(a$1.Provider, { value: J }, A);
}
let d = createContext(null);
function f$1() {
  let A = useContext(d);
  if (A === null) {
    let B = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(B, f$1), B;
  }
  return A;
}
function w$1() {
  let [A, B] = useState([]);
  return [A.length > 0 ? A.join(" ") : void 0, useMemo(() => function(L) {
    let K = o$6((W) => (B((J) => [...J, W]), () => B((J) => {
      let ne = J.slice(), ie = ne.indexOf(W);
      return ie !== -1 && ne.splice(ie, 1), ne;
    }))), re = useMemo(() => ({ register: K, slot: L.slot, name: L.name, props: L.props }), [K, L.slot, L.name, L.props]);
    return C__default.createElement(d.Provider, { value: re }, L.children);
  }, [B])];
}
let I$2 = "p";
function S$1(A, B) {
  let L = I$5(), { id: K = `headlessui-description-${L}`, ...re } = A, W = f$1(), J = y$1(B);
  l$5(() => W.register(K), [K, W.register]);
  let ne = { ref: J, ...W.props, id: K };
  return C$1({ ourProps: ne, theirProps: re, slot: W.slot || {}, defaultTag: I$2, name: W.name || "Description" });
}
let h$2 = U$3(S$1), G = Object.assign(h$2, {});
var Me$1 = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(Me$1 || {}), we = ((A) => (A[A.SetTitleId = 0] = "SetTitleId", A))(we || {});
let He$1 = { 0(A, B) {
  return A.titleId === B.id ? A : { ...A, titleId: B.id };
} }, I$1 = createContext(null);
I$1.displayName = "DialogContext";
function b$1(A) {
  let B = useContext(I$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, b$1), L;
  }
  return B;
}
function Be(A, B, L = () => [document.body]) {
  p(A, B, (K) => {
    var re;
    return { containers: [...(re = K.containers) != null ? re : [], L] };
  });
}
function Ge(A, B) {
  return u$7(B.type, He$1, A, B);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-${L}`, open: re, onClose: W, initialFocus: J, role: ne = "dialog", __demoMode: ie = !1, ...oe } = A, [V, ce] = useState(0), ke = useRef(!1);
  ne = function() {
    return ne === "dialog" || ne === "alertdialog" ? ne : (ke.current || (ke.current = !0, console.warn(`Invalid role [${ne}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Ce = u$3();
  re === void 0 && Ce !== null && (re = (Ce & d$3.Open) === d$3.Open);
  let it = useRef(null), at = y$1(it, B), lt = n$2(it), ht = A.hasOwnProperty("open") || Ce !== null, dt = A.hasOwnProperty("onClose");
  if (!ht && !dt) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!ht) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!dt) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof re != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${re}`);
  if (typeof W != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${W}`);
  let bt = re ? 0 : 1, [vt, Bt] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), At = o$6(() => W(!1)), Nt = o$6((Mt) => Bt({ type: 0, id: Mt })), $t = l$4() ? ie ? !1 : bt === 0 : !1, mt = V > 1, xt = useContext(I$1) !== null, [wt, Oe] = ee(), rt = { get current() {
    var Mt;
    return (Mt = vt.panelRef.current) != null ? Mt : it.current;
  } }, { resolveContainers: pe, mainTreeNodeRef: nt, MainTreeNode: ot } = N({ portals: wt, defaultContainers: [rt] }), st = mt ? "parent" : "leaf", ut = Ce !== null ? (Ce & d$3.Closing) === d$3.Closing : !1, pt = xt || ut ? !1 : $t, ft = useCallback(() => {
    var Mt, Pt;
    return (Pt = Array.from((Mt = lt == null ? void 0 : lt.querySelectorAll("body > *")) != null ? Mt : []).find((Kt) => Kt.id === "headlessui-portal-root" ? !1 : Kt.contains(nt.current) && Kt instanceof HTMLElement)) != null ? Pt : null;
  }, [nt]);
  b$3(ft, pt);
  let yt = mt ? !0 : $t, ct = useCallback(() => {
    var Mt, Pt;
    return (Pt = Array.from((Mt = lt == null ? void 0 : lt.querySelectorAll("[data-headlessui-portal]")) != null ? Mt : []).find((Kt) => Kt.contains(nt.current) && Kt instanceof HTMLElement)) != null ? Pt : null;
  }, [nt]);
  b$3(ct, yt), y$2(pe, (Mt) => {
    Mt.preventDefault(), At();
  }, !(!$t || mt));
  let qt = !(mt || bt !== 0);
  E(lt == null ? void 0 : lt.defaultView, "keydown", (Mt) => {
    qt && (Mt.defaultPrevented || Mt.key === o$2.Escape && (Mt.preventDefault(), Mt.stopPropagation(), At()));
  }), Be(lt, !(ut || bt !== 0 || xt), pe), useEffect(() => {
    if (bt !== 0 || !it.current) return;
    let Mt = new ResizeObserver((Pt) => {
      for (let Kt of Pt) {
        let Zt = Kt.target.getBoundingClientRect();
        Zt.x === 0 && Zt.y === 0 && Zt.width === 0 && Zt.height === 0 && At();
      }
    });
    return Mt.observe(it.current), () => Mt.disconnect();
  }, [bt, it, At]);
  let [Ot, Tt] = w$1(), Rt = useMemo(() => [{ dialogState: bt, close: At, setTitleId: Nt }, vt], [bt, vt, At, Nt]), Ut = useMemo(() => ({ open: bt === 0 }), [bt]), Gt = { ref: at, id: K, role: ne, "aria-modal": bt === 0 ? !0 : void 0, "aria-labelledby": vt.titleId, "aria-describedby": Ot };
  return C__default.createElement(b$2, { type: "Dialog", enabled: bt === 0, element: it, onUpdate: o$6((Mt, Pt) => {
    Pt === "Dialog" && u$7(Mt, { [s$2.Add]: () => ce((Kt) => Kt + 1), [s$2.Remove]: () => ce((Kt) => Kt - 1) });
  }) }, C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$1.Provider, { value: Rt }, C__default.createElement(te.Group, { target: it }, C__default.createElement(l$2, { force: !1 }, C__default.createElement(Tt, { slot: Ut, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: J, containers: pe, features: $t ? u$7(st, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(Oe, null, C$1({ ourProps: Gt, theirProps: oe, slot: Ut, defaultTag: Ne$1, features: Ue, visible: bt === 0, name: "Dialog" }))))))))), C__default.createElement(ot, null));
}
let $e = "div";
function Ye(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-overlay-${L}`, ...re } = A, [{ dialogState: W, close: J }] = b$1("Dialog.Overlay"), ne = y$1(B), ie = o$6((V) => {
    if (V.target === V.currentTarget) {
      if (r$3(V.currentTarget)) return V.preventDefault();
      V.preventDefault(), V.stopPropagation(), J();
    }
  }), oe = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0, onClick: ie }, theirProps: re, slot: oe, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-backdrop-${L}`, ...re } = A, [{ dialogState: W }, J] = b$1("Dialog.Backdrop"), ne = y$1(B);
  useEffect(() => {
    if (J.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [J.panelRef]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0 }, theirProps: re, slot: ie, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-panel-${L}`, ...re } = A, [{ dialogState: W }, J] = b$1("Dialog.Panel"), ne = y$1(B, J.panelRef), ie = useMemo(() => ({ open: W === 0 }), [W]), oe = o$6((V) => {
    V.stopPropagation();
  });
  return C$1({ ourProps: { ref: ne, id: K, onClick: oe }, theirProps: re, slot: ie, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-title-${L}`, ...re } = A, [{ dialogState: W, setTitleId: J }] = b$1("Dialog.Title"), ne = y$1(B);
  useEffect(() => (J(K), () => J(null)), [K, J]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K }, theirProps: re, slot: ie, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(A) {
  var B, L;
  let K = (B = A.innerText) != null ? B : "", re = A.cloneNode(!0);
  if (!(re instanceof HTMLElement)) return K;
  let W = !1;
  for (let ne of re.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ne.remove(), W = !0;
  let J = W ? (L = re.innerText) != null ? L : "" : K;
  return a.test(J) && (J = J.replace(a, "")), J;
}
function g$1(A) {
  let B = A.getAttribute("aria-label");
  if (typeof B == "string") return B.trim();
  let L = A.getAttribute("aria-labelledby");
  if (L) {
    let K = L.split(" ").map((re) => {
      let W = document.getElementById(re);
      if (W) {
        let J = W.getAttribute("aria-label");
        return typeof J == "string" ? J.trim() : o$1(W).trim();
      }
      return null;
    }).filter(Boolean);
    if (K.length > 0) return K.join(", ");
  }
  return o$1(A).trim();
}
function s$1(A) {
  let B = useRef(""), L = useRef("");
  return o$6(() => {
    let K = A.current;
    if (!K) return "";
    let re = K.innerText;
    if (B.current === re) return L.current;
    let W = g$1(K).trim().toLowerCase();
    return B.current = re, L.current = W, W;
  });
}
var me = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(me || {}), de = ((A) => (A[A.Pointer = 0] = "Pointer", A[A.Other = 1] = "Other", A))(de || {}), fe = ((A) => (A[A.OpenMenu = 0] = "OpenMenu", A[A.CloseMenu = 1] = "CloseMenu", A[A.GoToItem = 2] = "GoToItem", A[A.Search = 3] = "Search", A[A.ClearSearch = 4] = "ClearSearch", A[A.RegisterItem = 5] = "RegisterItem", A[A.UnregisterItem = 6] = "UnregisterItem", A))(fe || {});
function w(A, B = (L) => L) {
  let L = A.activeItemIndex !== null ? A.items[A.activeItemIndex] : null, K = I$4(B(A.items.slice()), (W) => W.dataRef.current.domRef.current), re = L ? K.indexOf(L) : null;
  return re === -1 && (re = null), { items: K, activeItemIndex: re };
}
let Te = { 1(A) {
  return A.menuState === 1 ? A : { ...A, activeItemIndex: null, menuState: 1 };
}, 0(A) {
  return A.menuState === 0 ? A : { ...A, __demoMode: !1, menuState: 0 };
}, 2: (A, B) => {
  var L;
  let K = w(A), re = f$5(B, { resolveItems: () => K.items, resolveActiveIndex: () => K.activeItemIndex, resolveId: (W) => W.id, resolveDisabled: (W) => W.dataRef.current.disabled });
  return { ...A, ...K, searchQuery: "", activeItemIndex: re, activationTrigger: (L = B.trigger) != null ? L : 1 };
}, 3: (A, B) => {
  let L = A.searchQuery !== "" ? 0 : 1, K = A.searchQuery + B.value.toLowerCase(), re = (A.activeItemIndex !== null ? A.items.slice(A.activeItemIndex + L).concat(A.items.slice(0, A.activeItemIndex + L)) : A.items).find((J) => {
    var ne;
    return ((ne = J.dataRef.current.textValue) == null ? void 0 : ne.startsWith(K)) && !J.dataRef.current.disabled;
  }), W = re ? A.items.indexOf(re) : -1;
  return W === -1 || W === A.activeItemIndex ? { ...A, searchQuery: K } : { ...A, searchQuery: K, activeItemIndex: W, activationTrigger: 1 };
}, 4(A) {
  return A.searchQuery === "" ? A : { ...A, searchQuery: "", searchActiveItemIndex: null };
}, 5: (A, B) => {
  let L = w(A, (K) => [...K, { id: B.id, dataRef: B.dataRef }]);
  return { ...A, ...L };
}, 6: (A, B) => {
  let L = w(A, (K) => {
    let re = K.findIndex((W) => W.id === B.id);
    return re !== -1 && K.splice(re, 1), K;
  });
  return { ...A, ...L, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C(A) {
  let B = useContext(U$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, C), L;
  }
  return B;
}
function ye$1(A, B) {
  return u$7(B.type, Te, A, B);
}
let Ie = Fragment;
function Me(A, B) {
  let { __demoMode: L = !1, ...K } = A, re = useReducer(ye$1, { __demoMode: L, menuState: L ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: W, itemsRef: J, buttonRef: ne }, ie] = re, oe = y$1(B);
  y$2([ne, J], (Ce, it) => {
    var at;
    ie({ type: 1 }), h$4(it, T$2.Loose) || (Ce.preventDefault(), (at = ne.current) == null || at.focus());
  }, W === 0);
  let V = o$6(() => {
    ie({ type: 1 });
  }), ce = useMemo(() => ({ open: W === 0, close: V }), [W, V]), ke = { ref: oe };
  return C__default.createElement(U$1.Provider, { value: re }, C__default.createElement(s$5, { value: u$7(W, { 0: d$3.Open, 1: d$3.Closed }) }, C$1({ ourProps: ke, theirProps: K, slot: ce, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(A, B) {
  var L;
  let K = I$5(), { id: re = `headlessui-menu-button-${K}`, ...W } = A, [J, ne] = C("Menu.Button"), ie = y$1(J.buttonRef, B), oe = p$3(), V = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), oe.nextFrame(() => ne({ type: 2, focus: c$4.First }));
        break;
      case o$2.ArrowUp:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), oe.nextFrame(() => ne({ type: 2, focus: c$4.Last }));
        break;
    }
  }), ce = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
        at.preventDefault();
        break;
    }
  }), ke = o$6((at) => {
    if (r$3(at.currentTarget)) return at.preventDefault();
    A.disabled || (J.menuState === 0 ? (ne({ type: 1 }), oe.nextFrame(() => {
      var lt;
      return (lt = J.buttonRef.current) == null ? void 0 : lt.focus({ preventScroll: !0 });
    })) : (at.preventDefault(), ne({ type: 0 })));
  }), Ce = useMemo(() => ({ open: J.menuState === 0 }), [J]), it = { ref: ie, id: re, type: T$1(A, J.buttonRef), "aria-haspopup": "menu", "aria-controls": (L = J.itemsRef.current) == null ? void 0 : L.id, "aria-expanded": J.menuState === 0, onKeyDown: V, onKeyUp: ce, onClick: ke };
  return C$1({ ourProps: it, theirProps: W, slot: Ce, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O.RenderStrategy | O.Static;
function Ee(A, B) {
  var L, K;
  let re = I$5(), { id: W = `headlessui-menu-items-${re}`, ...J } = A, [ne, ie] = C("Menu.Items"), oe = y$1(ne.itemsRef, B), V = n$2(ne.itemsRef), ce = p$3(), ke = u$3(), Ce = ke !== null ? (ke & d$3.Open) === d$3.Open : ne.menuState === 0;
  useEffect(() => {
    let dt = ne.itemsRef.current;
    dt && ne.menuState === 0 && dt !== (V == null ? void 0 : V.activeElement) && dt.focus({ preventScroll: !0 });
  }, [ne.menuState, ne.itemsRef, V]), F$2({ container: ne.itemsRef.current, enabled: ne.menuState === 0, accept(dt) {
    return dt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : dt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(dt) {
    dt.setAttribute("role", "none");
  } });
  let it = o$6((dt) => {
    var bt, vt;
    switch (ce.dispose(), dt.key) {
      case o$2.Space:
        if (ne.searchQuery !== "") return dt.preventDefault(), dt.stopPropagation(), ie({ type: 3, value: dt.key });
      case o$2.Enter:
        if (dt.preventDefault(), dt.stopPropagation(), ie({ type: 1 }), ne.activeItemIndex !== null) {
          let { dataRef: Bt } = ne.items[ne.activeItemIndex];
          (vt = (bt = Bt.current) == null ? void 0 : bt.domRef.current) == null || vt.click();
        }
        D$3(ne.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.Next });
      case o$2.ArrowUp:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.First });
      case o$2.End:
      case o$2.PageDown:
        return dt.preventDefault(), dt.stopPropagation(), ie({ type: 2, focus: c$4.Last });
      case o$2.Escape:
        dt.preventDefault(), dt.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          var Bt;
          return (Bt = ne.buttonRef.current) == null ? void 0 : Bt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        dt.preventDefault(), dt.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          _$2(ne.buttonRef.current, dt.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        dt.key.length === 1 && (ie({ type: 3, value: dt.key }), ce.setTimeout(() => ie({ type: 4 }), 350));
        break;
    }
  }), at = o$6((dt) => {
    switch (dt.key) {
      case o$2.Space:
        dt.preventDefault();
        break;
    }
  }), lt = useMemo(() => ({ open: ne.menuState === 0 }), [ne]), ht = { "aria-activedescendant": ne.activeItemIndex === null || (L = ne.items[ne.activeItemIndex]) == null ? void 0 : L.id, "aria-labelledby": (K = ne.buttonRef.current) == null ? void 0 : K.id, id: W, onKeyDown: it, onKeyUp: at, role: "menu", tabIndex: 0, ref: oe };
  return C$1({ ourProps: ht, theirProps: J, slot: lt, defaultTag: Ae, features: be, visible: Ce, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(A, B) {
  let L = I$5(), { id: K = `headlessui-menu-item-${L}`, disabled: re = !1, ...W } = A, [J, ne] = C("Menu.Item"), ie = J.activeItemIndex !== null ? J.items[J.activeItemIndex].id === K : !1, oe = useRef(null), V = y$1(B, oe);
  l$5(() => {
    if (J.__demoMode || J.menuState !== 0 || !ie || J.activationTrigger === 0) return;
    let Bt = o$5();
    return Bt.requestAnimationFrame(() => {
      var At, Nt;
      (Nt = (At = oe.current) == null ? void 0 : At.scrollIntoView) == null || Nt.call(At, { block: "nearest" });
    }), Bt.dispose;
  }, [J.__demoMode, oe, ie, J.menuState, J.activationTrigger, J.activeItemIndex]);
  let ce = s$1(oe), ke = useRef({ disabled: re, domRef: oe, get textValue() {
    return ce();
  } });
  l$5(() => {
    ke.current.disabled = re;
  }, [ke, re]), l$5(() => (ne({ type: 5, id: K, dataRef: ke }), () => ne({ type: 6, id: K })), [ke, K]);
  let Ce = o$6(() => {
    ne({ type: 1 });
  }), it = o$6((Bt) => {
    if (re) return Bt.preventDefault();
    ne({ type: 1 }), D$3(J.buttonRef.current);
  }), at = o$6(() => {
    if (re) return ne({ type: 2, focus: c$4.Nothing });
    ne({ type: 2, focus: c$4.Specific, id: K });
  }), lt = u$5(), ht = o$6((Bt) => lt.update(Bt)), dt = o$6((Bt) => {
    lt.wasMoved(Bt) && (re || ie || ne({ type: 2, focus: c$4.Specific, id: K, trigger: 0 }));
  }), bt = o$6((Bt) => {
    lt.wasMoved(Bt) && (re || ie && ne({ type: 2, focus: c$4.Nothing }));
  }), vt = useMemo(() => ({ active: ie, disabled: re, close: Ce }), [ie, re, Ce]);
  return C$1({ ourProps: { id: K, ref: V, role: "menuitem", tabIndex: re === !0 ? void 0 : -1, "aria-disabled": re === !0 ? !0 : void 0, disabled: void 0, onClick: it, onFocus: at, onPointerEnter: ht, onMouseEnter: ht, onPointerMove: dt, onMouseMove: dt, onPointerLeave: bt, onMouseLeave: bt }, theirProps: W, slot: vt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c(A = 0) {
  let [B, L] = useState(A), K = f$4(), re = useCallback((ie) => {
    K.current && L((oe) => oe | ie);
  }, [B, K]), W = useCallback((ie) => !!(B & ie), [B]), J = useCallback((ie) => {
    K.current && L((oe) => oe & ~ie);
  }, [L, K]), ne = useCallback((ie) => {
    K.current && L((oe) => oe ^ ie);
  }, [L]);
  return { flags: B, addFlag: re, hasFlag: W, removeFlag: J, toggleFlag: ne };
}
function l(A) {
  let B = { called: !1 };
  return (...L) => {
    if (!B.called) return B.called = !0, A(...L);
  };
}
function g(A, ...B) {
  A && B.length > 0 && A.classList.add(...B);
}
function v(A, ...B) {
  A && B.length > 0 && A.classList.remove(...B);
}
function b(A, B) {
  let L = o$5();
  if (!A) return L.dispose;
  let { transitionDuration: K, transitionDelay: re } = getComputedStyle(A), [W, J] = [K, re].map((ie) => {
    let [oe = 0] = ie.split(",").filter(Boolean).map((V) => V.includes("ms") ? parseFloat(V) : parseFloat(V) * 1e3).sort((V, ce) => ce - V);
    return oe;
  }), ne = W + J;
  if (ne !== 0) {
    L.group((oe) => {
      oe.setTimeout(() => {
        B(), oe.dispose();
      }, ne), oe.addEventListener(A, "transitionrun", (V) => {
        V.target === V.currentTarget && oe.dispose();
      });
    });
    let ie = L.addEventListener(A, "transitionend", (oe) => {
      oe.target === oe.currentTarget && (B(), ie());
    });
  } else B();
  return L.add(() => B()), L.dispose;
}
function M$1(A, B, L, K) {
  let re = L ? "enter" : "leave", W = o$5(), J = K !== void 0 ? l(K) : () => {
  };
  re === "enter" && (A.removeAttribute("hidden"), A.style.display = "");
  let ne = u$7(re, { enter: () => B.enter, leave: () => B.leave }), ie = u$7(re, { enter: () => B.enterTo, leave: () => B.leaveTo }), oe = u$7(re, { enter: () => B.enterFrom, leave: () => B.leaveFrom });
  return v(A, ...B.base, ...B.enter, ...B.enterTo, ...B.enterFrom, ...B.leave, ...B.leaveFrom, ...B.leaveTo, ...B.entered), g(A, ...B.base, ...ne, ...oe), W.nextFrame(() => {
    v(A, ...B.base, ...ne, ...oe), g(A, ...B.base, ...ne, ...ie), b(A, () => (v(A, ...B.base, ...ne), g(A, ...B.base, ...B.entered), J()));
  }), W.dispose;
}
function D({ immediate: A, container: B, direction: L, classes: K, onStart: re, onStop: W }) {
  let J = f$4(), ne = p$3(), ie = s$9(L);
  l$5(() => {
    A && (ie.current = "enter");
  }, [A]), l$5(() => {
    let oe = o$5();
    ne.add(oe.dispose);
    let V = B.current;
    if (V && ie.current !== "idle" && J.current) return oe.dispose(), re.current(ie.current), oe.add(M$1(V, K.current, ie.current === "enter", () => {
      oe.dispose(), W.current(ie.current);
    })), oe.dispose;
  }, [L]);
}
function S(A = "") {
  return A.split(/\s+/).filter((B) => B.length > 1);
}
let I = createContext(null);
I.displayName = "TransitionContext";
var Se = ((A) => (A.Visible = "visible", A.Hidden = "hidden", A))(Se || {});
function ye() {
  let A = useContext(I);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
function xe() {
  let A = useContext(M);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(A) {
  return "children" in A ? U(A.children) : A.current.filter(({ el: B }) => B.current !== null).filter(({ state: B }) => B === "visible").length > 0;
}
function se(A, B) {
  let L = s$9(A), K = useRef([]), re = f$4(), W = p$3(), J = o$6((Ce, it = v$1.Hidden) => {
    let at = K.current.findIndex(({ el: lt }) => lt === Ce);
    at !== -1 && (u$7(it, { [v$1.Unmount]() {
      K.current.splice(at, 1);
    }, [v$1.Hidden]() {
      K.current[at].state = "hidden";
    } }), W.microTask(() => {
      var lt;
      !U(K) && re.current && ((lt = L.current) == null || lt.call(L));
    }));
  }), ne = o$6((Ce) => {
    let it = K.current.find(({ el: at }) => at === Ce);
    return it ? it.state !== "visible" && (it.state = "visible") : K.current.push({ el: Ce, state: "visible" }), () => J(Ce, v$1.Unmount);
  }), ie = useRef([]), oe = useRef(Promise.resolve()), V = useRef({ enter: [], leave: [], idle: [] }), ce = o$6((Ce, it, at) => {
    ie.current.splice(0), B && (B.chains.current[it] = B.chains.current[it].filter(([lt]) => lt !== Ce)), B == null || B.chains.current[it].push([Ce, new Promise((lt) => {
      ie.current.push(lt);
    })]), B == null || B.chains.current[it].push([Ce, new Promise((lt) => {
      Promise.all(V.current[it].map(([ht, dt]) => dt)).then(() => lt());
    })]), it === "enter" ? oe.current = oe.current.then(() => B == null ? void 0 : B.wait.current).then(() => at(it)) : at(it);
  }), ke = o$6((Ce, it, at) => {
    Promise.all(V.current[it].splice(0).map(([lt, ht]) => ht)).then(() => {
      var lt;
      (lt = ie.current.shift()) == null || lt();
    }).then(() => at(it));
  });
  return useMemo(() => ({ children: K, register: ne, unregister: J, onStart: ce, onStop: ke, wait: oe, chains: V }), [ne, J, K, ce, ke, V, oe]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(A) {
  var B;
  let L = {};
  for (let K of Pe) L[K] = (B = A[K]) != null ? B : Ne;
  return L;
}
function Re(A) {
  let B = useRef(ae(A));
  return useEffect(() => {
    B.current = ae(A);
  }, [A]), B;
}
let De = "div", le = O.RenderStrategy;
function He(A, B) {
  var L, K;
  let { beforeEnter: re, afterEnter: W, beforeLeave: J, afterLeave: ne, enter: ie, enterFrom: oe, enterTo: V, entered: ce, leave: ke, leaveFrom: Ce, leaveTo: it, ...at } = A, lt = useRef(null), ht = y$1(lt, B), dt = (L = at.unmount) == null || L ? v$1.Unmount : v$1.Hidden, { show: bt, appear: vt, initial: Bt } = ye(), [At, Nt] = useState(bt ? "visible" : "hidden"), $t = xe(), { register: mt, unregister: xt } = $t;
  useEffect(() => mt(lt), [mt, lt]), useEffect(() => {
    if (dt === v$1.Hidden && lt.current) {
      if (bt && At !== "visible") {
        Nt("visible");
        return;
      }
      return u$7(At, { hidden: () => xt(lt), visible: () => mt(lt) });
    }
  }, [At, lt, mt, xt, bt, dt]);
  let wt = s$9({ base: S(at.className), enter: S(ie), enterFrom: S(oe), enterTo: S(V), entered: S(ce), leave: S(ke), leaveFrom: S(Ce), leaveTo: S(it) }), Oe = Re({ beforeEnter: re, afterEnter: W, beforeLeave: J, afterLeave: ne }), rt = l$4();
  useEffect(() => {
    if (rt && At === "visible" && lt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [lt, At, rt]);
  let pe = Bt && !vt, nt = vt && bt && Bt, ot = !rt || pe ? "idle" : bt ? "enter" : "leave", st = c(0), ut = o$6((qt) => u$7(qt, { enter: () => {
    st.addFlag(d$3.Opening), Oe.current.beforeEnter();
  }, leave: () => {
    st.addFlag(d$3.Closing), Oe.current.beforeLeave();
  }, idle: () => {
  } })), pt = o$6((qt) => u$7(qt, { enter: () => {
    st.removeFlag(d$3.Opening), Oe.current.afterEnter();
  }, leave: () => {
    st.removeFlag(d$3.Closing), Oe.current.afterLeave();
  }, idle: () => {
  } })), ft = se(() => {
    Nt("hidden"), xt(lt);
  }, $t), yt = useRef(!1);
  D({ immediate: nt, container: lt, classes: wt, direction: ot, onStart: s$9((qt) => {
    yt.current = !0, ft.onStart(lt, qt, ut);
  }), onStop: s$9((qt) => {
    yt.current = !1, ft.onStop(lt, qt, pt), qt === "leave" && !U(ft) && (Nt("hidden"), xt(lt));
  }) });
  let ct = at, St = { ref: ht };
  return nt ? ct = { ...ct, className: t$4(at.className, ...wt.current.enter, ...wt.current.enterFrom) } : yt.current && (ct.className = t$4(at.className, (K = lt.current) == null ? void 0 : K.className), ct.className === "" && delete ct.className), C__default.createElement(M.Provider, { value: ft }, C__default.createElement(s$5, { value: u$7(At, { visible: d$3.Open, hidden: d$3.Closed }) | st.flags }, C$1({ ourProps: St, theirProps: ct, defaultTag: De, features: le, visible: At === "visible", name: "Transition.Child" })));
}
function Fe(A, B) {
  let { show: L, appear: K = !1, unmount: re = !0, ...W } = A, J = useRef(null), ne = y$1(J, B);
  l$4();
  let ie = u$3();
  if (L === void 0 && ie !== null && (L = (ie & d$3.Open) === d$3.Open), ![!0, !1].includes(L)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [oe, V] = useState(L ? "visible" : "hidden"), ce = se(() => {
    V("hidden");
  }), [ke, Ce] = useState(!0), it = useRef([L]);
  l$5(() => {
    ke !== !1 && it.current[it.current.length - 1] !== L && (it.current.push(L), Ce(!1));
  }, [it, L]);
  let at = useMemo(() => ({ show: L, appear: K, initial: ke }), [L, K, ke]);
  useEffect(() => {
    if (L) V("visible");
    else if (!U(ce)) V("hidden");
    else {
      let bt = J.current;
      if (!bt) return;
      let vt = bt.getBoundingClientRect();
      vt.x === 0 && vt.y === 0 && vt.width === 0 && vt.height === 0 && V("hidden");
    }
  }, [L, ce]);
  let lt = { unmount: re }, ht = o$6(() => {
    var bt;
    ke && Ce(!1), (bt = A.beforeEnter) == null || bt.call(A);
  }), dt = o$6(() => {
    var bt;
    ke && Ce(!1), (bt = A.beforeLeave) == null || bt.call(A);
  });
  return C__default.createElement(M.Provider, { value: ce }, C__default.createElement(I.Provider, { value: at }, C$1({ ourProps: { ...lt, as: Fragment, children: C__default.createElement(ue, { ref: ne, ...lt, ...W, beforeEnter: ht, beforeLeave: dt }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: oe === "visible", name: "Transition" })));
}
function _e(A, B) {
  let L = useContext(I) !== null, K = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !L && K ? C__default.createElement(q, { ref: B, ...A }) : C__default.createElement(ue, { ref: B, ...A }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.2692%206.04835H10.6729C7.79592%2012.2004%2012.4577%2014.8894%2015.1483%2015.4648L13.9495%2019.3884C12.7348%2018.4467%2010.7795%2018.0282%209.79384%2017.8974C5.55824%2017.662%204.20118%2020.7103%204.03982%2021.9779C3.72015%2024.4889%205.31849%2026.9215%209.07459%2026.9215C12.0795%2026.9215%2014.3758%2025.2998%2015.1483%2024.4889C18.0892%2027%2020.7958%2027.1569%2021.7814%2026.9215C26.7043%2026.5449%2027.5621%2022.004%2027.3756%2019.7807H24.1789C23.4117%2025.8072%2019.0642%2023.338%2016.9864%2021.3501L18.6646%2015.7002C30.0128%2013.1892%2029.9329%204.322%2024.1789%204.00811C19.5757%203.75701%2016.8265%209.39643%2016.0274%2012.2475C12.1914%2011.6198%2013.2569%207.85317%2014.2692%206.04835Z'%20fill='white'/%3e%3cpath%20d='M19.5437%2012.2475C19.9699%2010.6258%2021.7814%206.99461%2023.7793%207.2254C26.4965%207.53927%2022.6605%2011.5413%2019.5437%2012.2475Z'%20fill='%23303746'/%3e%3cpath%20d='M12.8307%2022.2918C11.7918%2021.2716%208.03567%2020.0946%207.31642%2022.2918C7.00817%2023.2334%209.47418%2024.8813%2012.8307%2022.2918Z'%20fill='%23303746'/%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21.403%2011.0761L22.9233%2012.9126C23.0973%2013.1219%2023.2486%2013.2846%2023.3167%2013.3853C23.7705%2013.8503%2024.0277%2014.478%2024.0277%2015.1289C23.9823%2015.8961%2023.4982%2016.423%2023.0444%2016.9887L21.9779%2018.2673L21.4257%2018.9338C21.403%2018.957%2021.3954%2018.988%2021.3879%2019.019C21.3803%2019.05%2021.3879%2019.081%2021.403%2019.1043C21.4181%2019.1353%2021.4332%2019.1585%2021.4635%2019.174C21.4862%2019.1895%2021.5165%2019.1973%2021.5467%2019.1973H27.0986C27.9458%2019.1973%2029.0123%2019.9257%2028.9518%2021.0338C28.9518%2021.5375%2028.7476%2022.018%2028.3996%2022.3744C28.0441%2022.7309%2027.5676%2022.9324%2027.0684%2022.9324H18.3699C17.795%2022.9324%2016.2595%2022.9944%2015.8284%2021.6538C15.7376%2021.3748%2015.7225%2021.0726%2015.7906%2020.7858C15.9192%2020.3596%2016.1158%2019.9567%2016.373%2019.6002C16.8117%2018.9338%2017.2807%2018.2751%2017.7496%2017.6319C18.3547%2016.7872%2018.9674%2015.9736%2019.5801%2015.1134C19.6028%2015.0824%2019.6103%2015.0514%2019.6103%2015.0127C19.6103%2014.9739%2019.5952%2014.9429%2019.5801%2014.9119L17.3714%2012.254C17.3563%2012.2385%2017.3412%2012.223%2017.3185%2012.2075C17.2958%2012.1997%2017.2731%2012.192%2017.2504%2012.192C17.2277%2012.192%2017.205%2012.1997%2017.1823%2012.2075C17.1596%2012.2152%2017.1445%2012.2307%2017.1294%2012.254C16.5394%2013.0599%2013.945%2016.6323%2013.3928%2017.3607C12.8406%2018.0814%2011.4791%2018.1279%2010.7228%2017.3607L7.26605%2013.8581C7.24335%2013.8348%207.2131%2013.8193%207.18284%2013.8116C7.15259%2013.8038%207.12233%2013.8116%207.09208%2013.8193C7.06182%2013.8348%207.03913%2013.8503%207.024%2013.8813C7.00887%2013.9045%206.99374%2013.9355%207.00131%2013.9665V20.7006C7.00887%2021.181%206.87272%2021.646%206.60042%2022.0412C6.32812%2022.4364%205.94993%2022.7309%205.50365%2022.8936C5.21623%2022.9944%204.91367%2023.0254%204.61868%2022.9789C4.32368%2022.9324%204.03626%2022.8239%203.79421%2022.6456C3.5446%2022.4674%203.34794%2022.2349%203.21179%2021.9637C3.07564%2021.6925%203%2021.3903%203%2021.0881V8.97605C3.02269%208.54209%203.17397%208.12364%203.44627%207.77492C3.71857%207.43396%204.08164%207.18598%204.49765%207.06974C4.85316%206.97675%205.23135%206.97675%205.58686%207.06974C5.94236%207.17048%206.26761%207.35646%206.53235%207.62769L11.8498%2012.9979C11.8649%2013.0134%2011.8876%2013.0289%2011.9027%2013.0366C11.9254%2013.0444%2011.9481%2013.0444%2011.9708%2013.0444C11.9935%2013.0444%2012.0162%2013.0366%2012.0313%2013.0211C12.054%2013.0134%2012.0691%2012.9979%2012.0843%2012.9746L15.8586%207.69743C16.0326%207.48045%2016.252%207.30997%2016.5016%207.19373C16.7512%207.07749%2017.0235%207.00775%2017.2958%207.00775H27.1137C27.386%207.00775%2027.6508%207.06974%2027.8928%207.17823C28.1349%207.29447%2028.3542%207.4572%2028.5358%207.65868C28.7097%207.86016%2028.8459%208.10039%2028.9215%208.36386C28.9972%208.62733%2029.0199%208.89856%2028.982%209.16978C28.914%209.63473%2028.6795%2010.0609%2028.324%2010.3632C27.9685%2010.6654%2027.5146%2010.8359%2027.0457%2010.8281H21.5467C21.5165%2010.8281%2021.4938%2010.8359%2021.4711%2010.8514C21.4484%2010.8669%2021.4257%2010.8901%2021.4181%2010.9134C21.403%2010.9366%2021.403%2010.9676%2021.403%2010.9908C21.3803%2011.0218%2021.3879%2011.0528%2021.403%2011.0761Z'%20fill='url(%23paint0_linear_3119_13568)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13568'%20x1='4.08333'%20y1='11'%20x2='29'%20y2='11'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23EF2690'/%3e%3cstop%20offset='1'%20stop-color='%23AB27FE'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11.8444%205H5.48893C5.21893%205%205%205.21883%205%205.48892V11.8444C5%2012.1144%205.21893%2012.3334%205.48893%2012.3334H11.8444C12.1145%2012.3334%2012.3334%2012.1144%2012.3334%2011.8444V5.48892C12.3334%205.21883%2012.1145%205%2011.8444%205ZM19.1807%2012.3336H12.8252C12.5552%2012.3336%2012.3363%2012.5524%2012.3363%2012.8224V19.178C12.3363%2019.448%2012.5552%2019.6669%2012.8252%2019.6669H19.1807C19.4507%2019.6669%2019.6697%2019.448%2019.6697%2019.178V12.8224C19.6697%2012.5524%2019.4507%2012.3336%2019.1807%2012.3336ZM20.1556%205.00001H26.5112C26.7812%205.00001%2027%205.21884%2027%205.48893V11.8444C27%2012.1144%2026.7812%2012.3334%2026.5112%2012.3334H20.1556C19.8856%2012.3334%2019.6666%2012.1144%2019.6666%2011.8444V5.48893C19.6666%205.21884%2019.8856%205.00001%2020.1556%205.00001ZM11.8445%2019.6665H5.48895C5.21895%2019.6665%205.00002%2019.8853%205.00002%2020.1553V26.511C5.00002%2026.781%205.21895%2026.9999%205.48895%2026.9999H11.8445C12.1146%2026.9999%2012.3334%2026.781%2012.3334%2026.511V20.1553C12.3334%2019.8853%2012.1146%2019.6665%2011.8445%2019.6665ZM20.1556%2019.6665H26.5112C26.7812%2019.6665%2027%2019.8853%2027%2020.1553V26.511C27%2026.781%2026.7812%2026.9999%2026.5112%2026.9999H20.1556C19.8856%2026.9999%2019.6666%2026.781%2019.6666%2026.511V20.1553C19.6666%2019.8853%2019.8856%2019.6665%2020.1556%2019.6665Z'%20fill='white'/%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.2892%204.87219L26.2505%2010.3415C26.7579%2010.8061%2027.0077%2011.2762%2026.9998%2011.7498C26.992%2012.2235%2026.7737%2012.6553%2026.3469%2013.047C25.9004%2013.457%2025.4185%2013.6647%2024.9032%2013.6738C24.3879%2013.6811%2023.8766%2013.4515%2023.3691%2012.9869L17.2721%207.39369C16.5798%206.75785%2015.9111%206.30785%2015.268%206.04367C14.6248%205.7795%2013.9482%205.73759%2013.2402%205.91978C12.5302%206.10015%2011.769%206.56473%2010.9528%207.31171C9.82782%208.34472%209.29089%209.31397%209.34596%2010.2195C9.40103%2011.1249%209.9596%2012.065%2011.0197%2013.0361L17.1659%2018.6767C17.6792%2019.1467%2017.931%2019.6168%2017.9231%2020.0832C17.9152%2020.5514%2017.695%2020.9832%2017.2603%2021.3822C16.8276%2021.7794%2016.3497%2021.9871%2015.8305%2022.0035C15.3112%2022.0199%2014.794%2021.7921%2014.2826%2021.3221L8.32127%2015.8528C7.35164%2014.9637%206.65146%2014.122%206.22074%2013.3276C5.79001%2012.5333%205.62874%2011.6351%205.74084%2010.633C5.84115%209.77491%206.13813%208.94413%206.63376%208.13885C7.12743%207.33357%207.83547%206.51008%208.75396%205.66654C9.84749%204.66268%2010.8919%203.89384%2011.887%203.3582C12.8803%202.82256%2013.842%202.52559%2014.7704%202.46365C15.7006%202.4017%2016.6172%202.57296%2017.5239%202.97742C18.4305%203.38188%2019.351%204.01226%2020.2872%204.87219H20.2892Z'%20fill='url(%23paint0_linear_3119_13572)'/%3e%3cpath%20d='M10.9371%2026.9408L4.97771%2021.4714C4.47027%2021.005%204.22049%2020.5368%204.22836%2020.0631C4.23623%2019.5894%204.45454%2019.1576%204.88133%2018.7659C5.32779%2018.356%205.80966%2018.1483%206.32495%2018.1392C6.84025%2018.1319%207.35162%2018.3596%207.85905%2018.826L13.9541%2024.4193C14.6484%2025.0551%2015.3151%2025.5051%2015.9583%2025.7693C16.6014%2026.0335%2017.278%2026.0735%2017.988%2025.8932C18.698%2025.7128%2019.4591%2025.2482%2020.2754%2024.4994C21.4004%2023.4664%2021.9373%2022.4972%2021.8822%2021.5917C21.8272%2020.6862%2021.2686%2019.7461%2020.2085%2018.7732L16.9338%2015.7944C16.4205%2015.3244%2016.1687%2014.8543%2016.1766%2014.3879C16.1845%2013.9197%2016.4047%2013.4879%2016.8394%2013.0889C17.2721%2012.6917%2017.75%2012.484%2018.2692%2012.4676C18.7885%2012.4512%2019.3057%2012.679%2019.8171%2013.149L22.905%2015.9566C23.8746%2016.8457%2024.5748%2017.6874%2025.0055%2018.4817C25.4362%2019.2761%2025.5975%2020.1743%2025.4854%2021.1763C25.3851%2022.0344%2025.0881%2022.8652%2024.5925%2023.6705C24.0988%2024.4757%2023.3908%2025.2992%2022.4723%2026.1428C21.3787%2027.1466%2020.3344%2027.9155%2019.3392%2028.4511C18.344%2028.9868%2017.3822%2029.2856%2016.4519%2029.3475C15.5216%2029.4094%2014.6051%2029.2382%2013.6984%2028.8337C12.7917%2028.4293%2011.8713%2027.7989%2010.9351%2026.9389L10.9371%2026.9408Z'%20fill='url(%23paint1_linear_3119_13572)'/%3e%3cpath%20d='M14.6543%2012.8284C15.8633%2012.8284%2016.8433%2011.9205%2016.8433%2010.8006C16.8433%209.6807%2015.8633%208.77284%2014.6543%208.77284C13.4453%208.77284%2012.4653%209.6807%2012.4653%2010.8006C12.4653%2011.9205%2013.4453%2012.8284%2014.6543%2012.8284Z'%20fill='url(%23paint2_radial_3119_13572)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13572'%20x1='25.27'%20y1='8.05866'%20x2='7.28614'%20y2='16.6864'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_3119_13572'%20x1='6.4668'%20y1='23.9797'%20x2='27.5911'%20y2='17.1926'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_3119_13572'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(14.6543%2010.8024)%20scale(2.18903%202.02777)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M27.0042%2026.6428V22.6649C27.0042%2022.5072%2026.9416%2022.3568%2026.8298%2022.245L9.90453%205.31965C9.79276%205.20788%209.64232%205.14521%209.4846%205.14521H5.50684C5.31046%205.14521%205.15063%205.30503%205.15063%205.50141V9.19714C5.15063%209.35487%205.21331%209.50528%205.32508%209.61706L11.4004%2015.6923C11.5393%2015.8313%2011.5393%2016.0569%2011.4004%2016.1959L5.25509%2022.3411C5.18824%2022.4079%205.15063%2022.4988%205.15063%2022.5929V26.6428C5.15063%2026.839%205.31046%2026.999%205.50684%2026.999H12.1535C12.3499%2026.999%2012.5097%2026.839%2012.5097%2026.6428V24.2569C12.5097%2024.1629%2012.5473%2024.072%2012.6142%2024.0051L15.9108%2020.7084C16.0498%2020.5695%2016.2754%2020.5695%2016.4144%2020.7084L22.5314%2026.8256C22.6432%2026.9373%2022.7936%2027%2022.9513%2027H26.647C26.8434%2027%2027.0032%2026.8401%2027.0032%2026.6438L27.0042%2026.6428Z'%20fill='white'/%3e%3cpath%20d='M18.1379%2010.413H21.467C21.6644%2010.413%2021.8253%2010.5739%2021.8253%2010.7713V14.1003C21.8253%2014.42%2022.2118%2014.5799%2022.4374%2014.3531L27.0043%209.77894C27.0711%209.71207%2027.1088%209.62121%2027.1088%209.52614V5.52017C27.1088%205.32275%2026.9488%205.16188%2026.7504%205.16188L22.6849%205.15666C22.5899%205.15666%2022.4991%205.19426%2022.4311%205.26112L17.8841%209.80087C17.6585%2010.0265%2017.8182%2010.413%2018.1369%2010.413H18.1379Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(A, B = 4, L = 5) {
  if (A.length <= B + L)
    return A;
  const K = A.slice(0, B), re = A.slice(A.length - L);
  return `${K}...${re}`;
}
const WALLET_TO_ICON = {
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: A,
  network: B,
  onViewProfile: L,
  onChangeWallet: K,
  onDisconnectWallet: re,
  renderAvatar: W
}) {
  const { wallet: J } = useWallie();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(qe$1, { as: "section", className: "wallie-relative wallie-inline-block wallie-text-left", children: ({ open: ne }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
        W ? W(A, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Avatar,
          {
            size: 28,
            variant: "beam",
            name: A,
            colors: ["#1C2DCB", "#F226B8"]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: WALLET_TO_ICON[J],
            alt: `${J} is connected`
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(A) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[B] ?? B })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: ChevronDownIcon,
          className: `dropdown-button ${ne ? "close-dropdown-button" : "expand-dropdown-button"}`,
          alt: "ord connect dropdown"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      qe,
      {
        as: Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            qe$1.Item,
            {
              as: "button",
              className: "dropdown-button",
              onClick: () => L == null ? void 0 : L(),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(A) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            qe$1.Item,
            {
              as: "button",
              className: "dropdown-button",
              onClick: () => K == null ? void 0 : K(),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            qe$1.Item,
            {
              as: "button",
              className: "dropdown-button",
              onClick: () => re == null ? void 0 : re(),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "logout" })
              ]
            }
          )
        ] })
      }
    )
  ] }) });
}
const WalletIcon = "data:image/svg+xml,%3csvg%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3cpath%20d='M9%206.25C7.61929%206.25%206.5%207.36929%206.5%208.75V21.25C6.5%2022.6308%207.61929%2023.75%209%2023.75H25C26.3808%2023.75%2027.5%2022.6308%2027.5%2021.25V18.75H23.75C21.6789%2018.75%2020%2017.0711%2020%2015C20%2012.9289%2021.6789%2011.25%2023.75%2011.25H27.5V8.75C27.5%207.36929%2026.3808%206.25%2025%206.25H9Z'%20fill='%231C2033'%20/%3e%3cpath%20d='M25%2015C25%2015.6904%2024.4404%2016.25%2023.75%2016.25C23.0596%2016.25%2022.5%2015.6904%2022.5%2015C22.5%2014.3096%2023.0596%2013.75%2023.75%2013.75C24.4404%2013.75%2025%2014.3096%2025%2015Z'%20fill='%231C2033'%20/%3e%3c/svg%3e";
function PreConnectButton({
  openModal: A,
  disabled: B,
  connectButton: L = "Wallet Connect",
  connectButtonComponent: K
}) {
  return K ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: A, "aria-label": "Connect Button", type: "button", className: "wallie-w-full", children: K }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      onClick: A,
      disabled: B,
      className: "wallie-bg-ord-orange wallie-rounded-full wallie-flex wallie-flex-row md:wallie-space-x-2 wallie-items-center wallie-p-1 wallie-pr-2 wallie-px-1 md:wallie-pr-3 md:wallie-px-3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallie-w-6 md:wallie-w-7", src: WalletIcon, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-hidden md:wallie-block wallie-text-ord-blue wallie-mb-1 wallie-pr-2", children: L })
      ]
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='19'%20height='19'%20viewBox='0%200%2019%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.07844%204.07811C4.25659%203.90001%204.49818%203.79996%204.75009%203.79996C5.002%203.79996%205.24359%203.90001%205.42174%204.07811L9.50009%208.15646L13.5784%204.07811C13.6661%203.98738%2013.7709%203.915%2013.8868%203.86521C14.0027%203.81542%2014.1274%203.78922%2014.2535%203.78812C14.3796%203.78703%2014.5047%203.81106%2014.6215%203.85883C14.7382%203.9066%2014.8443%203.97714%2014.9335%204.06633C15.0227%204.15553%2015.0933%204.2616%2015.141%204.37835C15.1888%204.4951%2015.2128%204.6202%2015.2117%204.74634C15.2106%204.87248%2015.1844%204.99714%2015.1346%205.11304C15.0848%205.22895%2015.0125%205.33378%2014.9217%205.42141L10.8434%209.49976L14.9217%2013.5781C15.0948%2013.7573%2015.1905%2013.9973%2015.1884%2014.2463C15.1862%2014.4954%2015.0863%2014.7337%2014.9102%2014.9098C14.734%2015.086%2014.4958%2015.1859%2014.2467%2015.1881C13.9976%2015.1902%2013.7576%2015.0945%2013.5784%2014.9214L9.50009%2010.8431L5.42174%2014.9214C5.24257%2015.0945%205.0026%2015.1902%204.75351%2015.1881C4.50442%2015.1859%204.26615%2015.086%204.09001%2014.9098C3.91387%2014.7337%203.81396%2014.4954%203.8118%2014.2463C3.80964%2013.9973%203.90539%2013.7573%204.07844%2013.5781L8.15679%209.49976L4.07844%205.42141C3.90034%205.24326%203.80029%205.00167%203.80029%204.74976C3.80029%204.49785%203.90034%204.25626%204.07844%204.07811Z'%20fill='%23D9D5D2'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
async function waitForUnisatExtensionReady() {
  let A = 0;
  const B = 20;
  for (; A < B; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const L = await window.unisat.getAccounts();
        if (L && L.length > 0)
          return !0;
      } catch {
        break;
      }
    A += 1, await new Promise((L) => {
      setTimeout(L, 100);
    });
  }
  return !1;
}
const LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: A,
  subtitle: B,
  onConnect: L,
  icon: K,
  setErrorMessage: re,
  isDisabled: W,
  isMobileDevice: J
  // renderAvatar,
}) {
  const { wallet: ne, address: ie } = useWallie(), [{ connectedWallet: oe, connectedAddress: V }] = useState({
    connectedWallet: ne,
    connectedAddress: ie
  }), [ce, ke] = useState(!1), Ce = WALLET_TO_NAME[A], it = useCallback(async () => {
    ke(!0), await Promise.race([
      L().then(() => ke(!1)).catch(() => ke(!1)),
      new Promise((lt) => {
        setTimeout(() => lt("timeout"), 5e3);
      })
    ]) === "timeout" ? re(
      "No wallet pop-up? The extension is not responding. Try reloading your browser."
    ) : ke(!1);
  }, [L, re]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      type: "button",
      className: "wallie-w-full wallie-flex wallie-flex-row wallie-justify-between wallie-items-center wallie-text-ord-light-gray wallie-bg-ord-light-blue wallie-hover:bg-ord-light-blue-250 wallie-p-2 wallie-rounded-lg md:wallie-text-xl wallie-space-x-4 md:space-x-6 wallie-ease-in wallie-transition-all wallie-duration-100 wallie-ease-in-outscale-120",
      onClick: it,
      disabled: W,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallie-flex wallie-flex-row wallie-space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallie-w-5 md:wallie-w-8", src: K, alt: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-text-lg wallie-block wallie-font-medium", children: Ce }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "wallie-text-sm wallie-font-medium",
              style: { display: J ? "block" : "none" },
              children: B
            }
          )
        ] }),
        oe === A && V.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-flex wallie-flex-row wallie-ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallie-text-sm wallie-font-medium wallie-pr-3", children: truncateMiddle(V.ordinals) }) }) : null,
        ce && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: 24,
            alt: `${Ce} extension is loading`
          }
        )
      ]
    }
  );
}
const WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download"
  // their www subdomain doesn't work
};
function SelectWalletModal({
  isOpen: A,
  closeModal: B
}) {
  const {
    updateAddress: L,
    network: K,
    updateWallet: re,
    updatePublicKey: W,
    updateFormat: J,
    wallet: ne,
    format: ie,
    address: oe,
    publicKey: V,
    disconnectWallet: ce
  } = useWallie(), [ke, Ce] = useState(""), it = isMobileUserAgent(), at = useCallback(
    (bt, vt) => {
      vt instanceof BrowserWalletNotInstalledError && window.open(
        WALLET_CHROME_EXTENSION_URL[bt],
        "_blank",
        "noopener,noreferrer"
      ), Ce(vt.message ?? vt.toString()), console.error(`Error while connecting to ${bt} wallet`, vt), ce();
    },
    [ce]
  ), lt = useCallback(async () => {
    if (K === "testnet") {
      const bt = new Error(
        "Magic Eden wallet is not supported on testnet"
      );
      return at(Wallet.MAGICEDEN, bt), !1;
    }
    try {
      Ce("");
      const bt = await getAddresses(K);
      if (!bt || bt.length < 1)
        throw ce(), new Error("Magic Eden via Ordit returned no addresses.");
      const vt = bt.find(
        (At) => At.format === "segwit" || At.format === "p2sh-p2wpkh"
      );
      if (!vt)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address."
        );
      const Bt = bt.find(
        (At) => At.format === "taproot"
      );
      if (!Bt)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address."
        );
      return L({
        ordinals: Bt.address,
        payments: vt.address
      }), W({
        ordinals: Bt.publicKey,
        payments: vt.publicKey
      }), re(Wallet.MAGICEDEN), J({
        ordinals: Bt.format,
        payments: vt.format
      }), B(), !0;
    } catch (bt) {
      return at(Wallet.MAGICEDEN, bt), !1;
    }
  }, [
    B,
    ce,
    K,
    at,
    L,
    J,
    W,
    re
  ]), ht = useCallback(
    async ({ readOnly: bt } = {}) => {
      try {
        Ce("");
        const vt = await getAddresses$1(K, bt);
        if (!vt || vt.length < 1)
          throw ce(), new Error("Unisat via Ordit returned no addresses.");
        const Bt = vt[0];
        return L({
          ordinals: Bt.address,
          payments: Bt.address
        }), W({
          ordinals: Bt.publicKey,
          payments: Bt.publicKey
        }), re(Wallet.UNISAT), J({
          ordinals: Bt.format,
          payments: Bt.format
        }), B(), !0;
      } catch (vt) {
        return at(Wallet.UNISAT, vt), !1;
      }
    },
    [
      B,
      ce,
      K,
      at,
      L,
      J,
      W,
      re
    ]
  ), dt = useCallback(async () => {
    try {
      Ce("");
      const bt = await getAddresses$2(K);
      if (!bt || bt.length < 1)
        throw ce(), new Error("Xverse via Ordit returned no addresses.");
      const vt = bt.find(
        (At) => At.format === "p2sh-p2wpkh" || At.format === "segwit"
      );
      if (!vt)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address."
        );
      const Bt = bt.find(
        (At) => At.format === "taproot"
      );
      if (!Bt)
        throw new Error("Xverse via Ordit did not return a Taproot address.");
      return L({
        ordinals: Bt.address,
        payments: vt.address
      }), W({
        ordinals: Bt.publicKey,
        payments: vt.publicKey
      }), re(Wallet.XVERSE), J({
        ordinals: Bt.format,
        payments: vt.format
      }), B(), !0;
    } catch (bt) {
      return at(Wallet.XVERSE, bt), !1;
    }
  }, [
    B,
    ce,
    K,
    at,
    L,
    J,
    W,
    re
  ]);
  return useEffect(() => {
    if (ne !== Wallet.UNISAT)
      return;
    let bt = !0, vt = !1;
    const Bt = () => ht();
    return oe && V && ie && (async () => {
      const Nt = await waitForUnisatExtensionReady();
      if (bt) {
        if (!Nt) {
          ce();
          return;
        }
        vt = await ht({ readOnly: !0 }), bt && vt && window.unisat.addListener("accountsChanged", Bt);
      }
    })(), () => {
      bt = !1, vt && window.unisat.removeListener("accountsChanged", Bt);
    };
  }, [ne, ht, ce]), /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: A, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "wallie-z-50 wallie-fixed wallie-inset-0 wallie-overflow-y-auto",
      onClose: B,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "wallie-ease-out wallie-duration-300",
            enterFrom: "wallie-opacity-0",
            enterTo: "wallie-opacity-100",
            leave: "wallie-ease-in wallie-duration-200",
            leaveFrom: "wallie-opacity-100",
            leaveTo: "wallie-opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-fixed wallie-inset-0 wallie-bg-black wallie-bg-opacity-90 md:wallie-bg-opacity-75 wallie-transition-opacity" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "wallie-fixed wallie-inset-0 wallie-z-10 wallie-overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallie-flex wallie-min-h-full wallie-w-full md:wallie-w-96 wallie-mx-auto wallie-items-end wallie-justify-center wallie-p-4 wallie-text-left sm:wallie-items-center sm:wallie-p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "wallie-ease-out wallie-duration-300",
            enterFrom: "wallie-opacity-0 wallie-scale-95",
            enterTo: "wallie-opacity-100 wallie-scale-100",
            leave: "wallie-ease-in wallie-duration-200",
            leaveFrom: "wallie-opacity-100 wallie-scale-100",
            leaveTo: "wallie-opacity-0 wallie-scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "wallie-relative wallie-bg-ord-blue-600 wallie-transform wallie-overflow-hidden wallie-rounded-lg wallie-p-8 wallie-transition-all wallie-w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "wallie-flex wallie-flex-row", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  _t.Title,
                  {
                    as: "h3",
                    className: "wallie-text-[21px] wallie-font-medium wallie-leading-8 wallie--mt-1  wallie-text-ord-gray",
                    children: "Connect a wallet to continue"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: B,
                    className: "wallie-ml-auto",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: CloseModalIcon,
                        alt: "close modal",
                        className: "wallie-w-[19px] wallie-h-[19px]"
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallie-text-ord-light-blue-400 wallie-font-medium wallie-py-3", children: "Choose a wallet below to connect and continue" }),
              ke && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallie-text-ord-alert wallie-pb-4", children: ke }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "wallie-w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "wallie-w-full wallie-space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.XVERSE,
                    subtitle: "",
                    onConnect: dt,
                    icon: XverseWalletIcon,
                    setErrorMessage: Ce,
                    isMobileDevice: it
                  }
                ),
                !it && // TODO: remove this once unisat supported on mobile devices
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.UNISAT,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: ht,
                    icon: UnisatWalletIcon,
                    setErrorMessage: Ce,
                    isDisabled: it,
                    isMobileDevice: it
                  }
                ),
                !it && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WalletButton,
                  {
                    wallet: Wallet.MAGICEDEN,
                    subtitle: "Coming soon on mobile browsing",
                    onConnect: lt,
                    icon: MagicEdenWalletIcon,
                    setErrorMessage: Ce,
                    isDisabled: it,
                    isMobileDevice: it
                  }
                ) })
              ] }) })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  connectButton: A,
  connectButtonComponent: B,
  hideConnectButton: L,
  onViewProfile: K,
  onChangeWalletClick: re,
  onDisconnectWalletClick: W,
  renderAvatar: J
}) {
  const {
    address: ne,
    disconnectWallet: ie,
    network: oe,
    isModalOpen: V,
    openModal: ce,
    closeModal: ke
  } = useWallie(), Ce = useHasMounted(), it = () => L ? null : ne != null && ne.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ne.ordinals,
      network: oe,
      onViewProfile: K,
      onChangeWallet: () => {
        ce(), re == null || re();
      },
      onDisconnectWallet: () => {
        ie(), W == null || W();
      },
      renderAvatar: J
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    PreConnectButton,
    {
      disabled: !Ce,
      connectButton: A,
      connectButtonComponent: B,
      openModal: ce
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    it(),
    Ce ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectWalletModal, { isOpen: V, closeModal: ke }) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(A) {
  var B, L, K, re = dt.prototype = { constructor: dt, toString: null, valueOf: null }, W = new dt(1), J = 20, ne = 4, ie = -7, oe = 21, V = -1e7, ce = 1e7, ke = !1, Ce = 1, it = 0, at = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, lt = "0123456789abcdefghijklmnopqrstuvwxyz", ht = !0;
  function dt($t, mt) {
    var xt, wt, Oe, rt, pe, nt, ot, st, ut = this;
    if (!(ut instanceof dt)) return new dt($t, mt);
    if (mt == null) {
      if ($t && $t._isBigNumber === !0) {
        ut.s = $t.s, !$t.c || $t.e > ce ? ut.c = ut.e = null : $t.e < V ? ut.c = [ut.e = 0] : (ut.e = $t.e, ut.c = $t.c.slice());
        return;
      }
      if ((nt = typeof $t == "number") && $t * 0 == 0) {
        if (ut.s = 1 / $t < 0 ? ($t = -$t, -1) : 1, $t === ~~$t) {
          for (rt = 0, pe = $t; pe >= 10; pe /= 10, rt++) ;
          rt > ce ? ut.c = ut.e = null : (ut.e = rt, ut.c = [$t]);
          return;
        }
        st = String($t);
      } else {
        if (!isNumeric.test(st = String($t))) return K(ut, st, nt);
        ut.s = st.charCodeAt(0) == 45 ? (st = st.slice(1), -1) : 1;
      }
      (rt = st.indexOf(".")) > -1 && (st = st.replace(".", "")), (pe = st.search(/e/i)) > 0 ? (rt < 0 && (rt = pe), rt += +st.slice(pe + 1), st = st.substring(0, pe)) : rt < 0 && (rt = st.length);
    } else {
      if (intCheck(mt, 2, lt.length, "Base"), mt == 10 && ht)
        return ut = new dt($t), At(ut, J + ut.e + 1, ne);
      if (st = String($t), nt = typeof $t == "number") {
        if ($t * 0 != 0) return K(ut, st, nt, mt);
        if (ut.s = 1 / $t < 0 ? (st = st.slice(1), -1) : 1, dt.DEBUG && st.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + $t);
      } else
        ut.s = st.charCodeAt(0) === 45 ? (st = st.slice(1), -1) : 1;
      for (xt = lt.slice(0, mt), rt = pe = 0, ot = st.length; pe < ot; pe++)
        if (xt.indexOf(wt = st.charAt(pe)) < 0) {
          if (wt == ".") {
            if (pe > rt) {
              rt = ot;
              continue;
            }
          } else if (!Oe && (st == st.toUpperCase() && (st = st.toLowerCase()) || st == st.toLowerCase() && (st = st.toUpperCase()))) {
            Oe = !0, pe = -1, rt = 0;
            continue;
          }
          return K(ut, String($t), nt, mt);
        }
      nt = !1, st = L(st, mt, 10, ut.s), (rt = st.indexOf(".")) > -1 ? st = st.replace(".", "") : rt = st.length;
    }
    for (pe = 0; st.charCodeAt(pe) === 48; pe++) ;
    for (ot = st.length; st.charCodeAt(--ot) === 48; ) ;
    if (st = st.slice(pe, ++ot)) {
      if (ot -= pe, nt && dt.DEBUG && ot > 15 && ($t > MAX_SAFE_INTEGER$2 || $t !== mathfloor($t)))
        throw Error(tooManyDigits + ut.s * $t);
      if ((rt = rt - pe - 1) > ce)
        ut.c = ut.e = null;
      else if (rt < V)
        ut.c = [ut.e = 0];
      else {
        if (ut.e = rt, ut.c = [], pe = (rt + 1) % LOG_BASE, rt < 0 && (pe += LOG_BASE), pe < ot) {
          for (pe && ut.c.push(+st.slice(0, pe)), ot -= LOG_BASE; pe < ot; )
            ut.c.push(+st.slice(pe, pe += LOG_BASE));
          pe = LOG_BASE - (st = st.slice(pe)).length;
        } else
          pe -= ot;
        for (; pe--; st += "0") ;
        ut.c.push(+st);
      }
    } else
      ut.c = [ut.e = 0];
  }
  dt.clone = clone, dt.ROUND_UP = 0, dt.ROUND_DOWN = 1, dt.ROUND_CEIL = 2, dt.ROUND_FLOOR = 3, dt.ROUND_HALF_UP = 4, dt.ROUND_HALF_DOWN = 5, dt.ROUND_HALF_EVEN = 6, dt.ROUND_HALF_CEIL = 7, dt.ROUND_HALF_FLOOR = 8, dt.EUCLID = 9, dt.config = dt.set = function($t) {
    var mt, xt;
    if ($t != null)
      if (typeof $t == "object") {
        if ($t.hasOwnProperty(mt = "DECIMAL_PLACES") && (xt = $t[mt], intCheck(xt, 0, MAX, mt), J = xt), $t.hasOwnProperty(mt = "ROUNDING_MODE") && (xt = $t[mt], intCheck(xt, 0, 8, mt), ne = xt), $t.hasOwnProperty(mt = "EXPONENTIAL_AT") && (xt = $t[mt], xt && xt.pop ? (intCheck(xt[0], -MAX, 0, mt), intCheck(xt[1], 0, MAX, mt), ie = xt[0], oe = xt[1]) : (intCheck(xt, -MAX, MAX, mt), ie = -(oe = xt < 0 ? -xt : xt))), $t.hasOwnProperty(mt = "RANGE"))
          if (xt = $t[mt], xt && xt.pop)
            intCheck(xt[0], -MAX, -1, mt), intCheck(xt[1], 1, MAX, mt), V = xt[0], ce = xt[1];
          else if (intCheck(xt, -MAX, MAX, mt), xt)
            V = -(ce = xt < 0 ? -xt : xt);
          else
            throw Error(bignumberError + mt + " cannot be zero: " + xt);
        if ($t.hasOwnProperty(mt = "CRYPTO"))
          if (xt = $t[mt], xt === !!xt)
            if (xt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                ke = xt;
              else
                throw ke = !xt, Error(bignumberError + "crypto unavailable");
            else
              ke = xt;
          else
            throw Error(bignumberError + mt + " not true or false: " + xt);
        if ($t.hasOwnProperty(mt = "MODULO_MODE") && (xt = $t[mt], intCheck(xt, 0, 9, mt), Ce = xt), $t.hasOwnProperty(mt = "POW_PRECISION") && (xt = $t[mt], intCheck(xt, 0, MAX, mt), it = xt), $t.hasOwnProperty(mt = "FORMAT"))
          if (xt = $t[mt], typeof xt == "object") at = xt;
          else throw Error(bignumberError + mt + " not an object: " + xt);
        if ($t.hasOwnProperty(mt = "ALPHABET"))
          if (xt = $t[mt], typeof xt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(xt))
            ht = xt.slice(0, 10) == "0123456789", lt = xt;
          else
            throw Error(bignumberError + mt + " invalid: " + xt);
      } else
        throw Error(bignumberError + "Object expected: " + $t);
    return {
      DECIMAL_PLACES: J,
      ROUNDING_MODE: ne,
      EXPONENTIAL_AT: [ie, oe],
      RANGE: [V, ce],
      CRYPTO: ke,
      MODULO_MODE: Ce,
      POW_PRECISION: it,
      FORMAT: at,
      ALPHABET: lt
    };
  }, dt.isBigNumber = function($t) {
    if (!$t || $t._isBigNumber !== !0) return !1;
    if (!dt.DEBUG) return !0;
    var mt, xt, wt = $t.c, Oe = $t.e, rt = $t.s;
    e: if ({}.toString.call(wt) == "[object Array]") {
      if ((rt === 1 || rt === -1) && Oe >= -MAX && Oe <= MAX && Oe === mathfloor(Oe)) {
        if (wt[0] === 0) {
          if (Oe === 0 && wt.length === 1) return !0;
          break e;
        }
        if (mt = (Oe + 1) % LOG_BASE, mt < 1 && (mt += LOG_BASE), String(wt[0]).length == mt) {
          for (mt = 0; mt < wt.length; mt++)
            if (xt = wt[mt], xt < 0 || xt >= BASE || xt !== mathfloor(xt)) break e;
          if (xt !== 0) return !0;
        }
      }
    } else if (wt === null && Oe === null && (rt === null || rt === 1 || rt === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + $t);
  }, dt.maximum = dt.max = function() {
    return vt(arguments, -1);
  }, dt.minimum = dt.min = function() {
    return vt(arguments, 1);
  }, dt.random = function() {
    var $t = 9007199254740992, mt = Math.random() * $t & 2097151 ? function() {
      return mathfloor(Math.random() * $t);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(xt) {
      var wt, Oe, rt, pe, nt, ot = 0, st = [], ut = new dt(W);
      if (xt == null ? xt = J : intCheck(xt, 0, MAX), pe = mathceil(xt / LOG_BASE), ke)
        if (crypto.getRandomValues) {
          for (wt = crypto.getRandomValues(new Uint32Array(pe *= 2)); ot < pe; )
            nt = wt[ot] * 131072 + (wt[ot + 1] >>> 11), nt >= 9e15 ? (Oe = crypto.getRandomValues(new Uint32Array(2)), wt[ot] = Oe[0], wt[ot + 1] = Oe[1]) : (st.push(nt % 1e14), ot += 2);
          ot = pe / 2;
        } else if (crypto.randomBytes) {
          for (wt = crypto.randomBytes(pe *= 7); ot < pe; )
            nt = (wt[ot] & 31) * 281474976710656 + wt[ot + 1] * 1099511627776 + wt[ot + 2] * 4294967296 + wt[ot + 3] * 16777216 + (wt[ot + 4] << 16) + (wt[ot + 5] << 8) + wt[ot + 6], nt >= 9e15 ? crypto.randomBytes(7).copy(wt, ot) : (st.push(nt % 1e14), ot += 7);
          ot = pe / 7;
        } else
          throw ke = !1, Error(bignumberError + "crypto unavailable");
      if (!ke)
        for (; ot < pe; )
          nt = mt(), nt < 9e15 && (st[ot++] = nt % 1e14);
      for (pe = st[--ot], xt %= LOG_BASE, pe && xt && (nt = POWS_TEN[LOG_BASE - xt], st[ot] = mathfloor(pe / nt) * nt); st[ot] === 0; st.pop(), ot--) ;
      if (ot < 0)
        st = [rt = 0];
      else {
        for (rt = -1; st[0] === 0; st.splice(0, 1), rt -= LOG_BASE) ;
        for (ot = 1, nt = st[0]; nt >= 10; nt /= 10, ot++) ;
        ot < LOG_BASE && (rt -= LOG_BASE - ot);
      }
      return ut.e = rt, ut.c = st, ut;
    };
  }(), dt.sum = function() {
    for (var $t = 1, mt = arguments, xt = new dt(mt[0]); $t < mt.length; ) xt = xt.plus(mt[$t++]);
    return xt;
  }, L = /* @__PURE__ */ function() {
    var $t = "0123456789";
    function mt(xt, wt, Oe, rt) {
      for (var pe, nt = [0], ot, st = 0, ut = xt.length; st < ut; ) {
        for (ot = nt.length; ot--; nt[ot] *= wt) ;
        for (nt[0] += rt.indexOf(xt.charAt(st++)), pe = 0; pe < nt.length; pe++)
          nt[pe] > Oe - 1 && (nt[pe + 1] == null && (nt[pe + 1] = 0), nt[pe + 1] += nt[pe] / Oe | 0, nt[pe] %= Oe);
      }
      return nt.reverse();
    }
    return function(xt, wt, Oe, rt, pe) {
      var nt, ot, st, ut, pt, ft, yt, ct, St = xt.indexOf("."), qt = J, jt = ne;
      for (St >= 0 && (ut = it, it = 0, xt = xt.replace(".", ""), ct = new dt(wt), ft = ct.pow(xt.length - St), it = ut, ct.c = mt(
        toFixedPoint(coeffToString(ft.c), ft.e, "0"),
        10,
        Oe,
        $t
      ), ct.e = ct.c.length), yt = mt(xt, wt, Oe, pe ? (nt = lt, $t) : (nt = $t, lt)), st = ut = yt.length; yt[--ut] == 0; yt.pop()) ;
      if (!yt[0]) return nt.charAt(0);
      if (St < 0 ? --st : (ft.c = yt, ft.e = st, ft.s = rt, ft = B(ft, ct, qt, jt, Oe), yt = ft.c, pt = ft.r, st = ft.e), ot = st + qt + 1, St = yt[ot], ut = Oe / 2, pt = pt || ot < 0 || yt[ot + 1] != null, pt = jt < 4 ? (St != null || pt) && (jt == 0 || jt == (ft.s < 0 ? 3 : 2)) : St > ut || St == ut && (jt == 4 || pt || jt == 6 && yt[ot - 1] & 1 || jt == (ft.s < 0 ? 8 : 7)), ot < 1 || !yt[0])
        xt = pt ? toFixedPoint(nt.charAt(1), -qt, nt.charAt(0)) : nt.charAt(0);
      else {
        if (yt.length = ot, pt)
          for (--Oe; ++yt[--ot] > Oe; )
            yt[ot] = 0, ot || (++st, yt = [1].concat(yt));
        for (ut = yt.length; !yt[--ut]; ) ;
        for (St = 0, xt = ""; St <= ut; xt += nt.charAt(yt[St++])) ;
        xt = toFixedPoint(xt, st, nt.charAt(0));
      }
      return xt;
    };
  }(), B = /* @__PURE__ */ function() {
    function $t(wt, Oe, rt) {
      var pe, nt, ot, st, ut = 0, pt = wt.length, ft = Oe % SQRT_BASE, yt = Oe / SQRT_BASE | 0;
      for (wt = wt.slice(); pt--; )
        ot = wt[pt] % SQRT_BASE, st = wt[pt] / SQRT_BASE | 0, pe = yt * ot + st * ft, nt = ft * ot + pe % SQRT_BASE * SQRT_BASE + ut, ut = (nt / rt | 0) + (pe / SQRT_BASE | 0) + yt * st, wt[pt] = nt % rt;
      return ut && (wt = [ut].concat(wt)), wt;
    }
    function mt(wt, Oe, rt, pe) {
      var nt, ot;
      if (rt != pe)
        ot = rt > pe ? 1 : -1;
      else
        for (nt = ot = 0; nt < rt; nt++)
          if (wt[nt] != Oe[nt]) {
            ot = wt[nt] > Oe[nt] ? 1 : -1;
            break;
          }
      return ot;
    }
    function xt(wt, Oe, rt, pe) {
      for (var nt = 0; rt--; )
        wt[rt] -= nt, nt = wt[rt] < Oe[rt] ? 1 : 0, wt[rt] = nt * pe + wt[rt] - Oe[rt];
      for (; !wt[0] && wt.length > 1; wt.splice(0, 1)) ;
    }
    return function(wt, Oe, rt, pe, nt) {
      var ot, st, ut, pt, ft, yt, ct, St, qt, jt, Ot, Tt, Rt, Ut, Gt, Mt, Pt, Kt = wt.s == Oe.s ? 1 : -1, Zt = wt.c, rr = Oe.c;
      if (!Zt || !Zt[0] || !rr || !rr[0])
        return new dt(
          // Return NaN if either NaN, or both Infinity or 0.
          !wt.s || !Oe.s || (Zt ? rr && Zt[0] == rr[0] : !rr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            Zt && Zt[0] == 0 || !rr ? Kt * 0 : Kt / 0
          )
        );
      for (St = new dt(Kt), qt = St.c = [], st = wt.e - Oe.e, Kt = rt + st + 1, nt || (nt = BASE, st = bitFloor(wt.e / LOG_BASE) - bitFloor(Oe.e / LOG_BASE), Kt = Kt / LOG_BASE | 0), ut = 0; rr[ut] == (Zt[ut] || 0); ut++) ;
      if (rr[ut] > (Zt[ut] || 0) && st--, Kt < 0)
        qt.push(1), pt = !0;
      else {
        for (Ut = Zt.length, Mt = rr.length, ut = 0, Kt += 2, ft = mathfloor(nt / (rr[0] + 1)), ft > 1 && (rr = $t(rr, ft, nt), Zt = $t(Zt, ft, nt), Mt = rr.length, Ut = Zt.length), Rt = Mt, jt = Zt.slice(0, Mt), Ot = jt.length; Ot < Mt; jt[Ot++] = 0) ;
        Pt = rr.slice(), Pt = [0].concat(Pt), Gt = rr[0], rr[1] >= nt / 2 && Gt++;
        do {
          if (ft = 0, ot = mt(rr, jt, Mt, Ot), ot < 0) {
            if (Tt = jt[0], Mt != Ot && (Tt = Tt * nt + (jt[1] || 0)), ft = mathfloor(Tt / Gt), ft > 1)
              for (ft >= nt && (ft = nt - 1), yt = $t(rr, ft, nt), ct = yt.length, Ot = jt.length; mt(yt, jt, ct, Ot) == 1; )
                ft--, xt(yt, Mt < ct ? Pt : rr, ct, nt), ct = yt.length, ot = 1;
            else
              ft == 0 && (ot = ft = 1), yt = rr.slice(), ct = yt.length;
            if (ct < Ot && (yt = [0].concat(yt)), xt(jt, yt, Ot, nt), Ot = jt.length, ot == -1)
              for (; mt(rr, jt, Mt, Ot) < 1; )
                ft++, xt(jt, Mt < Ot ? Pt : rr, Ot, nt), Ot = jt.length;
          } else ot === 0 && (ft++, jt = [0]);
          qt[ut++] = ft, jt[0] ? jt[Ot++] = Zt[Rt] || 0 : (jt = [Zt[Rt]], Ot = 1);
        } while ((Rt++ < Ut || jt[0] != null) && Kt--);
        pt = jt[0] != null, qt[0] || qt.splice(0, 1);
      }
      if (nt == BASE) {
        for (ut = 1, Kt = qt[0]; Kt >= 10; Kt /= 10, ut++) ;
        At(St, rt + (St.e = ut + st * LOG_BASE - 1) + 1, pe, pt);
      } else
        St.e = st, St.r = +pt;
      return St;
    };
  }();
  function bt($t, mt, xt, wt) {
    var Oe, rt, pe, nt, ot;
    if (xt == null ? xt = ne : intCheck(xt, 0, 8), !$t.c) return $t.toString();
    if (Oe = $t.c[0], pe = $t.e, mt == null)
      ot = coeffToString($t.c), ot = wt == 1 || wt == 2 && (pe <= ie || pe >= oe) ? toExponential(ot, pe) : toFixedPoint(ot, pe, "0");
    else if ($t = At(new dt($t), mt, xt), rt = $t.e, ot = coeffToString($t.c), nt = ot.length, wt == 1 || wt == 2 && (mt <= rt || rt <= ie)) {
      for (; nt < mt; ot += "0", nt++) ;
      ot = toExponential(ot, rt);
    } else if (mt -= pe, ot = toFixedPoint(ot, rt, "0"), rt + 1 > nt) {
      if (--mt > 0) for (ot += "."; mt--; ot += "0") ;
    } else if (mt += rt - nt, mt > 0)
      for (rt + 1 == nt && (ot += "."); mt--; ot += "0") ;
    return $t.s < 0 && Oe ? "-" + ot : ot;
  }
  function vt($t, mt) {
    for (var xt, wt, Oe = 1, rt = new dt($t[0]); Oe < $t.length; Oe++)
      wt = new dt($t[Oe]), (!wt.s || (xt = compare(rt, wt)) === mt || xt === 0 && rt.s === mt) && (rt = wt);
    return rt;
  }
  function Bt($t, mt, xt) {
    for (var wt = 1, Oe = mt.length; !mt[--Oe]; mt.pop()) ;
    for (Oe = mt[0]; Oe >= 10; Oe /= 10, wt++) ;
    return (xt = wt + xt * LOG_BASE - 1) > ce ? $t.c = $t.e = null : xt < V ? $t.c = [$t.e = 0] : ($t.e = xt, $t.c = mt), $t;
  }
  K = /* @__PURE__ */ function() {
    var $t = /^(-?)0([xbo])(?=\w[\w.]*$)/i, mt = /^([^.]+)\.$/, xt = /^\.([^.]+)$/, wt = /^-?(Infinity|NaN)$/, Oe = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(rt, pe, nt, ot) {
      var st, ut = nt ? pe : pe.replace(Oe, "");
      if (wt.test(ut))
        rt.s = isNaN(ut) ? null : ut < 0 ? -1 : 1;
      else {
        if (!nt && (ut = ut.replace($t, function(pt, ft, yt) {
          return st = (yt = yt.toLowerCase()) == "x" ? 16 : yt == "b" ? 2 : 8, !ot || ot == st ? ft : pt;
        }), ot && (st = ot, ut = ut.replace(mt, "$1").replace(xt, "0.$1")), pe != ut))
          return new dt(ut, st);
        if (dt.DEBUG)
          throw Error(bignumberError + "Not a" + (ot ? " base " + ot : "") + " number: " + pe);
        rt.s = null;
      }
      rt.c = rt.e = null;
    };
  }();
  function At($t, mt, xt, wt) {
    var Oe, rt, pe, nt, ot, st, ut, pt = $t.c, ft = POWS_TEN;
    if (pt) {
      e: {
        for (Oe = 1, nt = pt[0]; nt >= 10; nt /= 10, Oe++) ;
        if (rt = mt - Oe, rt < 0)
          rt += LOG_BASE, pe = mt, ot = pt[st = 0], ut = mathfloor(ot / ft[Oe - pe - 1] % 10);
        else if (st = mathceil((rt + 1) / LOG_BASE), st >= pt.length)
          if (wt) {
            for (; pt.length <= st; pt.push(0)) ;
            ot = ut = 0, Oe = 1, rt %= LOG_BASE, pe = rt - LOG_BASE + 1;
          } else
            break e;
        else {
          for (ot = nt = pt[st], Oe = 1; nt >= 10; nt /= 10, Oe++) ;
          rt %= LOG_BASE, pe = rt - LOG_BASE + Oe, ut = pe < 0 ? 0 : mathfloor(ot / ft[Oe - pe - 1] % 10);
        }
        if (wt = wt || mt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        pt[st + 1] != null || (pe < 0 ? ot : ot % ft[Oe - pe - 1]), wt = xt < 4 ? (ut || wt) && (xt == 0 || xt == ($t.s < 0 ? 3 : 2)) : ut > 5 || ut == 5 && (xt == 4 || wt || xt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (rt > 0 ? pe > 0 ? ot / ft[Oe - pe] : 0 : pt[st - 1]) % 10 & 1 || xt == ($t.s < 0 ? 8 : 7)), mt < 1 || !pt[0])
          return pt.length = 0, wt ? (mt -= $t.e + 1, pt[0] = ft[(LOG_BASE - mt % LOG_BASE) % LOG_BASE], $t.e = -mt || 0) : pt[0] = $t.e = 0, $t;
        if (rt == 0 ? (pt.length = st, nt = 1, st--) : (pt.length = st + 1, nt = ft[LOG_BASE - rt], pt[st] = pe > 0 ? mathfloor(ot / ft[Oe - pe] % ft[pe]) * nt : 0), wt)
          for (; ; )
            if (st == 0) {
              for (rt = 1, pe = pt[0]; pe >= 10; pe /= 10, rt++) ;
              for (pe = pt[0] += nt, nt = 1; pe >= 10; pe /= 10, nt++) ;
              rt != nt && ($t.e++, pt[0] == BASE && (pt[0] = 1));
              break;
            } else {
              if (pt[st] += nt, pt[st] != BASE) break;
              pt[st--] = 0, nt = 1;
            }
        for (rt = pt.length; pt[--rt] === 0; pt.pop()) ;
      }
      $t.e > ce ? $t.c = $t.e = null : $t.e < V && ($t.c = [$t.e = 0]);
    }
    return $t;
  }
  function Nt($t) {
    var mt, xt = $t.e;
    return xt === null ? $t.toString() : (mt = coeffToString($t.c), mt = xt <= ie || xt >= oe ? toExponential(mt, xt) : toFixedPoint(mt, xt, "0"), $t.s < 0 ? "-" + mt : mt);
  }
  return re.absoluteValue = re.abs = function() {
    var $t = new dt(this);
    return $t.s < 0 && ($t.s = 1), $t;
  }, re.comparedTo = function($t, mt) {
    return compare(this, new dt($t, mt));
  }, re.decimalPlaces = re.dp = function($t, mt) {
    var xt, wt, Oe, rt = this;
    if ($t != null)
      return intCheck($t, 0, MAX), mt == null ? mt = ne : intCheck(mt, 0, 8), At(new dt(rt), $t + rt.e + 1, mt);
    if (!(xt = rt.c)) return null;
    if (wt = ((Oe = xt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Oe = xt[Oe]) for (; Oe % 10 == 0; Oe /= 10, wt--) ;
    return wt < 0 && (wt = 0), wt;
  }, re.dividedBy = re.div = function($t, mt) {
    return B(this, new dt($t, mt), J, ne);
  }, re.dividedToIntegerBy = re.idiv = function($t, mt) {
    return B(this, new dt($t, mt), 0, 1);
  }, re.exponentiatedBy = re.pow = function($t, mt) {
    var xt, wt, Oe, rt, pe, nt, ot, st, ut, pt = this;
    if ($t = new dt($t), $t.c && !$t.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Nt($t));
    if (mt != null && (mt = new dt(mt)), nt = $t.e > 14, !pt.c || !pt.c[0] || pt.c[0] == 1 && !pt.e && pt.c.length == 1 || !$t.c || !$t.c[0])
      return ut = new dt(Math.pow(+Nt(pt), nt ? $t.s * (2 - isOdd($t)) : +Nt($t))), mt ? ut.mod(mt) : ut;
    if (ot = $t.s < 0, mt) {
      if (mt.c ? !mt.c[0] : !mt.s) return new dt(NaN);
      wt = !ot && pt.isInteger() && mt.isInteger(), wt && (pt = pt.mod(mt));
    } else {
      if ($t.e > 9 && (pt.e > 0 || pt.e < -1 || (pt.e == 0 ? pt.c[0] > 1 || nt && pt.c[1] >= 24e7 : pt.c[0] < 8e13 || nt && pt.c[0] <= 9999975e7)))
        return rt = pt.s < 0 && isOdd($t) ? -0 : 0, pt.e > -1 && (rt = 1 / rt), new dt(ot ? 1 / rt : rt);
      it && (rt = mathceil(it / LOG_BASE + 2));
    }
    for (nt ? (xt = new dt(0.5), ot && ($t.s = 1), st = isOdd($t)) : (Oe = Math.abs(+Nt($t)), st = Oe % 2), ut = new dt(W); ; ) {
      if (st) {
        if (ut = ut.times(pt), !ut.c) break;
        rt ? ut.c.length > rt && (ut.c.length = rt) : wt && (ut = ut.mod(mt));
      }
      if (Oe) {
        if (Oe = mathfloor(Oe / 2), Oe === 0) break;
        st = Oe % 2;
      } else if ($t = $t.times(xt), At($t, $t.e + 1, 1), $t.e > 14)
        st = isOdd($t);
      else {
        if (Oe = +Nt($t), Oe === 0) break;
        st = Oe % 2;
      }
      pt = pt.times(pt), rt ? pt.c && pt.c.length > rt && (pt.c.length = rt) : wt && (pt = pt.mod(mt));
    }
    return wt ? ut : (ot && (ut = W.div(ut)), mt ? ut.mod(mt) : rt ? At(ut, it, ne, pe) : ut);
  }, re.integerValue = function($t) {
    var mt = new dt(this);
    return $t == null ? $t = ne : intCheck($t, 0, 8), At(mt, mt.e + 1, $t);
  }, re.isEqualTo = re.eq = function($t, mt) {
    return compare(this, new dt($t, mt)) === 0;
  }, re.isFinite = function() {
    return !!this.c;
  }, re.isGreaterThan = re.gt = function($t, mt) {
    return compare(this, new dt($t, mt)) > 0;
  }, re.isGreaterThanOrEqualTo = re.gte = function($t, mt) {
    return (mt = compare(this, new dt($t, mt))) === 1 || mt === 0;
  }, re.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, re.isLessThan = re.lt = function($t, mt) {
    return compare(this, new dt($t, mt)) < 0;
  }, re.isLessThanOrEqualTo = re.lte = function($t, mt) {
    return (mt = compare(this, new dt($t, mt))) === -1 || mt === 0;
  }, re.isNaN = function() {
    return !this.s;
  }, re.isNegative = function() {
    return this.s < 0;
  }, re.isPositive = function() {
    return this.s > 0;
  }, re.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, re.minus = function($t, mt) {
    var xt, wt, Oe, rt, pe = this, nt = pe.s;
    if ($t = new dt($t, mt), mt = $t.s, !nt || !mt) return new dt(NaN);
    if (nt != mt)
      return $t.s = -mt, pe.plus($t);
    var ot = pe.e / LOG_BASE, st = $t.e / LOG_BASE, ut = pe.c, pt = $t.c;
    if (!ot || !st) {
      if (!ut || !pt) return ut ? ($t.s = -mt, $t) : new dt(pt ? pe : NaN);
      if (!ut[0] || !pt[0])
        return pt[0] ? ($t.s = -mt, $t) : new dt(ut[0] ? pe : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ne == 3 ? -0 : 0
        ));
    }
    if (ot = bitFloor(ot), st = bitFloor(st), ut = ut.slice(), nt = ot - st) {
      for ((rt = nt < 0) ? (nt = -nt, Oe = ut) : (st = ot, Oe = pt), Oe.reverse(), mt = nt; mt--; Oe.push(0)) ;
      Oe.reverse();
    } else
      for (wt = (rt = (nt = ut.length) < (mt = pt.length)) ? nt : mt, nt = mt = 0; mt < wt; mt++)
        if (ut[mt] != pt[mt]) {
          rt = ut[mt] < pt[mt];
          break;
        }
    if (rt && (Oe = ut, ut = pt, pt = Oe, $t.s = -$t.s), mt = (wt = pt.length) - (xt = ut.length), mt > 0) for (; mt--; ut[xt++] = 0) ;
    for (mt = BASE - 1; wt > nt; ) {
      if (ut[--wt] < pt[wt]) {
        for (xt = wt; xt && !ut[--xt]; ut[xt] = mt) ;
        --ut[xt], ut[wt] += BASE;
      }
      ut[wt] -= pt[wt];
    }
    for (; ut[0] == 0; ut.splice(0, 1), --st) ;
    return ut[0] ? Bt($t, ut, st) : ($t.s = ne == 3 ? -1 : 1, $t.c = [$t.e = 0], $t);
  }, re.modulo = re.mod = function($t, mt) {
    var xt, wt, Oe = this;
    return $t = new dt($t, mt), !Oe.c || !$t.s || $t.c && !$t.c[0] ? new dt(NaN) : !$t.c || Oe.c && !Oe.c[0] ? new dt(Oe) : (Ce == 9 ? (wt = $t.s, $t.s = 1, xt = B(Oe, $t, 0, 3), $t.s = wt, xt.s *= wt) : xt = B(Oe, $t, 0, Ce), $t = Oe.minus(xt.times($t)), !$t.c[0] && Ce == 1 && ($t.s = Oe.s), $t);
  }, re.multipliedBy = re.times = function($t, mt) {
    var xt, wt, Oe, rt, pe, nt, ot, st, ut, pt, ft, yt, ct, St, qt, jt = this, Ot = jt.c, Tt = ($t = new dt($t, mt)).c;
    if (!Ot || !Tt || !Ot[0] || !Tt[0])
      return !jt.s || !$t.s || Ot && !Ot[0] && !Tt || Tt && !Tt[0] && !Ot ? $t.c = $t.e = $t.s = null : ($t.s *= jt.s, !Ot || !Tt ? $t.c = $t.e = null : ($t.c = [0], $t.e = 0)), $t;
    for (wt = bitFloor(jt.e / LOG_BASE) + bitFloor($t.e / LOG_BASE), $t.s *= jt.s, ot = Ot.length, pt = Tt.length, ot < pt && (ct = Ot, Ot = Tt, Tt = ct, Oe = ot, ot = pt, pt = Oe), Oe = ot + pt, ct = []; Oe--; ct.push(0)) ;
    for (St = BASE, qt = SQRT_BASE, Oe = pt; --Oe >= 0; ) {
      for (xt = 0, ft = Tt[Oe] % qt, yt = Tt[Oe] / qt | 0, pe = ot, rt = Oe + pe; rt > Oe; )
        st = Ot[--pe] % qt, ut = Ot[pe] / qt | 0, nt = yt * st + ut * ft, st = ft * st + nt % qt * qt + ct[rt] + xt, xt = (st / St | 0) + (nt / qt | 0) + yt * ut, ct[rt--] = st % St;
      ct[rt] = xt;
    }
    return xt ? ++wt : ct.splice(0, 1), Bt($t, ct, wt);
  }, re.negated = function() {
    var $t = new dt(this);
    return $t.s = -$t.s || null, $t;
  }, re.plus = function($t, mt) {
    var xt, wt = this, Oe = wt.s;
    if ($t = new dt($t, mt), mt = $t.s, !Oe || !mt) return new dt(NaN);
    if (Oe != mt)
      return $t.s = -mt, wt.minus($t);
    var rt = wt.e / LOG_BASE, pe = $t.e / LOG_BASE, nt = wt.c, ot = $t.c;
    if (!rt || !pe) {
      if (!nt || !ot) return new dt(Oe / 0);
      if (!nt[0] || !ot[0]) return ot[0] ? $t : new dt(nt[0] ? wt : Oe * 0);
    }
    if (rt = bitFloor(rt), pe = bitFloor(pe), nt = nt.slice(), Oe = rt - pe) {
      for (Oe > 0 ? (pe = rt, xt = ot) : (Oe = -Oe, xt = nt), xt.reverse(); Oe--; xt.push(0)) ;
      xt.reverse();
    }
    for (Oe = nt.length, mt = ot.length, Oe - mt < 0 && (xt = ot, ot = nt, nt = xt, mt = Oe), Oe = 0; mt; )
      Oe = (nt[--mt] = nt[mt] + ot[mt] + Oe) / BASE | 0, nt[mt] = BASE === nt[mt] ? 0 : nt[mt] % BASE;
    return Oe && (nt = [Oe].concat(nt), ++pe), Bt($t, nt, pe);
  }, re.precision = re.sd = function($t, mt) {
    var xt, wt, Oe, rt = this;
    if ($t != null && $t !== !!$t)
      return intCheck($t, 1, MAX), mt == null ? mt = ne : intCheck(mt, 0, 8), At(new dt(rt), $t, mt);
    if (!(xt = rt.c)) return null;
    if (Oe = xt.length - 1, wt = Oe * LOG_BASE + 1, Oe = xt[Oe]) {
      for (; Oe % 10 == 0; Oe /= 10, wt--) ;
      for (Oe = xt[0]; Oe >= 10; Oe /= 10, wt++) ;
    }
    return $t && rt.e + 1 > wt && (wt = rt.e + 1), wt;
  }, re.shiftedBy = function($t) {
    return intCheck($t, -MAX_SAFE_INTEGER$2, MAX_SAFE_INTEGER$2), this.times("1e" + $t);
  }, re.squareRoot = re.sqrt = function() {
    var $t, mt, xt, wt, Oe, rt = this, pe = rt.c, nt = rt.s, ot = rt.e, st = J + 4, ut = new dt("0.5");
    if (nt !== 1 || !pe || !pe[0])
      return new dt(!nt || nt < 0 && (!pe || pe[0]) ? NaN : pe ? rt : 1 / 0);
    if (nt = Math.sqrt(+Nt(rt)), nt == 0 || nt == 1 / 0 ? (mt = coeffToString(pe), (mt.length + ot) % 2 == 0 && (mt += "0"), nt = Math.sqrt(+mt), ot = bitFloor((ot + 1) / 2) - (ot < 0 || ot % 2), nt == 1 / 0 ? mt = "5e" + ot : (mt = nt.toExponential(), mt = mt.slice(0, mt.indexOf("e") + 1) + ot), xt = new dt(mt)) : xt = new dt(nt + ""), xt.c[0]) {
      for (ot = xt.e, nt = ot + st, nt < 3 && (nt = 0); ; )
        if (Oe = xt, xt = ut.times(Oe.plus(B(rt, Oe, st, 1))), coeffToString(Oe.c).slice(0, nt) === (mt = coeffToString(xt.c)).slice(0, nt))
          if (xt.e < ot && --nt, mt = mt.slice(nt - 3, nt + 1), mt == "9999" || !wt && mt == "4999") {
            if (!wt && (At(Oe, Oe.e + J + 2, 0), Oe.times(Oe).eq(rt))) {
              xt = Oe;
              break;
            }
            st += 4, nt += 4, wt = 1;
          } else {
            (!+mt || !+mt.slice(1) && mt.charAt(0) == "5") && (At(xt, xt.e + J + 2, 1), $t = !xt.times(xt).eq(rt));
            break;
          }
    }
    return At(xt, xt.e + J + 1, ne, $t);
  }, re.toExponential = function($t, mt) {
    return $t != null && (intCheck($t, 0, MAX), $t++), bt(this, $t, mt, 1);
  }, re.toFixed = function($t, mt) {
    return $t != null && (intCheck($t, 0, MAX), $t = $t + this.e + 1), bt(this, $t, mt);
  }, re.toFormat = function($t, mt, xt) {
    var wt, Oe = this;
    if (xt == null)
      $t != null && mt && typeof mt == "object" ? (xt = mt, mt = null) : $t && typeof $t == "object" ? (xt = $t, $t = mt = null) : xt = at;
    else if (typeof xt != "object")
      throw Error(bignumberError + "Argument not an object: " + xt);
    if (wt = Oe.toFixed($t, mt), Oe.c) {
      var rt, pe = wt.split("."), nt = +xt.groupSize, ot = +xt.secondaryGroupSize, st = xt.groupSeparator || "", ut = pe[0], pt = pe[1], ft = Oe.s < 0, yt = ft ? ut.slice(1) : ut, ct = yt.length;
      if (ot && (rt = nt, nt = ot, ot = rt, ct -= rt), nt > 0 && ct > 0) {
        for (rt = ct % nt || nt, ut = yt.substr(0, rt); rt < ct; rt += nt) ut += st + yt.substr(rt, nt);
        ot > 0 && (ut += st + yt.slice(rt)), ft && (ut = "-" + ut);
      }
      wt = pt ? ut + (xt.decimalSeparator || "") + ((ot = +xt.fractionGroupSize) ? pt.replace(
        new RegExp("\\d{" + ot + "}\\B", "g"),
        "$&" + (xt.fractionGroupSeparator || "")
      ) : pt) : ut;
    }
    return (xt.prefix || "") + wt + (xt.suffix || "");
  }, re.toFraction = function($t) {
    var mt, xt, wt, Oe, rt, pe, nt, ot, st, ut, pt, ft, yt = this, ct = yt.c;
    if ($t != null && (nt = new dt($t), !nt.isInteger() && (nt.c || nt.s !== 1) || nt.lt(W)))
      throw Error(bignumberError + "Argument " + (nt.isInteger() ? "out of range: " : "not an integer: ") + Nt(nt));
    if (!ct) return new dt(yt);
    for (mt = new dt(W), st = xt = new dt(W), wt = ot = new dt(W), ft = coeffToString(ct), rt = mt.e = ft.length - yt.e - 1, mt.c[0] = POWS_TEN[(pe = rt % LOG_BASE) < 0 ? LOG_BASE + pe : pe], $t = !$t || nt.comparedTo(mt) > 0 ? rt > 0 ? mt : st : nt, pe = ce, ce = 1 / 0, nt = new dt(ft), ot.c[0] = 0; ut = B(nt, mt, 0, 1), Oe = xt.plus(ut.times(wt)), Oe.comparedTo($t) != 1; )
      xt = wt, wt = Oe, st = ot.plus(ut.times(Oe = st)), ot = Oe, mt = nt.minus(ut.times(Oe = mt)), nt = Oe;
    return Oe = B($t.minus(xt), wt, 0, 1), ot = ot.plus(Oe.times(st)), xt = xt.plus(Oe.times(wt)), ot.s = st.s = yt.s, rt = rt * 2, pt = B(st, wt, rt, ne).minus(yt).abs().comparedTo(
      B(ot, xt, rt, ne).minus(yt).abs()
    ) < 1 ? [st, wt] : [ot, xt], ce = pe, pt;
  }, re.toNumber = function() {
    return +Nt(this);
  }, re.toPrecision = function($t, mt) {
    return $t != null && intCheck($t, 1, MAX), bt(this, $t, mt, 2);
  }, re.toString = function($t) {
    var mt, xt = this, wt = xt.s, Oe = xt.e;
    return Oe === null ? wt ? (mt = "Infinity", wt < 0 && (mt = "-" + mt)) : mt = "NaN" : ($t == null ? mt = Oe <= ie || Oe >= oe ? toExponential(coeffToString(xt.c), Oe) : toFixedPoint(coeffToString(xt.c), Oe, "0") : $t === 10 && ht ? (xt = At(new dt(xt), J + Oe + 1, ne), mt = toFixedPoint(coeffToString(xt.c), xt.e, "0")) : (intCheck($t, 2, lt.length, "Base"), mt = L(toFixedPoint(coeffToString(xt.c), Oe, "0"), 10, $t, wt, !0)), wt < 0 && xt.c[0] && (mt = "-" + mt)), mt;
  }, re.valueOf = re.toJSON = function() {
    return Nt(this);
  }, re._isBigNumber = !0, re[Symbol.toStringTag] = "BigNumber", re[Symbol.for("nodejs.util.inspect.custom")] = re.valueOf, A != null && dt.set(A), dt;
}
function bitFloor(A) {
  var B = A | 0;
  return A > 0 || A === B ? B : B - 1;
}
function coeffToString(A) {
  for (var B, L, K = 1, re = A.length, W = A[0] + ""; K < re; ) {
    for (B = A[K++] + "", L = LOG_BASE - B.length; L--; B = "0" + B) ;
    W += B;
  }
  for (re = W.length; W.charCodeAt(--re) === 48; ) ;
  return W.slice(0, re + 1 || 1);
}
function compare(A, B) {
  var L, K, re = A.c, W = B.c, J = A.s, ne = B.s, ie = A.e, oe = B.e;
  if (!J || !ne) return null;
  if (L = re && !re[0], K = W && !W[0], L || K) return L ? K ? 0 : -ne : J;
  if (J != ne) return J;
  if (L = J < 0, K = ie == oe, !re || !W) return K ? 0 : !re ^ L ? 1 : -1;
  if (!K) return ie > oe ^ L ? 1 : -1;
  for (ne = (ie = re.length) < (oe = W.length) ? ie : oe, J = 0; J < ne; J++) if (re[J] != W[J]) return re[J] > W[J] ^ L ? 1 : -1;
  return ie == oe ? 0 : ie > oe ^ L ? 1 : -1;
}
function intCheck(A, B, L, K) {
  if (A < B || A > L || A !== mathfloor(A))
    throw Error(bignumberError + (K || "Argument") + (typeof A == "number" ? A < B || A > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(A));
}
function isOdd(A) {
  var B = A.c.length - 1;
  return bitFloor(A.e / LOG_BASE) == B && A.c[B] % 2 != 0;
}
function toExponential(A, B) {
  return (A.length > 1 ? A.charAt(0) + "." + A.slice(1) : A) + (B < 0 ? "e" : "e+") + B;
}
function toFixedPoint(A, B, L) {
  var K, re;
  if (B < 0) {
    for (re = L + "."; ++B; re += L) ;
    A = re + A;
  } else if (K = A.length, ++B > K) {
    for (re = L, B -= K; --B; re += L) ;
    A += re;
  } else B < K && (A = A.slice(0, B) + "." + A.slice(B));
  return A;
}
var BigNumber = clone();
function useBalance() {
  const { network: A, publicKey: B, format: L } = useWallie(), [K, re] = useState(null), [W, J] = useState(!1);
  return { getBalance: useCallback(async () => {
    J(!0);
    try {
      if (re(null), !L || !L.payments || !B || !B.payments)
        throw new Error("No wallet is connected");
      const { address: ie } = getAddressesFromPublicKey(
        B.payments,
        A,
        ADDRESS_FORMAT_TO_TYPE[L.payments]
      )[0], V = await new JsonRpcDatasource({ network: A }).getBalance({ address: ie }), ce = Number(
        new BigNumber(V).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return J(!1), ce;
    } catch (ie) {
      throw re(ie.message), J(!1), ie;
    }
  }, [L, A, B]), error: K, loading: W };
}
async function signPsbt({
  address: A,
  wallet: B,
  network: L,
  psbt: K,
  options: re
}) {
  var ie, oe;
  if ((ie = re == null ? void 0 : re.signingIndexes) != null && ie.length && ((oe = re == null ? void 0 : re.inputsToSign) != null && oe.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const W = (re == null ? void 0 : re.finalize) ?? !0, J = (re == null ? void 0 : re.extractTx) ?? !0, ne = () => K.data.inputs.map((V, ce) => ce);
  if (B === Wallet.MAGICEDEN)
    return await signPsbt$1(K, {
      network: L,
      inputsToSign: (re == null ? void 0 : re.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (re == null ? void 0 : re.signingIndexes) ?? ne(),
          sigHash: re == null ? void 0 : re.sigHash
        }
      ],
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.UNISAT)
    return await signPsbt$2(K, {
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.XVERSE)
    return await signPsbt$3(K, {
      network: L,
      inputsToSign: (re == null ? void 0 : re.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (re == null ? void 0 : re.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: re == null ? void 0 : re.sigHash
        }
      ],
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.LEATHER)
    return await signPsbt$4(K, {
      network: L,
      finalize: W,
      extractTx: J,
      allowedSighash: re != null && re.sigHash ? [re == null ? void 0 : re.sigHash] : [],
      signAtIndexes: (re == null ? void 0 : re.signingIndexes) ?? ne()
      // If signingIndexes is not provided, just sign everything
    });
  if (B === Wallet.OKX)
    return await signPsbt$5(K, {
      finalize: W,
      extractTx: J,
      network: L,
      inputsToSign: (re == null ? void 0 : re.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (re == null ? void 0 : re.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: re == null ? void 0 : re.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: A, network: B, address: L, publicKey: K } = useWallie(), [re, W] = useState(null), [J, ne] = useState(!1);
  return { send: useCallback(
    async (oe, V, ce, ke = !0) => {
      ne(!0);
      try {
        if (W(null), !L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const Ce = new PSBTBuilder({
          address: L.payments,
          feeRate: ce,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: oe,
              value: V
            }
          ]
        });
        await Ce.prepare();
        const it = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: Ce.toPSBT()
        });
        if (ke) {
          const lt = await new JsonRpcDatasource({ network: B }).relay({ hex: it.hex });
          return ne(!1), lt;
        }
        return ne(!1), it.hex;
      } catch (Ce) {
        return W(Ce.message), ne(!1), null;
      }
    },
    [L, B, K, A]
  ), error: re, loading: J };
}
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
function getValue$1(A, B) {
  return A == null ? void 0 : A[B];
}
function isHostObject(A) {
  var B = !1;
  if (A != null && typeof A.toString != "function")
    try {
      B = !!(A + "");
    } catch {
    }
  return B;
}
var funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var A = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return A ? "Symbol(src)_1." + A : "";
}(), funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), Symbol$1 = root.Symbol;
Symbol$1 && Symbol$1.isConcatSpreadable;
getNative(root, "Map");
getNative(Object, "create");
function baseIsNative(A) {
  if (!isObject(A) || isMasked(A))
    return !1;
  var B = isFunction(A) || isHostObject(A) ? reIsNative : reIsHostCtor;
  return B.test(toSource(A));
}
function getNative(A, B) {
  var L = getValue$1(A, B);
  return baseIsNative(L) ? L : void 0;
}
function isMasked(A) {
  return !!maskSrcKey && maskSrcKey in A;
}
function toSource(A) {
  if (A != null) {
    try {
      return funcToString.call(A);
    } catch {
    }
    try {
      return A + "";
    } catch {
    }
  }
  return "";
}
function isFunction(A) {
  var B = isObject(A) ? objectToString.call(A) : "";
  return B == funcTag || B == genTag;
}
function isObject(A) {
  var B = typeof A;
  return !!A && (B == "object" || B == "function");
}
var store2;
function getGlobalMessage(A) {
  return store2 == null ? void 0 : store2.get(A);
}
var store3;
function getSchemaMessage(A) {
  return store3 == null ? void 0 : store3.get(A);
}
var store4;
function getSpecificMessage(A, B) {
  var L;
  return (L = store4 == null ? void 0 : store4.get(A)) == null ? void 0 : L.get(B);
}
function _stringify(A) {
  var L, K;
  let B = typeof A;
  return B === "object" && (B = (A && ((K = (L = Object.getPrototypeOf(A)) == null ? void 0 : L.constructor) == null ? void 0 : K.name)) ?? "null"), B === "string" ? `"${A}"` : B === "number" || B === "bigint" || B === "boolean" ? `${A}` : B;
}
function _addIssue(A, B, L, K, re) {
  const W = re && "input" in re ? re.input : L.value, J = (re == null ? void 0 : re.expected) ?? A.expects ?? null, ne = (re == null ? void 0 : re.received) ?? _stringify(W), ie = {
    kind: A.kind,
    type: A.type,
    input: W,
    expected: J,
    received: ne,
    message: `Invalid ${B}: ${J ? `Expected ${J} but r` : "R"}eceived ${ne}`,
    // @ts-expect-error
    requirement: A.requirement,
    path: re == null ? void 0 : re.path,
    issues: re == null ? void 0 : re.issues,
    lang: K.lang,
    abortEarly: K.abortEarly,
    abortPipeEarly: K.abortPipeEarly
  }, oe = A.kind === "schema", V = (re == null ? void 0 : re.message) ?? // @ts-expect-error
  A.message ?? getSpecificMessage(A.reference, ie.lang) ?? (oe ? getSchemaMessage(ie.lang) : null) ?? K.message ?? getGlobalMessage(ie.lang);
  V && (ie.message = typeof V == "function" ? V(ie) : V), oe && (L.typed = !1), L.issues ? L.issues.push(ie) : L.issues = [ie];
}
function _isValidObjectKey(A, B) {
  return Object.hasOwn(A, B) && B !== "__proto__" && B !== "prototype" && B !== "constructor";
}
function getDefault(A, B, L) {
  return typeof A.default == "function" ? (
    // @ts-expect-error
    A.default(B, L)
  ) : (
    // @ts-expect-error
    A.default
  );
}
function array(A, B) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: A,
    message: B,
    _run(L, K) {
      var W;
      const re = L.value;
      if (Array.isArray(re)) {
        L.typed = !0, L.value = [];
        for (let J = 0; J < re.length; J++) {
          const ne = re[J], ie = this.item._run({ typed: !1, value: ne }, K);
          if (ie.issues) {
            const oe = {
              type: "array",
              origin: "value",
              input: re,
              key: J,
              value: ne
            };
            for (const V of ie.issues)
              V.path ? V.path.unshift(oe) : V.path = [oe], (W = L.issues) == null || W.push(V);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), L.value.push(ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function boolean(A) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "boolean" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function enum_(A, B) {
  const L = Object.entries(A).filter(([K]) => isNaN(+K)).map(([, K]) => K);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: L.map(_stringify).join(" | ") || "never",
    async: !1,
    enum: A,
    options: L,
    message: B,
    _run(K, re) {
      return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, re), K;
    }
  };
}
function literal(A, B) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(A),
    async: !1,
    literal: A,
    message: B,
    _run(L, K) {
      return L.value === this.literal ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function looseObject(A, B) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const re = L.value;
      if (re && typeof re == "object") {
        L.typed = !0, L.value = {};
        for (const J in this.entries) {
          const ne = re[J], ie = this.entries[J]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const oe = {
              type: "object",
              origin: "value",
              input: re,
              key: J,
              value: ne
            };
            for (const V of ie.issues)
              V.path ? V.path.unshift(oe) : V.path = [oe], (W = L.issues) == null || W.push(V);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || J in re) && (L.value[J] = ie.value);
        }
        if (!L.issues || !K.abortEarly)
          for (const J in re)
            _isValidObjectKey(re, J) && !(J in this.entries) && (L.value[J] = re[J]);
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function nonOptional(A, B) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: A,
    message: B,
    _run(L, K) {
      return L.value === void 0 ? (_addIssue(this, "type", L, K), L) : this.wrapped._run(L, K);
    }
  };
}
function null_(A) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === null ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function nullish(A, ...B) {
  const L = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `${A.expects} | null | undefined`,
    async: !1,
    wrapped: A,
    _run(K, re) {
      return (K.value === null || K.value === void 0) && ("default" in this && (K.value = getDefault(
        this,
        K,
        re
      )), K.value === null || K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, re);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function number$1(A) {
  return {
    kind: "schema",
    type: "number",
    reference: number$1,
    expects: "number",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "number" && !isNaN(B.value) ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function object(A, B) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const re = L.value;
      if (re && typeof re == "object") {
        L.typed = !0, L.value = {};
        for (const J in this.entries) {
          const ne = re[J], ie = this.entries[J]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const oe = {
              type: "object",
              origin: "value",
              input: re,
              key: J,
              value: ne
            };
            for (const V of ie.issues)
              V.path ? V.path.unshift(oe) : V.path = [oe], (W = L.issues) == null || W.push(V);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || J in re) && (L.value[J] = ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function optional(A, ...B) {
  const L = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${A.expects} | undefined`,
    async: !1,
    wrapped: A,
    _run(K, re) {
      return K.value === void 0 && ("default" in this && (K.value = getDefault(
        this,
        K,
        re
      )), K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, re);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function picklist(A, B) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: A.map(_stringify).join(" | ") || "never",
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      return this.options.includes(L.value) ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function string(A) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "string" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function undefined_(A) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === void 0 ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function _subIssues(A) {
  let B;
  if (A)
    for (const L of A)
      B ? B.push(...L.issues) : B = L.issues;
  return B;
}
function union(A, B) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: [...new Set(A.map((L) => L.expects))].join(" | ") || "never",
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      let re, W, J;
      for (const ne of this.options) {
        const ie = ne._run(
          { typed: !1, value: L.value },
          K
        );
        if (ie.typed)
          if (ie.issues)
            W ? W.push(ie) : W = [ie];
          else {
            re = ie;
            break;
          }
        else
          J ? J.push(ie) : J = [ie];
      }
      if (re)
        return re;
      if (W) {
        if (W.length === 1)
          return W[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(W)
        }), L.typed = !0;
      } else {
        if ((J == null ? void 0 : J.length) === 1)
          return J[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(J)
        });
      }
      return L;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(A) {
      return A.typed = !0, A;
    }
  };
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength$1(A) {
  var B = getLens$1(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength$1(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray$1(A) {
  var B, L = getLens$1(A), K = L[0], re = L[1], W = new Arr$1(_byteLength$1(A, K, re)), J = 0, ne = re > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup$1[A.charCodeAt(ie)] << 18 | revLookup$1[A.charCodeAt(ie + 1)] << 12 | revLookup$1[A.charCodeAt(ie + 2)] << 6 | revLookup$1[A.charCodeAt(ie + 3)], W[J++] = B >> 16 & 255, W[J++] = B >> 8 & 255, W[J++] = B & 255;
  return re === 2 && (B = revLookup$1[A.charCodeAt(ie)] << 2 | revLookup$1[A.charCodeAt(ie + 1)] >> 4, W[J++] = B & 255), re === 1 && (B = revLookup$1[A.charCodeAt(ie)] << 10 | revLookup$1[A.charCodeAt(ie + 1)] << 4 | revLookup$1[A.charCodeAt(ie + 2)] >> 2, W[J++] = B >> 8 & 255, W[J++] = B & 255), W;
}
function tripletToBase64$1(A) {
  return lookup$1[A >> 18 & 63] + lookup$1[A >> 12 & 63] + lookup$1[A >> 6 & 63] + lookup$1[A & 63];
}
function encodeChunk$1(A, B, L) {
  for (var K, re = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), re.push(tripletToBase64$1(K));
  return re.join("");
}
function fromByteArray$1(A) {
  for (var B, L = A.length, K = L % 3, re = [], W = 16383, J = 0, ne = L - K; J < ne; J += W)
    re.push(encodeChunk$1(A, J, J + W > ne ? ne : J + W));
  return K === 1 ? (B = A[L - 1], re.push(
    lookup$1[B >> 2] + lookup$1[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], re.push(
    lookup$1[B >> 10] + lookup$1[B >> 4 & 63] + lookup$1[B << 2 & 63] + "="
  )), re.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js$1;
function pad(A) {
  return `${A}${"=".repeat(4 - (A.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(A) {
  return A.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(A) {
  return pad(A).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(A) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(A)));
}
base64Url.encode = encode$j;
function decode$j(A) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(A))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = _assert.isBytes = void 0;
function number(A) {
  if (!Number.isSafeInteger(A) || A < 0)
    throw new Error(`positive integer expected, not ${A}`);
}
_assert.number = number;
function bool(A) {
  if (typeof A != "boolean")
    throw new Error(`boolean expected, not ${A}`);
}
_assert.bool = bool;
function isBytes(A) {
  return A instanceof Uint8Array || A != null && typeof A == "object" && A.constructor.name === "Uint8Array";
}
_assert.isBytes = isBytes;
function bytes(A, ...B) {
  if (!isBytes(A))
    throw new Error("Uint8Array expected");
  if (B.length > 0 && !B.includes(A.length))
    throw new Error(`Uint8Array expected of length ${B}, not of length=${A.length}`);
}
_assert.bytes = bytes;
function hash$2(A) {
  if (typeof A != "function" || typeof A.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(A.outputLen), number(A.blockLen);
}
_assert.hash = hash$2;
function exists(A, B = !0) {
  if (A.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (B && A.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(A, B) {
  bytes(A);
  const L = B.outputLen;
  if (A.length < L)
    throw new Error(`digestInto() expects output buffer of length at least ${L}`);
}
_assert.output = output;
const assert$1 = { number, bool, bytes, hash: hash$2, exists, output };
_assert.default = assert$1;
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(A) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.randomBytes = A.wrapXOFConstructorWithOpts = A.wrapConstructorWithOpts = A.wrapConstructor = A.checkOpts = A.Hash = A.concatBytes = A.toBytes = A.utf8ToBytes = A.asyncLoop = A.nextTick = A.hexToBytes = A.bytesToHex = A.byteSwap32 = A.byteSwapIfBE = A.byteSwap = A.isLE = A.rotl = A.rotr = A.createView = A.u32 = A.u8 = A.isBytes = void 0;
  const B = crypto$2, L = _assert;
  function K(Oe) {
    return Oe instanceof Uint8Array || Oe != null && typeof Oe == "object" && Oe.constructor.name === "Uint8Array";
  }
  A.isBytes = K;
  const re = (Oe) => new Uint8Array(Oe.buffer, Oe.byteOffset, Oe.byteLength);
  A.u8 = re;
  const W = (Oe) => new Uint32Array(Oe.buffer, Oe.byteOffset, Math.floor(Oe.byteLength / 4));
  A.u32 = W;
  const J = (Oe) => new DataView(Oe.buffer, Oe.byteOffset, Oe.byteLength);
  A.createView = J;
  const ne = (Oe, rt) => Oe << 32 - rt | Oe >>> rt;
  A.rotr = ne;
  const ie = (Oe, rt) => Oe << rt | Oe >>> 32 - rt >>> 0;
  A.rotl = ie, A.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const oe = (Oe) => Oe << 24 & 4278190080 | Oe << 8 & 16711680 | Oe >>> 8 & 65280 | Oe >>> 24 & 255;
  A.byteSwap = oe, A.byteSwapIfBE = A.isLE ? (Oe) => Oe : (Oe) => (0, A.byteSwap)(Oe);
  function V(Oe) {
    for (let rt = 0; rt < Oe.length; rt++)
      Oe[rt] = (0, A.byteSwap)(Oe[rt]);
  }
  A.byteSwap32 = V;
  const ce = /* @__PURE__ */ Array.from({ length: 256 }, (Oe, rt) => rt.toString(16).padStart(2, "0"));
  function ke(Oe) {
    (0, L.bytes)(Oe);
    let rt = "";
    for (let pe = 0; pe < Oe.length; pe++)
      rt += ce[Oe[pe]];
    return rt;
  }
  A.bytesToHex = ke;
  const Ce = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function it(Oe) {
    if (Oe >= Ce._0 && Oe <= Ce._9)
      return Oe - Ce._0;
    if (Oe >= Ce._A && Oe <= Ce._F)
      return Oe - (Ce._A - 10);
    if (Oe >= Ce._a && Oe <= Ce._f)
      return Oe - (Ce._a - 10);
  }
  function at(Oe) {
    if (typeof Oe != "string")
      throw new Error("hex string expected, got " + typeof Oe);
    const rt = Oe.length, pe = rt / 2;
    if (rt % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + rt);
    const nt = new Uint8Array(pe);
    for (let ot = 0, st = 0; ot < pe; ot++, st += 2) {
      const ut = it(Oe.charCodeAt(st)), pt = it(Oe.charCodeAt(st + 1));
      if (ut === void 0 || pt === void 0) {
        const ft = Oe[st] + Oe[st + 1];
        throw new Error('hex string expected, got non-hex character "' + ft + '" at index ' + st);
      }
      nt[ot] = ut * 16 + pt;
    }
    return nt;
  }
  A.hexToBytes = at;
  const lt = async () => {
  };
  A.nextTick = lt;
  async function ht(Oe, rt, pe) {
    let nt = Date.now();
    for (let ot = 0; ot < Oe; ot++) {
      pe(ot);
      const st = Date.now() - nt;
      st >= 0 && st < rt || (await (0, A.nextTick)(), nt += st);
    }
  }
  A.asyncLoop = ht;
  function dt(Oe) {
    if (typeof Oe != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof Oe}`);
    return new Uint8Array(new TextEncoder().encode(Oe));
  }
  A.utf8ToBytes = dt;
  function bt(Oe) {
    return typeof Oe == "string" && (Oe = dt(Oe)), (0, L.bytes)(Oe), Oe;
  }
  A.toBytes = bt;
  function vt(...Oe) {
    let rt = 0;
    for (let nt = 0; nt < Oe.length; nt++) {
      const ot = Oe[nt];
      (0, L.bytes)(ot), rt += ot.length;
    }
    const pe = new Uint8Array(rt);
    for (let nt = 0, ot = 0; nt < Oe.length; nt++) {
      const st = Oe[nt];
      pe.set(st, ot), ot += st.length;
    }
    return pe;
  }
  A.concatBytes = vt;
  class Bt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  A.Hash = Bt;
  const At = {}.toString;
  function Nt(Oe, rt) {
    if (rt !== void 0 && At.call(rt) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Oe, rt);
  }
  A.checkOpts = Nt;
  function $t(Oe) {
    const rt = (nt) => Oe().update(bt(nt)).digest(), pe = Oe();
    return rt.outputLen = pe.outputLen, rt.blockLen = pe.blockLen, rt.create = () => Oe(), rt;
  }
  A.wrapConstructor = $t;
  function mt(Oe) {
    const rt = (nt, ot) => Oe(ot).update(bt(nt)).digest(), pe = Oe({});
    return rt.outputLen = pe.outputLen, rt.blockLen = pe.blockLen, rt.create = (nt) => Oe(nt), rt;
  }
  A.wrapConstructorWithOpts = mt;
  function xt(Oe) {
    const rt = (nt, ot) => Oe(ot).update(bt(nt)).digest(), pe = Oe({});
    return rt.outputLen = pe.outputLen, rt.blockLen = pe.blockLen, rt.create = (nt) => Oe(nt), rt;
  }
  A.wrapXOFConstructorWithOpts = xt;
  function wt(Oe = 32) {
    if (B.crypto && typeof B.crypto.getRandomValues == "function")
      return B.crypto.getRandomValues(new Uint8Array(Oe));
    throw new Error("crypto.getRandomValues must be defined");
  }
  A.randomBytes = wt;
})(utils$5);
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.hmac = A.HMAC = void 0;
  const B = _assert, L = utils$5;
  class K extends L.Hash {
    constructor(J, ne) {
      super(), this.finished = !1, this.destroyed = !1, (0, B.hash)(J);
      const ie = (0, L.toBytes)(ne);
      if (this.iHash = J.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const oe = this.blockLen, V = new Uint8Array(oe);
      V.set(ie.length > oe ? J.create().update(ie).digest() : ie);
      for (let ce = 0; ce < V.length; ce++)
        V[ce] ^= 54;
      this.iHash.update(V), this.oHash = J.create();
      for (let ce = 0; ce < V.length; ce++)
        V[ce] ^= 106;
      this.oHash.update(V), V.fill(0);
    }
    update(J) {
      return (0, B.exists)(this), this.iHash.update(J), this;
    }
    digestInto(J) {
      (0, B.exists)(this), (0, B.bytes)(J, this.outputLen), this.finished = !0, this.iHash.digestInto(J), this.oHash.update(J), this.oHash.digestInto(J), this.destroy();
    }
    digest() {
      const J = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(J), J;
    }
    _cloneInto(J) {
      J || (J = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ne, iHash: ie, finished: oe, destroyed: V, blockLen: ce, outputLen: ke } = this;
      return J = J, J.finished = oe, J.destroyed = V, J.blockLen = ce, J.outputLen = ke, J.oHash = ne._cloneInto(J.oHash), J.iHash = ie._cloneInto(J.iHash), J;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  A.HMAC = K;
  const re = (W, J, ne) => new K(W, J).update(ne).digest();
  A.hmac = re, A.hmac.create = (W, J) => new K(W, J);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = _md.Maj = _md.Chi = void 0;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(A, B, L, K) {
  if (typeof A.setBigUint64 == "function")
    return A.setBigUint64(B, L, K);
  const re = BigInt(32), W = BigInt(4294967295), J = Number(L >> re & W), ne = Number(L & W), ie = K ? 4 : 0, oe = K ? 0 : 4;
  A.setUint32(B + ie, J, K), A.setUint32(B + oe, ne, K);
}
const Chi = (A, B, L) => A & B ^ ~A & L;
_md.Chi = Chi;
const Maj = (A, B, L) => A & B ^ A & L ^ B & L;
_md.Maj = Maj;
class HashMD extends utils_js_1$3.Hash {
  constructor(B, L, K, re) {
    super(), this.blockLen = B, this.outputLen = L, this.padOffset = K, this.isLE = re, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(B), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(B) {
    (0, _assert_js_1.exists)(this);
    const { view: L, buffer: K, blockLen: re } = this;
    B = (0, utils_js_1$3.toBytes)(B);
    const W = B.length;
    for (let J = 0; J < W; ) {
      const ne = Math.min(re - this.pos, W - J);
      if (ne === re) {
        const ie = (0, utils_js_1$3.createView)(B);
        for (; re <= W - J; J += re)
          this.process(ie, J);
        continue;
      }
      K.set(B.subarray(J, J + ne), this.pos), this.pos += ne, J += ne, this.pos === re && (this.process(L, 0), this.pos = 0);
    }
    return this.length += B.length, this.roundClean(), this;
  }
  digestInto(B) {
    (0, _assert_js_1.exists)(this), (0, _assert_js_1.output)(B, this), this.finished = !0;
    const { buffer: L, view: K, blockLen: re, isLE: W } = this;
    let { pos: J } = this;
    L[J++] = 128, this.buffer.subarray(J).fill(0), this.padOffset > re - J && (this.process(K, 0), J = 0);
    for (let ce = J; ce < re; ce++)
      L[ce] = 0;
    setBigUint64(K, re - 8, BigInt(this.length * 8), W), this.process(K, 0);
    const ne = (0, utils_js_1$3.createView)(B), ie = this.outputLen;
    if (ie % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const oe = ie / 4, V = this.get();
    if (oe > V.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let ce = 0; ce < oe; ce++)
      ne.setUint32(4 * ce, V[ce], W);
  }
  digest() {
    const { buffer: B, outputLen: L } = this;
    this.digestInto(B);
    const K = B.slice(0, L);
    return this.destroy(), K;
  }
  _cloneInto(B) {
    B || (B = new this.constructor()), B.set(...this.get());
    const { blockLen: L, buffer: K, length: re, finished: W, destroyed: J, pos: ne } = this;
    return B.length = re, B.pos = ne, B.finished = W, B.destroyed = J, re % L && B.buffer.set(K), B;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: re, E: W, F: J, G: ne, H: ie } = this;
    return [B, L, K, re, W, J, ne, ie];
  }
  // prettier-ignore
  set(B, L, K, re, W, J, ne, ie) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = re | 0, this.E = W | 0, this.F = J | 0, this.G = ne | 0, this.H = ie | 0;
  }
  process(B, L) {
    for (let ce = 0; ce < 16; ce++, L += 4)
      SHA256_W[ce] = B.getUint32(L, !1);
    for (let ce = 16; ce < 64; ce++) {
      const ke = SHA256_W[ce - 15], Ce = SHA256_W[ce - 2], it = (0, utils_js_1$2.rotr)(ke, 7) ^ (0, utils_js_1$2.rotr)(ke, 18) ^ ke >>> 3, at = (0, utils_js_1$2.rotr)(Ce, 17) ^ (0, utils_js_1$2.rotr)(Ce, 19) ^ Ce >>> 10;
      SHA256_W[ce] = at + SHA256_W[ce - 7] + it + SHA256_W[ce - 16] | 0;
    }
    let { A: K, B: re, C: W, D: J, E: ne, F: ie, G: oe, H: V } = this;
    for (let ce = 0; ce < 64; ce++) {
      const ke = (0, utils_js_1$2.rotr)(ne, 6) ^ (0, utils_js_1$2.rotr)(ne, 11) ^ (0, utils_js_1$2.rotr)(ne, 25), Ce = V + ke + (0, _md_js_1$2.Chi)(ne, ie, oe) + SHA256_K[ce] + SHA256_W[ce] | 0, at = ((0, utils_js_1$2.rotr)(K, 2) ^ (0, utils_js_1$2.rotr)(K, 13) ^ (0, utils_js_1$2.rotr)(K, 22)) + (0, _md_js_1$2.Maj)(K, re, W) | 0;
      V = oe, oe = ie, ie = ne, ne = J + Ce | 0, J = W, W = re, re = K, K = Ce + at | 0;
    }
    K = K + this.A | 0, re = re + this.B | 0, W = W + this.C | 0, J = J + this.D | 0, ne = ne + this.E | 0, ie = ie + this.F | 0, oe = oe + this.G | 0, V = V + this.H | 0, this.set(K, re, W, J, ne, ie, oe, V);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} }, buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength(A) {
  var B = getLens(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray(A) {
  var B, L = getLens(A), K = L[0], re = L[1], W = new Arr(_byteLength(A, K, re)), J = 0, ne = re > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup[A.charCodeAt(ie)] << 18 | revLookup[A.charCodeAt(ie + 1)] << 12 | revLookup[A.charCodeAt(ie + 2)] << 6 | revLookup[A.charCodeAt(ie + 3)], W[J++] = B >> 16 & 255, W[J++] = B >> 8 & 255, W[J++] = B & 255;
  return re === 2 && (B = revLookup[A.charCodeAt(ie)] << 2 | revLookup[A.charCodeAt(ie + 1)] >> 4, W[J++] = B & 255), re === 1 && (B = revLookup[A.charCodeAt(ie)] << 10 | revLookup[A.charCodeAt(ie + 1)] << 4 | revLookup[A.charCodeAt(ie + 2)] >> 2, W[J++] = B >> 8 & 255, W[J++] = B & 255), W;
}
function tripletToBase64(A) {
  return lookup[A >> 18 & 63] + lookup[A >> 12 & 63] + lookup[A >> 6 & 63] + lookup[A & 63];
}
function encodeChunk(A, B, L) {
  for (var K, re = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), re.push(tripletToBase64(K));
  return re.join("");
}
function fromByteArray(A) {
  for (var B, L = A.length, K = L % 3, re = [], W = 16383, J = 0, ne = L - K; J < ne; J += W)
    re.push(encodeChunk(A, J, J + W > ne ? ne : J + W));
  return K === 1 ? (B = A[L - 1], re.push(
    lookup[B >> 2] + lookup[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], re.push(
    lookup[B >> 10] + lookup[B >> 4 & 63] + lookup[B << 2 & 63] + "="
  )), re.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(A, B, L, K, re) {
  var W, J, ne = re * 8 - K - 1, ie = (1 << ne) - 1, oe = ie >> 1, V = -7, ce = L ? re - 1 : 0, ke = L ? -1 : 1, Ce = A[B + ce];
  for (ce += ke, W = Ce & (1 << -V) - 1, Ce >>= -V, V += ne; V > 0; W = W * 256 + A[B + ce], ce += ke, V -= 8)
    ;
  for (J = W & (1 << -V) - 1, W >>= -V, V += K; V > 0; J = J * 256 + A[B + ce], ce += ke, V -= 8)
    ;
  if (W === 0)
    W = 1 - oe;
  else {
    if (W === ie)
      return J ? NaN : (Ce ? -1 : 1) * (1 / 0);
    J = J + Math.pow(2, K), W = W - oe;
  }
  return (Ce ? -1 : 1) * J * Math.pow(2, W - K);
};
ieee754.write = function(A, B, L, K, re, W) {
  var J, ne, ie, oe = W * 8 - re - 1, V = (1 << oe) - 1, ce = V >> 1, ke = re === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ce = K ? 0 : W - 1, it = K ? 1 : -1, at = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
  for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (ne = isNaN(B) ? 1 : 0, J = V) : (J = Math.floor(Math.log(B) / Math.LN2), B * (ie = Math.pow(2, -J)) < 1 && (J--, ie *= 2), J + ce >= 1 ? B += ke / ie : B += ke * Math.pow(2, 1 - ce), B * ie >= 2 && (J++, ie /= 2), J + ce >= V ? (ne = 0, J = V) : J + ce >= 1 ? (ne = (B * ie - 1) * Math.pow(2, re), J = J + ce) : (ne = B * Math.pow(2, ce - 1) * Math.pow(2, re), J = 0)); re >= 8; A[L + Ce] = ne & 255, Ce += it, ne /= 256, re -= 8)
    ;
  for (J = J << re | ne, oe += re; oe > 0; A[L + Ce] = J & 255, Ce += it, J /= 256, oe -= 8)
    ;
  A[L + Ce - it] |= at * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(A) {
  const B = base64Js, L = ieee754, K = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  A.Buffer = V, A.SlowBuffer = Bt, A.INSPECT_MAX_BYTES = 50;
  const re = 2147483647;
  A.kMaxLength = re;
  const { Uint8Array: W, ArrayBuffer: J, SharedArrayBuffer: ne } = globalThis;
  V.TYPED_ARRAY_SUPPORT = ie(), !V.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ie() {
    try {
      const It = new W(1), gt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(gt, W.prototype), Object.setPrototypeOf(It, gt), It.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(V.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (V.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(V.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (V.isBuffer(this))
        return this.byteOffset;
    }
  });
  function oe(It) {
    if (It > re)
      throw new RangeError('The value "' + It + '" is invalid for option "size"');
    const gt = new W(It);
    return Object.setPrototypeOf(gt, V.prototype), gt;
  }
  function V(It, gt, Et) {
    if (typeof It == "number") {
      if (typeof gt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return it(It);
    }
    return ce(It, gt, Et);
  }
  V.poolSize = 8192;
  function ce(It, gt, Et) {
    if (typeof It == "string")
      return at(It, gt);
    if (J.isView(It))
      return ht(It);
    if (It == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof It
      );
    if (Er(It, J) || It && Er(It.buffer, J) || typeof ne < "u" && (Er(It, ne) || It && Er(It.buffer, ne)))
      return dt(It, gt, Et);
    if (typeof It == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ct = It.valueOf && It.valueOf();
    if (Ct != null && Ct !== It)
      return V.from(Ct, gt, Et);
    const Wt = bt(It);
    if (Wt) return Wt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof It[Symbol.toPrimitive] == "function")
      return V.from(It[Symbol.toPrimitive]("string"), gt, Et);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof It
    );
  }
  V.from = function(It, gt, Et) {
    return ce(It, gt, Et);
  }, Object.setPrototypeOf(V.prototype, W.prototype), Object.setPrototypeOf(V, W);
  function ke(It) {
    if (typeof It != "number")
      throw new TypeError('"size" argument must be of type number');
    if (It < 0)
      throw new RangeError('The value "' + It + '" is invalid for option "size"');
  }
  function Ce(It, gt, Et) {
    return ke(It), It <= 0 ? oe(It) : gt !== void 0 ? typeof Et == "string" ? oe(It).fill(gt, Et) : oe(It).fill(gt) : oe(It);
  }
  V.alloc = function(It, gt, Et) {
    return Ce(It, gt, Et);
  };
  function it(It) {
    return ke(It), oe(It < 0 ? 0 : vt(It) | 0);
  }
  V.allocUnsafe = function(It) {
    return it(It);
  }, V.allocUnsafeSlow = function(It) {
    return it(It);
  };
  function at(It, gt) {
    if ((typeof gt != "string" || gt === "") && (gt = "utf8"), !V.isEncoding(gt))
      throw new TypeError("Unknown encoding: " + gt);
    const Et = At(It, gt) | 0;
    let Ct = oe(Et);
    const Wt = Ct.write(It, gt);
    return Wt !== Et && (Ct = Ct.slice(0, Wt)), Ct;
  }
  function lt(It) {
    const gt = It.length < 0 ? 0 : vt(It.length) | 0, Et = oe(gt);
    for (let Ct = 0; Ct < gt; Ct += 1)
      Et[Ct] = It[Ct] & 255;
    return Et;
  }
  function ht(It) {
    if (Er(It, W)) {
      const gt = new W(It);
      return dt(gt.buffer, gt.byteOffset, gt.byteLength);
    }
    return lt(It);
  }
  function dt(It, gt, Et) {
    if (gt < 0 || It.byteLength < gt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (It.byteLength < gt + (Et || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ct;
    return gt === void 0 && Et === void 0 ? Ct = new W(It) : Et === void 0 ? Ct = new W(It, gt) : Ct = new W(It, gt, Et), Object.setPrototypeOf(Ct, V.prototype), Ct;
  }
  function bt(It) {
    if (V.isBuffer(It)) {
      const gt = vt(It.length) | 0, Et = oe(gt);
      return Et.length === 0 || It.copy(Et, 0, 0, gt), Et;
    }
    if (It.length !== void 0)
      return typeof It.length != "number" || Pr(It.length) ? oe(0) : lt(It);
    if (It.type === "Buffer" && Array.isArray(It.data))
      return lt(It.data);
  }
  function vt(It) {
    if (It >= re)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + re.toString(16) + " bytes");
    return It | 0;
  }
  function Bt(It) {
    return +It != It && (It = 0), V.alloc(+It);
  }
  V.isBuffer = function(gt) {
    return gt != null && gt._isBuffer === !0 && gt !== V.prototype;
  }, V.compare = function(gt, Et) {
    if (Er(gt, W) && (gt = V.from(gt, gt.offset, gt.byteLength)), Er(Et, W) && (Et = V.from(Et, Et.offset, Et.byteLength)), !V.isBuffer(gt) || !V.isBuffer(Et))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (gt === Et) return 0;
    let Ct = gt.length, Wt = Et.length;
    for (let zt = 0, Vt = Math.min(Ct, Wt); zt < Vt; ++zt)
      if (gt[zt] !== Et[zt]) {
        Ct = gt[zt], Wt = Et[zt];
        break;
      }
    return Ct < Wt ? -1 : Wt < Ct ? 1 : 0;
  }, V.isEncoding = function(gt) {
    switch (String(gt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, V.concat = function(gt, Et) {
    if (!Array.isArray(gt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (gt.length === 0)
      return V.alloc(0);
    let Ct;
    if (Et === void 0)
      for (Et = 0, Ct = 0; Ct < gt.length; ++Ct)
        Et += gt[Ct].length;
    const Wt = V.allocUnsafe(Et);
    let zt = 0;
    for (Ct = 0; Ct < gt.length; ++Ct) {
      let Vt = gt[Ct];
      if (Er(Vt, W))
        zt + Vt.length > Wt.length ? (V.isBuffer(Vt) || (Vt = V.from(Vt)), Vt.copy(Wt, zt)) : W.prototype.set.call(
          Wt,
          Vt,
          zt
        );
      else if (V.isBuffer(Vt))
        Vt.copy(Wt, zt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      zt += Vt.length;
    }
    return Wt;
  };
  function At(It, gt) {
    if (V.isBuffer(It))
      return It.length;
    if (J.isView(It) || Er(It, J))
      return It.byteLength;
    if (typeof It != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof It
      );
    const Et = It.length, Ct = arguments.length > 2 && arguments[2] === !0;
    if (!Ct && Et === 0) return 0;
    let Wt = !1;
    for (; ; )
      switch (gt) {
        case "ascii":
        case "latin1":
        case "binary":
          return Et;
        case "utf8":
        case "utf-8":
          return Ir(It).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Et * 2;
        case "hex":
          return Et >>> 1;
        case "base64":
          return Br(It).length;
        default:
          if (Wt)
            return Ct ? -1 : Ir(It).length;
          gt = ("" + gt).toLowerCase(), Wt = !0;
      }
  }
  V.byteLength = At;
  function Nt(It, gt, Et) {
    let Ct = !1;
    if ((gt === void 0 || gt < 0) && (gt = 0), gt > this.length || ((Et === void 0 || Et > this.length) && (Et = this.length), Et <= 0) || (Et >>>= 0, gt >>>= 0, Et <= gt))
      return "";
    for (It || (It = "utf8"); ; )
      switch (It) {
        case "hex":
          return ct(this, gt, Et);
        case "utf8":
        case "utf-8":
          return st(this, gt, Et);
        case "ascii":
          return ft(this, gt, Et);
        case "latin1":
        case "binary":
          return yt(this, gt, Et);
        case "base64":
          return ot(this, gt, Et);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return St(this, gt, Et);
        default:
          if (Ct) throw new TypeError("Unknown encoding: " + It);
          It = (It + "").toLowerCase(), Ct = !0;
      }
  }
  V.prototype._isBuffer = !0;
  function $t(It, gt, Et) {
    const Ct = It[gt];
    It[gt] = It[Et], It[Et] = Ct;
  }
  V.prototype.swap16 = function() {
    const gt = this.length;
    if (gt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Et = 0; Et < gt; Et += 2)
      $t(this, Et, Et + 1);
    return this;
  }, V.prototype.swap32 = function() {
    const gt = this.length;
    if (gt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Et = 0; Et < gt; Et += 4)
      $t(this, Et, Et + 3), $t(this, Et + 1, Et + 2);
    return this;
  }, V.prototype.swap64 = function() {
    const gt = this.length;
    if (gt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Et = 0; Et < gt; Et += 8)
      $t(this, Et, Et + 7), $t(this, Et + 1, Et + 6), $t(this, Et + 2, Et + 5), $t(this, Et + 3, Et + 4);
    return this;
  }, V.prototype.toString = function() {
    const gt = this.length;
    return gt === 0 ? "" : arguments.length === 0 ? st(this, 0, gt) : Nt.apply(this, arguments);
  }, V.prototype.toLocaleString = V.prototype.toString, V.prototype.equals = function(gt) {
    if (!V.isBuffer(gt)) throw new TypeError("Argument must be a Buffer");
    return this === gt ? !0 : V.compare(this, gt) === 0;
  }, V.prototype.inspect = function() {
    let gt = "";
    const Et = A.INSPECT_MAX_BYTES;
    return gt = this.toString("hex", 0, Et).replace(/(.{2})/g, "$1 ").trim(), this.length > Et && (gt += " ... "), "<Buffer " + gt + ">";
  }, K && (V.prototype[K] = V.prototype.inspect), V.prototype.compare = function(gt, Et, Ct, Wt, zt) {
    if (Er(gt, W) && (gt = V.from(gt, gt.offset, gt.byteLength)), !V.isBuffer(gt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof gt
      );
    if (Et === void 0 && (Et = 0), Ct === void 0 && (Ct = gt ? gt.length : 0), Wt === void 0 && (Wt = 0), zt === void 0 && (zt = this.length), Et < 0 || Ct > gt.length || Wt < 0 || zt > this.length)
      throw new RangeError("out of range index");
    if (Wt >= zt && Et >= Ct)
      return 0;
    if (Wt >= zt)
      return -1;
    if (Et >= Ct)
      return 1;
    if (Et >>>= 0, Ct >>>= 0, Wt >>>= 0, zt >>>= 0, this === gt) return 0;
    let Vt = zt - Wt, yr = Ct - Et;
    const $r = Math.min(Vt, yr), cr = this.slice(Wt, zt), xr = gt.slice(Et, Ct);
    for (let gr = 0; gr < $r; ++gr)
      if (cr[gr] !== xr[gr]) {
        Vt = cr[gr], yr = xr[gr];
        break;
      }
    return Vt < yr ? -1 : yr < Vt ? 1 : 0;
  };
  function mt(It, gt, Et, Ct, Wt) {
    if (It.length === 0) return -1;
    if (typeof Et == "string" ? (Ct = Et, Et = 0) : Et > 2147483647 ? Et = 2147483647 : Et < -2147483648 && (Et = -2147483648), Et = +Et, Pr(Et) && (Et = Wt ? 0 : It.length - 1), Et < 0 && (Et = It.length + Et), Et >= It.length) {
      if (Wt) return -1;
      Et = It.length - 1;
    } else if (Et < 0)
      if (Wt) Et = 0;
      else return -1;
    if (typeof gt == "string" && (gt = V.from(gt, Ct)), V.isBuffer(gt))
      return gt.length === 0 ? -1 : xt(It, gt, Et, Ct, Wt);
    if (typeof gt == "number")
      return gt = gt & 255, typeof W.prototype.indexOf == "function" ? Wt ? W.prototype.indexOf.call(It, gt, Et) : W.prototype.lastIndexOf.call(It, gt, Et) : xt(It, [gt], Et, Ct, Wt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function xt(It, gt, Et, Ct, Wt) {
    let zt = 1, Vt = It.length, yr = gt.length;
    if (Ct !== void 0 && (Ct = String(Ct).toLowerCase(), Ct === "ucs2" || Ct === "ucs-2" || Ct === "utf16le" || Ct === "utf-16le")) {
      if (It.length < 2 || gt.length < 2)
        return -1;
      zt = 2, Vt /= 2, yr /= 2, Et /= 2;
    }
    function $r(xr, gr) {
      return zt === 1 ? xr[gr] : xr.readUInt16BE(gr * zt);
    }
    let cr;
    if (Wt) {
      let xr = -1;
      for (cr = Et; cr < Vt; cr++)
        if ($r(It, cr) === $r(gt, xr === -1 ? 0 : cr - xr)) {
          if (xr === -1 && (xr = cr), cr - xr + 1 === yr) return xr * zt;
        } else
          xr !== -1 && (cr -= cr - xr), xr = -1;
    } else
      for (Et + yr > Vt && (Et = Vt - yr), cr = Et; cr >= 0; cr--) {
        let xr = !0;
        for (let gr = 0; gr < yr; gr++)
          if ($r(It, cr + gr) !== $r(gt, gr)) {
            xr = !1;
            break;
          }
        if (xr) return cr;
      }
    return -1;
  }
  V.prototype.includes = function(gt, Et, Ct) {
    return this.indexOf(gt, Et, Ct) !== -1;
  }, V.prototype.indexOf = function(gt, Et, Ct) {
    return mt(this, gt, Et, Ct, !0);
  }, V.prototype.lastIndexOf = function(gt, Et, Ct) {
    return mt(this, gt, Et, Ct, !1);
  };
  function wt(It, gt, Et, Ct) {
    Et = Number(Et) || 0;
    const Wt = It.length - Et;
    Ct ? (Ct = Number(Ct), Ct > Wt && (Ct = Wt)) : Ct = Wt;
    const zt = gt.length;
    Ct > zt / 2 && (Ct = zt / 2);
    let Vt;
    for (Vt = 0; Vt < Ct; ++Vt) {
      const yr = parseInt(gt.substr(Vt * 2, 2), 16);
      if (Pr(yr)) return Vt;
      It[Et + Vt] = yr;
    }
    return Vt;
  }
  function Oe(It, gt, Et, Ct) {
    return dr(Ir(gt, It.length - Et), It, Et, Ct);
  }
  function rt(It, gt, Et, Ct) {
    return dr(lr(gt), It, Et, Ct);
  }
  function pe(It, gt, Et, Ct) {
    return dr(Br(gt), It, Et, Ct);
  }
  function nt(It, gt, Et, Ct) {
    return dr(Ar(gt, It.length - Et), It, Et, Ct);
  }
  V.prototype.write = function(gt, Et, Ct, Wt) {
    if (Et === void 0)
      Wt = "utf8", Ct = this.length, Et = 0;
    else if (Ct === void 0 && typeof Et == "string")
      Wt = Et, Ct = this.length, Et = 0;
    else if (isFinite(Et))
      Et = Et >>> 0, isFinite(Ct) ? (Ct = Ct >>> 0, Wt === void 0 && (Wt = "utf8")) : (Wt = Ct, Ct = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const zt = this.length - Et;
    if ((Ct === void 0 || Ct > zt) && (Ct = zt), gt.length > 0 && (Ct < 0 || Et < 0) || Et > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Wt || (Wt = "utf8");
    let Vt = !1;
    for (; ; )
      switch (Wt) {
        case "hex":
          return wt(this, gt, Et, Ct);
        case "utf8":
        case "utf-8":
          return Oe(this, gt, Et, Ct);
        case "ascii":
        case "latin1":
        case "binary":
          return rt(this, gt, Et, Ct);
        case "base64":
          return pe(this, gt, Et, Ct);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return nt(this, gt, Et, Ct);
        default:
          if (Vt) throw new TypeError("Unknown encoding: " + Wt);
          Wt = ("" + Wt).toLowerCase(), Vt = !0;
      }
  }, V.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ot(It, gt, Et) {
    return gt === 0 && Et === It.length ? B.fromByteArray(It) : B.fromByteArray(It.slice(gt, Et));
  }
  function st(It, gt, Et) {
    Et = Math.min(It.length, Et);
    const Ct = [];
    let Wt = gt;
    for (; Wt < Et; ) {
      const zt = It[Wt];
      let Vt = null, yr = zt > 239 ? 4 : zt > 223 ? 3 : zt > 191 ? 2 : 1;
      if (Wt + yr <= Et) {
        let $r, cr, xr, gr;
        switch (yr) {
          case 1:
            zt < 128 && (Vt = zt);
            break;
          case 2:
            $r = It[Wt + 1], ($r & 192) === 128 && (gr = (zt & 31) << 6 | $r & 63, gr > 127 && (Vt = gr));
            break;
          case 3:
            $r = It[Wt + 1], cr = It[Wt + 2], ($r & 192) === 128 && (cr & 192) === 128 && (gr = (zt & 15) << 12 | ($r & 63) << 6 | cr & 63, gr > 2047 && (gr < 55296 || gr > 57343) && (Vt = gr));
            break;
          case 4:
            $r = It[Wt + 1], cr = It[Wt + 2], xr = It[Wt + 3], ($r & 192) === 128 && (cr & 192) === 128 && (xr & 192) === 128 && (gr = (zt & 15) << 18 | ($r & 63) << 12 | (cr & 63) << 6 | xr & 63, gr > 65535 && gr < 1114112 && (Vt = gr));
        }
      }
      Vt === null ? (Vt = 65533, yr = 1) : Vt > 65535 && (Vt -= 65536, Ct.push(Vt >>> 10 & 1023 | 55296), Vt = 56320 | Vt & 1023), Ct.push(Vt), Wt += yr;
    }
    return pt(Ct);
  }
  const ut = 4096;
  function pt(It) {
    const gt = It.length;
    if (gt <= ut)
      return String.fromCharCode.apply(String, It);
    let Et = "", Ct = 0;
    for (; Ct < gt; )
      Et += String.fromCharCode.apply(
        String,
        It.slice(Ct, Ct += ut)
      );
    return Et;
  }
  function ft(It, gt, Et) {
    let Ct = "";
    Et = Math.min(It.length, Et);
    for (let Wt = gt; Wt < Et; ++Wt)
      Ct += String.fromCharCode(It[Wt] & 127);
    return Ct;
  }
  function yt(It, gt, Et) {
    let Ct = "";
    Et = Math.min(It.length, Et);
    for (let Wt = gt; Wt < Et; ++Wt)
      Ct += String.fromCharCode(It[Wt]);
    return Ct;
  }
  function ct(It, gt, Et) {
    const Ct = It.length;
    (!gt || gt < 0) && (gt = 0), (!Et || Et < 0 || Et > Ct) && (Et = Ct);
    let Wt = "";
    for (let zt = gt; zt < Et; ++zt)
      Wt += br[It[zt]];
    return Wt;
  }
  function St(It, gt, Et) {
    const Ct = It.slice(gt, Et);
    let Wt = "";
    for (let zt = 0; zt < Ct.length - 1; zt += 2)
      Wt += String.fromCharCode(Ct[zt] + Ct[zt + 1] * 256);
    return Wt;
  }
  V.prototype.slice = function(gt, Et) {
    const Ct = this.length;
    gt = ~~gt, Et = Et === void 0 ? Ct : ~~Et, gt < 0 ? (gt += Ct, gt < 0 && (gt = 0)) : gt > Ct && (gt = Ct), Et < 0 ? (Et += Ct, Et < 0 && (Et = 0)) : Et > Ct && (Et = Ct), Et < gt && (Et = gt);
    const Wt = this.subarray(gt, Et);
    return Object.setPrototypeOf(Wt, V.prototype), Wt;
  };
  function qt(It, gt, Et) {
    if (It % 1 !== 0 || It < 0) throw new RangeError("offset is not uint");
    if (It + gt > Et) throw new RangeError("Trying to access beyond buffer length");
  }
  V.prototype.readUintLE = V.prototype.readUIntLE = function(gt, Et, Ct) {
    gt = gt >>> 0, Et = Et >>> 0, Ct || qt(gt, Et, this.length);
    let Wt = this[gt], zt = 1, Vt = 0;
    for (; ++Vt < Et && (zt *= 256); )
      Wt += this[gt + Vt] * zt;
    return Wt;
  }, V.prototype.readUintBE = V.prototype.readUIntBE = function(gt, Et, Ct) {
    gt = gt >>> 0, Et = Et >>> 0, Ct || qt(gt, Et, this.length);
    let Wt = this[gt + --Et], zt = 1;
    for (; Et > 0 && (zt *= 256); )
      Wt += this[gt + --Et] * zt;
    return Wt;
  }, V.prototype.readUint8 = V.prototype.readUInt8 = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 1, this.length), this[gt];
  }, V.prototype.readUint16LE = V.prototype.readUInt16LE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 2, this.length), this[gt] | this[gt + 1] << 8;
  }, V.prototype.readUint16BE = V.prototype.readUInt16BE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 2, this.length), this[gt] << 8 | this[gt + 1];
  }, V.prototype.readUint32LE = V.prototype.readUInt32LE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 4, this.length), (this[gt] | this[gt + 1] << 8 | this[gt + 2] << 16) + this[gt + 3] * 16777216;
  }, V.prototype.readUint32BE = V.prototype.readUInt32BE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 4, this.length), this[gt] * 16777216 + (this[gt + 1] << 16 | this[gt + 2] << 8 | this[gt + 3]);
  }, V.prototype.readBigUInt64LE = Mr(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const Et = this[gt], Ct = this[gt + 7];
    (Et === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = Et + this[++gt] * 2 ** 8 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 24, zt = this[++gt] + this[++gt] * 2 ** 8 + this[++gt] * 2 ** 16 + Ct * 2 ** 24;
    return BigInt(Wt) + (BigInt(zt) << BigInt(32));
  }), V.prototype.readBigUInt64BE = Mr(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const Et = this[gt], Ct = this[gt + 7];
    (Et === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = Et * 2 ** 24 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + this[++gt], zt = this[++gt] * 2 ** 24 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + Ct;
    return (BigInt(Wt) << BigInt(32)) + BigInt(zt);
  }), V.prototype.readIntLE = function(gt, Et, Ct) {
    gt = gt >>> 0, Et = Et >>> 0, Ct || qt(gt, Et, this.length);
    let Wt = this[gt], zt = 1, Vt = 0;
    for (; ++Vt < Et && (zt *= 256); )
      Wt += this[gt + Vt] * zt;
    return zt *= 128, Wt >= zt && (Wt -= Math.pow(2, 8 * Et)), Wt;
  }, V.prototype.readIntBE = function(gt, Et, Ct) {
    gt = gt >>> 0, Et = Et >>> 0, Ct || qt(gt, Et, this.length);
    let Wt = Et, zt = 1, Vt = this[gt + --Wt];
    for (; Wt > 0 && (zt *= 256); )
      Vt += this[gt + --Wt] * zt;
    return zt *= 128, Vt >= zt && (Vt -= Math.pow(2, 8 * Et)), Vt;
  }, V.prototype.readInt8 = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 1, this.length), this[gt] & 128 ? (255 - this[gt] + 1) * -1 : this[gt];
  }, V.prototype.readInt16LE = function(gt, Et) {
    gt = gt >>> 0, Et || qt(gt, 2, this.length);
    const Ct = this[gt] | this[gt + 1] << 8;
    return Ct & 32768 ? Ct | 4294901760 : Ct;
  }, V.prototype.readInt16BE = function(gt, Et) {
    gt = gt >>> 0, Et || qt(gt, 2, this.length);
    const Ct = this[gt + 1] | this[gt] << 8;
    return Ct & 32768 ? Ct | 4294901760 : Ct;
  }, V.prototype.readInt32LE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 4, this.length), this[gt] | this[gt + 1] << 8 | this[gt + 2] << 16 | this[gt + 3] << 24;
  }, V.prototype.readInt32BE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 4, this.length), this[gt] << 24 | this[gt + 1] << 16 | this[gt + 2] << 8 | this[gt + 3];
  }, V.prototype.readBigInt64LE = Mr(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const Et = this[gt], Ct = this[gt + 7];
    (Et === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = this[gt + 4] + this[gt + 5] * 2 ** 8 + this[gt + 6] * 2 ** 16 + (Ct << 24);
    return (BigInt(Wt) << BigInt(32)) + BigInt(Et + this[++gt] * 2 ** 8 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 24);
  }), V.prototype.readBigInt64BE = Mr(function(gt) {
    gt = gt >>> 0, ar(gt, "offset");
    const Et = this[gt], Ct = this[gt + 7];
    (Et === void 0 || Ct === void 0) && ur(gt, this.length - 8);
    const Wt = (Et << 24) + // Overflow
    this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + this[++gt];
    return (BigInt(Wt) << BigInt(32)) + BigInt(this[++gt] * 2 ** 24 + this[++gt] * 2 ** 16 + this[++gt] * 2 ** 8 + Ct);
  }), V.prototype.readFloatLE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 4, this.length), L.read(this, gt, !0, 23, 4);
  }, V.prototype.readFloatBE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 4, this.length), L.read(this, gt, !1, 23, 4);
  }, V.prototype.readDoubleLE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 8, this.length), L.read(this, gt, !0, 52, 8);
  }, V.prototype.readDoubleBE = function(gt, Et) {
    return gt = gt >>> 0, Et || qt(gt, 8, this.length), L.read(this, gt, !1, 52, 8);
  };
  function jt(It, gt, Et, Ct, Wt, zt) {
    if (!V.isBuffer(It)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (gt > Wt || gt < zt) throw new RangeError('"value" argument is out of bounds');
    if (Et + Ct > It.length) throw new RangeError("Index out of range");
  }
  V.prototype.writeUintLE = V.prototype.writeUIntLE = function(gt, Et, Ct, Wt) {
    if (gt = +gt, Et = Et >>> 0, Ct = Ct >>> 0, !Wt) {
      const yr = Math.pow(2, 8 * Ct) - 1;
      jt(this, gt, Et, Ct, yr, 0);
    }
    let zt = 1, Vt = 0;
    for (this[Et] = gt & 255; ++Vt < Ct && (zt *= 256); )
      this[Et + Vt] = gt / zt & 255;
    return Et + Ct;
  }, V.prototype.writeUintBE = V.prototype.writeUIntBE = function(gt, Et, Ct, Wt) {
    if (gt = +gt, Et = Et >>> 0, Ct = Ct >>> 0, !Wt) {
      const yr = Math.pow(2, 8 * Ct) - 1;
      jt(this, gt, Et, Ct, yr, 0);
    }
    let zt = Ct - 1, Vt = 1;
    for (this[Et + zt] = gt & 255; --zt >= 0 && (Vt *= 256); )
      this[Et + zt] = gt / Vt & 255;
    return Et + Ct;
  }, V.prototype.writeUint8 = V.prototype.writeUInt8 = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 1, 255, 0), this[Et] = gt & 255, Et + 1;
  }, V.prototype.writeUint16LE = V.prototype.writeUInt16LE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 2, 65535, 0), this[Et] = gt & 255, this[Et + 1] = gt >>> 8, Et + 2;
  }, V.prototype.writeUint16BE = V.prototype.writeUInt16BE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 2, 65535, 0), this[Et] = gt >>> 8, this[Et + 1] = gt & 255, Et + 2;
  }, V.prototype.writeUint32LE = V.prototype.writeUInt32LE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 4, 4294967295, 0), this[Et + 3] = gt >>> 24, this[Et + 2] = gt >>> 16, this[Et + 1] = gt >>> 8, this[Et] = gt & 255, Et + 4;
  }, V.prototype.writeUint32BE = V.prototype.writeUInt32BE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 4, 4294967295, 0), this[Et] = gt >>> 24, this[Et + 1] = gt >>> 16, this[Et + 2] = gt >>> 8, this[Et + 3] = gt & 255, Et + 4;
  };
  function Ot(It, gt, Et, Ct, Wt) {
    rr(gt, Ct, Wt, It, Et, 7);
    let zt = Number(gt & BigInt(4294967295));
    It[Et++] = zt, zt = zt >> 8, It[Et++] = zt, zt = zt >> 8, It[Et++] = zt, zt = zt >> 8, It[Et++] = zt;
    let Vt = Number(gt >> BigInt(32) & BigInt(4294967295));
    return It[Et++] = Vt, Vt = Vt >> 8, It[Et++] = Vt, Vt = Vt >> 8, It[Et++] = Vt, Vt = Vt >> 8, It[Et++] = Vt, Et;
  }
  function Tt(It, gt, Et, Ct, Wt) {
    rr(gt, Ct, Wt, It, Et, 7);
    let zt = Number(gt & BigInt(4294967295));
    It[Et + 7] = zt, zt = zt >> 8, It[Et + 6] = zt, zt = zt >> 8, It[Et + 5] = zt, zt = zt >> 8, It[Et + 4] = zt;
    let Vt = Number(gt >> BigInt(32) & BigInt(4294967295));
    return It[Et + 3] = Vt, Vt = Vt >> 8, It[Et + 2] = Vt, Vt = Vt >> 8, It[Et + 1] = Vt, Vt = Vt >> 8, It[Et] = Vt, Et + 8;
  }
  V.prototype.writeBigUInt64LE = Mr(function(gt, Et = 0) {
    return Ot(this, gt, Et, BigInt(0), BigInt("0xffffffffffffffff"));
  }), V.prototype.writeBigUInt64BE = Mr(function(gt, Et = 0) {
    return Tt(this, gt, Et, BigInt(0), BigInt("0xffffffffffffffff"));
  }), V.prototype.writeIntLE = function(gt, Et, Ct, Wt) {
    if (gt = +gt, Et = Et >>> 0, !Wt) {
      const $r = Math.pow(2, 8 * Ct - 1);
      jt(this, gt, Et, Ct, $r - 1, -$r);
    }
    let zt = 0, Vt = 1, yr = 0;
    for (this[Et] = gt & 255; ++zt < Ct && (Vt *= 256); )
      gt < 0 && yr === 0 && this[Et + zt - 1] !== 0 && (yr = 1), this[Et + zt] = (gt / Vt >> 0) - yr & 255;
    return Et + Ct;
  }, V.prototype.writeIntBE = function(gt, Et, Ct, Wt) {
    if (gt = +gt, Et = Et >>> 0, !Wt) {
      const $r = Math.pow(2, 8 * Ct - 1);
      jt(this, gt, Et, Ct, $r - 1, -$r);
    }
    let zt = Ct - 1, Vt = 1, yr = 0;
    for (this[Et + zt] = gt & 255; --zt >= 0 && (Vt *= 256); )
      gt < 0 && yr === 0 && this[Et + zt + 1] !== 0 && (yr = 1), this[Et + zt] = (gt / Vt >> 0) - yr & 255;
    return Et + Ct;
  }, V.prototype.writeInt8 = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 1, 127, -128), gt < 0 && (gt = 255 + gt + 1), this[Et] = gt & 255, Et + 1;
  }, V.prototype.writeInt16LE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 2, 32767, -32768), this[Et] = gt & 255, this[Et + 1] = gt >>> 8, Et + 2;
  }, V.prototype.writeInt16BE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 2, 32767, -32768), this[Et] = gt >>> 8, this[Et + 1] = gt & 255, Et + 2;
  }, V.prototype.writeInt32LE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 4, 2147483647, -2147483648), this[Et] = gt & 255, this[Et + 1] = gt >>> 8, this[Et + 2] = gt >>> 16, this[Et + 3] = gt >>> 24, Et + 4;
  }, V.prototype.writeInt32BE = function(gt, Et, Ct) {
    return gt = +gt, Et = Et >>> 0, Ct || jt(this, gt, Et, 4, 2147483647, -2147483648), gt < 0 && (gt = 4294967295 + gt + 1), this[Et] = gt >>> 24, this[Et + 1] = gt >>> 16, this[Et + 2] = gt >>> 8, this[Et + 3] = gt & 255, Et + 4;
  }, V.prototype.writeBigInt64LE = Mr(function(gt, Et = 0) {
    return Ot(this, gt, Et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), V.prototype.writeBigInt64BE = Mr(function(gt, Et = 0) {
    return Tt(this, gt, Et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Rt(It, gt, Et, Ct, Wt, zt) {
    if (Et + Ct > It.length) throw new RangeError("Index out of range");
    if (Et < 0) throw new RangeError("Index out of range");
  }
  function Ut(It, gt, Et, Ct, Wt) {
    return gt = +gt, Et = Et >>> 0, Wt || Rt(It, gt, Et, 4), L.write(It, gt, Et, Ct, 23, 4), Et + 4;
  }
  V.prototype.writeFloatLE = function(gt, Et, Ct) {
    return Ut(this, gt, Et, !0, Ct);
  }, V.prototype.writeFloatBE = function(gt, Et, Ct) {
    return Ut(this, gt, Et, !1, Ct);
  };
  function Gt(It, gt, Et, Ct, Wt) {
    return gt = +gt, Et = Et >>> 0, Wt || Rt(It, gt, Et, 8), L.write(It, gt, Et, Ct, 52, 8), Et + 8;
  }
  V.prototype.writeDoubleLE = function(gt, Et, Ct) {
    return Gt(this, gt, Et, !0, Ct);
  }, V.prototype.writeDoubleBE = function(gt, Et, Ct) {
    return Gt(this, gt, Et, !1, Ct);
  }, V.prototype.copy = function(gt, Et, Ct, Wt) {
    if (!V.isBuffer(gt)) throw new TypeError("argument should be a Buffer");
    if (Ct || (Ct = 0), !Wt && Wt !== 0 && (Wt = this.length), Et >= gt.length && (Et = gt.length), Et || (Et = 0), Wt > 0 && Wt < Ct && (Wt = Ct), Wt === Ct || gt.length === 0 || this.length === 0) return 0;
    if (Et < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ct < 0 || Ct >= this.length) throw new RangeError("Index out of range");
    if (Wt < 0) throw new RangeError("sourceEnd out of bounds");
    Wt > this.length && (Wt = this.length), gt.length - Et < Wt - Ct && (Wt = gt.length - Et + Ct);
    const zt = Wt - Ct;
    return this === gt && typeof W.prototype.copyWithin == "function" ? this.copyWithin(Et, Ct, Wt) : W.prototype.set.call(
      gt,
      this.subarray(Ct, Wt),
      Et
    ), zt;
  }, V.prototype.fill = function(gt, Et, Ct, Wt) {
    if (typeof gt == "string") {
      if (typeof Et == "string" ? (Wt = Et, Et = 0, Ct = this.length) : typeof Ct == "string" && (Wt = Ct, Ct = this.length), Wt !== void 0 && typeof Wt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Wt == "string" && !V.isEncoding(Wt))
        throw new TypeError("Unknown encoding: " + Wt);
      if (gt.length === 1) {
        const Vt = gt.charCodeAt(0);
        (Wt === "utf8" && Vt < 128 || Wt === "latin1") && (gt = Vt);
      }
    } else typeof gt == "number" ? gt = gt & 255 : typeof gt == "boolean" && (gt = Number(gt));
    if (Et < 0 || this.length < Et || this.length < Ct)
      throw new RangeError("Out of range index");
    if (Ct <= Et)
      return this;
    Et = Et >>> 0, Ct = Ct === void 0 ? this.length : Ct >>> 0, gt || (gt = 0);
    let zt;
    if (typeof gt == "number")
      for (zt = Et; zt < Ct; ++zt)
        this[zt] = gt;
    else {
      const Vt = V.isBuffer(gt) ? gt : V.from(gt, Wt), yr = Vt.length;
      if (yr === 0)
        throw new TypeError('The value "' + gt + '" is invalid for argument "value"');
      for (zt = 0; zt < Ct - Et; ++zt)
        this[zt + Et] = Vt[zt % yr];
    }
    return this;
  };
  const Mt = {};
  function Pt(It, gt, Et) {
    Mt[It] = class extends Et {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: gt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${It}]`, this.stack, delete this.name;
      }
      get code() {
        return It;
      }
      set code(Wt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Wt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${It}]: ${this.message}`;
      }
    };
  }
  Pt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(It) {
      return It ? `${It} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Pt(
    "ERR_INVALID_ARG_TYPE",
    function(It, gt) {
      return `The "${It}" argument must be of type number. Received type ${typeof gt}`;
    },
    TypeError
  ), Pt(
    "ERR_OUT_OF_RANGE",
    function(It, gt, Et) {
      let Ct = `The value of "${It}" is out of range.`, Wt = Et;
      return Number.isInteger(Et) && Math.abs(Et) > 2 ** 32 ? Wt = Kt(String(Et)) : typeof Et == "bigint" && (Wt = String(Et), (Et > BigInt(2) ** BigInt(32) || Et < -(BigInt(2) ** BigInt(32))) && (Wt = Kt(Wt)), Wt += "n"), Ct += ` It must be ${gt}. Received ${Wt}`, Ct;
    },
    RangeError
  );
  function Kt(It) {
    let gt = "", Et = It.length;
    const Ct = It[0] === "-" ? 1 : 0;
    for (; Et >= Ct + 4; Et -= 3)
      gt = `_${It.slice(Et - 3, Et)}${gt}`;
    return `${It.slice(0, Et)}${gt}`;
  }
  function Zt(It, gt, Et) {
    ar(gt, "offset"), (It[gt] === void 0 || It[gt + Et] === void 0) && ur(gt, It.length - (Et + 1));
  }
  function rr(It, gt, Et, Ct, Wt, zt) {
    if (It > Et || It < gt) {
      const Vt = typeof gt == "bigint" ? "n" : "";
      let yr;
      throw gt === 0 || gt === BigInt(0) ? yr = `>= 0${Vt} and < 2${Vt} ** ${(zt + 1) * 8}${Vt}` : yr = `>= -(2${Vt} ** ${(zt + 1) * 8 - 1}${Vt}) and < 2 ** ${(zt + 1) * 8 - 1}${Vt}`, new Mt.ERR_OUT_OF_RANGE("value", yr, It);
    }
    Zt(Ct, Wt, zt);
  }
  function ar(It, gt) {
    if (typeof It != "number")
      throw new Mt.ERR_INVALID_ARG_TYPE(gt, "number", It);
  }
  function ur(It, gt, Et) {
    throw Math.floor(It) !== It ? (ar(It, Et), new Mt.ERR_OUT_OF_RANGE("offset", "an integer", It)) : gt < 0 ? new Mt.ERR_BUFFER_OUT_OF_BOUNDS() : new Mt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${gt}`,
      It
    );
  }
  const hr = /[^+/0-9A-Za-z-_]/g;
  function Yt(It) {
    if (It = It.split("=")[0], It = It.trim().replace(hr, ""), It.length < 2) return "";
    for (; It.length % 4 !== 0; )
      It = It + "=";
    return It;
  }
  function Ir(It, gt) {
    gt = gt || 1 / 0;
    let Et;
    const Ct = It.length;
    let Wt = null;
    const zt = [];
    for (let Vt = 0; Vt < Ct; ++Vt) {
      if (Et = It.charCodeAt(Vt), Et > 55295 && Et < 57344) {
        if (!Wt) {
          if (Et > 56319) {
            (gt -= 3) > -1 && zt.push(239, 191, 189);
            continue;
          } else if (Vt + 1 === Ct) {
            (gt -= 3) > -1 && zt.push(239, 191, 189);
            continue;
          }
          Wt = Et;
          continue;
        }
        if (Et < 56320) {
          (gt -= 3) > -1 && zt.push(239, 191, 189), Wt = Et;
          continue;
        }
        Et = (Wt - 55296 << 10 | Et - 56320) + 65536;
      } else Wt && (gt -= 3) > -1 && zt.push(239, 191, 189);
      if (Wt = null, Et < 128) {
        if ((gt -= 1) < 0) break;
        zt.push(Et);
      } else if (Et < 2048) {
        if ((gt -= 2) < 0) break;
        zt.push(
          Et >> 6 | 192,
          Et & 63 | 128
        );
      } else if (Et < 65536) {
        if ((gt -= 3) < 0) break;
        zt.push(
          Et >> 12 | 224,
          Et >> 6 & 63 | 128,
          Et & 63 | 128
        );
      } else if (Et < 1114112) {
        if ((gt -= 4) < 0) break;
        zt.push(
          Et >> 18 | 240,
          Et >> 12 & 63 | 128,
          Et >> 6 & 63 | 128,
          Et & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return zt;
  }
  function lr(It) {
    const gt = [];
    for (let Et = 0; Et < It.length; ++Et)
      gt.push(It.charCodeAt(Et) & 255);
    return gt;
  }
  function Ar(It, gt) {
    let Et, Ct, Wt;
    const zt = [];
    for (let Vt = 0; Vt < It.length && !((gt -= 2) < 0); ++Vt)
      Et = It.charCodeAt(Vt), Ct = Et >> 8, Wt = Et % 256, zt.push(Wt), zt.push(Ct);
    return zt;
  }
  function Br(It) {
    return B.toByteArray(Yt(It));
  }
  function dr(It, gt, Et, Ct) {
    let Wt;
    for (Wt = 0; Wt < Ct && !(Wt + Et >= gt.length || Wt >= It.length); ++Wt)
      gt[Wt + Et] = It[Wt];
    return Wt;
  }
  function Er(It, gt) {
    return It instanceof gt || It != null && It.constructor != null && It.constructor.name != null && It.constructor.name === gt.name;
  }
  function Pr(It) {
    return It !== It;
  }
  const br = function() {
    const It = "0123456789abcdef", gt = new Array(256);
    for (let Et = 0; Et < 16; ++Et) {
      const Ct = Et * 16;
      for (let Wt = 0; Wt < 16; ++Wt)
        gt[Ct + Wt] = It[Et] + It[Wt];
    }
    return gt;
  }();
  function Mr(It) {
    return typeof BigInt > "u" ? Or : It;
  }
  function Or() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(A, B) {
  var L = require$$0$1, K = L.Buffer;
  function re(J, ne) {
    for (var ie in J)
      ne[ie] = J[ie];
  }
  K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (re(L, B), B.Buffer = W);
  function W(J, ne, ie) {
    return K(J, ne, ie);
  }
  W.prototype = Object.create(K.prototype), re(K, W), W.from = function(J, ne, ie) {
    if (typeof J == "number")
      throw new TypeError("Argument must not be a number");
    return K(J, ne, ie);
  }, W.alloc = function(J, ne, ie) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    var oe = K(J);
    return ne !== void 0 ? typeof ie == "string" ? oe.fill(ne, ie) : oe.fill(ne) : oe.fill(0), oe;
  }, W.allocUnsafe = function(J) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    return K(J);
  }, W.allocUnsafeSlow = function(J) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    return L.SlowBuffer(J);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var A = 65536, B = 4294967295;
  function L() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var K = safeBufferExports.Buffer, re = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  re && re.getRandomValues ? browser$b.exports = W : browser$b.exports = L;
  function W(J, ne) {
    if (J > B) throw new RangeError("requested too many random bytes");
    var ie = K.allocUnsafe(J);
    if (J > 0)
      if (J > A)
        for (var oe = 0; oe < J; oe += A)
          re.getRandomValues(ie.slice(oe, oe + A));
      else
        re.getRandomValues(ie);
    return typeof ne == "function" ? process$1.nextTick(function() {
      ne(null, ie);
    }) : ie;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(B, L) {
    L && (B.super_ = L, B.prototype = Object.create(L.prototype, {
      constructor: {
        value: B,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(B, L) {
    if (L) {
      B.super_ = L;
      var K = function() {
      };
      K.prototype = L.prototype, B.prototype = new K(), B.prototype.constructor = B;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var A = typeof Reflect == "object" ? Reflect : null, B = A && typeof A.apply == "function" ? A.apply : function(Bt, At, Nt) {
    return Function.prototype.apply.call(Bt, At, Nt);
  }, L;
  A && typeof A.ownKeys == "function" ? L = A.ownKeys : Object.getOwnPropertySymbols ? L = function(Bt) {
    return Object.getOwnPropertyNames(Bt).concat(Object.getOwnPropertySymbols(Bt));
  } : L = function(Bt) {
    return Object.getOwnPropertyNames(Bt);
  };
  function K(vt) {
    console && console.warn && console.warn(vt);
  }
  var re = Number.isNaN || function(Bt) {
    return Bt !== Bt;
  };
  function W() {
    W.init.call(this);
  }
  events.exports = W, events.exports.once = ht, W.EventEmitter = W, W.prototype._events = void 0, W.prototype._eventsCount = 0, W.prototype._maxListeners = void 0;
  var J = 10;
  function ne(vt) {
    if (typeof vt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof vt);
  }
  Object.defineProperty(W, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return J;
    },
    set: function(vt) {
      if (typeof vt != "number" || vt < 0 || re(vt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + vt + ".");
      J = vt;
    }
  }), W.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, W.prototype.setMaxListeners = function(Bt) {
    if (typeof Bt != "number" || Bt < 0 || re(Bt))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Bt + ".");
    return this._maxListeners = Bt, this;
  };
  function ie(vt) {
    return vt._maxListeners === void 0 ? W.defaultMaxListeners : vt._maxListeners;
  }
  W.prototype.getMaxListeners = function() {
    return ie(this);
  }, W.prototype.emit = function(Bt) {
    for (var At = [], Nt = 1; Nt < arguments.length; Nt++) At.push(arguments[Nt]);
    var $t = Bt === "error", mt = this._events;
    if (mt !== void 0)
      $t = $t && mt.error === void 0;
    else if (!$t)
      return !1;
    if ($t) {
      var xt;
      if (At.length > 0 && (xt = At[0]), xt instanceof Error)
        throw xt;
      var wt = new Error("Unhandled error." + (xt ? " (" + xt.message + ")" : ""));
      throw wt.context = xt, wt;
    }
    var Oe = mt[Bt];
    if (Oe === void 0)
      return !1;
    if (typeof Oe == "function")
      B(Oe, this, At);
    else
      for (var rt = Oe.length, pe = it(Oe, rt), Nt = 0; Nt < rt; ++Nt)
        B(pe[Nt], this, At);
    return !0;
  };
  function oe(vt, Bt, At, Nt) {
    var $t, mt, xt;
    if (ne(At), mt = vt._events, mt === void 0 ? (mt = vt._events = /* @__PURE__ */ Object.create(null), vt._eventsCount = 0) : (mt.newListener !== void 0 && (vt.emit(
      "newListener",
      Bt,
      At.listener ? At.listener : At
    ), mt = vt._events), xt = mt[Bt]), xt === void 0)
      xt = mt[Bt] = At, ++vt._eventsCount;
    else if (typeof xt == "function" ? xt = mt[Bt] = Nt ? [At, xt] : [xt, At] : Nt ? xt.unshift(At) : xt.push(At), $t = ie(vt), $t > 0 && xt.length > $t && !xt.warned) {
      xt.warned = !0;
      var wt = new Error("Possible EventEmitter memory leak detected. " + xt.length + " " + String(Bt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      wt.name = "MaxListenersExceededWarning", wt.emitter = vt, wt.type = Bt, wt.count = xt.length, K(wt);
    }
    return vt;
  }
  W.prototype.addListener = function(Bt, At) {
    return oe(this, Bt, At, !1);
  }, W.prototype.on = W.prototype.addListener, W.prototype.prependListener = function(Bt, At) {
    return oe(this, Bt, At, !0);
  };
  function V() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function ce(vt, Bt, At) {
    var Nt = { fired: !1, wrapFn: void 0, target: vt, type: Bt, listener: At }, $t = V.bind(Nt);
    return $t.listener = At, Nt.wrapFn = $t, $t;
  }
  W.prototype.once = function(Bt, At) {
    return ne(At), this.on(Bt, ce(this, Bt, At)), this;
  }, W.prototype.prependOnceListener = function(Bt, At) {
    return ne(At), this.prependListener(Bt, ce(this, Bt, At)), this;
  }, W.prototype.removeListener = function(Bt, At) {
    var Nt, $t, mt, xt, wt;
    if (ne(At), $t = this._events, $t === void 0)
      return this;
    if (Nt = $t[Bt], Nt === void 0)
      return this;
    if (Nt === At || Nt.listener === At)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete $t[Bt], $t.removeListener && this.emit("removeListener", Bt, Nt.listener || At));
    else if (typeof Nt != "function") {
      for (mt = -1, xt = Nt.length - 1; xt >= 0; xt--)
        if (Nt[xt] === At || Nt[xt].listener === At) {
          wt = Nt[xt].listener, mt = xt;
          break;
        }
      if (mt < 0)
        return this;
      mt === 0 ? Nt.shift() : at(Nt, mt), Nt.length === 1 && ($t[Bt] = Nt[0]), $t.removeListener !== void 0 && this.emit("removeListener", Bt, wt || At);
    }
    return this;
  }, W.prototype.off = W.prototype.removeListener, W.prototype.removeAllListeners = function(Bt) {
    var At, Nt, $t;
    if (Nt = this._events, Nt === void 0)
      return this;
    if (Nt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Nt[Bt] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Nt[Bt]), this;
    if (arguments.length === 0) {
      var mt = Object.keys(Nt), xt;
      for ($t = 0; $t < mt.length; ++$t)
        xt = mt[$t], xt !== "removeListener" && this.removeAllListeners(xt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (At = Nt[Bt], typeof At == "function")
      this.removeListener(Bt, At);
    else if (At !== void 0)
      for ($t = At.length - 1; $t >= 0; $t--)
        this.removeListener(Bt, At[$t]);
    return this;
  };
  function ke(vt, Bt, At) {
    var Nt = vt._events;
    if (Nt === void 0)
      return [];
    var $t = Nt[Bt];
    return $t === void 0 ? [] : typeof $t == "function" ? At ? [$t.listener || $t] : [$t] : At ? lt($t) : it($t, $t.length);
  }
  W.prototype.listeners = function(Bt) {
    return ke(this, Bt, !0);
  }, W.prototype.rawListeners = function(Bt) {
    return ke(this, Bt, !1);
  }, W.listenerCount = function(vt, Bt) {
    return typeof vt.listenerCount == "function" ? vt.listenerCount(Bt) : Ce.call(vt, Bt);
  }, W.prototype.listenerCount = Ce;
  function Ce(vt) {
    var Bt = this._events;
    if (Bt !== void 0) {
      var At = Bt[vt];
      if (typeof At == "function")
        return 1;
      if (At !== void 0)
        return At.length;
    }
    return 0;
  }
  W.prototype.eventNames = function() {
    return this._eventsCount > 0 ? L(this._events) : [];
  };
  function it(vt, Bt) {
    for (var At = new Array(Bt), Nt = 0; Nt < Bt; ++Nt)
      At[Nt] = vt[Nt];
    return At;
  }
  function at(vt, Bt) {
    for (; Bt + 1 < vt.length; Bt++)
      vt[Bt] = vt[Bt + 1];
    vt.pop();
  }
  function lt(vt) {
    for (var Bt = new Array(vt.length), At = 0; At < Bt.length; ++At)
      Bt[At] = vt[At].listener || vt[At];
    return Bt;
  }
  function ht(vt, Bt) {
    return new Promise(function(At, Nt) {
      function $t(xt) {
        vt.removeListener(Bt, mt), Nt(xt);
      }
      function mt() {
        typeof vt.removeListener == "function" && vt.removeListener("error", $t), At([].slice.call(arguments));
      }
      bt(vt, Bt, mt, { once: !0 }), Bt !== "error" && dt(vt, $t, { once: !0 });
    });
  }
  function dt(vt, Bt, At) {
    typeof vt.on == "function" && bt(vt, "error", Bt, At);
  }
  function bt(vt, Bt, At, Nt) {
    if (typeof vt.on == "function")
      Nt.once ? vt.once(Bt, At) : vt.on(Bt, At);
    else if (typeof vt.addEventListener == "function")
      vt.addEventListener(Bt, function $t(mt) {
        Nt.once && vt.removeEventListener(Bt, $t), At(mt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof vt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var B = {}, L = Symbol("test"), K = Object(L);
    if (typeof L == "string" || Object.prototype.toString.call(L) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]")
      return !1;
    var re = 42;
    B[L] = re;
    for (L in B)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0)
      return !1;
    var W = Object.getOwnPropertySymbols(B);
    if (W.length !== 1 || W[0] !== L || !Object.prototype.propertyIsEnumerable.call(B, L))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var J = Object.getOwnPropertyDescriptor(B, L);
      if (J.value !== re || J.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var A = requireShams$1();
  return shams = function() {
    return A() && !!Symbol.toStringTag;
  }, shams;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var A = typeof Symbol < "u" && Symbol, B = requireShams$1();
  return hasSymbols = function() {
    return typeof A != "function" || typeof Symbol != "function" || typeof A("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : B();
  }, hasSymbols;
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var A = {
    __proto__: null,
    foo: {}
  }, B = Object;
  return hasProto = function() {
    return { __proto__: A }.foo === A.foo && !(A instanceof B);
  }, hasProto;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var A = "Function.prototype.bind called on incompatible ", B = Object.prototype.toString, L = Math.max, K = "[object Function]", re = function(ie, oe) {
    for (var V = [], ce = 0; ce < ie.length; ce += 1)
      V[ce] = ie[ce];
    for (var ke = 0; ke < oe.length; ke += 1)
      V[ke + ie.length] = oe[ke];
    return V;
  }, W = function(ie, oe) {
    for (var V = [], ce = oe, ke = 0; ce < ie.length; ce += 1, ke += 1)
      V[ke] = ie[ce];
    return V;
  }, J = function(ne, ie) {
    for (var oe = "", V = 0; V < ne.length; V += 1)
      oe += ne[V], V + 1 < ne.length && (oe += ie);
    return oe;
  };
  return implementation = function(ie) {
    var oe = this;
    if (typeof oe != "function" || B.apply(oe) !== K)
      throw new TypeError(A + oe);
    for (var V = W(arguments, 1), ce, ke = function() {
      if (this instanceof ce) {
        var ht = oe.apply(
          this,
          re(V, arguments)
        );
        return Object(ht) === ht ? ht : this;
      }
      return oe.apply(
        ie,
        re(V, arguments)
      );
    }, Ce = L(0, oe.length - V.length), it = [], at = 0; at < Ce; at++)
      it[at] = "$" + at;
    if (ce = Function("binder", "return function (" + J(it, ",") + "){ return binder.apply(this,arguments); }")(ke), oe.prototype) {
      var lt = function() {
      };
      lt.prototype = oe.prototype, ce.prototype = new lt(), lt.prototype = null;
    }
    return ce;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var A = requireImplementation();
  return functionBind = Function.prototype.bind || A, functionBind;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var A = Function.prototype.call, B = Object.prototype.hasOwnProperty, L = requireFunctionBind();
  return hasown = L.call(A, B), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var A, B = requireEsErrors(), L = require_eval(), K = requireRange(), re = requireRef(), W = requireSyntax(), J = requireType(), ne = requireUri(), ie = Function, oe = function(st) {
    try {
      return ie('"use strict"; return (' + st + ").constructor;")();
    } catch {
    }
  }, V = Object.getOwnPropertyDescriptor;
  if (V)
    try {
      V({}, "");
    } catch {
      V = null;
    }
  var ce = function() {
    throw new J();
  }, ke = V ? function() {
    try {
      return arguments.callee, ce;
    } catch {
      try {
        return V(arguments, "callee").get;
      } catch {
        return ce;
      }
    }
  }() : ce, Ce = requireHasSymbols()(), it = requireHasProto()(), at = Object.getPrototypeOf || (it ? function(st) {
    return st.__proto__;
  } : null), lt = {}, ht = typeof Uint8Array > "u" || !at ? A : at(Uint8Array), dt = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? A : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? A : ArrayBuffer,
    "%ArrayIteratorPrototype%": Ce && at ? at([][Symbol.iterator]()) : A,
    "%AsyncFromSyncIteratorPrototype%": A,
    "%AsyncFunction%": lt,
    "%AsyncGenerator%": lt,
    "%AsyncGeneratorFunction%": lt,
    "%AsyncIteratorPrototype%": lt,
    "%Atomics%": typeof Atomics > "u" ? A : Atomics,
    "%BigInt%": typeof BigInt > "u" ? A : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? A : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? A : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? A : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": B,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": L,
    "%Float32Array%": typeof Float32Array > "u" ? A : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? A : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? A : FinalizationRegistry,
    "%Function%": ie,
    "%GeneratorFunction%": lt,
    "%Int8Array%": typeof Int8Array > "u" ? A : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? A : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? A : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Ce && at ? at(at([][Symbol.iterator]())) : A,
    "%JSON%": typeof JSON == "object" ? JSON : A,
    "%Map%": typeof Map > "u" ? A : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Ce || !at ? A : at((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? A : Promise,
    "%Proxy%": typeof Proxy > "u" ? A : Proxy,
    "%RangeError%": K,
    "%ReferenceError%": re,
    "%Reflect%": typeof Reflect > "u" ? A : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? A : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Ce || !at ? A : at((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? A : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Ce && at ? at(""[Symbol.iterator]()) : A,
    "%Symbol%": Ce ? Symbol : A,
    "%SyntaxError%": W,
    "%ThrowTypeError%": ke,
    "%TypedArray%": ht,
    "%TypeError%": J,
    "%Uint8Array%": typeof Uint8Array > "u" ? A : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? A : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? A : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? A : Uint32Array,
    "%URIError%": ne,
    "%WeakMap%": typeof WeakMap > "u" ? A : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? A : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? A : WeakSet
  };
  if (at)
    try {
      null.error;
    } catch (st) {
      var bt = at(at(st));
      dt["%Error.prototype%"] = bt;
    }
  var vt = function st(ut) {
    var pt;
    if (ut === "%AsyncFunction%")
      pt = oe("async function () {}");
    else if (ut === "%GeneratorFunction%")
      pt = oe("function* () {}");
    else if (ut === "%AsyncGeneratorFunction%")
      pt = oe("async function* () {}");
    else if (ut === "%AsyncGenerator%") {
      var ft = st("%AsyncGeneratorFunction%");
      ft && (pt = ft.prototype);
    } else if (ut === "%AsyncIteratorPrototype%") {
      var yt = st("%AsyncGenerator%");
      yt && at && (pt = at(yt.prototype));
    }
    return dt[ut] = pt, pt;
  }, Bt = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, At = requireFunctionBind(), Nt = requireHasown(), $t = At.call(Function.call, Array.prototype.concat), mt = At.call(Function.apply, Array.prototype.splice), xt = At.call(Function.call, String.prototype.replace), wt = At.call(Function.call, String.prototype.slice), Oe = At.call(Function.call, RegExp.prototype.exec), rt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, pe = /\\(\\)?/g, nt = function(ut) {
    var pt = wt(ut, 0, 1), ft = wt(ut, -1);
    if (pt === "%" && ft !== "%")
      throw new W("invalid intrinsic syntax, expected closing `%`");
    if (ft === "%" && pt !== "%")
      throw new W("invalid intrinsic syntax, expected opening `%`");
    var yt = [];
    return xt(ut, rt, function(ct, St, qt, jt) {
      yt[yt.length] = qt ? xt(jt, pe, "$1") : St || ct;
    }), yt;
  }, ot = function(ut, pt) {
    var ft = ut, yt;
    if (Nt(Bt, ft) && (yt = Bt[ft], ft = "%" + yt[0] + "%"), Nt(dt, ft)) {
      var ct = dt[ft];
      if (ct === lt && (ct = vt(ft)), typeof ct > "u" && !pt)
        throw new J("intrinsic " + ut + " exists, but is not available. Please file an issue!");
      return {
        alias: yt,
        name: ft,
        value: ct
      };
    }
    throw new W("intrinsic " + ut + " does not exist!");
  };
  return getIntrinsic = function(ut, pt) {
    if (typeof ut != "string" || ut.length === 0)
      throw new J("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof pt != "boolean")
      throw new J('"allowMissing" argument must be a boolean');
    if (Oe(/^%?[^%]*%?$/, ut) === null)
      throw new W("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ft = nt(ut), yt = ft.length > 0 ? ft[0] : "", ct = ot("%" + yt + "%", pt), St = ct.name, qt = ct.value, jt = !1, Ot = ct.alias;
    Ot && (yt = Ot[0], mt(ft, $t([0, 1], Ot)));
    for (var Tt = 1, Rt = !0; Tt < ft.length; Tt += 1) {
      var Ut = ft[Tt], Gt = wt(Ut, 0, 1), Mt = wt(Ut, -1);
      if ((Gt === '"' || Gt === "'" || Gt === "`" || Mt === '"' || Mt === "'" || Mt === "`") && Gt !== Mt)
        throw new W("property names with quotes must have matching quotes");
      if ((Ut === "constructor" || !Rt) && (jt = !0), yt += "." + Ut, St = "%" + yt + "%", Nt(dt, St))
        qt = dt[St];
      else if (qt != null) {
        if (!(Ut in qt)) {
          if (!pt)
            throw new J("base intrinsic for " + ut + " exists, but the property is not available.");
          return;
        }
        if (V && Tt + 1 >= ft.length) {
          var Pt = V(qt, Ut);
          Rt = !!Pt, Rt && "get" in Pt && !("originalValue" in Pt.get) ? qt = Pt.get : qt = qt[Ut];
        } else
          Rt = Nt(qt, Ut), qt = qt[Ut];
        Rt && !jt && (dt[St] = qt);
      }
    }
    return qt;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var A = requireGetIntrinsic(), B = A("%Object.defineProperty%", !0) || !1;
  if (B)
    try {
      B({}, "a", { value: 1 });
    } catch {
      B = !1;
    }
  return esDefineProperty = B, esDefineProperty;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var A = requireGetIntrinsic(), B = A("%Object.getOwnPropertyDescriptor%", !0);
  if (B)
    try {
      B([], "length");
    } catch {
      B = null;
    }
  return gopd = B, gopd;
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var A = requireEsDefineProperty(), B = requireSyntax(), L = requireType(), K = requireGopd();
  return defineDataProperty = function(W, J, ne) {
    if (!W || typeof W != "object" && typeof W != "function")
      throw new L("`obj` must be an object or a function`");
    if (typeof J != "string" && typeof J != "symbol")
      throw new L("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new L("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new L("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new L("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new L("`loose`, if provided, must be a boolean");
    var ie = arguments.length > 3 ? arguments[3] : null, oe = arguments.length > 4 ? arguments[4] : null, V = arguments.length > 5 ? arguments[5] : null, ce = arguments.length > 6 ? arguments[6] : !1, ke = !!K && K(W, J);
    if (A)
      A(W, J, {
        configurable: V === null && ke ? ke.configurable : !V,
        enumerable: ie === null && ke ? ke.enumerable : !ie,
        value: ne,
        writable: oe === null && ke ? ke.writable : !oe
      });
    else if (ce || !ie && !oe && !V)
      W[J] = ne;
    else
      throw new B("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var A = requireEsDefineProperty(), B = function() {
    return !!A;
  };
  return B.hasArrayLengthDefineBug = function() {
    if (!A)
      return null;
    try {
      return A([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = B, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var A = requireGetIntrinsic(), B = requireDefineDataProperty(), L = requireHasPropertyDescriptors()(), K = requireGopd(), re = requireType(), W = A("%Math.floor%");
  return setFunctionLength = function(ne, ie) {
    if (typeof ne != "function")
      throw new re("`fn` is not a function");
    if (typeof ie != "number" || ie < 0 || ie > 4294967295 || W(ie) !== ie)
      throw new re("`length` must be a positive 32-bit integer");
    var oe = arguments.length > 2 && !!arguments[2], V = !0, ce = !0;
    if ("length" in ne && K) {
      var ke = K(ne, "length");
      ke && !ke.configurable && (V = !1), ke && !ke.writable && (ce = !1);
    }
    return (V || ce || !oe) && (L ? B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie,
      !0,
      !0
    ) : B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie
    )), ne;
  }, setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(A) {
    var B = requireFunctionBind(), L = requireGetIntrinsic(), K = requireSetFunctionLength(), re = requireType(), W = L("%Function.prototype.apply%"), J = L("%Function.prototype.call%"), ne = L("%Reflect.apply%", !0) || B.call(J, W), ie = requireEsDefineProperty(), oe = L("%Math.max%");
    A.exports = function(ke) {
      if (typeof ke != "function")
        throw new re("a function is required");
      var Ce = ne(B, J, arguments);
      return K(
        Ce,
        1 + oe(0, ke.length - (arguments.length - 1)),
        !0
      );
    };
    var V = function() {
      return ne(B, W, arguments);
    };
    ie ? ie(A.exports, "apply", { value: V }) : A.exports.apply = V;
  }(callBind)), callBind.exports;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var A = requireGetIntrinsic(), B = requireCallBind(), L = B(A("String.prototype.indexOf"));
  return callBound = function(re, W) {
    var J = A(re, !!W);
    return typeof J == "function" && L(re, ".prototype.") > -1 ? B(J) : J;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var A = requireShams()(), B = requireCallBound(), L = B("Object.prototype.toString"), K = function(ne) {
    return A && ne && typeof ne == "object" && Symbol.toStringTag in ne ? !1 : L(ne) === "[object Arguments]";
  }, re = function(ne) {
    return K(ne) ? !0 : ne !== null && typeof ne == "object" && typeof ne.length == "number" && ne.length >= 0 && L(ne) !== "[object Array]" && L(ne.callee) === "[object Function]";
  }, W = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = re, isArguments = W ? K : re, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var A = Object.prototype.toString, B = Function.prototype.toString, L = /^\s*(?:function)?\*/, K = requireShams()(), re = Object.getPrototypeOf, W = function() {
    if (!K)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, J;
  return isGeneratorFunction = function(ie) {
    if (typeof ie != "function")
      return !1;
    if (L.test(B.call(ie)))
      return !0;
    if (!K) {
      var oe = A.call(ie);
      return oe === "[object GeneratorFunction]";
    }
    if (!re)
      return !1;
    if (typeof J > "u") {
      var V = W();
      J = V ? re(V) : !1;
    }
    return re(ie) === J;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var A = Function.prototype.toString, B = typeof Reflect == "object" && Reflect !== null && Reflect.apply, L, K;
  if (typeof B == "function" && typeof Object.defineProperty == "function")
    try {
      L = Object.defineProperty({}, "length", {
        get: function() {
          throw K;
        }
      }), K = {}, B(function() {
        throw 42;
      }, null, L);
    } catch (dt) {
      dt !== K && (B = null);
    }
  else
    B = null;
  var re = /^\s*class\b/, W = function(bt) {
    try {
      var vt = A.call(bt);
      return re.test(vt);
    } catch {
      return !1;
    }
  }, J = function(bt) {
    try {
      return W(bt) ? !1 : (A.call(bt), !0);
    } catch {
      return !1;
    }
  }, ne = Object.prototype.toString, ie = "[object Object]", oe = "[object Function]", V = "[object GeneratorFunction]", ce = "[object HTMLAllCollection]", ke = "[object HTML document.all class]", Ce = "[object HTMLCollection]", it = typeof Symbol == "function" && !!Symbol.toStringTag, at = !(0 in [,]), lt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var ht = document.all;
    ne.call(ht) === ne.call(document.all) && (lt = function(bt) {
      if ((at || !bt) && (typeof bt > "u" || typeof bt == "object"))
        try {
          var vt = ne.call(bt);
          return (vt === ce || vt === ke || vt === Ce || vt === ie) && bt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = B ? function(bt) {
    if (lt(bt))
      return !0;
    if (!bt || typeof bt != "function" && typeof bt != "object")
      return !1;
    try {
      B(bt, null, L);
    } catch (vt) {
      if (vt !== K)
        return !1;
    }
    return !W(bt) && J(bt);
  } : function(bt) {
    if (lt(bt))
      return !0;
    if (!bt || typeof bt != "function" && typeof bt != "object")
      return !1;
    if (it)
      return J(bt);
    if (W(bt))
      return !1;
    var vt = ne.call(bt);
    return vt !== oe && vt !== V && !/^\[object HTML/.test(vt) ? !1 : J(bt);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var A = requireIsCallable(), B = Object.prototype.toString, L = Object.prototype.hasOwnProperty, K = function(ie, oe, V) {
    for (var ce = 0, ke = ie.length; ce < ke; ce++)
      L.call(ie, ce) && (V == null ? oe(ie[ce], ce, ie) : oe.call(V, ie[ce], ce, ie));
  }, re = function(ie, oe, V) {
    for (var ce = 0, ke = ie.length; ce < ke; ce++)
      V == null ? oe(ie.charAt(ce), ce, ie) : oe.call(V, ie.charAt(ce), ce, ie);
  }, W = function(ie, oe, V) {
    for (var ce in ie)
      L.call(ie, ce) && (V == null ? oe(ie[ce], ce, ie) : oe.call(V, ie[ce], ce, ie));
  }, J = function(ie, oe, V) {
    if (!A(oe))
      throw new TypeError("iterator must be a function");
    var ce;
    arguments.length >= 3 && (ce = V), B.call(ie) === "[object Array]" ? K(ie, oe, ce) : typeof ie == "string" ? re(ie, oe, ce) : W(ie, oe, ce);
  };
  return forEach_1 = J, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var A = requirePossibleTypedArrayNames(), B = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], re = 0; re < A.length; re++)
      typeof B[A[re]] == "function" && (K[K.length] = A[re]);
    return K;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var A = requireForEach(), B = requireAvailableTypedArrays(), L = requireCallBind(), K = requireCallBound(), re = requireGopd(), W = K("Object.prototype.toString"), J = requireShams()(), ne = typeof globalThis > "u" ? commonjsGlobal : globalThis, ie = B(), oe = K("String.prototype.slice"), V = Object.getPrototypeOf, ce = K("Array.prototype.indexOf", !0) || function(lt, ht) {
    for (var dt = 0; dt < lt.length; dt += 1)
      if (lt[dt] === ht)
        return dt;
    return -1;
  }, ke = { __proto__: null };
  J && re && V ? A(ie, function(at) {
    var lt = new ne[at]();
    if (Symbol.toStringTag in lt) {
      var ht = V(lt), dt = re(ht, Symbol.toStringTag);
      if (!dt) {
        var bt = V(ht);
        dt = re(bt, Symbol.toStringTag);
      }
      ke["$" + at] = L(dt.get);
    }
  }) : A(ie, function(at) {
    var lt = new ne[at](), ht = lt.slice || lt.set;
    ht && (ke["$" + at] = L(ht));
  });
  var Ce = function(lt) {
    var ht = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(dt, bt) {
        if (!ht)
          try {
            "$" + dt(lt) === bt && (ht = oe(bt, 1));
          } catch {
          }
      }
    ), ht;
  }, it = function(lt) {
    var ht = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(dt, bt) {
        if (!ht)
          try {
            dt(lt), ht = oe(bt, 1);
          } catch {
          }
      }
    ), ht;
  };
  return whichTypedArray = function(lt) {
    if (!lt || typeof lt != "object")
      return !1;
    if (!J) {
      var ht = oe(W(lt), 8, -1);
      return ce(ie, ht) > -1 ? ht : ht !== "Object" ? !1 : it(lt);
    }
    return re ? Ce(lt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var A = requireWhichTypedArray();
  return isTypedArray = function(L) {
    return !!A(L);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(A) {
    var B = requireIsArguments(), L = requireIsGeneratorFunction(), K = requireWhichTypedArray(), re = requireIsTypedArray();
    function W(Yt) {
      return Yt.call.bind(Yt);
    }
    var J = typeof BigInt < "u", ne = typeof Symbol < "u", ie = W(Object.prototype.toString), oe = W(Number.prototype.valueOf), V = W(String.prototype.valueOf), ce = W(Boolean.prototype.valueOf);
    if (J)
      var ke = W(BigInt.prototype.valueOf);
    if (ne)
      var Ce = W(Symbol.prototype.valueOf);
    function it(Yt, Ir) {
      if (typeof Yt != "object")
        return !1;
      try {
        return Ir(Yt), !0;
      } catch {
        return !1;
      }
    }
    A.isArgumentsObject = B, A.isGeneratorFunction = L, A.isTypedArray = re;
    function at(Yt) {
      return typeof Promise < "u" && Yt instanceof Promise || Yt !== null && typeof Yt == "object" && typeof Yt.then == "function" && typeof Yt.catch == "function";
    }
    A.isPromise = at;
    function lt(Yt) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Yt) : re(Yt) || St(Yt);
    }
    A.isArrayBufferView = lt;
    function ht(Yt) {
      return K(Yt) === "Uint8Array";
    }
    A.isUint8Array = ht;
    function dt(Yt) {
      return K(Yt) === "Uint8ClampedArray";
    }
    A.isUint8ClampedArray = dt;
    function bt(Yt) {
      return K(Yt) === "Uint16Array";
    }
    A.isUint16Array = bt;
    function vt(Yt) {
      return K(Yt) === "Uint32Array";
    }
    A.isUint32Array = vt;
    function Bt(Yt) {
      return K(Yt) === "Int8Array";
    }
    A.isInt8Array = Bt;
    function At(Yt) {
      return K(Yt) === "Int16Array";
    }
    A.isInt16Array = At;
    function Nt(Yt) {
      return K(Yt) === "Int32Array";
    }
    A.isInt32Array = Nt;
    function $t(Yt) {
      return K(Yt) === "Float32Array";
    }
    A.isFloat32Array = $t;
    function mt(Yt) {
      return K(Yt) === "Float64Array";
    }
    A.isFloat64Array = mt;
    function xt(Yt) {
      return K(Yt) === "BigInt64Array";
    }
    A.isBigInt64Array = xt;
    function wt(Yt) {
      return K(Yt) === "BigUint64Array";
    }
    A.isBigUint64Array = wt;
    function Oe(Yt) {
      return ie(Yt) === "[object Map]";
    }
    Oe.working = typeof Map < "u" && Oe(/* @__PURE__ */ new Map());
    function rt(Yt) {
      return typeof Map > "u" ? !1 : Oe.working ? Oe(Yt) : Yt instanceof Map;
    }
    A.isMap = rt;
    function pe(Yt) {
      return ie(Yt) === "[object Set]";
    }
    pe.working = typeof Set < "u" && pe(/* @__PURE__ */ new Set());
    function nt(Yt) {
      return typeof Set > "u" ? !1 : pe.working ? pe(Yt) : Yt instanceof Set;
    }
    A.isSet = nt;
    function ot(Yt) {
      return ie(Yt) === "[object WeakMap]";
    }
    ot.working = typeof WeakMap < "u" && ot(/* @__PURE__ */ new WeakMap());
    function st(Yt) {
      return typeof WeakMap > "u" ? !1 : ot.working ? ot(Yt) : Yt instanceof WeakMap;
    }
    A.isWeakMap = st;
    function ut(Yt) {
      return ie(Yt) === "[object WeakSet]";
    }
    ut.working = typeof WeakSet < "u" && ut(/* @__PURE__ */ new WeakSet());
    function pt(Yt) {
      return ut(Yt);
    }
    A.isWeakSet = pt;
    function ft(Yt) {
      return ie(Yt) === "[object ArrayBuffer]";
    }
    ft.working = typeof ArrayBuffer < "u" && ft(new ArrayBuffer());
    function yt(Yt) {
      return typeof ArrayBuffer > "u" ? !1 : ft.working ? ft(Yt) : Yt instanceof ArrayBuffer;
    }
    A.isArrayBuffer = yt;
    function ct(Yt) {
      return ie(Yt) === "[object DataView]";
    }
    ct.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ct(new DataView(new ArrayBuffer(1), 0, 1));
    function St(Yt) {
      return typeof DataView > "u" ? !1 : ct.working ? ct(Yt) : Yt instanceof DataView;
    }
    A.isDataView = St;
    var qt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function jt(Yt) {
      return ie(Yt) === "[object SharedArrayBuffer]";
    }
    function Ot(Yt) {
      return typeof qt > "u" ? !1 : (typeof jt.working > "u" && (jt.working = jt(new qt())), jt.working ? jt(Yt) : Yt instanceof qt);
    }
    A.isSharedArrayBuffer = Ot;
    function Tt(Yt) {
      return ie(Yt) === "[object AsyncFunction]";
    }
    A.isAsyncFunction = Tt;
    function Rt(Yt) {
      return ie(Yt) === "[object Map Iterator]";
    }
    A.isMapIterator = Rt;
    function Ut(Yt) {
      return ie(Yt) === "[object Set Iterator]";
    }
    A.isSetIterator = Ut;
    function Gt(Yt) {
      return ie(Yt) === "[object Generator]";
    }
    A.isGeneratorObject = Gt;
    function Mt(Yt) {
      return ie(Yt) === "[object WebAssembly.Module]";
    }
    A.isWebAssemblyCompiledModule = Mt;
    function Pt(Yt) {
      return it(Yt, oe);
    }
    A.isNumberObject = Pt;
    function Kt(Yt) {
      return it(Yt, V);
    }
    A.isStringObject = Kt;
    function Zt(Yt) {
      return it(Yt, ce);
    }
    A.isBooleanObject = Zt;
    function rr(Yt) {
      return J && it(Yt, ke);
    }
    A.isBigIntObject = rr;
    function ar(Yt) {
      return ne && it(Yt, Ce);
    }
    A.isSymbolObject = ar;
    function ur(Yt) {
      return Pt(Yt) || Kt(Yt) || Zt(Yt) || rr(Yt) || ar(Yt);
    }
    A.isBoxedPrimitive = ur;
    function hr(Yt) {
      return typeof Uint8Array < "u" && (yt(Yt) || Ot(Yt));
    }
    A.isAnyArrayBuffer = hr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Yt) {
      Object.defineProperty(A, Yt, {
        enumerable: !1,
        value: function() {
          throw new Error(Yt + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(B) {
    return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(A) {
    var B = Object.getOwnPropertyDescriptors || function(St) {
      for (var qt = Object.keys(St), jt = {}, Ot = 0; Ot < qt.length; Ot++)
        jt[qt[Ot]] = Object.getOwnPropertyDescriptor(St, qt[Ot]);
      return jt;
    }, L = /%[sdj%]/g;
    A.format = function(ct) {
      if (!Bt(ct)) {
        for (var St = [], qt = 0; qt < arguments.length; qt++)
          St.push(J(arguments[qt]));
        return St.join(" ");
      }
      for (var qt = 1, jt = arguments, Ot = jt.length, Tt = String(ct).replace(L, function(Ut) {
        if (Ut === "%%") return "%";
        if (qt >= Ot) return Ut;
        switch (Ut) {
          case "%s":
            return String(jt[qt++]);
          case "%d":
            return Number(jt[qt++]);
          case "%j":
            try {
              return JSON.stringify(jt[qt++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ut;
        }
      }), Rt = jt[qt]; qt < Ot; Rt = jt[++qt])
        dt(Rt) || !mt(Rt) ? Tt += " " + Rt : Tt += " " + J(Rt);
      return Tt;
    }, A.deprecate = function(ct, St) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return ct;
      if (typeof process$1 > "u")
        return function() {
          return A.deprecate(ct, St).apply(this, arguments);
        };
      var qt = !1;
      function jt() {
        if (!qt) {
          if (process$1.throwDeprecation)
            throw new Error(St);
          process$1.traceDeprecation ? console.trace(St) : console.error(St), qt = !0;
        }
        return ct.apply(this, arguments);
      }
      return jt;
    };
    var K = {}, re = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var W = process$1.env.NODE_DEBUG;
      W = W.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), re = new RegExp("^" + W + "$", "i");
    }
    A.debuglog = function(ct) {
      if (ct = ct.toUpperCase(), !K[ct])
        if (re.test(ct)) {
          var St = process$1.pid;
          K[ct] = function() {
            var qt = A.format.apply(A, arguments);
            console.error("%s %d: %s", ct, St, qt);
          };
        } else
          K[ct] = function() {
          };
      return K[ct];
    };
    function J(ct, St) {
      var qt = {
        seen: [],
        stylize: ie
      };
      return arguments.length >= 3 && (qt.depth = arguments[2]), arguments.length >= 4 && (qt.colors = arguments[3]), ht(St) ? qt.showHidden = St : St && A._extend(qt, St), Nt(qt.showHidden) && (qt.showHidden = !1), Nt(qt.depth) && (qt.depth = 2), Nt(qt.colors) && (qt.colors = !1), Nt(qt.customInspect) && (qt.customInspect = !0), qt.colors && (qt.stylize = ne), V(qt, ct, qt.depth);
    }
    A.inspect = J, J.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, J.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function ne(ct, St) {
      var qt = J.styles[St];
      return qt ? "\x1B[" + J.colors[qt][0] + "m" + ct + "\x1B[" + J.colors[qt][1] + "m" : ct;
    }
    function ie(ct, St) {
      return ct;
    }
    function oe(ct) {
      var St = {};
      return ct.forEach(function(qt, jt) {
        St[qt] = !0;
      }), St;
    }
    function V(ct, St, qt) {
      if (ct.customInspect && St && Oe(St.inspect) && // Filter out the util module, it's inspect function is special
      St.inspect !== A.inspect && // Also filter out any prototype objects using the circular check.
      !(St.constructor && St.constructor.prototype === St)) {
        var jt = St.inspect(qt, ct);
        return Bt(jt) || (jt = V(ct, jt, qt)), jt;
      }
      var Ot = ce(ct, St);
      if (Ot)
        return Ot;
      var Tt = Object.keys(St), Rt = oe(Tt);
      if (ct.showHidden && (Tt = Object.getOwnPropertyNames(St)), wt(St) && (Tt.indexOf("message") >= 0 || Tt.indexOf("description") >= 0))
        return ke(St);
      if (Tt.length === 0) {
        if (Oe(St)) {
          var Ut = St.name ? ": " + St.name : "";
          return ct.stylize("[Function" + Ut + "]", "special");
        }
        if ($t(St))
          return ct.stylize(RegExp.prototype.toString.call(St), "regexp");
        if (xt(St))
          return ct.stylize(Date.prototype.toString.call(St), "date");
        if (wt(St))
          return ke(St);
      }
      var Gt = "", Mt = !1, Pt = ["{", "}"];
      if (lt(St) && (Mt = !0, Pt = ["[", "]"]), Oe(St)) {
        var Kt = St.name ? ": " + St.name : "";
        Gt = " [Function" + Kt + "]";
      }
      if ($t(St) && (Gt = " " + RegExp.prototype.toString.call(St)), xt(St) && (Gt = " " + Date.prototype.toUTCString.call(St)), wt(St) && (Gt = " " + ke(St)), Tt.length === 0 && (!Mt || St.length == 0))
        return Pt[0] + Gt + Pt[1];
      if (qt < 0)
        return $t(St) ? ct.stylize(RegExp.prototype.toString.call(St), "regexp") : ct.stylize("[Object]", "special");
      ct.seen.push(St);
      var Zt;
      return Mt ? Zt = Ce(ct, St, qt, Rt, Tt) : Zt = Tt.map(function(rr) {
        return it(ct, St, qt, Rt, rr, Mt);
      }), ct.seen.pop(), at(Zt, Gt, Pt);
    }
    function ce(ct, St) {
      if (Nt(St))
        return ct.stylize("undefined", "undefined");
      if (Bt(St)) {
        var qt = "'" + JSON.stringify(St).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ct.stylize(qt, "string");
      }
      if (vt(St))
        return ct.stylize("" + St, "number");
      if (ht(St))
        return ct.stylize("" + St, "boolean");
      if (dt(St))
        return ct.stylize("null", "null");
    }
    function ke(ct) {
      return "[" + Error.prototype.toString.call(ct) + "]";
    }
    function Ce(ct, St, qt, jt, Ot) {
      for (var Tt = [], Rt = 0, Ut = St.length; Rt < Ut; ++Rt)
        ut(St, String(Rt)) ? Tt.push(it(
          ct,
          St,
          qt,
          jt,
          String(Rt),
          !0
        )) : Tt.push("");
      return Ot.forEach(function(Gt) {
        Gt.match(/^\d+$/) || Tt.push(it(
          ct,
          St,
          qt,
          jt,
          Gt,
          !0
        ));
      }), Tt;
    }
    function it(ct, St, qt, jt, Ot, Tt) {
      var Rt, Ut, Gt;
      if (Gt = Object.getOwnPropertyDescriptor(St, Ot) || { value: St[Ot] }, Gt.get ? Gt.set ? Ut = ct.stylize("[Getter/Setter]", "special") : Ut = ct.stylize("[Getter]", "special") : Gt.set && (Ut = ct.stylize("[Setter]", "special")), ut(jt, Ot) || (Rt = "[" + Ot + "]"), Ut || (ct.seen.indexOf(Gt.value) < 0 ? (dt(qt) ? Ut = V(ct, Gt.value, null) : Ut = V(ct, Gt.value, qt - 1), Ut.indexOf(`
`) > -1 && (Tt ? Ut = Ut.split(`
`).map(function(Mt) {
        return "  " + Mt;
      }).join(`
`).slice(2) : Ut = `
` + Ut.split(`
`).map(function(Mt) {
        return "   " + Mt;
      }).join(`
`))) : Ut = ct.stylize("[Circular]", "special")), Nt(Rt)) {
        if (Tt && Ot.match(/^\d+$/))
          return Ut;
        Rt = JSON.stringify("" + Ot), Rt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Rt = Rt.slice(1, -1), Rt = ct.stylize(Rt, "name")) : (Rt = Rt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Rt = ct.stylize(Rt, "string"));
      }
      return Rt + ": " + Ut;
    }
    function at(ct, St, qt) {
      var jt = ct.reduce(function(Ot, Tt) {
        return Tt.indexOf(`
`) >= 0, Ot + Tt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return jt > 60 ? qt[0] + (St === "" ? "" : St + `
 `) + " " + ct.join(`,
  `) + " " + qt[1] : qt[0] + St + " " + ct.join(", ") + " " + qt[1];
    }
    A.types = requireTypes();
    function lt(ct) {
      return Array.isArray(ct);
    }
    A.isArray = lt;
    function ht(ct) {
      return typeof ct == "boolean";
    }
    A.isBoolean = ht;
    function dt(ct) {
      return ct === null;
    }
    A.isNull = dt;
    function bt(ct) {
      return ct == null;
    }
    A.isNullOrUndefined = bt;
    function vt(ct) {
      return typeof ct == "number";
    }
    A.isNumber = vt;
    function Bt(ct) {
      return typeof ct == "string";
    }
    A.isString = Bt;
    function At(ct) {
      return typeof ct == "symbol";
    }
    A.isSymbol = At;
    function Nt(ct) {
      return ct === void 0;
    }
    A.isUndefined = Nt;
    function $t(ct) {
      return mt(ct) && pe(ct) === "[object RegExp]";
    }
    A.isRegExp = $t, A.types.isRegExp = $t;
    function mt(ct) {
      return typeof ct == "object" && ct !== null;
    }
    A.isObject = mt;
    function xt(ct) {
      return mt(ct) && pe(ct) === "[object Date]";
    }
    A.isDate = xt, A.types.isDate = xt;
    function wt(ct) {
      return mt(ct) && (pe(ct) === "[object Error]" || ct instanceof Error);
    }
    A.isError = wt, A.types.isNativeError = wt;
    function Oe(ct) {
      return typeof ct == "function";
    }
    A.isFunction = Oe;
    function rt(ct) {
      return ct === null || typeof ct == "boolean" || typeof ct == "number" || typeof ct == "string" || typeof ct == "symbol" || // ES6 symbol
      typeof ct > "u";
    }
    A.isPrimitive = rt, A.isBuffer = requireIsBufferBrowser();
    function pe(ct) {
      return Object.prototype.toString.call(ct);
    }
    function nt(ct) {
      return ct < 10 ? "0" + ct.toString(10) : ct.toString(10);
    }
    var ot = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function st() {
      var ct = /* @__PURE__ */ new Date(), St = [
        nt(ct.getHours()),
        nt(ct.getMinutes()),
        nt(ct.getSeconds())
      ].join(":");
      return [ct.getDate(), ot[ct.getMonth()], St].join(" ");
    }
    A.log = function() {
      console.log("%s - %s", st(), A.format.apply(A, arguments));
    }, A.inherits = requireInherits_browser(), A._extend = function(ct, St) {
      if (!St || !mt(St)) return ct;
      for (var qt = Object.keys(St), jt = qt.length; jt--; )
        ct[qt[jt]] = St[qt[jt]];
      return ct;
    };
    function ut(ct, St) {
      return Object.prototype.hasOwnProperty.call(ct, St);
    }
    var pt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    A.promisify = function(St) {
      if (typeof St != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (pt && St[pt]) {
        var qt = St[pt];
        if (typeof qt != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(qt, pt, {
          value: qt,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), qt;
      }
      function qt() {
        for (var jt, Ot, Tt = new Promise(function(Gt, Mt) {
          jt = Gt, Ot = Mt;
        }), Rt = [], Ut = 0; Ut < arguments.length; Ut++)
          Rt.push(arguments[Ut]);
        Rt.push(function(Gt, Mt) {
          Gt ? Ot(Gt) : jt(Mt);
        });
        try {
          St.apply(this, Rt);
        } catch (Gt) {
          Ot(Gt);
        }
        return Tt;
      }
      return Object.setPrototypeOf(qt, Object.getPrototypeOf(St)), pt && Object.defineProperty(qt, pt, {
        value: qt,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        qt,
        B(St)
      );
    }, A.promisify.custom = pt;
    function ft(ct, St) {
      if (!ct) {
        var qt = new Error("Promise was rejected with a falsy value");
        qt.reason = ct, ct = qt;
      }
      return St(ct);
    }
    function yt(ct) {
      if (typeof ct != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function St() {
        for (var qt = [], jt = 0; jt < arguments.length; jt++)
          qt.push(arguments[jt]);
        var Ot = qt.pop();
        if (typeof Ot != "function")
          throw new TypeError("The last argument must be of type Function");
        var Tt = this, Rt = function() {
          return Ot.apply(Tt, arguments);
        };
        ct.apply(this, qt).then(
          function(Ut) {
            process$1.nextTick(Rt.bind(null, null, Ut));
          },
          function(Ut) {
            process$1.nextTick(ft.bind(null, Ut, Rt));
          }
        );
      }
      return Object.setPrototypeOf(St, Object.getPrototypeOf(ct)), Object.defineProperties(
        St,
        B(ct)
      ), St;
    }
    A.callbackify = yt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function A(it, at) {
    var lt = Object.keys(it);
    if (Object.getOwnPropertySymbols) {
      var ht = Object.getOwnPropertySymbols(it);
      at && (ht = ht.filter(function(dt) {
        return Object.getOwnPropertyDescriptor(it, dt).enumerable;
      })), lt.push.apply(lt, ht);
    }
    return lt;
  }
  function B(it) {
    for (var at = 1; at < arguments.length; at++) {
      var lt = arguments[at] != null ? arguments[at] : {};
      at % 2 ? A(Object(lt), !0).forEach(function(ht) {
        L(it, ht, lt[ht]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(it, Object.getOwnPropertyDescriptors(lt)) : A(Object(lt)).forEach(function(ht) {
        Object.defineProperty(it, ht, Object.getOwnPropertyDescriptor(lt, ht));
      });
    }
    return it;
  }
  function L(it, at, lt) {
    return at = J(at), at in it ? Object.defineProperty(it, at, { value: lt, enumerable: !0, configurable: !0, writable: !0 }) : it[at] = lt, it;
  }
  function K(it, at) {
    if (!(it instanceof at))
      throw new TypeError("Cannot call a class as a function");
  }
  function re(it, at) {
    for (var lt = 0; lt < at.length; lt++) {
      var ht = at[lt];
      ht.enumerable = ht.enumerable || !1, ht.configurable = !0, "value" in ht && (ht.writable = !0), Object.defineProperty(it, J(ht.key), ht);
    }
  }
  function W(it, at, lt) {
    return at && re(it.prototype, at), Object.defineProperty(it, "prototype", { writable: !1 }), it;
  }
  function J(it) {
    var at = ne(it, "string");
    return typeof at == "symbol" ? at : String(at);
  }
  function ne(it, at) {
    if (typeof it != "object" || it === null) return it;
    var lt = it[Symbol.toPrimitive];
    if (lt !== void 0) {
      var ht = lt.call(it, at || "default");
      if (typeof ht != "object") return ht;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (at === "string" ? String : Number)(it);
  }
  var ie = require$$0$1, oe = ie.Buffer, V = requireUtil$1(), ce = V.inspect, ke = ce && ce.custom || "inspect";
  function Ce(it, at, lt) {
    oe.prototype.copy.call(it, at, lt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function it() {
      K(this, it), this.head = null, this.tail = null, this.length = 0;
    }
    return W(it, [{
      key: "push",
      value: function(lt) {
        var ht = {
          data: lt,
          next: null
        };
        this.length > 0 ? this.tail.next = ht : this.head = ht, this.tail = ht, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(lt) {
        var ht = {
          data: lt,
          next: this.head
        };
        this.length === 0 && (this.tail = ht), this.head = ht, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var lt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, lt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(lt) {
        if (this.length === 0) return "";
        for (var ht = this.head, dt = "" + ht.data; ht = ht.next; ) dt += lt + ht.data;
        return dt;
      }
    }, {
      key: "concat",
      value: function(lt) {
        if (this.length === 0) return oe.alloc(0);
        for (var ht = oe.allocUnsafe(lt >>> 0), dt = this.head, bt = 0; dt; )
          Ce(dt.data, ht, bt), bt += dt.data.length, dt = dt.next;
        return ht;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(lt, ht) {
        var dt;
        return lt < this.head.data.length ? (dt = this.head.data.slice(0, lt), this.head.data = this.head.data.slice(lt)) : lt === this.head.data.length ? dt = this.shift() : dt = ht ? this._getString(lt) : this._getBuffer(lt), dt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(lt) {
        var ht = this.head, dt = 1, bt = ht.data;
        for (lt -= bt.length; ht = ht.next; ) {
          var vt = ht.data, Bt = lt > vt.length ? vt.length : lt;
          if (Bt === vt.length ? bt += vt : bt += vt.slice(0, lt), lt -= Bt, lt === 0) {
            Bt === vt.length ? (++dt, ht.next ? this.head = ht.next : this.head = this.tail = null) : (this.head = ht, ht.data = vt.slice(Bt));
            break;
          }
          ++dt;
        }
        return this.length -= dt, bt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(lt) {
        var ht = oe.allocUnsafe(lt), dt = this.head, bt = 1;
        for (dt.data.copy(ht), lt -= dt.data.length; dt = dt.next; ) {
          var vt = dt.data, Bt = lt > vt.length ? vt.length : lt;
          if (vt.copy(ht, ht.length - lt, 0, Bt), lt -= Bt, lt === 0) {
            Bt === vt.length ? (++bt, dt.next ? this.head = dt.next : this.head = this.tail = null) : (this.head = dt, dt.data = vt.slice(Bt));
            break;
          }
          ++bt;
        }
        return this.length -= bt, ht;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: ke,
      value: function(lt, ht) {
        return ce(this, B(B({}, ht), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), it;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function A(J, ne) {
    var ie = this, oe = this._readableState && this._readableState.destroyed, V = this._writableState && this._writableState.destroyed;
    return oe || V ? (ne ? ne(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(re, this, J)) : process$1.nextTick(re, this, J)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(ce) {
      !ne && ce ? ie._writableState ? ie._writableState.errorEmitted ? process$1.nextTick(L, ie) : (ie._writableState.errorEmitted = !0, process$1.nextTick(B, ie, ce)) : process$1.nextTick(B, ie, ce) : ne ? (process$1.nextTick(L, ie), ne(ce)) : process$1.nextTick(L, ie);
    }), this);
  }
  function B(J, ne) {
    re(J, ne), L(J);
  }
  function L(J) {
    J._writableState && !J._writableState.emitClose || J._readableState && !J._readableState.emitClose || J.emit("close");
  }
  function K() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function re(J, ne) {
    J.emit("error", ne);
  }
  function W(J, ne) {
    var ie = J._readableState, oe = J._writableState;
    ie && ie.autoDestroy || oe && oe.autoDestroy ? J.destroy(ne) : J.emit("error", ne);
  }
  return destroy_1$1 = {
    destroy: A,
    undestroy: K,
    errorOrDestroy: W
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function A(ne, ie) {
    ne.prototype = Object.create(ie.prototype), ne.prototype.constructor = ne, ne.__proto__ = ie;
  }
  var B = {};
  function L(ne, ie, oe) {
    oe || (oe = Error);
    function V(ke, Ce, it) {
      return typeof ie == "string" ? ie : ie(ke, Ce, it);
    }
    var ce = /* @__PURE__ */ function(ke) {
      A(Ce, ke);
      function Ce(it, at, lt) {
        return ke.call(this, V(it, at, lt)) || this;
      }
      return Ce;
    }(oe);
    ce.prototype.name = oe.name, ce.prototype.code = ne, B[ne] = ce;
  }
  function K(ne, ie) {
    if (Array.isArray(ne)) {
      var oe = ne.length;
      return ne = ne.map(function(V) {
        return String(V);
      }), oe > 2 ? "one of ".concat(ie, " ").concat(ne.slice(0, oe - 1).join(", "), ", or ") + ne[oe - 1] : oe === 2 ? "one of ".concat(ie, " ").concat(ne[0], " or ").concat(ne[1]) : "of ".concat(ie, " ").concat(ne[0]);
    } else
      return "of ".concat(ie, " ").concat(String(ne));
  }
  function re(ne, ie, oe) {
    return ne.substr(0, ie.length) === ie;
  }
  function W(ne, ie, oe) {
    return (oe === void 0 || oe > ne.length) && (oe = ne.length), ne.substring(oe - ie.length, oe) === ie;
  }
  function J(ne, ie, oe) {
    return typeof oe != "number" && (oe = 0), oe + ie.length > ne.length ? !1 : ne.indexOf(ie, oe) !== -1;
  }
  return L("ERR_INVALID_OPT_VALUE", function(ne, ie) {
    return 'The value "' + ie + '" is invalid for option "' + ne + '"';
  }, TypeError), L("ERR_INVALID_ARG_TYPE", function(ne, ie, oe) {
    var V;
    typeof ie == "string" && re(ie, "not ") ? (V = "must not be", ie = ie.replace(/^not /, "")) : V = "must be";
    var ce;
    if (W(ne, " argument"))
      ce = "The ".concat(ne, " ").concat(V, " ").concat(K(ie, "type"));
    else {
      var ke = J(ne, ".") ? "property" : "argument";
      ce = 'The "'.concat(ne, '" ').concat(ke, " ").concat(V, " ").concat(K(ie, "type"));
    }
    return ce += ". Received type ".concat(typeof oe), ce;
  }, TypeError), L("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), L("ERR_METHOD_NOT_IMPLEMENTED", function(ne) {
    return "The " + ne + " method is not implemented";
  }), L("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), L("ERR_STREAM_DESTROYED", function(ne) {
    return "Cannot call " + ne + " after a stream was destroyed";
  }), L("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), L("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), L("ERR_STREAM_WRITE_AFTER_END", "write after end"), L("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), L("ERR_UNKNOWN_ENCODING", function(ne) {
    return "Unknown encoding: " + ne;
  }, TypeError), L("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = B, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var A = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function B(K, re, W) {
    return K.highWaterMark != null ? K.highWaterMark : re ? K[W] : null;
  }
  function L(K, re, W, J) {
    var ne = B(re, J, W);
    if (ne != null) {
      if (!(isFinite(ne) && Math.floor(ne) === ne) || ne < 0) {
        var ie = J ? W : "highWaterMark";
        throw new A(ie, ne);
      }
      return Math.floor(ne);
    }
    return K.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: L
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = A;
  function A(L, K) {
    if (B("noDeprecation"))
      return L;
    var re = !1;
    function W() {
      if (!re) {
        if (B("throwDeprecation"))
          throw new Error(K);
        B("traceDeprecation") ? console.trace(K) : console.warn(K), re = !0;
      }
      return L.apply(this, arguments);
    }
    return W;
  }
  function B(L) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[L];
    return K == null ? !1 : String(K).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = $t;
  function A(Ot) {
    var Tt = this;
    this.next = null, this.entry = null, this.finish = function() {
      jt(Tt, Ot);
    };
  }
  var B;
  $t.WritableState = At;
  var L = {
    deprecate: requireBrowser$a()
  }, K = requireStreamBrowser$1(), re = require$$0$1.Buffer, W = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function J(Ot) {
    return re.from(Ot);
  }
  function ne(Ot) {
    return re.isBuffer(Ot) || Ot instanceof W;
  }
  var ie = requireDestroy$1(), oe = requireState(), V = oe.getHighWaterMark, ce = requireErrorsBrowser().codes, ke = ce.ERR_INVALID_ARG_TYPE, Ce = ce.ERR_METHOD_NOT_IMPLEMENTED, it = ce.ERR_MULTIPLE_CALLBACK, at = ce.ERR_STREAM_CANNOT_PIPE, lt = ce.ERR_STREAM_DESTROYED, ht = ce.ERR_STREAM_NULL_VALUES, dt = ce.ERR_STREAM_WRITE_AFTER_END, bt = ce.ERR_UNKNOWN_ENCODING, vt = ie.errorOrDestroy;
  requireInherits_browser()($t, K);
  function Bt() {
  }
  function At(Ot, Tt, Rt) {
    B = B || require_stream_duplex$1(), Ot = Ot || {}, typeof Rt != "boolean" && (Rt = Tt instanceof B), this.objectMode = !!Ot.objectMode, Rt && (this.objectMode = this.objectMode || !!Ot.writableObjectMode), this.highWaterMark = V(this, Ot, "writableHighWaterMark", Rt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ut = Ot.decodeStrings === !1;
    this.decodeStrings = !Ut, this.defaultEncoding = Ot.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Gt) {
      ot(Tt, Gt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Ot.emitClose !== !1, this.autoDestroy = !!Ot.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
  }
  At.prototype.getBuffer = function() {
    for (var Tt = this.bufferedRequest, Rt = []; Tt; )
      Rt.push(Tt), Tt = Tt.next;
    return Rt;
  }, function() {
    try {
      Object.defineProperty(At.prototype, "buffer", {
        get: L.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Nt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Nt = Function.prototype[Symbol.hasInstance], Object.defineProperty($t, Symbol.hasInstance, {
    value: function(Tt) {
      return Nt.call(this, Tt) ? !0 : this !== $t ? !1 : Tt && Tt._writableState instanceof At;
    }
  })) : Nt = function(Tt) {
    return Tt instanceof this;
  };
  function $t(Ot) {
    B = B || require_stream_duplex$1();
    var Tt = this instanceof B;
    if (!Tt && !Nt.call($t, this)) return new $t(Ot);
    this._writableState = new At(Ot, this, Tt), this.writable = !0, Ot && (typeof Ot.write == "function" && (this._write = Ot.write), typeof Ot.writev == "function" && (this._writev = Ot.writev), typeof Ot.destroy == "function" && (this._destroy = Ot.destroy), typeof Ot.final == "function" && (this._final = Ot.final)), K.call(this);
  }
  $t.prototype.pipe = function() {
    vt(this, new at());
  };
  function mt(Ot, Tt) {
    var Rt = new dt();
    vt(Ot, Rt), process$1.nextTick(Tt, Rt);
  }
  function xt(Ot, Tt, Rt, Ut) {
    var Gt;
    return Rt === null ? Gt = new ht() : typeof Rt != "string" && !Tt.objectMode && (Gt = new ke("chunk", ["string", "Buffer"], Rt)), Gt ? (vt(Ot, Gt), process$1.nextTick(Ut, Gt), !1) : !0;
  }
  $t.prototype.write = function(Ot, Tt, Rt) {
    var Ut = this._writableState, Gt = !1, Mt = !Ut.objectMode && ne(Ot);
    return Mt && !re.isBuffer(Ot) && (Ot = J(Ot)), typeof Tt == "function" && (Rt = Tt, Tt = null), Mt ? Tt = "buffer" : Tt || (Tt = Ut.defaultEncoding), typeof Rt != "function" && (Rt = Bt), Ut.ending ? mt(this, Rt) : (Mt || xt(this, Ut, Ot, Rt)) && (Ut.pendingcb++, Gt = Oe(this, Ut, Mt, Ot, Tt, Rt)), Gt;
  }, $t.prototype.cork = function() {
    this._writableState.corked++;
  }, $t.prototype.uncork = function() {
    var Ot = this._writableState;
    Ot.corked && (Ot.corked--, !Ot.writing && !Ot.corked && !Ot.bufferProcessing && Ot.bufferedRequest && pt(this, Ot));
  }, $t.prototype.setDefaultEncoding = function(Tt) {
    if (typeof Tt == "string" && (Tt = Tt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Tt + "").toLowerCase()) > -1)) throw new bt(Tt);
    return this._writableState.defaultEncoding = Tt, this;
  }, Object.defineProperty($t.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function wt(Ot, Tt, Rt) {
    return !Ot.objectMode && Ot.decodeStrings !== !1 && typeof Tt == "string" && (Tt = re.from(Tt, Rt)), Tt;
  }
  Object.defineProperty($t.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Oe(Ot, Tt, Rt, Ut, Gt, Mt) {
    if (!Rt) {
      var Pt = wt(Tt, Ut, Gt);
      Ut !== Pt && (Rt = !0, Gt = "buffer", Ut = Pt);
    }
    var Kt = Tt.objectMode ? 1 : Ut.length;
    Tt.length += Kt;
    var Zt = Tt.length < Tt.highWaterMark;
    if (Zt || (Tt.needDrain = !0), Tt.writing || Tt.corked) {
      var rr = Tt.lastBufferedRequest;
      Tt.lastBufferedRequest = {
        chunk: Ut,
        encoding: Gt,
        isBuf: Rt,
        callback: Mt,
        next: null
      }, rr ? rr.next = Tt.lastBufferedRequest : Tt.bufferedRequest = Tt.lastBufferedRequest, Tt.bufferedRequestCount += 1;
    } else
      rt(Ot, Tt, !1, Kt, Ut, Gt, Mt);
    return Zt;
  }
  function rt(Ot, Tt, Rt, Ut, Gt, Mt, Pt) {
    Tt.writelen = Ut, Tt.writecb = Pt, Tt.writing = !0, Tt.sync = !0, Tt.destroyed ? Tt.onwrite(new lt("write")) : Rt ? Ot._writev(Gt, Tt.onwrite) : Ot._write(Gt, Mt, Tt.onwrite), Tt.sync = !1;
  }
  function pe(Ot, Tt, Rt, Ut, Gt) {
    --Tt.pendingcb, Rt ? (process$1.nextTick(Gt, Ut), process$1.nextTick(St, Ot, Tt), Ot._writableState.errorEmitted = !0, vt(Ot, Ut)) : (Gt(Ut), Ot._writableState.errorEmitted = !0, vt(Ot, Ut), St(Ot, Tt));
  }
  function nt(Ot) {
    Ot.writing = !1, Ot.writecb = null, Ot.length -= Ot.writelen, Ot.writelen = 0;
  }
  function ot(Ot, Tt) {
    var Rt = Ot._writableState, Ut = Rt.sync, Gt = Rt.writecb;
    if (typeof Gt != "function") throw new it();
    if (nt(Rt), Tt) pe(Ot, Rt, Ut, Tt, Gt);
    else {
      var Mt = ft(Rt) || Ot.destroyed;
      !Mt && !Rt.corked && !Rt.bufferProcessing && Rt.bufferedRequest && pt(Ot, Rt), Ut ? process$1.nextTick(st, Ot, Rt, Mt, Gt) : st(Ot, Rt, Mt, Gt);
    }
  }
  function st(Ot, Tt, Rt, Ut) {
    Rt || ut(Ot, Tt), Tt.pendingcb--, Ut(), St(Ot, Tt);
  }
  function ut(Ot, Tt) {
    Tt.length === 0 && Tt.needDrain && (Tt.needDrain = !1, Ot.emit("drain"));
  }
  function pt(Ot, Tt) {
    Tt.bufferProcessing = !0;
    var Rt = Tt.bufferedRequest;
    if (Ot._writev && Rt && Rt.next) {
      var Ut = Tt.bufferedRequestCount, Gt = new Array(Ut), Mt = Tt.corkedRequestsFree;
      Mt.entry = Rt;
      for (var Pt = 0, Kt = !0; Rt; )
        Gt[Pt] = Rt, Rt.isBuf || (Kt = !1), Rt = Rt.next, Pt += 1;
      Gt.allBuffers = Kt, rt(Ot, Tt, !0, Tt.length, Gt, "", Mt.finish), Tt.pendingcb++, Tt.lastBufferedRequest = null, Mt.next ? (Tt.corkedRequestsFree = Mt.next, Mt.next = null) : Tt.corkedRequestsFree = new A(Tt), Tt.bufferedRequestCount = 0;
    } else {
      for (; Rt; ) {
        var Zt = Rt.chunk, rr = Rt.encoding, ar = Rt.callback, ur = Tt.objectMode ? 1 : Zt.length;
        if (rt(Ot, Tt, !1, ur, Zt, rr, ar), Rt = Rt.next, Tt.bufferedRequestCount--, Tt.writing)
          break;
      }
      Rt === null && (Tt.lastBufferedRequest = null);
    }
    Tt.bufferedRequest = Rt, Tt.bufferProcessing = !1;
  }
  $t.prototype._write = function(Ot, Tt, Rt) {
    Rt(new Ce("_write()"));
  }, $t.prototype._writev = null, $t.prototype.end = function(Ot, Tt, Rt) {
    var Ut = this._writableState;
    return typeof Ot == "function" ? (Rt = Ot, Ot = null, Tt = null) : typeof Tt == "function" && (Rt = Tt, Tt = null), Ot != null && this.write(Ot, Tt), Ut.corked && (Ut.corked = 1, this.uncork()), Ut.ending || qt(this, Ut, Rt), this;
  }, Object.defineProperty($t.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ft(Ot) {
    return Ot.ending && Ot.length === 0 && Ot.bufferedRequest === null && !Ot.finished && !Ot.writing;
  }
  function yt(Ot, Tt) {
    Ot._final(function(Rt) {
      Tt.pendingcb--, Rt && vt(Ot, Rt), Tt.prefinished = !0, Ot.emit("prefinish"), St(Ot, Tt);
    });
  }
  function ct(Ot, Tt) {
    !Tt.prefinished && !Tt.finalCalled && (typeof Ot._final == "function" && !Tt.destroyed ? (Tt.pendingcb++, Tt.finalCalled = !0, process$1.nextTick(yt, Ot, Tt)) : (Tt.prefinished = !0, Ot.emit("prefinish")));
  }
  function St(Ot, Tt) {
    var Rt = ft(Tt);
    if (Rt && (ct(Ot, Tt), Tt.pendingcb === 0 && (Tt.finished = !0, Ot.emit("finish"), Tt.autoDestroy))) {
      var Ut = Ot._readableState;
      (!Ut || Ut.autoDestroy && Ut.endEmitted) && Ot.destroy();
    }
    return Rt;
  }
  function qt(Ot, Tt, Rt) {
    Tt.ending = !0, St(Ot, Tt), Rt && (Tt.finished ? process$1.nextTick(Rt) : Ot.once("finish", Rt)), Tt.ended = !0, Ot.writable = !1;
  }
  function jt(Ot, Tt, Rt) {
    var Ut = Ot.entry;
    for (Ot.entry = null; Ut; ) {
      var Gt = Ut.callback;
      Tt.pendingcb--, Gt(Rt), Ut = Ut.next;
    }
    Tt.corkedRequestsFree.next = Ot;
  }
  return Object.defineProperty($t.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Tt) {
      this._writableState && (this._writableState.destroyed = Tt);
    }
  }), $t.prototype.destroy = ie.destroy, $t.prototype._undestroy = ie.undestroy, $t.prototype._destroy = function(Ot, Tt) {
    Tt(Ot);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var A = Object.keys || function(oe) {
    var V = [];
    for (var ce in oe) V.push(ce);
    return V;
  };
  _stream_duplex$1 = J;
  var B = require_stream_readable$1(), L = require_stream_writable$1();
  requireInherits_browser()(J, B);
  for (var K = A(L.prototype), re = 0; re < K.length; re++) {
    var W = K[re];
    J.prototype[W] || (J.prototype[W] = L.prototype[W]);
  }
  function J(oe) {
    if (!(this instanceof J)) return new J(oe);
    B.call(this, oe), L.call(this, oe), this.allowHalfOpen = !0, oe && (oe.readable === !1 && (this.readable = !1), oe.writable === !1 && (this.writable = !1), oe.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ne)));
  }
  Object.defineProperty(J.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(J.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(J.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ne() {
    this._writableState.ended || process$1.nextTick(ie, this);
  }
  function ie(oe) {
    oe.end();
  }
  return Object.defineProperty(J.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(V) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = V, this._writableState.destroyed = V);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var A = safeBufferExports.Buffer, B = A.isEncoding || function(ht) {
    switch (ht = "" + ht, ht && ht.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function L(ht) {
    if (!ht) return "utf8";
    for (var dt; ; )
      switch (ht) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return ht;
        default:
          if (dt) return;
          ht = ("" + ht).toLowerCase(), dt = !0;
      }
  }
  function K(ht) {
    var dt = L(ht);
    if (typeof dt != "string" && (A.isEncoding === B || !B(ht))) throw new Error("Unknown encoding: " + ht);
    return dt || ht;
  }
  string_decoder.StringDecoder = re;
  function re(ht) {
    this.encoding = K(ht);
    var dt;
    switch (this.encoding) {
      case "utf16le":
        this.text = ce, this.end = ke, dt = 4;
        break;
      case "utf8":
        this.fillLast = ie, dt = 4;
        break;
      case "base64":
        this.text = Ce, this.end = it, dt = 3;
        break;
      default:
        this.write = at, this.end = lt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = A.allocUnsafe(dt);
  }
  re.prototype.write = function(ht) {
    if (ht.length === 0) return "";
    var dt, bt;
    if (this.lastNeed) {
      if (dt = this.fillLast(ht), dt === void 0) return "";
      bt = this.lastNeed, this.lastNeed = 0;
    } else
      bt = 0;
    return bt < ht.length ? dt ? dt + this.text(ht, bt) : this.text(ht, bt) : dt || "";
  }, re.prototype.end = V, re.prototype.text = oe, re.prototype.fillLast = function(ht) {
    if (this.lastNeed <= ht.length)
      return ht.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    ht.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ht.length), this.lastNeed -= ht.length;
  };
  function W(ht) {
    return ht <= 127 ? 0 : ht >> 5 === 6 ? 2 : ht >> 4 === 14 ? 3 : ht >> 3 === 30 ? 4 : ht >> 6 === 2 ? -1 : -2;
  }
  function J(ht, dt, bt) {
    var vt = dt.length - 1;
    if (vt < bt) return 0;
    var Bt = W(dt[vt]);
    return Bt >= 0 ? (Bt > 0 && (ht.lastNeed = Bt - 1), Bt) : --vt < bt || Bt === -2 ? 0 : (Bt = W(dt[vt]), Bt >= 0 ? (Bt > 0 && (ht.lastNeed = Bt - 2), Bt) : --vt < bt || Bt === -2 ? 0 : (Bt = W(dt[vt]), Bt >= 0 ? (Bt > 0 && (Bt === 2 ? Bt = 0 : ht.lastNeed = Bt - 3), Bt) : 0));
  }
  function ne(ht, dt, bt) {
    if ((dt[0] & 192) !== 128)
      return ht.lastNeed = 0, "";
    if (ht.lastNeed > 1 && dt.length > 1) {
      if ((dt[1] & 192) !== 128)
        return ht.lastNeed = 1, "";
      if (ht.lastNeed > 2 && dt.length > 2 && (dt[2] & 192) !== 128)
        return ht.lastNeed = 2, "";
    }
  }
  function ie(ht) {
    var dt = this.lastTotal - this.lastNeed, bt = ne(this, ht);
    if (bt !== void 0) return bt;
    if (this.lastNeed <= ht.length)
      return ht.copy(this.lastChar, dt, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    ht.copy(this.lastChar, dt, 0, ht.length), this.lastNeed -= ht.length;
  }
  function oe(ht, dt) {
    var bt = J(this, ht, dt);
    if (!this.lastNeed) return ht.toString("utf8", dt);
    this.lastTotal = bt;
    var vt = ht.length - (bt - this.lastNeed);
    return ht.copy(this.lastChar, 0, vt), ht.toString("utf8", dt, vt);
  }
  function V(ht) {
    var dt = ht && ht.length ? this.write(ht) : "";
    return this.lastNeed ? dt + "" : dt;
  }
  function ce(ht, dt) {
    if ((ht.length - dt) % 2 === 0) {
      var bt = ht.toString("utf16le", dt);
      if (bt) {
        var vt = bt.charCodeAt(bt.length - 1);
        if (vt >= 55296 && vt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = ht[ht.length - 2], this.lastChar[1] = ht[ht.length - 1], bt.slice(0, -1);
      }
      return bt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = ht[ht.length - 1], ht.toString("utf16le", dt, ht.length - 1);
  }
  function ke(ht) {
    var dt = ht && ht.length ? this.write(ht) : "";
    if (this.lastNeed) {
      var bt = this.lastTotal - this.lastNeed;
      return dt + this.lastChar.toString("utf16le", 0, bt);
    }
    return dt;
  }
  function Ce(ht, dt) {
    var bt = (ht.length - dt) % 3;
    return bt === 0 ? ht.toString("base64", dt) : (this.lastNeed = 3 - bt, this.lastTotal = 3, bt === 1 ? this.lastChar[0] = ht[ht.length - 1] : (this.lastChar[0] = ht[ht.length - 2], this.lastChar[1] = ht[ht.length - 1]), ht.toString("base64", dt, ht.length - bt));
  }
  function it(ht) {
    var dt = ht && ht.length ? this.write(ht) : "";
    return this.lastNeed ? dt + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : dt;
  }
  function at(ht) {
    return ht.toString(this.encoding);
  }
  function lt(ht) {
    return ht && ht.length ? this.write(ht) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var A = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function B(W) {
    var J = !1;
    return function() {
      if (!J) {
        J = !0;
        for (var ne = arguments.length, ie = new Array(ne), oe = 0; oe < ne; oe++)
          ie[oe] = arguments[oe];
        W.apply(this, ie);
      }
    };
  }
  function L() {
  }
  function K(W) {
    return W.setHeader && typeof W.abort == "function";
  }
  function re(W, J, ne) {
    if (typeof J == "function") return re(W, null, J);
    J || (J = {}), ne = B(ne || L);
    var ie = J.readable || J.readable !== !1 && W.readable, oe = J.writable || J.writable !== !1 && W.writable, V = function() {
      W.writable || ke();
    }, ce = W._writableState && W._writableState.finished, ke = function() {
      oe = !1, ce = !0, ie || ne.call(W);
    }, Ce = W._readableState && W._readableState.endEmitted, it = function() {
      ie = !1, Ce = !0, oe || ne.call(W);
    }, at = function(bt) {
      ne.call(W, bt);
    }, lt = function() {
      var bt;
      if (ie && !Ce)
        return (!W._readableState || !W._readableState.ended) && (bt = new A()), ne.call(W, bt);
      if (oe && !ce)
        return (!W._writableState || !W._writableState.ended) && (bt = new A()), ne.call(W, bt);
    }, ht = function() {
      W.req.on("finish", ke);
    };
    return K(W) ? (W.on("complete", ke), W.on("abort", lt), W.req ? ht() : W.on("request", ht)) : oe && !W._writableState && (W.on("end", V), W.on("close", V)), W.on("end", it), W.on("finish", ke), J.error !== !1 && W.on("error", at), W.on("close", lt), function() {
      W.removeListener("complete", ke), W.removeListener("abort", lt), W.removeListener("request", ht), W.req && W.req.removeListener("finish", ke), W.removeListener("end", V), W.removeListener("close", V), W.removeListener("finish", ke), W.removeListener("end", it), W.removeListener("error", at), W.removeListener("close", lt);
    };
  }
  return endOfStream = re, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var A;
  function B(bt, vt, Bt) {
    return vt = L(vt), vt in bt ? Object.defineProperty(bt, vt, { value: Bt, enumerable: !0, configurable: !0, writable: !0 }) : bt[vt] = Bt, bt;
  }
  function L(bt) {
    var vt = K(bt, "string");
    return typeof vt == "symbol" ? vt : String(vt);
  }
  function K(bt, vt) {
    if (typeof bt != "object" || bt === null) return bt;
    var Bt = bt[Symbol.toPrimitive];
    if (Bt !== void 0) {
      var At = Bt.call(bt, vt || "default");
      if (typeof At != "object") return At;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (vt === "string" ? String : Number)(bt);
  }
  var re = requireEndOfStream(), W = Symbol("lastResolve"), J = Symbol("lastReject"), ne = Symbol("error"), ie = Symbol("ended"), oe = Symbol("lastPromise"), V = Symbol("handlePromise"), ce = Symbol("stream");
  function ke(bt, vt) {
    return {
      value: bt,
      done: vt
    };
  }
  function Ce(bt) {
    var vt = bt[W];
    if (vt !== null) {
      var Bt = bt[ce].read();
      Bt !== null && (bt[oe] = null, bt[W] = null, bt[J] = null, vt(ke(Bt, !1)));
    }
  }
  function it(bt) {
    process$1.nextTick(Ce, bt);
  }
  function at(bt, vt) {
    return function(Bt, At) {
      bt.then(function() {
        if (vt[ie]) {
          Bt(ke(void 0, !0));
          return;
        }
        vt[V](Bt, At);
      }, At);
    };
  }
  var lt = Object.getPrototypeOf(function() {
  }), ht = Object.setPrototypeOf((A = {
    get stream() {
      return this[ce];
    },
    next: function() {
      var vt = this, Bt = this[ne];
      if (Bt !== null)
        return Promise.reject(Bt);
      if (this[ie])
        return Promise.resolve(ke(void 0, !0));
      if (this[ce].destroyed)
        return new Promise(function(mt, xt) {
          process$1.nextTick(function() {
            vt[ne] ? xt(vt[ne]) : mt(ke(void 0, !0));
          });
        });
      var At = this[oe], Nt;
      if (At)
        Nt = new Promise(at(At, this));
      else {
        var $t = this[ce].read();
        if ($t !== null)
          return Promise.resolve(ke($t, !1));
        Nt = new Promise(this[V]);
      }
      return this[oe] = Nt, Nt;
    }
  }, B(A, Symbol.asyncIterator, function() {
    return this;
  }), B(A, "return", function() {
    var vt = this;
    return new Promise(function(Bt, At) {
      vt[ce].destroy(null, function(Nt) {
        if (Nt) {
          At(Nt);
          return;
        }
        Bt(ke(void 0, !0));
      });
    });
  }), A), lt), dt = function(vt) {
    var Bt, At = Object.create(ht, (Bt = {}, B(Bt, ce, {
      value: vt,
      writable: !0
    }), B(Bt, W, {
      value: null,
      writable: !0
    }), B(Bt, J, {
      value: null,
      writable: !0
    }), B(Bt, ne, {
      value: null,
      writable: !0
    }), B(Bt, ie, {
      value: vt._readableState.endEmitted,
      writable: !0
    }), B(Bt, V, {
      value: function($t, mt) {
        var xt = At[ce].read();
        xt ? (At[oe] = null, At[W] = null, At[J] = null, $t(ke(xt, !1))) : (At[W] = $t, At[J] = mt);
      },
      writable: !0
    }), Bt));
    return At[oe] = null, re(vt, function(Nt) {
      if (Nt && Nt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var $t = At[J];
        $t !== null && (At[oe] = null, At[W] = null, At[J] = null, $t(Nt)), At[ne] = Nt;
        return;
      }
      var mt = At[W];
      mt !== null && (At[oe] = null, At[W] = null, At[J] = null, mt(ke(void 0, !0))), At[ie] = !0;
    }), vt.on("readable", it.bind(null, At)), At;
  };
  return async_iterator = dt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = mt;
  var A;
  mt.ReadableState = $t, requireEvents().EventEmitter;
  var B = function(Pt, Kt) {
    return Pt.listeners(Kt).length;
  }, L = requireStreamBrowser$1(), K = require$$0$1.Buffer, re = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function W(Mt) {
    return K.from(Mt);
  }
  function J(Mt) {
    return K.isBuffer(Mt) || Mt instanceof re;
  }
  var ne = requireUtil$1(), ie;
  ne && ne.debuglog ? ie = ne.debuglog("stream") : ie = function() {
  };
  var oe = requireBuffer_list(), V = requireDestroy$1(), ce = requireState(), ke = ce.getHighWaterMark, Ce = requireErrorsBrowser().codes, it = Ce.ERR_INVALID_ARG_TYPE, at = Ce.ERR_STREAM_PUSH_AFTER_EOF, lt = Ce.ERR_METHOD_NOT_IMPLEMENTED, ht = Ce.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, dt, bt, vt;
  requireInherits_browser()(mt, L);
  var Bt = V.errorOrDestroy, At = ["error", "close", "destroy", "pause", "resume"];
  function Nt(Mt, Pt, Kt) {
    if (typeof Mt.prependListener == "function") return Mt.prependListener(Pt, Kt);
    !Mt._events || !Mt._events[Pt] ? Mt.on(Pt, Kt) : Array.isArray(Mt._events[Pt]) ? Mt._events[Pt].unshift(Kt) : Mt._events[Pt] = [Kt, Mt._events[Pt]];
  }
  function $t(Mt, Pt, Kt) {
    A = A || require_stream_duplex$1(), Mt = Mt || {}, typeof Kt != "boolean" && (Kt = Pt instanceof A), this.objectMode = !!Mt.objectMode, Kt && (this.objectMode = this.objectMode || !!Mt.readableObjectMode), this.highWaterMark = ke(this, Mt, "readableHighWaterMark", Kt), this.buffer = new oe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Mt.emitClose !== !1, this.autoDestroy = !!Mt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Mt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Mt.encoding && (dt || (dt = requireString_decoder().StringDecoder), this.decoder = new dt(Mt.encoding), this.encoding = Mt.encoding);
  }
  function mt(Mt) {
    if (A = A || require_stream_duplex$1(), !(this instanceof mt)) return new mt(Mt);
    var Pt = this instanceof A;
    this._readableState = new $t(Mt, this, Pt), this.readable = !0, Mt && (typeof Mt.read == "function" && (this._read = Mt.read), typeof Mt.destroy == "function" && (this._destroy = Mt.destroy)), L.call(this);
  }
  Object.defineProperty(mt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Pt) {
      this._readableState && (this._readableState.destroyed = Pt);
    }
  }), mt.prototype.destroy = V.destroy, mt.prototype._undestroy = V.undestroy, mt.prototype._destroy = function(Mt, Pt) {
    Pt(Mt);
  }, mt.prototype.push = function(Mt, Pt) {
    var Kt = this._readableState, Zt;
    return Kt.objectMode ? Zt = !0 : typeof Mt == "string" && (Pt = Pt || Kt.defaultEncoding, Pt !== Kt.encoding && (Mt = K.from(Mt, Pt), Pt = ""), Zt = !0), xt(this, Mt, Pt, !1, Zt);
  }, mt.prototype.unshift = function(Mt) {
    return xt(this, Mt, null, !0, !1);
  };
  function xt(Mt, Pt, Kt, Zt, rr) {
    ie("readableAddChunk", Pt);
    var ar = Mt._readableState;
    if (Pt === null)
      ar.reading = !1, ot(Mt, ar);
    else {
      var ur;
      if (rr || (ur = Oe(ar, Pt)), ur)
        Bt(Mt, ur);
      else if (ar.objectMode || Pt && Pt.length > 0)
        if (typeof Pt != "string" && !ar.objectMode && Object.getPrototypeOf(Pt) !== K.prototype && (Pt = W(Pt)), Zt)
          ar.endEmitted ? Bt(Mt, new ht()) : wt(Mt, ar, Pt, !0);
        else if (ar.ended)
          Bt(Mt, new at());
        else {
          if (ar.destroyed)
            return !1;
          ar.reading = !1, ar.decoder && !Kt ? (Pt = ar.decoder.write(Pt), ar.objectMode || Pt.length !== 0 ? wt(Mt, ar, Pt, !1) : pt(Mt, ar)) : wt(Mt, ar, Pt, !1);
        }
      else Zt || (ar.reading = !1, pt(Mt, ar));
    }
    return !ar.ended && (ar.length < ar.highWaterMark || ar.length === 0);
  }
  function wt(Mt, Pt, Kt, Zt) {
    Pt.flowing && Pt.length === 0 && !Pt.sync ? (Pt.awaitDrain = 0, Mt.emit("data", Kt)) : (Pt.length += Pt.objectMode ? 1 : Kt.length, Zt ? Pt.buffer.unshift(Kt) : Pt.buffer.push(Kt), Pt.needReadable && st(Mt)), pt(Mt, Pt);
  }
  function Oe(Mt, Pt) {
    var Kt;
    return !J(Pt) && typeof Pt != "string" && Pt !== void 0 && !Mt.objectMode && (Kt = new it("chunk", ["string", "Buffer", "Uint8Array"], Pt)), Kt;
  }
  mt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, mt.prototype.setEncoding = function(Mt) {
    dt || (dt = requireString_decoder().StringDecoder);
    var Pt = new dt(Mt);
    this._readableState.decoder = Pt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Kt = this._readableState.buffer.head, Zt = ""; Kt !== null; )
      Zt += Pt.write(Kt.data), Kt = Kt.next;
    return this._readableState.buffer.clear(), Zt !== "" && this._readableState.buffer.push(Zt), this._readableState.length = Zt.length, this;
  };
  var rt = 1073741824;
  function pe(Mt) {
    return Mt >= rt ? Mt = rt : (Mt--, Mt |= Mt >>> 1, Mt |= Mt >>> 2, Mt |= Mt >>> 4, Mt |= Mt >>> 8, Mt |= Mt >>> 16, Mt++), Mt;
  }
  function nt(Mt, Pt) {
    return Mt <= 0 || Pt.length === 0 && Pt.ended ? 0 : Pt.objectMode ? 1 : Mt !== Mt ? Pt.flowing && Pt.length ? Pt.buffer.head.data.length : Pt.length : (Mt > Pt.highWaterMark && (Pt.highWaterMark = pe(Mt)), Mt <= Pt.length ? Mt : Pt.ended ? Pt.length : (Pt.needReadable = !0, 0));
  }
  mt.prototype.read = function(Mt) {
    ie("read", Mt), Mt = parseInt(Mt, 10);
    var Pt = this._readableState, Kt = Mt;
    if (Mt !== 0 && (Pt.emittedReadable = !1), Mt === 0 && Pt.needReadable && ((Pt.highWaterMark !== 0 ? Pt.length >= Pt.highWaterMark : Pt.length > 0) || Pt.ended))
      return ie("read: emitReadable", Pt.length, Pt.ended), Pt.length === 0 && Pt.ended ? Rt(this) : st(this), null;
    if (Mt = nt(Mt, Pt), Mt === 0 && Pt.ended)
      return Pt.length === 0 && Rt(this), null;
    var Zt = Pt.needReadable;
    ie("need readable", Zt), (Pt.length === 0 || Pt.length - Mt < Pt.highWaterMark) && (Zt = !0, ie("length less than watermark", Zt)), Pt.ended || Pt.reading ? (Zt = !1, ie("reading or ended", Zt)) : Zt && (ie("do read"), Pt.reading = !0, Pt.sync = !0, Pt.length === 0 && (Pt.needReadable = !0), this._read(Pt.highWaterMark), Pt.sync = !1, Pt.reading || (Mt = nt(Kt, Pt)));
    var rr;
    return Mt > 0 ? rr = Tt(Mt, Pt) : rr = null, rr === null ? (Pt.needReadable = Pt.length <= Pt.highWaterMark, Mt = 0) : (Pt.length -= Mt, Pt.awaitDrain = 0), Pt.length === 0 && (Pt.ended || (Pt.needReadable = !0), Kt !== Mt && Pt.ended && Rt(this)), rr !== null && this.emit("data", rr), rr;
  };
  function ot(Mt, Pt) {
    if (ie("onEofChunk"), !Pt.ended) {
      if (Pt.decoder) {
        var Kt = Pt.decoder.end();
        Kt && Kt.length && (Pt.buffer.push(Kt), Pt.length += Pt.objectMode ? 1 : Kt.length);
      }
      Pt.ended = !0, Pt.sync ? st(Mt) : (Pt.needReadable = !1, Pt.emittedReadable || (Pt.emittedReadable = !0, ut(Mt)));
    }
  }
  function st(Mt) {
    var Pt = Mt._readableState;
    ie("emitReadable", Pt.needReadable, Pt.emittedReadable), Pt.needReadable = !1, Pt.emittedReadable || (ie("emitReadable", Pt.flowing), Pt.emittedReadable = !0, process$1.nextTick(ut, Mt));
  }
  function ut(Mt) {
    var Pt = Mt._readableState;
    ie("emitReadable_", Pt.destroyed, Pt.length, Pt.ended), !Pt.destroyed && (Pt.length || Pt.ended) && (Mt.emit("readable"), Pt.emittedReadable = !1), Pt.needReadable = !Pt.flowing && !Pt.ended && Pt.length <= Pt.highWaterMark, Ot(Mt);
  }
  function pt(Mt, Pt) {
    Pt.readingMore || (Pt.readingMore = !0, process$1.nextTick(ft, Mt, Pt));
  }
  function ft(Mt, Pt) {
    for (; !Pt.reading && !Pt.ended && (Pt.length < Pt.highWaterMark || Pt.flowing && Pt.length === 0); ) {
      var Kt = Pt.length;
      if (ie("maybeReadMore read 0"), Mt.read(0), Kt === Pt.length)
        break;
    }
    Pt.readingMore = !1;
  }
  mt.prototype._read = function(Mt) {
    Bt(this, new lt("_read()"));
  }, mt.prototype.pipe = function(Mt, Pt) {
    var Kt = this, Zt = this._readableState;
    switch (Zt.pipesCount) {
      case 0:
        Zt.pipes = Mt;
        break;
      case 1:
        Zt.pipes = [Zt.pipes, Mt];
        break;
      default:
        Zt.pipes.push(Mt);
        break;
    }
    Zt.pipesCount += 1, ie("pipe count=%d opts=%j", Zt.pipesCount, Pt);
    var rr = (!Pt || Pt.end !== !1) && Mt !== process$1.stdout && Mt !== process$1.stderr, ar = rr ? hr : Pr;
    Zt.endEmitted ? process$1.nextTick(ar) : Kt.once("end", ar), Mt.on("unpipe", ur);
    function ur(br, Mr) {
      ie("onunpipe"), br === Kt && Mr && Mr.hasUnpiped === !1 && (Mr.hasUnpiped = !0, lr());
    }
    function hr() {
      ie("onend"), Mt.end();
    }
    var Yt = yt(Kt);
    Mt.on("drain", Yt);
    var Ir = !1;
    function lr() {
      ie("cleanup"), Mt.removeListener("close", dr), Mt.removeListener("finish", Er), Mt.removeListener("drain", Yt), Mt.removeListener("error", Br), Mt.removeListener("unpipe", ur), Kt.removeListener("end", hr), Kt.removeListener("end", Pr), Kt.removeListener("data", Ar), Ir = !0, Zt.awaitDrain && (!Mt._writableState || Mt._writableState.needDrain) && Yt();
    }
    Kt.on("data", Ar);
    function Ar(br) {
      ie("ondata");
      var Mr = Mt.write(br);
      ie("dest.write", Mr), Mr === !1 && ((Zt.pipesCount === 1 && Zt.pipes === Mt || Zt.pipesCount > 1 && Gt(Zt.pipes, Mt) !== -1) && !Ir && (ie("false write response, pause", Zt.awaitDrain), Zt.awaitDrain++), Kt.pause());
    }
    function Br(br) {
      ie("onerror", br), Pr(), Mt.removeListener("error", Br), B(Mt, "error") === 0 && Bt(Mt, br);
    }
    Nt(Mt, "error", Br);
    function dr() {
      Mt.removeListener("finish", Er), Pr();
    }
    Mt.once("close", dr);
    function Er() {
      ie("onfinish"), Mt.removeListener("close", dr), Pr();
    }
    Mt.once("finish", Er);
    function Pr() {
      ie("unpipe"), Kt.unpipe(Mt);
    }
    return Mt.emit("pipe", Kt), Zt.flowing || (ie("pipe resume"), Kt.resume()), Mt;
  };
  function yt(Mt) {
    return function() {
      var Kt = Mt._readableState;
      ie("pipeOnDrain", Kt.awaitDrain), Kt.awaitDrain && Kt.awaitDrain--, Kt.awaitDrain === 0 && B(Mt, "data") && (Kt.flowing = !0, Ot(Mt));
    };
  }
  mt.prototype.unpipe = function(Mt) {
    var Pt = this._readableState, Kt = {
      hasUnpiped: !1
    };
    if (Pt.pipesCount === 0) return this;
    if (Pt.pipesCount === 1)
      return Mt && Mt !== Pt.pipes ? this : (Mt || (Mt = Pt.pipes), Pt.pipes = null, Pt.pipesCount = 0, Pt.flowing = !1, Mt && Mt.emit("unpipe", this, Kt), this);
    if (!Mt) {
      var Zt = Pt.pipes, rr = Pt.pipesCount;
      Pt.pipes = null, Pt.pipesCount = 0, Pt.flowing = !1;
      for (var ar = 0; ar < rr; ar++) Zt[ar].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ur = Gt(Pt.pipes, Mt);
    return ur === -1 ? this : (Pt.pipes.splice(ur, 1), Pt.pipesCount -= 1, Pt.pipesCount === 1 && (Pt.pipes = Pt.pipes[0]), Mt.emit("unpipe", this, Kt), this);
  }, mt.prototype.on = function(Mt, Pt) {
    var Kt = L.prototype.on.call(this, Mt, Pt), Zt = this._readableState;
    return Mt === "data" ? (Zt.readableListening = this.listenerCount("readable") > 0, Zt.flowing !== !1 && this.resume()) : Mt === "readable" && !Zt.endEmitted && !Zt.readableListening && (Zt.readableListening = Zt.needReadable = !0, Zt.flowing = !1, Zt.emittedReadable = !1, ie("on readable", Zt.length, Zt.reading), Zt.length ? st(this) : Zt.reading || process$1.nextTick(St, this)), Kt;
  }, mt.prototype.addListener = mt.prototype.on, mt.prototype.removeListener = function(Mt, Pt) {
    var Kt = L.prototype.removeListener.call(this, Mt, Pt);
    return Mt === "readable" && process$1.nextTick(ct, this), Kt;
  }, mt.prototype.removeAllListeners = function(Mt) {
    var Pt = L.prototype.removeAllListeners.apply(this, arguments);
    return (Mt === "readable" || Mt === void 0) && process$1.nextTick(ct, this), Pt;
  };
  function ct(Mt) {
    var Pt = Mt._readableState;
    Pt.readableListening = Mt.listenerCount("readable") > 0, Pt.resumeScheduled && !Pt.paused ? Pt.flowing = !0 : Mt.listenerCount("data") > 0 && Mt.resume();
  }
  function St(Mt) {
    ie("readable nexttick read 0"), Mt.read(0);
  }
  mt.prototype.resume = function() {
    var Mt = this._readableState;
    return Mt.flowing || (ie("resume"), Mt.flowing = !Mt.readableListening, qt(this, Mt)), Mt.paused = !1, this;
  };
  function qt(Mt, Pt) {
    Pt.resumeScheduled || (Pt.resumeScheduled = !0, process$1.nextTick(jt, Mt, Pt));
  }
  function jt(Mt, Pt) {
    ie("resume", Pt.reading), Pt.reading || Mt.read(0), Pt.resumeScheduled = !1, Mt.emit("resume"), Ot(Mt), Pt.flowing && !Pt.reading && Mt.read(0);
  }
  mt.prototype.pause = function() {
    return ie("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ie("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Ot(Mt) {
    var Pt = Mt._readableState;
    for (ie("flow", Pt.flowing); Pt.flowing && Mt.read() !== null; ) ;
  }
  mt.prototype.wrap = function(Mt) {
    var Pt = this, Kt = this._readableState, Zt = !1;
    Mt.on("end", function() {
      if (ie("wrapped end"), Kt.decoder && !Kt.ended) {
        var ur = Kt.decoder.end();
        ur && ur.length && Pt.push(ur);
      }
      Pt.push(null);
    }), Mt.on("data", function(ur) {
      if (ie("wrapped data"), Kt.decoder && (ur = Kt.decoder.write(ur)), !(Kt.objectMode && ur == null) && !(!Kt.objectMode && (!ur || !ur.length))) {
        var hr = Pt.push(ur);
        hr || (Zt = !0, Mt.pause());
      }
    });
    for (var rr in Mt)
      this[rr] === void 0 && typeof Mt[rr] == "function" && (this[rr] = /* @__PURE__ */ function(hr) {
        return function() {
          return Mt[hr].apply(Mt, arguments);
        };
      }(rr));
    for (var ar = 0; ar < At.length; ar++)
      Mt.on(At[ar], this.emit.bind(this, At[ar]));
    return this._read = function(ur) {
      ie("wrapped _read", ur), Zt && (Zt = !1, Mt.resume());
    }, this;
  }, typeof Symbol == "function" && (mt.prototype[Symbol.asyncIterator] = function() {
    return bt === void 0 && (bt = requireAsync_iterator()), bt(this);
  }), Object.defineProperty(mt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(mt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(mt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Pt) {
      this._readableState && (this._readableState.flowing = Pt);
    }
  }), mt._fromList = Tt, Object.defineProperty(mt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Tt(Mt, Pt) {
    if (Pt.length === 0) return null;
    var Kt;
    return Pt.objectMode ? Kt = Pt.buffer.shift() : !Mt || Mt >= Pt.length ? (Pt.decoder ? Kt = Pt.buffer.join("") : Pt.buffer.length === 1 ? Kt = Pt.buffer.first() : Kt = Pt.buffer.concat(Pt.length), Pt.buffer.clear()) : Kt = Pt.buffer.consume(Mt, Pt.decoder), Kt;
  }
  function Rt(Mt) {
    var Pt = Mt._readableState;
    ie("endReadable", Pt.endEmitted), Pt.endEmitted || (Pt.ended = !0, process$1.nextTick(Ut, Pt, Mt));
  }
  function Ut(Mt, Pt) {
    if (ie("endReadableNT", Mt.endEmitted, Mt.length), !Mt.endEmitted && Mt.length === 0 && (Mt.endEmitted = !0, Pt.readable = !1, Pt.emit("end"), Mt.autoDestroy)) {
      var Kt = Pt._writableState;
      (!Kt || Kt.autoDestroy && Kt.finished) && Pt.destroy();
    }
  }
  typeof Symbol == "function" && (mt.from = function(Mt, Pt) {
    return vt === void 0 && (vt = requireFromBrowser()), vt(mt, Mt, Pt);
  });
  function Gt(Mt, Pt) {
    for (var Kt = 0, Zt = Mt.length; Kt < Zt; Kt++)
      if (Mt[Kt] === Pt) return Kt;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ne;
  var A = requireErrorsBrowser().codes, B = A.ERR_METHOD_NOT_IMPLEMENTED, L = A.ERR_MULTIPLE_CALLBACK, K = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, re = A.ERR_TRANSFORM_WITH_LENGTH_0, W = require_stream_duplex$1();
  requireInherits_browser()(ne, W);
  function J(V, ce) {
    var ke = this._transformState;
    ke.transforming = !1;
    var Ce = ke.writecb;
    if (Ce === null)
      return this.emit("error", new L());
    ke.writechunk = null, ke.writecb = null, ce != null && this.push(ce), Ce(V);
    var it = this._readableState;
    it.reading = !1, (it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
  }
  function ne(V) {
    if (!(this instanceof ne)) return new ne(V);
    W.call(this, V), this._transformState = {
      afterTransform: J.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, V && (typeof V.transform == "function" && (this._transform = V.transform), typeof V.flush == "function" && (this._flush = V.flush)), this.on("prefinish", ie);
  }
  function ie() {
    var V = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(ce, ke) {
      oe(V, ce, ke);
    }) : oe(this, null, null);
  }
  ne.prototype.push = function(V, ce) {
    return this._transformState.needTransform = !1, W.prototype.push.call(this, V, ce);
  }, ne.prototype._transform = function(V, ce, ke) {
    ke(new B("_transform()"));
  }, ne.prototype._write = function(V, ce, ke) {
    var Ce = this._transformState;
    if (Ce.writecb = ke, Ce.writechunk = V, Ce.writeencoding = ce, !Ce.transforming) {
      var it = this._readableState;
      (Ce.needTransform || it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
    }
  }, ne.prototype._read = function(V) {
    var ce = this._transformState;
    ce.writechunk !== null && !ce.transforming ? (ce.transforming = !0, this._transform(ce.writechunk, ce.writeencoding, ce.afterTransform)) : ce.needTransform = !0;
  }, ne.prototype._destroy = function(V, ce) {
    W.prototype._destroy.call(this, V, function(ke) {
      ce(ke);
    });
  };
  function oe(V, ce, ke) {
    if (ce) return V.emit("error", ce);
    if (ke != null && V.push(ke), V._writableState.length) throw new re();
    if (V._transformState.transforming) throw new K();
    return V.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = B;
  var A = require_stream_transform$1();
  requireInherits_browser()(B, A);
  function B(L) {
    if (!(this instanceof B)) return new B(L);
    A.call(this, L);
  }
  return B.prototype._transform = function(L, K, re) {
    re(null, L);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var A;
  function B(ke) {
    var Ce = !1;
    return function() {
      Ce || (Ce = !0, ke.apply(void 0, arguments));
    };
  }
  var L = requireErrorsBrowser().codes, K = L.ERR_MISSING_ARGS, re = L.ERR_STREAM_DESTROYED;
  function W(ke) {
    if (ke) throw ke;
  }
  function J(ke) {
    return ke.setHeader && typeof ke.abort == "function";
  }
  function ne(ke, Ce, it, at) {
    at = B(at);
    var lt = !1;
    ke.on("close", function() {
      lt = !0;
    }), A === void 0 && (A = requireEndOfStream()), A(ke, {
      readable: Ce,
      writable: it
    }, function(dt) {
      if (dt) return at(dt);
      lt = !0, at();
    });
    var ht = !1;
    return function(dt) {
      if (!lt && !ht) {
        if (ht = !0, J(ke)) return ke.abort();
        if (typeof ke.destroy == "function") return ke.destroy();
        at(dt || new re("pipe"));
      }
    };
  }
  function ie(ke) {
    ke();
  }
  function oe(ke, Ce) {
    return ke.pipe(Ce);
  }
  function V(ke) {
    return !ke.length || typeof ke[ke.length - 1] != "function" ? W : ke.pop();
  }
  function ce() {
    for (var ke = arguments.length, Ce = new Array(ke), it = 0; it < ke; it++)
      Ce[it] = arguments[it];
    var at = V(Ce);
    if (Array.isArray(Ce[0]) && (Ce = Ce[0]), Ce.length < 2)
      throw new K("streams");
    var lt, ht = Ce.map(function(dt, bt) {
      var vt = bt < Ce.length - 1, Bt = bt > 0;
      return ne(dt, vt, Bt, function(At) {
        lt || (lt = At), At && ht.forEach(ie), !vt && (ht.forEach(ie), at(lt));
      });
    });
    return Ce.reduce(oe);
  }
  return pipeline_1 = ce, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(A, B) {
    B = A.exports = require_stream_readable$1(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable$1(), B.Duplex = require_stream_duplex$1(), B.Transform = require_stream_transform$1(), B.PassThrough = require_stream_passthrough$1(), B.finished = requireEndOfStream(), B.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var A = safeBufferExports.Buffer, B = requireReadableBrowser$1().Transform, L = requireInherits_browser();
  function K(W, J) {
    if (!A.isBuffer(W) && typeof W != "string")
      throw new TypeError(J + " must be a string or a buffer");
  }
  function re(W) {
    B.call(this), this._block = A.allocUnsafe(W), this._blockSize = W, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return L(re, B), re.prototype._transform = function(W, J, ne) {
    var ie = null;
    try {
      this.update(W, J);
    } catch (oe) {
      ie = oe;
    }
    ne(ie);
  }, re.prototype._flush = function(W) {
    var J = null;
    try {
      this.push(this.digest());
    } catch (ne) {
      J = ne;
    }
    W(J);
  }, re.prototype.update = function(W, J) {
    if (K(W, "Data"), this._finalized) throw new Error("Digest already called");
    A.isBuffer(W) || (W = A.from(W, J));
    for (var ne = this._block, ie = 0; this._blockOffset + W.length - ie >= this._blockSize; ) {
      for (var oe = this._blockOffset; oe < this._blockSize; ) ne[oe++] = W[ie++];
      this._update(), this._blockOffset = 0;
    }
    for (; ie < W.length; ) ne[this._blockOffset++] = W[ie++];
    for (var V = 0, ce = W.length * 8; ce > 0; ++V)
      this._length[V] += ce, ce = this._length[V] / 4294967296 | 0, ce > 0 && (this._length[V] -= 4294967296 * ce);
    return this;
  }, re.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, re.prototype.digest = function(W) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var J = this._digest();
    W !== void 0 && (J = J.toString(W)), this._block.fill(0), this._blockOffset = 0;
    for (var ne = 0; ne < 4; ++ne) this._length[ne] = 0;
    return J;
  }, re.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = re, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var A = requireInherits_browser(), B = requireHashBase(), L = safeBufferExports.Buffer, K = new Array(16);
  function re() {
    B.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  A(re, B), re.prototype._update = function() {
    for (var V = K, ce = 0; ce < 16; ++ce) V[ce] = this._block.readInt32LE(ce * 4);
    var ke = this._a, Ce = this._b, it = this._c, at = this._d;
    ke = J(ke, Ce, it, at, V[0], 3614090360, 7), at = J(at, ke, Ce, it, V[1], 3905402710, 12), it = J(it, at, ke, Ce, V[2], 606105819, 17), Ce = J(Ce, it, at, ke, V[3], 3250441966, 22), ke = J(ke, Ce, it, at, V[4], 4118548399, 7), at = J(at, ke, Ce, it, V[5], 1200080426, 12), it = J(it, at, ke, Ce, V[6], 2821735955, 17), Ce = J(Ce, it, at, ke, V[7], 4249261313, 22), ke = J(ke, Ce, it, at, V[8], 1770035416, 7), at = J(at, ke, Ce, it, V[9], 2336552879, 12), it = J(it, at, ke, Ce, V[10], 4294925233, 17), Ce = J(Ce, it, at, ke, V[11], 2304563134, 22), ke = J(ke, Ce, it, at, V[12], 1804603682, 7), at = J(at, ke, Ce, it, V[13], 4254626195, 12), it = J(it, at, ke, Ce, V[14], 2792965006, 17), Ce = J(Ce, it, at, ke, V[15], 1236535329, 22), ke = ne(ke, Ce, it, at, V[1], 4129170786, 5), at = ne(at, ke, Ce, it, V[6], 3225465664, 9), it = ne(it, at, ke, Ce, V[11], 643717713, 14), Ce = ne(Ce, it, at, ke, V[0], 3921069994, 20), ke = ne(ke, Ce, it, at, V[5], 3593408605, 5), at = ne(at, ke, Ce, it, V[10], 38016083, 9), it = ne(it, at, ke, Ce, V[15], 3634488961, 14), Ce = ne(Ce, it, at, ke, V[4], 3889429448, 20), ke = ne(ke, Ce, it, at, V[9], 568446438, 5), at = ne(at, ke, Ce, it, V[14], 3275163606, 9), it = ne(it, at, ke, Ce, V[3], 4107603335, 14), Ce = ne(Ce, it, at, ke, V[8], 1163531501, 20), ke = ne(ke, Ce, it, at, V[13], 2850285829, 5), at = ne(at, ke, Ce, it, V[2], 4243563512, 9), it = ne(it, at, ke, Ce, V[7], 1735328473, 14), Ce = ne(Ce, it, at, ke, V[12], 2368359562, 20), ke = ie(ke, Ce, it, at, V[5], 4294588738, 4), at = ie(at, ke, Ce, it, V[8], 2272392833, 11), it = ie(it, at, ke, Ce, V[11], 1839030562, 16), Ce = ie(Ce, it, at, ke, V[14], 4259657740, 23), ke = ie(ke, Ce, it, at, V[1], 2763975236, 4), at = ie(at, ke, Ce, it, V[4], 1272893353, 11), it = ie(it, at, ke, Ce, V[7], 4139469664, 16), Ce = ie(Ce, it, at, ke, V[10], 3200236656, 23), ke = ie(ke, Ce, it, at, V[13], 681279174, 4), at = ie(at, ke, Ce, it, V[0], 3936430074, 11), it = ie(it, at, ke, Ce, V[3], 3572445317, 16), Ce = ie(Ce, it, at, ke, V[6], 76029189, 23), ke = ie(ke, Ce, it, at, V[9], 3654602809, 4), at = ie(at, ke, Ce, it, V[12], 3873151461, 11), it = ie(it, at, ke, Ce, V[15], 530742520, 16), Ce = ie(Ce, it, at, ke, V[2], 3299628645, 23), ke = oe(ke, Ce, it, at, V[0], 4096336452, 6), at = oe(at, ke, Ce, it, V[7], 1126891415, 10), it = oe(it, at, ke, Ce, V[14], 2878612391, 15), Ce = oe(Ce, it, at, ke, V[5], 4237533241, 21), ke = oe(ke, Ce, it, at, V[12], 1700485571, 6), at = oe(at, ke, Ce, it, V[3], 2399980690, 10), it = oe(it, at, ke, Ce, V[10], 4293915773, 15), Ce = oe(Ce, it, at, ke, V[1], 2240044497, 21), ke = oe(ke, Ce, it, at, V[8], 1873313359, 6), at = oe(at, ke, Ce, it, V[15], 4264355552, 10), it = oe(it, at, ke, Ce, V[6], 2734768916, 15), Ce = oe(Ce, it, at, ke, V[13], 1309151649, 21), ke = oe(ke, Ce, it, at, V[4], 4149444226, 6), at = oe(at, ke, Ce, it, V[11], 3174756917, 10), it = oe(it, at, ke, Ce, V[2], 718787259, 15), Ce = oe(Ce, it, at, ke, V[9], 3951481745, 21), this._a = this._a + ke | 0, this._b = this._b + Ce | 0, this._c = this._c + it | 0, this._d = this._d + at | 0;
  }, re.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var V = L.allocUnsafe(16);
    return V.writeInt32LE(this._a, 0), V.writeInt32LE(this._b, 4), V.writeInt32LE(this._c, 8), V.writeInt32LE(this._d, 12), V;
  };
  function W(V, ce) {
    return V << ce | V >>> 32 - ce;
  }
  function J(V, ce, ke, Ce, it, at, lt) {
    return W(V + (ce & ke | ~ce & Ce) + it + at | 0, lt) + ce | 0;
  }
  function ne(V, ce, ke, Ce, it, at, lt) {
    return W(V + (ce & Ce | ke & ~Ce) + it + at | 0, lt) + ce | 0;
  }
  function ie(V, ce, ke, Ce, it, at, lt) {
    return W(V + (ce ^ ke ^ Ce) + it + at | 0, lt) + ce | 0;
  }
  function oe(V, ce, ke, Ce, it, at, lt) {
    return W(V + (ke ^ (ce | ~Ce)) + it + at | 0, lt) + ce | 0;
  }
  return md5_js = re, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var A = require$$0$1.Buffer, B = requireInherits_browser(), L = requireHashBase(), K = new Array(16), re = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], W = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], J = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ne = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ie = [0, 1518500249, 1859775393, 2400959708, 2840853838], oe = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function V() {
    L.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  B(V, L), V.prototype._update = function() {
    for (var ht = K, dt = 0; dt < 16; ++dt) ht[dt] = this._block.readInt32LE(dt * 4);
    for (var bt = this._a | 0, vt = this._b | 0, Bt = this._c | 0, At = this._d | 0, Nt = this._e | 0, $t = this._a | 0, mt = this._b | 0, xt = this._c | 0, wt = this._d | 0, Oe = this._e | 0, rt = 0; rt < 80; rt += 1) {
      var pe, nt;
      rt < 16 ? (pe = ke(bt, vt, Bt, At, Nt, ht[re[rt]], ie[0], J[rt]), nt = lt($t, mt, xt, wt, Oe, ht[W[rt]], oe[0], ne[rt])) : rt < 32 ? (pe = Ce(bt, vt, Bt, At, Nt, ht[re[rt]], ie[1], J[rt]), nt = at($t, mt, xt, wt, Oe, ht[W[rt]], oe[1], ne[rt])) : rt < 48 ? (pe = it(bt, vt, Bt, At, Nt, ht[re[rt]], ie[2], J[rt]), nt = it($t, mt, xt, wt, Oe, ht[W[rt]], oe[2], ne[rt])) : rt < 64 ? (pe = at(bt, vt, Bt, At, Nt, ht[re[rt]], ie[3], J[rt]), nt = Ce($t, mt, xt, wt, Oe, ht[W[rt]], oe[3], ne[rt])) : (pe = lt(bt, vt, Bt, At, Nt, ht[re[rt]], ie[4], J[rt]), nt = ke($t, mt, xt, wt, Oe, ht[W[rt]], oe[4], ne[rt])), bt = Nt, Nt = At, At = ce(Bt, 10), Bt = vt, vt = pe, $t = Oe, Oe = wt, wt = ce(xt, 10), xt = mt, mt = nt;
    }
    var ot = this._b + Bt + wt | 0;
    this._b = this._c + At + Oe | 0, this._c = this._d + Nt + $t | 0, this._d = this._e + bt + mt | 0, this._e = this._a + vt + xt | 0, this._a = ot;
  }, V.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var ht = A.alloc ? A.alloc(20) : new A(20);
    return ht.writeInt32LE(this._a, 0), ht.writeInt32LE(this._b, 4), ht.writeInt32LE(this._c, 8), ht.writeInt32LE(this._d, 12), ht.writeInt32LE(this._e, 16), ht;
  };
  function ce(ht, dt) {
    return ht << dt | ht >>> 32 - dt;
  }
  function ke(ht, dt, bt, vt, Bt, At, Nt, $t) {
    return ce(ht + (dt ^ bt ^ vt) + At + Nt | 0, $t) + Bt | 0;
  }
  function Ce(ht, dt, bt, vt, Bt, At, Nt, $t) {
    return ce(ht + (dt & bt | ~dt & vt) + At + Nt | 0, $t) + Bt | 0;
  }
  function it(ht, dt, bt, vt, Bt, At, Nt, $t) {
    return ce(ht + ((dt | ~bt) ^ vt) + At + Nt | 0, $t) + Bt | 0;
  }
  function at(ht, dt, bt, vt, Bt, At, Nt, $t) {
    return ce(ht + (dt & vt | bt & ~vt) + At + Nt | 0, $t) + Bt | 0;
  }
  function lt(ht, dt, bt, vt, Bt, At, Nt, $t) {
    return ce(ht + (dt ^ (bt | ~vt)) + At + Nt | 0, $t) + Bt | 0;
  }
  return ripemd160$1 = V, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K) {
    this._block = A.alloc(L), this._finalSize = K, this._blockSize = L, this._len = 0;
  }
  return B.prototype.update = function(L, K) {
    typeof L == "string" && (K = K || "utf8", L = A.from(L, K));
    for (var re = this._block, W = this._blockSize, J = L.length, ne = this._len, ie = 0; ie < J; ) {
      for (var oe = ne % W, V = Math.min(J - ie, W - oe), ce = 0; ce < V; ce++)
        re[oe + ce] = L[ie + ce];
      ne += V, ie += V, ne % W === 0 && this._update(re);
    }
    return this._len += J, this;
  }, B.prototype.digest = function(L) {
    var K = this._len % this._blockSize;
    this._block[K] = 128, this._block.fill(0, K + 1), K >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var re = this._len * 8;
    if (re <= 4294967295)
      this._block.writeUInt32BE(re, this._blockSize - 4);
    else {
      var W = (re & 4294967295) >>> 0, J = (re - W) / 4294967296;
      this._block.writeUInt32BE(J, this._blockSize - 8), this._block.writeUInt32BE(W, this._blockSize - 4);
    }
    this._update(this._block);
    var ne = this._hash();
    return L ? ne.toString(L) : ne;
  }, B.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = B, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], re = new Array(80);
  function W() {
    this.init(), this._w = re, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function J(oe) {
    return oe << 5 | oe >>> 27;
  }
  function ne(oe) {
    return oe << 30 | oe >>> 2;
  }
  function ie(oe, V, ce, ke) {
    return oe === 0 ? V & ce | ~V & ke : oe === 2 ? V & ce | V & ke | ce & ke : V ^ ce ^ ke;
  }
  return W.prototype._update = function(oe) {
    for (var V = this._w, ce = this._a | 0, ke = this._b | 0, Ce = this._c | 0, it = this._d | 0, at = this._e | 0, lt = 0; lt < 16; ++lt) V[lt] = oe.readInt32BE(lt * 4);
    for (; lt < 80; ++lt) V[lt] = V[lt - 3] ^ V[lt - 8] ^ V[lt - 14] ^ V[lt - 16];
    for (var ht = 0; ht < 80; ++ht) {
      var dt = ~~(ht / 20), bt = J(ce) + ie(dt, ke, Ce, it) + at + V[ht] + K[dt] | 0;
      at = it, it = Ce, Ce = ne(ke), ke = ce, ce = bt;
    }
    this._a = ce + this._a | 0, this._b = ke + this._b | 0, this._c = Ce + this._c | 0, this._d = it + this._d | 0, this._e = at + this._e | 0;
  }, W.prototype._hash = function() {
    var oe = L.allocUnsafe(20);
    return oe.writeInt32BE(this._a | 0, 0), oe.writeInt32BE(this._b | 0, 4), oe.writeInt32BE(this._c | 0, 8), oe.writeInt32BE(this._d | 0, 12), oe.writeInt32BE(this._e | 0, 16), oe;
  }, sha$1 = W, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], re = new Array(80);
  function W() {
    this.init(), this._w = re, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function J(V) {
    return V << 1 | V >>> 31;
  }
  function ne(V) {
    return V << 5 | V >>> 27;
  }
  function ie(V) {
    return V << 30 | V >>> 2;
  }
  function oe(V, ce, ke, Ce) {
    return V === 0 ? ce & ke | ~ce & Ce : V === 2 ? ce & ke | ce & Ce | ke & Ce : ce ^ ke ^ Ce;
  }
  return W.prototype._update = function(V) {
    for (var ce = this._w, ke = this._a | 0, Ce = this._b | 0, it = this._c | 0, at = this._d | 0, lt = this._e | 0, ht = 0; ht < 16; ++ht) ce[ht] = V.readInt32BE(ht * 4);
    for (; ht < 80; ++ht) ce[ht] = J(ce[ht - 3] ^ ce[ht - 8] ^ ce[ht - 14] ^ ce[ht - 16]);
    for (var dt = 0; dt < 80; ++dt) {
      var bt = ~~(dt / 20), vt = ne(ke) + oe(bt, Ce, it, at) + lt + ce[dt] + K[bt] | 0;
      lt = at, at = it, it = ie(Ce), Ce = ke, ke = vt;
    }
    this._a = ke + this._a | 0, this._b = Ce + this._b | 0, this._c = it + this._c | 0, this._d = at + this._d | 0, this._e = lt + this._e | 0;
  }, W.prototype._hash = function() {
    var V = L.allocUnsafe(20);
    return V.writeInt32BE(this._a | 0, 0), V.writeInt32BE(this._b | 0, 4), V.writeInt32BE(this._c | 0, 8), V.writeInt32BE(this._d | 0, 12), V.writeInt32BE(this._e | 0, 16), V;
  }, sha1$1 = W, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], re = new Array(64);
  function W() {
    this.init(), this._w = re, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function J(ke, Ce, it) {
    return it ^ ke & (Ce ^ it);
  }
  function ne(ke, Ce, it) {
    return ke & Ce | it & (ke | Ce);
  }
  function ie(ke) {
    return (ke >>> 2 | ke << 30) ^ (ke >>> 13 | ke << 19) ^ (ke >>> 22 | ke << 10);
  }
  function oe(ke) {
    return (ke >>> 6 | ke << 26) ^ (ke >>> 11 | ke << 21) ^ (ke >>> 25 | ke << 7);
  }
  function V(ke) {
    return (ke >>> 7 | ke << 25) ^ (ke >>> 18 | ke << 14) ^ ke >>> 3;
  }
  function ce(ke) {
    return (ke >>> 17 | ke << 15) ^ (ke >>> 19 | ke << 13) ^ ke >>> 10;
  }
  return W.prototype._update = function(ke) {
    for (var Ce = this._w, it = this._a | 0, at = this._b | 0, lt = this._c | 0, ht = this._d | 0, dt = this._e | 0, bt = this._f | 0, vt = this._g | 0, Bt = this._h | 0, At = 0; At < 16; ++At) Ce[At] = ke.readInt32BE(At * 4);
    for (; At < 64; ++At) Ce[At] = ce(Ce[At - 2]) + Ce[At - 7] + V(Ce[At - 15]) + Ce[At - 16] | 0;
    for (var Nt = 0; Nt < 64; ++Nt) {
      var $t = Bt + oe(dt) + J(dt, bt, vt) + K[Nt] + Ce[Nt] | 0, mt = ie(it) + ne(it, at, lt) | 0;
      Bt = vt, vt = bt, bt = dt, dt = ht + $t | 0, ht = lt, lt = at, at = it, it = $t + mt | 0;
    }
    this._a = it + this._a | 0, this._b = at + this._b | 0, this._c = lt + this._c | 0, this._d = ht + this._d | 0, this._e = dt + this._e | 0, this._f = bt + this._f | 0, this._g = vt + this._g | 0, this._h = Bt + this._h | 0;
  }, W.prototype._hash = function() {
    var ke = L.allocUnsafe(32);
    return ke.writeInt32BE(this._a, 0), ke.writeInt32BE(this._b, 4), ke.writeInt32BE(this._c, 8), ke.writeInt32BE(this._d, 12), ke.writeInt32BE(this._e, 16), ke.writeInt32BE(this._f, 20), ke.writeInt32BE(this._g, 24), ke.writeInt32BE(this._h, 28), ke;
  }, sha256$3 = W, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var A = requireInherits_browser(), B = requireSha256(), L = requireHash$1(), K = safeBufferExports.Buffer, re = new Array(64);
  function W() {
    this.init(), this._w = re, L.call(this, 64, 56);
  }
  return A(W, B), W.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, W.prototype._hash = function() {
    var J = K.allocUnsafe(28);
    return J.writeInt32BE(this._a, 0), J.writeInt32BE(this._b, 4), J.writeInt32BE(this._c, 8), J.writeInt32BE(this._d, 12), J.writeInt32BE(this._e, 16), J.writeInt32BE(this._f, 20), J.writeInt32BE(this._g, 24), J;
  }, sha224$1 = W, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], re = new Array(160);
  function W() {
    this.init(), this._w = re, B.call(this, 128, 112);
  }
  A(W, B), W.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function J(at, lt, ht) {
    return ht ^ at & (lt ^ ht);
  }
  function ne(at, lt, ht) {
    return at & lt | ht & (at | lt);
  }
  function ie(at, lt) {
    return (at >>> 28 | lt << 4) ^ (lt >>> 2 | at << 30) ^ (lt >>> 7 | at << 25);
  }
  function oe(at, lt) {
    return (at >>> 14 | lt << 18) ^ (at >>> 18 | lt << 14) ^ (lt >>> 9 | at << 23);
  }
  function V(at, lt) {
    return (at >>> 1 | lt << 31) ^ (at >>> 8 | lt << 24) ^ at >>> 7;
  }
  function ce(at, lt) {
    return (at >>> 1 | lt << 31) ^ (at >>> 8 | lt << 24) ^ (at >>> 7 | lt << 25);
  }
  function ke(at, lt) {
    return (at >>> 19 | lt << 13) ^ (lt >>> 29 | at << 3) ^ at >>> 6;
  }
  function Ce(at, lt) {
    return (at >>> 19 | lt << 13) ^ (lt >>> 29 | at << 3) ^ (at >>> 6 | lt << 26);
  }
  function it(at, lt) {
    return at >>> 0 < lt >>> 0 ? 1 : 0;
  }
  return W.prototype._update = function(at) {
    for (var lt = this._w, ht = this._ah | 0, dt = this._bh | 0, bt = this._ch | 0, vt = this._dh | 0, Bt = this._eh | 0, At = this._fh | 0, Nt = this._gh | 0, $t = this._hh | 0, mt = this._al | 0, xt = this._bl | 0, wt = this._cl | 0, Oe = this._dl | 0, rt = this._el | 0, pe = this._fl | 0, nt = this._gl | 0, ot = this._hl | 0, st = 0; st < 32; st += 2)
      lt[st] = at.readInt32BE(st * 4), lt[st + 1] = at.readInt32BE(st * 4 + 4);
    for (; st < 160; st += 2) {
      var ut = lt[st - 30], pt = lt[st - 15 * 2 + 1], ft = V(ut, pt), yt = ce(pt, ut);
      ut = lt[st - 2 * 2], pt = lt[st - 2 * 2 + 1];
      var ct = ke(ut, pt), St = Ce(pt, ut), qt = lt[st - 7 * 2], jt = lt[st - 7 * 2 + 1], Ot = lt[st - 16 * 2], Tt = lt[st - 16 * 2 + 1], Rt = yt + jt | 0, Ut = ft + qt + it(Rt, yt) | 0;
      Rt = Rt + St | 0, Ut = Ut + ct + it(Rt, St) | 0, Rt = Rt + Tt | 0, Ut = Ut + Ot + it(Rt, Tt) | 0, lt[st] = Ut, lt[st + 1] = Rt;
    }
    for (var Gt = 0; Gt < 160; Gt += 2) {
      Ut = lt[Gt], Rt = lt[Gt + 1];
      var Mt = ne(ht, dt, bt), Pt = ne(mt, xt, wt), Kt = ie(ht, mt), Zt = ie(mt, ht), rr = oe(Bt, rt), ar = oe(rt, Bt), ur = K[Gt], hr = K[Gt + 1], Yt = J(Bt, At, Nt), Ir = J(rt, pe, nt), lr = ot + ar | 0, Ar = $t + rr + it(lr, ot) | 0;
      lr = lr + Ir | 0, Ar = Ar + Yt + it(lr, Ir) | 0, lr = lr + hr | 0, Ar = Ar + ur + it(lr, hr) | 0, lr = lr + Rt | 0, Ar = Ar + Ut + it(lr, Rt) | 0;
      var Br = Zt + Pt | 0, dr = Kt + Mt + it(Br, Zt) | 0;
      $t = Nt, ot = nt, Nt = At, nt = pe, At = Bt, pe = rt, rt = Oe + lr | 0, Bt = vt + Ar + it(rt, Oe) | 0, vt = bt, Oe = wt, bt = dt, wt = xt, dt = ht, xt = mt, mt = lr + Br | 0, ht = Ar + dr + it(mt, lr) | 0;
    }
    this._al = this._al + mt | 0, this._bl = this._bl + xt | 0, this._cl = this._cl + wt | 0, this._dl = this._dl + Oe | 0, this._el = this._el + rt | 0, this._fl = this._fl + pe | 0, this._gl = this._gl + nt | 0, this._hl = this._hl + ot | 0, this._ah = this._ah + ht + it(this._al, mt) | 0, this._bh = this._bh + dt + it(this._bl, xt) | 0, this._ch = this._ch + bt + it(this._cl, wt) | 0, this._dh = this._dh + vt + it(this._dl, Oe) | 0, this._eh = this._eh + Bt + it(this._el, rt) | 0, this._fh = this._fh + At + it(this._fl, pe) | 0, this._gh = this._gh + Nt + it(this._gl, nt) | 0, this._hh = this._hh + $t + it(this._hl, ot) | 0;
  }, W.prototype._hash = function() {
    var at = L.allocUnsafe(64);
    function lt(ht, dt, bt) {
      at.writeInt32BE(ht, bt), at.writeInt32BE(dt, bt + 4);
    }
    return lt(this._ah, this._al, 0), lt(this._bh, this._bl, 8), lt(this._ch, this._cl, 16), lt(this._dh, this._dl, 24), lt(this._eh, this._el, 32), lt(this._fh, this._fl, 40), lt(this._gh, this._gl, 48), lt(this._hh, this._hl, 56), at;
  }, sha512$1 = W, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var A = requireInherits_browser(), B = requireSha512(), L = requireHash$1(), K = safeBufferExports.Buffer, re = new Array(160);
  function W() {
    this.init(), this._w = re, L.call(this, 128, 112);
  }
  return A(W, B), W.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, W.prototype._hash = function() {
    var J = K.allocUnsafe(48);
    function ne(ie, oe, V) {
      J.writeInt32BE(ie, V), J.writeInt32BE(oe, V + 4);
    }
    return ne(this._ah, this._al, 0), ne(this._bh, this._bl, 8), ne(this._ch, this._cl, 16), ne(this._dh, this._dl, 24), ne(this._eh, this._el, 32), ne(this._fh, this._fl, 40), J;
  }, sha384$1 = W, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var A = sha_js.exports = function(L) {
    L = L.toLowerCase();
    var K = A[L];
    if (!K) throw new Error(L + " is not supported (we accept pull requests)");
    return new K();
  };
  return A.sha = requireSha$1(), A.sha1 = requireSha1(), A.sha224 = requireSha224(), A.sha256 = requireSha256(), A.sha384 = requireSha384(), A.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = L;
  var A = requireEvents().EventEmitter, B = requireInherits_browser();
  B(L, A), L.Readable = require_stream_readable$1(), L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline(), L.Stream = L;
  function L() {
    A.call(this);
  }
  return L.prototype.pipe = function(K, re) {
    var W = this;
    function J(Ce) {
      K.writable && K.write(Ce) === !1 && W.pause && W.pause();
    }
    W.on("data", J);
    function ne() {
      W.readable && W.resume && W.resume();
    }
    K.on("drain", ne), !K._isStdio && (!re || re.end !== !1) && (W.on("end", oe), W.on("close", V));
    var ie = !1;
    function oe() {
      ie || (ie = !0, K.end());
    }
    function V() {
      ie || (ie = !0, typeof K.destroy == "function" && K.destroy());
    }
    function ce(Ce) {
      if (ke(), A.listenerCount(this, "error") === 0)
        throw Ce;
    }
    W.on("error", ce), K.on("error", ce);
    function ke() {
      W.removeListener("data", J), K.removeListener("drain", ne), W.removeListener("end", oe), W.removeListener("close", V), W.removeListener("error", ce), K.removeListener("error", ce), W.removeListener("end", ke), W.removeListener("close", ke), K.removeListener("close", ke);
    }
    return W.on("end", ke), W.on("close", ke), K.on("close", ke), K.emit("pipe", W), K;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var A = safeBufferExports.Buffer, B = requireStreamBrowserify().Transform, L = requireString_decoder().StringDecoder, K = requireInherits_browser();
  function re(W) {
    B.call(this), this.hashMode = typeof W == "string", this.hashMode ? this[W] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return K(re, B), re.prototype.update = function(W, J, ne) {
    typeof W == "string" && (W = A.from(W, J));
    var ie = this._update(W);
    return this.hashMode ? this : (ne && (ie = this._toString(ie, ne)), ie);
  }, re.prototype.setAutoPadding = function() {
  }, re.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, re.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, re.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, re.prototype._transform = function(W, J, ne) {
    var ie;
    try {
      this.hashMode ? this._update(W) : this.push(this._update(W));
    } catch (oe) {
      ie = oe;
    } finally {
      ne(ie);
    }
  }, re.prototype._flush = function(W) {
    var J;
    try {
      this.push(this.__final());
    } catch (ne) {
      J = ne;
    }
    W(J);
  }, re.prototype._finalOrDigest = function(W) {
    var J = this.__final() || A.alloc(0);
    return W && (J = this._toString(J, W, !0)), J;
  }, re.prototype._toString = function(W, J, ne) {
    if (this._decoder || (this._decoder = new L(J), this._encoding = J), this._encoding !== J) throw new Error("can't switch encodings");
    var ie = this._decoder.write(W);
    return ne && (ie += this._decoder.end()), ie;
  }, cipherBase = re, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var A = requireInherits_browser(), B = requireMd5_js(), L = requireRipemd160(), K = requireSha_js(), re = requireCipherBase();
  function W(J) {
    re.call(this, "digest"), this._hash = J;
  }
  return A(W, re), W.prototype._update = function(J) {
    this._hash.update(J);
  }, W.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(ne) {
    return ne = ne.toLowerCase(), ne === "md5" ? new B() : ne === "rmd160" || ne === "ripemd160" ? new L() : new W(K(ne));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var A = requireInherits_browser(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = B.alloc(128), re = 64;
  function W(J, ne) {
    L.call(this, "digest"), typeof ne == "string" && (ne = B.from(ne)), this._alg = J, this._key = ne, ne.length > re ? ne = J(ne) : ne.length < re && (ne = B.concat([ne, K], re));
    for (var ie = this._ipad = B.allocUnsafe(re), oe = this._opad = B.allocUnsafe(re), V = 0; V < re; V++)
      ie[V] = ne[V] ^ 54, oe[V] = ne[V] ^ 92;
    this._hash = [ie];
  }
  return A(W, L), W.prototype._update = function(J) {
    this._hash.push(J);
  }, W.prototype._final = function() {
    var J = this._alg(B.concat(this._hash));
    return this._alg(B.concat([this._opad, J]));
  }, legacy = W, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var A = requireMd5_js();
  return md5 = function(B) {
    return new A().update(B).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var A = requireInherits_browser(), B = requireLegacy(), L = requireCipherBase(), K = safeBufferExports.Buffer, re = requireMd5(), W = requireRipemd160(), J = requireSha_js(), ne = K.alloc(128);
  function ie(oe, V) {
    L.call(this, "digest"), typeof V == "string" && (V = K.from(V));
    var ce = oe === "sha512" || oe === "sha384" ? 128 : 64;
    if (this._alg = oe, this._key = V, V.length > ce) {
      var ke = oe === "rmd160" ? new W() : J(oe);
      V = ke.update(V).digest();
    } else V.length < ce && (V = K.concat([V, ne], ce));
    for (var Ce = this._ipad = K.allocUnsafe(ce), it = this._opad = K.allocUnsafe(ce), at = 0; at < ce; at++)
      Ce[at] = V[at] ^ 54, it[at] = V[at] ^ 92;
    this._hash = oe === "rmd160" ? new W() : J(oe), this._hash.update(Ce);
  }
  return A(ie, L), ie.prototype._update = function(oe) {
    this._hash.update(oe);
  }, ie.prototype._final = function() {
    var oe = this._hash.digest(), V = this._alg === "rmd160" ? new W() : J(this._alg);
    return V.update(this._opad).update(oe).digest();
  }, browser$8 = function(V, ce) {
    return V = V.toLowerCase(), V === "rmd160" || V === "ripemd160" ? new ie("rmd160", ce) : V === "md5" ? new B(re, ce) : new ie(V, ce);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var A = Math.pow(2, 30) - 1;
  return precondition = function(B, L) {
    if (typeof B != "number")
      throw new TypeError("Iterations not a number");
    if (B < 0)
      throw new TypeError("Bad iterations");
    if (typeof L != "number")
      throw new TypeError("Key length not a number");
    if (L < 0 || L > A || L !== L)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var A;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    A = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var B = parseInt(process$1.version.split(".")[0].slice(1), 10);
    A = B >= 6 ? "utf-8" : "binary";
  } else
    A = "utf-8";
  return defaultEncoding_1 = A, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var A = safeBufferExports.Buffer;
  return toBuffer$1 = function(B, L, K) {
    if (A.isBuffer(B))
      return B;
    if (typeof B == "string")
      return A.from(B, L);
    if (ArrayBuffer.isView(B))
      return A.from(B.buffer);
    throw new TypeError(K + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var A = requireMd5(), B = requireRipemd160(), L = requireSha_js(), K = safeBufferExports.Buffer, re = requirePrecondition(), W = requireDefaultEncoding(), J = requireToBuffer(), ne = K.alloc(128), ie = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function oe(ke, Ce, it) {
    var at = V(ke), lt = ke === "sha512" || ke === "sha384" ? 128 : 64;
    Ce.length > lt ? Ce = at(Ce) : Ce.length < lt && (Ce = K.concat([Ce, ne], lt));
    for (var ht = K.allocUnsafe(lt + ie[ke]), dt = K.allocUnsafe(lt + ie[ke]), bt = 0; bt < lt; bt++)
      ht[bt] = Ce[bt] ^ 54, dt[bt] = Ce[bt] ^ 92;
    var vt = K.allocUnsafe(lt + it + 4);
    ht.copy(vt, 0, 0, lt), this.ipad1 = vt, this.ipad2 = ht, this.opad = dt, this.alg = ke, this.blocksize = lt, this.hash = at, this.size = ie[ke];
  }
  oe.prototype.run = function(ke, Ce) {
    ke.copy(Ce, this.blocksize);
    var it = this.hash(Ce);
    return it.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function V(ke) {
    function Ce(at) {
      return L(ke).update(at).digest();
    }
    function it(at) {
      return new B().update(at).digest();
    }
    return ke === "rmd160" || ke === "ripemd160" ? it : ke === "md5" ? A : Ce;
  }
  function ce(ke, Ce, it, at, lt) {
    re(it, at), ke = J(ke, W, "Password"), Ce = J(Ce, W, "Salt"), lt = lt || "sha1";
    var ht = new oe(lt, ke, Ce.length), dt = K.allocUnsafe(at), bt = K.allocUnsafe(Ce.length + 4);
    Ce.copy(bt, 0, 0, Ce.length);
    for (var vt = 0, Bt = ie[lt], At = Math.ceil(at / Bt), Nt = 1; Nt <= At; Nt++) {
      bt.writeUInt32BE(Nt, Ce.length);
      for (var $t = ht.run(bt, ht.ipad1), mt = $t, xt = 1; xt < it; xt++) {
        mt = ht.run(mt, ht.ipad2);
        for (var wt = 0; wt < Bt; wt++) $t[wt] ^= mt[wt];
      }
      $t.copy(dt, vt), vt += Bt;
    }
    return dt;
  }
  return syncBrowser = ce, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var A = safeBufferExports.Buffer, B = requirePrecondition(), L = requireDefaultEncoding(), K = requireSyncBrowser(), re = requireToBuffer(), W, J = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ne = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ie = [];
  function oe(it) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !J || !J.importKey || !J.deriveBits)
      return Promise.resolve(!1);
    if (ie[it] !== void 0)
      return ie[it];
    W = W || A.alloc(8);
    var at = ke(W, W, 10, 128, it).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ie[it] = at, at;
  }
  var V;
  function ce() {
    return V || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? V = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? V = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? V = commonjsGlobal.setImmediate : V = commonjsGlobal.setTimeout, V);
  }
  function ke(it, at, lt, ht, dt) {
    return J.importKey(
      "raw",
      it,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(bt) {
      return J.deriveBits({
        name: "PBKDF2",
        salt: at,
        iterations: lt,
        hash: {
          name: dt
        }
      }, bt, ht << 3);
    }).then(function(bt) {
      return A.from(bt);
    });
  }
  function Ce(it, at) {
    it.then(function(lt) {
      ce()(function() {
        at(null, lt);
      });
    }, function(lt) {
      ce()(function() {
        at(lt);
      });
    });
  }
  return async = function(it, at, lt, ht, dt, bt) {
    typeof dt == "function" && (bt = dt, dt = void 0), dt = dt || "sha1";
    var vt = ne[dt.toLowerCase()];
    if (!vt || typeof commonjsGlobal.Promise != "function") {
      ce()(function() {
        var Bt;
        try {
          Bt = K(it, at, lt, ht, dt);
        } catch (At) {
          return bt(At);
        }
        bt(null, Bt);
      });
      return;
    }
    if (B(lt, ht), it = re(it, L, "Password"), at = re(at, L, "Salt"), typeof bt != "function") throw new Error("No callback provided to pbkdf2");
    Ce(oe(vt).then(function(Bt) {
      return Bt ? ke(it, at, lt, ht, vt) : K(it, at, lt, ht, dt);
    }), bt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(re, W) {
    var J = re[0 + W] << 24 | re[1 + W] << 16 | re[2 + W] << 8 | re[3 + W];
    return J >>> 0;
  }, utils$4.writeUInt32BE = function(re, W, J) {
    re[0 + J] = W >>> 24, re[1 + J] = W >>> 16 & 255, re[2 + J] = W >>> 8 & 255, re[3 + J] = W & 255;
  }, utils$4.ip = function(re, W, J, ne) {
    for (var ie = 0, oe = 0, V = 6; V >= 0; V -= 2) {
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= W >>> ce + V & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= re >>> ce + V & 1;
    }
    for (var V = 6; V >= 0; V -= 2) {
      for (var ce = 1; ce <= 25; ce += 8)
        oe <<= 1, oe |= W >>> ce + V & 1;
      for (var ce = 1; ce <= 25; ce += 8)
        oe <<= 1, oe |= re >>> ce + V & 1;
    }
    J[ne + 0] = ie >>> 0, J[ne + 1] = oe >>> 0;
  }, utils$4.rip = function(re, W, J, ne) {
    for (var ie = 0, oe = 0, V = 0; V < 4; V++)
      for (var ce = 24; ce >= 0; ce -= 8)
        ie <<= 1, ie |= W >>> ce + V & 1, ie <<= 1, ie |= re >>> ce + V & 1;
    for (var V = 4; V < 8; V++)
      for (var ce = 24; ce >= 0; ce -= 8)
        oe <<= 1, oe |= W >>> ce + V & 1, oe <<= 1, oe |= re >>> ce + V & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = oe >>> 0;
  }, utils$4.pc1 = function(re, W, J, ne) {
    for (var ie = 0, oe = 0, V = 7; V >= 5; V--) {
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= W >> ce + V & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        ie <<= 1, ie |= re >> ce + V & 1;
    }
    for (var ce = 0; ce <= 24; ce += 8)
      ie <<= 1, ie |= W >> ce + V & 1;
    for (var V = 1; V <= 3; V++) {
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= W >> ce + V & 1;
      for (var ce = 0; ce <= 24; ce += 8)
        oe <<= 1, oe |= re >> ce + V & 1;
    }
    for (var ce = 0; ce <= 24; ce += 8)
      oe <<= 1, oe |= re >> ce + V & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = oe >>> 0;
  }, utils$4.r28shl = function(re, W) {
    return re << W & 268435455 | re >>> 28 - W;
  };
  var A = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(re, W, J, ne) {
    for (var ie = 0, oe = 0, V = A.length >>> 1, ce = 0; ce < V; ce++)
      ie <<= 1, ie |= re >>> A[ce] & 1;
    for (var ce = V; ce < A.length; ce++)
      oe <<= 1, oe |= W >>> A[ce] & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = oe >>> 0;
  }, utils$4.expand = function(re, W, J) {
    var ne = 0, ie = 0;
    ne = (re & 1) << 5 | re >>> 27;
    for (var oe = 23; oe >= 15; oe -= 4)
      ne <<= 6, ne |= re >>> oe & 63;
    for (var oe = 11; oe >= 3; oe -= 4)
      ie |= re >>> oe & 63, ie <<= 6;
    ie |= (re & 31) << 1 | re >>> 31, W[J + 0] = ne >>> 0, W[J + 1] = ie >>> 0;
  };
  var B = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(re, W) {
    for (var J = 0, ne = 0; ne < 4; ne++) {
      var ie = re >>> 18 - ne * 6 & 63, oe = B[ne * 64 + ie];
      J <<= 4, J |= oe;
    }
    for (var ne = 0; ne < 4; ne++) {
      var ie = W >>> 18 - ne * 6 & 63, oe = B[4 * 64 + ne * 64 + ie];
      J <<= 4, J |= oe;
    }
    return J >>> 0;
  };
  var L = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(re) {
    for (var W = 0, J = 0; J < L.length; J++)
      W <<= 1, W |= re >>> L[J] & 1;
    return W >>> 0;
  }, utils$4.padSplit = function(re, W, J) {
    for (var ne = re.toString(2); ne.length < W; )
      ne = "0" + ne;
    for (var ie = [], oe = 0; oe < W; oe += J)
      ie.push(ne.slice(oe, oe + J));
    return ie.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = A;
  function A(B, L) {
    if (!B)
      throw new Error(L || "Assertion failed");
  }
  return A.equal = function(L, K, re) {
    if (L != K)
      throw new Error(re || "Assertion failed: " + L + " != " + K);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var A = requireMinimalisticAssert();
  function B(L) {
    this.options = L, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = L.padding !== !1;
  }
  return cipher = B, B.prototype._init = function() {
  }, B.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, B.prototype._buffer = function(K, re) {
    for (var W = Math.min(this.buffer.length - this.bufferOff, K.length - re), J = 0; J < W; J++)
      this.buffer[this.bufferOff + J] = K[re + J];
    return this.bufferOff += W, W;
  }, B.prototype._flushBuffer = function(K, re) {
    return this._update(this.buffer, 0, K, re), this.bufferOff = 0, this.blockSize;
  }, B.prototype._updateEncrypt = function(K) {
    var re = 0, W = 0, J = (this.bufferOff + K.length) / this.blockSize | 0, ne = new Array(J * this.blockSize);
    this.bufferOff !== 0 && (re += this._buffer(K, re), this.bufferOff === this.buffer.length && (W += this._flushBuffer(ne, W)));
    for (var ie = K.length - (K.length - re) % this.blockSize; re < ie; re += this.blockSize)
      this._update(K, re, ne, W), W += this.blockSize;
    for (; re < K.length; re++, this.bufferOff++)
      this.buffer[this.bufferOff] = K[re];
    return ne;
  }, B.prototype._updateDecrypt = function(K) {
    for (var re = 0, W = 0, J = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, ne = new Array(J * this.blockSize); J > 0; J--)
      re += this._buffer(K, re), W += this._flushBuffer(ne, W);
    return re += this._buffer(K, re), ne;
  }, B.prototype.final = function(K) {
    var re;
    K && (re = this.update(K));
    var W;
    return this.type === "encrypt" ? W = this._finalEncrypt() : W = this._finalDecrypt(), re ? re.concat(W) : W;
  }, B.prototype._pad = function(K, re) {
    if (re === 0)
      return !1;
    for (; re < K.length; )
      K[re++] = 0;
    return !0;
  }, B.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, B.prototype._unpad = function(K) {
    return K;
  }, B.prototype._finalDecrypt = function() {
    A.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireUtils$3(), K = requireCipher();
  function re() {
    this.tmp = new Array(2), this.keys = null;
  }
  function W(ne) {
    K.call(this, ne);
    var ie = new re();
    this._desState = ie, this.deriveKeys(ie, ne.key);
  }
  B(W, K), des = W, W.create = function(ie) {
    return new W(ie);
  };
  var J = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return W.prototype.deriveKeys = function(ie, oe) {
    ie.keys = new Array(16 * 2), A.equal(oe.length, this.blockSize, "Invalid key length");
    var V = L.readUInt32BE(oe, 0), ce = L.readUInt32BE(oe, 4);
    L.pc1(V, ce, ie.tmp, 0), V = ie.tmp[0], ce = ie.tmp[1];
    for (var ke = 0; ke < ie.keys.length; ke += 2) {
      var Ce = J[ke >>> 1];
      V = L.r28shl(V, Ce), ce = L.r28shl(ce, Ce), L.pc2(V, ce, ie.keys, ke);
    }
  }, W.prototype._update = function(ie, oe, V, ce) {
    var ke = this._desState, Ce = L.readUInt32BE(ie, oe), it = L.readUInt32BE(ie, oe + 4);
    L.ip(Ce, it, ke.tmp, 0), Ce = ke.tmp[0], it = ke.tmp[1], this.type === "encrypt" ? this._encrypt(ke, Ce, it, ke.tmp, 0) : this._decrypt(ke, Ce, it, ke.tmp, 0), Ce = ke.tmp[0], it = ke.tmp[1], L.writeUInt32BE(V, Ce, ce), L.writeUInt32BE(V, it, ce + 4);
  }, W.prototype._pad = function(ie, oe) {
    if (this.padding === !1)
      return !1;
    for (var V = ie.length - oe, ce = oe; ce < ie.length; ce++)
      ie[ce] = V;
    return !0;
  }, W.prototype._unpad = function(ie) {
    if (this.padding === !1)
      return ie;
    for (var oe = ie[ie.length - 1], V = ie.length - oe; V < ie.length; V++)
      A.equal(ie[V], oe);
    return ie.slice(0, ie.length - oe);
  }, W.prototype._encrypt = function(ie, oe, V, ce, ke) {
    for (var Ce = oe, it = V, at = 0; at < ie.keys.length; at += 2) {
      var lt = ie.keys[at], ht = ie.keys[at + 1];
      L.expand(it, ie.tmp, 0), lt ^= ie.tmp[0], ht ^= ie.tmp[1];
      var dt = L.substitute(lt, ht), bt = L.permute(dt), vt = it;
      it = (Ce ^ bt) >>> 0, Ce = vt;
    }
    L.rip(it, Ce, ce, ke);
  }, W.prototype._decrypt = function(ie, oe, V, ce, ke) {
    for (var Ce = V, it = oe, at = ie.keys.length - 2; at >= 0; at -= 2) {
      var lt = ie.keys[at], ht = ie.keys[at + 1];
      L.expand(Ce, ie.tmp, 0), lt ^= ie.tmp[0], ht ^= ie.tmp[1];
      var dt = L.substitute(lt, ht), bt = L.permute(dt), vt = Ce;
      Ce = (it ^ bt) >>> 0, it = vt;
    }
    L.rip(Ce, it, ce, ke);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = {};
  function K(W) {
    A.equal(W.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var J = 0; J < this.iv.length; J++)
      this.iv[J] = W[J];
  }
  function re(W) {
    function J(V) {
      W.call(this, V), this._cbcInit();
    }
    B(J, W);
    for (var ne = Object.keys(L), ie = 0; ie < ne.length; ie++) {
      var oe = ne[ie];
      J.prototype[oe] = L[oe];
    }
    return J.create = function(ce) {
      return new J(ce);
    }, J;
  }
  return cbc$1.instantiate = re, L._cbcInit = function() {
    var J = new K(this.options.iv);
    this._cbcState = J;
  }, L._update = function(J, ne, ie, oe) {
    var V = this._cbcState, ce = this.constructor.super_.prototype, ke = V.iv;
    if (this.type === "encrypt") {
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] ^= J[ne + Ce];
      ce._update.call(this, ke, 0, ie, oe);
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] = ie[oe + Ce];
    } else {
      ce._update.call(this, J, ne, ie, oe);
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ie[oe + Ce] ^= ke[Ce];
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] = J[ne + Ce];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireCipher(), K = requireDes$1();
  function re(J, ne) {
    A.equal(ne.length, 24, "Invalid key length");
    var ie = ne.slice(0, 8), oe = ne.slice(8, 16), V = ne.slice(16, 24);
    J === "encrypt" ? this.ciphers = [
      K.create({ type: "encrypt", key: ie }),
      K.create({ type: "decrypt", key: oe }),
      K.create({ type: "encrypt", key: V })
    ] : this.ciphers = [
      K.create({ type: "decrypt", key: V }),
      K.create({ type: "encrypt", key: oe }),
      K.create({ type: "decrypt", key: ie })
    ];
  }
  function W(J) {
    L.call(this, J);
    var ne = new re(this.type, this.options.key);
    this._edeState = ne;
  }
  return B(W, L), ede = W, W.create = function(ne) {
    return new W(ne);
  }, W.prototype._update = function(ne, ie, oe, V) {
    var ce = this._edeState;
    ce.ciphers[0]._update(ne, ie, oe, V), ce.ciphers[1]._update(oe, V, oe, V), ce.ciphers[2]._update(oe, V, oe, V);
  }, W.prototype._pad = K.prototype._pad, W.prototype._unpad = K.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var A = requireCipherBase(), B = requireDes(), L = requireInherits_browser(), K = safeBufferExports.Buffer, re = {
    "des-ede3-cbc": B.CBC.instantiate(B.EDE),
    "des-ede3": B.EDE,
    "des-ede-cbc": B.CBC.instantiate(B.EDE),
    "des-ede": B.EDE,
    "des-cbc": B.CBC.instantiate(B.DES),
    "des-ecb": B.DES
  };
  re.des = re["des-cbc"], re.des3 = re["des-ede3-cbc"], browserifyDes = W, L(W, A);
  function W(J) {
    A.call(this);
    var ne = J.mode.toLowerCase(), ie = re[ne], oe;
    J.decrypt ? oe = "decrypt" : oe = "encrypt";
    var V = J.key;
    K.isBuffer(V) || (V = K.from(V)), (ne === "des-ede" || ne === "des-ede-cbc") && (V = K.concat([V, V.slice(0, 8)]));
    var ce = J.iv;
    K.isBuffer(ce) || (ce = K.from(ce)), this._des = ie.create({
      key: V,
      iv: ce,
      type: oe
    });
  }
  return W.prototype._update = function(J) {
    return K.from(this._des.update(J));
  }, W.prototype._final = function() {
    return K.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(A, B) {
    return A._cipher.encryptBlock(B);
  }, ecb.decrypt = function(A, B) {
    return A._cipher.decryptBlock(B);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(B, L) {
    for (var K = Math.min(B.length, L.length), re = new Buffer$1(K), W = 0; W < K; ++W)
      re[W] = B[W] ^ L[W];
    return re;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var A = requireBufferXor();
  return cbc.encrypt = function(B, L) {
    var K = A(L, B._prev);
    return B._prev = B._cipher.encryptBlock(K), B._prev;
  }, cbc.decrypt = function(B, L) {
    var K = B._prev;
    B._prev = L;
    var re = B._cipher.decryptBlock(L);
    return A(re, K);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var A = safeBufferExports.Buffer, B = requireBufferXor();
  function L(K, re, W) {
    var J = re.length, ne = B(re, K._cache);
    return K._cache = K._cache.slice(J), K._prev = A.concat([K._prev, W ? re : ne]), ne;
  }
  return cfb.encrypt = function(K, re, W) {
    for (var J = A.allocUnsafe(0), ne; re.length; )
      if (K._cache.length === 0 && (K._cache = K._cipher.encryptBlock(K._prev), K._prev = A.allocUnsafe(0)), K._cache.length <= re.length)
        ne = K._cache.length, J = A.concat([J, L(K, re.slice(0, ne), W)]), re = re.slice(ne);
      else {
        J = A.concat([J, L(K, re, W)]);
        break;
      }
    return J;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K, re) {
    var W = L._cipher.encryptBlock(L._prev), J = W[0] ^ K;
    return L._prev = A.concat([
      L._prev.slice(1),
      A.from([re ? K : J])
    ]), J;
  }
  return cfb8.encrypt = function(L, K, re) {
    for (var W = K.length, J = A.allocUnsafe(W), ne = -1; ++ne < W; )
      J[ne] = B(L, K[ne], re);
    return J;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var A = safeBufferExports.Buffer;
  function B(K, re, W) {
    for (var J, ne = -1, ie = 8, oe = 0, V, ce; ++ne < ie; )
      J = K._cipher.encryptBlock(K._prev), V = re & 1 << 7 - ne ? 128 : 0, ce = J[0] ^ V, oe += (ce & 128) >> ne % 8, K._prev = L(K._prev, W ? V : ce);
    return oe;
  }
  function L(K, re) {
    var W = K.length, J = -1, ne = A.allocUnsafe(K.length);
    for (K = A.concat([K, A.from([re])]); ++J < W; )
      ne[J] = K[J] << 1 | K[J + 1] >> 7;
    return ne;
  }
  return cfb1.encrypt = function(K, re, W) {
    for (var J = re.length, ne = A.allocUnsafe(J), ie = -1; ++ie < J; )
      ne[ie] = B(K, re[ie], W);
    return ne;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var A = requireBufferXor();
  function B(L) {
    return L._prev = L._cipher.encryptBlock(L._prev), L._prev;
  }
  return ofb.encrypt = function(L, K) {
    for (; L._cache.length < K.length; )
      L._cache = Buffer$1.concat([L._cache, B(L)]);
    var re = L._cache.slice(0, K.length);
    return L._cache = L._cache.slice(K.length), A(K, re);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function A(B) {
    for (var L = B.length, K; L--; )
      if (K = B.readUInt8(L), K === 255)
        B.writeUInt8(0, L);
      else {
        K++, B.writeUInt8(K, L);
        break;
      }
  }
  return incr32_1 = A, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var A = requireBufferXor(), B = safeBufferExports.Buffer, L = requireIncr32();
  function K(W) {
    var J = W._cipher.encryptBlockRaw(W._prev);
    return L(W._prev), J;
  }
  var re = 16;
  return ctr.encrypt = function(W, J) {
    var ne = Math.ceil(J.length / re), ie = W._cache.length;
    W._cache = B.concat([
      W._cache,
      B.allocUnsafe(ne * re)
    ]);
    for (var oe = 0; oe < ne; oe++) {
      var V = K(W), ce = ie + oe * re;
      W._cache.writeUInt32BE(V[0], ce + 0), W._cache.writeUInt32BE(V[1], ce + 4), W._cache.writeUInt32BE(V[2], ce + 8), W._cache.writeUInt32BE(V[3], ce + 12);
    }
    var ke = W._cache.slice(0, J.length);
    return W._cache = W._cache.slice(J.length), A(J, ke);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var A = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, B = require$$2;
  for (var L in B)
    B[L].module = A[B[L].mode];
  return modes_1 = B, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var A = safeBufferExports.Buffer;
  function B(ne) {
    A.isBuffer(ne) || (ne = A.from(ne));
    for (var ie = ne.length / 4 | 0, oe = new Array(ie), V = 0; V < ie; V++)
      oe[V] = ne.readUInt32BE(V * 4);
    return oe;
  }
  function L(ne) {
    for (var ie = 0; ie < ne.length; ne++)
      ne[ie] = 0;
  }
  function K(ne, ie, oe, V, ce) {
    for (var ke = oe[0], Ce = oe[1], it = oe[2], at = oe[3], lt = ne[0] ^ ie[0], ht = ne[1] ^ ie[1], dt = ne[2] ^ ie[2], bt = ne[3] ^ ie[3], vt, Bt, At, Nt, $t = 4, mt = 1; mt < ce; mt++)
      vt = ke[lt >>> 24] ^ Ce[ht >>> 16 & 255] ^ it[dt >>> 8 & 255] ^ at[bt & 255] ^ ie[$t++], Bt = ke[ht >>> 24] ^ Ce[dt >>> 16 & 255] ^ it[bt >>> 8 & 255] ^ at[lt & 255] ^ ie[$t++], At = ke[dt >>> 24] ^ Ce[bt >>> 16 & 255] ^ it[lt >>> 8 & 255] ^ at[ht & 255] ^ ie[$t++], Nt = ke[bt >>> 24] ^ Ce[lt >>> 16 & 255] ^ it[ht >>> 8 & 255] ^ at[dt & 255] ^ ie[$t++], lt = vt, ht = Bt, dt = At, bt = Nt;
    return vt = (V[lt >>> 24] << 24 | V[ht >>> 16 & 255] << 16 | V[dt >>> 8 & 255] << 8 | V[bt & 255]) ^ ie[$t++], Bt = (V[ht >>> 24] << 24 | V[dt >>> 16 & 255] << 16 | V[bt >>> 8 & 255] << 8 | V[lt & 255]) ^ ie[$t++], At = (V[dt >>> 24] << 24 | V[bt >>> 16 & 255] << 16 | V[lt >>> 8 & 255] << 8 | V[ht & 255]) ^ ie[$t++], Nt = (V[bt >>> 24] << 24 | V[lt >>> 16 & 255] << 16 | V[ht >>> 8 & 255] << 8 | V[dt & 255]) ^ ie[$t++], vt = vt >>> 0, Bt = Bt >>> 0, At = At >>> 0, Nt = Nt >>> 0, [vt, Bt, At, Nt];
  }
  var re = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], W = function() {
    for (var ne = new Array(256), ie = 0; ie < 256; ie++)
      ie < 128 ? ne[ie] = ie << 1 : ne[ie] = ie << 1 ^ 283;
    for (var oe = [], V = [], ce = [[], [], [], []], ke = [[], [], [], []], Ce = 0, it = 0, at = 0; at < 256; ++at) {
      var lt = it ^ it << 1 ^ it << 2 ^ it << 3 ^ it << 4;
      lt = lt >>> 8 ^ lt & 255 ^ 99, oe[Ce] = lt, V[lt] = Ce;
      var ht = ne[Ce], dt = ne[ht], bt = ne[dt], vt = ne[lt] * 257 ^ lt * 16843008;
      ce[0][Ce] = vt << 24 | vt >>> 8, ce[1][Ce] = vt << 16 | vt >>> 16, ce[2][Ce] = vt << 8 | vt >>> 24, ce[3][Ce] = vt, vt = bt * 16843009 ^ dt * 65537 ^ ht * 257 ^ Ce * 16843008, ke[0][lt] = vt << 24 | vt >>> 8, ke[1][lt] = vt << 16 | vt >>> 16, ke[2][lt] = vt << 8 | vt >>> 24, ke[3][lt] = vt, Ce === 0 ? Ce = it = 1 : (Ce = ht ^ ne[ne[ne[bt ^ ht]]], it ^= ne[ne[it]]);
    }
    return {
      SBOX: oe,
      INV_SBOX: V,
      SUB_MIX: ce,
      INV_SUB_MIX: ke
    };
  }();
  function J(ne) {
    this._key = B(ne), this._reset();
  }
  return J.blockSize = 4 * 4, J.keySize = 256 / 8, J.prototype.blockSize = J.blockSize, J.prototype.keySize = J.keySize, J.prototype._reset = function() {
    for (var ne = this._key, ie = ne.length, oe = ie + 6, V = (oe + 1) * 4, ce = [], ke = 0; ke < ie; ke++)
      ce[ke] = ne[ke];
    for (ke = ie; ke < V; ke++) {
      var Ce = ce[ke - 1];
      ke % ie === 0 ? (Ce = Ce << 8 | Ce >>> 24, Ce = W.SBOX[Ce >>> 24] << 24 | W.SBOX[Ce >>> 16 & 255] << 16 | W.SBOX[Ce >>> 8 & 255] << 8 | W.SBOX[Ce & 255], Ce ^= re[ke / ie | 0] << 24) : ie > 6 && ke % ie === 4 && (Ce = W.SBOX[Ce >>> 24] << 24 | W.SBOX[Ce >>> 16 & 255] << 16 | W.SBOX[Ce >>> 8 & 255] << 8 | W.SBOX[Ce & 255]), ce[ke] = ce[ke - ie] ^ Ce;
    }
    for (var it = [], at = 0; at < V; at++) {
      var lt = V - at, ht = ce[lt - (at % 4 ? 0 : 4)];
      at < 4 || lt <= 4 ? it[at] = ht : it[at] = W.INV_SUB_MIX[0][W.SBOX[ht >>> 24]] ^ W.INV_SUB_MIX[1][W.SBOX[ht >>> 16 & 255]] ^ W.INV_SUB_MIX[2][W.SBOX[ht >>> 8 & 255]] ^ W.INV_SUB_MIX[3][W.SBOX[ht & 255]];
    }
    this._nRounds = oe, this._keySchedule = ce, this._invKeySchedule = it;
  }, J.prototype.encryptBlockRaw = function(ne) {
    return ne = B(ne), K(ne, this._keySchedule, W.SUB_MIX, W.SBOX, this._nRounds);
  }, J.prototype.encryptBlock = function(ne) {
    var ie = this.encryptBlockRaw(ne), oe = A.allocUnsafe(16);
    return oe.writeUInt32BE(ie[0], 0), oe.writeUInt32BE(ie[1], 4), oe.writeUInt32BE(ie[2], 8), oe.writeUInt32BE(ie[3], 12), oe;
  }, J.prototype.decryptBlock = function(ne) {
    ne = B(ne);
    var ie = ne[1];
    ne[1] = ne[3], ne[3] = ie;
    var oe = K(ne, this._invKeySchedule, W.INV_SUB_MIX, W.INV_SBOX, this._nRounds), V = A.allocUnsafe(16);
    return V.writeUInt32BE(oe[0], 0), V.writeUInt32BE(oe[3], 4), V.writeUInt32BE(oe[2], 8), V.writeUInt32BE(oe[1], 12), V;
  }, J.prototype.scrub = function() {
    L(this._keySchedule), L(this._invKeySchedule), L(this._key);
  }, aes.AES = J, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var A = safeBufferExports.Buffer, B = A.alloc(16, 0);
  function L(W) {
    return [
      W.readUInt32BE(0),
      W.readUInt32BE(4),
      W.readUInt32BE(8),
      W.readUInt32BE(12)
    ];
  }
  function K(W) {
    var J = A.allocUnsafe(16);
    return J.writeUInt32BE(W[0] >>> 0, 0), J.writeUInt32BE(W[1] >>> 0, 4), J.writeUInt32BE(W[2] >>> 0, 8), J.writeUInt32BE(W[3] >>> 0, 12), J;
  }
  function re(W) {
    this.h = W, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
  }
  return re.prototype.ghash = function(W) {
    for (var J = -1; ++J < W.length; )
      this.state[J] ^= W[J];
    this._multiply();
  }, re.prototype._multiply = function() {
    for (var W = L(this.h), J = [0, 0, 0, 0], ne, ie, oe, V = -1; ++V < 128; ) {
      for (ie = (this.state[~~(V / 8)] & 1 << 7 - V % 8) !== 0, ie && (J[0] ^= W[0], J[1] ^= W[1], J[2] ^= W[2], J[3] ^= W[3]), oe = (W[3] & 1) !== 0, ne = 3; ne > 0; ne--)
        W[ne] = W[ne] >>> 1 | (W[ne - 1] & 1) << 31;
      W[0] = W[0] >>> 1, oe && (W[0] = W[0] ^ 225 << 24);
    }
    this.state = K(J);
  }, re.prototype.update = function(W) {
    this.cache = A.concat([this.cache, W]);
    for (var J; this.cache.length >= 16; )
      J = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(J);
  }, re.prototype.final = function(W, J) {
    return this.cache.length && this.ghash(A.concat([this.cache, B], 16)), this.ghash(K([0, W, 0, J])), this.state;
  }, ghash = re, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser(), re = requireGhash(), W = requireBufferXor(), J = requireIncr32();
  function ne(V, ce) {
    var ke = 0;
    V.length !== ce.length && ke++;
    for (var Ce = Math.min(V.length, ce.length), it = 0; it < Ce; ++it)
      ke += V[it] ^ ce[it];
    return ke;
  }
  function ie(V, ce, ke) {
    if (ce.length === 12)
      return V._finID = B.concat([ce, B.from([0, 0, 0, 1])]), B.concat([ce, B.from([0, 0, 0, 2])]);
    var Ce = new re(ke), it = ce.length, at = it % 16;
    Ce.update(ce), at && (at = 16 - at, Ce.update(B.alloc(at, 0))), Ce.update(B.alloc(8, 0));
    var lt = it * 8, ht = B.alloc(8);
    ht.writeUIntBE(lt, 0, 8), Ce.update(ht), V._finID = Ce.state;
    var dt = B.from(V._finID);
    return J(dt), dt;
  }
  function oe(V, ce, ke, Ce) {
    L.call(this);
    var it = B.alloc(4, 0);
    this._cipher = new A.AES(ce);
    var at = this._cipher.encryptBlock(it);
    this._ghash = new re(at), ke = ie(this, ke, at), this._prev = B.from(ke), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = Ce, this._alen = 0, this._len = 0, this._mode = V, this._authTag = null, this._called = !1;
  }
  return K(oe, L), oe.prototype._update = function(V) {
    if (!this._called && this._alen) {
      var ce = 16 - this._alen % 16;
      ce < 16 && (ce = B.alloc(ce, 0), this._ghash.update(ce));
    }
    this._called = !0;
    var ke = this._mode.encrypt(this, V);
    return this._decrypt ? this._ghash.update(V) : this._ghash.update(ke), this._len += V.length, ke;
  }, oe.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var V = W(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ne(V, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = V, this._cipher.scrub();
  }, oe.prototype.getAuthTag = function() {
    if (this._decrypt || !B.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, oe.prototype.setAuthTag = function(ce) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = ce;
  }, oe.prototype.setAAD = function(ce) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(ce), this._alen += ce.length;
  }, authCipher = oe, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser();
  function re(W, J, ne, ie) {
    L.call(this), this._cipher = new A.AES(J), this._prev = B.from(ne), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = ie, this._mode = W;
  }
  return K(re, L), re.prototype._update = function(W) {
    return this._mode.encrypt(this, W, this._decrypt);
  }, re.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = re, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var A = safeBufferExports.Buffer, B = requireMd5_js();
  function L(K, re, W, J) {
    if (A.isBuffer(K) || (K = A.from(K, "binary")), re && (A.isBuffer(re) || (re = A.from(re, "binary")), re.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var ne = W / 8, ie = A.alloc(ne), oe = A.alloc(J || 0), V = A.alloc(0); ne > 0 || J > 0; ) {
      var ce = new B();
      ce.update(V), ce.update(K), re && ce.update(re), V = ce.digest();
      var ke = 0;
      if (ne > 0) {
        var Ce = ie.length - ne;
        ke = Math.min(ne, V.length), V.copy(ie, Ce, 0, ke), ne -= ke;
      }
      if (ke < V.length && J > 0) {
        var it = oe.length - J, at = Math.min(J, V.length - ke);
        V.copy(oe, it, ke, ke + at), J -= at;
      }
    }
    return V.fill(0), { key: ie, iv: oe };
  }
  return evp_bytestokey = L, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var A = requireModes$1(), B = requireAuthCipher(), L = safeBufferExports.Buffer, K = requireStreamCipher(), re = requireCipherBase(), W = requireAes(), J = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Ce, it, at) {
    re.call(this), this._cache = new V(), this._cipher = new W.AES(it), this._prev = L.from(at), this._mode = Ce, this._autopadding = !0;
  }
  ne(ie, re), ie.prototype._update = function(Ce) {
    this._cache.add(Ce);
    for (var it, at, lt = []; it = this._cache.get(); )
      at = this._mode.encrypt(this, it), lt.push(at);
    return L.concat(lt);
  };
  var oe = L.alloc(16, 16);
  ie.prototype._final = function() {
    var Ce = this._cache.flush();
    if (this._autopadding)
      return Ce = this._mode.encrypt(this, Ce), this._cipher.scrub(), Ce;
    if (!Ce.equals(oe))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Ce) {
    return this._autopadding = !!Ce, this;
  };
  function V() {
    this.cache = L.allocUnsafe(0);
  }
  V.prototype.add = function(Ce) {
    this.cache = L.concat([this.cache, Ce]);
  }, V.prototype.get = function() {
    if (this.cache.length > 15) {
      var Ce = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Ce;
    }
    return null;
  }, V.prototype.flush = function() {
    for (var Ce = 16 - this.cache.length, it = L.allocUnsafe(Ce), at = -1; ++at < Ce; )
      it.writeUInt8(Ce, at);
    return L.concat([this.cache, it]);
  };
  function ce(Ce, it, at) {
    var lt = A[Ce.toLowerCase()];
    if (!lt) throw new TypeError("invalid suite type");
    if (typeof it == "string" && (it = L.from(it)), it.length !== lt.key / 8) throw new TypeError("invalid key length " + it.length);
    if (typeof at == "string" && (at = L.from(at)), lt.mode !== "GCM" && at.length !== lt.iv) throw new TypeError("invalid iv length " + at.length);
    return lt.type === "stream" ? new K(lt.module, it, at) : lt.type === "auth" ? new B(lt.module, it, at) : new ie(lt.module, it, at);
  }
  function ke(Ce, it) {
    var at = A[Ce.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var lt = J(it, !1, at.key, at.iv);
    return ce(Ce, lt.key, lt.iv);
  }
  return encrypter.createCipheriv = ce, encrypter.createCipher = ke, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var A = requireAuthCipher(), B = safeBufferExports.Buffer, L = requireModes$1(), K = requireStreamCipher(), re = requireCipherBase(), W = requireAes(), J = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Ce, it, at) {
    re.call(this), this._cache = new oe(), this._last = void 0, this._cipher = new W.AES(it), this._prev = B.from(at), this._mode = Ce, this._autopadding = !0;
  }
  ne(ie, re), ie.prototype._update = function(Ce) {
    this._cache.add(Ce);
    for (var it, at, lt = []; it = this._cache.get(this._autopadding); )
      at = this._mode.decrypt(this, it), lt.push(at);
    return B.concat(lt);
  }, ie.prototype._final = function() {
    var Ce = this._cache.flush();
    if (this._autopadding)
      return V(this._mode.decrypt(this, Ce));
    if (Ce)
      throw new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Ce) {
    return this._autopadding = !!Ce, this;
  };
  function oe() {
    this.cache = B.allocUnsafe(0);
  }
  oe.prototype.add = function(Ce) {
    this.cache = B.concat([this.cache, Ce]);
  }, oe.prototype.get = function(Ce) {
    var it;
    if (Ce) {
      if (this.cache.length > 16)
        return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    } else if (this.cache.length >= 16)
      return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    return null;
  }, oe.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function V(Ce) {
    var it = Ce[15];
    if (it < 1 || it > 16)
      throw new Error("unable to decrypt data");
    for (var at = -1; ++at < it; )
      if (Ce[at + (16 - it)] !== it)
        throw new Error("unable to decrypt data");
    if (it !== 16)
      return Ce.slice(0, 16 - it);
  }
  function ce(Ce, it, at) {
    var lt = L[Ce.toLowerCase()];
    if (!lt) throw new TypeError("invalid suite type");
    if (typeof at == "string" && (at = B.from(at)), lt.mode !== "GCM" && at.length !== lt.iv) throw new TypeError("invalid iv length " + at.length);
    if (typeof it == "string" && (it = B.from(it)), it.length !== lt.key / 8) throw new TypeError("invalid key length " + it.length);
    return lt.type === "stream" ? new K(lt.module, it, at, !0) : lt.type === "auth" ? new A(lt.module, it, at, !0) : new ie(lt.module, it, at);
  }
  function ke(Ce, it) {
    var at = L[Ce.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var lt = J(it, !1, at.key, at.iv);
    return ce(Ce, lt.key, lt.iv);
  }
  return decrypter.createDecipher = ke, decrypter.createDecipheriv = ce, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var A = requireEncrypter(), B = requireDecrypter(), L = require$$2;
  function K() {
    return Object.keys(L);
  }
  return browser$5.createCipher = browser$5.Cipher = A.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = A.createCipheriv, browser$5.createDecipher = browser$5.Decipher = B.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = B.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = K, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(A) {
    A["des-ecb"] = {
      key: 8,
      iv: 0
    }, A["des-cbc"] = A.des = {
      key: 8,
      iv: 8
    }, A["des-ede3-cbc"] = A.des3 = {
      key: 24,
      iv: 8
    }, A["des-ede3"] = {
      key: 24,
      iv: 0
    }, A["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, A["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var A = requireBrowserifyDes(), B = requireBrowser$6(), L = requireModes$1(), K = requireModes(), re = requireEvp_bytestokey();
  function W(V, ce) {
    V = V.toLowerCase();
    var ke, Ce;
    if (L[V])
      ke = L[V].key, Ce = L[V].iv;
    else if (K[V])
      ke = K[V].key * 8, Ce = K[V].iv;
    else
      throw new TypeError("invalid suite type");
    var it = re(ce, !1, ke, Ce);
    return ne(V, it.key, it.iv);
  }
  function J(V, ce) {
    V = V.toLowerCase();
    var ke, Ce;
    if (L[V])
      ke = L[V].key, Ce = L[V].iv;
    else if (K[V])
      ke = K[V].key * 8, Ce = K[V].iv;
    else
      throw new TypeError("invalid suite type");
    var it = re(ce, !1, ke, Ce);
    return ie(V, it.key, it.iv);
  }
  function ne(V, ce, ke) {
    if (V = V.toLowerCase(), L[V]) return B.createCipheriv(V, ce, ke);
    if (K[V]) return new A({ key: ce, iv: ke, mode: V });
    throw new TypeError("invalid suite type");
  }
  function ie(V, ce, ke) {
    if (V = V.toLowerCase(), L[V]) return B.createDecipheriv(V, ce, ke);
    if (K[V]) return new A({ key: ce, iv: ke, mode: V, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function oe() {
    return Object.keys(K).concat(B.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = W, browser$6.createCipheriv = browser$6.Cipheriv = ne, browser$6.createDecipher = browser$6.Decipher = J, browser$6.createDecipheriv = browser$6.Decipheriv = ie, browser$6.listCiphers = browser$6.getCiphers = oe, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(A) {
    (function(B, L) {
      function K(wt, Oe) {
        if (!wt) throw new Error(Oe || "Assertion failed");
      }
      function re(wt, Oe) {
        wt.super_ = Oe;
        var rt = function() {
        };
        rt.prototype = Oe.prototype, wt.prototype = new rt(), wt.prototype.constructor = wt;
      }
      function W(wt, Oe, rt) {
        if (W.isBN(wt))
          return wt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, wt !== null && ((Oe === "le" || Oe === "be") && (rt = Oe, Oe = 10), this._init(wt || 0, Oe || 10, rt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var J;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? J = window.Buffer : J = require$$0$1.Buffer;
      } catch {
      }
      W.isBN = function(Oe) {
        return Oe instanceof W ? !0 : Oe !== null && typeof Oe == "object" && Oe.constructor.wordSize === W.wordSize && Array.isArray(Oe.words);
      }, W.max = function(Oe, rt) {
        return Oe.cmp(rt) > 0 ? Oe : rt;
      }, W.min = function(Oe, rt) {
        return Oe.cmp(rt) < 0 ? Oe : rt;
      }, W.prototype._init = function(Oe, rt, pe) {
        if (typeof Oe == "number")
          return this._initNumber(Oe, rt, pe);
        if (typeof Oe == "object")
          return this._initArray(Oe, rt, pe);
        rt === "hex" && (rt = 16), K(rt === (rt | 0) && rt >= 2 && rt <= 36), Oe = Oe.toString().replace(/\s+/g, "");
        var nt = 0;
        Oe[0] === "-" && (nt++, this.negative = 1), nt < Oe.length && (rt === 16 ? this._parseHex(Oe, nt, pe) : (this._parseBase(Oe, rt, nt), pe === "le" && this._initArray(this.toArray(), rt, pe)));
      }, W.prototype._initNumber = function(Oe, rt, pe) {
        Oe < 0 && (this.negative = 1, Oe = -Oe), Oe < 67108864 ? (this.words = [Oe & 67108863], this.length = 1) : Oe < 4503599627370496 ? (this.words = [
          Oe & 67108863,
          Oe / 67108864 & 67108863
        ], this.length = 2) : (K(Oe < 9007199254740992), this.words = [
          Oe & 67108863,
          Oe / 67108864 & 67108863,
          1
        ], this.length = 3), pe === "le" && this._initArray(this.toArray(), rt, pe);
      }, W.prototype._initArray = function(Oe, rt, pe) {
        if (K(typeof Oe.length == "number"), Oe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Oe.length / 3), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var ot, st, ut = 0;
        if (pe === "be")
          for (nt = Oe.length - 1, ot = 0; nt >= 0; nt -= 3)
            st = Oe[nt] | Oe[nt - 1] << 8 | Oe[nt - 2] << 16, this.words[ot] |= st << ut & 67108863, this.words[ot + 1] = st >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ot++);
        else if (pe === "le")
          for (nt = 0, ot = 0; nt < Oe.length; nt += 3)
            st = Oe[nt] | Oe[nt + 1] << 8 | Oe[nt + 2] << 16, this.words[ot] |= st << ut & 67108863, this.words[ot + 1] = st >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ot++);
        return this.strip();
      };
      function ne(wt, Oe) {
        var rt = wt.charCodeAt(Oe);
        return rt >= 65 && rt <= 70 ? rt - 55 : rt >= 97 && rt <= 102 ? rt - 87 : rt - 48 & 15;
      }
      function ie(wt, Oe, rt) {
        var pe = ne(wt, rt);
        return rt - 1 >= Oe && (pe |= ne(wt, rt - 1) << 4), pe;
      }
      W.prototype._parseHex = function(Oe, rt, pe) {
        this.length = Math.ceil((Oe.length - rt) / 6), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var ot = 0, st = 0, ut;
        if (pe === "be")
          for (nt = Oe.length - 1; nt >= rt; nt -= 2)
            ut = ie(Oe, rt, nt) << ot, this.words[st] |= ut & 67108863, ot >= 18 ? (ot -= 18, st += 1, this.words[st] |= ut >>> 26) : ot += 8;
        else {
          var pt = Oe.length - rt;
          for (nt = pt % 2 === 0 ? rt + 1 : rt; nt < Oe.length; nt += 2)
            ut = ie(Oe, rt, nt) << ot, this.words[st] |= ut & 67108863, ot >= 18 ? (ot -= 18, st += 1, this.words[st] |= ut >>> 26) : ot += 8;
        }
        this.strip();
      };
      function oe(wt, Oe, rt, pe) {
        for (var nt = 0, ot = Math.min(wt.length, rt), st = Oe; st < ot; st++) {
          var ut = wt.charCodeAt(st) - 48;
          nt *= pe, ut >= 49 ? nt += ut - 49 + 10 : ut >= 17 ? nt += ut - 17 + 10 : nt += ut;
        }
        return nt;
      }
      W.prototype._parseBase = function(Oe, rt, pe) {
        this.words = [0], this.length = 1;
        for (var nt = 0, ot = 1; ot <= 67108863; ot *= rt)
          nt++;
        nt--, ot = ot / rt | 0;
        for (var st = Oe.length - pe, ut = st % nt, pt = Math.min(st, st - ut) + pe, ft = 0, yt = pe; yt < pt; yt += nt)
          ft = oe(Oe, yt, yt + nt, rt), this.imuln(ot), this.words[0] + ft < 67108864 ? this.words[0] += ft : this._iaddn(ft);
        if (ut !== 0) {
          var ct = 1;
          for (ft = oe(Oe, yt, Oe.length, rt), yt = 0; yt < ut; yt++)
            ct *= rt;
          this.imuln(ct), this.words[0] + ft < 67108864 ? this.words[0] += ft : this._iaddn(ft);
        }
        this.strip();
      }, W.prototype.copy = function(Oe) {
        Oe.words = new Array(this.length);
        for (var rt = 0; rt < this.length; rt++)
          Oe.words[rt] = this.words[rt];
        Oe.length = this.length, Oe.negative = this.negative, Oe.red = this.red;
      }, W.prototype.clone = function() {
        var Oe = new W(null);
        return this.copy(Oe), Oe;
      }, W.prototype._expand = function(Oe) {
        for (; this.length < Oe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, W.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var V = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], ce = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ke = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(Oe, rt) {
        Oe = Oe || 10, rt = rt | 0 || 1;
        var pe;
        if (Oe === 16 || Oe === "hex") {
          pe = "";
          for (var nt = 0, ot = 0, st = 0; st < this.length; st++) {
            var ut = this.words[st], pt = ((ut << nt | ot) & 16777215).toString(16);
            ot = ut >>> 24 - nt & 16777215, ot !== 0 || st !== this.length - 1 ? pe = V[6 - pt.length] + pt + pe : pe = pt + pe, nt += 2, nt >= 26 && (nt -= 26, st--);
          }
          for (ot !== 0 && (pe = ot.toString(16) + pe); pe.length % rt !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        if (Oe === (Oe | 0) && Oe >= 2 && Oe <= 36) {
          var ft = ce[Oe], yt = ke[Oe];
          pe = "";
          var ct = this.clone();
          for (ct.negative = 0; !ct.isZero(); ) {
            var St = ct.modn(yt).toString(Oe);
            ct = ct.idivn(yt), ct.isZero() ? pe = St + pe : pe = V[ft - St.length] + St + pe;
          }
          for (this.isZero() && (pe = "0" + pe); pe.length % rt !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var Oe = this.words[0];
        return this.length === 2 ? Oe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Oe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Oe : Oe;
      }, W.prototype.toJSON = function() {
        return this.toString(16);
      }, W.prototype.toBuffer = function(Oe, rt) {
        return K(typeof J < "u"), this.toArrayLike(J, Oe, rt);
      }, W.prototype.toArray = function(Oe, rt) {
        return this.toArrayLike(Array, Oe, rt);
      }, W.prototype.toArrayLike = function(Oe, rt, pe) {
        var nt = this.byteLength(), ot = pe || Math.max(1, nt);
        K(nt <= ot, "byte array longer than desired length"), K(ot > 0, "Requested array length <= 0"), this.strip();
        var st = rt === "le", ut = new Oe(ot), pt, ft, yt = this.clone();
        if (st) {
          for (ft = 0; !yt.isZero(); ft++)
            pt = yt.andln(255), yt.iushrn(8), ut[ft] = pt;
          for (; ft < ot; ft++)
            ut[ft] = 0;
        } else {
          for (ft = 0; ft < ot - nt; ft++)
            ut[ft] = 0;
          for (ft = 0; !yt.isZero(); ft++)
            pt = yt.andln(255), yt.iushrn(8), ut[ot - ft - 1] = pt;
        }
        return ut;
      }, Math.clz32 ? W.prototype._countBits = function(Oe) {
        return 32 - Math.clz32(Oe);
      } : W.prototype._countBits = function(Oe) {
        var rt = Oe, pe = 0;
        return rt >= 4096 && (pe += 13, rt >>>= 13), rt >= 64 && (pe += 7, rt >>>= 7), rt >= 8 && (pe += 4, rt >>>= 4), rt >= 2 && (pe += 2, rt >>>= 2), pe + rt;
      }, W.prototype._zeroBits = function(Oe) {
        if (Oe === 0) return 26;
        var rt = Oe, pe = 0;
        return rt & 8191 || (pe += 13, rt >>>= 13), rt & 127 || (pe += 7, rt >>>= 7), rt & 15 || (pe += 4, rt >>>= 4), rt & 3 || (pe += 2, rt >>>= 2), rt & 1 || pe++, pe;
      }, W.prototype.bitLength = function() {
        var Oe = this.words[this.length - 1], rt = this._countBits(Oe);
        return (this.length - 1) * 26 + rt;
      };
      function Ce(wt) {
        for (var Oe = new Array(wt.bitLength()), rt = 0; rt < Oe.length; rt++) {
          var pe = rt / 26 | 0, nt = rt % 26;
          Oe[rt] = (wt.words[pe] & 1 << nt) >>> nt;
        }
        return Oe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Oe = 0, rt = 0; rt < this.length; rt++) {
          var pe = this._zeroBits(this.words[rt]);
          if (Oe += pe, pe !== 26) break;
        }
        return Oe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(Oe) {
        return this.negative !== 0 ? this.abs().inotn(Oe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(Oe) {
        return this.testn(Oe - 1) ? this.notn(Oe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(Oe) {
        for (; this.length < Oe.length; )
          this.words[this.length++] = 0;
        for (var rt = 0; rt < Oe.length; rt++)
          this.words[rt] = this.words[rt] | Oe.words[rt];
        return this.strip();
      }, W.prototype.ior = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuor(Oe);
      }, W.prototype.or = function(Oe) {
        return this.length > Oe.length ? this.clone().ior(Oe) : Oe.clone().ior(this);
      }, W.prototype.uor = function(Oe) {
        return this.length > Oe.length ? this.clone().iuor(Oe) : Oe.clone().iuor(this);
      }, W.prototype.iuand = function(Oe) {
        var rt;
        this.length > Oe.length ? rt = Oe : rt = this;
        for (var pe = 0; pe < rt.length; pe++)
          this.words[pe] = this.words[pe] & Oe.words[pe];
        return this.length = rt.length, this.strip();
      }, W.prototype.iand = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuand(Oe);
      }, W.prototype.and = function(Oe) {
        return this.length > Oe.length ? this.clone().iand(Oe) : Oe.clone().iand(this);
      }, W.prototype.uand = function(Oe) {
        return this.length > Oe.length ? this.clone().iuand(Oe) : Oe.clone().iuand(this);
      }, W.prototype.iuxor = function(Oe) {
        var rt, pe;
        this.length > Oe.length ? (rt = this, pe = Oe) : (rt = Oe, pe = this);
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = rt.words[nt] ^ pe.words[nt];
        if (this !== rt)
          for (; nt < rt.length; nt++)
            this.words[nt] = rt.words[nt];
        return this.length = rt.length, this.strip();
      }, W.prototype.ixor = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuxor(Oe);
      }, W.prototype.xor = function(Oe) {
        return this.length > Oe.length ? this.clone().ixor(Oe) : Oe.clone().ixor(this);
      }, W.prototype.uxor = function(Oe) {
        return this.length > Oe.length ? this.clone().iuxor(Oe) : Oe.clone().iuxor(this);
      }, W.prototype.inotn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Math.ceil(Oe / 26) | 0, pe = Oe % 26;
        this._expand(rt), pe > 0 && rt--;
        for (var nt = 0; nt < rt; nt++)
          this.words[nt] = ~this.words[nt] & 67108863;
        return pe > 0 && (this.words[nt] = ~this.words[nt] & 67108863 >> 26 - pe), this.strip();
      }, W.prototype.notn = function(Oe) {
        return this.clone().inotn(Oe);
      }, W.prototype.setn = function(Oe, rt) {
        K(typeof Oe == "number" && Oe >= 0);
        var pe = Oe / 26 | 0, nt = Oe % 26;
        return this._expand(pe + 1), rt ? this.words[pe] = this.words[pe] | 1 << nt : this.words[pe] = this.words[pe] & ~(1 << nt), this.strip();
      }, W.prototype.iadd = function(Oe) {
        var rt;
        if (this.negative !== 0 && Oe.negative === 0)
          return this.negative = 0, rt = this.isub(Oe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Oe.negative !== 0)
          return Oe.negative = 0, rt = this.isub(Oe), Oe.negative = 1, rt._normSign();
        var pe, nt;
        this.length > Oe.length ? (pe = this, nt = Oe) : (pe = Oe, nt = this);
        for (var ot = 0, st = 0; st < nt.length; st++)
          rt = (pe.words[st] | 0) + (nt.words[st] | 0) + ot, this.words[st] = rt & 67108863, ot = rt >>> 26;
        for (; ot !== 0 && st < pe.length; st++)
          rt = (pe.words[st] | 0) + ot, this.words[st] = rt & 67108863, ot = rt >>> 26;
        if (this.length = pe.length, ot !== 0)
          this.words[this.length] = ot, this.length++;
        else if (pe !== this)
          for (; st < pe.length; st++)
            this.words[st] = pe.words[st];
        return this;
      }, W.prototype.add = function(Oe) {
        var rt;
        return Oe.negative !== 0 && this.negative === 0 ? (Oe.negative = 0, rt = this.sub(Oe), Oe.negative ^= 1, rt) : Oe.negative === 0 && this.negative !== 0 ? (this.negative = 0, rt = Oe.sub(this), this.negative = 1, rt) : this.length > Oe.length ? this.clone().iadd(Oe) : Oe.clone().iadd(this);
      }, W.prototype.isub = function(Oe) {
        if (Oe.negative !== 0) {
          Oe.negative = 0;
          var rt = this.iadd(Oe);
          return Oe.negative = 1, rt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Oe), this.negative = 1, this._normSign();
        var pe = this.cmp(Oe);
        if (pe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var nt, ot;
        pe > 0 ? (nt = this, ot = Oe) : (nt = Oe, ot = this);
        for (var st = 0, ut = 0; ut < ot.length; ut++)
          rt = (nt.words[ut] | 0) - (ot.words[ut] | 0) + st, st = rt >> 26, this.words[ut] = rt & 67108863;
        for (; st !== 0 && ut < nt.length; ut++)
          rt = (nt.words[ut] | 0) + st, st = rt >> 26, this.words[ut] = rt & 67108863;
        if (st === 0 && ut < nt.length && nt !== this)
          for (; ut < nt.length; ut++)
            this.words[ut] = nt.words[ut];
        return this.length = Math.max(this.length, ut), nt !== this && (this.negative = 1), this.strip();
      }, W.prototype.sub = function(Oe) {
        return this.clone().isub(Oe);
      };
      function it(wt, Oe, rt) {
        rt.negative = Oe.negative ^ wt.negative;
        var pe = wt.length + Oe.length | 0;
        rt.length = pe, pe = pe - 1 | 0;
        var nt = wt.words[0] | 0, ot = Oe.words[0] | 0, st = nt * ot, ut = st & 67108863, pt = st / 67108864 | 0;
        rt.words[0] = ut;
        for (var ft = 1; ft < pe; ft++) {
          for (var yt = pt >>> 26, ct = pt & 67108863, St = Math.min(ft, Oe.length - 1), qt = Math.max(0, ft - wt.length + 1); qt <= St; qt++) {
            var jt = ft - qt | 0;
            nt = wt.words[jt] | 0, ot = Oe.words[qt] | 0, st = nt * ot + ct, yt += st / 67108864 | 0, ct = st & 67108863;
          }
          rt.words[ft] = ct | 0, pt = yt | 0;
        }
        return pt !== 0 ? rt.words[ft] = pt | 0 : rt.length--, rt.strip();
      }
      var at = function(Oe, rt, pe) {
        var nt = Oe.words, ot = rt.words, st = pe.words, ut = 0, pt, ft, yt, ct = nt[0] | 0, St = ct & 8191, qt = ct >>> 13, jt = nt[1] | 0, Ot = jt & 8191, Tt = jt >>> 13, Rt = nt[2] | 0, Ut = Rt & 8191, Gt = Rt >>> 13, Mt = nt[3] | 0, Pt = Mt & 8191, Kt = Mt >>> 13, Zt = nt[4] | 0, rr = Zt & 8191, ar = Zt >>> 13, ur = nt[5] | 0, hr = ur & 8191, Yt = ur >>> 13, Ir = nt[6] | 0, lr = Ir & 8191, Ar = Ir >>> 13, Br = nt[7] | 0, dr = Br & 8191, Er = Br >>> 13, Pr = nt[8] | 0, br = Pr & 8191, Mr = Pr >>> 13, Or = nt[9] | 0, It = Or & 8191, gt = Or >>> 13, Et = ot[0] | 0, Ct = Et & 8191, Wt = Et >>> 13, zt = ot[1] | 0, Vt = zt & 8191, yr = zt >>> 13, $r = ot[2] | 0, cr = $r & 8191, xr = $r >>> 13, gr = ot[3] | 0, _r = gr & 8191, kr = gr >>> 13, Cr = ot[4] | 0, Ft = Cr & 8191, kt = Cr >>> 13, Dt = ot[5] | 0, Ht = Dt & 8191, Xt = Dt >>> 13, Qt = ot[6] | 0, tr = Qt & 8191, nr = Qt >>> 13, fr = ot[7] | 0, ir = fr & 8191, pr = fr >>> 13, wr = ot[8] | 0, sr = wr & 8191, Lt = wr >>> 13, Jt = ot[9] | 0, er = Jt & 8191, or = Jt >>> 13;
        pe.negative = Oe.negative ^ rt.negative, pe.length = 19, pt = Math.imul(St, Ct), ft = Math.imul(St, Wt), ft = ft + Math.imul(qt, Ct) | 0, yt = Math.imul(qt, Wt);
        var vr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, pt = Math.imul(Ot, Ct), ft = Math.imul(Ot, Wt), ft = ft + Math.imul(Tt, Ct) | 0, yt = Math.imul(Tt, Wt), pt = pt + Math.imul(St, Vt) | 0, ft = ft + Math.imul(St, yr) | 0, ft = ft + Math.imul(qt, Vt) | 0, yt = yt + Math.imul(qt, yr) | 0;
        var Sr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, pt = Math.imul(Ut, Ct), ft = Math.imul(Ut, Wt), ft = ft + Math.imul(Gt, Ct) | 0, yt = Math.imul(Gt, Wt), pt = pt + Math.imul(Ot, Vt) | 0, ft = ft + Math.imul(Ot, yr) | 0, ft = ft + Math.imul(Tt, Vt) | 0, yt = yt + Math.imul(Tt, yr) | 0, pt = pt + Math.imul(St, cr) | 0, ft = ft + Math.imul(St, xr) | 0, ft = ft + Math.imul(qt, cr) | 0, yt = yt + Math.imul(qt, xr) | 0;
        var Rr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, pt = Math.imul(Pt, Ct), ft = Math.imul(Pt, Wt), ft = ft + Math.imul(Kt, Ct) | 0, yt = Math.imul(Kt, Wt), pt = pt + Math.imul(Ut, Vt) | 0, ft = ft + Math.imul(Ut, yr) | 0, ft = ft + Math.imul(Gt, Vt) | 0, yt = yt + Math.imul(Gt, yr) | 0, pt = pt + Math.imul(Ot, cr) | 0, ft = ft + Math.imul(Ot, xr) | 0, ft = ft + Math.imul(Tt, cr) | 0, yt = yt + Math.imul(Tt, xr) | 0, pt = pt + Math.imul(St, _r) | 0, ft = ft + Math.imul(St, kr) | 0, ft = ft + Math.imul(qt, _r) | 0, yt = yt + Math.imul(qt, kr) | 0;
        var Tr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, pt = Math.imul(rr, Ct), ft = Math.imul(rr, Wt), ft = ft + Math.imul(ar, Ct) | 0, yt = Math.imul(ar, Wt), pt = pt + Math.imul(Pt, Vt) | 0, ft = ft + Math.imul(Pt, yr) | 0, ft = ft + Math.imul(Kt, Vt) | 0, yt = yt + Math.imul(Kt, yr) | 0, pt = pt + Math.imul(Ut, cr) | 0, ft = ft + Math.imul(Ut, xr) | 0, ft = ft + Math.imul(Gt, cr) | 0, yt = yt + Math.imul(Gt, xr) | 0, pt = pt + Math.imul(Ot, _r) | 0, ft = ft + Math.imul(Ot, kr) | 0, ft = ft + Math.imul(Tt, _r) | 0, yt = yt + Math.imul(Tt, kr) | 0, pt = pt + Math.imul(St, Ft) | 0, ft = ft + Math.imul(St, kt) | 0, ft = ft + Math.imul(qt, Ft) | 0, yt = yt + Math.imul(qt, kt) | 0;
        var Nr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, pt = Math.imul(hr, Ct), ft = Math.imul(hr, Wt), ft = ft + Math.imul(Yt, Ct) | 0, yt = Math.imul(Yt, Wt), pt = pt + Math.imul(rr, Vt) | 0, ft = ft + Math.imul(rr, yr) | 0, ft = ft + Math.imul(ar, Vt) | 0, yt = yt + Math.imul(ar, yr) | 0, pt = pt + Math.imul(Pt, cr) | 0, ft = ft + Math.imul(Pt, xr) | 0, ft = ft + Math.imul(Kt, cr) | 0, yt = yt + Math.imul(Kt, xr) | 0, pt = pt + Math.imul(Ut, _r) | 0, ft = ft + Math.imul(Ut, kr) | 0, ft = ft + Math.imul(Gt, _r) | 0, yt = yt + Math.imul(Gt, kr) | 0, pt = pt + Math.imul(Ot, Ft) | 0, ft = ft + Math.imul(Ot, kt) | 0, ft = ft + Math.imul(Tt, Ft) | 0, yt = yt + Math.imul(Tt, kt) | 0, pt = pt + Math.imul(St, Ht) | 0, ft = ft + Math.imul(St, Xt) | 0, ft = ft + Math.imul(qt, Ht) | 0, yt = yt + Math.imul(qt, Xt) | 0;
        var qr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(lr, Ct), ft = Math.imul(lr, Wt), ft = ft + Math.imul(Ar, Ct) | 0, yt = Math.imul(Ar, Wt), pt = pt + Math.imul(hr, Vt) | 0, ft = ft + Math.imul(hr, yr) | 0, ft = ft + Math.imul(Yt, Vt) | 0, yt = yt + Math.imul(Yt, yr) | 0, pt = pt + Math.imul(rr, cr) | 0, ft = ft + Math.imul(rr, xr) | 0, ft = ft + Math.imul(ar, cr) | 0, yt = yt + Math.imul(ar, xr) | 0, pt = pt + Math.imul(Pt, _r) | 0, ft = ft + Math.imul(Pt, kr) | 0, ft = ft + Math.imul(Kt, _r) | 0, yt = yt + Math.imul(Kt, kr) | 0, pt = pt + Math.imul(Ut, Ft) | 0, ft = ft + Math.imul(Ut, kt) | 0, ft = ft + Math.imul(Gt, Ft) | 0, yt = yt + Math.imul(Gt, kt) | 0, pt = pt + Math.imul(Ot, Ht) | 0, ft = ft + Math.imul(Ot, Xt) | 0, ft = ft + Math.imul(Tt, Ht) | 0, yt = yt + Math.imul(Tt, Xt) | 0, pt = pt + Math.imul(St, tr) | 0, ft = ft + Math.imul(St, nr) | 0, ft = ft + Math.imul(qt, tr) | 0, yt = yt + Math.imul(qt, nr) | 0;
        var Fr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(dr, Ct), ft = Math.imul(dr, Wt), ft = ft + Math.imul(Er, Ct) | 0, yt = Math.imul(Er, Wt), pt = pt + Math.imul(lr, Vt) | 0, ft = ft + Math.imul(lr, yr) | 0, ft = ft + Math.imul(Ar, Vt) | 0, yt = yt + Math.imul(Ar, yr) | 0, pt = pt + Math.imul(hr, cr) | 0, ft = ft + Math.imul(hr, xr) | 0, ft = ft + Math.imul(Yt, cr) | 0, yt = yt + Math.imul(Yt, xr) | 0, pt = pt + Math.imul(rr, _r) | 0, ft = ft + Math.imul(rr, kr) | 0, ft = ft + Math.imul(ar, _r) | 0, yt = yt + Math.imul(ar, kr) | 0, pt = pt + Math.imul(Pt, Ft) | 0, ft = ft + Math.imul(Pt, kt) | 0, ft = ft + Math.imul(Kt, Ft) | 0, yt = yt + Math.imul(Kt, kt) | 0, pt = pt + Math.imul(Ut, Ht) | 0, ft = ft + Math.imul(Ut, Xt) | 0, ft = ft + Math.imul(Gt, Ht) | 0, yt = yt + Math.imul(Gt, Xt) | 0, pt = pt + Math.imul(Ot, tr) | 0, ft = ft + Math.imul(Ot, nr) | 0, ft = ft + Math.imul(Tt, tr) | 0, yt = yt + Math.imul(Tt, nr) | 0, pt = pt + Math.imul(St, ir) | 0, ft = ft + Math.imul(St, pr) | 0, ft = ft + Math.imul(qt, ir) | 0, yt = yt + Math.imul(qt, pr) | 0;
        var Ur = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(br, Ct), ft = Math.imul(br, Wt), ft = ft + Math.imul(Mr, Ct) | 0, yt = Math.imul(Mr, Wt), pt = pt + Math.imul(dr, Vt) | 0, ft = ft + Math.imul(dr, yr) | 0, ft = ft + Math.imul(Er, Vt) | 0, yt = yt + Math.imul(Er, yr) | 0, pt = pt + Math.imul(lr, cr) | 0, ft = ft + Math.imul(lr, xr) | 0, ft = ft + Math.imul(Ar, cr) | 0, yt = yt + Math.imul(Ar, xr) | 0, pt = pt + Math.imul(hr, _r) | 0, ft = ft + Math.imul(hr, kr) | 0, ft = ft + Math.imul(Yt, _r) | 0, yt = yt + Math.imul(Yt, kr) | 0, pt = pt + Math.imul(rr, Ft) | 0, ft = ft + Math.imul(rr, kt) | 0, ft = ft + Math.imul(ar, Ft) | 0, yt = yt + Math.imul(ar, kt) | 0, pt = pt + Math.imul(Pt, Ht) | 0, ft = ft + Math.imul(Pt, Xt) | 0, ft = ft + Math.imul(Kt, Ht) | 0, yt = yt + Math.imul(Kt, Xt) | 0, pt = pt + Math.imul(Ut, tr) | 0, ft = ft + Math.imul(Ut, nr) | 0, ft = ft + Math.imul(Gt, tr) | 0, yt = yt + Math.imul(Gt, nr) | 0, pt = pt + Math.imul(Ot, ir) | 0, ft = ft + Math.imul(Ot, pr) | 0, ft = ft + Math.imul(Tt, ir) | 0, yt = yt + Math.imul(Tt, pr) | 0, pt = pt + Math.imul(St, sr) | 0, ft = ft + Math.imul(St, Lt) | 0, ft = ft + Math.imul(qt, sr) | 0, yt = yt + Math.imul(qt, Lt) | 0;
        var jr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(It, Ct), ft = Math.imul(It, Wt), ft = ft + Math.imul(gt, Ct) | 0, yt = Math.imul(gt, Wt), pt = pt + Math.imul(br, Vt) | 0, ft = ft + Math.imul(br, yr) | 0, ft = ft + Math.imul(Mr, Vt) | 0, yt = yt + Math.imul(Mr, yr) | 0, pt = pt + Math.imul(dr, cr) | 0, ft = ft + Math.imul(dr, xr) | 0, ft = ft + Math.imul(Er, cr) | 0, yt = yt + Math.imul(Er, xr) | 0, pt = pt + Math.imul(lr, _r) | 0, ft = ft + Math.imul(lr, kr) | 0, ft = ft + Math.imul(Ar, _r) | 0, yt = yt + Math.imul(Ar, kr) | 0, pt = pt + Math.imul(hr, Ft) | 0, ft = ft + Math.imul(hr, kt) | 0, ft = ft + Math.imul(Yt, Ft) | 0, yt = yt + Math.imul(Yt, kt) | 0, pt = pt + Math.imul(rr, Ht) | 0, ft = ft + Math.imul(rr, Xt) | 0, ft = ft + Math.imul(ar, Ht) | 0, yt = yt + Math.imul(ar, Xt) | 0, pt = pt + Math.imul(Pt, tr) | 0, ft = ft + Math.imul(Pt, nr) | 0, ft = ft + Math.imul(Kt, tr) | 0, yt = yt + Math.imul(Kt, nr) | 0, pt = pt + Math.imul(Ut, ir) | 0, ft = ft + Math.imul(Ut, pr) | 0, ft = ft + Math.imul(Gt, ir) | 0, yt = yt + Math.imul(Gt, pr) | 0, pt = pt + Math.imul(Ot, sr) | 0, ft = ft + Math.imul(Ot, Lt) | 0, ft = ft + Math.imul(Tt, sr) | 0, yt = yt + Math.imul(Tt, Lt) | 0, pt = pt + Math.imul(St, er) | 0, ft = ft + Math.imul(St, or) | 0, ft = ft + Math.imul(qt, er) | 0, yt = yt + Math.imul(qt, or) | 0;
        var Dr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, pt = Math.imul(It, Vt), ft = Math.imul(It, yr), ft = ft + Math.imul(gt, Vt) | 0, yt = Math.imul(gt, yr), pt = pt + Math.imul(br, cr) | 0, ft = ft + Math.imul(br, xr) | 0, ft = ft + Math.imul(Mr, cr) | 0, yt = yt + Math.imul(Mr, xr) | 0, pt = pt + Math.imul(dr, _r) | 0, ft = ft + Math.imul(dr, kr) | 0, ft = ft + Math.imul(Er, _r) | 0, yt = yt + Math.imul(Er, kr) | 0, pt = pt + Math.imul(lr, Ft) | 0, ft = ft + Math.imul(lr, kt) | 0, ft = ft + Math.imul(Ar, Ft) | 0, yt = yt + Math.imul(Ar, kt) | 0, pt = pt + Math.imul(hr, Ht) | 0, ft = ft + Math.imul(hr, Xt) | 0, ft = ft + Math.imul(Yt, Ht) | 0, yt = yt + Math.imul(Yt, Xt) | 0, pt = pt + Math.imul(rr, tr) | 0, ft = ft + Math.imul(rr, nr) | 0, ft = ft + Math.imul(ar, tr) | 0, yt = yt + Math.imul(ar, nr) | 0, pt = pt + Math.imul(Pt, ir) | 0, ft = ft + Math.imul(Pt, pr) | 0, ft = ft + Math.imul(Kt, ir) | 0, yt = yt + Math.imul(Kt, pr) | 0, pt = pt + Math.imul(Ut, sr) | 0, ft = ft + Math.imul(Ut, Lt) | 0, ft = ft + Math.imul(Gt, sr) | 0, yt = yt + Math.imul(Gt, Lt) | 0, pt = pt + Math.imul(Ot, er) | 0, ft = ft + Math.imul(Ot, or) | 0, ft = ft + Math.imul(Tt, er) | 0, yt = yt + Math.imul(Tt, or) | 0;
        var Lr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, pt = Math.imul(It, cr), ft = Math.imul(It, xr), ft = ft + Math.imul(gt, cr) | 0, yt = Math.imul(gt, xr), pt = pt + Math.imul(br, _r) | 0, ft = ft + Math.imul(br, kr) | 0, ft = ft + Math.imul(Mr, _r) | 0, yt = yt + Math.imul(Mr, kr) | 0, pt = pt + Math.imul(dr, Ft) | 0, ft = ft + Math.imul(dr, kt) | 0, ft = ft + Math.imul(Er, Ft) | 0, yt = yt + Math.imul(Er, kt) | 0, pt = pt + Math.imul(lr, Ht) | 0, ft = ft + Math.imul(lr, Xt) | 0, ft = ft + Math.imul(Ar, Ht) | 0, yt = yt + Math.imul(Ar, Xt) | 0, pt = pt + Math.imul(hr, tr) | 0, ft = ft + Math.imul(hr, nr) | 0, ft = ft + Math.imul(Yt, tr) | 0, yt = yt + Math.imul(Yt, nr) | 0, pt = pt + Math.imul(rr, ir) | 0, ft = ft + Math.imul(rr, pr) | 0, ft = ft + Math.imul(ar, ir) | 0, yt = yt + Math.imul(ar, pr) | 0, pt = pt + Math.imul(Pt, sr) | 0, ft = ft + Math.imul(Pt, Lt) | 0, ft = ft + Math.imul(Kt, sr) | 0, yt = yt + Math.imul(Kt, Lt) | 0, pt = pt + Math.imul(Ut, er) | 0, ft = ft + Math.imul(Ut, or) | 0, ft = ft + Math.imul(Gt, er) | 0, yt = yt + Math.imul(Gt, or) | 0;
        var Hr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, pt = Math.imul(It, _r), ft = Math.imul(It, kr), ft = ft + Math.imul(gt, _r) | 0, yt = Math.imul(gt, kr), pt = pt + Math.imul(br, Ft) | 0, ft = ft + Math.imul(br, kt) | 0, ft = ft + Math.imul(Mr, Ft) | 0, yt = yt + Math.imul(Mr, kt) | 0, pt = pt + Math.imul(dr, Ht) | 0, ft = ft + Math.imul(dr, Xt) | 0, ft = ft + Math.imul(Er, Ht) | 0, yt = yt + Math.imul(Er, Xt) | 0, pt = pt + Math.imul(lr, tr) | 0, ft = ft + Math.imul(lr, nr) | 0, ft = ft + Math.imul(Ar, tr) | 0, yt = yt + Math.imul(Ar, nr) | 0, pt = pt + Math.imul(hr, ir) | 0, ft = ft + Math.imul(hr, pr) | 0, ft = ft + Math.imul(Yt, ir) | 0, yt = yt + Math.imul(Yt, pr) | 0, pt = pt + Math.imul(rr, sr) | 0, ft = ft + Math.imul(rr, Lt) | 0, ft = ft + Math.imul(ar, sr) | 0, yt = yt + Math.imul(ar, Lt) | 0, pt = pt + Math.imul(Pt, er) | 0, ft = ft + Math.imul(Pt, or) | 0, ft = ft + Math.imul(Kt, er) | 0, yt = yt + Math.imul(Kt, or) | 0;
        var Wr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, pt = Math.imul(It, Ft), ft = Math.imul(It, kt), ft = ft + Math.imul(gt, Ft) | 0, yt = Math.imul(gt, kt), pt = pt + Math.imul(br, Ht) | 0, ft = ft + Math.imul(br, Xt) | 0, ft = ft + Math.imul(Mr, Ht) | 0, yt = yt + Math.imul(Mr, Xt) | 0, pt = pt + Math.imul(dr, tr) | 0, ft = ft + Math.imul(dr, nr) | 0, ft = ft + Math.imul(Er, tr) | 0, yt = yt + Math.imul(Er, nr) | 0, pt = pt + Math.imul(lr, ir) | 0, ft = ft + Math.imul(lr, pr) | 0, ft = ft + Math.imul(Ar, ir) | 0, yt = yt + Math.imul(Ar, pr) | 0, pt = pt + Math.imul(hr, sr) | 0, ft = ft + Math.imul(hr, Lt) | 0, ft = ft + Math.imul(Yt, sr) | 0, yt = yt + Math.imul(Yt, Lt) | 0, pt = pt + Math.imul(rr, er) | 0, ft = ft + Math.imul(rr, or) | 0, ft = ft + Math.imul(ar, er) | 0, yt = yt + Math.imul(ar, or) | 0;
        var Gr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(It, Ht), ft = Math.imul(It, Xt), ft = ft + Math.imul(gt, Ht) | 0, yt = Math.imul(gt, Xt), pt = pt + Math.imul(br, tr) | 0, ft = ft + Math.imul(br, nr) | 0, ft = ft + Math.imul(Mr, tr) | 0, yt = yt + Math.imul(Mr, nr) | 0, pt = pt + Math.imul(dr, ir) | 0, ft = ft + Math.imul(dr, pr) | 0, ft = ft + Math.imul(Er, ir) | 0, yt = yt + Math.imul(Er, pr) | 0, pt = pt + Math.imul(lr, sr) | 0, ft = ft + Math.imul(lr, Lt) | 0, ft = ft + Math.imul(Ar, sr) | 0, yt = yt + Math.imul(Ar, Lt) | 0, pt = pt + Math.imul(hr, er) | 0, ft = ft + Math.imul(hr, or) | 0, ft = ft + Math.imul(Yt, er) | 0, yt = yt + Math.imul(Yt, or) | 0;
        var zr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, pt = Math.imul(It, tr), ft = Math.imul(It, nr), ft = ft + Math.imul(gt, tr) | 0, yt = Math.imul(gt, nr), pt = pt + Math.imul(br, ir) | 0, ft = ft + Math.imul(br, pr) | 0, ft = ft + Math.imul(Mr, ir) | 0, yt = yt + Math.imul(Mr, pr) | 0, pt = pt + Math.imul(dr, sr) | 0, ft = ft + Math.imul(dr, Lt) | 0, ft = ft + Math.imul(Er, sr) | 0, yt = yt + Math.imul(Er, Lt) | 0, pt = pt + Math.imul(lr, er) | 0, ft = ft + Math.imul(lr, or) | 0, ft = ft + Math.imul(Ar, er) | 0, yt = yt + Math.imul(Ar, or) | 0;
        var Vr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(It, ir), ft = Math.imul(It, pr), ft = ft + Math.imul(gt, ir) | 0, yt = Math.imul(gt, pr), pt = pt + Math.imul(br, sr) | 0, ft = ft + Math.imul(br, Lt) | 0, ft = ft + Math.imul(Mr, sr) | 0, yt = yt + Math.imul(Mr, Lt) | 0, pt = pt + Math.imul(dr, er) | 0, ft = ft + Math.imul(dr, or) | 0, ft = ft + Math.imul(Er, er) | 0, yt = yt + Math.imul(Er, or) | 0;
        var Xr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, pt = Math.imul(It, sr), ft = Math.imul(It, Lt), ft = ft + Math.imul(gt, sr) | 0, yt = Math.imul(gt, Lt), pt = pt + Math.imul(br, er) | 0, ft = ft + Math.imul(br, or) | 0, ft = ft + Math.imul(Mr, er) | 0, yt = yt + Math.imul(Mr, or) | 0;
        var Yr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        ut = (yt + (ft >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, pt = Math.imul(It, er), ft = Math.imul(It, or), ft = ft + Math.imul(gt, er) | 0, yt = Math.imul(gt, or);
        var Jr = (ut + pt | 0) + ((ft & 8191) << 13) | 0;
        return ut = (yt + (ft >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, st[0] = vr, st[1] = Sr, st[2] = Rr, st[3] = Tr, st[4] = Nr, st[5] = qr, st[6] = Fr, st[7] = Ur, st[8] = jr, st[9] = Dr, st[10] = Lr, st[11] = Hr, st[12] = Wr, st[13] = Gr, st[14] = zr, st[15] = Vr, st[16] = Xr, st[17] = Yr, st[18] = Jr, ut !== 0 && (st[19] = ut, pe.length++), pe;
      };
      Math.imul || (at = it);
      function lt(wt, Oe, rt) {
        rt.negative = Oe.negative ^ wt.negative, rt.length = wt.length + Oe.length;
        for (var pe = 0, nt = 0, ot = 0; ot < rt.length - 1; ot++) {
          var st = nt;
          nt = 0;
          for (var ut = pe & 67108863, pt = Math.min(ot, Oe.length - 1), ft = Math.max(0, ot - wt.length + 1); ft <= pt; ft++) {
            var yt = ot - ft, ct = wt.words[yt] | 0, St = Oe.words[ft] | 0, qt = ct * St, jt = qt & 67108863;
            st = st + (qt / 67108864 | 0) | 0, jt = jt + ut | 0, ut = jt & 67108863, st = st + (jt >>> 26) | 0, nt += st >>> 26, st &= 67108863;
          }
          rt.words[ot] = ut, pe = st, st = nt;
        }
        return pe !== 0 ? rt.words[ot] = pe : rt.length--, rt.strip();
      }
      function ht(wt, Oe, rt) {
        var pe = new dt();
        return pe.mulp(wt, Oe, rt);
      }
      W.prototype.mulTo = function(Oe, rt) {
        var pe, nt = this.length + Oe.length;
        return this.length === 10 && Oe.length === 10 ? pe = at(this, Oe, rt) : nt < 63 ? pe = it(this, Oe, rt) : nt < 1024 ? pe = lt(this, Oe, rt) : pe = ht(this, Oe, rt), pe;
      };
      function dt(wt, Oe) {
        this.x = wt, this.y = Oe;
      }
      dt.prototype.makeRBT = function(Oe) {
        for (var rt = new Array(Oe), pe = W.prototype._countBits(Oe) - 1, nt = 0; nt < Oe; nt++)
          rt[nt] = this.revBin(nt, pe, Oe);
        return rt;
      }, dt.prototype.revBin = function(Oe, rt, pe) {
        if (Oe === 0 || Oe === pe - 1) return Oe;
        for (var nt = 0, ot = 0; ot < rt; ot++)
          nt |= (Oe & 1) << rt - ot - 1, Oe >>= 1;
        return nt;
      }, dt.prototype.permute = function(Oe, rt, pe, nt, ot, st) {
        for (var ut = 0; ut < st; ut++)
          nt[ut] = rt[Oe[ut]], ot[ut] = pe[Oe[ut]];
      }, dt.prototype.transform = function(Oe, rt, pe, nt, ot, st) {
        this.permute(st, Oe, rt, pe, nt, ot);
        for (var ut = 1; ut < ot; ut <<= 1)
          for (var pt = ut << 1, ft = Math.cos(2 * Math.PI / pt), yt = Math.sin(2 * Math.PI / pt), ct = 0; ct < ot; ct += pt)
            for (var St = ft, qt = yt, jt = 0; jt < ut; jt++) {
              var Ot = pe[ct + jt], Tt = nt[ct + jt], Rt = pe[ct + jt + ut], Ut = nt[ct + jt + ut], Gt = St * Rt - qt * Ut;
              Ut = St * Ut + qt * Rt, Rt = Gt, pe[ct + jt] = Ot + Rt, nt[ct + jt] = Tt + Ut, pe[ct + jt + ut] = Ot - Rt, nt[ct + jt + ut] = Tt - Ut, jt !== pt && (Gt = ft * St - yt * qt, qt = ft * qt + yt * St, St = Gt);
            }
      }, dt.prototype.guessLen13b = function(Oe, rt) {
        var pe = Math.max(rt, Oe) | 1, nt = pe & 1, ot = 0;
        for (pe = pe / 2 | 0; pe; pe = pe >>> 1)
          ot++;
        return 1 << ot + 1 + nt;
      }, dt.prototype.conjugate = function(Oe, rt, pe) {
        if (!(pe <= 1))
          for (var nt = 0; nt < pe / 2; nt++) {
            var ot = Oe[nt];
            Oe[nt] = Oe[pe - nt - 1], Oe[pe - nt - 1] = ot, ot = rt[nt], rt[nt] = -rt[pe - nt - 1], rt[pe - nt - 1] = -ot;
          }
      }, dt.prototype.normalize13b = function(Oe, rt) {
        for (var pe = 0, nt = 0; nt < rt / 2; nt++) {
          var ot = Math.round(Oe[2 * nt + 1] / rt) * 8192 + Math.round(Oe[2 * nt] / rt) + pe;
          Oe[nt] = ot & 67108863, ot < 67108864 ? pe = 0 : pe = ot / 67108864 | 0;
        }
        return Oe;
      }, dt.prototype.convert13b = function(Oe, rt, pe, nt) {
        for (var ot = 0, st = 0; st < rt; st++)
          ot = ot + (Oe[st] | 0), pe[2 * st] = ot & 8191, ot = ot >>> 13, pe[2 * st + 1] = ot & 8191, ot = ot >>> 13;
        for (st = 2 * rt; st < nt; ++st)
          pe[st] = 0;
        K(ot === 0), K((ot & -8192) === 0);
      }, dt.prototype.stub = function(Oe) {
        for (var rt = new Array(Oe), pe = 0; pe < Oe; pe++)
          rt[pe] = 0;
        return rt;
      }, dt.prototype.mulp = function(Oe, rt, pe) {
        var nt = 2 * this.guessLen13b(Oe.length, rt.length), ot = this.makeRBT(nt), st = this.stub(nt), ut = new Array(nt), pt = new Array(nt), ft = new Array(nt), yt = new Array(nt), ct = new Array(nt), St = new Array(nt), qt = pe.words;
        qt.length = nt, this.convert13b(Oe.words, Oe.length, ut, nt), this.convert13b(rt.words, rt.length, yt, nt), this.transform(ut, st, pt, ft, nt, ot), this.transform(yt, st, ct, St, nt, ot);
        for (var jt = 0; jt < nt; jt++) {
          var Ot = pt[jt] * ct[jt] - ft[jt] * St[jt];
          ft[jt] = pt[jt] * St[jt] + ft[jt] * ct[jt], pt[jt] = Ot;
        }
        return this.conjugate(pt, ft, nt), this.transform(pt, ft, qt, st, nt, ot), this.conjugate(qt, st, nt), this.normalize13b(qt, nt), pe.negative = Oe.negative ^ rt.negative, pe.length = Oe.length + rt.length, pe.strip();
      }, W.prototype.mul = function(Oe) {
        var rt = new W(null);
        return rt.words = new Array(this.length + Oe.length), this.mulTo(Oe, rt);
      }, W.prototype.mulf = function(Oe) {
        var rt = new W(null);
        return rt.words = new Array(this.length + Oe.length), ht(this, Oe, rt);
      }, W.prototype.imul = function(Oe) {
        return this.clone().mulTo(Oe, this);
      }, W.prototype.imuln = function(Oe) {
        K(typeof Oe == "number"), K(Oe < 67108864);
        for (var rt = 0, pe = 0; pe < this.length; pe++) {
          var nt = (this.words[pe] | 0) * Oe, ot = (nt & 67108863) + (rt & 67108863);
          rt >>= 26, rt += nt / 67108864 | 0, rt += ot >>> 26, this.words[pe] = ot & 67108863;
        }
        return rt !== 0 && (this.words[pe] = rt, this.length++), this;
      }, W.prototype.muln = function(Oe) {
        return this.clone().imuln(Oe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(Oe) {
        var rt = Ce(Oe);
        if (rt.length === 0) return new W(1);
        for (var pe = this, nt = 0; nt < rt.length && rt[nt] === 0; nt++, pe = pe.sqr())
          ;
        if (++nt < rt.length)
          for (var ot = pe.sqr(); nt < rt.length; nt++, ot = ot.sqr())
            rt[nt] !== 0 && (pe = pe.mul(ot));
        return pe;
      }, W.prototype.iushln = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 67108863 >>> 26 - rt << 26 - rt, ot;
        if (rt !== 0) {
          var st = 0;
          for (ot = 0; ot < this.length; ot++) {
            var ut = this.words[ot] & nt, pt = (this.words[ot] | 0) - ut << rt;
            this.words[ot] = pt | st, st = ut >>> 26 - rt;
          }
          st && (this.words[ot] = st, this.length++);
        }
        if (pe !== 0) {
          for (ot = this.length - 1; ot >= 0; ot--)
            this.words[ot + pe] = this.words[ot];
          for (ot = 0; ot < pe; ot++)
            this.words[ot] = 0;
          this.length += pe;
        }
        return this.strip();
      }, W.prototype.ishln = function(Oe) {
        return K(this.negative === 0), this.iushln(Oe);
      }, W.prototype.iushrn = function(Oe, rt, pe) {
        K(typeof Oe == "number" && Oe >= 0);
        var nt;
        rt ? nt = (rt - rt % 26) / 26 : nt = 0;
        var ot = Oe % 26, st = Math.min((Oe - ot) / 26, this.length), ut = 67108863 ^ 67108863 >>> ot << ot, pt = pe;
        if (nt -= st, nt = Math.max(0, nt), pt) {
          for (var ft = 0; ft < st; ft++)
            pt.words[ft] = this.words[ft];
          pt.length = st;
        }
        if (st !== 0) if (this.length > st)
          for (this.length -= st, ft = 0; ft < this.length; ft++)
            this.words[ft] = this.words[ft + st];
        else
          this.words[0] = 0, this.length = 1;
        var yt = 0;
        for (ft = this.length - 1; ft >= 0 && (yt !== 0 || ft >= nt); ft--) {
          var ct = this.words[ft] | 0;
          this.words[ft] = yt << 26 - ot | ct >>> ot, yt = ct & ut;
        }
        return pt && yt !== 0 && (pt.words[pt.length++] = yt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, W.prototype.ishrn = function(Oe, rt, pe) {
        return K(this.negative === 0), this.iushrn(Oe, rt, pe);
      }, W.prototype.shln = function(Oe) {
        return this.clone().ishln(Oe);
      }, W.prototype.ushln = function(Oe) {
        return this.clone().iushln(Oe);
      }, W.prototype.shrn = function(Oe) {
        return this.clone().ishrn(Oe);
      }, W.prototype.ushrn = function(Oe) {
        return this.clone().iushrn(Oe);
      }, W.prototype.testn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 1 << rt;
        if (this.length <= pe) return !1;
        var ot = this.words[pe];
        return !!(ot & nt);
      }, W.prototype.imaskn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= pe)
          return this;
        if (rt !== 0 && pe++, this.length = Math.min(pe, this.length), rt !== 0) {
          var nt = 67108863 ^ 67108863 >>> rt << rt;
          this.words[this.length - 1] &= nt;
        }
        return this.strip();
      }, W.prototype.maskn = function(Oe) {
        return this.clone().imaskn(Oe);
      }, W.prototype.iaddn = function(Oe) {
        return K(typeof Oe == "number"), K(Oe < 67108864), Oe < 0 ? this.isubn(-Oe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Oe ? (this.words[0] = Oe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Oe), this.negative = 1, this) : this._iaddn(Oe);
      }, W.prototype._iaddn = function(Oe) {
        this.words[0] += Oe;
        for (var rt = 0; rt < this.length && this.words[rt] >= 67108864; rt++)
          this.words[rt] -= 67108864, rt === this.length - 1 ? this.words[rt + 1] = 1 : this.words[rt + 1]++;
        return this.length = Math.max(this.length, rt + 1), this;
      }, W.prototype.isubn = function(Oe) {
        if (K(typeof Oe == "number"), K(Oe < 67108864), Oe < 0) return this.iaddn(-Oe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Oe), this.negative = 1, this;
        if (this.words[0] -= Oe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var rt = 0; rt < this.length && this.words[rt] < 0; rt++)
            this.words[rt] += 67108864, this.words[rt + 1] -= 1;
        return this.strip();
      }, W.prototype.addn = function(Oe) {
        return this.clone().iaddn(Oe);
      }, W.prototype.subn = function(Oe) {
        return this.clone().isubn(Oe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(Oe, rt, pe) {
        var nt = Oe.length + pe, ot;
        this._expand(nt);
        var st, ut = 0;
        for (ot = 0; ot < Oe.length; ot++) {
          st = (this.words[ot + pe] | 0) + ut;
          var pt = (Oe.words[ot] | 0) * rt;
          st -= pt & 67108863, ut = (st >> 26) - (pt / 67108864 | 0), this.words[ot + pe] = st & 67108863;
        }
        for (; ot < this.length - pe; ot++)
          st = (this.words[ot + pe] | 0) + ut, ut = st >> 26, this.words[ot + pe] = st & 67108863;
        if (ut === 0) return this.strip();
        for (K(ut === -1), ut = 0, ot = 0; ot < this.length; ot++)
          st = -(this.words[ot] | 0) + ut, ut = st >> 26, this.words[ot] = st & 67108863;
        return this.negative = 1, this.strip();
      }, W.prototype._wordDiv = function(Oe, rt) {
        var pe = this.length - Oe.length, nt = this.clone(), ot = Oe, st = ot.words[ot.length - 1] | 0, ut = this._countBits(st);
        pe = 26 - ut, pe !== 0 && (ot = ot.ushln(pe), nt.iushln(pe), st = ot.words[ot.length - 1] | 0);
        var pt = nt.length - ot.length, ft;
        if (rt !== "mod") {
          ft = new W(null), ft.length = pt + 1, ft.words = new Array(ft.length);
          for (var yt = 0; yt < ft.length; yt++)
            ft.words[yt] = 0;
        }
        var ct = nt.clone()._ishlnsubmul(ot, 1, pt);
        ct.negative === 0 && (nt = ct, ft && (ft.words[pt] = 1));
        for (var St = pt - 1; St >= 0; St--) {
          var qt = (nt.words[ot.length + St] | 0) * 67108864 + (nt.words[ot.length + St - 1] | 0);
          for (qt = Math.min(qt / st | 0, 67108863), nt._ishlnsubmul(ot, qt, St); nt.negative !== 0; )
            qt--, nt.negative = 0, nt._ishlnsubmul(ot, 1, St), nt.isZero() || (nt.negative ^= 1);
          ft && (ft.words[St] = qt);
        }
        return ft && ft.strip(), nt.strip(), rt !== "div" && pe !== 0 && nt.iushrn(pe), {
          div: ft || null,
          mod: nt
        };
      }, W.prototype.divmod = function(Oe, rt, pe) {
        if (K(!Oe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var nt, ot, st;
        return this.negative !== 0 && Oe.negative === 0 ? (st = this.neg().divmod(Oe, rt), rt !== "mod" && (nt = st.div.neg()), rt !== "div" && (ot = st.mod.neg(), pe && ot.negative !== 0 && ot.iadd(Oe)), {
          div: nt,
          mod: ot
        }) : this.negative === 0 && Oe.negative !== 0 ? (st = this.divmod(Oe.neg(), rt), rt !== "mod" && (nt = st.div.neg()), {
          div: nt,
          mod: st.mod
        }) : this.negative & Oe.negative ? (st = this.neg().divmod(Oe.neg(), rt), rt !== "div" && (ot = st.mod.neg(), pe && ot.negative !== 0 && ot.isub(Oe)), {
          div: st.div,
          mod: ot
        }) : Oe.length > this.length || this.cmp(Oe) < 0 ? {
          div: new W(0),
          mod: this
        } : Oe.length === 1 ? rt === "div" ? {
          div: this.divn(Oe.words[0]),
          mod: null
        } : rt === "mod" ? {
          div: null,
          mod: new W(this.modn(Oe.words[0]))
        } : {
          div: this.divn(Oe.words[0]),
          mod: new W(this.modn(Oe.words[0]))
        } : this._wordDiv(Oe, rt);
      }, W.prototype.div = function(Oe) {
        return this.divmod(Oe, "div", !1).div;
      }, W.prototype.mod = function(Oe) {
        return this.divmod(Oe, "mod", !1).mod;
      }, W.prototype.umod = function(Oe) {
        return this.divmod(Oe, "mod", !0).mod;
      }, W.prototype.divRound = function(Oe) {
        var rt = this.divmod(Oe);
        if (rt.mod.isZero()) return rt.div;
        var pe = rt.div.negative !== 0 ? rt.mod.isub(Oe) : rt.mod, nt = Oe.ushrn(1), ot = Oe.andln(1), st = pe.cmp(nt);
        return st < 0 || ot === 1 && st === 0 ? rt.div : rt.div.negative !== 0 ? rt.div.isubn(1) : rt.div.iaddn(1);
      }, W.prototype.modn = function(Oe) {
        K(Oe <= 67108863);
        for (var rt = (1 << 26) % Oe, pe = 0, nt = this.length - 1; nt >= 0; nt--)
          pe = (rt * pe + (this.words[nt] | 0)) % Oe;
        return pe;
      }, W.prototype.idivn = function(Oe) {
        K(Oe <= 67108863);
        for (var rt = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = (this.words[pe] | 0) + rt * 67108864;
          this.words[pe] = nt / Oe | 0, rt = nt % Oe;
        }
        return this.strip();
      }, W.prototype.divn = function(Oe) {
        return this.clone().idivn(Oe);
      }, W.prototype.egcd = function(Oe) {
        K(Oe.negative === 0), K(!Oe.isZero());
        var rt = this, pe = Oe.clone();
        rt.negative !== 0 ? rt = rt.umod(Oe) : rt = rt.clone();
        for (var nt = new W(1), ot = new W(0), st = new W(0), ut = new W(1), pt = 0; rt.isEven() && pe.isEven(); )
          rt.iushrn(1), pe.iushrn(1), ++pt;
        for (var ft = pe.clone(), yt = rt.clone(); !rt.isZero(); ) {
          for (var ct = 0, St = 1; !(rt.words[0] & St) && ct < 26; ++ct, St <<= 1) ;
          if (ct > 0)
            for (rt.iushrn(ct); ct-- > 0; )
              (nt.isOdd() || ot.isOdd()) && (nt.iadd(ft), ot.isub(yt)), nt.iushrn(1), ot.iushrn(1);
          for (var qt = 0, jt = 1; !(pe.words[0] & jt) && qt < 26; ++qt, jt <<= 1) ;
          if (qt > 0)
            for (pe.iushrn(qt); qt-- > 0; )
              (st.isOdd() || ut.isOdd()) && (st.iadd(ft), ut.isub(yt)), st.iushrn(1), ut.iushrn(1);
          rt.cmp(pe) >= 0 ? (rt.isub(pe), nt.isub(st), ot.isub(ut)) : (pe.isub(rt), st.isub(nt), ut.isub(ot));
        }
        return {
          a: st,
          b: ut,
          gcd: pe.iushln(pt)
        };
      }, W.prototype._invmp = function(Oe) {
        K(Oe.negative === 0), K(!Oe.isZero());
        var rt = this, pe = Oe.clone();
        rt.negative !== 0 ? rt = rt.umod(Oe) : rt = rt.clone();
        for (var nt = new W(1), ot = new W(0), st = pe.clone(); rt.cmpn(1) > 0 && pe.cmpn(1) > 0; ) {
          for (var ut = 0, pt = 1; !(rt.words[0] & pt) && ut < 26; ++ut, pt <<= 1) ;
          if (ut > 0)
            for (rt.iushrn(ut); ut-- > 0; )
              nt.isOdd() && nt.iadd(st), nt.iushrn(1);
          for (var ft = 0, yt = 1; !(pe.words[0] & yt) && ft < 26; ++ft, yt <<= 1) ;
          if (ft > 0)
            for (pe.iushrn(ft); ft-- > 0; )
              ot.isOdd() && ot.iadd(st), ot.iushrn(1);
          rt.cmp(pe) >= 0 ? (rt.isub(pe), nt.isub(ot)) : (pe.isub(rt), ot.isub(nt));
        }
        var ct;
        return rt.cmpn(1) === 0 ? ct = nt : ct = ot, ct.cmpn(0) < 0 && ct.iadd(Oe), ct;
      }, W.prototype.gcd = function(Oe) {
        if (this.isZero()) return Oe.abs();
        if (Oe.isZero()) return this.abs();
        var rt = this.clone(), pe = Oe.clone();
        rt.negative = 0, pe.negative = 0;
        for (var nt = 0; rt.isEven() && pe.isEven(); nt++)
          rt.iushrn(1), pe.iushrn(1);
        do {
          for (; rt.isEven(); )
            rt.iushrn(1);
          for (; pe.isEven(); )
            pe.iushrn(1);
          var ot = rt.cmp(pe);
          if (ot < 0) {
            var st = rt;
            rt = pe, pe = st;
          } else if (ot === 0 || pe.cmpn(1) === 0)
            break;
          rt.isub(pe);
        } while (!0);
        return pe.iushln(nt);
      }, W.prototype.invm = function(Oe) {
        return this.egcd(Oe).a.umod(Oe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(Oe) {
        return this.words[0] & Oe;
      }, W.prototype.bincn = function(Oe) {
        K(typeof Oe == "number");
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 1 << rt;
        if (this.length <= pe)
          return this._expand(pe + 1), this.words[pe] |= nt, this;
        for (var ot = nt, st = pe; ot !== 0 && st < this.length; st++) {
          var ut = this.words[st] | 0;
          ut += ot, ot = ut >>> 26, ut &= 67108863, this.words[st] = ut;
        }
        return ot !== 0 && (this.words[st] = ot, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(Oe) {
        var rt = Oe < 0;
        if (this.negative !== 0 && !rt) return -1;
        if (this.negative === 0 && rt) return 1;
        this.strip();
        var pe;
        if (this.length > 1)
          pe = 1;
        else {
          rt && (Oe = -Oe), K(Oe <= 67108863, "Number is too big");
          var nt = this.words[0] | 0;
          pe = nt === Oe ? 0 : nt < Oe ? -1 : 1;
        }
        return this.negative !== 0 ? -pe | 0 : pe;
      }, W.prototype.cmp = function(Oe) {
        if (this.negative !== 0 && Oe.negative === 0) return -1;
        if (this.negative === 0 && Oe.negative !== 0) return 1;
        var rt = this.ucmp(Oe);
        return this.negative !== 0 ? -rt | 0 : rt;
      }, W.prototype.ucmp = function(Oe) {
        if (this.length > Oe.length) return 1;
        if (this.length < Oe.length) return -1;
        for (var rt = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = this.words[pe] | 0, ot = Oe.words[pe] | 0;
          if (nt !== ot) {
            nt < ot ? rt = -1 : nt > ot && (rt = 1);
            break;
          }
        }
        return rt;
      }, W.prototype.gtn = function(Oe) {
        return this.cmpn(Oe) === 1;
      }, W.prototype.gt = function(Oe) {
        return this.cmp(Oe) === 1;
      }, W.prototype.gten = function(Oe) {
        return this.cmpn(Oe) >= 0;
      }, W.prototype.gte = function(Oe) {
        return this.cmp(Oe) >= 0;
      }, W.prototype.ltn = function(Oe) {
        return this.cmpn(Oe) === -1;
      }, W.prototype.lt = function(Oe) {
        return this.cmp(Oe) === -1;
      }, W.prototype.lten = function(Oe) {
        return this.cmpn(Oe) <= 0;
      }, W.prototype.lte = function(Oe) {
        return this.cmp(Oe) <= 0;
      }, W.prototype.eqn = function(Oe) {
        return this.cmpn(Oe) === 0;
      }, W.prototype.eq = function(Oe) {
        return this.cmp(Oe) === 0;
      }, W.red = function(Oe) {
        return new mt(Oe);
      }, W.prototype.toRed = function(Oe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), Oe.convertTo(this)._forceRed(Oe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(Oe) {
        return this.red = Oe, this;
      }, W.prototype.forceRed = function(Oe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(Oe);
      }, W.prototype.redAdd = function(Oe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, Oe);
      }, W.prototype.redIAdd = function(Oe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Oe);
      }, W.prototype.redSub = function(Oe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, Oe);
      }, W.prototype.redISub = function(Oe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, Oe);
      }, W.prototype.redShl = function(Oe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, Oe);
      }, W.prototype.redMul = function(Oe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Oe), this.red.mul(this, Oe);
      }, W.prototype.redIMul = function(Oe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Oe), this.red.imul(this, Oe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(Oe) {
        return K(this.red && !Oe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Oe);
      };
      var bt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function vt(wt, Oe) {
        this.name = wt, this.p = new W(Oe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      vt.prototype._tmp = function() {
        var Oe = new W(null);
        return Oe.words = new Array(Math.ceil(this.n / 13)), Oe;
      }, vt.prototype.ireduce = function(Oe) {
        var rt = Oe, pe;
        do
          this.split(rt, this.tmp), rt = this.imulK(rt), rt = rt.iadd(this.tmp), pe = rt.bitLength();
        while (pe > this.n);
        var nt = pe < this.n ? -1 : rt.ucmp(this.p);
        return nt === 0 ? (rt.words[0] = 0, rt.length = 1) : nt > 0 ? rt.isub(this.p) : rt.strip !== void 0 ? rt.strip() : rt._strip(), rt;
      }, vt.prototype.split = function(Oe, rt) {
        Oe.iushrn(this.n, 0, rt);
      }, vt.prototype.imulK = function(Oe) {
        return Oe.imul(this.k);
      };
      function Bt() {
        vt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      re(Bt, vt), Bt.prototype.split = function(Oe, rt) {
        for (var pe = 4194303, nt = Math.min(Oe.length, 9), ot = 0; ot < nt; ot++)
          rt.words[ot] = Oe.words[ot];
        if (rt.length = nt, Oe.length <= 9) {
          Oe.words[0] = 0, Oe.length = 1;
          return;
        }
        var st = Oe.words[9];
        for (rt.words[rt.length++] = st & pe, ot = 10; ot < Oe.length; ot++) {
          var ut = Oe.words[ot] | 0;
          Oe.words[ot - 10] = (ut & pe) << 4 | st >>> 22, st = ut;
        }
        st >>>= 22, Oe.words[ot - 10] = st, st === 0 && Oe.length > 10 ? Oe.length -= 10 : Oe.length -= 9;
      }, Bt.prototype.imulK = function(Oe) {
        Oe.words[Oe.length] = 0, Oe.words[Oe.length + 1] = 0, Oe.length += 2;
        for (var rt = 0, pe = 0; pe < Oe.length; pe++) {
          var nt = Oe.words[pe] | 0;
          rt += nt * 977, Oe.words[pe] = rt & 67108863, rt = nt * 64 + (rt / 67108864 | 0);
        }
        return Oe.words[Oe.length - 1] === 0 && (Oe.length--, Oe.words[Oe.length - 1] === 0 && Oe.length--), Oe;
      };
      function At() {
        vt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      re(At, vt);
      function Nt() {
        vt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      re(Nt, vt);
      function $t() {
        vt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      re($t, vt), $t.prototype.imulK = function(Oe) {
        for (var rt = 0, pe = 0; pe < Oe.length; pe++) {
          var nt = (Oe.words[pe] | 0) * 19 + rt, ot = nt & 67108863;
          nt >>>= 26, Oe.words[pe] = ot, rt = nt;
        }
        return rt !== 0 && (Oe.words[Oe.length++] = rt), Oe;
      }, W._prime = function(Oe) {
        if (bt[Oe]) return bt[Oe];
        var rt;
        if (Oe === "k256")
          rt = new Bt();
        else if (Oe === "p224")
          rt = new At();
        else if (Oe === "p192")
          rt = new Nt();
        else if (Oe === "p25519")
          rt = new $t();
        else
          throw new Error("Unknown prime " + Oe);
        return bt[Oe] = rt, rt;
      };
      function mt(wt) {
        if (typeof wt == "string") {
          var Oe = W._prime(wt);
          this.m = Oe.p, this.prime = Oe;
        } else
          K(wt.gtn(1), "modulus must be greater than 1"), this.m = wt, this.prime = null;
      }
      mt.prototype._verify1 = function(Oe) {
        K(Oe.negative === 0, "red works only with positives"), K(Oe.red, "red works only with red numbers");
      }, mt.prototype._verify2 = function(Oe, rt) {
        K((Oe.negative | rt.negative) === 0, "red works only with positives"), K(
          Oe.red && Oe.red === rt.red,
          "red works only with red numbers"
        );
      }, mt.prototype.imod = function(Oe) {
        return this.prime ? this.prime.ireduce(Oe)._forceRed(this) : Oe.umod(this.m)._forceRed(this);
      }, mt.prototype.neg = function(Oe) {
        return Oe.isZero() ? Oe.clone() : this.m.sub(Oe)._forceRed(this);
      }, mt.prototype.add = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.add(rt);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe._forceRed(this);
      }, mt.prototype.iadd = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.iadd(rt);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe;
      }, mt.prototype.sub = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.sub(rt);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe._forceRed(this);
      }, mt.prototype.isub = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.isub(rt);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe;
      }, mt.prototype.shl = function(Oe, rt) {
        return this._verify1(Oe), this.imod(Oe.ushln(rt));
      }, mt.prototype.imul = function(Oe, rt) {
        return this._verify2(Oe, rt), this.imod(Oe.imul(rt));
      }, mt.prototype.mul = function(Oe, rt) {
        return this._verify2(Oe, rt), this.imod(Oe.mul(rt));
      }, mt.prototype.isqr = function(Oe) {
        return this.imul(Oe, Oe.clone());
      }, mt.prototype.sqr = function(Oe) {
        return this.mul(Oe, Oe);
      }, mt.prototype.sqrt = function(Oe) {
        if (Oe.isZero()) return Oe.clone();
        var rt = this.m.andln(3);
        if (K(rt % 2 === 1), rt === 3) {
          var pe = this.m.add(new W(1)).iushrn(2);
          return this.pow(Oe, pe);
        }
        for (var nt = this.m.subn(1), ot = 0; !nt.isZero() && nt.andln(1) === 0; )
          ot++, nt.iushrn(1);
        K(!nt.isZero());
        var st = new W(1).toRed(this), ut = st.redNeg(), pt = this.m.subn(1).iushrn(1), ft = this.m.bitLength();
        for (ft = new W(2 * ft * ft).toRed(this); this.pow(ft, pt).cmp(ut) !== 0; )
          ft.redIAdd(ut);
        for (var yt = this.pow(ft, nt), ct = this.pow(Oe, nt.addn(1).iushrn(1)), St = this.pow(Oe, nt), qt = ot; St.cmp(st) !== 0; ) {
          for (var jt = St, Ot = 0; jt.cmp(st) !== 0; Ot++)
            jt = jt.redSqr();
          K(Ot < qt);
          var Tt = this.pow(yt, new W(1).iushln(qt - Ot - 1));
          ct = ct.redMul(Tt), yt = Tt.redSqr(), St = St.redMul(yt), qt = Ot;
        }
        return ct;
      }, mt.prototype.invm = function(Oe) {
        var rt = Oe._invmp(this.m);
        return rt.negative !== 0 ? (rt.negative = 0, this.imod(rt).redNeg()) : this.imod(rt);
      }, mt.prototype.pow = function(Oe, rt) {
        if (rt.isZero()) return new W(1).toRed(this);
        if (rt.cmpn(1) === 0) return Oe.clone();
        var pe = 4, nt = new Array(1 << pe);
        nt[0] = new W(1).toRed(this), nt[1] = Oe;
        for (var ot = 2; ot < nt.length; ot++)
          nt[ot] = this.mul(nt[ot - 1], Oe);
        var st = nt[0], ut = 0, pt = 0, ft = rt.bitLength() % 26;
        for (ft === 0 && (ft = 26), ot = rt.length - 1; ot >= 0; ot--) {
          for (var yt = rt.words[ot], ct = ft - 1; ct >= 0; ct--) {
            var St = yt >> ct & 1;
            if (st !== nt[0] && (st = this.sqr(st)), St === 0 && ut === 0) {
              pt = 0;
              continue;
            }
            ut <<= 1, ut |= St, pt++, !(pt !== pe && (ot !== 0 || ct !== 0)) && (st = this.mul(st, nt[ut]), pt = 0, ut = 0);
          }
          ft = 26;
        }
        return st;
      }, mt.prototype.convertTo = function(Oe) {
        var rt = Oe.umod(this.m);
        return rt === Oe ? rt.clone() : rt;
      }, mt.prototype.convertFrom = function(Oe) {
        var rt = Oe.clone();
        return rt.red = null, rt;
      }, W.mont = function(Oe) {
        return new xt(Oe);
      };
      function xt(wt) {
        mt.call(this, wt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      re(xt, mt), xt.prototype.convertTo = function(Oe) {
        return this.imod(Oe.ushln(this.shift));
      }, xt.prototype.convertFrom = function(Oe) {
        var rt = this.imod(Oe.mul(this.rinv));
        return rt.red = null, rt;
      }, xt.prototype.imul = function(Oe, rt) {
        if (Oe.isZero() || rt.isZero())
          return Oe.words[0] = 0, Oe.length = 1, Oe;
        var pe = Oe.imul(rt), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = pe.isub(nt).iushrn(this.shift), st = ot;
        return ot.cmp(this.m) >= 0 ? st = ot.isub(this.m) : ot.cmpn(0) < 0 && (st = ot.iadd(this.m)), st._forceRed(this);
      }, xt.prototype.mul = function(Oe, rt) {
        if (Oe.isZero() || rt.isZero()) return new W(0)._forceRed(this);
        var pe = Oe.mul(rt), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = pe.isub(nt).iushrn(this.shift), st = ot;
        return ot.cmp(this.m) >= 0 ? st = ot.isub(this.m) : ot.cmpn(0) < 0 && (st = ot.iadd(this.m)), st._forceRed(this);
      }, xt.prototype.invm = function(Oe) {
        var rt = this.imod(Oe._invmp(this.m).mul(this.r2));
        return rt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var A;
  brorand.exports = function(re) {
    return A || (A = new B(null)), A.generate(re);
  };
  function B(K) {
    this.rand = K;
  }
  if (brorand.exports.Rand = B, B.prototype.generate = function(re) {
    return this._rand(re);
  }, B.prototype._rand = function(re) {
    if (this.rand.getBytes)
      return this.rand.getBytes(re);
    for (var W = new Uint8Array(re), J = 0; J < W.length; J++)
      W[J] = this.rand.getByte();
    return W;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? B.prototype._rand = function(re) {
      var W = new Uint8Array(re);
      return self.crypto.getRandomValues(W), W;
    } : self.msCrypto && self.msCrypto.getRandomValues ? B.prototype._rand = function(re) {
      var W = new Uint8Array(re);
      return self.msCrypto.getRandomValues(W), W;
    } : typeof window == "object" && (B.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var L = requireCryptoBrowserify();
      if (typeof L.randomBytes != "function")
        throw new Error("Not supported");
      B.prototype._rand = function(re) {
        return L.randomBytes(re);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var A = requireBn$1(), B = requireBrorand();
  function L(K) {
    this.rand = K || new B.Rand();
  }
  return mr = L, L.create = function(re) {
    return new L(re);
  }, L.prototype._randbelow = function(re) {
    var W = re.bitLength(), J = Math.ceil(W / 8);
    do
      var ne = new A(this.rand.generate(J));
    while (ne.cmp(re) >= 0);
    return ne;
  }, L.prototype._randrange = function(re, W) {
    var J = W.sub(re);
    return re.add(this._randbelow(J));
  }, L.prototype.test = function(re, W, J) {
    var ne = re.bitLength(), ie = A.mont(re), oe = new A(1).toRed(ie);
    W || (W = Math.max(1, ne / 48 | 0));
    for (var V = re.subn(1), ce = 0; !V.testn(ce); ce++)
      ;
    for (var ke = re.shrn(ce), Ce = V.toRed(ie), it = !0; W > 0; W--) {
      var at = this._randrange(new A(2), V);
      J && J(at);
      var lt = at.toRed(ie).redPow(ke);
      if (!(lt.cmp(oe) === 0 || lt.cmp(Ce) === 0)) {
        for (var ht = 1; ht < ce; ht++) {
          if (lt = lt.redSqr(), lt.cmp(oe) === 0)
            return !1;
          if (lt.cmp(Ce) === 0)
            break;
        }
        if (ht === ce)
          return !1;
      }
    }
    return it;
  }, L.prototype.getDivisor = function(re, W) {
    var J = re.bitLength(), ne = A.mont(re), ie = new A(1).toRed(ne);
    W || (W = Math.max(1, J / 48 | 0));
    for (var oe = re.subn(1), V = 0; !oe.testn(V); V++)
      ;
    for (var ce = re.shrn(V), ke = oe.toRed(ne); W > 0; W--) {
      var Ce = this._randrange(new A(2), oe), it = re.gcd(Ce);
      if (it.cmpn(1) !== 0)
        return it;
      var at = Ce.toRed(ne).redPow(ce);
      if (!(at.cmp(ie) === 0 || at.cmp(ke) === 0)) {
        for (var lt = 1; lt < V; lt++) {
          if (at = at.redSqr(), at.cmp(ie) === 0)
            return at.fromRed().subn(1).gcd(re);
          if (at.cmp(ke) === 0)
            break;
        }
        if (lt === V)
          return at = at.redSqr(), at.fromRed().subn(1).gcd(re);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var A = requireBrowser$b();
  generatePrime = lt, lt.simpleSieve = it, lt.fermatTest = at;
  var B = requireBn$1(), L = new B(24), K = requireMr(), re = new K(), W = new B(1), J = new B(2), ne = new B(5);
  new B(16), new B(8);
  var ie = new B(10), oe = new B(3);
  new B(7);
  var V = new B(11), ce = new B(4);
  new B(12);
  var ke = null;
  function Ce() {
    if (ke !== null)
      return ke;
    var ht = 1048576, dt = [];
    dt[0] = 2;
    for (var bt = 1, vt = 3; vt < ht; vt += 2) {
      for (var Bt = Math.ceil(Math.sqrt(vt)), At = 0; At < bt && dt[At] <= Bt && vt % dt[At] !== 0; At++)
        ;
      bt !== At && dt[At] <= Bt || (dt[bt++] = vt);
    }
    return ke = dt, dt;
  }
  function it(ht) {
    for (var dt = Ce(), bt = 0; bt < dt.length; bt++)
      if (ht.modn(dt[bt]) === 0)
        return ht.cmpn(dt[bt]) === 0;
    return !0;
  }
  function at(ht) {
    var dt = B.mont(ht);
    return J.toRed(dt).redPow(ht.subn(1)).fromRed().cmpn(1) === 0;
  }
  function lt(ht, dt) {
    if (ht < 16)
      return dt === 2 || dt === 5 ? new B([140, 123]) : new B([140, 39]);
    dt = new B(dt);
    for (var bt, vt; ; ) {
      for (bt = new B(A(Math.ceil(ht / 8))); bt.bitLength() > ht; )
        bt.ishrn(1);
      if (bt.isEven() && bt.iadd(W), bt.testn(1) || bt.iadd(J), dt.cmp(J)) {
        if (!dt.cmp(ne))
          for (; bt.mod(ie).cmp(oe); )
            bt.iadd(ce);
      } else for (; bt.mod(L).cmp(V); )
        bt.iadd(ce);
      if (vt = bt.shrn(1), it(vt) && it(bt) && at(vt) && at(bt) && re.test(vt) && re.test(bt))
        return bt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var A = requireBn$1(), B = requireMr(), L = new B(), K = new A(24), re = new A(11), W = new A(10), J = new A(3), ne = new A(7), ie = requireGeneratePrime(), oe = requireBrowser$b();
  dh = it;
  function V(lt, ht) {
    return ht = ht || "utf8", Buffer$1.isBuffer(lt) || (lt = new Buffer$1(lt, ht)), this._pub = new A(lt), this;
  }
  function ce(lt, ht) {
    return ht = ht || "utf8", Buffer$1.isBuffer(lt) || (lt = new Buffer$1(lt, ht)), this._priv = new A(lt), this;
  }
  var ke = {};
  function Ce(lt, ht) {
    var dt = ht.toString("hex"), bt = [dt, lt.toString(16)].join("_");
    if (bt in ke)
      return ke[bt];
    var vt = 0;
    if (lt.isEven() || !ie.simpleSieve || !ie.fermatTest(lt) || !L.test(lt))
      return vt += 1, dt === "02" || dt === "05" ? vt += 8 : vt += 4, ke[bt] = vt, vt;
    L.test(lt.shrn(1)) || (vt += 2);
    var Bt;
    switch (dt) {
      case "02":
        lt.mod(K).cmp(re) && (vt += 8);
        break;
      case "05":
        Bt = lt.mod(W), Bt.cmp(J) && Bt.cmp(ne) && (vt += 8);
        break;
      default:
        vt += 4;
    }
    return ke[bt] = vt, vt;
  }
  function it(lt, ht, dt) {
    this.setGenerator(ht), this.__prime = new A(lt), this._prime = A.mont(this.__prime), this._primeLen = lt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, dt ? (this.setPublicKey = V, this.setPrivateKey = ce) : this._primeCode = 8;
  }
  Object.defineProperty(it.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ce(this.__prime, this.__gen)), this._primeCode;
    }
  }), it.prototype.generateKeys = function() {
    return this._priv || (this._priv = new A(oe(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, it.prototype.computeSecret = function(lt) {
    lt = new A(lt), lt = lt.toRed(this._prime);
    var ht = lt.redPow(this._priv).fromRed(), dt = new Buffer$1(ht.toArray()), bt = this.getPrime();
    if (dt.length < bt.length) {
      var vt = new Buffer$1(bt.length - dt.length);
      vt.fill(0), dt = Buffer$1.concat([vt, dt]);
    }
    return dt;
  }, it.prototype.getPublicKey = function(ht) {
    return at(this._pub, ht);
  }, it.prototype.getPrivateKey = function(ht) {
    return at(this._priv, ht);
  }, it.prototype.getPrime = function(lt) {
    return at(this.__prime, lt);
  }, it.prototype.getGenerator = function(lt) {
    return at(this._gen, lt);
  }, it.prototype.setGenerator = function(lt, ht) {
    return ht = ht || "utf8", Buffer$1.isBuffer(lt) || (lt = new Buffer$1(lt, ht)), this.__gen = lt, this._gen = new A(lt), this;
  };
  function at(lt, ht) {
    var dt = new Buffer$1(lt.toArray());
    return ht ? dt.toString(ht) : dt;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var A = requireGeneratePrime(), B = require$$1$1, L = requireDh();
  function K(J) {
    var ne = new Buffer$1(B[J].prime, "hex"), ie = new Buffer$1(B[J].gen, "hex");
    return new L(ne, ie);
  }
  var re = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function W(J, ne, ie, oe) {
    return Buffer$1.isBuffer(ne) || re[ne] === void 0 ? W(J, "binary", ne, ie) : (ne = ne || "binary", oe = oe || "binary", ie = ie || new Buffer$1([2]), Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, oe)), typeof J == "number" ? new L(A(J, ie), ie, !0) : (Buffer$1.isBuffer(J) || (J = new Buffer$1(J, ne)), new L(J, ie, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = K, browser$4.createDiffieHellman = browser$4.DiffieHellman = W, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: A } : processNextickArgs.exports = process$1;
  function A(B, L, K, re) {
    if (typeof B != "function")
      throw new TypeError('"callback" argument must be a function');
    var W = arguments.length, J, ne;
    switch (W) {
      case 0:
      case 1:
        return process$1.nextTick(B);
      case 2:
        return process$1.nextTick(function() {
          B.call(null, L);
        });
      case 3:
        return process$1.nextTick(function() {
          B.call(null, L, K);
        });
      case 4:
        return process$1.nextTick(function() {
          B.call(null, L, K, re);
        });
      default:
        for (J = new Array(W - 1), ne = 0; ne < J.length; )
          J[ne++] = arguments[ne];
        return process$1.nextTick(function() {
          B.apply(null, J);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var A = {}.toString;
  return isarray = Array.isArray || function(B) {
    return A.call(B) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(A, B) {
    var L = require$$0$1, K = L.Buffer;
    function re(J, ne) {
      for (var ie in J)
        ne[ie] = J[ie];
    }
    K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (re(L, B), B.Buffer = W);
    function W(J, ne, ie) {
      return K(J, ne, ie);
    }
    re(K, W), W.from = function(J, ne, ie) {
      if (typeof J == "number")
        throw new TypeError("Argument must not be a number");
      return K(J, ne, ie);
    }, W.alloc = function(J, ne, ie) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      var oe = K(J);
      return ne !== void 0 ? typeof ie == "string" ? oe.fill(ne, ie) : oe.fill(ne) : oe.fill(0), oe;
    }, W.allocUnsafe = function(J) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      return K(J);
    }, W.allocUnsafeSlow = function(J) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      return L.SlowBuffer(J);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function A(at) {
    return Array.isArray ? Array.isArray(at) : it(at) === "[object Array]";
  }
  util.isArray = A;
  function B(at) {
    return typeof at == "boolean";
  }
  util.isBoolean = B;
  function L(at) {
    return at === null;
  }
  util.isNull = L;
  function K(at) {
    return at == null;
  }
  util.isNullOrUndefined = K;
  function re(at) {
    return typeof at == "number";
  }
  util.isNumber = re;
  function W(at) {
    return typeof at == "string";
  }
  util.isString = W;
  function J(at) {
    return typeof at == "symbol";
  }
  util.isSymbol = J;
  function ne(at) {
    return at === void 0;
  }
  util.isUndefined = ne;
  function ie(at) {
    return it(at) === "[object RegExp]";
  }
  util.isRegExp = ie;
  function oe(at) {
    return typeof at == "object" && at !== null;
  }
  util.isObject = oe;
  function V(at) {
    return it(at) === "[object Date]";
  }
  util.isDate = V;
  function ce(at) {
    return it(at) === "[object Error]" || at instanceof Error;
  }
  util.isError = ce;
  function ke(at) {
    return typeof at == "function";
  }
  util.isFunction = ke;
  function Ce(at) {
    return at === null || typeof at == "boolean" || typeof at == "number" || typeof at == "string" || typeof at == "symbol" || // ES6 symbol
    typeof at > "u";
  }
  util.isPrimitive = Ce, util.isBuffer = require$$0$1.Buffer.isBuffer;
  function it(at) {
    return Object.prototype.toString.call(at);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(A) {
    function B(W, J) {
      if (!(W instanceof J))
        throw new TypeError("Cannot call a class as a function");
    }
    var L = requireSafeBuffer().Buffer, K = requireUtil$1();
    function re(W, J, ne) {
      W.copy(J, ne);
    }
    A.exports = function() {
      function W() {
        B(this, W), this.head = null, this.tail = null, this.length = 0;
      }
      return W.prototype.push = function(ne) {
        var ie = { data: ne, next: null };
        this.length > 0 ? this.tail.next = ie : this.head = ie, this.tail = ie, ++this.length;
      }, W.prototype.unshift = function(ne) {
        var ie = { data: ne, next: this.head };
        this.length === 0 && (this.tail = ie), this.head = ie, ++this.length;
      }, W.prototype.shift = function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }, W.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, W.prototype.join = function(ne) {
        if (this.length === 0) return "";
        for (var ie = this.head, oe = "" + ie.data; ie = ie.next; )
          oe += ne + ie.data;
        return oe;
      }, W.prototype.concat = function(ne) {
        if (this.length === 0) return L.alloc(0);
        for (var ie = L.allocUnsafe(ne >>> 0), oe = this.head, V = 0; oe; )
          re(oe.data, ie, V), V += oe.data.length, oe = oe.next;
        return ie;
      }, W;
    }(), K && K.inspect && K.inspect.custom && (A.exports.prototype[K.inspect.custom] = function() {
      var W = K.inspect({ length: this.length });
      return this.constructor.name + " " + W;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var A = requireProcessNextickArgs();
  function B(re, W) {
    var J = this, ne = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
    return ne || ie ? (W ? W(re) : re && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, A.nextTick(K, this, re)) : A.nextTick(K, this, re)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(re || null, function(oe) {
      !W && oe ? J._writableState ? J._writableState.errorEmitted || (J._writableState.errorEmitted = !0, A.nextTick(K, J, oe)) : A.nextTick(K, J, oe) : W && W(oe);
    }), this);
  }
  function L() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function K(re, W) {
    re.emit("error", W);
  }
  return destroy_1 = {
    destroy: B,
    undestroy: L
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var A = requireProcessNextickArgs();
  _stream_writable = at;
  function B(st) {
    var ut = this;
    this.next = null, this.entry = null, this.finish = function() {
      ot(ut, st);
    };
  }
  var L = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : A.nextTick, K;
  at.WritableState = Ce;
  var re = Object.create(requireUtil());
  re.inherits = requireInherits_browser();
  var W = {
    deprecate: requireBrowser$a()
  }, J = requireStreamBrowser(), ne = requireSafeBuffer().Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function oe(st) {
    return ne.from(st);
  }
  function V(st) {
    return ne.isBuffer(st) || st instanceof ie;
  }
  var ce = requireDestroy();
  re.inherits(at, J);
  function ke() {
  }
  function Ce(st, ut) {
    K = K || require_stream_duplex(), st = st || {};
    var pt = ut instanceof K;
    this.objectMode = !!st.objectMode, pt && (this.objectMode = this.objectMode || !!st.writableObjectMode);
    var ft = st.highWaterMark, yt = st.writableHighWaterMark, ct = this.objectMode ? 16 : 16 * 1024;
    ft || ft === 0 ? this.highWaterMark = ft : pt && (yt || yt === 0) ? this.highWaterMark = yt : this.highWaterMark = ct, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var St = st.decodeStrings === !1;
    this.decodeStrings = !St, this.defaultEncoding = st.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(qt) {
      Nt(ut, qt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Ce.prototype.getBuffer = function() {
    for (var ut = this.bufferedRequest, pt = []; ut; )
      pt.push(ut), ut = ut.next;
    return pt;
  }, function() {
    try {
      Object.defineProperty(Ce.prototype, "buffer", {
        get: W.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var it;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (it = Function.prototype[Symbol.hasInstance], Object.defineProperty(at, Symbol.hasInstance, {
    value: function(st) {
      return it.call(this, st) ? !0 : this !== at ? !1 : st && st._writableState instanceof Ce;
    }
  })) : it = function(st) {
    return st instanceof this;
  };
  function at(st) {
    if (K = K || require_stream_duplex(), !it.call(at, this) && !(this instanceof K))
      return new at(st);
    this._writableState = new Ce(st, this), this.writable = !0, st && (typeof st.write == "function" && (this._write = st.write), typeof st.writev == "function" && (this._writev = st.writev), typeof st.destroy == "function" && (this._destroy = st.destroy), typeof st.final == "function" && (this._final = st.final)), J.call(this);
  }
  at.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function lt(st, ut) {
    var pt = new Error("write after end");
    st.emit("error", pt), A.nextTick(ut, pt);
  }
  function ht(st, ut, pt, ft) {
    var yt = !0, ct = !1;
    return pt === null ? ct = new TypeError("May not write null values to stream") : typeof pt != "string" && pt !== void 0 && !ut.objectMode && (ct = new TypeError("Invalid non-string/buffer chunk")), ct && (st.emit("error", ct), A.nextTick(ft, ct), yt = !1), yt;
  }
  at.prototype.write = function(st, ut, pt) {
    var ft = this._writableState, yt = !1, ct = !ft.objectMode && V(st);
    return ct && !ne.isBuffer(st) && (st = oe(st)), typeof ut == "function" && (pt = ut, ut = null), ct ? ut = "buffer" : ut || (ut = ft.defaultEncoding), typeof pt != "function" && (pt = ke), ft.ended ? lt(this, pt) : (ct || ht(this, ft, st, pt)) && (ft.pendingcb++, yt = bt(this, ft, ct, st, ut, pt)), yt;
  }, at.prototype.cork = function() {
    var st = this._writableState;
    st.corked++;
  }, at.prototype.uncork = function() {
    var st = this._writableState;
    st.corked && (st.corked--, !st.writing && !st.corked && !st.bufferProcessing && st.bufferedRequest && xt(this, st));
  }, at.prototype.setDefaultEncoding = function(ut) {
    if (typeof ut == "string" && (ut = ut.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ut + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ut);
    return this._writableState.defaultEncoding = ut, this;
  };
  function dt(st, ut, pt) {
    return !st.objectMode && st.decodeStrings !== !1 && typeof ut == "string" && (ut = ne.from(ut, pt)), ut;
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function bt(st, ut, pt, ft, yt, ct) {
    if (!pt) {
      var St = dt(ut, ft, yt);
      ft !== St && (pt = !0, yt = "buffer", ft = St);
    }
    var qt = ut.objectMode ? 1 : ft.length;
    ut.length += qt;
    var jt = ut.length < ut.highWaterMark;
    if (jt || (ut.needDrain = !0), ut.writing || ut.corked) {
      var Ot = ut.lastBufferedRequest;
      ut.lastBufferedRequest = {
        chunk: ft,
        encoding: yt,
        isBuf: pt,
        callback: ct,
        next: null
      }, Ot ? Ot.next = ut.lastBufferedRequest : ut.bufferedRequest = ut.lastBufferedRequest, ut.bufferedRequestCount += 1;
    } else
      vt(st, ut, !1, qt, ft, yt, ct);
    return jt;
  }
  function vt(st, ut, pt, ft, yt, ct, St) {
    ut.writelen = ft, ut.writecb = St, ut.writing = !0, ut.sync = !0, pt ? st._writev(yt, ut.onwrite) : st._write(yt, ct, ut.onwrite), ut.sync = !1;
  }
  function Bt(st, ut, pt, ft, yt) {
    --ut.pendingcb, pt ? (A.nextTick(yt, ft), A.nextTick(pe, st, ut), st._writableState.errorEmitted = !0, st.emit("error", ft)) : (yt(ft), st._writableState.errorEmitted = !0, st.emit("error", ft), pe(st, ut));
  }
  function At(st) {
    st.writing = !1, st.writecb = null, st.length -= st.writelen, st.writelen = 0;
  }
  function Nt(st, ut) {
    var pt = st._writableState, ft = pt.sync, yt = pt.writecb;
    if (At(pt), ut) Bt(st, pt, ft, ut, yt);
    else {
      var ct = wt(pt);
      !ct && !pt.corked && !pt.bufferProcessing && pt.bufferedRequest && xt(st, pt), ft ? L($t, st, pt, ct, yt) : $t(st, pt, ct, yt);
    }
  }
  function $t(st, ut, pt, ft) {
    pt || mt(st, ut), ut.pendingcb--, ft(), pe(st, ut);
  }
  function mt(st, ut) {
    ut.length === 0 && ut.needDrain && (ut.needDrain = !1, st.emit("drain"));
  }
  function xt(st, ut) {
    ut.bufferProcessing = !0;
    var pt = ut.bufferedRequest;
    if (st._writev && pt && pt.next) {
      var ft = ut.bufferedRequestCount, yt = new Array(ft), ct = ut.corkedRequestsFree;
      ct.entry = pt;
      for (var St = 0, qt = !0; pt; )
        yt[St] = pt, pt.isBuf || (qt = !1), pt = pt.next, St += 1;
      yt.allBuffers = qt, vt(st, ut, !0, ut.length, yt, "", ct.finish), ut.pendingcb++, ut.lastBufferedRequest = null, ct.next ? (ut.corkedRequestsFree = ct.next, ct.next = null) : ut.corkedRequestsFree = new B(ut), ut.bufferedRequestCount = 0;
    } else {
      for (; pt; ) {
        var jt = pt.chunk, Ot = pt.encoding, Tt = pt.callback, Rt = ut.objectMode ? 1 : jt.length;
        if (vt(st, ut, !1, Rt, jt, Ot, Tt), pt = pt.next, ut.bufferedRequestCount--, ut.writing)
          break;
      }
      pt === null && (ut.lastBufferedRequest = null);
    }
    ut.bufferedRequest = pt, ut.bufferProcessing = !1;
  }
  at.prototype._write = function(st, ut, pt) {
    pt(new Error("_write() is not implemented"));
  }, at.prototype._writev = null, at.prototype.end = function(st, ut, pt) {
    var ft = this._writableState;
    typeof st == "function" ? (pt = st, st = null, ut = null) : typeof ut == "function" && (pt = ut, ut = null), st != null && this.write(st, ut), ft.corked && (ft.corked = 1, this.uncork()), ft.ending || nt(this, ft, pt);
  };
  function wt(st) {
    return st.ending && st.length === 0 && st.bufferedRequest === null && !st.finished && !st.writing;
  }
  function Oe(st, ut) {
    st._final(function(pt) {
      ut.pendingcb--, pt && st.emit("error", pt), ut.prefinished = !0, st.emit("prefinish"), pe(st, ut);
    });
  }
  function rt(st, ut) {
    !ut.prefinished && !ut.finalCalled && (typeof st._final == "function" ? (ut.pendingcb++, ut.finalCalled = !0, A.nextTick(Oe, st, ut)) : (ut.prefinished = !0, st.emit("prefinish")));
  }
  function pe(st, ut) {
    var pt = wt(ut);
    return pt && (rt(st, ut), ut.pendingcb === 0 && (ut.finished = !0, st.emit("finish"))), pt;
  }
  function nt(st, ut, pt) {
    ut.ending = !0, pe(st, ut), pt && (ut.finished ? A.nextTick(pt) : st.once("finish", pt)), ut.ended = !0, st.writable = !1;
  }
  function ot(st, ut, pt) {
    var ft = st.entry;
    for (st.entry = null; ft; ) {
      var yt = ft.callback;
      ut.pendingcb--, yt(pt), ft = ft.next;
    }
    ut.corkedRequestsFree.next = st;
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(st) {
      this._writableState && (this._writableState.destroyed = st);
    }
  }), at.prototype.destroy = ce.destroy, at.prototype._undestroy = ce.undestroy, at.prototype._destroy = function(st, ut) {
    this.end(), ut(st);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var A = requireProcessNextickArgs(), B = Object.keys || function(ce) {
    var ke = [];
    for (var Ce in ce)
      ke.push(Ce);
    return ke;
  };
  _stream_duplex = ie;
  var L = Object.create(requireUtil());
  L.inherits = requireInherits_browser();
  var K = require_stream_readable(), re = require_stream_writable();
  L.inherits(ie, K);
  for (var W = B(re.prototype), J = 0; J < W.length; J++) {
    var ne = W[J];
    ie.prototype[ne] || (ie.prototype[ne] = re.prototype[ne]);
  }
  function ie(ce) {
    if (!(this instanceof ie)) return new ie(ce);
    K.call(this, ce), re.call(this, ce), ce && ce.readable === !1 && (this.readable = !1), ce && ce.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, ce && ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", oe);
  }
  Object.defineProperty(ie.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function oe() {
    this.allowHalfOpen || this._writableState.ended || A.nextTick(V, this);
  }
  function V(ce) {
    ce.end();
  }
  return Object.defineProperty(ie.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ce) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ce, this._writableState.destroyed = ce);
    }
  }), ie.prototype._destroy = function(ce, ke) {
    this.push(null), this.end(), A.nextTick(ke, ce);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var A = requireProcessNextickArgs();
  _stream_readable = dt;
  var B = requireIsarray(), L;
  dt.ReadableState = ht, requireEvents().EventEmitter;
  var K = function(Tt, Rt) {
    return Tt.listeners(Rt).length;
  }, re = requireStreamBrowser(), W = requireSafeBuffer().Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ne(Tt) {
    return W.from(Tt);
  }
  function ie(Tt) {
    return W.isBuffer(Tt) || Tt instanceof J;
  }
  var oe = Object.create(requireUtil());
  oe.inherits = requireInherits_browser();
  var V = requireUtil$1(), ce = void 0;
  V && V.debuglog ? ce = V.debuglog("stream") : ce = function() {
  };
  var ke = requireBufferList(), Ce = requireDestroy(), it;
  oe.inherits(dt, re);
  var at = ["error", "close", "destroy", "pause", "resume"];
  function lt(Tt, Rt, Ut) {
    if (typeof Tt.prependListener == "function") return Tt.prependListener(Rt, Ut);
    !Tt._events || !Tt._events[Rt] ? Tt.on(Rt, Ut) : B(Tt._events[Rt]) ? Tt._events[Rt].unshift(Ut) : Tt._events[Rt] = [Ut, Tt._events[Rt]];
  }
  function ht(Tt, Rt) {
    L = L || require_stream_duplex(), Tt = Tt || {};
    var Ut = Rt instanceof L;
    this.objectMode = !!Tt.objectMode, Ut && (this.objectMode = this.objectMode || !!Tt.readableObjectMode);
    var Gt = Tt.highWaterMark, Mt = Tt.readableHighWaterMark, Pt = this.objectMode ? 16 : 16 * 1024;
    Gt || Gt === 0 ? this.highWaterMark = Gt : Ut && (Mt || Mt === 0) ? this.highWaterMark = Mt : this.highWaterMark = Pt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new ke(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Tt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Tt.encoding && (it || (it = requireString_decoder().StringDecoder), this.decoder = new it(Tt.encoding), this.encoding = Tt.encoding);
  }
  function dt(Tt) {
    if (L = L || require_stream_duplex(), !(this instanceof dt)) return new dt(Tt);
    this._readableState = new ht(Tt, this), this.readable = !0, Tt && (typeof Tt.read == "function" && (this._read = Tt.read), typeof Tt.destroy == "function" && (this._destroy = Tt.destroy)), re.call(this);
  }
  Object.defineProperty(dt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Tt) {
      this._readableState && (this._readableState.destroyed = Tt);
    }
  }), dt.prototype.destroy = Ce.destroy, dt.prototype._undestroy = Ce.undestroy, dt.prototype._destroy = function(Tt, Rt) {
    this.push(null), Rt(Tt);
  }, dt.prototype.push = function(Tt, Rt) {
    var Ut = this._readableState, Gt;
    return Ut.objectMode ? Gt = !0 : typeof Tt == "string" && (Rt = Rt || Ut.defaultEncoding, Rt !== Ut.encoding && (Tt = W.from(Tt, Rt), Rt = ""), Gt = !0), bt(this, Tt, Rt, !1, Gt);
  }, dt.prototype.unshift = function(Tt) {
    return bt(this, Tt, null, !0, !1);
  };
  function bt(Tt, Rt, Ut, Gt, Mt) {
    var Pt = Tt._readableState;
    if (Rt === null)
      Pt.reading = !1, xt(Tt, Pt);
    else {
      var Kt;
      Mt || (Kt = Bt(Pt, Rt)), Kt ? Tt.emit("error", Kt) : Pt.objectMode || Rt && Rt.length > 0 ? (typeof Rt != "string" && !Pt.objectMode && Object.getPrototypeOf(Rt) !== W.prototype && (Rt = ne(Rt)), Gt ? Pt.endEmitted ? Tt.emit("error", new Error("stream.unshift() after end event")) : vt(Tt, Pt, Rt, !0) : Pt.ended ? Tt.emit("error", new Error("stream.push() after EOF")) : (Pt.reading = !1, Pt.decoder && !Ut ? (Rt = Pt.decoder.write(Rt), Pt.objectMode || Rt.length !== 0 ? vt(Tt, Pt, Rt, !1) : rt(Tt, Pt)) : vt(Tt, Pt, Rt, !1))) : Gt || (Pt.reading = !1);
    }
    return At(Pt);
  }
  function vt(Tt, Rt, Ut, Gt) {
    Rt.flowing && Rt.length === 0 && !Rt.sync ? (Tt.emit("data", Ut), Tt.read(0)) : (Rt.length += Rt.objectMode ? 1 : Ut.length, Gt ? Rt.buffer.unshift(Ut) : Rt.buffer.push(Ut), Rt.needReadable && wt(Tt)), rt(Tt, Rt);
  }
  function Bt(Tt, Rt) {
    var Ut;
    return !ie(Rt) && typeof Rt != "string" && Rt !== void 0 && !Tt.objectMode && (Ut = new TypeError("Invalid non-string/buffer chunk")), Ut;
  }
  function At(Tt) {
    return !Tt.ended && (Tt.needReadable || Tt.length < Tt.highWaterMark || Tt.length === 0);
  }
  dt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, dt.prototype.setEncoding = function(Tt) {
    return it || (it = requireString_decoder().StringDecoder), this._readableState.decoder = new it(Tt), this._readableState.encoding = Tt, this;
  };
  var Nt = 8388608;
  function $t(Tt) {
    return Tt >= Nt ? Tt = Nt : (Tt--, Tt |= Tt >>> 1, Tt |= Tt >>> 2, Tt |= Tt >>> 4, Tt |= Tt >>> 8, Tt |= Tt >>> 16, Tt++), Tt;
  }
  function mt(Tt, Rt) {
    return Tt <= 0 || Rt.length === 0 && Rt.ended ? 0 : Rt.objectMode ? 1 : Tt !== Tt ? Rt.flowing && Rt.length ? Rt.buffer.head.data.length : Rt.length : (Tt > Rt.highWaterMark && (Rt.highWaterMark = $t(Tt)), Tt <= Rt.length ? Tt : Rt.ended ? Rt.length : (Rt.needReadable = !0, 0));
  }
  dt.prototype.read = function(Tt) {
    ce("read", Tt), Tt = parseInt(Tt, 10);
    var Rt = this._readableState, Ut = Tt;
    if (Tt !== 0 && (Rt.emittedReadable = !1), Tt === 0 && Rt.needReadable && (Rt.length >= Rt.highWaterMark || Rt.ended))
      return ce("read: emitReadable", Rt.length, Rt.ended), Rt.length === 0 && Rt.ended ? qt(this) : wt(this), null;
    if (Tt = mt(Tt, Rt), Tt === 0 && Rt.ended)
      return Rt.length === 0 && qt(this), null;
    var Gt = Rt.needReadable;
    ce("need readable", Gt), (Rt.length === 0 || Rt.length - Tt < Rt.highWaterMark) && (Gt = !0, ce("length less than watermark", Gt)), Rt.ended || Rt.reading ? (Gt = !1, ce("reading or ended", Gt)) : Gt && (ce("do read"), Rt.reading = !0, Rt.sync = !0, Rt.length === 0 && (Rt.needReadable = !0), this._read(Rt.highWaterMark), Rt.sync = !1, Rt.reading || (Tt = mt(Ut, Rt)));
    var Mt;
    return Tt > 0 ? Mt = ft(Tt, Rt) : Mt = null, Mt === null ? (Rt.needReadable = !0, Tt = 0) : Rt.length -= Tt, Rt.length === 0 && (Rt.ended || (Rt.needReadable = !0), Ut !== Tt && Rt.ended && qt(this)), Mt !== null && this.emit("data", Mt), Mt;
  };
  function xt(Tt, Rt) {
    if (!Rt.ended) {
      if (Rt.decoder) {
        var Ut = Rt.decoder.end();
        Ut && Ut.length && (Rt.buffer.push(Ut), Rt.length += Rt.objectMode ? 1 : Ut.length);
      }
      Rt.ended = !0, wt(Tt);
    }
  }
  function wt(Tt) {
    var Rt = Tt._readableState;
    Rt.needReadable = !1, Rt.emittedReadable || (ce("emitReadable", Rt.flowing), Rt.emittedReadable = !0, Rt.sync ? A.nextTick(Oe, Tt) : Oe(Tt));
  }
  function Oe(Tt) {
    ce("emit readable"), Tt.emit("readable"), pt(Tt);
  }
  function rt(Tt, Rt) {
    Rt.readingMore || (Rt.readingMore = !0, A.nextTick(pe, Tt, Rt));
  }
  function pe(Tt, Rt) {
    for (var Ut = Rt.length; !Rt.reading && !Rt.flowing && !Rt.ended && Rt.length < Rt.highWaterMark && (ce("maybeReadMore read 0"), Tt.read(0), Ut !== Rt.length); )
      Ut = Rt.length;
    Rt.readingMore = !1;
  }
  dt.prototype._read = function(Tt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, dt.prototype.pipe = function(Tt, Rt) {
    var Ut = this, Gt = this._readableState;
    switch (Gt.pipesCount) {
      case 0:
        Gt.pipes = Tt;
        break;
      case 1:
        Gt.pipes = [Gt.pipes, Tt];
        break;
      default:
        Gt.pipes.push(Tt);
        break;
    }
    Gt.pipesCount += 1, ce("pipe count=%d opts=%j", Gt.pipesCount, Rt);
    var Mt = (!Rt || Rt.end !== !1) && Tt !== process$1.stdout && Tt !== process$1.stderr, Pt = Mt ? Zt : Br;
    Gt.endEmitted ? A.nextTick(Pt) : Ut.once("end", Pt), Tt.on("unpipe", Kt);
    function Kt(dr, Er) {
      ce("onunpipe"), dr === Ut && Er && Er.hasUnpiped === !1 && (Er.hasUnpiped = !0, ur());
    }
    function Zt() {
      ce("onend"), Tt.end();
    }
    var rr = nt(Ut);
    Tt.on("drain", rr);
    var ar = !1;
    function ur() {
      ce("cleanup"), Tt.removeListener("close", lr), Tt.removeListener("finish", Ar), Tt.removeListener("drain", rr), Tt.removeListener("error", Ir), Tt.removeListener("unpipe", Kt), Ut.removeListener("end", Zt), Ut.removeListener("end", Br), Ut.removeListener("data", Yt), ar = !0, Gt.awaitDrain && (!Tt._writableState || Tt._writableState.needDrain) && rr();
    }
    var hr = !1;
    Ut.on("data", Yt);
    function Yt(dr) {
      ce("ondata"), hr = !1;
      var Er = Tt.write(dr);
      Er === !1 && !hr && ((Gt.pipesCount === 1 && Gt.pipes === Tt || Gt.pipesCount > 1 && Ot(Gt.pipes, Tt) !== -1) && !ar && (ce("false write response, pause", Gt.awaitDrain), Gt.awaitDrain++, hr = !0), Ut.pause());
    }
    function Ir(dr) {
      ce("onerror", dr), Br(), Tt.removeListener("error", Ir), K(Tt, "error") === 0 && Tt.emit("error", dr);
    }
    lt(Tt, "error", Ir);
    function lr() {
      Tt.removeListener("finish", Ar), Br();
    }
    Tt.once("close", lr);
    function Ar() {
      ce("onfinish"), Tt.removeListener("close", lr), Br();
    }
    Tt.once("finish", Ar);
    function Br() {
      ce("unpipe"), Ut.unpipe(Tt);
    }
    return Tt.emit("pipe", Ut), Gt.flowing || (ce("pipe resume"), Ut.resume()), Tt;
  };
  function nt(Tt) {
    return function() {
      var Rt = Tt._readableState;
      ce("pipeOnDrain", Rt.awaitDrain), Rt.awaitDrain && Rt.awaitDrain--, Rt.awaitDrain === 0 && K(Tt, "data") && (Rt.flowing = !0, pt(Tt));
    };
  }
  dt.prototype.unpipe = function(Tt) {
    var Rt = this._readableState, Ut = { hasUnpiped: !1 };
    if (Rt.pipesCount === 0) return this;
    if (Rt.pipesCount === 1)
      return Tt && Tt !== Rt.pipes ? this : (Tt || (Tt = Rt.pipes), Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1, Tt && Tt.emit("unpipe", this, Ut), this);
    if (!Tt) {
      var Gt = Rt.pipes, Mt = Rt.pipesCount;
      Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1;
      for (var Pt = 0; Pt < Mt; Pt++)
        Gt[Pt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Kt = Ot(Rt.pipes, Tt);
    return Kt === -1 ? this : (Rt.pipes.splice(Kt, 1), Rt.pipesCount -= 1, Rt.pipesCount === 1 && (Rt.pipes = Rt.pipes[0]), Tt.emit("unpipe", this, Ut), this);
  }, dt.prototype.on = function(Tt, Rt) {
    var Ut = re.prototype.on.call(this, Tt, Rt);
    if (Tt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Tt === "readable") {
      var Gt = this._readableState;
      !Gt.endEmitted && !Gt.readableListening && (Gt.readableListening = Gt.needReadable = !0, Gt.emittedReadable = !1, Gt.reading ? Gt.length && wt(this) : A.nextTick(ot, this));
    }
    return Ut;
  }, dt.prototype.addListener = dt.prototype.on;
  function ot(Tt) {
    ce("readable nexttick read 0"), Tt.read(0);
  }
  dt.prototype.resume = function() {
    var Tt = this._readableState;
    return Tt.flowing || (ce("resume"), Tt.flowing = !0, st(this, Tt)), this;
  };
  function st(Tt, Rt) {
    Rt.resumeScheduled || (Rt.resumeScheduled = !0, A.nextTick(ut, Tt, Rt));
  }
  function ut(Tt, Rt) {
    Rt.reading || (ce("resume read 0"), Tt.read(0)), Rt.resumeScheduled = !1, Rt.awaitDrain = 0, Tt.emit("resume"), pt(Tt), Rt.flowing && !Rt.reading && Tt.read(0);
  }
  dt.prototype.pause = function() {
    return ce("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ce("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function pt(Tt) {
    var Rt = Tt._readableState;
    for (ce("flow", Rt.flowing); Rt.flowing && Tt.read() !== null; )
      ;
  }
  dt.prototype.wrap = function(Tt) {
    var Rt = this, Ut = this._readableState, Gt = !1;
    Tt.on("end", function() {
      if (ce("wrapped end"), Ut.decoder && !Ut.ended) {
        var Kt = Ut.decoder.end();
        Kt && Kt.length && Rt.push(Kt);
      }
      Rt.push(null);
    }), Tt.on("data", function(Kt) {
      if (ce("wrapped data"), Ut.decoder && (Kt = Ut.decoder.write(Kt)), !(Ut.objectMode && Kt == null) && !(!Ut.objectMode && (!Kt || !Kt.length))) {
        var Zt = Rt.push(Kt);
        Zt || (Gt = !0, Tt.pause());
      }
    });
    for (var Mt in Tt)
      this[Mt] === void 0 && typeof Tt[Mt] == "function" && (this[Mt] = /* @__PURE__ */ function(Kt) {
        return function() {
          return Tt[Kt].apply(Tt, arguments);
        };
      }(Mt));
    for (var Pt = 0; Pt < at.length; Pt++)
      Tt.on(at[Pt], this.emit.bind(this, at[Pt]));
    return this._read = function(Kt) {
      ce("wrapped _read", Kt), Gt && (Gt = !1, Tt.resume());
    }, this;
  }, Object.defineProperty(dt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), dt._fromList = ft;
  function ft(Tt, Rt) {
    if (Rt.length === 0) return null;
    var Ut;
    return Rt.objectMode ? Ut = Rt.buffer.shift() : !Tt || Tt >= Rt.length ? (Rt.decoder ? Ut = Rt.buffer.join("") : Rt.buffer.length === 1 ? Ut = Rt.buffer.head.data : Ut = Rt.buffer.concat(Rt.length), Rt.buffer.clear()) : Ut = yt(Tt, Rt.buffer, Rt.decoder), Ut;
  }
  function yt(Tt, Rt, Ut) {
    var Gt;
    return Tt < Rt.head.data.length ? (Gt = Rt.head.data.slice(0, Tt), Rt.head.data = Rt.head.data.slice(Tt)) : Tt === Rt.head.data.length ? Gt = Rt.shift() : Gt = Ut ? ct(Tt, Rt) : St(Tt, Rt), Gt;
  }
  function ct(Tt, Rt) {
    var Ut = Rt.head, Gt = 1, Mt = Ut.data;
    for (Tt -= Mt.length; Ut = Ut.next; ) {
      var Pt = Ut.data, Kt = Tt > Pt.length ? Pt.length : Tt;
      if (Kt === Pt.length ? Mt += Pt : Mt += Pt.slice(0, Tt), Tt -= Kt, Tt === 0) {
        Kt === Pt.length ? (++Gt, Ut.next ? Rt.head = Ut.next : Rt.head = Rt.tail = null) : (Rt.head = Ut, Ut.data = Pt.slice(Kt));
        break;
      }
      ++Gt;
    }
    return Rt.length -= Gt, Mt;
  }
  function St(Tt, Rt) {
    var Ut = W.allocUnsafe(Tt), Gt = Rt.head, Mt = 1;
    for (Gt.data.copy(Ut), Tt -= Gt.data.length; Gt = Gt.next; ) {
      var Pt = Gt.data, Kt = Tt > Pt.length ? Pt.length : Tt;
      if (Pt.copy(Ut, Ut.length - Tt, 0, Kt), Tt -= Kt, Tt === 0) {
        Kt === Pt.length ? (++Mt, Gt.next ? Rt.head = Gt.next : Rt.head = Rt.tail = null) : (Rt.head = Gt, Gt.data = Pt.slice(Kt));
        break;
      }
      ++Mt;
    }
    return Rt.length -= Mt, Ut;
  }
  function qt(Tt) {
    var Rt = Tt._readableState;
    if (Rt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Rt.endEmitted || (Rt.ended = !0, A.nextTick(jt, Rt, Tt));
  }
  function jt(Tt, Rt) {
    !Tt.endEmitted && Tt.length === 0 && (Tt.endEmitted = !0, Rt.readable = !1, Rt.emit("end"));
  }
  function Ot(Tt, Rt) {
    for (var Ut = 0, Gt = Tt.length; Ut < Gt; Ut++)
      if (Tt[Ut] === Rt) return Ut;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = K;
  var A = require_stream_duplex(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(K, A);
  function L(J, ne) {
    var ie = this._transformState;
    ie.transforming = !1;
    var oe = ie.writecb;
    if (!oe)
      return this.emit("error", new Error("write callback called multiple times"));
    ie.writechunk = null, ie.writecb = null, ne != null && this.push(ne), oe(J);
    var V = this._readableState;
    V.reading = !1, (V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark);
  }
  function K(J) {
    if (!(this instanceof K)) return new K(J);
    A.call(this, J), this._transformState = {
      afterTransform: L.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, J && (typeof J.transform == "function" && (this._transform = J.transform), typeof J.flush == "function" && (this._flush = J.flush)), this.on("prefinish", re);
  }
  function re() {
    var J = this;
    typeof this._flush == "function" ? this._flush(function(ne, ie) {
      W(J, ne, ie);
    }) : W(this, null, null);
  }
  K.prototype.push = function(J, ne) {
    return this._transformState.needTransform = !1, A.prototype.push.call(this, J, ne);
  }, K.prototype._transform = function(J, ne, ie) {
    throw new Error("_transform() is not implemented");
  }, K.prototype._write = function(J, ne, ie) {
    var oe = this._transformState;
    if (oe.writecb = ie, oe.writechunk = J, oe.writeencoding = ne, !oe.transforming) {
      var V = this._readableState;
      (oe.needTransform || V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark);
    }
  }, K.prototype._read = function(J) {
    var ne = this._transformState;
    ne.writechunk !== null && ne.writecb && !ne.transforming ? (ne.transforming = !0, this._transform(ne.writechunk, ne.writeencoding, ne.afterTransform)) : ne.needTransform = !0;
  }, K.prototype._destroy = function(J, ne) {
    var ie = this;
    A.prototype._destroy.call(this, J, function(oe) {
      ne(oe), ie.emit("close");
    });
  };
  function W(J, ne, ie) {
    if (ne) return J.emit("error", ne);
    if (ie != null && J.push(ie), J._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (J._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return J.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = L;
  var A = require_stream_transform(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(L, A);
  function L(K) {
    if (!(this instanceof L)) return new L(K);
    A.call(this, K);
  }
  return L.prototype._transform = function(K, re, W) {
    W(null, K);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(A, B) {
    B = A.exports = require_stream_readable(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable(), B.Duplex = require_stream_duplex(), B.Transform = require_stream_transform(), B.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(A) {
    (function(B, L) {
      function K(rt, pe) {
        if (!rt) throw new Error(pe || "Assertion failed");
      }
      function re(rt, pe) {
        rt.super_ = pe;
        var nt = function() {
        };
        nt.prototype = pe.prototype, rt.prototype = new nt(), rt.prototype.constructor = rt;
      }
      function W(rt, pe, nt) {
        if (W.isBN(rt))
          return rt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, rt !== null && ((pe === "le" || pe === "be") && (nt = pe, pe = 10), this._init(rt || 0, pe || 10, nt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var J;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? J = window.Buffer : J = require$$0$1.Buffer;
      } catch {
      }
      W.isBN = function(pe) {
        return pe instanceof W ? !0 : pe !== null && typeof pe == "object" && pe.constructor.wordSize === W.wordSize && Array.isArray(pe.words);
      }, W.max = function(pe, nt) {
        return pe.cmp(nt) > 0 ? pe : nt;
      }, W.min = function(pe, nt) {
        return pe.cmp(nt) < 0 ? pe : nt;
      }, W.prototype._init = function(pe, nt, ot) {
        if (typeof pe == "number")
          return this._initNumber(pe, nt, ot);
        if (typeof pe == "object")
          return this._initArray(pe, nt, ot);
        nt === "hex" && (nt = 16), K(nt === (nt | 0) && nt >= 2 && nt <= 36), pe = pe.toString().replace(/\s+/g, "");
        var st = 0;
        pe[0] === "-" && (st++, this.negative = 1), st < pe.length && (nt === 16 ? this._parseHex(pe, st, ot) : (this._parseBase(pe, nt, st), ot === "le" && this._initArray(this.toArray(), nt, ot)));
      }, W.prototype._initNumber = function(pe, nt, ot) {
        pe < 0 && (this.negative = 1, pe = -pe), pe < 67108864 ? (this.words = [pe & 67108863], this.length = 1) : pe < 4503599627370496 ? (this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863
        ], this.length = 2) : (K(pe < 9007199254740992), this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863,
          1
        ], this.length = 3), ot === "le" && this._initArray(this.toArray(), nt, ot);
      }, W.prototype._initArray = function(pe, nt, ot) {
        if (K(typeof pe.length == "number"), pe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(pe.length / 3), this.words = new Array(this.length);
        for (var st = 0; st < this.length; st++)
          this.words[st] = 0;
        var ut, pt, ft = 0;
        if (ot === "be")
          for (st = pe.length - 1, ut = 0; st >= 0; st -= 3)
            pt = pe[st] | pe[st - 1] << 8 | pe[st - 2] << 16, this.words[ut] |= pt << ft & 67108863, this.words[ut + 1] = pt >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, ut++);
        else if (ot === "le")
          for (st = 0, ut = 0; st < pe.length; st += 3)
            pt = pe[st] | pe[st + 1] << 8 | pe[st + 2] << 16, this.words[ut] |= pt << ft & 67108863, this.words[ut + 1] = pt >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, ut++);
        return this._strip();
      };
      function ne(rt, pe) {
        var nt = rt.charCodeAt(pe);
        if (nt >= 48 && nt <= 57)
          return nt - 48;
        if (nt >= 65 && nt <= 70)
          return nt - 55;
        if (nt >= 97 && nt <= 102)
          return nt - 87;
        K(!1, "Invalid character in " + rt);
      }
      function ie(rt, pe, nt) {
        var ot = ne(rt, nt);
        return nt - 1 >= pe && (ot |= ne(rt, nt - 1) << 4), ot;
      }
      W.prototype._parseHex = function(pe, nt, ot) {
        this.length = Math.ceil((pe.length - nt) / 6), this.words = new Array(this.length);
        for (var st = 0; st < this.length; st++)
          this.words[st] = 0;
        var ut = 0, pt = 0, ft;
        if (ot === "be")
          for (st = pe.length - 1; st >= nt; st -= 2)
            ft = ie(pe, nt, st) << ut, this.words[pt] |= ft & 67108863, ut >= 18 ? (ut -= 18, pt += 1, this.words[pt] |= ft >>> 26) : ut += 8;
        else {
          var yt = pe.length - nt;
          for (st = yt % 2 === 0 ? nt + 1 : nt; st < pe.length; st += 2)
            ft = ie(pe, nt, st) << ut, this.words[pt] |= ft & 67108863, ut >= 18 ? (ut -= 18, pt += 1, this.words[pt] |= ft >>> 26) : ut += 8;
        }
        this._strip();
      };
      function oe(rt, pe, nt, ot) {
        for (var st = 0, ut = 0, pt = Math.min(rt.length, nt), ft = pe; ft < pt; ft++) {
          var yt = rt.charCodeAt(ft) - 48;
          st *= ot, yt >= 49 ? ut = yt - 49 + 10 : yt >= 17 ? ut = yt - 17 + 10 : ut = yt, K(yt >= 0 && ut < ot, "Invalid character"), st += ut;
        }
        return st;
      }
      W.prototype._parseBase = function(pe, nt, ot) {
        this.words = [0], this.length = 1;
        for (var st = 0, ut = 1; ut <= 67108863; ut *= nt)
          st++;
        st--, ut = ut / nt | 0;
        for (var pt = pe.length - ot, ft = pt % st, yt = Math.min(pt, pt - ft) + ot, ct = 0, St = ot; St < yt; St += st)
          ct = oe(pe, St, St + st, nt), this.imuln(ut), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
        if (ft !== 0) {
          var qt = 1;
          for (ct = oe(pe, St, pe.length, nt), St = 0; St < ft; St++)
            qt *= nt;
          this.imuln(qt), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
        }
        this._strip();
      }, W.prototype.copy = function(pe) {
        pe.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          pe.words[nt] = this.words[nt];
        pe.length = this.length, pe.negative = this.negative, pe.red = this.red;
      };
      function V(rt, pe) {
        rt.words = pe.words, rt.length = pe.length, rt.negative = pe.negative, rt.red = pe.red;
      }
      if (W.prototype._move = function(pe) {
        V(pe, this);
      }, W.prototype.clone = function() {
        var pe = new W(null);
        return this.copy(pe), pe;
      }, W.prototype._expand = function(pe) {
        for (; this.length < pe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          W.prototype[Symbol.for("nodejs.util.inspect.custom")] = ce;
        } catch {
          W.prototype.inspect = ce;
        }
      else
        W.prototype.inspect = ce;
      function ce() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var ke = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ce = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], it = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(pe, nt) {
        pe = pe || 10, nt = nt | 0 || 1;
        var ot;
        if (pe === 16 || pe === "hex") {
          ot = "";
          for (var st = 0, ut = 0, pt = 0; pt < this.length; pt++) {
            var ft = this.words[pt], yt = ((ft << st | ut) & 16777215).toString(16);
            ut = ft >>> 24 - st & 16777215, st += 2, st >= 26 && (st -= 26, pt--), ut !== 0 || pt !== this.length - 1 ? ot = ke[6 - yt.length] + yt + ot : ot = yt + ot;
          }
          for (ut !== 0 && (ot = ut.toString(16) + ot); ot.length % nt !== 0; )
            ot = "0" + ot;
          return this.negative !== 0 && (ot = "-" + ot), ot;
        }
        if (pe === (pe | 0) && pe >= 2 && pe <= 36) {
          var ct = Ce[pe], St = it[pe];
          ot = "";
          var qt = this.clone();
          for (qt.negative = 0; !qt.isZero(); ) {
            var jt = qt.modrn(St).toString(pe);
            qt = qt.idivn(St), qt.isZero() ? ot = jt + ot : ot = ke[ct - jt.length] + jt + ot;
          }
          for (this.isZero() && (ot = "0" + ot); ot.length % nt !== 0; )
            ot = "0" + ot;
          return this.negative !== 0 && (ot = "-" + ot), ot;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var pe = this.words[0];
        return this.length === 2 ? pe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? pe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -pe : pe;
      }, W.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, J && (W.prototype.toBuffer = function(pe, nt) {
        return this.toArrayLike(J, pe, nt);
      }), W.prototype.toArray = function(pe, nt) {
        return this.toArrayLike(Array, pe, nt);
      };
      var at = function(pe, nt) {
        return pe.allocUnsafe ? pe.allocUnsafe(nt) : new pe(nt);
      };
      W.prototype.toArrayLike = function(pe, nt, ot) {
        this._strip();
        var st = this.byteLength(), ut = ot || Math.max(1, st);
        K(st <= ut, "byte array longer than desired length"), K(ut > 0, "Requested array length <= 0");
        var pt = at(pe, ut), ft = nt === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ft](pt, st), pt;
      }, W.prototype._toArrayLikeLE = function(pe, nt) {
        for (var ot = 0, st = 0, ut = 0, pt = 0; ut < this.length; ut++) {
          var ft = this.words[ut] << pt | st;
          pe[ot++] = ft & 255, ot < pe.length && (pe[ot++] = ft >> 8 & 255), ot < pe.length && (pe[ot++] = ft >> 16 & 255), pt === 6 ? (ot < pe.length && (pe[ot++] = ft >> 24 & 255), st = 0, pt = 0) : (st = ft >>> 24, pt += 2);
        }
        if (ot < pe.length)
          for (pe[ot++] = st; ot < pe.length; )
            pe[ot++] = 0;
      }, W.prototype._toArrayLikeBE = function(pe, nt) {
        for (var ot = pe.length - 1, st = 0, ut = 0, pt = 0; ut < this.length; ut++) {
          var ft = this.words[ut] << pt | st;
          pe[ot--] = ft & 255, ot >= 0 && (pe[ot--] = ft >> 8 & 255), ot >= 0 && (pe[ot--] = ft >> 16 & 255), pt === 6 ? (ot >= 0 && (pe[ot--] = ft >> 24 & 255), st = 0, pt = 0) : (st = ft >>> 24, pt += 2);
        }
        if (ot >= 0)
          for (pe[ot--] = st; ot >= 0; )
            pe[ot--] = 0;
      }, Math.clz32 ? W.prototype._countBits = function(pe) {
        return 32 - Math.clz32(pe);
      } : W.prototype._countBits = function(pe) {
        var nt = pe, ot = 0;
        return nt >= 4096 && (ot += 13, nt >>>= 13), nt >= 64 && (ot += 7, nt >>>= 7), nt >= 8 && (ot += 4, nt >>>= 4), nt >= 2 && (ot += 2, nt >>>= 2), ot + nt;
      }, W.prototype._zeroBits = function(pe) {
        if (pe === 0) return 26;
        var nt = pe, ot = 0;
        return nt & 8191 || (ot += 13, nt >>>= 13), nt & 127 || (ot += 7, nt >>>= 7), nt & 15 || (ot += 4, nt >>>= 4), nt & 3 || (ot += 2, nt >>>= 2), nt & 1 || ot++, ot;
      }, W.prototype.bitLength = function() {
        var pe = this.words[this.length - 1], nt = this._countBits(pe);
        return (this.length - 1) * 26 + nt;
      };
      function lt(rt) {
        for (var pe = new Array(rt.bitLength()), nt = 0; nt < pe.length; nt++) {
          var ot = nt / 26 | 0, st = nt % 26;
          pe[nt] = rt.words[ot] >>> st & 1;
        }
        return pe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var pe = 0, nt = 0; nt < this.length; nt++) {
          var ot = this._zeroBits(this.words[nt]);
          if (pe += ot, ot !== 26) break;
        }
        return pe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(pe) {
        return this.negative !== 0 ? this.abs().inotn(pe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(pe) {
        return this.testn(pe - 1) ? this.notn(pe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(pe) {
        for (; this.length < pe.length; )
          this.words[this.length++] = 0;
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = this.words[nt] | pe.words[nt];
        return this._strip();
      }, W.prototype.ior = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuor(pe);
      }, W.prototype.or = function(pe) {
        return this.length > pe.length ? this.clone().ior(pe) : pe.clone().ior(this);
      }, W.prototype.uor = function(pe) {
        return this.length > pe.length ? this.clone().iuor(pe) : pe.clone().iuor(this);
      }, W.prototype.iuand = function(pe) {
        var nt;
        this.length > pe.length ? nt = pe : nt = this;
        for (var ot = 0; ot < nt.length; ot++)
          this.words[ot] = this.words[ot] & pe.words[ot];
        return this.length = nt.length, this._strip();
      }, W.prototype.iand = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuand(pe);
      }, W.prototype.and = function(pe) {
        return this.length > pe.length ? this.clone().iand(pe) : pe.clone().iand(this);
      }, W.prototype.uand = function(pe) {
        return this.length > pe.length ? this.clone().iuand(pe) : pe.clone().iuand(this);
      }, W.prototype.iuxor = function(pe) {
        var nt, ot;
        this.length > pe.length ? (nt = this, ot = pe) : (nt = pe, ot = this);
        for (var st = 0; st < ot.length; st++)
          this.words[st] = nt.words[st] ^ ot.words[st];
        if (this !== nt)
          for (; st < nt.length; st++)
            this.words[st] = nt.words[st];
        return this.length = nt.length, this._strip();
      }, W.prototype.ixor = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuxor(pe);
      }, W.prototype.xor = function(pe) {
        return this.length > pe.length ? this.clone().ixor(pe) : pe.clone().ixor(this);
      }, W.prototype.uxor = function(pe) {
        return this.length > pe.length ? this.clone().iuxor(pe) : pe.clone().iuxor(this);
      }, W.prototype.inotn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = Math.ceil(pe / 26) | 0, ot = pe % 26;
        this._expand(nt), ot > 0 && nt--;
        for (var st = 0; st < nt; st++)
          this.words[st] = ~this.words[st] & 67108863;
        return ot > 0 && (this.words[st] = ~this.words[st] & 67108863 >> 26 - ot), this._strip();
      }, W.prototype.notn = function(pe) {
        return this.clone().inotn(pe);
      }, W.prototype.setn = function(pe, nt) {
        K(typeof pe == "number" && pe >= 0);
        var ot = pe / 26 | 0, st = pe % 26;
        return this._expand(ot + 1), nt ? this.words[ot] = this.words[ot] | 1 << st : this.words[ot] = this.words[ot] & ~(1 << st), this._strip();
      }, W.prototype.iadd = function(pe) {
        var nt;
        if (this.negative !== 0 && pe.negative === 0)
          return this.negative = 0, nt = this.isub(pe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && pe.negative !== 0)
          return pe.negative = 0, nt = this.isub(pe), pe.negative = 1, nt._normSign();
        var ot, st;
        this.length > pe.length ? (ot = this, st = pe) : (ot = pe, st = this);
        for (var ut = 0, pt = 0; pt < st.length; pt++)
          nt = (ot.words[pt] | 0) + (st.words[pt] | 0) + ut, this.words[pt] = nt & 67108863, ut = nt >>> 26;
        for (; ut !== 0 && pt < ot.length; pt++)
          nt = (ot.words[pt] | 0) + ut, this.words[pt] = nt & 67108863, ut = nt >>> 26;
        if (this.length = ot.length, ut !== 0)
          this.words[this.length] = ut, this.length++;
        else if (ot !== this)
          for (; pt < ot.length; pt++)
            this.words[pt] = ot.words[pt];
        return this;
      }, W.prototype.add = function(pe) {
        var nt;
        return pe.negative !== 0 && this.negative === 0 ? (pe.negative = 0, nt = this.sub(pe), pe.negative ^= 1, nt) : pe.negative === 0 && this.negative !== 0 ? (this.negative = 0, nt = pe.sub(this), this.negative = 1, nt) : this.length > pe.length ? this.clone().iadd(pe) : pe.clone().iadd(this);
      }, W.prototype.isub = function(pe) {
        if (pe.negative !== 0) {
          pe.negative = 0;
          var nt = this.iadd(pe);
          return pe.negative = 1, nt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(pe), this.negative = 1, this._normSign();
        var ot = this.cmp(pe);
        if (ot === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var st, ut;
        ot > 0 ? (st = this, ut = pe) : (st = pe, ut = this);
        for (var pt = 0, ft = 0; ft < ut.length; ft++)
          nt = (st.words[ft] | 0) - (ut.words[ft] | 0) + pt, pt = nt >> 26, this.words[ft] = nt & 67108863;
        for (; pt !== 0 && ft < st.length; ft++)
          nt = (st.words[ft] | 0) + pt, pt = nt >> 26, this.words[ft] = nt & 67108863;
        if (pt === 0 && ft < st.length && st !== this)
          for (; ft < st.length; ft++)
            this.words[ft] = st.words[ft];
        return this.length = Math.max(this.length, ft), st !== this && (this.negative = 1), this._strip();
      }, W.prototype.sub = function(pe) {
        return this.clone().isub(pe);
      };
      function ht(rt, pe, nt) {
        nt.negative = pe.negative ^ rt.negative;
        var ot = rt.length + pe.length | 0;
        nt.length = ot, ot = ot - 1 | 0;
        var st = rt.words[0] | 0, ut = pe.words[0] | 0, pt = st * ut, ft = pt & 67108863, yt = pt / 67108864 | 0;
        nt.words[0] = ft;
        for (var ct = 1; ct < ot; ct++) {
          for (var St = yt >>> 26, qt = yt & 67108863, jt = Math.min(ct, pe.length - 1), Ot = Math.max(0, ct - rt.length + 1); Ot <= jt; Ot++) {
            var Tt = ct - Ot | 0;
            st = rt.words[Tt] | 0, ut = pe.words[Ot] | 0, pt = st * ut + qt, St += pt / 67108864 | 0, qt = pt & 67108863;
          }
          nt.words[ct] = qt | 0, yt = St | 0;
        }
        return yt !== 0 ? nt.words[ct] = yt | 0 : nt.length--, nt._strip();
      }
      var dt = function(pe, nt, ot) {
        var st = pe.words, ut = nt.words, pt = ot.words, ft = 0, yt, ct, St, qt = st[0] | 0, jt = qt & 8191, Ot = qt >>> 13, Tt = st[1] | 0, Rt = Tt & 8191, Ut = Tt >>> 13, Gt = st[2] | 0, Mt = Gt & 8191, Pt = Gt >>> 13, Kt = st[3] | 0, Zt = Kt & 8191, rr = Kt >>> 13, ar = st[4] | 0, ur = ar & 8191, hr = ar >>> 13, Yt = st[5] | 0, Ir = Yt & 8191, lr = Yt >>> 13, Ar = st[6] | 0, Br = Ar & 8191, dr = Ar >>> 13, Er = st[7] | 0, Pr = Er & 8191, br = Er >>> 13, Mr = st[8] | 0, Or = Mr & 8191, It = Mr >>> 13, gt = st[9] | 0, Et = gt & 8191, Ct = gt >>> 13, Wt = ut[0] | 0, zt = Wt & 8191, Vt = Wt >>> 13, yr = ut[1] | 0, $r = yr & 8191, cr = yr >>> 13, xr = ut[2] | 0, gr = xr & 8191, _r = xr >>> 13, kr = ut[3] | 0, Cr = kr & 8191, Ft = kr >>> 13, kt = ut[4] | 0, Dt = kt & 8191, Ht = kt >>> 13, Xt = ut[5] | 0, Qt = Xt & 8191, tr = Xt >>> 13, nr = ut[6] | 0, fr = nr & 8191, ir = nr >>> 13, pr = ut[7] | 0, wr = pr & 8191, sr = pr >>> 13, Lt = ut[8] | 0, Jt = Lt & 8191, er = Lt >>> 13, or = ut[9] | 0, vr = or & 8191, Sr = or >>> 13;
        ot.negative = pe.negative ^ nt.negative, ot.length = 19, yt = Math.imul(jt, zt), ct = Math.imul(jt, Vt), ct = ct + Math.imul(Ot, zt) | 0, St = Math.imul(Ot, Vt);
        var Rr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, yt = Math.imul(Rt, zt), ct = Math.imul(Rt, Vt), ct = ct + Math.imul(Ut, zt) | 0, St = Math.imul(Ut, Vt), yt = yt + Math.imul(jt, $r) | 0, ct = ct + Math.imul(jt, cr) | 0, ct = ct + Math.imul(Ot, $r) | 0, St = St + Math.imul(Ot, cr) | 0;
        var Tr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, yt = Math.imul(Mt, zt), ct = Math.imul(Mt, Vt), ct = ct + Math.imul(Pt, zt) | 0, St = Math.imul(Pt, Vt), yt = yt + Math.imul(Rt, $r) | 0, ct = ct + Math.imul(Rt, cr) | 0, ct = ct + Math.imul(Ut, $r) | 0, St = St + Math.imul(Ut, cr) | 0, yt = yt + Math.imul(jt, gr) | 0, ct = ct + Math.imul(jt, _r) | 0, ct = ct + Math.imul(Ot, gr) | 0, St = St + Math.imul(Ot, _r) | 0;
        var Nr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, yt = Math.imul(Zt, zt), ct = Math.imul(Zt, Vt), ct = ct + Math.imul(rr, zt) | 0, St = Math.imul(rr, Vt), yt = yt + Math.imul(Mt, $r) | 0, ct = ct + Math.imul(Mt, cr) | 0, ct = ct + Math.imul(Pt, $r) | 0, St = St + Math.imul(Pt, cr) | 0, yt = yt + Math.imul(Rt, gr) | 0, ct = ct + Math.imul(Rt, _r) | 0, ct = ct + Math.imul(Ut, gr) | 0, St = St + Math.imul(Ut, _r) | 0, yt = yt + Math.imul(jt, Cr) | 0, ct = ct + Math.imul(jt, Ft) | 0, ct = ct + Math.imul(Ot, Cr) | 0, St = St + Math.imul(Ot, Ft) | 0;
        var qr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, yt = Math.imul(ur, zt), ct = Math.imul(ur, Vt), ct = ct + Math.imul(hr, zt) | 0, St = Math.imul(hr, Vt), yt = yt + Math.imul(Zt, $r) | 0, ct = ct + Math.imul(Zt, cr) | 0, ct = ct + Math.imul(rr, $r) | 0, St = St + Math.imul(rr, cr) | 0, yt = yt + Math.imul(Mt, gr) | 0, ct = ct + Math.imul(Mt, _r) | 0, ct = ct + Math.imul(Pt, gr) | 0, St = St + Math.imul(Pt, _r) | 0, yt = yt + Math.imul(Rt, Cr) | 0, ct = ct + Math.imul(Rt, Ft) | 0, ct = ct + Math.imul(Ut, Cr) | 0, St = St + Math.imul(Ut, Ft) | 0, yt = yt + Math.imul(jt, Dt) | 0, ct = ct + Math.imul(jt, Ht) | 0, ct = ct + Math.imul(Ot, Dt) | 0, St = St + Math.imul(Ot, Ht) | 0;
        var Fr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, yt = Math.imul(Ir, zt), ct = Math.imul(Ir, Vt), ct = ct + Math.imul(lr, zt) | 0, St = Math.imul(lr, Vt), yt = yt + Math.imul(ur, $r) | 0, ct = ct + Math.imul(ur, cr) | 0, ct = ct + Math.imul(hr, $r) | 0, St = St + Math.imul(hr, cr) | 0, yt = yt + Math.imul(Zt, gr) | 0, ct = ct + Math.imul(Zt, _r) | 0, ct = ct + Math.imul(rr, gr) | 0, St = St + Math.imul(rr, _r) | 0, yt = yt + Math.imul(Mt, Cr) | 0, ct = ct + Math.imul(Mt, Ft) | 0, ct = ct + Math.imul(Pt, Cr) | 0, St = St + Math.imul(Pt, Ft) | 0, yt = yt + Math.imul(Rt, Dt) | 0, ct = ct + Math.imul(Rt, Ht) | 0, ct = ct + Math.imul(Ut, Dt) | 0, St = St + Math.imul(Ut, Ht) | 0, yt = yt + Math.imul(jt, Qt) | 0, ct = ct + Math.imul(jt, tr) | 0, ct = ct + Math.imul(Ot, Qt) | 0, St = St + Math.imul(Ot, tr) | 0;
        var Ur = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, yt = Math.imul(Br, zt), ct = Math.imul(Br, Vt), ct = ct + Math.imul(dr, zt) | 0, St = Math.imul(dr, Vt), yt = yt + Math.imul(Ir, $r) | 0, ct = ct + Math.imul(Ir, cr) | 0, ct = ct + Math.imul(lr, $r) | 0, St = St + Math.imul(lr, cr) | 0, yt = yt + Math.imul(ur, gr) | 0, ct = ct + Math.imul(ur, _r) | 0, ct = ct + Math.imul(hr, gr) | 0, St = St + Math.imul(hr, _r) | 0, yt = yt + Math.imul(Zt, Cr) | 0, ct = ct + Math.imul(Zt, Ft) | 0, ct = ct + Math.imul(rr, Cr) | 0, St = St + Math.imul(rr, Ft) | 0, yt = yt + Math.imul(Mt, Dt) | 0, ct = ct + Math.imul(Mt, Ht) | 0, ct = ct + Math.imul(Pt, Dt) | 0, St = St + Math.imul(Pt, Ht) | 0, yt = yt + Math.imul(Rt, Qt) | 0, ct = ct + Math.imul(Rt, tr) | 0, ct = ct + Math.imul(Ut, Qt) | 0, St = St + Math.imul(Ut, tr) | 0, yt = yt + Math.imul(jt, fr) | 0, ct = ct + Math.imul(jt, ir) | 0, ct = ct + Math.imul(Ot, fr) | 0, St = St + Math.imul(Ot, ir) | 0;
        var jr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, yt = Math.imul(Pr, zt), ct = Math.imul(Pr, Vt), ct = ct + Math.imul(br, zt) | 0, St = Math.imul(br, Vt), yt = yt + Math.imul(Br, $r) | 0, ct = ct + Math.imul(Br, cr) | 0, ct = ct + Math.imul(dr, $r) | 0, St = St + Math.imul(dr, cr) | 0, yt = yt + Math.imul(Ir, gr) | 0, ct = ct + Math.imul(Ir, _r) | 0, ct = ct + Math.imul(lr, gr) | 0, St = St + Math.imul(lr, _r) | 0, yt = yt + Math.imul(ur, Cr) | 0, ct = ct + Math.imul(ur, Ft) | 0, ct = ct + Math.imul(hr, Cr) | 0, St = St + Math.imul(hr, Ft) | 0, yt = yt + Math.imul(Zt, Dt) | 0, ct = ct + Math.imul(Zt, Ht) | 0, ct = ct + Math.imul(rr, Dt) | 0, St = St + Math.imul(rr, Ht) | 0, yt = yt + Math.imul(Mt, Qt) | 0, ct = ct + Math.imul(Mt, tr) | 0, ct = ct + Math.imul(Pt, Qt) | 0, St = St + Math.imul(Pt, tr) | 0, yt = yt + Math.imul(Rt, fr) | 0, ct = ct + Math.imul(Rt, ir) | 0, ct = ct + Math.imul(Ut, fr) | 0, St = St + Math.imul(Ut, ir) | 0, yt = yt + Math.imul(jt, wr) | 0, ct = ct + Math.imul(jt, sr) | 0, ct = ct + Math.imul(Ot, wr) | 0, St = St + Math.imul(Ot, sr) | 0;
        var Dr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, yt = Math.imul(Or, zt), ct = Math.imul(Or, Vt), ct = ct + Math.imul(It, zt) | 0, St = Math.imul(It, Vt), yt = yt + Math.imul(Pr, $r) | 0, ct = ct + Math.imul(Pr, cr) | 0, ct = ct + Math.imul(br, $r) | 0, St = St + Math.imul(br, cr) | 0, yt = yt + Math.imul(Br, gr) | 0, ct = ct + Math.imul(Br, _r) | 0, ct = ct + Math.imul(dr, gr) | 0, St = St + Math.imul(dr, _r) | 0, yt = yt + Math.imul(Ir, Cr) | 0, ct = ct + Math.imul(Ir, Ft) | 0, ct = ct + Math.imul(lr, Cr) | 0, St = St + Math.imul(lr, Ft) | 0, yt = yt + Math.imul(ur, Dt) | 0, ct = ct + Math.imul(ur, Ht) | 0, ct = ct + Math.imul(hr, Dt) | 0, St = St + Math.imul(hr, Ht) | 0, yt = yt + Math.imul(Zt, Qt) | 0, ct = ct + Math.imul(Zt, tr) | 0, ct = ct + Math.imul(rr, Qt) | 0, St = St + Math.imul(rr, tr) | 0, yt = yt + Math.imul(Mt, fr) | 0, ct = ct + Math.imul(Mt, ir) | 0, ct = ct + Math.imul(Pt, fr) | 0, St = St + Math.imul(Pt, ir) | 0, yt = yt + Math.imul(Rt, wr) | 0, ct = ct + Math.imul(Rt, sr) | 0, ct = ct + Math.imul(Ut, wr) | 0, St = St + Math.imul(Ut, sr) | 0, yt = yt + Math.imul(jt, Jt) | 0, ct = ct + Math.imul(jt, er) | 0, ct = ct + Math.imul(Ot, Jt) | 0, St = St + Math.imul(Ot, er) | 0;
        var Lr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, yt = Math.imul(Et, zt), ct = Math.imul(Et, Vt), ct = ct + Math.imul(Ct, zt) | 0, St = Math.imul(Ct, Vt), yt = yt + Math.imul(Or, $r) | 0, ct = ct + Math.imul(Or, cr) | 0, ct = ct + Math.imul(It, $r) | 0, St = St + Math.imul(It, cr) | 0, yt = yt + Math.imul(Pr, gr) | 0, ct = ct + Math.imul(Pr, _r) | 0, ct = ct + Math.imul(br, gr) | 0, St = St + Math.imul(br, _r) | 0, yt = yt + Math.imul(Br, Cr) | 0, ct = ct + Math.imul(Br, Ft) | 0, ct = ct + Math.imul(dr, Cr) | 0, St = St + Math.imul(dr, Ft) | 0, yt = yt + Math.imul(Ir, Dt) | 0, ct = ct + Math.imul(Ir, Ht) | 0, ct = ct + Math.imul(lr, Dt) | 0, St = St + Math.imul(lr, Ht) | 0, yt = yt + Math.imul(ur, Qt) | 0, ct = ct + Math.imul(ur, tr) | 0, ct = ct + Math.imul(hr, Qt) | 0, St = St + Math.imul(hr, tr) | 0, yt = yt + Math.imul(Zt, fr) | 0, ct = ct + Math.imul(Zt, ir) | 0, ct = ct + Math.imul(rr, fr) | 0, St = St + Math.imul(rr, ir) | 0, yt = yt + Math.imul(Mt, wr) | 0, ct = ct + Math.imul(Mt, sr) | 0, ct = ct + Math.imul(Pt, wr) | 0, St = St + Math.imul(Pt, sr) | 0, yt = yt + Math.imul(Rt, Jt) | 0, ct = ct + Math.imul(Rt, er) | 0, ct = ct + Math.imul(Ut, Jt) | 0, St = St + Math.imul(Ut, er) | 0, yt = yt + Math.imul(jt, vr) | 0, ct = ct + Math.imul(jt, Sr) | 0, ct = ct + Math.imul(Ot, vr) | 0, St = St + Math.imul(Ot, Sr) | 0;
        var Hr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, yt = Math.imul(Et, $r), ct = Math.imul(Et, cr), ct = ct + Math.imul(Ct, $r) | 0, St = Math.imul(Ct, cr), yt = yt + Math.imul(Or, gr) | 0, ct = ct + Math.imul(Or, _r) | 0, ct = ct + Math.imul(It, gr) | 0, St = St + Math.imul(It, _r) | 0, yt = yt + Math.imul(Pr, Cr) | 0, ct = ct + Math.imul(Pr, Ft) | 0, ct = ct + Math.imul(br, Cr) | 0, St = St + Math.imul(br, Ft) | 0, yt = yt + Math.imul(Br, Dt) | 0, ct = ct + Math.imul(Br, Ht) | 0, ct = ct + Math.imul(dr, Dt) | 0, St = St + Math.imul(dr, Ht) | 0, yt = yt + Math.imul(Ir, Qt) | 0, ct = ct + Math.imul(Ir, tr) | 0, ct = ct + Math.imul(lr, Qt) | 0, St = St + Math.imul(lr, tr) | 0, yt = yt + Math.imul(ur, fr) | 0, ct = ct + Math.imul(ur, ir) | 0, ct = ct + Math.imul(hr, fr) | 0, St = St + Math.imul(hr, ir) | 0, yt = yt + Math.imul(Zt, wr) | 0, ct = ct + Math.imul(Zt, sr) | 0, ct = ct + Math.imul(rr, wr) | 0, St = St + Math.imul(rr, sr) | 0, yt = yt + Math.imul(Mt, Jt) | 0, ct = ct + Math.imul(Mt, er) | 0, ct = ct + Math.imul(Pt, Jt) | 0, St = St + Math.imul(Pt, er) | 0, yt = yt + Math.imul(Rt, vr) | 0, ct = ct + Math.imul(Rt, Sr) | 0, ct = ct + Math.imul(Ut, vr) | 0, St = St + Math.imul(Ut, Sr) | 0;
        var Wr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, yt = Math.imul(Et, gr), ct = Math.imul(Et, _r), ct = ct + Math.imul(Ct, gr) | 0, St = Math.imul(Ct, _r), yt = yt + Math.imul(Or, Cr) | 0, ct = ct + Math.imul(Or, Ft) | 0, ct = ct + Math.imul(It, Cr) | 0, St = St + Math.imul(It, Ft) | 0, yt = yt + Math.imul(Pr, Dt) | 0, ct = ct + Math.imul(Pr, Ht) | 0, ct = ct + Math.imul(br, Dt) | 0, St = St + Math.imul(br, Ht) | 0, yt = yt + Math.imul(Br, Qt) | 0, ct = ct + Math.imul(Br, tr) | 0, ct = ct + Math.imul(dr, Qt) | 0, St = St + Math.imul(dr, tr) | 0, yt = yt + Math.imul(Ir, fr) | 0, ct = ct + Math.imul(Ir, ir) | 0, ct = ct + Math.imul(lr, fr) | 0, St = St + Math.imul(lr, ir) | 0, yt = yt + Math.imul(ur, wr) | 0, ct = ct + Math.imul(ur, sr) | 0, ct = ct + Math.imul(hr, wr) | 0, St = St + Math.imul(hr, sr) | 0, yt = yt + Math.imul(Zt, Jt) | 0, ct = ct + Math.imul(Zt, er) | 0, ct = ct + Math.imul(rr, Jt) | 0, St = St + Math.imul(rr, er) | 0, yt = yt + Math.imul(Mt, vr) | 0, ct = ct + Math.imul(Mt, Sr) | 0, ct = ct + Math.imul(Pt, vr) | 0, St = St + Math.imul(Pt, Sr) | 0;
        var Gr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, yt = Math.imul(Et, Cr), ct = Math.imul(Et, Ft), ct = ct + Math.imul(Ct, Cr) | 0, St = Math.imul(Ct, Ft), yt = yt + Math.imul(Or, Dt) | 0, ct = ct + Math.imul(Or, Ht) | 0, ct = ct + Math.imul(It, Dt) | 0, St = St + Math.imul(It, Ht) | 0, yt = yt + Math.imul(Pr, Qt) | 0, ct = ct + Math.imul(Pr, tr) | 0, ct = ct + Math.imul(br, Qt) | 0, St = St + Math.imul(br, tr) | 0, yt = yt + Math.imul(Br, fr) | 0, ct = ct + Math.imul(Br, ir) | 0, ct = ct + Math.imul(dr, fr) | 0, St = St + Math.imul(dr, ir) | 0, yt = yt + Math.imul(Ir, wr) | 0, ct = ct + Math.imul(Ir, sr) | 0, ct = ct + Math.imul(lr, wr) | 0, St = St + Math.imul(lr, sr) | 0, yt = yt + Math.imul(ur, Jt) | 0, ct = ct + Math.imul(ur, er) | 0, ct = ct + Math.imul(hr, Jt) | 0, St = St + Math.imul(hr, er) | 0, yt = yt + Math.imul(Zt, vr) | 0, ct = ct + Math.imul(Zt, Sr) | 0, ct = ct + Math.imul(rr, vr) | 0, St = St + Math.imul(rr, Sr) | 0;
        var zr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, yt = Math.imul(Et, Dt), ct = Math.imul(Et, Ht), ct = ct + Math.imul(Ct, Dt) | 0, St = Math.imul(Ct, Ht), yt = yt + Math.imul(Or, Qt) | 0, ct = ct + Math.imul(Or, tr) | 0, ct = ct + Math.imul(It, Qt) | 0, St = St + Math.imul(It, tr) | 0, yt = yt + Math.imul(Pr, fr) | 0, ct = ct + Math.imul(Pr, ir) | 0, ct = ct + Math.imul(br, fr) | 0, St = St + Math.imul(br, ir) | 0, yt = yt + Math.imul(Br, wr) | 0, ct = ct + Math.imul(Br, sr) | 0, ct = ct + Math.imul(dr, wr) | 0, St = St + Math.imul(dr, sr) | 0, yt = yt + Math.imul(Ir, Jt) | 0, ct = ct + Math.imul(Ir, er) | 0, ct = ct + Math.imul(lr, Jt) | 0, St = St + Math.imul(lr, er) | 0, yt = yt + Math.imul(ur, vr) | 0, ct = ct + Math.imul(ur, Sr) | 0, ct = ct + Math.imul(hr, vr) | 0, St = St + Math.imul(hr, Sr) | 0;
        var Vr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, yt = Math.imul(Et, Qt), ct = Math.imul(Et, tr), ct = ct + Math.imul(Ct, Qt) | 0, St = Math.imul(Ct, tr), yt = yt + Math.imul(Or, fr) | 0, ct = ct + Math.imul(Or, ir) | 0, ct = ct + Math.imul(It, fr) | 0, St = St + Math.imul(It, ir) | 0, yt = yt + Math.imul(Pr, wr) | 0, ct = ct + Math.imul(Pr, sr) | 0, ct = ct + Math.imul(br, wr) | 0, St = St + Math.imul(br, sr) | 0, yt = yt + Math.imul(Br, Jt) | 0, ct = ct + Math.imul(Br, er) | 0, ct = ct + Math.imul(dr, Jt) | 0, St = St + Math.imul(dr, er) | 0, yt = yt + Math.imul(Ir, vr) | 0, ct = ct + Math.imul(Ir, Sr) | 0, ct = ct + Math.imul(lr, vr) | 0, St = St + Math.imul(lr, Sr) | 0;
        var Xr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, yt = Math.imul(Et, fr), ct = Math.imul(Et, ir), ct = ct + Math.imul(Ct, fr) | 0, St = Math.imul(Ct, ir), yt = yt + Math.imul(Or, wr) | 0, ct = ct + Math.imul(Or, sr) | 0, ct = ct + Math.imul(It, wr) | 0, St = St + Math.imul(It, sr) | 0, yt = yt + Math.imul(Pr, Jt) | 0, ct = ct + Math.imul(Pr, er) | 0, ct = ct + Math.imul(br, Jt) | 0, St = St + Math.imul(br, er) | 0, yt = yt + Math.imul(Br, vr) | 0, ct = ct + Math.imul(Br, Sr) | 0, ct = ct + Math.imul(dr, vr) | 0, St = St + Math.imul(dr, Sr) | 0;
        var Yr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, yt = Math.imul(Et, wr), ct = Math.imul(Et, sr), ct = ct + Math.imul(Ct, wr) | 0, St = Math.imul(Ct, sr), yt = yt + Math.imul(Or, Jt) | 0, ct = ct + Math.imul(Or, er) | 0, ct = ct + Math.imul(It, Jt) | 0, St = St + Math.imul(It, er) | 0, yt = yt + Math.imul(Pr, vr) | 0, ct = ct + Math.imul(Pr, Sr) | 0, ct = ct + Math.imul(br, vr) | 0, St = St + Math.imul(br, Sr) | 0;
        var Jr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, yt = Math.imul(Et, Jt), ct = Math.imul(Et, er), ct = ct + Math.imul(Ct, Jt) | 0, St = Math.imul(Ct, er), yt = yt + Math.imul(Or, vr) | 0, ct = ct + Math.imul(Or, Sr) | 0, ct = ct + Math.imul(It, vr) | 0, St = St + Math.imul(It, Sr) | 0;
        var Zr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        ft = (St + (ct >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, yt = Math.imul(Et, vr), ct = Math.imul(Et, Sr), ct = ct + Math.imul(Ct, vr) | 0, St = Math.imul(Ct, Sr);
        var Qr = (ft + yt | 0) + ((ct & 8191) << 13) | 0;
        return ft = (St + (ct >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, pt[0] = Rr, pt[1] = Tr, pt[2] = Nr, pt[3] = qr, pt[4] = Fr, pt[5] = Ur, pt[6] = jr, pt[7] = Dr, pt[8] = Lr, pt[9] = Hr, pt[10] = Wr, pt[11] = Gr, pt[12] = zr, pt[13] = Vr, pt[14] = Xr, pt[15] = Yr, pt[16] = Jr, pt[17] = Zr, pt[18] = Qr, ft !== 0 && (pt[19] = ft, ot.length++), ot;
      };
      Math.imul || (dt = ht);
      function bt(rt, pe, nt) {
        nt.negative = pe.negative ^ rt.negative, nt.length = rt.length + pe.length;
        for (var ot = 0, st = 0, ut = 0; ut < nt.length - 1; ut++) {
          var pt = st;
          st = 0;
          for (var ft = ot & 67108863, yt = Math.min(ut, pe.length - 1), ct = Math.max(0, ut - rt.length + 1); ct <= yt; ct++) {
            var St = ut - ct, qt = rt.words[St] | 0, jt = pe.words[ct] | 0, Ot = qt * jt, Tt = Ot & 67108863;
            pt = pt + (Ot / 67108864 | 0) | 0, Tt = Tt + ft | 0, ft = Tt & 67108863, pt = pt + (Tt >>> 26) | 0, st += pt >>> 26, pt &= 67108863;
          }
          nt.words[ut] = ft, ot = pt, pt = st;
        }
        return ot !== 0 ? nt.words[ut] = ot : nt.length--, nt._strip();
      }
      function vt(rt, pe, nt) {
        return bt(rt, pe, nt);
      }
      W.prototype.mulTo = function(pe, nt) {
        var ot, st = this.length + pe.length;
        return this.length === 10 && pe.length === 10 ? ot = dt(this, pe, nt) : st < 63 ? ot = ht(this, pe, nt) : st < 1024 ? ot = bt(this, pe, nt) : ot = vt(this, pe, nt), ot;
      }, W.prototype.mul = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), this.mulTo(pe, nt);
      }, W.prototype.mulf = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), vt(this, pe, nt);
      }, W.prototype.imul = function(pe) {
        return this.clone().mulTo(pe, this);
      }, W.prototype.imuln = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(typeof pe == "number"), K(pe < 67108864);
        for (var ot = 0, st = 0; st < this.length; st++) {
          var ut = (this.words[st] | 0) * pe, pt = (ut & 67108863) + (ot & 67108863);
          ot >>= 26, ot += ut / 67108864 | 0, ot += pt >>> 26, this.words[st] = pt & 67108863;
        }
        return ot !== 0 && (this.words[st] = ot, this.length++), nt ? this.ineg() : this;
      }, W.prototype.muln = function(pe) {
        return this.clone().imuln(pe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(pe) {
        var nt = lt(pe);
        if (nt.length === 0) return new W(1);
        for (var ot = this, st = 0; st < nt.length && nt[st] === 0; st++, ot = ot.sqr())
          ;
        if (++st < nt.length)
          for (var ut = ot.sqr(); st < nt.length; st++, ut = ut.sqr())
            nt[st] !== 0 && (ot = ot.mul(ut));
        return ot;
      }, W.prototype.iushln = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, ot = (pe - nt) / 26, st = 67108863 >>> 26 - nt << 26 - nt, ut;
        if (nt !== 0) {
          var pt = 0;
          for (ut = 0; ut < this.length; ut++) {
            var ft = this.words[ut] & st, yt = (this.words[ut] | 0) - ft << nt;
            this.words[ut] = yt | pt, pt = ft >>> 26 - nt;
          }
          pt && (this.words[ut] = pt, this.length++);
        }
        if (ot !== 0) {
          for (ut = this.length - 1; ut >= 0; ut--)
            this.words[ut + ot] = this.words[ut];
          for (ut = 0; ut < ot; ut++)
            this.words[ut] = 0;
          this.length += ot;
        }
        return this._strip();
      }, W.prototype.ishln = function(pe) {
        return K(this.negative === 0), this.iushln(pe);
      }, W.prototype.iushrn = function(pe, nt, ot) {
        K(typeof pe == "number" && pe >= 0);
        var st;
        nt ? st = (nt - nt % 26) / 26 : st = 0;
        var ut = pe % 26, pt = Math.min((pe - ut) / 26, this.length), ft = 67108863 ^ 67108863 >>> ut << ut, yt = ot;
        if (st -= pt, st = Math.max(0, st), yt) {
          for (var ct = 0; ct < pt; ct++)
            yt.words[ct] = this.words[ct];
          yt.length = pt;
        }
        if (pt !== 0) if (this.length > pt)
          for (this.length -= pt, ct = 0; ct < this.length; ct++)
            this.words[ct] = this.words[ct + pt];
        else
          this.words[0] = 0, this.length = 1;
        var St = 0;
        for (ct = this.length - 1; ct >= 0 && (St !== 0 || ct >= st); ct--) {
          var qt = this.words[ct] | 0;
          this.words[ct] = St << 26 - ut | qt >>> ut, St = qt & ft;
        }
        return yt && St !== 0 && (yt.words[yt.length++] = St), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, W.prototype.ishrn = function(pe, nt, ot) {
        return K(this.negative === 0), this.iushrn(pe, nt, ot);
      }, W.prototype.shln = function(pe) {
        return this.clone().ishln(pe);
      }, W.prototype.ushln = function(pe) {
        return this.clone().iushln(pe);
      }, W.prototype.shrn = function(pe) {
        return this.clone().ishrn(pe);
      }, W.prototype.ushrn = function(pe) {
        return this.clone().iushrn(pe);
      }, W.prototype.testn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, ot = (pe - nt) / 26, st = 1 << nt;
        if (this.length <= ot) return !1;
        var ut = this.words[ot];
        return !!(ut & st);
      }, W.prototype.imaskn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, ot = (pe - nt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ot)
          return this;
        if (nt !== 0 && ot++, this.length = Math.min(ot, this.length), nt !== 0) {
          var st = 67108863 ^ 67108863 >>> nt << nt;
          this.words[this.length - 1] &= st;
        }
        return this._strip();
      }, W.prototype.maskn = function(pe) {
        return this.clone().imaskn(pe);
      }, W.prototype.iaddn = function(pe) {
        return K(typeof pe == "number"), K(pe < 67108864), pe < 0 ? this.isubn(-pe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= pe ? (this.words[0] = pe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(pe), this.negative = 1, this) : this._iaddn(pe);
      }, W.prototype._iaddn = function(pe) {
        this.words[0] += pe;
        for (var nt = 0; nt < this.length && this.words[nt] >= 67108864; nt++)
          this.words[nt] -= 67108864, nt === this.length - 1 ? this.words[nt + 1] = 1 : this.words[nt + 1]++;
        return this.length = Math.max(this.length, nt + 1), this;
      }, W.prototype.isubn = function(pe) {
        if (K(typeof pe == "number"), K(pe < 67108864), pe < 0) return this.iaddn(-pe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(pe), this.negative = 1, this;
        if (this.words[0] -= pe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var nt = 0; nt < this.length && this.words[nt] < 0; nt++)
            this.words[nt] += 67108864, this.words[nt + 1] -= 1;
        return this._strip();
      }, W.prototype.addn = function(pe) {
        return this.clone().iaddn(pe);
      }, W.prototype.subn = function(pe) {
        return this.clone().isubn(pe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(pe, nt, ot) {
        var st = pe.length + ot, ut;
        this._expand(st);
        var pt, ft = 0;
        for (ut = 0; ut < pe.length; ut++) {
          pt = (this.words[ut + ot] | 0) + ft;
          var yt = (pe.words[ut] | 0) * nt;
          pt -= yt & 67108863, ft = (pt >> 26) - (yt / 67108864 | 0), this.words[ut + ot] = pt & 67108863;
        }
        for (; ut < this.length - ot; ut++)
          pt = (this.words[ut + ot] | 0) + ft, ft = pt >> 26, this.words[ut + ot] = pt & 67108863;
        if (ft === 0) return this._strip();
        for (K(ft === -1), ft = 0, ut = 0; ut < this.length; ut++)
          pt = -(this.words[ut] | 0) + ft, ft = pt >> 26, this.words[ut] = pt & 67108863;
        return this.negative = 1, this._strip();
      }, W.prototype._wordDiv = function(pe, nt) {
        var ot = this.length - pe.length, st = this.clone(), ut = pe, pt = ut.words[ut.length - 1] | 0, ft = this._countBits(pt);
        ot = 26 - ft, ot !== 0 && (ut = ut.ushln(ot), st.iushln(ot), pt = ut.words[ut.length - 1] | 0);
        var yt = st.length - ut.length, ct;
        if (nt !== "mod") {
          ct = new W(null), ct.length = yt + 1, ct.words = new Array(ct.length);
          for (var St = 0; St < ct.length; St++)
            ct.words[St] = 0;
        }
        var qt = st.clone()._ishlnsubmul(ut, 1, yt);
        qt.negative === 0 && (st = qt, ct && (ct.words[yt] = 1));
        for (var jt = yt - 1; jt >= 0; jt--) {
          var Ot = (st.words[ut.length + jt] | 0) * 67108864 + (st.words[ut.length + jt - 1] | 0);
          for (Ot = Math.min(Ot / pt | 0, 67108863), st._ishlnsubmul(ut, Ot, jt); st.negative !== 0; )
            Ot--, st.negative = 0, st._ishlnsubmul(ut, 1, jt), st.isZero() || (st.negative ^= 1);
          ct && (ct.words[jt] = Ot);
        }
        return ct && ct._strip(), st._strip(), nt !== "div" && ot !== 0 && st.iushrn(ot), {
          div: ct || null,
          mod: st
        };
      }, W.prototype.divmod = function(pe, nt, ot) {
        if (K(!pe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var st, ut, pt;
        return this.negative !== 0 && pe.negative === 0 ? (pt = this.neg().divmod(pe, nt), nt !== "mod" && (st = pt.div.neg()), nt !== "div" && (ut = pt.mod.neg(), ot && ut.negative !== 0 && ut.iadd(pe)), {
          div: st,
          mod: ut
        }) : this.negative === 0 && pe.negative !== 0 ? (pt = this.divmod(pe.neg(), nt), nt !== "mod" && (st = pt.div.neg()), {
          div: st,
          mod: pt.mod
        }) : this.negative & pe.negative ? (pt = this.neg().divmod(pe.neg(), nt), nt !== "div" && (ut = pt.mod.neg(), ot && ut.negative !== 0 && ut.isub(pe)), {
          div: pt.div,
          mod: ut
        }) : pe.length > this.length || this.cmp(pe) < 0 ? {
          div: new W(0),
          mod: this
        } : pe.length === 1 ? nt === "div" ? {
          div: this.divn(pe.words[0]),
          mod: null
        } : nt === "mod" ? {
          div: null,
          mod: new W(this.modrn(pe.words[0]))
        } : {
          div: this.divn(pe.words[0]),
          mod: new W(this.modrn(pe.words[0]))
        } : this._wordDiv(pe, nt);
      }, W.prototype.div = function(pe) {
        return this.divmod(pe, "div", !1).div;
      }, W.prototype.mod = function(pe) {
        return this.divmod(pe, "mod", !1).mod;
      }, W.prototype.umod = function(pe) {
        return this.divmod(pe, "mod", !0).mod;
      }, W.prototype.divRound = function(pe) {
        var nt = this.divmod(pe);
        if (nt.mod.isZero()) return nt.div;
        var ot = nt.div.negative !== 0 ? nt.mod.isub(pe) : nt.mod, st = pe.ushrn(1), ut = pe.andln(1), pt = ot.cmp(st);
        return pt < 0 || ut === 1 && pt === 0 ? nt.div : nt.div.negative !== 0 ? nt.div.isubn(1) : nt.div.iaddn(1);
      }, W.prototype.modrn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var ot = (1 << 26) % pe, st = 0, ut = this.length - 1; ut >= 0; ut--)
          st = (ot * st + (this.words[ut] | 0)) % pe;
        return nt ? -st : st;
      }, W.prototype.modn = function(pe) {
        return this.modrn(pe);
      }, W.prototype.idivn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var ot = 0, st = this.length - 1; st >= 0; st--) {
          var ut = (this.words[st] | 0) + ot * 67108864;
          this.words[st] = ut / pe | 0, ot = ut % pe;
        }
        return this._strip(), nt ? this.ineg() : this;
      }, W.prototype.divn = function(pe) {
        return this.clone().idivn(pe);
      }, W.prototype.egcd = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, ot = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var st = new W(1), ut = new W(0), pt = new W(0), ft = new W(1), yt = 0; nt.isEven() && ot.isEven(); )
          nt.iushrn(1), ot.iushrn(1), ++yt;
        for (var ct = ot.clone(), St = nt.clone(); !nt.isZero(); ) {
          for (var qt = 0, jt = 1; !(nt.words[0] & jt) && qt < 26; ++qt, jt <<= 1) ;
          if (qt > 0)
            for (nt.iushrn(qt); qt-- > 0; )
              (st.isOdd() || ut.isOdd()) && (st.iadd(ct), ut.isub(St)), st.iushrn(1), ut.iushrn(1);
          for (var Ot = 0, Tt = 1; !(ot.words[0] & Tt) && Ot < 26; ++Ot, Tt <<= 1) ;
          if (Ot > 0)
            for (ot.iushrn(Ot); Ot-- > 0; )
              (pt.isOdd() || ft.isOdd()) && (pt.iadd(ct), ft.isub(St)), pt.iushrn(1), ft.iushrn(1);
          nt.cmp(ot) >= 0 ? (nt.isub(ot), st.isub(pt), ut.isub(ft)) : (ot.isub(nt), pt.isub(st), ft.isub(ut));
        }
        return {
          a: pt,
          b: ft,
          gcd: ot.iushln(yt)
        };
      }, W.prototype._invmp = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, ot = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var st = new W(1), ut = new W(0), pt = ot.clone(); nt.cmpn(1) > 0 && ot.cmpn(1) > 0; ) {
          for (var ft = 0, yt = 1; !(nt.words[0] & yt) && ft < 26; ++ft, yt <<= 1) ;
          if (ft > 0)
            for (nt.iushrn(ft); ft-- > 0; )
              st.isOdd() && st.iadd(pt), st.iushrn(1);
          for (var ct = 0, St = 1; !(ot.words[0] & St) && ct < 26; ++ct, St <<= 1) ;
          if (ct > 0)
            for (ot.iushrn(ct); ct-- > 0; )
              ut.isOdd() && ut.iadd(pt), ut.iushrn(1);
          nt.cmp(ot) >= 0 ? (nt.isub(ot), st.isub(ut)) : (ot.isub(nt), ut.isub(st));
        }
        var qt;
        return nt.cmpn(1) === 0 ? qt = st : qt = ut, qt.cmpn(0) < 0 && qt.iadd(pe), qt;
      }, W.prototype.gcd = function(pe) {
        if (this.isZero()) return pe.abs();
        if (pe.isZero()) return this.abs();
        var nt = this.clone(), ot = pe.clone();
        nt.negative = 0, ot.negative = 0;
        for (var st = 0; nt.isEven() && ot.isEven(); st++)
          nt.iushrn(1), ot.iushrn(1);
        do {
          for (; nt.isEven(); )
            nt.iushrn(1);
          for (; ot.isEven(); )
            ot.iushrn(1);
          var ut = nt.cmp(ot);
          if (ut < 0) {
            var pt = nt;
            nt = ot, ot = pt;
          } else if (ut === 0 || ot.cmpn(1) === 0)
            break;
          nt.isub(ot);
        } while (!0);
        return ot.iushln(st);
      }, W.prototype.invm = function(pe) {
        return this.egcd(pe).a.umod(pe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(pe) {
        return this.words[0] & pe;
      }, W.prototype.bincn = function(pe) {
        K(typeof pe == "number");
        var nt = pe % 26, ot = (pe - nt) / 26, st = 1 << nt;
        if (this.length <= ot)
          return this._expand(ot + 1), this.words[ot] |= st, this;
        for (var ut = st, pt = ot; ut !== 0 && pt < this.length; pt++) {
          var ft = this.words[pt] | 0;
          ft += ut, ut = ft >>> 26, ft &= 67108863, this.words[pt] = ft;
        }
        return ut !== 0 && (this.words[pt] = ut, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(pe) {
        var nt = pe < 0;
        if (this.negative !== 0 && !nt) return -1;
        if (this.negative === 0 && nt) return 1;
        this._strip();
        var ot;
        if (this.length > 1)
          ot = 1;
        else {
          nt && (pe = -pe), K(pe <= 67108863, "Number is too big");
          var st = this.words[0] | 0;
          ot = st === pe ? 0 : st < pe ? -1 : 1;
        }
        return this.negative !== 0 ? -ot | 0 : ot;
      }, W.prototype.cmp = function(pe) {
        if (this.negative !== 0 && pe.negative === 0) return -1;
        if (this.negative === 0 && pe.negative !== 0) return 1;
        var nt = this.ucmp(pe);
        return this.negative !== 0 ? -nt | 0 : nt;
      }, W.prototype.ucmp = function(pe) {
        if (this.length > pe.length) return 1;
        if (this.length < pe.length) return -1;
        for (var nt = 0, ot = this.length - 1; ot >= 0; ot--) {
          var st = this.words[ot] | 0, ut = pe.words[ot] | 0;
          if (st !== ut) {
            st < ut ? nt = -1 : st > ut && (nt = 1);
            break;
          }
        }
        return nt;
      }, W.prototype.gtn = function(pe) {
        return this.cmpn(pe) === 1;
      }, W.prototype.gt = function(pe) {
        return this.cmp(pe) === 1;
      }, W.prototype.gten = function(pe) {
        return this.cmpn(pe) >= 0;
      }, W.prototype.gte = function(pe) {
        return this.cmp(pe) >= 0;
      }, W.prototype.ltn = function(pe) {
        return this.cmpn(pe) === -1;
      }, W.prototype.lt = function(pe) {
        return this.cmp(pe) === -1;
      }, W.prototype.lten = function(pe) {
        return this.cmpn(pe) <= 0;
      }, W.prototype.lte = function(pe) {
        return this.cmp(pe) <= 0;
      }, W.prototype.eqn = function(pe) {
        return this.cmpn(pe) === 0;
      }, W.prototype.eq = function(pe) {
        return this.cmp(pe) === 0;
      }, W.red = function(pe) {
        return new wt(pe);
      }, W.prototype.toRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), pe.convertTo(this)._forceRed(pe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(pe) {
        return this.red = pe, this;
      }, W.prototype.forceRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(pe);
      }, W.prototype.redAdd = function(pe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, pe);
      }, W.prototype.redIAdd = function(pe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, pe);
      }, W.prototype.redSub = function(pe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, pe);
      }, W.prototype.redISub = function(pe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, pe);
      }, W.prototype.redShl = function(pe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, pe);
      }, W.prototype.redMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.mul(this, pe);
      }, W.prototype.redIMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.imul(this, pe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(pe) {
        return K(this.red && !pe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, pe);
      };
      var Bt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function At(rt, pe) {
        this.name = rt, this.p = new W(pe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      At.prototype._tmp = function() {
        var pe = new W(null);
        return pe.words = new Array(Math.ceil(this.n / 13)), pe;
      }, At.prototype.ireduce = function(pe) {
        var nt = pe, ot;
        do
          this.split(nt, this.tmp), nt = this.imulK(nt), nt = nt.iadd(this.tmp), ot = nt.bitLength();
        while (ot > this.n);
        var st = ot < this.n ? -1 : nt.ucmp(this.p);
        return st === 0 ? (nt.words[0] = 0, nt.length = 1) : st > 0 ? nt.isub(this.p) : nt.strip !== void 0 ? nt.strip() : nt._strip(), nt;
      }, At.prototype.split = function(pe, nt) {
        pe.iushrn(this.n, 0, nt);
      }, At.prototype.imulK = function(pe) {
        return pe.imul(this.k);
      };
      function Nt() {
        At.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      re(Nt, At), Nt.prototype.split = function(pe, nt) {
        for (var ot = 4194303, st = Math.min(pe.length, 9), ut = 0; ut < st; ut++)
          nt.words[ut] = pe.words[ut];
        if (nt.length = st, pe.length <= 9) {
          pe.words[0] = 0, pe.length = 1;
          return;
        }
        var pt = pe.words[9];
        for (nt.words[nt.length++] = pt & ot, ut = 10; ut < pe.length; ut++) {
          var ft = pe.words[ut] | 0;
          pe.words[ut - 10] = (ft & ot) << 4 | pt >>> 22, pt = ft;
        }
        pt >>>= 22, pe.words[ut - 10] = pt, pt === 0 && pe.length > 10 ? pe.length -= 10 : pe.length -= 9;
      }, Nt.prototype.imulK = function(pe) {
        pe.words[pe.length] = 0, pe.words[pe.length + 1] = 0, pe.length += 2;
        for (var nt = 0, ot = 0; ot < pe.length; ot++) {
          var st = pe.words[ot] | 0;
          nt += st * 977, pe.words[ot] = nt & 67108863, nt = st * 64 + (nt / 67108864 | 0);
        }
        return pe.words[pe.length - 1] === 0 && (pe.length--, pe.words[pe.length - 1] === 0 && pe.length--), pe;
      };
      function $t() {
        At.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      re($t, At);
      function mt() {
        At.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      re(mt, At);
      function xt() {
        At.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      re(xt, At), xt.prototype.imulK = function(pe) {
        for (var nt = 0, ot = 0; ot < pe.length; ot++) {
          var st = (pe.words[ot] | 0) * 19 + nt, ut = st & 67108863;
          st >>>= 26, pe.words[ot] = ut, nt = st;
        }
        return nt !== 0 && (pe.words[pe.length++] = nt), pe;
      }, W._prime = function(pe) {
        if (Bt[pe]) return Bt[pe];
        var nt;
        if (pe === "k256")
          nt = new Nt();
        else if (pe === "p224")
          nt = new $t();
        else if (pe === "p192")
          nt = new mt();
        else if (pe === "p25519")
          nt = new xt();
        else
          throw new Error("Unknown prime " + pe);
        return Bt[pe] = nt, nt;
      };
      function wt(rt) {
        if (typeof rt == "string") {
          var pe = W._prime(rt);
          this.m = pe.p, this.prime = pe;
        } else
          K(rt.gtn(1), "modulus must be greater than 1"), this.m = rt, this.prime = null;
      }
      wt.prototype._verify1 = function(pe) {
        K(pe.negative === 0, "red works only with positives"), K(pe.red, "red works only with red numbers");
      }, wt.prototype._verify2 = function(pe, nt) {
        K((pe.negative | nt.negative) === 0, "red works only with positives"), K(
          pe.red && pe.red === nt.red,
          "red works only with red numbers"
        );
      }, wt.prototype.imod = function(pe) {
        return this.prime ? this.prime.ireduce(pe)._forceRed(this) : (V(pe, pe.umod(this.m)._forceRed(this)), pe);
      }, wt.prototype.neg = function(pe) {
        return pe.isZero() ? pe.clone() : this.m.sub(pe)._forceRed(this);
      }, wt.prototype.add = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.add(nt);
        return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot._forceRed(this);
      }, wt.prototype.iadd = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.iadd(nt);
        return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot;
      }, wt.prototype.sub = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.sub(nt);
        return ot.cmpn(0) < 0 && ot.iadd(this.m), ot._forceRed(this);
      }, wt.prototype.isub = function(pe, nt) {
        this._verify2(pe, nt);
        var ot = pe.isub(nt);
        return ot.cmpn(0) < 0 && ot.iadd(this.m), ot;
      }, wt.prototype.shl = function(pe, nt) {
        return this._verify1(pe), this.imod(pe.ushln(nt));
      }, wt.prototype.imul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.imul(nt));
      }, wt.prototype.mul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.mul(nt));
      }, wt.prototype.isqr = function(pe) {
        return this.imul(pe, pe.clone());
      }, wt.prototype.sqr = function(pe) {
        return this.mul(pe, pe);
      }, wt.prototype.sqrt = function(pe) {
        if (pe.isZero()) return pe.clone();
        var nt = this.m.andln(3);
        if (K(nt % 2 === 1), nt === 3) {
          var ot = this.m.add(new W(1)).iushrn(2);
          return this.pow(pe, ot);
        }
        for (var st = this.m.subn(1), ut = 0; !st.isZero() && st.andln(1) === 0; )
          ut++, st.iushrn(1);
        K(!st.isZero());
        var pt = new W(1).toRed(this), ft = pt.redNeg(), yt = this.m.subn(1).iushrn(1), ct = this.m.bitLength();
        for (ct = new W(2 * ct * ct).toRed(this); this.pow(ct, yt).cmp(ft) !== 0; )
          ct.redIAdd(ft);
        for (var St = this.pow(ct, st), qt = this.pow(pe, st.addn(1).iushrn(1)), jt = this.pow(pe, st), Ot = ut; jt.cmp(pt) !== 0; ) {
          for (var Tt = jt, Rt = 0; Tt.cmp(pt) !== 0; Rt++)
            Tt = Tt.redSqr();
          K(Rt < Ot);
          var Ut = this.pow(St, new W(1).iushln(Ot - Rt - 1));
          qt = qt.redMul(Ut), St = Ut.redSqr(), jt = jt.redMul(St), Ot = Rt;
        }
        return qt;
      }, wt.prototype.invm = function(pe) {
        var nt = pe._invmp(this.m);
        return nt.negative !== 0 ? (nt.negative = 0, this.imod(nt).redNeg()) : this.imod(nt);
      }, wt.prototype.pow = function(pe, nt) {
        if (nt.isZero()) return new W(1).toRed(this);
        if (nt.cmpn(1) === 0) return pe.clone();
        var ot = 4, st = new Array(1 << ot);
        st[0] = new W(1).toRed(this), st[1] = pe;
        for (var ut = 2; ut < st.length; ut++)
          st[ut] = this.mul(st[ut - 1], pe);
        var pt = st[0], ft = 0, yt = 0, ct = nt.bitLength() % 26;
        for (ct === 0 && (ct = 26), ut = nt.length - 1; ut >= 0; ut--) {
          for (var St = nt.words[ut], qt = ct - 1; qt >= 0; qt--) {
            var jt = St >> qt & 1;
            if (pt !== st[0] && (pt = this.sqr(pt)), jt === 0 && ft === 0) {
              yt = 0;
              continue;
            }
            ft <<= 1, ft |= jt, yt++, !(yt !== ot && (ut !== 0 || qt !== 0)) && (pt = this.mul(pt, st[ft]), yt = 0, ft = 0);
          }
          ct = 26;
        }
        return pt;
      }, wt.prototype.convertTo = function(pe) {
        var nt = pe.umod(this.m);
        return nt === pe ? nt.clone() : nt;
      }, wt.prototype.convertFrom = function(pe) {
        var nt = pe.clone();
        return nt.red = null, nt;
      }, W.mont = function(pe) {
        return new Oe(pe);
      };
      function Oe(rt) {
        wt.call(this, rt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      re(Oe, wt), Oe.prototype.convertTo = function(pe) {
        return this.imod(pe.ushln(this.shift));
      }, Oe.prototype.convertFrom = function(pe) {
        var nt = this.imod(pe.mul(this.rinv));
        return nt.red = null, nt;
      }, Oe.prototype.imul = function(pe, nt) {
        if (pe.isZero() || nt.isZero())
          return pe.words[0] = 0, pe.length = 1, pe;
        var ot = pe.imul(nt), st = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ut = ot.isub(st).iushrn(this.shift), pt = ut;
        return ut.cmp(this.m) >= 0 ? pt = ut.isub(this.m) : ut.cmpn(0) < 0 && (pt = ut.iadd(this.m)), pt._forceRed(this);
      }, Oe.prototype.mul = function(pe, nt) {
        if (pe.isZero() || nt.isZero()) return new W(0)._forceRed(this);
        var ot = pe.mul(nt), st = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ut = ot.isub(st).iushrn(this.shift), pt = ut;
        return ut.cmp(this.m) >= 0 ? pt = ut.isub(this.m) : ut.cmpn(0) < 0 && (pt = ut.iadd(this.m)), pt._forceRed(this);
      }, Oe.prototype.invm = function(pe) {
        var nt = this.imod(pe._invmp(this.m).mul(this.r2));
        return nt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var A = requireBn(), B = requireBrowser$b();
  function L(W) {
    var J = K(W), ne = J.toRed(A.mont(W.modulus)).redPow(new A(W.publicExponent)).fromRed();
    return { blinder: ne, unblinder: J.invm(W.modulus) };
  }
  function K(W) {
    var J = W.modulus.byteLength(), ne;
    do
      ne = new A(B(J));
    while (ne.cmp(W.modulus) >= 0 || !ne.umod(W.prime1) || !ne.umod(W.prime2));
    return ne;
  }
  function re(W, J) {
    var ne = L(J), ie = J.modulus.byteLength(), oe = new A(W).mul(ne.blinder).umod(J.modulus), V = oe.toRed(A.mont(J.prime1)), ce = oe.toRed(A.mont(J.prime2)), ke = J.coefficient, Ce = J.prime1, it = J.prime2, at = V.redPow(J.exponent1).fromRed(), lt = ce.redPow(J.exponent2).fromRed(), ht = at.isub(lt).imul(ke).umod(Ce).imul(it);
    return lt.iadd(ht).imul(ne.unblinder).umod(J.modulus).toArrayLike(Buffer$1, "be", ie);
  }
  return re.getr = K, browserifyRsa = re, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(A) {
    var B = A;
    function L(W, J) {
      if (Array.isArray(W))
        return W.slice();
      if (!W)
        return [];
      var ne = [];
      if (typeof W != "string") {
        for (var ie = 0; ie < W.length; ie++)
          ne[ie] = W[ie] | 0;
        return ne;
      }
      if (J === "hex") {
        W = W.replace(/[^a-z0-9]+/ig, ""), W.length % 2 !== 0 && (W = "0" + W);
        for (var ie = 0; ie < W.length; ie += 2)
          ne.push(parseInt(W[ie] + W[ie + 1], 16));
      } else
        for (var ie = 0; ie < W.length; ie++) {
          var oe = W.charCodeAt(ie), V = oe >> 8, ce = oe & 255;
          V ? ne.push(V, ce) : ne.push(ce);
        }
      return ne;
    }
    B.toArray = L;
    function K(W) {
      return W.length === 1 ? "0" + W : W;
    }
    B.zero2 = K;
    function re(W) {
      for (var J = "", ne = 0; ne < W.length; ne++)
        J += K(W[ne].toString(16));
      return J;
    }
    B.toHex = re, B.encode = function(J, ne) {
      return ne === "hex" ? re(J) : J;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(A) {
    var B = A, L = requireBn$1(), K = requireMinimalisticAssert(), re = requireUtils$2();
    B.assert = K, B.toArray = re.toArray, B.zero2 = re.zero2, B.toHex = re.toHex, B.encode = re.encode;
    function W(V, ce, ke) {
      var Ce = new Array(Math.max(V.bitLength(), ke) + 1), it;
      for (it = 0; it < Ce.length; it += 1)
        Ce[it] = 0;
      var at = 1 << ce + 1, lt = V.clone();
      for (it = 0; it < Ce.length; it++) {
        var ht, dt = lt.andln(at - 1);
        lt.isOdd() ? (dt > (at >> 1) - 1 ? ht = (at >> 1) - dt : ht = dt, lt.isubn(ht)) : ht = 0, Ce[it] = ht, lt.iushrn(1);
      }
      return Ce;
    }
    B.getNAF = W;
    function J(V, ce) {
      var ke = [
        [],
        []
      ];
      V = V.clone(), ce = ce.clone();
      for (var Ce = 0, it = 0, at; V.cmpn(-Ce) > 0 || ce.cmpn(-it) > 0; ) {
        var lt = V.andln(3) + Ce & 3, ht = ce.andln(3) + it & 3;
        lt === 3 && (lt = -1), ht === 3 && (ht = -1);
        var dt;
        lt & 1 ? (at = V.andln(7) + Ce & 7, (at === 3 || at === 5) && ht === 2 ? dt = -lt : dt = lt) : dt = 0, ke[0].push(dt);
        var bt;
        ht & 1 ? (at = ce.andln(7) + it & 7, (at === 3 || at === 5) && lt === 2 ? bt = -ht : bt = ht) : bt = 0, ke[1].push(bt), 2 * Ce === dt + 1 && (Ce = 1 - Ce), 2 * it === bt + 1 && (it = 1 - it), V.iushrn(1), ce.iushrn(1);
      }
      return ke;
    }
    B.getJSF = J;
    function ne(V, ce, ke) {
      var Ce = "_" + ce;
      V.prototype[ce] = function() {
        return this[Ce] !== void 0 ? this[Ce] : this[Ce] = ke.call(this);
      };
    }
    B.cachedProperty = ne;
    function ie(V) {
      return typeof V == "string" ? B.toArray(V, "hex") : V;
    }
    B.parseBytes = ie;
    function oe(V) {
      return new L(V, "hex", "le");
    }
    B.intFromLE = oe;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.getNAF, K = B.getJSF, re = B.assert;
  function W(ne, ie) {
    this.type = ne, this.p = new A(ie.p, 16), this.red = ie.prime ? A.red(ie.prime) : A.mont(this.p), this.zero = new A(0).toRed(this.red), this.one = new A(1).toRed(this.red), this.two = new A(2).toRed(this.red), this.n = ie.n && new A(ie.n, 16), this.g = ie.g && this.pointFromJSON(ie.g, ie.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var oe = this.n && this.p.div(this.n);
    !oe || oe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = W, W.prototype.point = function() {
    throw new Error("Not implemented");
  }, W.prototype.validate = function() {
    throw new Error("Not implemented");
  }, W.prototype._fixedNafMul = function(ie, oe) {
    re(ie.precomputed);
    var V = ie._getDoubles(), ce = L(oe, 1, this._bitLength), ke = (1 << V.step + 1) - (V.step % 2 === 0 ? 2 : 1);
    ke /= 3;
    var Ce = [], it, at;
    for (it = 0; it < ce.length; it += V.step) {
      at = 0;
      for (var lt = it + V.step - 1; lt >= it; lt--)
        at = (at << 1) + ce[lt];
      Ce.push(at);
    }
    for (var ht = this.jpoint(null, null, null), dt = this.jpoint(null, null, null), bt = ke; bt > 0; bt--) {
      for (it = 0; it < Ce.length; it++)
        at = Ce[it], at === bt ? dt = dt.mixedAdd(V.points[it]) : at === -bt && (dt = dt.mixedAdd(V.points[it].neg()));
      ht = ht.add(dt);
    }
    return ht.toP();
  }, W.prototype._wnafMul = function(ie, oe) {
    var V = 4, ce = ie._getNAFPoints(V);
    V = ce.wnd;
    for (var ke = ce.points, Ce = L(oe, V, this._bitLength), it = this.jpoint(null, null, null), at = Ce.length - 1; at >= 0; at--) {
      for (var lt = 0; at >= 0 && Ce[at] === 0; at--)
        lt++;
      if (at >= 0 && lt++, it = it.dblp(lt), at < 0)
        break;
      var ht = Ce[at];
      re(ht !== 0), ie.type === "affine" ? ht > 0 ? it = it.mixedAdd(ke[ht - 1 >> 1]) : it = it.mixedAdd(ke[-ht - 1 >> 1].neg()) : ht > 0 ? it = it.add(ke[ht - 1 >> 1]) : it = it.add(ke[-ht - 1 >> 1].neg());
    }
    return ie.type === "affine" ? it.toP() : it;
  }, W.prototype._wnafMulAdd = function(ie, oe, V, ce, ke) {
    var Ce = this._wnafT1, it = this._wnafT2, at = this._wnafT3, lt = 0, ht, dt, bt;
    for (ht = 0; ht < ce; ht++) {
      bt = oe[ht];
      var vt = bt._getNAFPoints(ie);
      Ce[ht] = vt.wnd, it[ht] = vt.points;
    }
    for (ht = ce - 1; ht >= 1; ht -= 2) {
      var Bt = ht - 1, At = ht;
      if (Ce[Bt] !== 1 || Ce[At] !== 1) {
        at[Bt] = L(V[Bt], Ce[Bt], this._bitLength), at[At] = L(V[At], Ce[At], this._bitLength), lt = Math.max(at[Bt].length, lt), lt = Math.max(at[At].length, lt);
        continue;
      }
      var Nt = [
        oe[Bt],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        oe[At]
        /* 7 */
      ];
      oe[Bt].y.cmp(oe[At].y) === 0 ? (Nt[1] = oe[Bt].add(oe[At]), Nt[2] = oe[Bt].toJ().mixedAdd(oe[At].neg())) : oe[Bt].y.cmp(oe[At].y.redNeg()) === 0 ? (Nt[1] = oe[Bt].toJ().mixedAdd(oe[At]), Nt[2] = oe[Bt].add(oe[At].neg())) : (Nt[1] = oe[Bt].toJ().mixedAdd(oe[At]), Nt[2] = oe[Bt].toJ().mixedAdd(oe[At].neg()));
      var $t = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], mt = K(V[Bt], V[At]);
      for (lt = Math.max(mt[0].length, lt), at[Bt] = new Array(lt), at[At] = new Array(lt), dt = 0; dt < lt; dt++) {
        var xt = mt[0][dt] | 0, wt = mt[1][dt] | 0;
        at[Bt][dt] = $t[(xt + 1) * 3 + (wt + 1)], at[At][dt] = 0, it[Bt] = Nt;
      }
    }
    var Oe = this.jpoint(null, null, null), rt = this._wnafT4;
    for (ht = lt; ht >= 0; ht--) {
      for (var pe = 0; ht >= 0; ) {
        var nt = !0;
        for (dt = 0; dt < ce; dt++)
          rt[dt] = at[dt][ht] | 0, rt[dt] !== 0 && (nt = !1);
        if (!nt)
          break;
        pe++, ht--;
      }
      if (ht >= 0 && pe++, Oe = Oe.dblp(pe), ht < 0)
        break;
      for (dt = 0; dt < ce; dt++) {
        var ot = rt[dt];
        ot !== 0 && (ot > 0 ? bt = it[dt][ot - 1 >> 1] : ot < 0 && (bt = it[dt][-ot - 1 >> 1].neg()), bt.type === "affine" ? Oe = Oe.mixedAdd(bt) : Oe = Oe.add(bt));
      }
    }
    for (ht = 0; ht < ce; ht++)
      it[ht] = null;
    return ke ? Oe : Oe.toP();
  };
  function J(ne, ie) {
    this.curve = ne, this.type = ie, this.precomputed = null;
  }
  return W.BasePoint = J, J.prototype.eq = function() {
    throw new Error("Not implemented");
  }, J.prototype.validate = function() {
    return this.curve.validate(this);
  }, W.prototype.decodePoint = function(ie, oe) {
    ie = B.toArray(ie, oe);
    var V = this.p.byteLength();
    if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 === 2 * V) {
      ie[0] === 6 ? re(ie[ie.length - 1] % 2 === 0) : ie[0] === 7 && re(ie[ie.length - 1] % 2 === 1);
      var ce = this.point(
        ie.slice(1, 1 + V),
        ie.slice(1 + V, 1 + 2 * V)
      );
      return ce;
    } else if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === V)
      return this.pointFromX(ie.slice(1, 1 + V), ie[0] === 3);
    throw new Error("Unknown point format");
  }, J.prototype.encodeCompressed = function(ie) {
    return this.encode(ie, !0);
  }, J.prototype._encode = function(ie) {
    var oe = this.curve.p.byteLength(), V = this.getX().toArray("be", oe);
    return ie ? [this.getY().isEven() ? 2 : 3].concat(V) : [4].concat(V, this.getY().toArray("be", oe));
  }, J.prototype.encode = function(ie, oe) {
    return B.encode(this._encode(oe), ie);
  }, J.prototype.precompute = function(ie) {
    if (this.precomputed)
      return this;
    var oe = {
      doubles: null,
      naf: null,
      beta: null
    };
    return oe.naf = this._getNAFPoints(8), oe.doubles = this._getDoubles(4, ie), oe.beta = this._getBeta(), this.precomputed = oe, this;
  }, J.prototype._hasDoubles = function(ie) {
    if (!this.precomputed)
      return !1;
    var oe = this.precomputed.doubles;
    return oe ? oe.points.length >= Math.ceil((ie.bitLength() + 1) / oe.step) : !1;
  }, J.prototype._getDoubles = function(ie, oe) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var V = [this], ce = this, ke = 0; ke < oe; ke += ie) {
      for (var Ce = 0; Ce < ie; Ce++)
        ce = ce.dbl();
      V.push(ce);
    }
    return {
      step: ie,
      points: V
    };
  }, J.prototype._getNAFPoints = function(ie) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var oe = [this], V = (1 << ie) - 1, ce = V === 1 ? null : this.dbl(), ke = 1; ke < V; ke++)
      oe[ke] = oe[ke - 1].add(ce);
    return {
      wnd: ie,
      points: oe
    };
  }, J.prototype._getBeta = function() {
    return null;
  }, J.prototype.dblp = function(ie) {
    for (var oe = this, V = 0; V < ie; V++)
      oe = oe.dbl();
    return oe;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), re = A.assert;
  function W(ie) {
    K.call(this, "short", ie), this.a = new B(ie.a, 16).toRed(this.red), this.b = new B(ie.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ie), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  L(W, K), short = W, W.prototype._getEndomorphism = function(oe) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var V, ce;
      if (oe.beta)
        V = new B(oe.beta, 16).toRed(this.red);
      else {
        var ke = this._getEndoRoots(this.p);
        V = ke[0].cmp(ke[1]) < 0 ? ke[0] : ke[1], V = V.toRed(this.red);
      }
      if (oe.lambda)
        ce = new B(oe.lambda, 16);
      else {
        var Ce = this._getEndoRoots(this.n);
        this.g.mul(Ce[0]).x.cmp(this.g.x.redMul(V)) === 0 ? ce = Ce[0] : (ce = Ce[1], re(this.g.mul(ce).x.cmp(this.g.x.redMul(V)) === 0));
      }
      var it;
      return oe.basis ? it = oe.basis.map(function(at) {
        return {
          a: new B(at.a, 16),
          b: new B(at.b, 16)
        };
      }) : it = this._getEndoBasis(ce), {
        beta: V,
        lambda: ce,
        basis: it
      };
    }
  }, W.prototype._getEndoRoots = function(oe) {
    var V = oe === this.p ? this.red : B.mont(oe), ce = new B(2).toRed(V).redInvm(), ke = ce.redNeg(), Ce = new B(3).toRed(V).redNeg().redSqrt().redMul(ce), it = ke.redAdd(Ce).fromRed(), at = ke.redSub(Ce).fromRed();
    return [it, at];
  }, W.prototype._getEndoBasis = function(oe) {
    for (var V = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ce = oe, ke = this.n.clone(), Ce = new B(1), it = new B(0), at = new B(0), lt = new B(1), ht, dt, bt, vt, Bt, At, Nt, $t = 0, mt, xt; ce.cmpn(0) !== 0; ) {
      var wt = ke.div(ce);
      mt = ke.sub(wt.mul(ce)), xt = at.sub(wt.mul(Ce));
      var Oe = lt.sub(wt.mul(it));
      if (!bt && mt.cmp(V) < 0)
        ht = Nt.neg(), dt = Ce, bt = mt.neg(), vt = xt;
      else if (bt && ++$t === 2)
        break;
      Nt = mt, ke = ce, ce = mt, at = Ce, Ce = xt, lt = it, it = Oe;
    }
    Bt = mt.neg(), At = xt;
    var rt = bt.sqr().add(vt.sqr()), pe = Bt.sqr().add(At.sqr());
    return pe.cmp(rt) >= 0 && (Bt = ht, At = dt), bt.negative && (bt = bt.neg(), vt = vt.neg()), Bt.negative && (Bt = Bt.neg(), At = At.neg()), [
      { a: bt, b: vt },
      { a: Bt, b: At }
    ];
  }, W.prototype._endoSplit = function(oe) {
    var V = this.endo.basis, ce = V[0], ke = V[1], Ce = ke.b.mul(oe).divRound(this.n), it = ce.b.neg().mul(oe).divRound(this.n), at = Ce.mul(ce.a), lt = it.mul(ke.a), ht = Ce.mul(ce.b), dt = it.mul(ke.b), bt = oe.sub(at).sub(lt), vt = ht.add(dt).neg();
    return { k1: bt, k2: vt };
  }, W.prototype.pointFromX = function(oe, V) {
    oe = new B(oe, 16), oe.red || (oe = oe.toRed(this.red));
    var ce = oe.redSqr().redMul(oe).redIAdd(oe.redMul(this.a)).redIAdd(this.b), ke = ce.redSqrt();
    if (ke.redSqr().redSub(ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Ce = ke.fromRed().isOdd();
    return (V && !Ce || !V && Ce) && (ke = ke.redNeg()), this.point(oe, ke);
  }, W.prototype.validate = function(oe) {
    if (oe.inf)
      return !0;
    var V = oe.x, ce = oe.y, ke = this.a.redMul(V), Ce = V.redSqr().redMul(V).redIAdd(ke).redIAdd(this.b);
    return ce.redSqr().redISub(Ce).cmpn(0) === 0;
  }, W.prototype._endoWnafMulAdd = function(oe, V, ce) {
    for (var ke = this._endoWnafT1, Ce = this._endoWnafT2, it = 0; it < oe.length; it++) {
      var at = this._endoSplit(V[it]), lt = oe[it], ht = lt._getBeta();
      at.k1.negative && (at.k1.ineg(), lt = lt.neg(!0)), at.k2.negative && (at.k2.ineg(), ht = ht.neg(!0)), ke[it * 2] = lt, ke[it * 2 + 1] = ht, Ce[it * 2] = at.k1, Ce[it * 2 + 1] = at.k2;
    }
    for (var dt = this._wnafMulAdd(1, ke, Ce, it * 2, ce), bt = 0; bt < it * 2; bt++)
      ke[bt] = null, Ce[bt] = null;
    return dt;
  };
  function J(ie, oe, V, ce) {
    K.BasePoint.call(this, ie, "affine"), oe === null && V === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new B(oe, 16), this.y = new B(V, 16), ce && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  L(J, K.BasePoint), W.prototype.point = function(oe, V, ce) {
    return new J(this, oe, V, ce);
  }, W.prototype.pointFromJSON = function(oe, V) {
    return J.fromJSON(this, oe, V);
  }, J.prototype._getBeta = function() {
    if (this.curve.endo) {
      var oe = this.precomputed;
      if (oe && oe.beta)
        return oe.beta;
      var V = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (oe) {
        var ce = this.curve, ke = function(Ce) {
          return ce.point(Ce.x.redMul(ce.endo.beta), Ce.y);
        };
        oe.beta = V, V.precomputed = {
          beta: null,
          naf: oe.naf && {
            wnd: oe.naf.wnd,
            points: oe.naf.points.map(ke)
          },
          doubles: oe.doubles && {
            step: oe.doubles.step,
            points: oe.doubles.points.map(ke)
          }
        };
      }
      return V;
    }
  }, J.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, J.fromJSON = function(oe, V, ce) {
    typeof V == "string" && (V = JSON.parse(V));
    var ke = oe.point(V[0], V[1], ce);
    if (!V[2])
      return ke;
    function Ce(at) {
      return oe.point(at[0], at[1], ce);
    }
    var it = V[2];
    return ke.precomputed = {
      beta: null,
      doubles: it.doubles && {
        step: it.doubles.step,
        points: [ke].concat(it.doubles.points.map(Ce))
      },
      naf: it.naf && {
        wnd: it.naf.wnd,
        points: [ke].concat(it.naf.points.map(Ce))
      }
    }, ke;
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.inf;
  }, J.prototype.add = function(oe) {
    if (this.inf)
      return oe;
    if (oe.inf)
      return this;
    if (this.eq(oe))
      return this.dbl();
    if (this.neg().eq(oe))
      return this.curve.point(null, null);
    if (this.x.cmp(oe.x) === 0)
      return this.curve.point(null, null);
    var V = this.y.redSub(oe.y);
    V.cmpn(0) !== 0 && (V = V.redMul(this.x.redSub(oe.x).redInvm()));
    var ce = V.redSqr().redISub(this.x).redISub(oe.x), ke = V.redMul(this.x.redSub(ce)).redISub(this.y);
    return this.curve.point(ce, ke);
  }, J.prototype.dbl = function() {
    if (this.inf)
      return this;
    var oe = this.y.redAdd(this.y);
    if (oe.cmpn(0) === 0)
      return this.curve.point(null, null);
    var V = this.curve.a, ce = this.x.redSqr(), ke = oe.redInvm(), Ce = ce.redAdd(ce).redIAdd(ce).redIAdd(V).redMul(ke), it = Ce.redSqr().redISub(this.x.redAdd(this.x)), at = Ce.redMul(this.x.redSub(it)).redISub(this.y);
    return this.curve.point(it, at);
  }, J.prototype.getX = function() {
    return this.x.fromRed();
  }, J.prototype.getY = function() {
    return this.y.fromRed();
  }, J.prototype.mul = function(oe) {
    return oe = new B(oe, 16), this.isInfinity() ? this : this._hasDoubles(oe) ? this.curve._fixedNafMul(this, oe) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [oe]) : this.curve._wnafMul(this, oe);
  }, J.prototype.mulAdd = function(oe, V, ce) {
    var ke = [this, V], Ce = [oe, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Ce) : this.curve._wnafMulAdd(1, ke, Ce, 2);
  }, J.prototype.jmulAdd = function(oe, V, ce) {
    var ke = [this, V], Ce = [oe, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Ce, !0) : this.curve._wnafMulAdd(1, ke, Ce, 2, !0);
  }, J.prototype.eq = function(oe) {
    return this === oe || this.inf === oe.inf && (this.inf || this.x.cmp(oe.x) === 0 && this.y.cmp(oe.y) === 0);
  }, J.prototype.neg = function(oe) {
    if (this.inf)
      return this;
    var V = this.curve.point(this.x, this.y.redNeg());
    if (oe && this.precomputed) {
      var ce = this.precomputed, ke = function(Ce) {
        return Ce.neg();
      };
      V.precomputed = {
        naf: ce.naf && {
          wnd: ce.naf.wnd,
          points: ce.naf.points.map(ke)
        },
        doubles: ce.doubles && {
          step: ce.doubles.step,
          points: ce.doubles.points.map(ke)
        }
      };
    }
    return V;
  }, J.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var oe = this.curve.jpoint(this.x, this.y, this.curve.one);
    return oe;
  };
  function ne(ie, oe, V, ce) {
    K.BasePoint.call(this, ie, "jacobian"), oe === null && V === null && ce === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new B(0)) : (this.x = new B(oe, 16), this.y = new B(V, 16), this.z = new B(ce, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return L(ne, K.BasePoint), W.prototype.jpoint = function(oe, V, ce) {
    return new ne(this, oe, V, ce);
  }, ne.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var oe = this.z.redInvm(), V = oe.redSqr(), ce = this.x.redMul(V), ke = this.y.redMul(V).redMul(oe);
    return this.curve.point(ce, ke);
  }, ne.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ne.prototype.add = function(oe) {
    if (this.isInfinity())
      return oe;
    if (oe.isInfinity())
      return this;
    var V = oe.z.redSqr(), ce = this.z.redSqr(), ke = this.x.redMul(V), Ce = oe.x.redMul(ce), it = this.y.redMul(V.redMul(oe.z)), at = oe.y.redMul(ce.redMul(this.z)), lt = ke.redSub(Ce), ht = it.redSub(at);
    if (lt.cmpn(0) === 0)
      return ht.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var dt = lt.redSqr(), bt = dt.redMul(lt), vt = ke.redMul(dt), Bt = ht.redSqr().redIAdd(bt).redISub(vt).redISub(vt), At = ht.redMul(vt.redISub(Bt)).redISub(it.redMul(bt)), Nt = this.z.redMul(oe.z).redMul(lt);
    return this.curve.jpoint(Bt, At, Nt);
  }, ne.prototype.mixedAdd = function(oe) {
    if (this.isInfinity())
      return oe.toJ();
    if (oe.isInfinity())
      return this;
    var V = this.z.redSqr(), ce = this.x, ke = oe.x.redMul(V), Ce = this.y, it = oe.y.redMul(V).redMul(this.z), at = ce.redSub(ke), lt = Ce.redSub(it);
    if (at.cmpn(0) === 0)
      return lt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var ht = at.redSqr(), dt = ht.redMul(at), bt = ce.redMul(ht), vt = lt.redSqr().redIAdd(dt).redISub(bt).redISub(bt), Bt = lt.redMul(bt.redISub(vt)).redISub(Ce.redMul(dt)), At = this.z.redMul(at);
    return this.curve.jpoint(vt, Bt, At);
  }, ne.prototype.dblp = function(oe) {
    if (oe === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!oe)
      return this.dbl();
    var V;
    if (this.curve.zeroA || this.curve.threeA) {
      var ce = this;
      for (V = 0; V < oe; V++)
        ce = ce.dbl();
      return ce;
    }
    var ke = this.curve.a, Ce = this.curve.tinv, it = this.x, at = this.y, lt = this.z, ht = lt.redSqr().redSqr(), dt = at.redAdd(at);
    for (V = 0; V < oe; V++) {
      var bt = it.redSqr(), vt = dt.redSqr(), Bt = vt.redSqr(), At = bt.redAdd(bt).redIAdd(bt).redIAdd(ke.redMul(ht)), Nt = it.redMul(vt), $t = At.redSqr().redISub(Nt.redAdd(Nt)), mt = Nt.redISub($t), xt = At.redMul(mt);
      xt = xt.redIAdd(xt).redISub(Bt);
      var wt = dt.redMul(lt);
      V + 1 < oe && (ht = ht.redMul(Bt)), it = $t, lt = wt, dt = xt;
    }
    return this.curve.jpoint(it, dt.redMul(Ce), lt);
  }, ne.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ne.prototype._zeroDbl = function() {
    var oe, V, ce;
    if (this.zOne) {
      var ke = this.x.redSqr(), Ce = this.y.redSqr(), it = Ce.redSqr(), at = this.x.redAdd(Ce).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var lt = ke.redAdd(ke).redIAdd(ke), ht = lt.redSqr().redISub(at).redISub(at), dt = it.redIAdd(it);
      dt = dt.redIAdd(dt), dt = dt.redIAdd(dt), oe = ht, V = lt.redMul(at.redISub(ht)).redISub(dt), ce = this.y.redAdd(this.y);
    } else {
      var bt = this.x.redSqr(), vt = this.y.redSqr(), Bt = vt.redSqr(), At = this.x.redAdd(vt).redSqr().redISub(bt).redISub(Bt);
      At = At.redIAdd(At);
      var Nt = bt.redAdd(bt).redIAdd(bt), $t = Nt.redSqr(), mt = Bt.redIAdd(Bt);
      mt = mt.redIAdd(mt), mt = mt.redIAdd(mt), oe = $t.redISub(At).redISub(At), V = Nt.redMul(At.redISub(oe)).redISub(mt), ce = this.y.redMul(this.z), ce = ce.redIAdd(ce);
    }
    return this.curve.jpoint(oe, V, ce);
  }, ne.prototype._threeDbl = function() {
    var oe, V, ce;
    if (this.zOne) {
      var ke = this.x.redSqr(), Ce = this.y.redSqr(), it = Ce.redSqr(), at = this.x.redAdd(Ce).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var lt = ke.redAdd(ke).redIAdd(ke).redIAdd(this.curve.a), ht = lt.redSqr().redISub(at).redISub(at);
      oe = ht;
      var dt = it.redIAdd(it);
      dt = dt.redIAdd(dt), dt = dt.redIAdd(dt), V = lt.redMul(at.redISub(ht)).redISub(dt), ce = this.y.redAdd(this.y);
    } else {
      var bt = this.z.redSqr(), vt = this.y.redSqr(), Bt = this.x.redMul(vt), At = this.x.redSub(bt).redMul(this.x.redAdd(bt));
      At = At.redAdd(At).redIAdd(At);
      var Nt = Bt.redIAdd(Bt);
      Nt = Nt.redIAdd(Nt);
      var $t = Nt.redAdd(Nt);
      oe = At.redSqr().redISub($t), ce = this.y.redAdd(this.z).redSqr().redISub(vt).redISub(bt);
      var mt = vt.redSqr();
      mt = mt.redIAdd(mt), mt = mt.redIAdd(mt), mt = mt.redIAdd(mt), V = At.redMul(Nt.redISub(oe)).redISub(mt);
    }
    return this.curve.jpoint(oe, V, ce);
  }, ne.prototype._dbl = function() {
    var oe = this.curve.a, V = this.x, ce = this.y, ke = this.z, Ce = ke.redSqr().redSqr(), it = V.redSqr(), at = ce.redSqr(), lt = it.redAdd(it).redIAdd(it).redIAdd(oe.redMul(Ce)), ht = V.redAdd(V);
    ht = ht.redIAdd(ht);
    var dt = ht.redMul(at), bt = lt.redSqr().redISub(dt.redAdd(dt)), vt = dt.redISub(bt), Bt = at.redSqr();
    Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt);
    var At = lt.redMul(vt).redISub(Bt), Nt = ce.redAdd(ce).redMul(ke);
    return this.curve.jpoint(bt, At, Nt);
  }, ne.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var oe = this.x.redSqr(), V = this.y.redSqr(), ce = this.z.redSqr(), ke = V.redSqr(), Ce = oe.redAdd(oe).redIAdd(oe), it = Ce.redSqr(), at = this.x.redAdd(V).redSqr().redISub(oe).redISub(ke);
    at = at.redIAdd(at), at = at.redAdd(at).redIAdd(at), at = at.redISub(it);
    var lt = at.redSqr(), ht = ke.redIAdd(ke);
    ht = ht.redIAdd(ht), ht = ht.redIAdd(ht), ht = ht.redIAdd(ht);
    var dt = Ce.redIAdd(at).redSqr().redISub(it).redISub(lt).redISub(ht), bt = V.redMul(dt);
    bt = bt.redIAdd(bt), bt = bt.redIAdd(bt);
    var vt = this.x.redMul(lt).redISub(bt);
    vt = vt.redIAdd(vt), vt = vt.redIAdd(vt);
    var Bt = this.y.redMul(dt.redMul(ht.redISub(dt)).redISub(at.redMul(lt)));
    Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt);
    var At = this.z.redAdd(at).redSqr().redISub(ce).redISub(lt);
    return this.curve.jpoint(vt, Bt, At);
  }, ne.prototype.mul = function(oe, V) {
    return oe = new B(oe, V), this.curve._wnafMul(this, oe);
  }, ne.prototype.eq = function(oe) {
    if (oe.type === "affine")
      return this.eq(oe.toJ());
    if (this === oe)
      return !0;
    var V = this.z.redSqr(), ce = oe.z.redSqr();
    if (this.x.redMul(ce).redISub(oe.x.redMul(V)).cmpn(0) !== 0)
      return !1;
    var ke = V.redMul(this.z), Ce = ce.redMul(oe.z);
    return this.y.redMul(Ce).redISub(oe.y.redMul(ke)).cmpn(0) === 0;
  }, ne.prototype.eqXToP = function(oe) {
    var V = this.z.redSqr(), ce = oe.toRed(this.curve.red).redMul(V);
    if (this.x.cmp(ce) === 0)
      return !0;
    for (var ke = oe.clone(), Ce = this.curve.redN.redMul(V); ; ) {
      if (ke.iadd(this.curve.n), ke.cmp(this.curve.p) >= 0)
        return !1;
      if (ce.redIAdd(Ce), this.x.cmp(ce) === 0)
        return !0;
    }
  }, ne.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ne.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var A = requireBn$1(), B = requireInherits_browser(), L = requireBase$1(), K = requireUtils$1();
  function re(J) {
    L.call(this, "mont", J), this.a = new A(J.a, 16).toRed(this.red), this.b = new A(J.b, 16).toRed(this.red), this.i4 = new A(4).toRed(this.red).redInvm(), this.two = new A(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  B(re, L), mont = re, re.prototype.validate = function(ne) {
    var ie = ne.normalize().x, oe = ie.redSqr(), V = oe.redMul(ie).redAdd(oe.redMul(this.a)).redAdd(ie), ce = V.redSqrt();
    return ce.redSqr().cmp(V) === 0;
  };
  function W(J, ne, ie) {
    L.BasePoint.call(this, J, "projective"), ne === null && ie === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new A(ne, 16), this.z = new A(ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return B(W, L.BasePoint), re.prototype.decodePoint = function(ne, ie) {
    return this.point(K.toArray(ne, ie), 1);
  }, re.prototype.point = function(ne, ie) {
    return new W(this, ne, ie);
  }, re.prototype.pointFromJSON = function(ne) {
    return W.fromJSON(this, ne);
  }, W.prototype.precompute = function() {
  }, W.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, W.fromJSON = function(ne, ie) {
    return new W(ne, ie[0], ie[1] || ne.one);
  }, W.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, W.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, W.prototype.dbl = function() {
    var ne = this.x.redAdd(this.z), ie = ne.redSqr(), oe = this.x.redSub(this.z), V = oe.redSqr(), ce = ie.redSub(V), ke = ie.redMul(V), Ce = ce.redMul(V.redAdd(this.curve.a24.redMul(ce)));
    return this.curve.point(ke, Ce);
  }, W.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.diffAdd = function(ne, ie) {
    var oe = this.x.redAdd(this.z), V = this.x.redSub(this.z), ce = ne.x.redAdd(ne.z), ke = ne.x.redSub(ne.z), Ce = ke.redMul(oe), it = ce.redMul(V), at = ie.z.redMul(Ce.redAdd(it).redSqr()), lt = ie.x.redMul(Ce.redISub(it).redSqr());
    return this.curve.point(at, lt);
  }, W.prototype.mul = function(ne) {
    for (var ie = ne.clone(), oe = this, V = this.curve.point(null, null), ce = this, ke = []; ie.cmpn(0) !== 0; ie.iushrn(1))
      ke.push(ie.andln(1));
    for (var Ce = ke.length - 1; Ce >= 0; Ce--)
      ke[Ce] === 0 ? (oe = oe.diffAdd(V, ce), V = V.dbl()) : (V = oe.diffAdd(V, ce), oe = oe.dbl());
    return V;
  }, W.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.eq = function(ne) {
    return this.getX().cmp(ne.getX()) === 0;
  }, W.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, W.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), re = A.assert;
  function W(ne) {
    this.twisted = (ne.a | 0) !== 1, this.mOneA = this.twisted && (ne.a | 0) === -1, this.extended = this.mOneA, K.call(this, "edwards", ne), this.a = new B(ne.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new B(ne.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new B(ne.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), re(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ne.c | 0) === 1;
  }
  L(W, K), edwards = W, W.prototype._mulA = function(ie) {
    return this.mOneA ? ie.redNeg() : this.a.redMul(ie);
  }, W.prototype._mulC = function(ie) {
    return this.oneC ? ie : this.c.redMul(ie);
  }, W.prototype.jpoint = function(ie, oe, V, ce) {
    return this.point(ie, oe, V, ce);
  }, W.prototype.pointFromX = function(ie, oe) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var V = ie.redSqr(), ce = this.c2.redSub(this.a.redMul(V)), ke = this.one.redSub(this.c2.redMul(this.d).redMul(V)), Ce = ce.redMul(ke.redInvm()), it = Ce.redSqrt();
    if (it.redSqr().redSub(Ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var at = it.fromRed().isOdd();
    return (oe && !at || !oe && at) && (it = it.redNeg()), this.point(ie, it);
  }, W.prototype.pointFromY = function(ie, oe) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var V = ie.redSqr(), ce = V.redSub(this.c2), ke = V.redMul(this.d).redMul(this.c2).redSub(this.a), Ce = ce.redMul(ke.redInvm());
    if (Ce.cmp(this.zero) === 0) {
      if (oe)
        throw new Error("invalid point");
      return this.point(this.zero, ie);
    }
    var it = Ce.redSqrt();
    if (it.redSqr().redSub(Ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return it.fromRed().isOdd() !== oe && (it = it.redNeg()), this.point(it, ie);
  }, W.prototype.validate = function(ie) {
    if (ie.isInfinity())
      return !0;
    ie.normalize();
    var oe = ie.x.redSqr(), V = ie.y.redSqr(), ce = oe.redMul(this.a).redAdd(V), ke = this.c2.redMul(this.one.redAdd(this.d.redMul(oe).redMul(V)));
    return ce.cmp(ke) === 0;
  };
  function J(ne, ie, oe, V, ce) {
    K.BasePoint.call(this, ne, "projective"), ie === null && oe === null && V === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new B(ie, 16), this.y = new B(oe, 16), this.z = V ? new B(V, 16) : this.curve.one, this.t = ce && new B(ce, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return L(J, K.BasePoint), W.prototype.pointFromJSON = function(ie) {
    return J.fromJSON(this, ie);
  }, W.prototype.point = function(ie, oe, V, ce) {
    return new J(this, ie, oe, V, ce);
  }, J.fromJSON = function(ie, oe) {
    return new J(ie, oe[0], oe[1], oe[2]);
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, J.prototype._extDbl = function() {
    var ie = this.x.redSqr(), oe = this.y.redSqr(), V = this.z.redSqr();
    V = V.redIAdd(V);
    var ce = this.curve._mulA(ie), ke = this.x.redAdd(this.y).redSqr().redISub(ie).redISub(oe), Ce = ce.redAdd(oe), it = Ce.redSub(V), at = ce.redSub(oe), lt = ke.redMul(it), ht = Ce.redMul(at), dt = ke.redMul(at), bt = it.redMul(Ce);
    return this.curve.point(lt, ht, bt, dt);
  }, J.prototype._projDbl = function() {
    var ie = this.x.redAdd(this.y).redSqr(), oe = this.x.redSqr(), V = this.y.redSqr(), ce, ke, Ce, it, at, lt;
    if (this.curve.twisted) {
      it = this.curve._mulA(oe);
      var ht = it.redAdd(V);
      this.zOne ? (ce = ie.redSub(oe).redSub(V).redMul(ht.redSub(this.curve.two)), ke = ht.redMul(it.redSub(V)), Ce = ht.redSqr().redSub(ht).redSub(ht)) : (at = this.z.redSqr(), lt = ht.redSub(at).redISub(at), ce = ie.redSub(oe).redISub(V).redMul(lt), ke = ht.redMul(it.redSub(V)), Ce = ht.redMul(lt));
    } else
      it = oe.redAdd(V), at = this.curve._mulC(this.z).redSqr(), lt = it.redSub(at).redSub(at), ce = this.curve._mulC(ie.redISub(it)).redMul(lt), ke = this.curve._mulC(it).redMul(oe.redISub(V)), Ce = it.redMul(lt);
    return this.curve.point(ce, ke, Ce);
  }, J.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, J.prototype._extAdd = function(ie) {
    var oe = this.y.redSub(this.x).redMul(ie.y.redSub(ie.x)), V = this.y.redAdd(this.x).redMul(ie.y.redAdd(ie.x)), ce = this.t.redMul(this.curve.dd).redMul(ie.t), ke = this.z.redMul(ie.z.redAdd(ie.z)), Ce = V.redSub(oe), it = ke.redSub(ce), at = ke.redAdd(ce), lt = V.redAdd(oe), ht = Ce.redMul(it), dt = at.redMul(lt), bt = Ce.redMul(lt), vt = it.redMul(at);
    return this.curve.point(ht, dt, vt, bt);
  }, J.prototype._projAdd = function(ie) {
    var oe = this.z.redMul(ie.z), V = oe.redSqr(), ce = this.x.redMul(ie.x), ke = this.y.redMul(ie.y), Ce = this.curve.d.redMul(ce).redMul(ke), it = V.redSub(Ce), at = V.redAdd(Ce), lt = this.x.redAdd(this.y).redMul(ie.x.redAdd(ie.y)).redISub(ce).redISub(ke), ht = oe.redMul(it).redMul(lt), dt, bt;
    return this.curve.twisted ? (dt = oe.redMul(at).redMul(ke.redSub(this.curve._mulA(ce))), bt = it.redMul(at)) : (dt = oe.redMul(at).redMul(ke.redSub(ce)), bt = this.curve._mulC(it).redMul(at)), this.curve.point(ht, dt, bt);
  }, J.prototype.add = function(ie) {
    return this.isInfinity() ? ie : ie.isInfinity() ? this : this.curve.extended ? this._extAdd(ie) : this._projAdd(ie);
  }, J.prototype.mul = function(ie) {
    return this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve._wnafMul(this, ie);
  }, J.prototype.mulAdd = function(ie, oe, V) {
    return this.curve._wnafMulAdd(1, [this, oe], [ie, V], 2, !1);
  }, J.prototype.jmulAdd = function(ie, oe, V) {
    return this.curve._wnafMulAdd(1, [this, oe], [ie, V], 2, !0);
  }, J.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ie = this.z.redInvm();
    return this.x = this.x.redMul(ie), this.y = this.y.redMul(ie), this.t && (this.t = this.t.redMul(ie)), this.z = this.curve.one, this.zOne = !0, this;
  }, J.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, J.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, J.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, J.prototype.eq = function(ie) {
    return this === ie || this.getX().cmp(ie.getX()) === 0 && this.getY().cmp(ie.getY()) === 0;
  }, J.prototype.eqXToP = function(ie) {
    var oe = ie.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(oe) === 0)
      return !0;
    for (var V = ie.clone(), ce = this.curve.redN.redMul(this.z); ; ) {
      if (V.iadd(this.curve.n), V.cmp(this.curve.p) >= 0)
        return !1;
      if (oe.redIAdd(ce), this.x.cmp(oe) === 0)
        return !0;
    }
  }, J.prototype.toP = J.prototype.normalize, J.prototype.mixedAdd = J.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(A) {
    var B = A;
    B.base = requireBase$1(), B.short = requireShort(), B.mont = requireMont(), B.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser();
  utils$1.inherits = B;
  function L(Oe, rt) {
    return (Oe.charCodeAt(rt) & 64512) !== 55296 || rt < 0 || rt + 1 >= Oe.length ? !1 : (Oe.charCodeAt(rt + 1) & 64512) === 56320;
  }
  function K(Oe, rt) {
    if (Array.isArray(Oe))
      return Oe.slice();
    if (!Oe)
      return [];
    var pe = [];
    if (typeof Oe == "string")
      if (rt) {
        if (rt === "hex")
          for (Oe = Oe.replace(/[^a-z0-9]+/ig, ""), Oe.length % 2 !== 0 && (Oe = "0" + Oe), ot = 0; ot < Oe.length; ot += 2)
            pe.push(parseInt(Oe[ot] + Oe[ot + 1], 16));
      } else for (var nt = 0, ot = 0; ot < Oe.length; ot++) {
        var st = Oe.charCodeAt(ot);
        st < 128 ? pe[nt++] = st : st < 2048 ? (pe[nt++] = st >> 6 | 192, pe[nt++] = st & 63 | 128) : L(Oe, ot) ? (st = 65536 + ((st & 1023) << 10) + (Oe.charCodeAt(++ot) & 1023), pe[nt++] = st >> 18 | 240, pe[nt++] = st >> 12 & 63 | 128, pe[nt++] = st >> 6 & 63 | 128, pe[nt++] = st & 63 | 128) : (pe[nt++] = st >> 12 | 224, pe[nt++] = st >> 6 & 63 | 128, pe[nt++] = st & 63 | 128);
      }
    else
      for (ot = 0; ot < Oe.length; ot++)
        pe[ot] = Oe[ot] | 0;
    return pe;
  }
  utils$1.toArray = K;
  function re(Oe) {
    for (var rt = "", pe = 0; pe < Oe.length; pe++)
      rt += ne(Oe[pe].toString(16));
    return rt;
  }
  utils$1.toHex = re;
  function W(Oe) {
    var rt = Oe >>> 24 | Oe >>> 8 & 65280 | Oe << 8 & 16711680 | (Oe & 255) << 24;
    return rt >>> 0;
  }
  utils$1.htonl = W;
  function J(Oe, rt) {
    for (var pe = "", nt = 0; nt < Oe.length; nt++) {
      var ot = Oe[nt];
      rt === "little" && (ot = W(ot)), pe += ie(ot.toString(16));
    }
    return pe;
  }
  utils$1.toHex32 = J;
  function ne(Oe) {
    return Oe.length === 1 ? "0" + Oe : Oe;
  }
  utils$1.zero2 = ne;
  function ie(Oe) {
    return Oe.length === 7 ? "0" + Oe : Oe.length === 6 ? "00" + Oe : Oe.length === 5 ? "000" + Oe : Oe.length === 4 ? "0000" + Oe : Oe.length === 3 ? "00000" + Oe : Oe.length === 2 ? "000000" + Oe : Oe.length === 1 ? "0000000" + Oe : Oe;
  }
  utils$1.zero8 = ie;
  function oe(Oe, rt, pe, nt) {
    var ot = pe - rt;
    A(ot % 4 === 0);
    for (var st = new Array(ot / 4), ut = 0, pt = rt; ut < st.length; ut++, pt += 4) {
      var ft;
      nt === "big" ? ft = Oe[pt] << 24 | Oe[pt + 1] << 16 | Oe[pt + 2] << 8 | Oe[pt + 3] : ft = Oe[pt + 3] << 24 | Oe[pt + 2] << 16 | Oe[pt + 1] << 8 | Oe[pt], st[ut] = ft >>> 0;
    }
    return st;
  }
  utils$1.join32 = oe;
  function V(Oe, rt) {
    for (var pe = new Array(Oe.length * 4), nt = 0, ot = 0; nt < Oe.length; nt++, ot += 4) {
      var st = Oe[nt];
      rt === "big" ? (pe[ot] = st >>> 24, pe[ot + 1] = st >>> 16 & 255, pe[ot + 2] = st >>> 8 & 255, pe[ot + 3] = st & 255) : (pe[ot + 3] = st >>> 24, pe[ot + 2] = st >>> 16 & 255, pe[ot + 1] = st >>> 8 & 255, pe[ot] = st & 255);
    }
    return pe;
  }
  utils$1.split32 = V;
  function ce(Oe, rt) {
    return Oe >>> rt | Oe << 32 - rt;
  }
  utils$1.rotr32 = ce;
  function ke(Oe, rt) {
    return Oe << rt | Oe >>> 32 - rt;
  }
  utils$1.rotl32 = ke;
  function Ce(Oe, rt) {
    return Oe + rt >>> 0;
  }
  utils$1.sum32 = Ce;
  function it(Oe, rt, pe) {
    return Oe + rt + pe >>> 0;
  }
  utils$1.sum32_3 = it;
  function at(Oe, rt, pe, nt) {
    return Oe + rt + pe + nt >>> 0;
  }
  utils$1.sum32_4 = at;
  function lt(Oe, rt, pe, nt, ot) {
    return Oe + rt + pe + nt + ot >>> 0;
  }
  utils$1.sum32_5 = lt;
  function ht(Oe, rt, pe, nt) {
    var ot = Oe[rt], st = Oe[rt + 1], ut = nt + st >>> 0, pt = (ut < nt ? 1 : 0) + pe + ot;
    Oe[rt] = pt >>> 0, Oe[rt + 1] = ut;
  }
  utils$1.sum64 = ht;
  function dt(Oe, rt, pe, nt) {
    var ot = rt + nt >>> 0, st = (ot < rt ? 1 : 0) + Oe + pe;
    return st >>> 0;
  }
  utils$1.sum64_hi = dt;
  function bt(Oe, rt, pe, nt) {
    var ot = rt + nt;
    return ot >>> 0;
  }
  utils$1.sum64_lo = bt;
  function vt(Oe, rt, pe, nt, ot, st, ut, pt) {
    var ft = 0, yt = rt;
    yt = yt + nt >>> 0, ft += yt < rt ? 1 : 0, yt = yt + st >>> 0, ft += yt < st ? 1 : 0, yt = yt + pt >>> 0, ft += yt < pt ? 1 : 0;
    var ct = Oe + pe + ot + ut + ft;
    return ct >>> 0;
  }
  utils$1.sum64_4_hi = vt;
  function Bt(Oe, rt, pe, nt, ot, st, ut, pt) {
    var ft = rt + nt + st + pt;
    return ft >>> 0;
  }
  utils$1.sum64_4_lo = Bt;
  function At(Oe, rt, pe, nt, ot, st, ut, pt, ft, yt) {
    var ct = 0, St = rt;
    St = St + nt >>> 0, ct += St < rt ? 1 : 0, St = St + st >>> 0, ct += St < st ? 1 : 0, St = St + pt >>> 0, ct += St < pt ? 1 : 0, St = St + yt >>> 0, ct += St < yt ? 1 : 0;
    var qt = Oe + pe + ot + ut + ft + ct;
    return qt >>> 0;
  }
  utils$1.sum64_5_hi = At;
  function Nt(Oe, rt, pe, nt, ot, st, ut, pt, ft, yt) {
    var ct = rt + nt + st + pt + yt;
    return ct >>> 0;
  }
  utils$1.sum64_5_lo = Nt;
  function $t(Oe, rt, pe) {
    var nt = rt << 32 - pe | Oe >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_hi = $t;
  function mt(Oe, rt, pe) {
    var nt = Oe << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_lo = mt;
  function xt(Oe, rt, pe) {
    return Oe >>> pe;
  }
  utils$1.shr64_hi = xt;
  function wt(Oe, rt, pe) {
    var nt = Oe << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  return utils$1.shr64_lo = wt, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = L, L.prototype.update = function(re, W) {
    if (re = A.toArray(re, W), this.pending ? this.pending = this.pending.concat(re) : this.pending = re, this.pendingTotal += re.length, this.pending.length >= this._delta8) {
      re = this.pending;
      var J = re.length % this._delta8;
      this.pending = re.slice(re.length - J, re.length), this.pending.length === 0 && (this.pending = null), re = A.join32(re, 0, re.length - J, this.endian);
      for (var ne = 0; ne < re.length; ne += this._delta32)
        this._update(re, ne, ne + this._delta32);
    }
    return this;
  }, L.prototype.digest = function(re) {
    return this.update(this._pad()), B(this.pending === null), this._digest(re);
  }, L.prototype._pad = function() {
    var re = this.pendingTotal, W = this._delta8, J = W - (re + this.padLength) % W, ne = new Array(J + this.padLength);
    ne[0] = 128;
    for (var ie = 1; ie < J; ie++)
      ne[ie] = 0;
    if (re <<= 3, this.endian === "big") {
      for (var oe = 8; oe < this.padLength; oe++)
        ne[ie++] = 0;
      ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = re >>> 24 & 255, ne[ie++] = re >>> 16 & 255, ne[ie++] = re >>> 8 & 255, ne[ie++] = re & 255;
    } else
      for (ne[ie++] = re & 255, ne[ie++] = re >>> 8 & 255, ne[ie++] = re >>> 16 & 255, ne[ie++] = re >>> 24 & 255, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, oe = 8; oe < this.padLength; oe++)
        ne[ie++] = 0;
    return ne;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var A = requireUtils(), B = A.rotr32;
  function L(V, ce, ke, Ce) {
    if (V === 0)
      return K(ce, ke, Ce);
    if (V === 1 || V === 3)
      return W(ce, ke, Ce);
    if (V === 2)
      return re(ce, ke, Ce);
  }
  common.ft_1 = L;
  function K(V, ce, ke) {
    return V & ce ^ ~V & ke;
  }
  common.ch32 = K;
  function re(V, ce, ke) {
    return V & ce ^ V & ke ^ ce & ke;
  }
  common.maj32 = re;
  function W(V, ce, ke) {
    return V ^ ce ^ ke;
  }
  common.p32 = W;
  function J(V) {
    return B(V, 2) ^ B(V, 13) ^ B(V, 22);
  }
  common.s0_256 = J;
  function ne(V) {
    return B(V, 6) ^ B(V, 11) ^ B(V, 25);
  }
  common.s1_256 = ne;
  function ie(V) {
    return B(V, 7) ^ B(V, 18) ^ V >>> 3;
  }
  common.g0_256 = ie;
  function oe(V) {
    return B(V, 17) ^ B(V, 19) ^ V >>> 10;
  }
  return common.g1_256 = oe, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = A.rotl32, re = A.sum32, W = A.sum32_5, J = L.ft_1, ne = B.BlockHash, ie = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function oe() {
    if (!(this instanceof oe))
      return new oe();
    ne.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return A.inherits(oe, ne), _1 = oe, oe.blockSize = 512, oe.outSize = 160, oe.hmacStrength = 80, oe.padLength = 64, oe.prototype._update = function(ce, ke) {
    for (var Ce = this.W, it = 0; it < 16; it++)
      Ce[it] = ce[ke + it];
    for (; it < Ce.length; it++)
      Ce[it] = K(Ce[it - 3] ^ Ce[it - 8] ^ Ce[it - 14] ^ Ce[it - 16], 1);
    var at = this.h[0], lt = this.h[1], ht = this.h[2], dt = this.h[3], bt = this.h[4];
    for (it = 0; it < Ce.length; it++) {
      var vt = ~~(it / 20), Bt = W(K(at, 5), J(vt, lt, ht, dt), bt, Ce[it], ie[vt]);
      bt = dt, dt = ht, ht = K(lt, 30), lt = at, at = Bt;
    }
    this.h[0] = re(this.h[0], at), this.h[1] = re(this.h[1], lt), this.h[2] = re(this.h[2], ht), this.h[3] = re(this.h[3], dt), this.h[4] = re(this.h[4], bt);
  }, oe.prototype._digest = function(ce) {
    return ce === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = requireMinimalisticAssert(), re = A.sum32, W = A.sum32_4, J = A.sum32_5, ne = L.ch32, ie = L.maj32, oe = L.s0_256, V = L.s1_256, ce = L.g0_256, ke = L.g1_256, Ce = B.BlockHash, it = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function at() {
    if (!(this instanceof at))
      return new at();
    Ce.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = it, this.W = new Array(64);
  }
  return A.inherits(at, Ce), _256 = at, at.blockSize = 512, at.outSize = 256, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(ht, dt) {
    for (var bt = this.W, vt = 0; vt < 16; vt++)
      bt[vt] = ht[dt + vt];
    for (; vt < bt.length; vt++)
      bt[vt] = W(ke(bt[vt - 2]), bt[vt - 7], ce(bt[vt - 15]), bt[vt - 16]);
    var Bt = this.h[0], At = this.h[1], Nt = this.h[2], $t = this.h[3], mt = this.h[4], xt = this.h[5], wt = this.h[6], Oe = this.h[7];
    for (K(this.k.length === bt.length), vt = 0; vt < bt.length; vt++) {
      var rt = J(Oe, V(mt), ne(mt, xt, wt), this.k[vt], bt[vt]), pe = re(oe(Bt), ie(Bt, At, Nt));
      Oe = wt, wt = xt, xt = mt, mt = re($t, rt), $t = Nt, Nt = At, At = Bt, Bt = re(rt, pe);
    }
    this.h[0] = re(this.h[0], Bt), this.h[1] = re(this.h[1], At), this.h[2] = re(this.h[2], Nt), this.h[3] = re(this.h[3], $t), this.h[4] = re(this.h[4], mt), this.h[5] = re(this.h[5], xt), this.h[6] = re(this.h[6], wt), this.h[7] = re(this.h[7], Oe);
  }, at.prototype._digest = function(ht) {
    return ht === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var A = requireUtils(), B = require_256();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return A.inherits(L, B), _224 = L, L.blockSize = 512, L.outSize = 224, L.hmacStrength = 192, L.padLength = 64, L.prototype._digest = function(re) {
    return re === "hex" ? A.toHex32(this.h.slice(0, 7), "big") : A.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireMinimalisticAssert(), K = A.rotr64_hi, re = A.rotr64_lo, W = A.shr64_hi, J = A.shr64_lo, ne = A.sum64, ie = A.sum64_hi, oe = A.sum64_lo, V = A.sum64_4_hi, ce = A.sum64_4_lo, ke = A.sum64_5_hi, Ce = A.sum64_5_lo, it = B.BlockHash, at = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function lt() {
    if (!(this instanceof lt))
      return new lt();
    it.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = at, this.W = new Array(160);
  }
  A.inherits(lt, it), _512 = lt, lt.blockSize = 1024, lt.outSize = 512, lt.hmacStrength = 192, lt.padLength = 128, lt.prototype._prepareBlock = function(pe, nt) {
    for (var ot = this.W, st = 0; st < 32; st++)
      ot[st] = pe[nt + st];
    for (; st < ot.length; st += 2) {
      var ut = wt(ot[st - 4], ot[st - 3]), pt = Oe(ot[st - 4], ot[st - 3]), ft = ot[st - 14], yt = ot[st - 13], ct = mt(ot[st - 30], ot[st - 29]), St = xt(ot[st - 30], ot[st - 29]), qt = ot[st - 32], jt = ot[st - 31];
      ot[st] = V(
        ut,
        pt,
        ft,
        yt,
        ct,
        St,
        qt,
        jt
      ), ot[st + 1] = ce(
        ut,
        pt,
        ft,
        yt,
        ct,
        St,
        qt,
        jt
      );
    }
  }, lt.prototype._update = function(pe, nt) {
    this._prepareBlock(pe, nt);
    var ot = this.W, st = this.h[0], ut = this.h[1], pt = this.h[2], ft = this.h[3], yt = this.h[4], ct = this.h[5], St = this.h[6], qt = this.h[7], jt = this.h[8], Ot = this.h[9], Tt = this.h[10], Rt = this.h[11], Ut = this.h[12], Gt = this.h[13], Mt = this.h[14], Pt = this.h[15];
    L(this.k.length === ot.length);
    for (var Kt = 0; Kt < ot.length; Kt += 2) {
      var Zt = Mt, rr = Pt, ar = Nt(jt, Ot), ur = $t(jt, Ot), hr = ht(jt, Ot, Tt, Rt, Ut), Yt = dt(jt, Ot, Tt, Rt, Ut, Gt), Ir = this.k[Kt], lr = this.k[Kt + 1], Ar = ot[Kt], Br = ot[Kt + 1], dr = ke(
        Zt,
        rr,
        ar,
        ur,
        hr,
        Yt,
        Ir,
        lr,
        Ar,
        Br
      ), Er = Ce(
        Zt,
        rr,
        ar,
        ur,
        hr,
        Yt,
        Ir,
        lr,
        Ar,
        Br
      );
      Zt = Bt(st, ut), rr = At(st, ut), ar = bt(st, ut, pt, ft, yt), ur = vt(st, ut, pt, ft, yt, ct);
      var Pr = ie(Zt, rr, ar, ur), br = oe(Zt, rr, ar, ur);
      Mt = Ut, Pt = Gt, Ut = Tt, Gt = Rt, Tt = jt, Rt = Ot, jt = ie(St, qt, dr, Er), Ot = oe(qt, qt, dr, Er), St = yt, qt = ct, yt = pt, ct = ft, pt = st, ft = ut, st = ie(dr, Er, Pr, br), ut = oe(dr, Er, Pr, br);
    }
    ne(this.h, 0, st, ut), ne(this.h, 2, pt, ft), ne(this.h, 4, yt, ct), ne(this.h, 6, St, qt), ne(this.h, 8, jt, Ot), ne(this.h, 10, Tt, Rt), ne(this.h, 12, Ut, Gt), ne(this.h, 14, Mt, Pt);
  }, lt.prototype._digest = function(pe) {
    return pe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  };
  function ht(rt, pe, nt, ot, st) {
    var ut = rt & nt ^ ~rt & st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function dt(rt, pe, nt, ot, st, ut) {
    var pt = pe & ot ^ ~pe & ut;
    return pt < 0 && (pt += 4294967296), pt;
  }
  function bt(rt, pe, nt, ot, st) {
    var ut = rt & nt ^ rt & st ^ nt & st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function vt(rt, pe, nt, ot, st, ut) {
    var pt = pe & ot ^ pe & ut ^ ot & ut;
    return pt < 0 && (pt += 4294967296), pt;
  }
  function Bt(rt, pe) {
    var nt = K(rt, pe, 28), ot = K(pe, rt, 2), st = K(pe, rt, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function At(rt, pe) {
    var nt = re(rt, pe, 28), ot = re(pe, rt, 2), st = re(pe, rt, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function Nt(rt, pe) {
    var nt = K(rt, pe, 14), ot = K(rt, pe, 18), st = K(pe, rt, 9), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function $t(rt, pe) {
    var nt = re(rt, pe, 14), ot = re(rt, pe, 18), st = re(pe, rt, 9), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function mt(rt, pe) {
    var nt = K(rt, pe, 1), ot = K(rt, pe, 8), st = W(rt, pe, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function xt(rt, pe) {
    var nt = re(rt, pe, 1), ot = re(rt, pe, 8), st = J(rt, pe, 7), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function wt(rt, pe) {
    var nt = K(rt, pe, 19), ot = K(pe, rt, 29), st = W(rt, pe, 6), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  function Oe(rt, pe) {
    var nt = re(rt, pe, 19), ot = re(pe, rt, 29), st = J(rt, pe, 6), ut = nt ^ ot ^ st;
    return ut < 0 && (ut += 4294967296), ut;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var A = requireUtils(), B = require_512();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return A.inherits(L, B), _384 = L, L.blockSize = 1024, L.outSize = 384, L.hmacStrength = 192, L.padLength = 128, L.prototype._digest = function(re) {
    return re === "hex" ? A.toHex32(this.h.slice(0, 12), "big") : A.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var A = requireUtils(), B = requireCommon$1(), L = A.rotl32, K = A.sum32, re = A.sum32_3, W = A.sum32_4, J = B.BlockHash;
  function ne() {
    if (!(this instanceof ne))
      return new ne();
    J.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  A.inherits(ne, J), ripemd.ripemd160 = ne, ne.blockSize = 512, ne.outSize = 160, ne.hmacStrength = 192, ne.padLength = 64, ne.prototype._update = function(lt, ht) {
    for (var dt = this.h[0], bt = this.h[1], vt = this.h[2], Bt = this.h[3], At = this.h[4], Nt = dt, $t = bt, mt = vt, xt = Bt, wt = At, Oe = 0; Oe < 80; Oe++) {
      var rt = K(
        L(
          W(dt, ie(Oe, bt, vt, Bt), lt[ce[Oe] + ht], oe(Oe)),
          Ce[Oe]
        ),
        At
      );
      dt = At, At = Bt, Bt = L(vt, 10), vt = bt, bt = rt, rt = K(
        L(
          W(Nt, ie(79 - Oe, $t, mt, xt), lt[ke[Oe] + ht], V(Oe)),
          it[Oe]
        ),
        wt
      ), Nt = wt, wt = xt, xt = L(mt, 10), mt = $t, $t = rt;
    }
    rt = re(this.h[1], vt, xt), this.h[1] = re(this.h[2], Bt, wt), this.h[2] = re(this.h[3], At, Nt), this.h[3] = re(this.h[4], dt, $t), this.h[4] = re(this.h[0], bt, mt), this.h[0] = rt;
  }, ne.prototype._digest = function(lt) {
    return lt === "hex" ? A.toHex32(this.h, "little") : A.split32(this.h, "little");
  };
  function ie(at, lt, ht, dt) {
    return at <= 15 ? lt ^ ht ^ dt : at <= 31 ? lt & ht | ~lt & dt : at <= 47 ? (lt | ~ht) ^ dt : at <= 63 ? lt & dt | ht & ~dt : lt ^ (ht | ~dt);
  }
  function oe(at) {
    return at <= 15 ? 0 : at <= 31 ? 1518500249 : at <= 47 ? 1859775393 : at <= 63 ? 2400959708 : 2840853838;
  }
  function V(at) {
    return at <= 15 ? 1352829926 : at <= 31 ? 1548603684 : at <= 47 ? 1836072691 : at <= 63 ? 2053994217 : 0;
  }
  var ce = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ke = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Ce = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], it = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L(K, re, W) {
    if (!(this instanceof L))
      return new L(K, re, W);
    this.Hash = K, this.blockSize = K.blockSize / 8, this.outSize = K.outSize / 8, this.inner = null, this.outer = null, this._init(A.toArray(re, W));
  }
  return hmac = L, L.prototype._init = function(re) {
    re.length > this.blockSize && (re = new this.Hash().update(re).digest()), B(re.length <= this.blockSize);
    for (var W = re.length; W < this.blockSize; W++)
      re.push(0);
    for (W = 0; W < re.length; W++)
      re[W] ^= 54;
    for (this.inner = new this.Hash().update(re), W = 0; W < re.length; W++)
      re[W] ^= 106;
    this.outer = new this.Hash().update(re);
  }, L.prototype.update = function(re, W) {
    return this.inner.update(re, W), this;
  }, L.prototype.digest = function(re) {
    return this.outer.update(this.inner.digest()), this.outer.digest(re);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(A) {
    var B = A;
    B.utils = requireUtils(), B.common = requireCommon$1(), B.sha = requireSha(), B.ripemd = requireRipemd(), B.hmac = requireHmac(), B.sha1 = B.sha.sha1, B.sha256 = B.sha.sha256, B.sha224 = B.sha.sha224, B.sha384 = B.sha.sha384, B.sha512 = B.sha.sha512, B.ripemd160 = B.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(A) {
    var B = A, L = requireHash(), K = requireCurve(), re = requireUtils$1(), W = re.assert;
    function J(oe) {
      oe.type === "short" ? this.curve = new K.short(oe) : oe.type === "edwards" ? this.curve = new K.edwards(oe) : this.curve = new K.mont(oe), this.g = this.curve.g, this.n = this.curve.n, this.hash = oe.hash, W(this.g.validate(), "Invalid curve"), W(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    B.PresetCurve = J;
    function ne(oe, V) {
      Object.defineProperty(B, oe, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var ce = new J(V);
          return Object.defineProperty(B, oe, {
            configurable: !0,
            enumerable: !0,
            value: ce
          }), ce;
        }
      });
    }
    ne("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: L.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), ne("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: L.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), ne("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: L.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), ne("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: L.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), ne("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: L.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), ne("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), ne("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ie;
    try {
      ie = requireSecp256k1();
    } catch {
      ie = void 0;
    }
    ne("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: L.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ie
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var A = requireHash(), B = requireUtils$2(), L = requireMinimalisticAssert();
  function K(re) {
    if (!(this instanceof K))
      return new K(re);
    this.hash = re.hash, this.predResist = !!re.predResist, this.outLen = this.hash.outSize, this.minEntropy = re.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var W = B.toArray(re.entropy, re.entropyEnc || "hex"), J = B.toArray(re.nonce, re.nonceEnc || "hex"), ne = B.toArray(re.pers, re.persEnc || "hex");
    L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(W, J, ne);
  }
  return hmacDrbg = K, K.prototype._init = function(W, J, ne) {
    var ie = W.concat(J).concat(ne);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var oe = 0; oe < this.V.length; oe++)
      this.K[oe] = 0, this.V[oe] = 1;
    this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, K.prototype._hmac = function() {
    return new A.hmac(this.hash, this.K);
  }, K.prototype._update = function(W) {
    var J = this._hmac().update(this.V).update([0]);
    W && (J = J.update(W)), this.K = J.digest(), this.V = this._hmac().update(this.V).digest(), W && (this.K = this._hmac().update(this.V).update([1]).update(W).digest(), this.V = this._hmac().update(this.V).digest());
  }, K.prototype.reseed = function(W, J, ne, ie) {
    typeof J != "string" && (ie = ne, ne = J, J = null), W = B.toArray(W, J), ne = B.toArray(ne, ie), L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(W.concat(ne || [])), this._reseed = 1;
  }, K.prototype.generate = function(W, J, ne, ie) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof J != "string" && (ie = ne, ne = J, J = null), ne && (ne = B.toArray(ne, ie || "hex"), this._update(ne));
    for (var oe = []; oe.length < W; )
      this.V = this._hmac().update(this.V).digest(), oe = oe.concat(this.V);
    var V = oe.slice(0, W);
    return this._update(ne), this._reseed++, B.encode(V, J);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(re, W) {
    this.ec = re, this.priv = null, this.pub = null, W.priv && this._importPrivate(W.priv, W.privEnc), W.pub && this._importPublic(W.pub, W.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(W, J, ne) {
    return J instanceof K ? J : new K(W, {
      pub: J,
      pubEnc: ne
    });
  }, K.fromPrivate = function(W, J, ne) {
    return J instanceof K ? J : new K(W, {
      priv: J,
      privEnc: ne
    });
  }, K.prototype.validate = function() {
    var W = this.getPublic();
    return W.isInfinity() ? { result: !1, reason: "Invalid public key" } : W.validate() ? W.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(W, J) {
    return typeof W == "string" && (J = W, W = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), J ? this.pub.encode(J, W) : this.pub;
  }, K.prototype.getPrivate = function(W) {
    return W === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(W, J) {
    this.priv = new A(W, J || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(W, J) {
    if (W.x || W.y) {
      this.ec.curve.type === "mont" ? L(W.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && L(W.x && W.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(W.x, W.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(W, J);
  }, K.prototype.derive = function(W) {
    return W.validate() || L(W.validate(), "public point not validated"), W.mul(this.priv).getX();
  }, K.prototype.sign = function(W, J, ne) {
    return this.ec.sign(W, this, J, ne);
  }, K.prototype.verify = function(W, J) {
    return this.ec.verify(W, J, this);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(ie, oe) {
    if (ie instanceof K)
      return ie;
    this._importDER(ie, oe) || (L(ie.r && ie.s, "Signature without r or s"), this.r = new A(ie.r, 16), this.s = new A(ie.s, 16), ie.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ie.recoveryParam);
  }
  signature$1 = K;
  function re() {
    this.place = 0;
  }
  function W(ie, oe) {
    var V = ie[oe.place++];
    if (!(V & 128))
      return V;
    var ce = V & 15;
    if (ce === 0 || ce > 4 || ie[oe.place] === 0)
      return !1;
    for (var ke = 0, Ce = 0, it = oe.place; Ce < ce; Ce++, it++)
      ke <<= 8, ke |= ie[it], ke >>>= 0;
    return ke <= 127 ? !1 : (oe.place = it, ke);
  }
  function J(ie) {
    for (var oe = 0, V = ie.length - 1; !ie[oe] && !(ie[oe + 1] & 128) && oe < V; )
      oe++;
    return oe === 0 ? ie : ie.slice(oe);
  }
  K.prototype._importDER = function(oe, V) {
    oe = B.toArray(oe, V);
    var ce = new re();
    if (oe[ce.place++] !== 48)
      return !1;
    var ke = W(oe, ce);
    if (ke === !1 || ke + ce.place !== oe.length || oe[ce.place++] !== 2)
      return !1;
    var Ce = W(oe, ce);
    if (Ce === !1 || oe[ce.place] & 128)
      return !1;
    var it = oe.slice(ce.place, Ce + ce.place);
    if (ce.place += Ce, oe[ce.place++] !== 2)
      return !1;
    var at = W(oe, ce);
    if (at === !1 || oe.length !== at + ce.place || oe[ce.place] & 128)
      return !1;
    var lt = oe.slice(ce.place, at + ce.place);
    if (it[0] === 0)
      if (it[1] & 128)
        it = it.slice(1);
      else
        return !1;
    if (lt[0] === 0)
      if (lt[1] & 128)
        lt = lt.slice(1);
      else
        return !1;
    return this.r = new A(it), this.s = new A(lt), this.recoveryParam = null, !0;
  };
  function ne(ie, oe) {
    if (oe < 128) {
      ie.push(oe);
      return;
    }
    var V = 1 + (Math.log(oe) / Math.LN2 >>> 3);
    for (ie.push(V | 128); --V; )
      ie.push(oe >>> (V << 3) & 255);
    ie.push(oe);
  }
  return K.prototype.toDER = function(oe) {
    var V = this.r.toArray(), ce = this.s.toArray();
    for (V[0] & 128 && (V = [0].concat(V)), ce[0] & 128 && (ce = [0].concat(ce)), V = J(V), ce = J(ce); !ce[0] && !(ce[1] & 128); )
      ce = ce.slice(1);
    var ke = [2];
    ne(ke, V.length), ke = ke.concat(V), ke.push(2), ne(ke, ce.length);
    var Ce = ke.concat(ce), it = [48];
    return ne(it, Ce.length), it = it.concat(Ce), B.encode(it, oe);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var A = requireBn$1(), B = requireHmacDrbg(), L = requireUtils$1(), K = requireCurves(), re = requireBrorand(), W = L.assert, J = requireKey$1(), ne = requireSignature$1();
  function ie(oe) {
    if (!(this instanceof ie))
      return new ie(oe);
    typeof oe == "string" && (W(
      Object.prototype.hasOwnProperty.call(K, oe),
      "Unknown curve " + oe
    ), oe = K[oe]), oe instanceof K.PresetCurve && (oe = { curve: oe }), this.curve = oe.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = oe.curve.g, this.g.precompute(oe.curve.n.bitLength() + 1), this.hash = oe.hash || oe.curve.hash;
  }
  return ec = ie, ie.prototype.keyPair = function(V) {
    return new J(this, V);
  }, ie.prototype.keyFromPrivate = function(V, ce) {
    return J.fromPrivate(this, V, ce);
  }, ie.prototype.keyFromPublic = function(V, ce) {
    return J.fromPublic(this, V, ce);
  }, ie.prototype.genKeyPair = function(V) {
    V || (V = {});
    for (var ce = new B({
      hash: this.hash,
      pers: V.pers,
      persEnc: V.persEnc || "utf8",
      entropy: V.entropy || re(this.hash.hmacStrength),
      entropyEnc: V.entropy && V.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), ke = this.n.byteLength(), Ce = this.n.sub(new A(2)); ; ) {
      var it = new A(ce.generate(ke));
      if (!(it.cmp(Ce) > 0))
        return it.iaddn(1), this.keyFromPrivate(it);
    }
  }, ie.prototype._truncateToN = function(V, ce) {
    var ke = V.byteLength() * 8 - this.n.bitLength();
    return ke > 0 && (V = V.ushrn(ke)), !ce && V.cmp(this.n) >= 0 ? V.sub(this.n) : V;
  }, ie.prototype.sign = function(V, ce, ke, Ce) {
    typeof ke == "object" && (Ce = ke, ke = null), Ce || (Ce = {}), ce = this.keyFromPrivate(ce, ke), V = this._truncateToN(new A(V, 16));
    for (var it = this.n.byteLength(), at = ce.getPrivate().toArray("be", it), lt = V.toArray("be", it), ht = new B({
      hash: this.hash,
      entropy: at,
      nonce: lt,
      pers: Ce.pers,
      persEnc: Ce.persEnc || "utf8"
    }), dt = this.n.sub(new A(1)), bt = 0; ; bt++) {
      var vt = Ce.k ? Ce.k(bt) : new A(ht.generate(this.n.byteLength()));
      if (vt = this._truncateToN(vt, !0), !(vt.cmpn(1) <= 0 || vt.cmp(dt) >= 0)) {
        var Bt = this.g.mul(vt);
        if (!Bt.isInfinity()) {
          var At = Bt.getX(), Nt = At.umod(this.n);
          if (Nt.cmpn(0) !== 0) {
            var $t = vt.invm(this.n).mul(Nt.mul(ce.getPrivate()).iadd(V));
            if ($t = $t.umod(this.n), $t.cmpn(0) !== 0) {
              var mt = (Bt.getY().isOdd() ? 1 : 0) | (At.cmp(Nt) !== 0 ? 2 : 0);
              return Ce.canonical && $t.cmp(this.nh) > 0 && ($t = this.n.sub($t), mt ^= 1), new ne({ r: Nt, s: $t, recoveryParam: mt });
            }
          }
        }
      }
    }
  }, ie.prototype.verify = function(V, ce, ke, Ce) {
    V = this._truncateToN(new A(V, 16)), ke = this.keyFromPublic(ke, Ce), ce = new ne(ce, "hex");
    var it = ce.r, at = ce.s;
    if (it.cmpn(1) < 0 || it.cmp(this.n) >= 0 || at.cmpn(1) < 0 || at.cmp(this.n) >= 0)
      return !1;
    var lt = at.invm(this.n), ht = lt.mul(V).umod(this.n), dt = lt.mul(it).umod(this.n), bt;
    return this.curve._maxwellTrick ? (bt = this.g.jmulAdd(ht, ke.getPublic(), dt), bt.isInfinity() ? !1 : bt.eqXToP(it)) : (bt = this.g.mulAdd(ht, ke.getPublic(), dt), bt.isInfinity() ? !1 : bt.getX().umod(this.n).cmp(it) === 0);
  }, ie.prototype.recoverPubKey = function(oe, V, ce, ke) {
    W((3 & ce) === ce, "The recovery param is more than two bits"), V = new ne(V, ke);
    var Ce = this.n, it = new A(oe), at = V.r, lt = V.s, ht = ce & 1, dt = ce >> 1;
    if (at.cmp(this.curve.p.umod(this.curve.n)) >= 0 && dt)
      throw new Error("Unable to find sencond key candinate");
    dt ? at = this.curve.pointFromX(at.add(this.curve.n), ht) : at = this.curve.pointFromX(at, ht);
    var bt = V.r.invm(Ce), vt = Ce.sub(it).mul(bt).umod(Ce), Bt = lt.mul(bt).umod(Ce);
    return this.g.mulAdd(vt, at, Bt);
  }, ie.prototype.getKeyRecoveryParam = function(oe, V, ce, ke) {
    if (V = new ne(V, ke), V.recoveryParam !== null)
      return V.recoveryParam;
    for (var Ce = 0; Ce < 4; Ce++) {
      var it;
      try {
        it = this.recoverPubKey(oe, V, Ce);
      } catch {
        continue;
      }
      if (it.eq(ce))
        return Ce;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var A = requireUtils$1(), B = A.assert, L = A.parseBytes, K = A.cachedProperty;
  function re(W, J) {
    this.eddsa = W, this._secret = L(J.secret), W.isPoint(J.pub) ? this._pub = J.pub : this._pubBytes = L(J.pub);
  }
  return re.fromPublic = function(J, ne) {
    return ne instanceof re ? ne : new re(J, { pub: ne });
  }, re.fromSecret = function(J, ne) {
    return ne instanceof re ? ne : new re(J, { secret: ne });
  }, re.prototype.secret = function() {
    return this._secret;
  }, K(re, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), K(re, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), K(re, "privBytes", function() {
    var J = this.eddsa, ne = this.hash(), ie = J.encodingLength - 1, oe = ne.slice(0, J.encodingLength);
    return oe[0] &= 248, oe[ie] &= 127, oe[ie] |= 64, oe;
  }), K(re, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), K(re, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), K(re, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), re.prototype.sign = function(J) {
    return B(this._secret, "KeyPair can only verify"), this.eddsa.sign(J, this);
  }, re.prototype.verify = function(J, ne) {
    return this.eddsa.verify(J, ne, this);
  }, re.prototype.getSecret = function(J) {
    return B(this._secret, "KeyPair is public only"), A.encode(this.secret(), J);
  }, re.prototype.getPublic = function(J) {
    return A.encode(this.pubBytes(), J);
  }, key = re, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert, K = B.cachedProperty, re = B.parseBytes;
  function W(J, ne) {
    this.eddsa = J, typeof ne != "object" && (ne = re(ne)), Array.isArray(ne) && (L(ne.length === J.encodingLength * 2, "Signature has invalid size"), ne = {
      R: ne.slice(0, J.encodingLength),
      S: ne.slice(J.encodingLength)
    }), L(ne.R && ne.S, "Signature without R or S"), J.isPoint(ne.R) && (this._R = ne.R), ne.S instanceof A && (this._S = ne.S), this._Rencoded = Array.isArray(ne.R) ? ne.R : ne.Rencoded, this._Sencoded = Array.isArray(ne.S) ? ne.S : ne.Sencoded;
  }
  return K(W, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), K(W, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), K(W, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), K(W, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), W.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, W.prototype.toHex = function() {
    return B.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = W, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var A = requireHash(), B = requireCurves(), L = requireUtils$1(), K = L.assert, re = L.parseBytes, W = requireKey(), J = requireSignature();
  function ne(ie) {
    if (K(ie === "ed25519", "only tested with ed25519 so far"), !(this instanceof ne))
      return new ne(ie);
    ie = B[ie].curve, this.curve = ie, this.g = ie.g, this.g.precompute(ie.n.bitLength() + 1), this.pointClass = ie.point().constructor, this.encodingLength = Math.ceil(ie.n.bitLength() / 8), this.hash = A.sha512;
  }
  return eddsa = ne, ne.prototype.sign = function(oe, V) {
    oe = re(oe);
    var ce = this.keyFromSecret(V), ke = this.hashInt(ce.messagePrefix(), oe), Ce = this.g.mul(ke), it = this.encodePoint(Ce), at = this.hashInt(it, ce.pubBytes(), oe).mul(ce.priv()), lt = ke.add(at).umod(this.curve.n);
    return this.makeSignature({ R: Ce, S: lt, Rencoded: it });
  }, ne.prototype.verify = function(oe, V, ce) {
    if (oe = re(oe), V = this.makeSignature(V), V.S().gte(V.eddsa.curve.n) || V.S().isNeg())
      return !1;
    var ke = this.keyFromPublic(ce), Ce = this.hashInt(V.Rencoded(), ke.pubBytes(), oe), it = this.g.mul(V.S()), at = V.R().add(ke.pub().mul(Ce));
    return at.eq(it);
  }, ne.prototype.hashInt = function() {
    for (var oe = this.hash(), V = 0; V < arguments.length; V++)
      oe.update(arguments[V]);
    return L.intFromLE(oe.digest()).umod(this.curve.n);
  }, ne.prototype.keyFromPublic = function(oe) {
    return W.fromPublic(this, oe);
  }, ne.prototype.keyFromSecret = function(oe) {
    return W.fromSecret(this, oe);
  }, ne.prototype.makeSignature = function(oe) {
    return oe instanceof J ? oe : new J(this, oe);
  }, ne.prototype.encodePoint = function(oe) {
    var V = oe.getY().toArray("le", this.encodingLength);
    return V[this.encodingLength - 1] |= oe.getX().isOdd() ? 128 : 0, V;
  }, ne.prototype.decodePoint = function(oe) {
    oe = L.parseBytes(oe);
    var V = oe.length - 1, ce = oe.slice(0, V).concat(oe[V] & -129), ke = (oe[V] & 128) !== 0, Ce = L.intFromLE(ce);
    return this.curve.pointFromY(Ce, ke);
  }, ne.prototype.encodeInt = function(oe) {
    return oe.toArray("le", this.encodingLength);
  }, ne.prototype.decodeInt = function(oe) {
    return L.intFromLE(oe);
  }, ne.prototype.isPoint = function(oe) {
    return oe instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(A) {
    var B = A;
    B.version = require$$0.version, B.utils = requireUtils$1(), B.rand = requireBrorand(), B.curve = requireCurve(), B.curves = requireCurves(), B.ec = requireEc(), B.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(A, B) {
      if (A.indexOf) return A.indexOf(B);
      for (var L = 0; L < A.length; L++)
        if (A[L] === B) return L;
      return -1;
    }, Object_keys = function(A) {
      if (Object.keys) return Object.keys(A);
      var B = [];
      for (var L in A) B.push(L);
      return B;
    }, forEach = function(A, B) {
      if (A.forEach) return A.forEach(B);
      for (var L = 0; L < A.length; L++)
        B(A[L], L, A);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(A, B, L) {
          Object.defineProperty(A, B, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: L
          });
        };
      } catch {
        return function(B, L, K) {
          B[L] = K;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(A) {
      if (!(A instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var B = document.createElement("iframe");
      B.style || (B.style = {}), B.style.display = "none", document.body.appendChild(B);
      var L = B.contentWindow, K = L.eval, re = L.execScript;
      !K && re && (re.call(L, "null"), K = L.eval), forEach(Object_keys(A), function(ne) {
        L[ne] = A[ne];
      }), forEach(globals, function(ne) {
        A[ne] && (L[ne] = A[ne]);
      });
      var W = Object_keys(L), J = K.call(L, this.code);
      return forEach(Object_keys(L), function(ne) {
        (ne in A || indexOf(W, ne) === -1) && (A[ne] = L[ne]);
      }), forEach(globals, function(ne) {
        ne in A || defineProp(A, ne, L[ne]);
      }), document.body.removeChild(B), J;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(A) {
      var B = Script.createContext(A), L = this.runInContext(B);
      return A && forEach(Object_keys(B), function(K) {
        A[K] = B[K];
      }), L;
    }, forEach(Object_keys(Script.prototype), function(A) {
      exports[A] = Script[A] = function(B) {
        var L = Script(B);
        return L[A].apply(L, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(A) {
      return A instanceof Context;
    }, exports.createScript = function(A) {
      return exports.Script(A);
    }, exports.createContext = Script.createContext = function(A) {
      var B = new Context();
      return typeof A == "object" && forEach(Object_keys(A), function(L) {
        B[L] = A[L];
      }), B;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(A) {
    var B = requireAsn1$1(), L = requireInherits_browser(), K = A;
    K.define = function(J, ne) {
      return new re(J, ne);
    };
    function re(W, J) {
      this.name = W, this.body = J, this.decoders = {}, this.encoders = {};
    }
    re.prototype._createNamed = function(J) {
      var ne;
      try {
        ne = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ne = function(oe) {
          this._initNamed(oe);
        };
      }
      return L(ne, J), ne.prototype._initNamed = function(oe) {
        J.call(this, oe);
      }, new ne(this);
    }, re.prototype._getDecoder = function(J) {
      return J = J || "der", this.decoders.hasOwnProperty(J) || (this.decoders[J] = this._createNamed(B.decoders[J])), this.decoders[J];
    }, re.prototype.decode = function(J, ne, ie) {
      return this._getDecoder(ne).decode(J, ie);
    }, re.prototype._getEncoder = function(J) {
      return J = J || "der", this.encoders.hasOwnProperty(J) || (this.encoders[J] = this._createNamed(B.encoders[J])), this.encoders[J];
    }, re.prototype.encode = function(J, ne, ie) {
      return this._getEncoder(ne).encode(J, ie);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var A = requireInherits_browser();
  function B(K) {
    this._reporterState = {
      obj: null,
      path: [],
      options: K || {},
      errors: []
    };
  }
  reporter.Reporter = B, B.prototype.isError = function(re) {
    return re instanceof L;
  }, B.prototype.save = function() {
    var re = this._reporterState;
    return { obj: re.obj, pathLen: re.path.length };
  }, B.prototype.restore = function(re) {
    var W = this._reporterState;
    W.obj = re.obj, W.path = W.path.slice(0, re.pathLen);
  }, B.prototype.enterKey = function(re) {
    return this._reporterState.path.push(re);
  }, B.prototype.exitKey = function(re) {
    var W = this._reporterState;
    W.path = W.path.slice(0, re - 1);
  }, B.prototype.leaveKey = function(re, W, J) {
    var ne = this._reporterState;
    this.exitKey(re), ne.obj !== null && (ne.obj[W] = J);
  }, B.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, B.prototype.enterObject = function() {
    var re = this._reporterState, W = re.obj;
    return re.obj = {}, W;
  }, B.prototype.leaveObject = function(re) {
    var W = this._reporterState, J = W.obj;
    return W.obj = re, J;
  }, B.prototype.error = function(re) {
    var W, J = this._reporterState, ne = re instanceof L;
    if (ne ? W = re : W = new L(J.path.map(function(ie) {
      return "[" + JSON.stringify(ie) + "]";
    }).join(""), re.message || re, re.stack), !J.options.partial)
      throw W;
    return ne || J.errors.push(W), W;
  }, B.prototype.wrapResult = function(re) {
    var W = this._reporterState;
    return W.options.partial ? {
      result: this.isError(re) ? null : re,
      errors: W.errors
    } : re;
  };
  function L(K, re) {
    this.path = K, this.rethrow(re);
  }
  return A(L, Error), L.prototype.rethrow = function(re) {
    if (this.message = re + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, L), !this.stack)
      try {
        throw new Error(this.message);
      } catch (W) {
        this.stack = W.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var A = requireInherits_browser(), B = requireBase().Reporter, L = require$$0$1.Buffer;
  function K(W, J) {
    if (B.call(this, J), !L.isBuffer(W)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = W, this.offset = 0, this.length = W.length;
  }
  A(K, B), buffer.DecoderBuffer = K, K.prototype.save = function() {
    return { offset: this.offset, reporter: B.prototype.save.call(this) };
  }, K.prototype.restore = function(J) {
    var ne = new K(this.base);
    return ne.offset = J.offset, ne.length = this.offset, this.offset = J.offset, B.prototype.restore.call(this, J.reporter), ne;
  }, K.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, K.prototype.readUInt8 = function(J) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(J || "DecoderBuffer overrun");
  }, K.prototype.skip = function(J, ne) {
    if (!(this.offset + J <= this.length))
      return this.error(ne || "DecoderBuffer overrun");
    var ie = new K(this.base);
    return ie._reporterState = this._reporterState, ie.offset = this.offset, ie.length = this.offset + J, this.offset += J, ie;
  }, K.prototype.raw = function(J) {
    return this.base.slice(J ? J.offset : this.offset, this.length);
  };
  function re(W, J) {
    if (Array.isArray(W))
      this.length = 0, this.value = W.map(function(ne) {
        return ne instanceof re || (ne = new re(ne, J)), this.length += ne.length, ne;
      }, this);
    else if (typeof W == "number") {
      if (!(0 <= W && W <= 255))
        return J.error("non-byte EncoderBuffer value");
      this.value = W, this.length = 1;
    } else if (typeof W == "string")
      this.value = W, this.length = L.byteLength(W);
    else if (L.isBuffer(W))
      this.value = W, this.length = W.length;
    else
      return J.error("Unsupported type: " + typeof W);
  }
  return buffer.EncoderBuffer = re, re.prototype.join = function(J, ne) {
    return J || (J = new L(this.length)), ne || (ne = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ie) {
      ie.join(J, ne), ne += ie.length;
    }) : (typeof this.value == "number" ? J[ne] = this.value : typeof this.value == "string" ? J.write(this.value, ne) : L.isBuffer(this.value) && this.value.copy(J, ne), ne += this.length)), J;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var A = requireBase().Reporter, B = requireBase().EncoderBuffer, L = requireBase().DecoderBuffer, K = requireMinimalisticAssert(), re = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], W = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(re), J = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ne(oe, V) {
    var ce = {};
    this._baseState = ce, ce.enc = oe, ce.parent = V || null, ce.children = null, ce.tag = null, ce.args = null, ce.reverseArgs = null, ce.choice = null, ce.optional = !1, ce.any = !1, ce.obj = !1, ce.use = null, ce.useDecoder = null, ce.key = null, ce.default = null, ce.explicit = null, ce.implicit = null, ce.contains = null, ce.parent || (ce.children = [], this._wrap());
  }
  node = ne;
  var ie = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ne.prototype.clone = function() {
    var V = this._baseState, ce = {};
    ie.forEach(function(Ce) {
      ce[Ce] = V[Ce];
    });
    var ke = new this.constructor(ce.parent);
    return ke._baseState = ce, ke;
  }, ne.prototype._wrap = function() {
    var V = this._baseState;
    W.forEach(function(ce) {
      this[ce] = function() {
        var Ce = new this.constructor(this);
        return V.children.push(Ce), Ce[ce].apply(Ce, arguments);
      };
    }, this);
  }, ne.prototype._init = function(V) {
    var ce = this._baseState;
    K(ce.parent === null), V.call(this), ce.children = ce.children.filter(function(ke) {
      return ke._baseState.parent === this;
    }, this), K.equal(ce.children.length, 1, "Root node can have only one child");
  }, ne.prototype._useArgs = function(V) {
    var ce = this._baseState, ke = V.filter(function(Ce) {
      return Ce instanceof this.constructor;
    }, this);
    V = V.filter(function(Ce) {
      return !(Ce instanceof this.constructor);
    }, this), ke.length !== 0 && (K(ce.children === null), ce.children = ke, ke.forEach(function(Ce) {
      Ce._baseState.parent = this;
    }, this)), V.length !== 0 && (K(ce.args === null), ce.args = V, ce.reverseArgs = V.map(function(Ce) {
      if (typeof Ce != "object" || Ce.constructor !== Object)
        return Ce;
      var it = {};
      return Object.keys(Ce).forEach(function(at) {
        at == (at | 0) && (at |= 0);
        var lt = Ce[at];
        it[lt] = at;
      }), it;
    }));
  }, J.forEach(function(oe) {
    ne.prototype[oe] = function() {
      var ce = this._baseState;
      throw new Error(oe + " not implemented for encoding: " + ce.enc);
    };
  }), re.forEach(function(oe) {
    ne.prototype[oe] = function() {
      var ce = this._baseState, ke = Array.prototype.slice.call(arguments);
      return K(ce.tag === null), ce.tag = oe, this._useArgs(ke), this;
    };
  }), ne.prototype.use = function(V) {
    K(V);
    var ce = this._baseState;
    return K(ce.use === null), ce.use = V, this;
  }, ne.prototype.optional = function() {
    var V = this._baseState;
    return V.optional = !0, this;
  }, ne.prototype.def = function(V) {
    var ce = this._baseState;
    return K(ce.default === null), ce.default = V, ce.optional = !0, this;
  }, ne.prototype.explicit = function(V) {
    var ce = this._baseState;
    return K(ce.explicit === null && ce.implicit === null), ce.explicit = V, this;
  }, ne.prototype.implicit = function(V) {
    var ce = this._baseState;
    return K(ce.explicit === null && ce.implicit === null), ce.implicit = V, this;
  }, ne.prototype.obj = function() {
    var V = this._baseState, ce = Array.prototype.slice.call(arguments);
    return V.obj = !0, ce.length !== 0 && this._useArgs(ce), this;
  }, ne.prototype.key = function(V) {
    var ce = this._baseState;
    return K(ce.key === null), ce.key = V, this;
  }, ne.prototype.any = function() {
    var V = this._baseState;
    return V.any = !0, this;
  }, ne.prototype.choice = function(V) {
    var ce = this._baseState;
    return K(ce.choice === null), ce.choice = V, this._useArgs(Object.keys(V).map(function(ke) {
      return V[ke];
    })), this;
  }, ne.prototype.contains = function(V) {
    var ce = this._baseState;
    return K(ce.use === null), ce.contains = V, this;
  }, ne.prototype._decode = function(V, ce) {
    var ke = this._baseState;
    if (ke.parent === null)
      return V.wrapResult(ke.children[0]._decode(V, ce));
    var Ce = ke.default, it = !0, at = null;
    if (ke.key !== null && (at = V.enterKey(ke.key)), ke.optional) {
      var lt = null;
      if (ke.explicit !== null ? lt = ke.explicit : ke.implicit !== null ? lt = ke.implicit : ke.tag !== null && (lt = ke.tag), lt === null && !ke.any) {
        var ht = V.save();
        try {
          ke.choice === null ? this._decodeGeneric(ke.tag, V, ce) : this._decodeChoice(V, ce), it = !0;
        } catch {
          it = !1;
        }
        V.restore(ht);
      } else if (it = this._peekTag(V, lt, ke.any), V.isError(it))
        return it;
    }
    var dt;
    if (ke.obj && it && (dt = V.enterObject()), it) {
      if (ke.explicit !== null) {
        var bt = this._decodeTag(V, ke.explicit);
        if (V.isError(bt))
          return bt;
        V = bt;
      }
      var vt = V.offset;
      if (ke.use === null && ke.choice === null) {
        if (ke.any)
          var ht = V.save();
        var Bt = this._decodeTag(
          V,
          ke.implicit !== null ? ke.implicit : ke.tag,
          ke.any
        );
        if (V.isError(Bt))
          return Bt;
        ke.any ? Ce = V.raw(ht) : V = Bt;
      }
      if (ce && ce.track && ke.tag !== null && ce.track(V.path(), vt, V.length, "tagged"), ce && ce.track && ke.tag !== null && ce.track(V.path(), V.offset, V.length, "content"), ke.any ? Ce = Ce : ke.choice === null ? Ce = this._decodeGeneric(ke.tag, V, ce) : Ce = this._decodeChoice(V, ce), V.isError(Ce))
        return Ce;
      if (!ke.any && ke.choice === null && ke.children !== null && ke.children.forEach(function($t) {
        $t._decode(V, ce);
      }), ke.contains && (ke.tag === "octstr" || ke.tag === "bitstr")) {
        var At = new L(Ce);
        Ce = this._getUse(ke.contains, V._reporterState.obj)._decode(At, ce);
      }
    }
    return ke.obj && it && (Ce = V.leaveObject(dt)), ke.key !== null && (Ce !== null || it === !0) ? V.leaveKey(at, ke.key, Ce) : at !== null && V.exitKey(at), Ce;
  }, ne.prototype._decodeGeneric = function(V, ce, ke) {
    var Ce = this._baseState;
    return V === "seq" || V === "set" ? null : V === "seqof" || V === "setof" ? this._decodeList(ce, V, Ce.args[0], ke) : /str$/.test(V) ? this._decodeStr(ce, V, ke) : V === "objid" && Ce.args ? this._decodeObjid(ce, Ce.args[0], Ce.args[1], ke) : V === "objid" ? this._decodeObjid(ce, null, null, ke) : V === "gentime" || V === "utctime" ? this._decodeTime(ce, V, ke) : V === "null_" ? this._decodeNull(ce, ke) : V === "bool" ? this._decodeBool(ce, ke) : V === "objDesc" ? this._decodeStr(ce, V, ke) : V === "int" || V === "enum" ? this._decodeInt(ce, Ce.args && Ce.args[0], ke) : Ce.use !== null ? this._getUse(Ce.use, ce._reporterState.obj)._decode(ce, ke) : ce.error("unknown tag: " + V);
  }, ne.prototype._getUse = function(V, ce) {
    var ke = this._baseState;
    return ke.useDecoder = this._use(V, ce), K(ke.useDecoder._baseState.parent === null), ke.useDecoder = ke.useDecoder._baseState.children[0], ke.implicit !== ke.useDecoder._baseState.implicit && (ke.useDecoder = ke.useDecoder.clone(), ke.useDecoder._baseState.implicit = ke.implicit), ke.useDecoder;
  }, ne.prototype._decodeChoice = function(V, ce) {
    var ke = this._baseState, Ce = null, it = !1;
    return Object.keys(ke.choice).some(function(at) {
      var lt = V.save(), ht = ke.choice[at];
      try {
        var dt = ht._decode(V, ce);
        if (V.isError(dt))
          return !1;
        Ce = { type: at, value: dt }, it = !0;
      } catch {
        return V.restore(lt), !1;
      }
      return !0;
    }, this), it ? Ce : V.error("Choice not matched");
  }, ne.prototype._createEncoderBuffer = function(V) {
    return new B(V, this.reporter);
  }, ne.prototype._encode = function(V, ce, ke) {
    var Ce = this._baseState;
    if (!(Ce.default !== null && Ce.default === V)) {
      var it = this._encodeValue(V, ce, ke);
      if (it !== void 0 && !this._skipDefault(it, ce, ke))
        return it;
    }
  }, ne.prototype._encodeValue = function(V, ce, ke) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return Ce.children[0]._encode(V, ce || new A());
    var ht = null;
    if (this.reporter = ce, Ce.optional && V === void 0)
      if (Ce.default !== null)
        V = Ce.default;
      else
        return;
    var it = null, at = !1;
    if (Ce.any)
      ht = this._createEncoderBuffer(V);
    else if (Ce.choice)
      ht = this._encodeChoice(V, ce);
    else if (Ce.contains)
      it = this._getUse(Ce.contains, ke)._encode(V, ce), at = !0;
    else if (Ce.children)
      it = Ce.children.map(function(vt) {
        if (vt._baseState.tag === "null_")
          return vt._encode(null, ce, V);
        if (vt._baseState.key === null)
          return ce.error("Child should have a key");
        var Bt = ce.enterKey(vt._baseState.key);
        if (typeof V != "object")
          return ce.error("Child expected, but input is not object");
        var At = vt._encode(V[vt._baseState.key], ce, V);
        return ce.leaveKey(Bt), At;
      }, this).filter(function(vt) {
        return vt;
      }), it = this._createEncoderBuffer(it);
    else if (Ce.tag === "seqof" || Ce.tag === "setof") {
      if (!(Ce.args && Ce.args.length === 1))
        return ce.error("Too many args for : " + Ce.tag);
      if (!Array.isArray(V))
        return ce.error("seqof/setof, but data is not Array");
      var lt = this.clone();
      lt._baseState.implicit = null, it = this._createEncoderBuffer(V.map(function(vt) {
        var Bt = this._baseState;
        return this._getUse(Bt.args[0], V)._encode(vt, ce);
      }, lt));
    } else Ce.use !== null ? ht = this._getUse(Ce.use, ke)._encode(V, ce) : (it = this._encodePrimitive(Ce.tag, V), at = !0);
    var ht;
    if (!Ce.any && Ce.choice === null) {
      var dt = Ce.implicit !== null ? Ce.implicit : Ce.tag, bt = Ce.implicit === null ? "universal" : "context";
      dt === null ? Ce.use === null && ce.error("Tag could be omitted only for .use()") : Ce.use === null && (ht = this._encodeComposite(dt, at, bt, it));
    }
    return Ce.explicit !== null && (ht = this._encodeComposite(Ce.explicit, !1, "context", ht)), ht;
  }, ne.prototype._encodeChoice = function(V, ce) {
    var ke = this._baseState, Ce = ke.choice[V.type];
    return Ce || K(
      !1,
      V.type + " not found in " + JSON.stringify(Object.keys(ke.choice))
    ), Ce._encode(V.value, ce);
  }, ne.prototype._encodePrimitive = function(V, ce) {
    var ke = this._baseState;
    if (/str$/.test(V))
      return this._encodeStr(ce, V);
    if (V === "objid" && ke.args)
      return this._encodeObjid(ce, ke.reverseArgs[0], ke.args[1]);
    if (V === "objid")
      return this._encodeObjid(ce, null, null);
    if (V === "gentime" || V === "utctime")
      return this._encodeTime(ce, V);
    if (V === "null_")
      return this._encodeNull();
    if (V === "int" || V === "enum")
      return this._encodeInt(ce, ke.args && ke.reverseArgs[0]);
    if (V === "bool")
      return this._encodeBool(ce);
    if (V === "objDesc")
      return this._encodeStr(ce, V);
    throw new Error("Unsupported tag: " + V);
  }, ne.prototype._isNumstr = function(V) {
    return /^[0-9 ]*$/.test(V);
  }, ne.prototype._isPrintstr = function(V) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(V);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(A) {
    var B = A;
    B.Reporter = requireReporter().Reporter, B.DecoderBuffer = requireBuffer().DecoderBuffer, B.EncoderBuffer = requireBuffer().EncoderBuffer, B.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(A) {
    var B = requireConstants();
    A.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, A.tagClassByName = B._reverse(A.tagClass), A.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, A.tagByName = B._reverse(A.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(A) {
    var B = A;
    B._reverse = function(K) {
      var re = {};
      return Object.keys(K).forEach(function(W) {
        (W | 0) == W && (W = W | 0);
        var J = K[W];
        re[J] = W;
      }), re;
    }, B.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var A = requireInherits_browser(), B = requireAsn1$1(), L = B.base, K = B.bignum, re = B.constants.der;
  function W(oe) {
    this.enc = "der", this.name = oe.name, this.entity = oe, this.tree = new J(), this.tree._init(oe.body);
  }
  der_1$1 = W, W.prototype.decode = function(V, ce) {
    return V instanceof L.DecoderBuffer || (V = new L.DecoderBuffer(V, ce)), this.tree._decode(V, ce);
  };
  function J(oe) {
    L.Node.call(this, "der", oe);
  }
  A(J, L.Node), J.prototype._peekTag = function(V, ce, ke) {
    if (V.isEmpty())
      return !1;
    var Ce = V.save(), it = ne(V, 'Failed to peek tag: "' + ce + '"');
    return V.isError(it) ? it : (V.restore(Ce), it.tag === ce || it.tagStr === ce || it.tagStr + "of" === ce || ke);
  }, J.prototype._decodeTag = function(V, ce, ke) {
    var Ce = ne(
      V,
      'Failed to decode tag of "' + ce + '"'
    );
    if (V.isError(Ce))
      return Ce;
    var it = ie(
      V,
      Ce.primitive,
      'Failed to get length of "' + ce + '"'
    );
    if (V.isError(it))
      return it;
    if (!ke && Ce.tag !== ce && Ce.tagStr !== ce && Ce.tagStr + "of" !== ce)
      return V.error('Failed to match tag: "' + ce + '"');
    if (Ce.primitive || it !== null)
      return V.skip(it, 'Failed to match body of: "' + ce + '"');
    var at = V.save(), lt = this._skipUntilEnd(
      V,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return V.isError(lt) ? lt : (it = V.offset - at.offset, V.restore(at), V.skip(it, 'Failed to match body of: "' + ce + '"'));
  }, J.prototype._skipUntilEnd = function(V, ce) {
    for (; ; ) {
      var ke = ne(V, ce);
      if (V.isError(ke))
        return ke;
      var Ce = ie(V, ke.primitive, ce);
      if (V.isError(Ce))
        return Ce;
      var it;
      if (ke.primitive || Ce !== null ? it = V.skip(Ce) : it = this._skipUntilEnd(V, ce), V.isError(it))
        return it;
      if (ke.tagStr === "end")
        break;
    }
  }, J.prototype._decodeList = function(V, ce, ke, Ce) {
    for (var it = []; !V.isEmpty(); ) {
      var at = this._peekTag(V, "end");
      if (V.isError(at))
        return at;
      var lt = ke.decode(V, "der", Ce);
      if (V.isError(lt) && at)
        break;
      it.push(lt);
    }
    return it;
  }, J.prototype._decodeStr = function(V, ce) {
    if (ce === "bitstr") {
      var ke = V.readUInt8();
      return V.isError(ke) ? ke : { unused: ke, data: V.raw() };
    } else if (ce === "bmpstr") {
      var Ce = V.raw();
      if (Ce.length % 2 === 1)
        return V.error("Decoding of string type: bmpstr length mismatch");
      for (var it = "", at = 0; at < Ce.length / 2; at++)
        it += String.fromCharCode(Ce.readUInt16BE(at * 2));
      return it;
    } else if (ce === "numstr") {
      var lt = V.raw().toString("ascii");
      return this._isNumstr(lt) ? lt : V.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (ce === "octstr")
        return V.raw();
      if (ce === "objDesc")
        return V.raw();
      if (ce === "printstr") {
        var ht = V.raw().toString("ascii");
        return this._isPrintstr(ht) ? ht : V.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(ce) ? V.raw().toString() : V.error("Decoding of string type: " + ce + " unsupported");
    }
  }, J.prototype._decodeObjid = function(V, ce, ke) {
    for (var Ce, it = [], at = 0; !V.isEmpty(); ) {
      var lt = V.readUInt8();
      at <<= 7, at |= lt & 127, lt & 128 || (it.push(at), at = 0);
    }
    lt & 128 && it.push(at);
    var ht = it[0] / 40 | 0, dt = it[0] % 40;
    if (ke ? Ce = it : Ce = [ht, dt].concat(it.slice(1)), ce) {
      var bt = ce[Ce.join(" ")];
      bt === void 0 && (bt = ce[Ce.join(".")]), bt !== void 0 && (Ce = bt);
    }
    return Ce;
  }, J.prototype._decodeTime = function(V, ce) {
    var ke = V.raw().toString();
    if (ce === "gentime")
      var Ce = ke.slice(0, 4) | 0, it = ke.slice(4, 6) | 0, at = ke.slice(6, 8) | 0, lt = ke.slice(8, 10) | 0, ht = ke.slice(10, 12) | 0, dt = ke.slice(12, 14) | 0;
    else if (ce === "utctime") {
      var Ce = ke.slice(0, 2) | 0, it = ke.slice(2, 4) | 0, at = ke.slice(4, 6) | 0, lt = ke.slice(6, 8) | 0, ht = ke.slice(8, 10) | 0, dt = ke.slice(10, 12) | 0;
      Ce < 70 ? Ce = 2e3 + Ce : Ce = 1900 + Ce;
    } else
      return V.error("Decoding " + ce + " time is not supported yet");
    return Date.UTC(Ce, it - 1, at, lt, ht, dt, 0);
  }, J.prototype._decodeNull = function(V) {
    return null;
  }, J.prototype._decodeBool = function(V) {
    var ce = V.readUInt8();
    return V.isError(ce) ? ce : ce !== 0;
  }, J.prototype._decodeInt = function(V, ce) {
    var ke = V.raw(), Ce = new K(ke);
    return ce && (Ce = ce[Ce.toString(10)] || Ce), Ce;
  }, J.prototype._use = function(V, ce) {
    return typeof V == "function" && (V = V(ce)), V._getDecoder("der").tree;
  };
  function ne(oe, V) {
    var ce = oe.readUInt8(V);
    if (oe.isError(ce))
      return ce;
    var ke = re.tagClass[ce >> 6], Ce = (ce & 32) === 0;
    if ((ce & 31) === 31) {
      var it = ce;
      for (ce = 0; (it & 128) === 128; ) {
        if (it = oe.readUInt8(V), oe.isError(it))
          return it;
        ce <<= 7, ce |= it & 127;
      }
    } else
      ce &= 31;
    var at = re.tag[ce];
    return {
      cls: ke,
      primitive: Ce,
      tag: ce,
      tagStr: at
    };
  }
  function ie(oe, V, ce) {
    var ke = oe.readUInt8(ce);
    if (oe.isError(ke))
      return ke;
    if (!V && ke === 128)
      return null;
    if (!(ke & 128))
      return ke;
    var Ce = ke & 127;
    if (Ce > 4)
      return oe.error("length octect is too long");
    ke = 0;
    for (var it = 0; it < Ce; it++) {
      ke <<= 8;
      var at = oe.readUInt8(ce);
      if (oe.isError(at))
        return at;
      ke |= at;
    }
    return ke;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, L = requireDer$1();
  function K(re) {
    L.call(this, re), this.enc = "pem";
  }
  return A(K, L), pem$1 = K, K.prototype.decode = function(W, J) {
    for (var ne = W.toString().split(/[\r\n]+/g), ie = J.label.toUpperCase(), oe = /^-----(BEGIN|END) ([^-]+)-----$/, V = -1, ce = -1, ke = 0; ke < ne.length; ke++) {
      var Ce = ne[ke].match(oe);
      if (Ce !== null && Ce[2] === ie)
        if (V === -1) {
          if (Ce[1] !== "BEGIN")
            break;
          V = ke;
        } else {
          if (Ce[1] !== "END")
            break;
          ce = ke;
          break;
        }
    }
    if (V === -1 || ce === -1)
      throw new Error("PEM section not found for: " + ie);
    var it = ne.slice(V + 1, ce).join("");
    it.replace(/[^a-z0-9\+\/=]+/gi, "");
    var at = new B(it, "base64");
    return L.prototype.decode.call(this, at, J);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(A) {
    var B = A;
    B.der = requireDer$1(), B.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, L = requireAsn1$1(), K = L.base, re = L.constants.der;
  function W(oe) {
    this.enc = "der", this.name = oe.name, this.entity = oe, this.tree = new J(), this.tree._init(oe.body);
  }
  der_1 = W, W.prototype.encode = function(V, ce) {
    return this.tree._encode(V, ce).join();
  };
  function J(oe) {
    K.Node.call(this, "der", oe);
  }
  A(J, K.Node), J.prototype._encodeComposite = function(V, ce, ke, Ce) {
    var it = ie(V, ce, ke, this.reporter);
    if (Ce.length < 128) {
      var ht = new B(2);
      return ht[0] = it, ht[1] = Ce.length, this._createEncoderBuffer([ht, Ce]);
    }
    for (var at = 1, lt = Ce.length; lt >= 256; lt >>= 8)
      at++;
    var ht = new B(2 + at);
    ht[0] = it, ht[1] = 128 | at;
    for (var lt = 1 + at, dt = Ce.length; dt > 0; lt--, dt >>= 8)
      ht[lt] = dt & 255;
    return this._createEncoderBuffer([ht, Ce]);
  }, J.prototype._encodeStr = function(V, ce) {
    if (ce === "bitstr")
      return this._createEncoderBuffer([V.unused | 0, V.data]);
    if (ce === "bmpstr") {
      for (var ke = new B(V.length * 2), Ce = 0; Ce < V.length; Ce++)
        ke.writeUInt16BE(V.charCodeAt(Ce), Ce * 2);
      return this._createEncoderBuffer(ke);
    } else return ce === "numstr" ? this._isNumstr(V) ? this._createEncoderBuffer(V) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : ce === "printstr" ? this._isPrintstr(V) ? this._createEncoderBuffer(V) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(ce) ? this._createEncoderBuffer(V) : ce === "objDesc" ? this._createEncoderBuffer(V) : this.reporter.error("Encoding of string type: " + ce + " unsupported");
  }, J.prototype._encodeObjid = function(V, ce, ke) {
    if (typeof V == "string") {
      if (!ce)
        return this.reporter.error("string objid given, but no values map found");
      if (!ce.hasOwnProperty(V))
        return this.reporter.error("objid not found in values map");
      V = ce[V].split(/[\s\.]+/g);
      for (var Ce = 0; Ce < V.length; Ce++)
        V[Ce] |= 0;
    } else if (Array.isArray(V)) {
      V = V.slice();
      for (var Ce = 0; Ce < V.length; Ce++)
        V[Ce] |= 0;
    }
    if (!Array.isArray(V))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(V));
    if (!ke) {
      if (V[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      V.splice(0, 2, V[0] * 40 + V[1]);
    }
    for (var it = 0, Ce = 0; Ce < V.length; Ce++) {
      var at = V[Ce];
      for (it++; at >= 128; at >>= 7)
        it++;
    }
    for (var lt = new B(it), ht = lt.length - 1, Ce = V.length - 1; Ce >= 0; Ce--) {
      var at = V[Ce];
      for (lt[ht--] = at & 127; (at >>= 7) > 0; )
        lt[ht--] = 128 | at & 127;
    }
    return this._createEncoderBuffer(lt);
  };
  function ne(oe) {
    return oe < 10 ? "0" + oe : oe;
  }
  J.prototype._encodeTime = function(V, ce) {
    var ke, Ce = new Date(V);
    return ce === "gentime" ? ke = [
      ne(Ce.getFullYear()),
      ne(Ce.getUTCMonth() + 1),
      ne(Ce.getUTCDate()),
      ne(Ce.getUTCHours()),
      ne(Ce.getUTCMinutes()),
      ne(Ce.getUTCSeconds()),
      "Z"
    ].join("") : ce === "utctime" ? ke = [
      ne(Ce.getFullYear() % 100),
      ne(Ce.getUTCMonth() + 1),
      ne(Ce.getUTCDate()),
      ne(Ce.getUTCHours()),
      ne(Ce.getUTCMinutes()),
      ne(Ce.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + ce + " time is not supported yet"), this._encodeStr(ke, "octstr");
  }, J.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, J.prototype._encodeInt = function(V, ce) {
    if (typeof V == "string") {
      if (!ce)
        return this.reporter.error("String int or enum given, but no values map");
      if (!ce.hasOwnProperty(V))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(V));
      V = ce[V];
    }
    if (typeof V != "number" && !B.isBuffer(V)) {
      var ke = V.toArray();
      !V.sign && ke[0] & 128 && ke.unshift(0), V = new B(ke);
    }
    if (B.isBuffer(V)) {
      var Ce = V.length;
      V.length === 0 && Ce++;
      var at = new B(Ce);
      return V.copy(at), V.length === 0 && (at[0] = 0), this._createEncoderBuffer(at);
    }
    if (V < 128)
      return this._createEncoderBuffer(V);
    if (V < 256)
      return this._createEncoderBuffer([0, V]);
    for (var Ce = 1, it = V; it >= 256; it >>= 8)
      Ce++;
    for (var at = new Array(Ce), it = at.length - 1; it >= 0; it--)
      at[it] = V & 255, V >>= 8;
    return at[0] & 128 && at.unshift(0), this._createEncoderBuffer(new B(at));
  }, J.prototype._encodeBool = function(V) {
    return this._createEncoderBuffer(V ? 255 : 0);
  }, J.prototype._use = function(V, ce) {
    return typeof V == "function" && (V = V(ce)), V._getEncoder("der").tree;
  }, J.prototype._skipDefault = function(V, ce, ke) {
    var Ce = this._baseState, it;
    if (Ce.default === null)
      return !1;
    var at = V.join();
    if (Ce.defaultBuffer === void 0 && (Ce.defaultBuffer = this._encodeValue(Ce.default, ce, ke).join()), at.length !== Ce.defaultBuffer.length)
      return !1;
    for (it = 0; it < at.length; it++)
      if (at[it] !== Ce.defaultBuffer[it])
        return !1;
    return !0;
  };
  function ie(oe, V, ce, ke) {
    var Ce;
    if (oe === "seqof" ? oe = "seq" : oe === "setof" && (oe = "set"), re.tagByName.hasOwnProperty(oe))
      Ce = re.tagByName[oe];
    else if (typeof oe == "number" && (oe | 0) === oe)
      Ce = oe;
    else
      return ke.error("Unknown tag: " + oe);
    return Ce >= 31 ? ke.error("Multi-octet tag encoding unsupported") : (V || (Ce |= 32), Ce |= re.tagClassByName[ce || "universal"] << 6, Ce);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var A = requireInherits_browser(), B = requireDer();
  function L(K) {
    B.call(this, K), this.enc = "pem";
  }
  return A(L, B), pem = L, L.prototype.encode = function(re, W) {
    for (var J = B.prototype.encode.call(this, re), ne = J.toString("base64"), ie = ["-----BEGIN " + W.label + "-----"], oe = 0; oe < ne.length; oe += 64)
      ie.push(ne.slice(oe, oe + 64));
    return ie.push("-----END " + W.label + "-----"), ie.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(A) {
    var B = A;
    B.der = requireDer(), B.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(A) {
    var B = A;
    B.bignum = requireBn$1(), B.define = requireApi().define, B.base = requireBase(), B.constants = requireConstants(), B.decoders = requireDecoders(), B.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var A = requireAsn1$1(), B = A.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), L = A.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), re = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  }), W = A.define("RelativeDistinguishedName", function() {
    this.setof(L);
  }), J = A.define("RDNSequence", function() {
    this.seqof(W);
  }), ne = A.define("Name", function() {
    this.choice({
      rdnSequence: this.use(J)
    });
  }), ie = A.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(B),
      this.key("notAfter").use(B)
    );
  }), oe = A.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), V = A.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(K),
      this.key("issuer").use(ne),
      this.key("validity").use(ie),
      this.key("subject").use(ne),
      this.key("subjectPublicKeyInfo").use(re),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(oe).optional()
    );
  }), ce = A.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(V),
      this.key("signatureAlgorithm").use(K),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = ce, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var A = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var B = A.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = B;
  var L = A.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = L;
  var K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), re = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = re;
  var W = A.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(K),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = W;
  var J = A.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = J;
  var ne = A.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = ne, asn1$1.DSAparam = A.define("DSAparam", function() {
    this.int();
  });
  var ie = A.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), oe = A.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ie),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = oe, asn1$1.signature = A.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var A = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, B = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, L = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K = requireEvp_bytestokey(), re = requireBrowser$6(), W = safeBufferExports.Buffer;
  return fixProc = function(J, ne) {
    var ie = J.toString(), oe = ie.match(A), V;
    if (oe) {
      var ke = "aes" + oe[1], Ce = W.from(oe[2], "hex"), it = W.from(oe[3].replace(/[\r\n]/g, ""), "base64"), at = K(ne, Ce.slice(0, 8), parseInt(oe[1], 10)).key, lt = [], ht = re.createDecipheriv(ke, at, Ce);
      lt.push(ht.update(it)), lt.push(ht.final()), V = W.concat(lt);
    } else {
      var ce = ie.match(L);
      V = W.from(ce[2].replace(/[\r\n]/g, ""), "base64");
    }
    var dt = ie.match(B)[1];
    return {
      tag: dt,
      data: V
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var A = requireAsn1(), B = require$$1, L = requireFixProc(), K = requireBrowser$6(), re = requireBrowser$7(), W = safeBufferExports.Buffer;
  function J(ie, oe) {
    var V = ie.algorithm.decrypt.kde.kdeparams.salt, ce = parseInt(ie.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ke = B[ie.algorithm.decrypt.cipher.algo.join(".")], Ce = ie.algorithm.decrypt.cipher.iv, it = ie.subjectPrivateKey, at = parseInt(ke.split("-")[1], 10) / 8, lt = re.pbkdf2Sync(oe, V, ce, at, "sha1"), ht = K.createDecipheriv(ke, lt, Ce), dt = [];
    return dt.push(ht.update(it)), dt.push(ht.final()), W.concat(dt);
  }
  function ne(ie) {
    var oe;
    typeof ie == "object" && !W.isBuffer(ie) && (oe = ie.passphrase, ie = ie.key), typeof ie == "string" && (ie = W.from(ie));
    var V = L(ie, oe), ce = V.tag, ke = V.data, Ce, it;
    switch (ce) {
      case "CERTIFICATE":
        it = A.certificate.decode(ke, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (it || (it = A.PublicKey.decode(ke, "der")), Ce = it.algorithm.algorithm.join("."), Ce) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPublicKey.decode(it.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return it.subjectPrivateKey = it.subjectPublicKey, {
              type: "ec",
              data: it
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.pub_key = A.DSAparam.decode(it.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ce);
        }
      case "ENCRYPTED PRIVATE KEY":
        ke = A.EncryptedPrivateKey.decode(ke, "der"), ke = J(ke, oe);
      case "PRIVATE KEY":
        switch (it = A.PrivateKey.decode(ke, "der"), Ce = it.algorithm.algorithm.join("."), Ce) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPrivateKey.decode(it.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: it.algorithm.curve,
              privateKey: A.ECPrivateKey.decode(it.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.priv_key = A.DSAparam.decode(it.subjectPrivateKey, "der"), {
              type: "dsa",
              params: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ce);
        }
      case "RSA PUBLIC KEY":
        return A.RSAPublicKey.decode(ke, "der");
      case "RSA PRIVATE KEY":
        return A.RSAPrivateKey.decode(ke, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: A.DSAPrivateKey.decode(ke, "der")
        };
      case "EC PRIVATE KEY":
        return ke = A.ECPrivateKey.decode(ke, "der"), {
          curve: ke.parameters.value,
          privateKey: ke.privateKey
        };
      default:
        throw new Error("unknown key type " + ce);
    }
  }
  return ne.signature = A.signature, parseAsn1 = ne, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$8(), L = requireBrowserifyRsa(), K = requireElliptic().ec, re = requireBn(), W = requireParseAsn1(), J = require$$4, ne = 1;
  function ie(ht, dt, bt, vt, Bt) {
    var At = W(dt);
    if (At.curve) {
      if (vt !== "ecdsa" && vt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return oe(ht, At);
    } else if (At.type === "dsa") {
      if (vt !== "dsa")
        throw new Error("wrong private key type");
      return V(ht, At, bt);
    }
    if (vt !== "rsa" && vt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (dt.padding !== void 0 && dt.padding !== ne)
      throw new Error("illegal or unsupported padding mode");
    ht = A.concat([Bt, ht]);
    for (var Nt = At.modulus.byteLength(), $t = [0, 1]; ht.length + $t.length + 1 < Nt; )
      $t.push(255);
    $t.push(0);
    for (var mt = -1; ++mt < ht.length; )
      $t.push(ht[mt]);
    var xt = L($t, At);
    return xt;
  }
  function oe(ht, dt) {
    var bt = J[dt.curve.join(".")];
    if (!bt)
      throw new Error("unknown curve " + dt.curve.join("."));
    var vt = new K(bt), Bt = vt.keyFromPrivate(dt.privateKey), At = Bt.sign(ht);
    return A.from(At.toDER());
  }
  function V(ht, dt, bt) {
    for (var vt = dt.params.priv_key, Bt = dt.params.p, At = dt.params.q, Nt = dt.params.g, $t = new re(0), mt, xt = Ce(ht, At).mod(At), wt = !1, Oe = ke(vt, At, ht, bt); wt === !1; )
      mt = at(At, Oe, bt), $t = lt(Nt, mt, Bt, At), wt = mt.invm(At).imul(xt.add(vt.mul($t))).mod(At), wt.cmpn(0) === 0 && (wt = !1, $t = new re(0));
    return ce($t, wt);
  }
  function ce(ht, dt) {
    ht = ht.toArray(), dt = dt.toArray(), ht[0] & 128 && (ht = [0].concat(ht)), dt[0] & 128 && (dt = [0].concat(dt));
    var bt = ht.length + dt.length + 4, vt = [
      48,
      bt,
      2,
      ht.length
    ];
    return vt = vt.concat(ht, [2, dt.length], dt), A.from(vt);
  }
  function ke(ht, dt, bt, vt) {
    if (ht = A.from(ht.toArray()), ht.length < dt.byteLength()) {
      var Bt = A.alloc(dt.byteLength() - ht.length);
      ht = A.concat([Bt, ht]);
    }
    var At = bt.length, Nt = it(bt, dt), $t = A.alloc(At);
    $t.fill(1);
    var mt = A.alloc(At);
    return mt = B(vt, mt).update($t).update(A.from([0])).update(ht).update(Nt).digest(), $t = B(vt, mt).update($t).digest(), mt = B(vt, mt).update($t).update(A.from([1])).update(ht).update(Nt).digest(), $t = B(vt, mt).update($t).digest(), { k: mt, v: $t };
  }
  function Ce(ht, dt) {
    var bt = new re(ht), vt = (ht.length << 3) - dt.bitLength();
    return vt > 0 && bt.ishrn(vt), bt;
  }
  function it(ht, dt) {
    ht = Ce(ht, dt), ht = ht.mod(dt);
    var bt = A.from(ht.toArray());
    if (bt.length < dt.byteLength()) {
      var vt = A.alloc(dt.byteLength() - bt.length);
      bt = A.concat([vt, bt]);
    }
    return bt;
  }
  function at(ht, dt, bt) {
    var vt, Bt;
    do {
      for (vt = A.alloc(0); vt.length * 8 < ht.bitLength(); )
        dt.v = B(bt, dt.k).update(dt.v).digest(), vt = A.concat([vt, dt.v]);
      Bt = Ce(vt, ht), dt.k = B(bt, dt.k).update(dt.v).update(A.from([0])).digest(), dt.v = B(bt, dt.k).update(dt.v).digest();
    } while (Bt.cmp(ht) !== -1);
    return Bt;
  }
  function lt(ht, dt, bt, vt) {
    return ht.toRed(re.mont(bt)).redPow(dt).fromRed().mod(vt);
  }
  return sign.exports = ie, sign.exports.getKey = ke, sign.exports.makeKey = at, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var A = safeBufferExports.Buffer, B = requireBn(), L = requireElliptic().ec, K = requireParseAsn1(), re = require$$4;
  function W(oe, V, ce, ke, Ce) {
    var it = K(ce);
    if (it.type === "ec") {
      if (ke !== "ecdsa" && ke !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return J(oe, V, it);
    } else if (it.type === "dsa") {
      if (ke !== "dsa")
        throw new Error("wrong public key type");
      return ne(oe, V, it);
    }
    if (ke !== "rsa" && ke !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    V = A.concat([Ce, V]);
    for (var at = it.modulus.byteLength(), lt = [1], ht = 0; V.length + lt.length + 2 < at; )
      lt.push(255), ht += 1;
    lt.push(0);
    for (var dt = -1; ++dt < V.length; )
      lt.push(V[dt]);
    lt = A.from(lt);
    var bt = B.mont(it.modulus);
    oe = new B(oe).toRed(bt), oe = oe.redPow(new B(it.publicExponent)), oe = A.from(oe.fromRed().toArray());
    var vt = ht < 8 ? 1 : 0;
    for (at = Math.min(oe.length, lt.length), oe.length !== lt.length && (vt = 1), dt = -1; ++dt < at; )
      vt |= oe[dt] ^ lt[dt];
    return vt === 0;
  }
  function J(oe, V, ce) {
    var ke = re[ce.data.algorithm.curve.join(".")];
    if (!ke)
      throw new Error("unknown curve " + ce.data.algorithm.curve.join("."));
    var Ce = new L(ke), it = ce.data.subjectPrivateKey.data;
    return Ce.verify(V, oe, it);
  }
  function ne(oe, V, ce) {
    var ke = ce.data.p, Ce = ce.data.q, it = ce.data.g, at = ce.data.pub_key, lt = K.signature.decode(oe, "der"), ht = lt.s, dt = lt.r;
    ie(ht, Ce), ie(dt, Ce);
    var bt = B.mont(ke), vt = ht.invm(Ce), Bt = it.toRed(bt).redPow(new B(V).mul(vt).mod(Ce)).fromRed().mul(at.toRed(bt).redPow(dt.mul(vt).mod(Ce)).fromRed()).mod(ke).mod(Ce);
    return Bt.cmp(dt) === 0;
  }
  function ie(oe, V) {
    if (oe.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (oe.cmp(V) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = W, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$9(), L = requireReadableBrowser(), K = requireInherits_browser(), re = requireSign(), W = requireVerify(), J = require$$6;
  Object.keys(J).forEach(function(ce) {
    J[ce].id = A.from(J[ce].id, "hex"), J[ce.toLowerCase()] = J[ce];
  });
  function ne(ce) {
    L.Writable.call(this);
    var ke = J[ce];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hashType = ke.hash, this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ne, L.Writable), ne.prototype._write = function(ke, Ce, it) {
    this._hash.update(ke), it();
  }, ne.prototype.update = function(ke, Ce) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Ce) : ke), this;
  }, ne.prototype.sign = function(ke, Ce) {
    this.end();
    var it = this._hash.digest(), at = re(it, ke, this._hashType, this._signType, this._tag);
    return Ce ? at.toString(Ce) : at;
  };
  function ie(ce) {
    L.Writable.call(this);
    var ke = J[ce];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ie, L.Writable), ie.prototype._write = function(ke, Ce, it) {
    this._hash.update(ke), it();
  }, ie.prototype.update = function(ke, Ce) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Ce) : ke), this;
  }, ie.prototype.verify = function(ke, Ce, it) {
    var at = typeof Ce == "string" ? A.from(Ce, it) : Ce;
    this.end();
    var lt = this._hash.digest();
    return W(at, lt, ke, this._signType, this._tag);
  };
  function oe(ce) {
    return new ne(ce);
  }
  function V(ce) {
    return new ie(ce);
  }
  return browser$3 = {
    Sign: oe,
    Verify: V,
    createSign: oe,
    createVerify: V
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var A = requireElliptic(), B = requireBn$1();
  browser$2 = function(J) {
    return new K(J);
  };
  var L = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  L.p224 = L.secp224r1, L.p256 = L.secp256r1 = L.prime256v1, L.p192 = L.secp192r1 = L.prime192v1, L.p384 = L.secp384r1, L.p521 = L.secp521r1;
  function K(W) {
    this.curveType = L[W], this.curveType || (this.curveType = {
      name: W
    }), this.curve = new A.ec(this.curveType.name), this.keys = void 0;
  }
  K.prototype.generateKeys = function(W, J) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(W, J);
  }, K.prototype.computeSecret = function(W, J, ne) {
    J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J));
    var ie = this.curve.keyFromPublic(W).getPublic(), oe = ie.mul(this.keys.getPrivate()).getX();
    return re(oe, ne, this.curveType.byteLength);
  }, K.prototype.getPublicKey = function(W, J) {
    var ne = this.keys.getPublic(J === "compressed", !0);
    return J === "hybrid" && (ne[ne.length - 1] % 2 ? ne[0] = 7 : ne[0] = 6), re(ne, W);
  }, K.prototype.getPrivateKey = function(W) {
    return re(this.keys.getPrivate(), W);
  }, K.prototype.setPublicKey = function(W, J) {
    return J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J)), this.keys._importPublic(W), this;
  }, K.prototype.setPrivateKey = function(W, J) {
    J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J));
    var ne = new B(W);
    return ne = ne.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ne), this;
  };
  function re(W, J, ne) {
    Array.isArray(W) || (W = W.toArray());
    var ie = new Buffer$1(W);
    if (ne && ie.length < ne) {
      var oe = new Buffer$1(ne - ie.length);
      oe.fill(0), ie = Buffer$1.concat([oe, ie]);
    }
    return J ? ie.toString(J) : ie;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var A = requireBrowser$9(), B = safeBufferExports.Buffer;
  mgf = function(K, re) {
    for (var W = B.alloc(0), J = 0, ne; W.length < re; )
      ne = L(J++), W = B.concat([W, A("sha1").update(K).update(ne).digest()]);
    return W.slice(0, re);
  };
  function L(K) {
    var re = B.allocUnsafe(4);
    return re.writeUInt32BE(K, 0), re;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(B, L) {
    for (var K = B.length, re = -1; ++re < K; )
      B[re] ^= L[re];
    return B;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var A = requireBn$1(), B = safeBufferExports.Buffer;
  function L(K, re) {
    return B.from(K.toRed(A.mont(re.modulus)).redPow(new A(re.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = L, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var A = requireParseAsn1(), B = requireBrowser$b(), L = requireBrowser$9(), K = requireMgf(), re = requireXor(), W = requireBn$1(), J = requireWithPublic(), ne = requireBrowserifyRsa(), ie = safeBufferExports.Buffer;
  publicEncrypt = function(Ce, it, at) {
    var lt;
    Ce.padding ? lt = Ce.padding : at ? lt = 1 : lt = 4;
    var ht = A(Ce), dt;
    if (lt === 4)
      dt = oe(ht, it);
    else if (lt === 1)
      dt = V(ht, it, at);
    else if (lt === 3) {
      if (dt = new W(it), dt.cmp(ht.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return at ? ne(dt, ht) : J(dt, ht);
  };
  function oe(ke, Ce) {
    var it = ke.modulus.byteLength(), at = Ce.length, lt = L("sha1").update(ie.alloc(0)).digest(), ht = lt.length, dt = 2 * ht;
    if (at > it - dt - 2)
      throw new Error("message too long");
    var bt = ie.alloc(it - at - dt - 2), vt = it - ht - 1, Bt = B(ht), At = re(ie.concat([lt, bt, ie.alloc(1, 1), Ce], vt), K(Bt, vt)), Nt = re(Bt, K(At, ht));
    return new W(ie.concat([ie.alloc(1), Nt, At], it));
  }
  function V(ke, Ce, it) {
    var at = Ce.length, lt = ke.modulus.byteLength();
    if (at > lt - 11)
      throw new Error("message too long");
    var ht;
    return it ? ht = ie.alloc(lt - at - 3, 255) : ht = ce(lt - at - 3), new W(ie.concat([ie.from([0, it ? 1 : 2]), ht, ie.alloc(1), Ce], lt));
  }
  function ce(ke) {
    for (var Ce = ie.allocUnsafe(ke), it = 0, at = B(ke * 2), lt = 0, ht; it < ke; )
      lt === at.length && (at = B(ke * 2), lt = 0), ht = at[lt++], ht && (Ce[it++] = ht);
    return Ce;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var A = requireParseAsn1(), B = requireMgf(), L = requireXor(), K = requireBn$1(), re = requireBrowserifyRsa(), W = requireBrowser$9(), J = requireWithPublic(), ne = safeBufferExports.Buffer;
  privateDecrypt = function(ke, Ce, it) {
    var at;
    ke.padding ? at = ke.padding : it ? at = 1 : at = 4;
    var lt = A(ke), ht = lt.modulus.byteLength();
    if (Ce.length > ht || new K(Ce).cmp(lt.modulus) >= 0)
      throw new Error("decryption error");
    var dt;
    it ? dt = J(new K(Ce), lt) : dt = re(Ce, lt);
    var bt = ne.alloc(ht - dt.length);
    if (dt = ne.concat([bt, dt], ht), at === 4)
      return ie(lt, dt);
    if (at === 1)
      return oe(lt, dt, it);
    if (at === 3)
      return dt;
    throw new Error("unknown padding");
  };
  function ie(ce, ke) {
    var Ce = ce.modulus.byteLength(), it = W("sha1").update(ne.alloc(0)).digest(), at = it.length;
    if (ke[0] !== 0)
      throw new Error("decryption error");
    var lt = ke.slice(1, at + 1), ht = ke.slice(at + 1), dt = L(lt, B(ht, at)), bt = L(ht, B(dt, Ce - at - 1));
    if (V(it, bt.slice(0, at)))
      throw new Error("decryption error");
    for (var vt = at; bt[vt] === 0; )
      vt++;
    if (bt[vt++] !== 1)
      throw new Error("decryption error");
    return bt.slice(vt);
  }
  function oe(ce, ke, Ce) {
    for (var it = ke.slice(0, 2), at = 2, lt = 0; ke[at++] !== 0; )
      if (at >= ke.length) {
        lt++;
        break;
      }
    var ht = ke.slice(2, at - 1);
    if ((it.toString("hex") !== "0002" && !Ce || it.toString("hex") !== "0001" && Ce) && lt++, ht.length < 8 && lt++, lt)
      throw new Error("decryption error");
    return ke.slice(at);
  }
  function V(ce, ke) {
    ce = ne.from(ce), ke = ne.from(ke);
    var Ce = 0, it = ce.length;
    ce.length !== ke.length && (Ce++, it = Math.min(ce.length, ke.length));
    for (var at = -1; ++at < it; )
      Ce += ce[at] ^ ke[at];
    return Ce;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(A) {
    A.publicEncrypt = requirePublicEncrypt(), A.privateDecrypt = requirePrivateDecrypt(), A.privateEncrypt = function(L, K) {
      return A.publicEncrypt(L, K, !0);
    }, A.publicDecrypt = function(L, K) {
      return A.privateDecrypt(L, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function A() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var B = safeBufferExports, L = requireBrowser$b(), K = B.Buffer, re = B.kMaxLength, W = commonjsGlobal.crypto || commonjsGlobal.msCrypto, J = Math.pow(2, 32) - 1;
  function ne(ke, Ce) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("offset must be a number");
    if (ke > J || ke < 0)
      throw new TypeError("offset must be a uint32");
    if (ke > re || ke > Ce)
      throw new RangeError("offset out of range");
  }
  function ie(ke, Ce, it) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("size must be a number");
    if (ke > J || ke < 0)
      throw new TypeError("size must be a uint32");
    if (ke + Ce > it || ke > re)
      throw new RangeError("buffer too small");
  }
  W && W.getRandomValues || !process$1.browser ? (browser.randomFill = oe, browser.randomFillSync = ce) : (browser.randomFill = A, browser.randomFillSync = A);
  function oe(ke, Ce, it, at) {
    if (!K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Ce == "function")
      at = Ce, Ce = 0, it = ke.length;
    else if (typeof it == "function")
      at = it, it = ke.length - Ce;
    else if (typeof at != "function")
      throw new TypeError('"cb" argument must be a function');
    return ne(Ce, ke.length), ie(it, Ce, ke.length), V(ke, Ce, it, at);
  }
  function V(ke, Ce, it, at) {
    if (process$1.browser) {
      var lt = ke.buffer, ht = new Uint8Array(lt, Ce, it);
      if (W.getRandomValues(ht), at) {
        process$1.nextTick(function() {
          at(null, ke);
        });
        return;
      }
      return ke;
    }
    if (at) {
      L(it, function(bt, vt) {
        if (bt)
          return at(bt);
        vt.copy(ke, Ce), at(null, ke);
      });
      return;
    }
    var dt = L(it);
    return dt.copy(ke, Ce), ke;
  }
  function ce(ke, Ce, it) {
    if (typeof Ce > "u" && (Ce = 0), !K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ne(Ce, ke.length), it === void 0 && (it = ke.length - Ce), ie(it, Ce, ke.length), V(ke, Ce, it);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var A = requireAlgos(), B = Object.keys(A), L = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(B);
  cryptoBrowserify.getHashes = function() {
    return L;
  };
  var K = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = K.pbkdf2, cryptoBrowserify.pbkdf2Sync = K.pbkdf2Sync;
  var re = requireBrowser$5();
  cryptoBrowserify.Cipher = re.Cipher, cryptoBrowserify.createCipher = re.createCipher, cryptoBrowserify.Cipheriv = re.Cipheriv, cryptoBrowserify.createCipheriv = re.createCipheriv, cryptoBrowserify.Decipher = re.Decipher, cryptoBrowserify.createDecipher = re.createDecipher, cryptoBrowserify.Decipheriv = re.Decipheriv, cryptoBrowserify.createDecipheriv = re.createDecipheriv, cryptoBrowserify.getCiphers = re.getCiphers, cryptoBrowserify.listCiphers = re.listCiphers;
  var W = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = W.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = W.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = W.getDiffieHellman, cryptoBrowserify.createDiffieHellman = W.createDiffieHellman, cryptoBrowserify.DiffieHellman = W.DiffieHellman;
  var J = requireBrowser$3();
  cryptoBrowserify.createSign = J.createSign, cryptoBrowserify.Sign = J.Sign, cryptoBrowserify.createVerify = J.createVerify, cryptoBrowserify.Verify = J.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ne = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ne.publicEncrypt, cryptoBrowserify.privateEncrypt = ne.privateEncrypt, cryptoBrowserify.publicDecrypt = ne.publicDecrypt, cryptoBrowserify.privateDecrypt = ne.privateDecrypt;
  var ie = requireBrowser();
  return cryptoBrowserify.randomFill = ie.randomFill, cryptoBrowserify.randomFillSync = ie.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(A) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.utils = A.schnorr = A.verify = A.signSync = A.sign = A.getSharedSecret = A.recoverPublicKey = A.getPublicKey = A.Signature = A.Point = A.CURVE = void 0;
  const B = requireCryptoBrowserify(), L = BigInt(0), K = BigInt(1), re = BigInt(2), W = BigInt(3), J = BigInt(8), ne = Object.freeze({
    a: L,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: K,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  A.CURVE = ne;
  const ie = (Ft, kt) => (Ft + kt / re) / kt, oe = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Ft) {
      const { n: kt } = ne, Dt = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ht = -K * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Xt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Qt = Dt, tr = BigInt("0x100000000000000000000000000000000"), nr = ie(Qt * Ft, kt), fr = ie(-Ht * Ft, kt);
      let ir = St(Ft - nr * Dt - fr * Xt, kt), pr = St(-nr * Ht - fr * Qt, kt);
      const wr = ir > tr, sr = pr > tr;
      if (wr && (ir = kt - ir), sr && (pr = kt - pr), ir > tr || pr > tr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Ft);
      return { k1neg: wr, k1: ir, k2neg: sr, k2: pr };
    }
  }, V = 32, ce = 32, ke = 32, Ce = V + 1, it = 2 * V + 1;
  function at(Ft) {
    const { a: kt, b: Dt } = ne, Ht = St(Ft * Ft), Xt = St(Ht * Ft);
    return St(Xt + kt * Ft + Dt);
  }
  const lt = ne.a === L;
  class ht extends Error {
    constructor(kt) {
      super(kt);
    }
  }
  function dt(Ft) {
    if (!(Ft instanceof bt))
      throw new TypeError("JacobianPoint expected");
  }
  class bt {
    constructor(kt, Dt, Ht) {
      this.x = kt, this.y = Dt, this.z = Ht;
    }
    static fromAffine(kt) {
      if (!(kt instanceof At))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return kt.equals(At.ZERO) ? bt.ZERO : new bt(kt.x, kt.y, K);
    }
    static toAffineBatch(kt) {
      const Dt = Tt(kt.map((Ht) => Ht.z));
      return kt.map((Ht, Xt) => Ht.toAffine(Dt[Xt]));
    }
    static normalizeZ(kt) {
      return bt.toAffineBatch(kt).map(bt.fromAffine);
    }
    equals(kt) {
      dt(kt);
      const { x: Dt, y: Ht, z: Xt } = this, { x: Qt, y: tr, z: nr } = kt, fr = St(Xt * Xt), ir = St(nr * nr), pr = St(Dt * ir), wr = St(Qt * fr), sr = St(St(Ht * nr) * ir), Lt = St(St(tr * Xt) * fr);
      return pr === wr && sr === Lt;
    }
    negate() {
      return new bt(this.x, St(-this.y), this.z);
    }
    double() {
      const { x: kt, y: Dt, z: Ht } = this, Xt = St(kt * kt), Qt = St(Dt * Dt), tr = St(Qt * Qt), nr = kt + Qt, fr = St(re * (St(nr * nr) - Xt - tr)), ir = St(W * Xt), pr = St(ir * ir), wr = St(pr - re * fr), sr = St(ir * (fr - wr) - J * tr), Lt = St(re * Dt * Ht);
      return new bt(wr, sr, Lt);
    }
    add(kt) {
      dt(kt);
      const { x: Dt, y: Ht, z: Xt } = this, { x: Qt, y: tr, z: nr } = kt;
      if (Qt === L || tr === L)
        return this;
      if (Dt === L || Ht === L)
        return kt;
      const fr = St(Xt * Xt), ir = St(nr * nr), pr = St(Dt * ir), wr = St(Qt * fr), sr = St(St(Ht * nr) * ir), Lt = St(St(tr * Xt) * fr), Jt = St(wr - pr), er = St(Lt - sr);
      if (Jt === L)
        return er === L ? this.double() : bt.ZERO;
      const or = St(Jt * Jt), vr = St(Jt * or), Sr = St(pr * or), Rr = St(er * er - vr - re * Sr), Tr = St(er * (Sr - Rr) - sr * vr), Nr = St(Xt * nr * Jt);
      return new bt(Rr, Tr, Nr);
    }
    subtract(kt) {
      return this.add(kt.negate());
    }
    multiplyUnsafe(kt) {
      const Dt = bt.ZERO;
      if (typeof kt == "bigint" && kt === L)
        return Dt;
      let Ht = ct(kt);
      if (Ht === K)
        return this;
      if (!lt) {
        let wr = Dt, sr = this;
        for (; Ht > L; )
          Ht & K && (wr = wr.add(sr)), sr = sr.double(), Ht >>= K;
        return wr;
      }
      let { k1neg: Xt, k1: Qt, k2neg: tr, k2: nr } = oe.splitScalar(Ht), fr = Dt, ir = Dt, pr = this;
      for (; Qt > L || nr > L; )
        Qt & K && (fr = fr.add(pr)), nr & K && (ir = ir.add(pr)), pr = pr.double(), Qt >>= K, nr >>= K;
      return Xt && (fr = fr.negate()), tr && (ir = ir.negate()), ir = new bt(St(ir.x * oe.beta), ir.y, ir.z), fr.add(ir);
    }
    precomputeWindow(kt) {
      const Dt = lt ? 128 / kt + 1 : 256 / kt + 1, Ht = [];
      let Xt = this, Qt = Xt;
      for (let tr = 0; tr < Dt; tr++) {
        Qt = Xt, Ht.push(Qt);
        for (let nr = 1; nr < 2 ** (kt - 1); nr++)
          Qt = Qt.add(Xt), Ht.push(Qt);
        Xt = Qt.double();
      }
      return Ht;
    }
    wNAF(kt, Dt) {
      !Dt && this.equals(bt.BASE) && (Dt = At.BASE);
      const Ht = Dt && Dt._WINDOW_SIZE || 1;
      if (256 % Ht)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Xt = Dt && Bt.get(Dt);
      Xt || (Xt = this.precomputeWindow(Ht), Dt && Ht !== 1 && (Xt = bt.normalizeZ(Xt), Bt.set(Dt, Xt)));
      let Qt = bt.ZERO, tr = bt.BASE;
      const nr = 1 + (lt ? 128 / Ht : 256 / Ht), fr = 2 ** (Ht - 1), ir = BigInt(2 ** Ht - 1), pr = 2 ** Ht, wr = BigInt(Ht);
      for (let sr = 0; sr < nr; sr++) {
        const Lt = sr * fr;
        let Jt = Number(kt & ir);
        kt >>= wr, Jt > fr && (Jt -= pr, kt += K);
        const er = Lt, or = Lt + Math.abs(Jt) - 1, vr = sr % 2 !== 0, Sr = Jt < 0;
        Jt === 0 ? tr = tr.add(vt(vr, Xt[er])) : Qt = Qt.add(vt(Sr, Xt[or]));
      }
      return { p: Qt, f: tr };
    }
    multiply(kt, Dt) {
      let Ht = ct(kt), Xt, Qt;
      if (lt) {
        const { k1neg: tr, k1: nr, k2neg: fr, k2: ir } = oe.splitScalar(Ht);
        let { p: pr, f: wr } = this.wNAF(nr, Dt), { p: sr, f: Lt } = this.wNAF(ir, Dt);
        pr = vt(tr, pr), sr = vt(fr, sr), sr = new bt(St(sr.x * oe.beta), sr.y, sr.z), Xt = pr.add(sr), Qt = wr.add(Lt);
      } else {
        const { p: tr, f: nr } = this.wNAF(Ht, Dt);
        Xt = tr, Qt = nr;
      }
      return bt.normalizeZ([Xt, Qt])[0];
    }
    toAffine(kt) {
      const { x: Dt, y: Ht, z: Xt } = this, Qt = this.equals(bt.ZERO);
      kt == null && (kt = Qt ? J : Ot(Xt));
      const tr = kt, nr = St(tr * tr), fr = St(nr * tr), ir = St(Dt * nr), pr = St(Ht * fr), wr = St(Xt * tr);
      if (Qt)
        return At.ZERO;
      if (wr !== K)
        throw new Error("invZ was invalid");
      return new At(ir, pr);
    }
  }
  bt.BASE = new bt(ne.Gx, ne.Gy, K), bt.ZERO = new bt(L, K, L);
  function vt(Ft, kt) {
    const Dt = kt.negate();
    return Ft ? Dt : kt;
  }
  const Bt = /* @__PURE__ */ new WeakMap();
  class At {
    constructor(kt, Dt) {
      this.x = kt, this.y = Dt;
    }
    _setWindowSize(kt) {
      this._WINDOW_SIZE = kt, Bt.delete(this);
    }
    hasEvenY() {
      return this.y % re === L;
    }
    static fromCompressedHex(kt) {
      const Dt = kt.length === 32, Ht = ft(Dt ? kt : kt.subarray(1));
      if (!Zt(Ht))
        throw new Error("Point is not on curve");
      const Xt = at(Ht);
      let Qt = jt(Xt);
      const tr = (Qt & K) === K;
      Dt ? tr && (Qt = St(-Qt)) : (kt[0] & 1) === 1 !== tr && (Qt = St(-Qt));
      const nr = new At(Ht, Qt);
      return nr.assertValidity(), nr;
    }
    static fromUncompressedHex(kt) {
      const Dt = ft(kt.subarray(1, V + 1)), Ht = ft(kt.subarray(V + 1, V * 2 + 1)), Xt = new At(Dt, Ht);
      return Xt.assertValidity(), Xt;
    }
    static fromHex(kt) {
      const Dt = yt(kt), Ht = Dt.length, Xt = Dt[0];
      if (Ht === V)
        return this.fromCompressedHex(Dt);
      if (Ht === Ce && (Xt === 2 || Xt === 3))
        return this.fromCompressedHex(Dt);
      if (Ht === it && Xt === 4)
        return this.fromUncompressedHex(Dt);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ce} compressed bytes or ${it} uncompressed bytes, not ${Ht}`);
    }
    static fromPrivateKey(kt) {
      return At.BASE.multiply(ar(kt));
    }
    static fromSignature(kt, Dt, Ht) {
      const { r: Xt, s: Qt } = hr(Dt);
      if (![0, 1, 2, 3].includes(Ht))
        throw new Error("Cannot recover: invalid recovery bit");
      const tr = Ut(yt(kt)), { n: nr } = ne, fr = Ht === 2 || Ht === 3 ? Xt + nr : Xt, ir = Ot(fr, nr), pr = St(-tr * ir, nr), wr = St(Qt * ir, nr), sr = Ht & 1 ? "03" : "02", Lt = At.fromHex(sr + nt(fr)), Jt = At.BASE.multiplyAndAddUnsafe(Lt, pr, wr);
      if (!Jt)
        throw new Error("Cannot recover signature: point at infinify");
      return Jt.assertValidity(), Jt;
    }
    toRawBytes(kt = !1) {
      return pt(this.toHex(kt));
    }
    toHex(kt = !1) {
      const Dt = nt(this.x);
      return kt ? `${this.hasEvenY() ? "02" : "03"}${Dt}` : `04${Dt}${nt(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const kt = "Point is not on elliptic curve", { x: Dt, y: Ht } = this;
      if (!Zt(Dt) || !Zt(Ht))
        throw new Error(kt);
      const Xt = St(Ht * Ht), Qt = at(Dt);
      if (St(Xt - Qt) !== L)
        throw new Error(kt);
    }
    equals(kt) {
      return this.x === kt.x && this.y === kt.y;
    }
    negate() {
      return new At(this.x, St(-this.y));
    }
    double() {
      return bt.fromAffine(this).double().toAffine();
    }
    add(kt) {
      return bt.fromAffine(this).add(bt.fromAffine(kt)).toAffine();
    }
    subtract(kt) {
      return this.add(kt.negate());
    }
    multiply(kt) {
      return bt.fromAffine(this).multiply(kt, this).toAffine();
    }
    multiplyAndAddUnsafe(kt, Dt, Ht) {
      const Xt = bt.fromAffine(this), Qt = Dt === L || Dt === K || this !== At.BASE ? Xt.multiplyUnsafe(Dt) : Xt.multiply(Dt), tr = bt.fromAffine(kt).multiplyUnsafe(Ht), nr = Qt.add(tr);
      return nr.equals(bt.ZERO) ? void 0 : nr.toAffine();
    }
  }
  A.Point = At, At.BASE = new At(ne.Gx, ne.Gy), At.ZERO = new At(L, L);
  function Nt(Ft) {
    return Number.parseInt(Ft[0], 16) >= 8 ? "00" + Ft : Ft;
  }
  function $t(Ft) {
    if (Ft.length < 2 || Ft[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${rt(Ft)}`);
    const kt = Ft[1], Dt = Ft.subarray(2, kt + 2);
    if (!kt || Dt.length !== kt)
      throw new Error("Invalid signature integer: wrong length");
    if (Dt[0] === 0 && Dt[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ft(Dt), left: Ft.subarray(kt + 2) };
  }
  function mt(Ft) {
    if (Ft.length < 2 || Ft[0] != 48)
      throw new Error(`Invalid signature tag: ${rt(Ft)}`);
    if (Ft[1] !== Ft.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: kt, left: Dt } = $t(Ft.subarray(2)), { data: Ht, left: Xt } = $t(Dt);
    if (Xt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${rt(Xt)}`);
    return { r: kt, s: Ht };
  }
  class xt {
    constructor(kt, Dt) {
      this.r = kt, this.s = Dt, this.assertValidity();
    }
    static fromCompact(kt) {
      const Dt = kt instanceof Uint8Array, Ht = "Signature.fromCompact";
      if (typeof kt != "string" && !Dt)
        throw new TypeError(`${Ht}: Expected string or Uint8Array`);
      const Xt = Dt ? rt(kt) : kt;
      if (Xt.length !== 128)
        throw new Error(`${Ht}: Expected 64-byte hex`);
      return new xt(ut(Xt.slice(0, 64)), ut(Xt.slice(64, 128)));
    }
    static fromDER(kt) {
      const Dt = kt instanceof Uint8Array;
      if (typeof kt != "string" && !Dt)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Ht, s: Xt } = mt(Dt ? kt : pt(kt));
      return new xt(Ht, Xt);
    }
    static fromHex(kt) {
      return this.fromDER(kt);
    }
    assertValidity() {
      const { r: kt, s: Dt } = this;
      if (!Kt(kt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Kt(Dt))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const kt = ne.n >> K;
      return this.s > kt;
    }
    normalizeS() {
      return this.hasHighS() ? new xt(this.r, St(-this.s, ne.n)) : this;
    }
    toDERRawBytes() {
      return pt(this.toDERHex());
    }
    toDERHex() {
      const kt = Nt(st(this.s)), Dt = Nt(st(this.r)), Ht = kt.length / 2, Xt = Dt.length / 2, Qt = st(Ht), tr = st(Xt);
      return `30${st(Xt + Ht + 4)}02${tr}${Dt}02${Qt}${kt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return pt(this.toCompactHex());
    }
    toCompactHex() {
      return nt(this.r) + nt(this.s);
    }
  }
  A.Signature = xt;
  function wt(...Ft) {
    if (!Ft.every((Ht) => Ht instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Ft.length === 1)
      return Ft[0];
    const kt = Ft.reduce((Ht, Xt) => Ht + Xt.length, 0), Dt = new Uint8Array(kt);
    for (let Ht = 0, Xt = 0; Ht < Ft.length; Ht++) {
      const Qt = Ft[Ht];
      Dt.set(Qt, Xt), Xt += Qt.length;
    }
    return Dt;
  }
  const Oe = Array.from({ length: 256 }, (Ft, kt) => kt.toString(16).padStart(2, "0"));
  function rt(Ft) {
    if (!(Ft instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let kt = "";
    for (let Dt = 0; Dt < Ft.length; Dt++)
      kt += Oe[Ft[Dt]];
    return kt;
  }
  const pe = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function nt(Ft) {
    if (typeof Ft != "bigint")
      throw new Error("Expected bigint");
    if (!(L <= Ft && Ft < pe))
      throw new Error("Expected number 0 <= n < 2^256");
    return Ft.toString(16).padStart(64, "0");
  }
  function ot(Ft) {
    const kt = pt(nt(Ft));
    if (kt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return kt;
  }
  function st(Ft) {
    const kt = Ft.toString(16);
    return kt.length & 1 ? `0${kt}` : kt;
  }
  function ut(Ft) {
    if (typeof Ft != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Ft);
    return BigInt(`0x${Ft}`);
  }
  function pt(Ft) {
    if (typeof Ft != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Ft);
    if (Ft.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Ft.length);
    const kt = new Uint8Array(Ft.length / 2);
    for (let Dt = 0; Dt < kt.length; Dt++) {
      const Ht = Dt * 2, Xt = Ft.slice(Ht, Ht + 2), Qt = Number.parseInt(Xt, 16);
      if (Number.isNaN(Qt) || Qt < 0)
        throw new Error("Invalid byte sequence");
      kt[Dt] = Qt;
    }
    return kt;
  }
  function ft(Ft) {
    return ut(rt(Ft));
  }
  function yt(Ft) {
    return Ft instanceof Uint8Array ? Uint8Array.from(Ft) : pt(Ft);
  }
  function ct(Ft) {
    if (typeof Ft == "number" && Number.isSafeInteger(Ft) && Ft > 0)
      return BigInt(Ft);
    if (typeof Ft == "bigint" && Kt(Ft))
      return Ft;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function St(Ft, kt = ne.P) {
    const Dt = Ft % kt;
    return Dt >= L ? Dt : kt + Dt;
  }
  function qt(Ft, kt) {
    const { P: Dt } = ne;
    let Ht = Ft;
    for (; kt-- > L; )
      Ht *= Ht, Ht %= Dt;
    return Ht;
  }
  function jt(Ft) {
    const { P: kt } = ne, Dt = BigInt(6), Ht = BigInt(11), Xt = BigInt(22), Qt = BigInt(23), tr = BigInt(44), nr = BigInt(88), fr = Ft * Ft * Ft % kt, ir = fr * fr * Ft % kt, pr = qt(ir, W) * ir % kt, wr = qt(pr, W) * ir % kt, sr = qt(wr, re) * fr % kt, Lt = qt(sr, Ht) * sr % kt, Jt = qt(Lt, Xt) * Lt % kt, er = qt(Jt, tr) * Jt % kt, or = qt(er, nr) * er % kt, vr = qt(or, tr) * Jt % kt, Sr = qt(vr, W) * ir % kt, Rr = qt(Sr, Qt) * Lt % kt, Tr = qt(Rr, Dt) * fr % kt, Nr = qt(Tr, re);
    if (Nr * Nr % kt !== Ft)
      throw new Error("Cannot find square root");
    return Nr;
  }
  function Ot(Ft, kt = ne.P) {
    if (Ft === L || kt <= L)
      throw new Error(`invert: expected positive integers, got n=${Ft} mod=${kt}`);
    let Dt = St(Ft, kt), Ht = kt, Xt = L, Qt = K;
    for (; Dt !== L; ) {
      const nr = Ht / Dt, fr = Ht % Dt, ir = Xt - Qt * nr;
      Ht = Dt, Dt = fr, Xt = Qt, Qt = ir;
    }
    if (Ht !== K)
      throw new Error("invert: does not exist");
    return St(Xt, kt);
  }
  function Tt(Ft, kt = ne.P) {
    const Dt = new Array(Ft.length), Ht = Ft.reduce((Qt, tr, nr) => tr === L ? Qt : (Dt[nr] = Qt, St(Qt * tr, kt)), K), Xt = Ot(Ht, kt);
    return Ft.reduceRight((Qt, tr, nr) => tr === L ? Qt : (Dt[nr] = St(Qt * Dt[nr], kt), St(Qt * tr, kt)), Xt), Dt;
  }
  function Rt(Ft) {
    const kt = Ft.length * 8 - ce * 8, Dt = ft(Ft);
    return kt > 0 ? Dt >> BigInt(kt) : Dt;
  }
  function Ut(Ft, kt = !1) {
    const Dt = Rt(Ft);
    if (kt)
      return Dt;
    const { n: Ht } = ne;
    return Dt >= Ht ? Dt - Ht : Dt;
  }
  let Gt, Mt;
  class Pt {
    constructor(kt, Dt) {
      if (this.hashLen = kt, this.qByteLen = Dt, typeof kt != "number" || kt < 2)
        throw new Error("hashLen must be a number");
      if (typeof Dt != "number" || Dt < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(kt).fill(1), this.k = new Uint8Array(kt).fill(0), this.counter = 0;
    }
    hmac(...kt) {
      return A.utils.hmacSha256(this.k, ...kt);
    }
    hmacSync(...kt) {
      return Mt(this.k, ...kt);
    }
    checkSync() {
      if (typeof Mt != "function")
        throw new ht("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(kt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), kt), this.v = await this.hmac(this.v), kt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), kt), this.v = await this.hmac(this.v));
    }
    reseedSync(kt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), kt), this.v = this.hmacSync(this.v), kt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), kt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let kt = 0;
      const Dt = [];
      for (; kt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), kt += this.v.length;
      }
      return wt(...Dt);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let kt = 0;
      const Dt = [];
      for (; kt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), kt += this.v.length;
      }
      return wt(...Dt);
    }
  }
  function Kt(Ft) {
    return L < Ft && Ft < ne.n;
  }
  function Zt(Ft) {
    return L < Ft && Ft < ne.P;
  }
  function rr(Ft, kt, Dt, Ht = !0) {
    const { n: Xt } = ne, Qt = Ut(Ft, !0);
    if (!Kt(Qt))
      return;
    const tr = Ot(Qt, Xt), nr = At.BASE.multiply(Qt), fr = St(nr.x, Xt);
    if (fr === L)
      return;
    const ir = St(tr * St(kt + Dt * fr, Xt), Xt);
    if (ir === L)
      return;
    let pr = new xt(fr, ir), wr = (nr.x === pr.r ? 0 : 2) | Number(nr.y & K);
    return Ht && pr.hasHighS() && (pr = pr.normalizeS(), wr ^= 1), { sig: pr, recovery: wr };
  }
  function ar(Ft) {
    let kt;
    if (typeof Ft == "bigint")
      kt = Ft;
    else if (typeof Ft == "number" && Number.isSafeInteger(Ft) && Ft > 0)
      kt = BigInt(Ft);
    else if (typeof Ft == "string") {
      if (Ft.length !== 2 * ce)
        throw new Error("Expected 32 bytes of private key");
      kt = ut(Ft);
    } else if (Ft instanceof Uint8Array) {
      if (Ft.length !== ce)
        throw new Error("Expected 32 bytes of private key");
      kt = ft(Ft);
    } else
      throw new TypeError("Expected valid private key");
    if (!Kt(kt))
      throw new Error("Expected private key: 0 < key < n");
    return kt;
  }
  function ur(Ft) {
    return Ft instanceof At ? (Ft.assertValidity(), Ft) : At.fromHex(Ft);
  }
  function hr(Ft) {
    if (Ft instanceof xt)
      return Ft.assertValidity(), Ft;
    try {
      return xt.fromDER(Ft);
    } catch {
      return xt.fromCompact(Ft);
    }
  }
  function Yt(Ft, kt = !1) {
    return At.fromPrivateKey(Ft).toRawBytes(kt);
  }
  A.getPublicKey = Yt;
  function Ir(Ft, kt, Dt, Ht = !1) {
    return At.fromSignature(Ft, kt, Dt).toRawBytes(Ht);
  }
  A.recoverPublicKey = Ir;
  function lr(Ft) {
    const kt = Ft instanceof Uint8Array, Dt = typeof Ft == "string", Ht = (kt || Dt) && Ft.length;
    return kt ? Ht === Ce || Ht === it : Dt ? Ht === Ce * 2 || Ht === it * 2 : Ft instanceof At;
  }
  function Ar(Ft, kt, Dt = !1) {
    if (lr(Ft))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!lr(kt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Ht = ur(kt);
    return Ht.assertValidity(), Ht.multiply(ar(Ft)).toRawBytes(Dt);
  }
  A.getSharedSecret = Ar;
  function Br(Ft) {
    const kt = Ft.length > V ? Ft.slice(0, V) : Ft;
    return ft(kt);
  }
  function dr(Ft) {
    const kt = Br(Ft), Dt = St(kt, ne.n);
    return Er(Dt < L ? kt : Dt);
  }
  function Er(Ft) {
    return ot(Ft);
  }
  function Pr(Ft, kt, Dt) {
    if (Ft == null)
      throw new Error(`sign: expected valid message hash, not "${Ft}"`);
    const Ht = yt(Ft), Xt = ar(kt), Qt = [Er(Xt), dr(Ht)];
    if (Dt != null) {
      Dt === !0 && (Dt = A.utils.randomBytes(V));
      const fr = yt(Dt);
      if (fr.length !== V)
        throw new Error(`sign: Expected ${V} bytes of extra data`);
      Qt.push(fr);
    }
    const tr = wt(...Qt), nr = Br(Ht);
    return { seed: tr, m: nr, d: Xt };
  }
  function br(Ft, kt) {
    const { sig: Dt, recovery: Ht } = Ft, { der: Xt, recovered: Qt } = Object.assign({ canonical: !0, der: !0 }, kt), tr = Xt ? Dt.toDERRawBytes() : Dt.toCompactRawBytes();
    return Qt ? [tr, Ht] : tr;
  }
  async function Mr(Ft, kt, Dt = {}) {
    const { seed: Ht, m: Xt, d: Qt } = Pr(Ft, kt, Dt.extraEntropy), tr = new Pt(ke, ce);
    await tr.reseed(Ht);
    let nr;
    for (; !(nr = rr(await tr.generate(), Xt, Qt, Dt.canonical)); )
      await tr.reseed();
    return br(nr, Dt);
  }
  A.sign = Mr;
  function Or(Ft, kt, Dt = {}) {
    const { seed: Ht, m: Xt, d: Qt } = Pr(Ft, kt, Dt.extraEntropy), tr = new Pt(ke, ce);
    tr.reseedSync(Ht);
    let nr;
    for (; !(nr = rr(tr.generateSync(), Xt, Qt, Dt.canonical)); )
      tr.reseedSync();
    return br(nr, Dt);
  }
  A.signSync = Or;
  const It = { strict: !0 };
  function gt(Ft, kt, Dt, Ht = It) {
    let Xt;
    try {
      Xt = hr(Ft), kt = yt(kt);
    } catch {
      return !1;
    }
    const { r: Qt, s: tr } = Xt;
    if (Ht.strict && Xt.hasHighS())
      return !1;
    const nr = Ut(kt);
    let fr;
    try {
      fr = ur(Dt);
    } catch {
      return !1;
    }
    const { n: ir } = ne, pr = Ot(tr, ir), wr = St(nr * pr, ir), sr = St(Qt * pr, ir), Lt = At.BASE.multiplyAndAddUnsafe(fr, wr, sr);
    return Lt ? St(Lt.x, ir) === Qt : !1;
  }
  A.verify = gt;
  function Et(Ft) {
    return St(ft(Ft), ne.n);
  }
  class Ct {
    constructor(kt, Dt) {
      this.r = kt, this.s = Dt, this.assertValidity();
    }
    static fromHex(kt) {
      const Dt = yt(kt);
      if (Dt.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Dt.length}`);
      const Ht = ft(Dt.subarray(0, 32)), Xt = ft(Dt.subarray(32, 64));
      return new Ct(Ht, Xt);
    }
    assertValidity() {
      const { r: kt, s: Dt } = this;
      if (!Zt(kt) || !Kt(Dt))
        throw new Error("Invalid signature");
    }
    toHex() {
      return nt(this.r) + nt(this.s);
    }
    toRawBytes() {
      return pt(this.toHex());
    }
  }
  function Wt(Ft) {
    return At.fromPrivateKey(Ft).toRawX();
  }
  class zt {
    constructor(kt, Dt, Ht = A.utils.randomBytes()) {
      if (kt == null)
        throw new TypeError(`sign: Expected valid message, not "${kt}"`);
      this.m = yt(kt);
      const { x: Xt, scalar: Qt } = this.getScalar(ar(Dt));
      if (this.px = Xt, this.d = Qt, this.rand = yt(Ht), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(kt) {
      const Dt = At.fromPrivateKey(kt), Ht = Dt.hasEvenY() ? kt : ne.n - kt;
      return { point: Dt, scalar: Ht, x: Dt.toRawX() };
    }
    initNonce(kt, Dt) {
      return ot(kt ^ ft(Dt));
    }
    finalizeNonce(kt) {
      const Dt = St(ft(kt), ne.n);
      if (Dt === L)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Ht, x: Xt, scalar: Qt } = this.getScalar(Dt);
      return { R: Ht, rx: Xt, k: Qt };
    }
    finalizeSig(kt, Dt, Ht, Xt) {
      return new Ct(kt.x, St(Dt + Ht * Xt, ne.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: kt, d: Dt, px: Ht, rand: Xt } = this, Qt = A.utils.taggedHash, tr = this.initNonce(Dt, await Qt(kr.aux, Xt)), { R: nr, rx: fr, k: ir } = this.finalizeNonce(await Qt(kr.nonce, tr, Ht, kt)), pr = Et(await Qt(kr.challenge, fr, Ht, kt)), wr = this.finalizeSig(nr, ir, pr, Dt);
      return await xr(wr, kt, Ht) || this.error(), wr;
    }
    calcSync() {
      const { m: kt, d: Dt, px: Ht, rand: Xt } = this, Qt = A.utils.taggedHashSync, tr = this.initNonce(Dt, Qt(kr.aux, Xt)), { R: nr, rx: fr, k: ir } = this.finalizeNonce(Qt(kr.nonce, tr, Ht, kt)), pr = Et(Qt(kr.challenge, fr, Ht, kt)), wr = this.finalizeSig(nr, ir, pr, Dt);
      return gr(wr, kt, Ht) || this.error(), wr;
    }
  }
  async function Vt(Ft, kt, Dt) {
    return new zt(Ft, kt, Dt).calc();
  }
  function yr(Ft, kt, Dt) {
    return new zt(Ft, kt, Dt).calcSync();
  }
  function $r(Ft, kt, Dt) {
    const Ht = Ft instanceof Ct, Xt = Ht ? Ft : Ct.fromHex(Ft);
    return Ht && Xt.assertValidity(), {
      ...Xt,
      m: yt(kt),
      P: ur(Dt)
    };
  }
  function cr(Ft, kt, Dt, Ht) {
    const Xt = At.BASE.multiplyAndAddUnsafe(kt, ar(Dt), St(-Ht, ne.n));
    return !(!Xt || !Xt.hasEvenY() || Xt.x !== Ft);
  }
  async function xr(Ft, kt, Dt) {
    try {
      const { r: Ht, s: Xt, m: Qt, P: tr } = $r(Ft, kt, Dt), nr = Et(await A.utils.taggedHash(kr.challenge, ot(Ht), tr.toRawX(), Qt));
      return cr(Ht, tr, Xt, nr);
    } catch {
      return !1;
    }
  }
  function gr(Ft, kt, Dt) {
    try {
      const { r: Ht, s: Xt, m: Qt, P: tr } = $r(Ft, kt, Dt), nr = Et(A.utils.taggedHashSync(kr.challenge, ot(Ht), tr.toRawX(), Qt));
      return cr(Ht, tr, Xt, nr);
    } catch (Ht) {
      if (Ht instanceof ht)
        throw Ht;
      return !1;
    }
  }
  A.schnorr = {
    Signature: Ct,
    getPublicKey: Wt,
    sign: Vt,
    verify: xr,
    signSync: yr,
    verifySync: gr
  }, At.BASE._setWindowSize(8);
  const _r = {
    node: B,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, kr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Cr = {};
  A.utils = {
    bytesToHex: rt,
    hexToBytes: pt,
    concatBytes: wt,
    mod: St,
    invert: Ot,
    isValidPrivateKey(Ft) {
      try {
        return ar(Ft), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: ot,
    _normalizePrivateKey: ar,
    hashToPrivateKey: (Ft) => {
      Ft = yt(Ft);
      const kt = ce + 8;
      if (Ft.length < kt || Ft.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Dt = St(ft(Ft), ne.n - K) + K;
      return ot(Dt);
    },
    randomBytes: (Ft = 32) => {
      if (_r.web)
        return _r.web.getRandomValues(new Uint8Array(Ft));
      if (_r.node) {
        const { randomBytes: kt } = _r.node;
        return Uint8Array.from(kt(Ft));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => A.utils.hashToPrivateKey(A.utils.randomBytes(ce + 8)),
    precompute(Ft = 8, kt = At.BASE) {
      const Dt = kt === At.BASE ? kt : new At(kt.x, kt.y);
      return Dt._setWindowSize(Ft), Dt.multiply(W), Dt;
    },
    sha256: async (...Ft) => {
      if (_r.web) {
        const kt = await _r.web.subtle.digest("SHA-256", wt(...Ft));
        return new Uint8Array(kt);
      } else if (_r.node) {
        const { createHash: kt } = _r.node, Dt = kt("sha256");
        return Ft.forEach((Ht) => Dt.update(Ht)), Uint8Array.from(Dt.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Ft, ...kt) => {
      if (_r.web) {
        const Dt = await _r.web.subtle.importKey("raw", Ft, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Ht = wt(...kt), Xt = await _r.web.subtle.sign("HMAC", Dt, Ht);
        return new Uint8Array(Xt);
      } else if (_r.node) {
        const { createHmac: Dt } = _r.node, Ht = Dt("sha256", Ft);
        return kt.forEach((Xt) => Ht.update(Xt)), Uint8Array.from(Ht.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Ft, ...kt) => {
      let Dt = Cr[Ft];
      if (Dt === void 0) {
        const Ht = await A.utils.sha256(Uint8Array.from(Ft, (Xt) => Xt.charCodeAt(0)));
        Dt = wt(Ht, Ht), Cr[Ft] = Dt;
      }
      return A.utils.sha256(Dt, ...kt);
    },
    taggedHashSync: (Ft, ...kt) => {
      if (typeof Gt != "function")
        throw new ht("sha256Sync is undefined, you need to set it");
      let Dt = Cr[Ft];
      if (Dt === void 0) {
        const Ht = Gt(Uint8Array.from(Ft, (Xt) => Xt.charCodeAt(0)));
        Dt = wt(Ht, Ht), Cr[Ft] = Dt;
      }
      return Gt(Dt, ...kt);
    },
    _JacobianPoint: bt
  }, Object.defineProperties(A.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return Gt;
      },
      set(Ft) {
        Gt || (Gt = Ft);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Mt;
      },
      set(Ft) {
        Mt || (Mt = Ft);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js$1, base64Url_1 = base64Url;
function getParamSize(A) {
  return (A / 8 | 0) + (A % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(A) {
  const B = paramBytesForAlg[A];
  if (B)
    return B;
  throw new Error(`Unknown algorithm "${A}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(A) {
  if (A instanceof Uint8Array)
    return A;
  if (typeof A == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(A));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(A, B) {
  const L = signatureAsBytes(A), K = getParamBytesForAlg(B), re = K + 1, W = L.length;
  let J = 0;
  if (L[J++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ne = L[J++];
  if (ne === (MAX_OCTET | 1) && (ne = L[J++]), W - J < ne)
    throw new Error(`"seq" specified length of "${ne}", only "${W - J}" remaining`);
  if (L[J++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ie = L[J++];
  if (W - J - 2 < ie)
    throw new Error(`"r" specified length of "${ie}", only "${W - J - 2}" available`);
  if (re < ie)
    throw new Error(`"r" specified length of "${ie}", max of "${re}" is acceptable`);
  const oe = J;
  if (J += ie, L[J++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const V = L[J++];
  if (W - J !== V)
    throw new Error(`"s" specified length of "${V}", expected "${W - J}"`);
  if (re < V)
    throw new Error(`"s" specified length of "${V}", max of "${re}" is acceptable`);
  const ce = J;
  if (J += V, J !== W)
    throw new Error(`Expected to consume entire array, but "${W - J}" bytes remain`);
  const ke = K - ie, Ce = K - V, it = new Uint8Array(ke + ie + Ce + V);
  for (J = 0; J < ke; ++J)
    it[J] = 0;
  it.set(L.subarray(oe + Math.max(-ke, 0), oe + ie), J), J = K;
  for (const at = J; J < at + Ce; ++J)
    it[J] = 0;
  return it.set(L.subarray(ce + Math.max(-Ce, 0), ce + V), J), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(it));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(A, B, L) {
  let K = 0;
  for (; B + K < L && A[B + K] === 0; )
    ++K;
  return A[B + K] >= MAX_OCTET && --K, K;
}
function joseToDer(A, B) {
  A = signatureAsBytes(A);
  const L = getParamBytesForAlg(B), K = A.length;
  if (K !== L * 2)
    throw new TypeError(`"${B}" signatures must be "${L * 2}" bytes, saw "${K}"`);
  const re = countPadding(A, 0, L), W = countPadding(A, L, A.length), J = L - re, ne = L - W, ie = 2 + J + 1 + 1 + ne, oe = ie < MAX_OCTET, V = new Uint8Array((oe ? 2 : 3) + ie);
  let ce = 0;
  return V[ce++] = ENCODED_TAG_SEQ, oe ? V[ce++] = ie : (V[ce++] = MAX_OCTET | 1, V[ce++] = ie & 255), V[ce++] = ENCODED_TAG_INT, V[ce++] = J, re < 0 ? (V[ce++] = 0, V.set(A.subarray(0, L), ce), ce += L) : (V.set(A.subarray(re, L), ce), ce += L - re), V[ce++] = ENCODED_TAG_INT, V[ce++] = ne, W < 0 ? (V[ce++] = 0, V.set(A.subarray(L), ce)) : V.set(A.subarray(L + W), ce), V;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(B) {
    super(), this.name = "MissingParametersError", this.message = B || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(B) {
    super(), this.name = "InvalidTokenError", this.message = B || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (A, ...B) => {
  const L = hmac_1.hmac.create(sha256_1$3.sha256, A);
  return B.forEach((K) => L.update(K)), L.digest();
};
class SECP256K1Client {
  static derivePublicKey(B, L = !0) {
    return B.length === 66 && (B = B.slice(0, 64)), B.length < 64 && (B = B.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(B, L));
  }
  static signHash(B, L, K = "jose") {
    if (!B || !L)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const re = secp.signSync(B, L.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (K === "der")
      return (0, utils_1$2.bytesToHex)(re);
    if (K === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(re, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(B) {
    return (0, ecdsaSigFormatter_1.joseToDer)(B, "ES256");
  }
  static verifyHash(B, L, K) {
    if (!B || !L || !K)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(L, B, K, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.cryptoClients = A.SECP256K1Client = void 0;
  const B = secp256k1$1;
  Object.defineProperty(A, "SECP256K1Client", { enumerable: !0, get: function() {
    return B.SECP256K1Client;
  } });
  const L = {
    ES256K: B.SECP256K1Client
  };
  A.cryptoClients = L;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function re(W) {
    return W instanceof L ? W : new L(function(J) {
      J(W);
    });
  }
  return new (L || (L = Promise))(function(W, J) {
    function ne(V) {
      try {
        oe(K.next(V));
      } catch (ce) {
        J(ce);
      }
    }
    function ie(V) {
      try {
        oe(K.throw(V));
      } catch (ce) {
        J(ce);
      }
    }
    function oe(V) {
      V.done ? W(V.value) : re(V.value).then(ne, ie);
    }
    oe((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(A) {
  return (0, sha256_1$2.sha256)(A);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(A) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const L = typeof A == "string" ? new TextEncoder().encode(A) : A, K = yield crypto.subtle.digest("SHA-256", L);
        return new Uint8Array(K);
      } else {
        const L = requireCryptoBrowserify();
        if (!L.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(L.createHash("sha256").update(A).digest());
      }
    } catch (B) {
      return console.log(B), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(A));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function re(W) {
    return W instanceof L ? W : new L(function(J) {
      J(W);
    });
  }
  return new (L || (L = Promise))(function(W, J) {
    function ne(V) {
      try {
        oe(K.next(V));
      } catch (ce) {
        J(ce);
      }
    }
    function ie(V) {
      try {
        oe(K.throw(V));
      } catch (ce) {
        J(ce);
      }
    }
    function oe(V) {
      V.done ? W(V.value) : re(V.value).then(ne, ie);
    }
    oe((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(A, B) {
  const L = [], K = base64url$2.encode(JSON.stringify(B));
  L.push(K);
  const re = base64url$2.encode(JSON.stringify(A));
  return L.push(re), L.join(".");
}
function createUnsecuredToken(A) {
  return createSigningInput(A, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof B != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (B = B.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(B))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[B], this.rawPrivateKey = L;
  }
  header(B = {}) {
    const L = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, L, B);
  }
  sign(B, L = !1, K = {}) {
    const re = this.header(K), W = createSigningInput(B, re), J = (0, sha256_1$1.hashSha256)(W);
    return this.createWithSignedHash(B, L, re, W, J);
  }
  signAsync(B, L = !1, K = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const re = this.header(K), W = createSigningInput(B, re), J = yield (0, sha256_1$1.hashSha256Async)(W);
      return this.createWithSignedHash(B, L, re, W, J);
    });
  }
  createWithSignedHash(B, L, K, re, W) {
    const J = this.cryptoClient.signHash(W, this.rawPrivateKey);
    return L ? {
      header: [base64url$2.encode(JSON.stringify(K))],
      payload: JSON.stringify(B),
      signature: [J]
    } : [re, J].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof B != "string")
      throw "signing algorithm parameter must be a string";
    if (B = B.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(B))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[B], this.rawPublicKey = L;
  }
  verify(B) {
    return typeof B == "string" ? this.verifyCompact(B, !1) : typeof B == "object" ? this.verifyExpanded(B, !1) : !1;
  }
  verifyAsync(B) {
    return typeof B == "string" ? this.verifyCompact(B, !0) : typeof B == "object" ? this.verifyExpanded(B, !0) : Promise.resolve(!1);
  }
  verifyCompact(B, L) {
    const K = B.split("."), re = K[0] + "." + K[1], W = (J) => {
      const ne = this.cryptoClient.loadSignature(K[2]);
      return this.cryptoClient.verifyHash(J, ne, this.rawPublicKey);
    };
    if (L)
      return (0, sha256_1.hashSha256Async)(re).then((J) => W(J));
    {
      const J = (0, sha256_1.hashSha256)(re);
      return W(J);
    }
  }
  verifyExpanded(B, L) {
    const K = [B.header.join("."), base64url$1.encode(B.payload)].join(".");
    let re = !0;
    const W = (J) => (B.signature.map((ne) => {
      const ie = this.cryptoClient.loadSignature(ne);
      this.cryptoClient.verifyHash(J, ie, this.rawPublicKey) || (re = !1);
    }), re);
    if (L)
      return (0, sha256_1.hashSha256Async)(K).then((J) => W(J));
    {
      const J = (0, sha256_1.hashSha256)(K);
      return W(J);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(A) {
  if (typeof A == "string") {
    const B = A.split("."), L = JSON.parse(base64url.decode(B[0])), K = JSON.parse(base64url.decode(B[1])), re = B[2];
    return {
      header: L,
      payload: K,
      signature: re
    };
  } else if (typeof A == "object") {
    if (typeof A.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let B = A.payload;
    A.payload[0] !== "{" && (B = base64url.decode(B));
    const L = [];
    return A.header.map((K) => {
      const re = JSON.parse(base64url.decode(K));
      L.push(re);
    }), {
      header: L,
      payload: JSON.parse(B),
      signature: A.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(A) {
  var B = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(K, re, W, J) {
    J === void 0 && (J = W);
    var ne = Object.getOwnPropertyDescriptor(re, W);
    (!ne || ("get" in ne ? !re.__esModule : ne.writable || ne.configurable)) && (ne = { enumerable: !0, get: function() {
      return re[W];
    } }), Object.defineProperty(K, J, ne);
  } : function(K, re, W, J) {
    J === void 0 && (J = W), K[J] = re[W];
  }), L = commonjsGlobal && commonjsGlobal.__exportStar || function(K, re) {
    for (var W in K) W !== "default" && !Object.prototype.hasOwnProperty.call(re, W) && B(re, K, W);
  };
  Object.defineProperty(A, "__esModule", { value: !0 }), L(signer, A), L(verifier, A), L(decode$i, A), L(errors$1, A), L(cryptoClients, A);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const A = Array(256).fill(-1);
  for (let B = 0; B < r.length; ++B) A[r.charCodeAt(B)] = B;
})();
var s, i, o, h$1 = (s = function(A, B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bech32m = B.bech32 = void 0;
  const L = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", K = {};
  for (let ce = 0; ce < 32; ce++) {
    const ke = L.charAt(ce);
    K[ke] = ce;
  }
  function re(ce) {
    const ke = ce >> 25;
    return (33554431 & ce) << 5 ^ 996825010 & -(ke >> 0 & 1) ^ 642813549 & -(ke >> 1 & 1) ^ 513874426 & -(ke >> 2 & 1) ^ 1027748829 & -(ke >> 3 & 1) ^ 705979059 & -(ke >> 4 & 1);
  }
  function W(ce) {
    let ke = 1;
    for (let Ce = 0; Ce < ce.length; ++Ce) {
      const it = ce.charCodeAt(Ce);
      if (it < 33 || it > 126) return "Invalid prefix (" + ce + ")";
      ke = re(ke) ^ it >> 5;
    }
    ke = re(ke);
    for (let Ce = 0; Ce < ce.length; ++Ce) {
      const it = ce.charCodeAt(Ce);
      ke = re(ke) ^ 31 & it;
    }
    return ke;
  }
  function J(ce, ke, Ce, it) {
    let at = 0, lt = 0;
    const ht = (1 << Ce) - 1, dt = [];
    for (let bt = 0; bt < ce.length; ++bt) for (at = at << ke | ce[bt], lt += ke; lt >= Ce; ) lt -= Ce, dt.push(at >> lt & ht);
    if (it) lt > 0 && dt.push(at << Ce - lt & ht);
    else {
      if (lt >= ke) return "Excess padding";
      if (at << Ce - lt & ht) return "Non-zero padding";
    }
    return dt;
  }
  function ne(ce) {
    return J(ce, 8, 5, !0);
  }
  function ie(ce) {
    const ke = J(ce, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
  }
  function oe(ce) {
    const ke = J(ce, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
    throw new Error(ke);
  }
  function V(ce) {
    let ke;
    function Ce(it, at) {
      if (at = at || 90, it.length < 8) return it + " too short";
      if (it.length > at) return "Exceeds length limit";
      const lt = it.toLowerCase(), ht = it.toUpperCase();
      if (it !== lt && it !== ht) return "Mixed-case string " + it;
      const dt = (it = lt).lastIndexOf("1");
      if (dt === -1) return "No separator character for " + it;
      if (dt === 0) return "Missing prefix for " + it;
      const bt = it.slice(0, dt), vt = it.slice(dt + 1);
      if (vt.length < 6) return "Data too short";
      let Bt = W(bt);
      if (typeof Bt == "string") return Bt;
      const At = [];
      for (let Nt = 0; Nt < vt.length; ++Nt) {
        const $t = vt.charAt(Nt), mt = K[$t];
        if (mt === void 0) return "Unknown character " + $t;
        Bt = re(Bt) ^ mt, Nt + 6 >= vt.length || At.push(mt);
      }
      return Bt !== ke ? "Invalid checksum for " + it : { prefix: bt, words: At };
    }
    return ke = ce === "bech32" ? 1 : 734539939, { decodeUnsafe: function(it, at) {
      const lt = Ce(it, at);
      if (typeof lt == "object") return lt;
    }, decode: function(it, at) {
      const lt = Ce(it, at);
      if (typeof lt == "object") return lt;
      throw new Error(lt);
    }, encode: function(it, at, lt) {
      if (lt = lt || 90, it.length + 7 + at.length > lt) throw new TypeError("Exceeds length limit");
      let ht = W(it = it.toLowerCase());
      if (typeof ht == "string") throw new Error(ht);
      let dt = it + "1";
      for (let bt = 0; bt < at.length; ++bt) {
        const vt = at[bt];
        if (vt >> 5) throw new Error("Non 5-bit word");
        ht = re(ht) ^ vt, dt += L.charAt(vt);
      }
      for (let bt = 0; bt < 6; ++bt) ht = re(ht);
      ht ^= ke;
      for (let bt = 0; bt < 6; ++bt) dt += L.charAt(ht >> 5 * (5 - bt) & 31);
      return dt;
    }, toWords: ne, fromWordsUnsafe: ie, fromWords: oe };
  }
  B.bech32 = V("bech32"), B.bech32m = V("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(A) {
  A.mainnet = "mainnet", A.testnet = "testnet", A.regtest = "regtest";
})(x || (x = {})), function(A) {
  A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange";
object({
  type: literal(networkChangeEventName)
});
async function getProviderOrThrow(A) {
  var L;
  const B = await (A == null ? void 0 : A()) || ((L = window.XverseProviders) == null ? void 0 : L.BitcoinProvider) || window.BitcoinProvider;
  if (!B)
    throw new Error("No Bitcoin wallet installed");
  return B;
}
var BitcoinNetworkType = /* @__PURE__ */ ((A) => (A.Mainnet = "Mainnet", A.Testnet = "Testnet", A.Signet = "Signet", A))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number$1(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: RpcIdSchema
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var AddressPurpose = /* @__PURE__ */ ((A) => (A.Ordinals = "ordinals", A.Payment = "payment", A.Stacks = "stacks", A))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((A) => (A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr", A.stacks = "stacks", A))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType)
}), stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((A) => (A.ECDSA = "ECDSA", A.BIP322 = "BIP322", A))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = undefined_();
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    id: string()
  }).entries
});
var getRunesBalanceMethodName = "runes_getBalance", getRunesBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number$1(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getRunesBalanceMethodName),
    params: getRunesBalanceParamsSchema,
    id: string()
  }).entries
});
var transferRunesMethodName = "runes_transfer", transferRunesParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(transferRunesMethodName),
    params: transferRunesParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number$1(),
  limit: number$1()
});
object({
  total: number$1(),
  limit: number$1(),
  offset: number$1(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number$1(),
      offset: number$1(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var serializer = (A) => A.map((B) => {
  const { address: L, amountSats: K } = B;
  return {
    address: L,
    amountSats: K.toString()
  };
}), sendBtcTransaction = async (A) => {
  var J, ne;
  const B = await getProviderOrThrow(A.getProvider), { recipients: L, senderAddress: K, network: re, message: W } = A.payload;
  if (!L || L.length === 0)
    throw new Error("At least one recipient is required");
  if (L.some(
    (ie) => typeof ie.address != "string" || typeof ie.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!K)
    throw new Error("The sender address is required");
  try {
    const ie = serializer(L), oe = {
      network: re,
      senderAddress: K,
      message: W,
      recipients: ie
    }, V = lib$1.createUnsecuredToken(oe), ce = await B.sendBtcTransaction(V);
    (J = A.onFinish) == null || J.call(A, ce);
  } catch (ie) {
    console.error("[Connect] Error during send BTC transaction request", ie), (ne = A.onCancel) == null || ne.call(A);
  }
};
async function leatherRequest(A, B) {
  if (typeof window < "u" && window.LeatherProvider)
    try {
      return (await window.LeatherProvider.request(
        A,
        B
      )).result;
    } catch (L) {
      const K = L, { message: re } = K.error;
      throw K.error.code === 4001 ? new Error(re) : new Error(`Leather error: ${re}`);
    }
  else
    throw new Error("LeatherProvider not found");
}
var __classPrivateFieldGet = function(A, B, L, K) {
  if (L === "a" && !K) throw new TypeError("Private accessor was defined without a getter");
  if (typeof B == "function" ? A !== B || !K : !B.has(A)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return L === "m" ? K : L === "a" ? K.call(A) : K ? K.value : B.get(A);
}, __classPrivateFieldSet = function(A, B, L, K, re) {
  if (K === "m") throw new TypeError("Private method is not writable");
  if (K === "a" && !re) throw new TypeError("Private accessor was defined without a setter");
  if (typeof B == "function" ? A !== B || !re : !B.has(A)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return K === "a" ? re.call(A, L) : re ? re.value = L : B.set(A, L), L;
}, _AppReadyEvent_detail;
let wallets;
const registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(A) {
  cachedWalletsArray = void 0, registeredWalletsSet.add(A);
}
function removeRegisteredWallet(A) {
  cachedWalletsArray = void 0, registeredWalletsSet.delete(A);
}
const listeners = {};
function getWallets() {
  if (wallets || (wallets = Object.freeze({ register, get, on }), typeof window > "u"))
    return wallets;
  const A = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: B }) => B(A));
  } catch (B) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, B);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(A));
  } catch (B) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, B);
  }
  return wallets;
}
function register(...A) {
  var B;
  return A = A.filter((L) => !registeredWalletsSet.has(L)), A.length ? (A.forEach((L) => addRegisteredWallet(L)), (B = listeners.register) == null || B.forEach((L) => guard(() => L(...A))), function() {
    var K;
    A.forEach((re) => removeRegisteredWallet(re)), (K = listeners.unregister) == null || K.forEach((re) => guard(() => re(...A)));
  }) : () => {
  };
}
let cachedWalletsArray;
function get() {
  return cachedWalletsArray || (cachedWalletsArray = [...registeredWalletsSet]), cachedWalletsArray;
}
function on(A, B) {
  var L;
  return (L = listeners[A]) != null && L.push(B) || (listeners[A] = [B]), function() {
    var re;
    listeners[A] = (re = listeners[A]) == null ? void 0 : re.filter((W) => B !== W);
  };
}
function guard(A) {
  try {
    A();
  } catch (B) {
    console.error(B);
  }
}
class AppReadyEvent extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(B) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), _AppReadyEvent_detail.set(this, void 0), __classPrivateFieldSet(this, _AppReadyEvent_detail, B, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();
async function walletProvider() {
  const { get: A } = getWallets(), L = A().find(
    (K) => {
      var re, W;
      return K.name === "Magic Eden" && ((W = (re = K.features["sats-connect:"]) == null ? void 0 : re.provider) == null ? void 0 : W.isMagicEden) === !0;
    }
  );
  if (!L)
    throw new Error("Magic Eden wallet not found");
  return L.features["sats-connect:"].provider;
}
function useSendBtc() {
  const { wallet: A, network: B, address: L, publicKey: K } = useWallie(), [re, W] = useState(null), [J, ne] = useState(!1);
  return { send: useCallback(
    async (oe, V) => {
      ne(!0);
      try {
        if (W(null), !L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        if (A === "magiceden" || A === "xverse") {
          const ce = A === "magiceden" ? await walletProvider() : void 0;
          let ke = null;
          return ke = await new Promise((Ce, it) => {
            sendBtcTransaction({
              payload: {
                network: {
                  type: B === "mainnet" ? BitcoinNetworkType.Mainnet : BitcoinNetworkType.Testnet
                },
                message: "Sign Transaction",
                recipients: [
                  {
                    address: oe,
                    amountSats: BigInt(V)
                  }
                ],
                senderAddress: L.payments
              },
              getProvider: async () => ce,
              onFinish: (at) => {
                Ce(at);
              },
              onCancel: () => {
                it(new Error("Transaction canceled"));
              }
            });
          }), ne(!1), ke;
        }
        if (A === "unisat") {
          let ce = "";
          return ce = await window.unisat.sendBitcoin(oe, V, {}), ne(!1), ce;
        }
        if (A === "leather") {
          let ce = "";
          return ce = (await leatherRequest(
            "sendTransfer",
            {
              recipients: [
                {
                  address: oe,
                  amount: V
                }
              ],
              network: B
            }
          )).txid, ne(!1), ce;
        }
        if (A === "okx") {
          let ce = "";
          if (B === "mainnet")
            return ce = await window.okxwallet.bitcoin.sendBitcoin(
              oe,
              V,
              {}
            ), ne(!1), ce;
          if (B === "testnet")
            return ce = await window.okxwallet.bitcoinTestnet.sendBitcoin(
              oe,
              V,
              {}
            ), ne(!1), ce;
        }
        return ne(!1), null;
      } catch (ce) {
        return W(ce.message), ne(!1), null;
      }
    },
    [L, B, K, A]
  ), error: re, loading: J };
}
function useSendV2() {
  const { wallet: A, network: B, address: L, publicKey: K } = useWallie(), [re, W] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ne,
      satoshis: ie,
      feeRate: oe,
      relay: V = !0,
      rbf: ce = !1
    }) => {
      W(!0);
      try {
        if (!L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const ke = new PSBTBuilder({
          address: L.payments,
          feeRate: oe,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ne,
              value: ie
            }
          ]
        });
        ke.setRBF(ce), await ke.prepare();
        const Ce = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: ke.toPSBT()
        });
        if (V) {
          const at = await new JsonRpcDatasource({ network: B }).relay({ hex: Ce.hex });
          return W(!1), {
            txId: at
          };
        }
        return W(!1), {
          signedPsbtHex: Ce.hex
        };
      } catch (ke) {
        return W(!1), {
          error: ke.message
        };
      }
    },
    [L, B, K, A]
  ), isLoading: re };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(A) {
  if (A.length < 8 || A.length > 72 || A[0] !== 48 || A[1] !== A.length - 2 || A[2] !== 2) return !1;
  const B = A[3];
  if (B === 0 || 5 + B >= A.length || A[4 + B] !== 2) return !1;
  const L = A[5 + B];
  return !(L === 0 || 6 + B + L !== A.length || A[4] & 128 || B > 1 && A[4] === 0 && !(A[5] & 128) || A[B + 6] & 128 || L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128));
}
bip66.check = check$d;
function decode$h(A) {
  if (A.length < 8) throw new Error("DER sequence length is too short");
  if (A.length > 72) throw new Error("DER sequence length is too long");
  if (A[0] !== 48) throw new Error("Expected DER sequence");
  if (A[1] !== A.length - 2)
    throw new Error("DER sequence length is invalid");
  if (A[2] !== 2) throw new Error("Expected DER integer");
  const B = A[3];
  if (B === 0) throw new Error("R length is zero");
  if (5 + B >= A.length) throw new Error("R length is too long");
  if (A[4 + B] !== 2) throw new Error("Expected DER integer (2)");
  const L = A[5 + B];
  if (L === 0) throw new Error("S length is zero");
  if (6 + B + L !== A.length) throw new Error("S length is invalid");
  if (A[4] & 128) throw new Error("R value is negative");
  if (B > 1 && A[4] === 0 && !(A[5] & 128))
    throw new Error("R value excessively padded");
  if (A[B + 6] & 128) throw new Error("S value is negative");
  if (L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: A.slice(4, 4 + B),
    s: A.slice(6 + B)
  };
}
bip66.decode = decode$h;
function encode$i(A, B) {
  const L = A.length, K = B.length;
  if (L === 0) throw new Error("R length is zero");
  if (K === 0) throw new Error("S length is zero");
  if (L > 33) throw new Error("R length is too long");
  if (K > 33) throw new Error("S length is too long");
  if (A[0] & 128) throw new Error("R value is negative");
  if (B[0] & 128) throw new Error("S value is negative");
  if (L > 1 && A[0] === 0 && !(A[1] & 128))
    throw new Error("R value excessively padded");
  if (K > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("S value excessively padded");
  const re = Buffer$1.allocUnsafe(6 + L + K);
  return re[0] = 48, re[1] = re.length - 2, re[2] = 2, re[3] = A.length, A.copy(re, 4), re[4 + L] = 2, re[5 + L] = B.length, B.copy(re, 6 + L), re;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const A of Object.keys(OPS$7)) {
  const B = OPS$7[A];
  REVERSE_OPS[B] = A;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(A) {
  return A < ops_1.OPS.OP_PUSHDATA1 ? 1 : A <= 255 ? 2 : A <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(A, B, L) {
  const K = encodingLength$2(B);
  return K === 1 ? A.writeUInt8(B, L) : K === 2 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA1, L), A.writeUInt8(B, L + 1)) : K === 3 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA2, L), A.writeUInt16LE(B, L + 1)) : (A.writeUInt8(ops_1.OPS.OP_PUSHDATA4, L), A.writeUInt32LE(B, L + 1)), K;
}
push_data.encode = encode$h;
function decode$g(A, B) {
  const L = A.readUInt8(B);
  let K, re;
  if (L < ops_1.OPS.OP_PUSHDATA1)
    K = L, re = 1;
  else if (L === ops_1.OPS.OP_PUSHDATA1) {
    if (B + 2 > A.length) return null;
    K = A.readUInt8(B + 1), re = 2;
  } else if (L === ops_1.OPS.OP_PUSHDATA2) {
    if (B + 3 > A.length) return null;
    K = A.readUInt16LE(B + 1), re = 3;
  } else {
    if (B + 5 > A.length) return null;
    if (L !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    K = A.readUInt32LE(B + 1), re = 5;
  }
  return {
    opcode: L,
    number: K,
    size: re
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(A, B, L) {
  B = B || 4, L = L === void 0 ? !0 : L;
  const K = A.length;
  if (K === 0) return 0;
  if (K > B) throw new TypeError("Script number overflow");
  if (L && !(A[K - 1] & 127) && (K <= 1 || !(A[K - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (K === 5) {
    const W = A.readUInt32LE(0), J = A.readUInt8(4);
    return J & 128 ? -((J & -129) * 4294967296 + W) : J * 4294967296 + W;
  }
  let re = 0;
  for (let W = 0; W < K; ++W)
    re |= A[W] << 8 * W;
  return A[K - 1] & 128 ? -(re & ~(128 << 8 * (K - 1))) : re;
}
script_number.decode = decode$f;
function scriptNumSize(A) {
  return A > 2147483647 ? 5 : A > 8388607 ? 4 : A > 32767 ? 3 : A > 127 ? 2 : A > 0 ? 1 : 0;
}
function encode$g(A) {
  let B = Math.abs(A);
  const L = scriptNumSize(B), K = Buffer$1.allocUnsafe(L), re = A < 0;
  for (let W = 0; W < L; ++W)
    K.writeUInt8(B & 255, W), B >>= 8;
  return K[L - 1] & 128 ? K.writeUInt8(re ? 128 : 0, L - 1) : re && (K[L - 1] |= 128), K;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(A) {
    return A != null && A.constructor === Array;
  },
  Boolean: function(A) {
    return typeof A == "boolean";
  },
  Function: function(A) {
    return typeof A == "function";
  },
  Nil: function(A) {
    return A == null;
  },
  Number: function(A) {
    return typeof A == "number";
  },
  Object: function(A) {
    return typeof A == "object";
  },
  String: function(A) {
    return typeof A == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(A) {
    return A;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(A) {
  return A.name || A.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(A) {
  return native.Nil(A) ? "" : getTypeName(A.constructor);
}
function getValue(A) {
  return native.Function(A) ? "" : native.String(A) ? JSON.stringify(A) : A && native.Object(A) ? "" : A;
}
function captureStackTrace(A, B) {
  Error.captureStackTrace && Error.captureStackTrace(A, B);
}
function tfJSON$1(A) {
  return native.Function(A) ? A.toJSON ? A.toJSON() : getTypeName(A) : native.Array(A) ? "Array" : A && native.Object(A) ? "Object" : A !== void 0 ? A : "";
}
function tfErrorString(A, B, L) {
  var K = getValue(B);
  return "Expected " + tfJSON$1(A) + ", got" + (L !== "" ? " " + L : "") + (K !== "" ? " " + K : "");
}
function TfTypeError$1(A, B, L) {
  L = L || getValueTypeName$1(B), this.message = tfErrorString(A, B, L), captureStackTrace(this, TfTypeError$1), this.__type = A, this.__value = B, this.__valueTypeName = L;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(A, B, L, K, re) {
  var W = '" of type ';
  return B === "key" && (W = '" with key type '), tfErrorString('property "' + tfJSON$1(L) + W + tfJSON$1(A), K, re);
}
function TfPropertyTypeError$1(A, B, L, K, re) {
  A ? (re = re || getValueTypeName$1(K), this.message = tfPropertyErrorString(A, L, B, K, re)) : this.message = 'Unexpected property "' + B + '"', captureStackTrace(this, TfTypeError$1), this.__label = L, this.__property = B, this.__type = A, this.__value = K, this.__valueTypeName = re;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(A, B) {
  return new TfTypeError$1(A, {}, B);
}
function tfSubError$1(A, B, L) {
  return A instanceof TfPropertyTypeError$1 ? (B = B + "." + A.__property, A = new TfPropertyTypeError$1(
    A.__type,
    B,
    A.__label,
    A.__value,
    A.__valueTypeName
  )) : A instanceof TfTypeError$1 && (A = new TfPropertyTypeError$1(
    A.__type,
    B,
    L,
    A.__value,
    A.__valueTypeName
  )), captureStackTrace(A), A;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var A = native$1, B = errors;
  function L(At) {
    return Buffer$1.isBuffer(At);
  }
  function K(At) {
    return typeof At == "string" && /^([0-9a-f]{2})+$/i.test(At);
  }
  function re(At, Nt) {
    var $t = At.toJSON();
    function mt(xt) {
      if (!At(xt)) return !1;
      if (xt.length === Nt) return !0;
      throw B.tfCustomError($t + "(Length: " + Nt + ")", $t + "(Length: " + xt.length + ")");
    }
    return mt.toJSON = function() {
      return $t;
    }, mt;
  }
  var W = re.bind(null, A.Array), J = re.bind(null, L), ne = re.bind(null, K), ie = re.bind(null, A.String);
  function oe(At, Nt, $t) {
    $t = $t || A.Number;
    function mt(xt, wt) {
      return $t(xt, wt) && xt > At && xt < Nt;
    }
    return mt.toJSON = function() {
      return `${$t.toJSON()} between [${At}, ${Nt}]`;
    }, mt;
  }
  var V = Math.pow(2, 53) - 1;
  function ce(At) {
    return typeof At == "number" && isFinite(At);
  }
  function ke(At) {
    return At << 24 >> 24 === At;
  }
  function Ce(At) {
    return At << 16 >> 16 === At;
  }
  function it(At) {
    return (At | 0) === At;
  }
  function at(At) {
    return typeof At == "number" && At >= -V && At <= V && Math.floor(At) === At;
  }
  function lt(At) {
    return (At & 255) === At;
  }
  function ht(At) {
    return (At & 65535) === At;
  }
  function dt(At) {
    return At >>> 0 === At;
  }
  function bt(At) {
    return typeof At == "number" && At >= 0 && At <= V && Math.floor(At) === At;
  }
  var vt = {
    ArrayN: W,
    Buffer: L,
    BufferN: J,
    Finite: ce,
    Hex: K,
    HexN: ne,
    Int8: ke,
    Int16: Ce,
    Int32: it,
    Int53: at,
    Range: oe,
    StringN: ie,
    UInt8: lt,
    UInt16: ht,
    UInt32: dt,
    UInt53: bt
  };
  for (var Bt in vt)
    vt[Bt].toJSON = (function(At) {
      return At;
    }).bind(null, Bt);
  return extra = vt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function A(B, L) {
    B = compile(B), L = L || {};
    function K(re, W) {
      return !NATIVE.Array(re) || NATIVE.Nil(re) || L.minLength !== void 0 && re.length < L.minLength || L.maxLength !== void 0 && re.length > L.maxLength || L.length !== void 0 && re.length !== L.length ? !1 : re.every(function(J, ne) {
        try {
          return typeforce$3(B, J, W);
        } catch (ie) {
          throw tfSubError(ie, ne);
        }
      });
    }
    return K.toJSON = function() {
      var re = "[" + tfJSON(B) + "]";
      return L.length !== void 0 ? re += "{" + L.length + "}" : (L.minLength !== void 0 || L.maxLength !== void 0) && (re += "{" + (L.minLength === void 0 ? 0 : L.minLength) + "," + (L.maxLength === void 0 ? 1 / 0 : L.maxLength) + "}"), re;
    }, K;
  },
  maybe: function A(B) {
    B = compile(B);
    function L(K, re) {
      return NATIVE.Nil(K) || B(K, re, A);
    }
    return L.toJSON = function() {
      return "?" + tfJSON(B);
    }, L;
  },
  map: function A(B, L) {
    B = compile(B), L && (L = compile(L));
    function K(re, W) {
      if (!NATIVE.Object(re) || NATIVE.Nil(re)) return !1;
      for (var J in re) {
        try {
          L && typeforce$3(L, J, W);
        } catch (ie) {
          throw tfSubError(ie, J, "key");
        }
        try {
          var ne = re[J];
          typeforce$3(B, ne, W);
        } catch (ie) {
          throw tfSubError(ie, J);
        }
      }
      return !0;
    }
    return L ? K.toJSON = function() {
      return "{" + tfJSON(L) + ": " + tfJSON(B) + "}";
    } : K.toJSON = function() {
      return "{" + tfJSON(B) + "}";
    }, K;
  },
  object: function A(B) {
    var L = {};
    for (var K in B)
      L[K] = compile(B[K]);
    function re(W, J) {
      if (!NATIVE.Object(W) || NATIVE.Nil(W)) return !1;
      var ne;
      try {
        for (ne in L) {
          var ie = L[ne], oe = W[ne];
          typeforce$3(ie, oe, J);
        }
      } catch (V) {
        throw tfSubError(V, ne);
      }
      if (J) {
        for (ne in W)
          if (!L[ne])
            throw new TfPropertyTypeError(void 0, ne);
      }
      return !0;
    }
    return re.toJSON = function() {
      return tfJSON(L);
    }, re;
  },
  anyOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, re) {
      return B.some(function(W) {
        try {
          return typeforce$3(W, K, re);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join("|");
    }, L;
  },
  allOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, re) {
      return B.every(function(W) {
        try {
          return typeforce$3(W, K, re);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join(" & ");
    }, L;
  },
  quacksLike: function A(B) {
    function L(K) {
      return B === getValueTypeName(K);
    }
    return L.toJSON = function() {
      return B;
    }, L;
  },
  tuple: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, re) {
      return NATIVE.Nil(K) || NATIVE.Nil(K.length) || re && K.length !== B.length ? !1 : B.every(function(W, J) {
        try {
          return typeforce$3(W, K[J], re);
        } catch (ne) {
          throw tfSubError(ne, J);
        }
      });
    }
    return L.toJSON = function() {
      return "(" + B.map(tfJSON).join(", ") + ")";
    }, L;
  },
  value: function A(B) {
    function L(K) {
      return K === B;
    }
    return L.toJSON = function() {
      return B;
    }, L;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(A) {
  if (NATIVE.String(A))
    return A[0] === "?" ? TYPES.maybe(A.slice(1)) : NATIVE[A] || TYPES.quacksLike(A);
  if (A && NATIVE.Object(A)) {
    if (NATIVE.Array(A)) {
      if (A.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(A[0]);
    }
    return TYPES.object(A);
  } else if (NATIVE.Function(A))
    return A;
  return TYPES.value(A);
}
function typeforce$3(A, B, L, K) {
  if (NATIVE.Function(A)) {
    if (A(B, L)) return !0;
    throw new TfTypeError(K || A, B);
  }
  return typeforce$3(compile(A), B, L);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.oneOf = A.Null = A.BufferN = A.Function = A.UInt32 = A.UInt8 = A.tuple = A.maybe = A.Hex = A.Buffer = A.String = A.Boolean = A.Array = A.Number = A.Hash256bit = A.Hash160bit = A.Buffer256bit = A.isTaptree = A.isTapleaf = A.TAPLEAF_VERSION_MASK = A.Satoshi = A.isPoint = A.stacksEqual = A.typeforce = void 0;
  const B = require$$0$1;
  A.typeforce = typeforce_1;
  const L = B.Buffer.alloc(32, 0), K = B.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function re(V, ce) {
    return V.length !== ce.length ? !1 : V.every((ke, Ce) => ke.equals(ce[Ce]));
  }
  A.stacksEqual = re;
  function W(V) {
    if (!B.Buffer.isBuffer(V) || V.length < 33) return !1;
    const ce = V[0], ke = V.slice(1, 33);
    if (ke.compare(L) === 0 || ke.compare(K) >= 0) return !1;
    if ((ce === 2 || ce === 3) && V.length === 33)
      return !0;
    const Ce = V.slice(33);
    return Ce.compare(L) === 0 || Ce.compare(K) >= 0 ? !1 : ce === 4 && V.length === 65;
  }
  A.isPoint = W;
  const J = 21 * 1e14;
  function ne(V) {
    return A.typeforce.UInt53(V) && V <= J;
  }
  A.Satoshi = ne, A.TAPLEAF_VERSION_MASK = 254;
  function ie(V) {
    return !V || !("output" in V) || !B.Buffer.isBuffer(V.output) ? !1 : V.version !== void 0 ? (V.version & A.TAPLEAF_VERSION_MASK) === V.version : !0;
  }
  A.isTapleaf = ie;
  function oe(V) {
    return (0, A.Array)(V) ? V.length !== 2 ? !1 : V.every((ce) => oe(ce)) : ie(V);
  }
  A.isTaptree = oe, A.Buffer256bit = A.typeforce.BufferN(32), A.Hash160bit = A.typeforce.BufferN(20), A.Hash256bit = A.typeforce.BufferN(32), A.Number = A.typeforce.Number, A.Array = A.typeforce.Array, A.Boolean = A.typeforce.Boolean, A.String = A.typeforce.String, A.Buffer = A.typeforce.Buffer, A.Hex = A.typeforce.Hex, A.maybe = A.typeforce.maybe, A.tuple = A.typeforce.tuple, A.UInt8 = A.typeforce.UInt8, A.UInt32 = A.typeforce.UInt32, A.Function = A.typeforce.Function, A.BufferN = A.typeforce.BufferN, A.Null = A.typeforce.Null, A.oneOf = A.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const A = bip66, B = requireScript(), L = types$4, { typeforce: K } = L, re = Buffer$1.alloc(1, 0);
  function W(oe) {
    let V = 0;
    for (; oe[V] === 0; ) ++V;
    return V === oe.length ? re : (oe = oe.slice(V), oe[0] & 128 ? Buffer$1.concat([re, oe], 1 + oe.length) : oe);
  }
  function J(oe) {
    oe[0] === 0 && (oe = oe.slice(1));
    const V = Buffer$1.alloc(32, 0), ce = Math.max(0, 32 - oe.length);
    return oe.copy(V, ce), V;
  }
  function ne(oe) {
    const V = oe.readUInt8(oe.length - 1);
    if (!(0, B.isDefinedHashType)(V))
      throw new Error("Invalid hashType " + V);
    const ce = A.decode(oe.slice(0, -1)), ke = J(ce.r), Ce = J(ce.s);
    return { signature: Buffer$1.concat([ke, Ce], 64), hashType: V };
  }
  script_signature.decode = ne;
  function ie(oe, V) {
    if (K(
      {
        signature: L.BufferN(64),
        hashType: L.UInt8
      },
      { signature: oe, hashType: V }
    ), !(0, B.isDefinedHashType)(V))
      throw new Error("Invalid hashType " + V);
    const ce = Buffer$1.allocUnsafe(1);
    ce.writeUInt8(V, 0);
    const ke = W(oe.slice(0, 32)), Ce = W(oe.slice(32, 64));
    return Buffer$1.concat([A.encode(ke, Ce), ce]);
  }
  return script_signature.encode = ie, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.signature = A.number = A.isCanonicalScriptSignature = A.isDefinedHashType = A.isCanonicalPubKey = A.toStack = A.fromASM = A.toASM = A.decompile = A.compile = A.countNonPushOnlyOPs = A.isPushOnly = A.OPS = void 0;
    const B = bip66, L = ops;
    Object.defineProperty(A, "OPS", {
      enumerable: !0,
      get: function() {
        return L.OPS;
      }
    });
    const K = push_data, re = script_number, W = requireScript_signature(), J = types$4, { typeforce: ne } = J, ie = L.OPS.OP_RESERVED;
    function oe(mt) {
      return J.Number(mt) && (mt === L.OPS.OP_0 || mt >= L.OPS.OP_1 && mt <= L.OPS.OP_16 || mt === L.OPS.OP_1NEGATE);
    }
    function V(mt) {
      return J.Buffer(mt) || oe(mt);
    }
    function ce(mt) {
      return J.Array(mt) && mt.every(V);
    }
    A.isPushOnly = ce;
    function ke(mt) {
      return mt.length - mt.filter(V).length;
    }
    A.countNonPushOnlyOPs = ke;
    function Ce(mt) {
      if (mt.length === 0) return L.OPS.OP_0;
      if (mt.length === 1) {
        if (mt[0] >= 1 && mt[0] <= 16) return ie + mt[0];
        if (mt[0] === 129) return L.OPS.OP_1NEGATE;
      }
    }
    function it(mt) {
      return Buffer$1.isBuffer(mt);
    }
    function at(mt) {
      return J.Array(mt);
    }
    function lt(mt) {
      return Buffer$1.isBuffer(mt);
    }
    function ht(mt) {
      if (it(mt)) return mt;
      ne(J.Array, mt);
      const xt = mt.reduce((rt, pe) => lt(pe) ? pe.length === 1 && Ce(pe) !== void 0 ? rt + 1 : rt + K.encodingLength(pe.length) + pe.length : rt + 1, 0), wt = Buffer$1.allocUnsafe(xt);
      let Oe = 0;
      if (mt.forEach((rt) => {
        if (lt(rt)) {
          const pe = Ce(rt);
          if (pe !== void 0) {
            wt.writeUInt8(pe, Oe), Oe += 1;
            return;
          }
          Oe += K.encode(wt, rt.length, Oe), rt.copy(wt, Oe), Oe += rt.length;
        } else
          wt.writeUInt8(rt, Oe), Oe += 1;
      }), Oe !== wt.length) throw new Error("Could not decode chunks");
      return wt;
    }
    A.compile = ht;
    function dt(mt) {
      if (at(mt)) return mt;
      ne(J.Buffer, mt);
      const xt = [];
      let wt = 0;
      for (; wt < mt.length; ) {
        const Oe = mt[wt];
        if (Oe > L.OPS.OP_0 && Oe <= L.OPS.OP_PUSHDATA4) {
          const rt = K.decode(mt, wt);
          if (rt === null || (wt += rt.size, wt + rt.number > mt.length)) return null;
          const pe = mt.slice(wt, wt + rt.number);
          wt += rt.number;
          const nt = Ce(pe);
          nt !== void 0 ? xt.push(nt) : xt.push(pe);
        } else
          xt.push(Oe), wt += 1;
      }
      return xt;
    }
    A.decompile = dt;
    function bt(mt) {
      if (it(mt) && (mt = dt(mt)), !mt)
        throw new Error("Could not convert invalid chunks to ASM");
      return mt.map((xt) => {
        if (lt(xt)) {
          const wt = Ce(xt);
          if (wt === void 0) return xt.toString("hex");
          xt = wt;
        }
        return L.REVERSE_OPS[xt];
      }).join(" ");
    }
    A.toASM = bt;
    function vt(mt) {
      return ne(J.String, mt), ht(
        mt.split(" ").map((xt) => L.OPS[xt] !== void 0 ? L.OPS[xt] : (ne(J.Hex, xt), Buffer$1.from(xt, "hex")))
      );
    }
    A.fromASM = vt;
    function Bt(mt) {
      return mt = dt(mt), ne(ce, mt), mt.map((xt) => lt(xt) ? xt : xt === L.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : re.encode(xt - ie));
    }
    A.toStack = Bt;
    function At(mt) {
      return J.isPoint(mt);
    }
    A.isCanonicalPubKey = At;
    function Nt(mt) {
      const xt = mt & -129;
      return xt > 0 && xt < 4;
    }
    A.isDefinedHashType = Nt;
    function $t(mt) {
      return !Buffer$1.isBuffer(mt) || !Nt(mt[mt.length - 1]) ? !1 : B.check(mt.slice(0, -1));
    }
    A.isCanonicalScriptSignature = $t, A.number = re, A.signature = W;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(A, B, L) {
  Object.defineProperty(A, B, {
    configurable: !0,
    enumerable: !0,
    get() {
      const K = L.call(this);
      return this[B] = K, K;
    },
    set(K) {
      Object.defineProperty(this, B, {
        configurable: !0,
        enumerable: !0,
        value: K,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(A) {
  let B;
  return () => (B !== void 0 || (B = A()), B);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(A, B) {
  if (!A.data && !A.output) throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    A
  );
  const K = { name: "embed", network: A.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (A.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(A.data));
  }), lazy$6.prop(K, "data", () => {
    if (A.output)
      return bscript$9.decompile(A.output).slice(1);
  }), B.validate && A.output) {
    const re = bscript$9.decompile(A.output);
    if (re[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!re.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (A.data && !(0, types_1$7.stacksEqual)(A.data, K.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(K, A);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(A, B) {
  if (!A.input && !A.output && !(A.pubkeys && A.m !== void 0) && !A.signatures)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {});
  function L(ie) {
    return bscript$8.isCanonicalScriptSignature(ie) || (B.allowIncomplete && ie === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(L)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    A
  );
  const re = { network: A.network || networks_1$6.bitcoin };
  let W = [], J = !1;
  function ne(ie) {
    J || (J = !0, W = bscript$8.decompile(ie), re.m = W[0] - OP_INT_BASE, re.n = W[W.length - 2] - OP_INT_BASE, re.pubkeys = W.slice(1, -2));
  }
  if (lazy$5.prop(re, "output", () => {
    if (A.m && re.n && A.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + A.m,
          A.pubkeys,
          OP_INT_BASE + re.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(re, "m", () => {
    if (re.output)
      return ne(re.output), re.m;
  }), lazy$5.prop(re, "n", () => {
    if (re.pubkeys)
      return re.pubkeys.length;
  }), lazy$5.prop(re, "pubkeys", () => {
    if (A.output)
      return ne(A.output), re.pubkeys;
  }), lazy$5.prop(re, "signatures", () => {
    if (A.input)
      return bscript$8.decompile(A.input).slice(1);
  }), lazy$5.prop(re, "input", () => {
    if (A.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(A.signatures));
  }), lazy$5.prop(re, "witness", () => {
    if (re.input)
      return [];
  }), lazy$5.prop(re, "name", () => {
    if (!(!re.m || !re.n))
      return `p2ms(${re.m} of ${re.n})`;
  }), B.validate) {
    if (A.output) {
      if (ne(A.output), !types_1$6.typeforce.Number(W[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(W[W.length - 2]))
        throw new TypeError("Output is invalid");
      if (W[W.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (re.m <= 0 || re.n > 16 || re.m > re.n || re.n !== W.length - 3)
        throw new TypeError("Output is invalid");
      if (!re.pubkeys.every((ie) => (0, types_1$6.isPoint)(ie)))
        throw new TypeError("Output is invalid");
      if (A.m !== void 0 && A.m !== re.m) throw new TypeError("m mismatch");
      if (A.n !== void 0 && A.n !== re.n) throw new TypeError("n mismatch");
      if (A.pubkeys && !(0, types_1$6.stacksEqual)(A.pubkeys, re.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (A.pubkeys) {
      if (A.n !== void 0 && A.n !== A.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (re.n = A.pubkeys.length, re.n < re.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (A.signatures) {
      if (A.signatures.length < re.m)
        throw new TypeError("Not enough signatures provided");
      if (A.signatures.length > re.m)
        throw new TypeError("Too many signatures provided");
    }
    if (A.input) {
      if (A.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (re.signatures.length === 0 || !re.signatures.every(L))
        throw new TypeError("Input has invalid signature(s)");
      if (A.signatures && !(0, types_1$6.stacksEqual)(A.signatures, re.signatures))
        throw new TypeError("Signature mismatch");
      if (A.m !== void 0 && A.m !== A.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(re, A);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(A, B) {
  if (!A.input && !A.output && !A.pubkey && !A.input && !A.signature)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    A
  );
  const L = lazy$4.value(() => bscript$7.decompile(A.input)), re = { name: "p2pk", network: A.network || networks_1$5.bitcoin };
  if (lazy$4.prop(re, "output", () => {
    if (A.pubkey)
      return bscript$7.compile([A.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(re, "pubkey", () => {
    if (A.output)
      return A.output.slice(1, -1);
  }), lazy$4.prop(re, "signature", () => {
    if (A.input)
      return L()[0];
  }), lazy$4.prop(re, "input", () => {
    if (A.signature)
      return bscript$7.compile([A.signature]);
  }), lazy$4.prop(re, "witness", () => {
    if (re.input)
      return [];
  }), B.validate) {
    if (A.output) {
      if (A.output[A.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(re.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (A.pubkey && !A.pubkey.equals(re.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (A.signature && A.input && !A.input.equals(re.input))
      throw new TypeError("Signature mismatch");
    if (A.input) {
      if (L().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(re.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(re, A);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((A, B) => B)), Pi = /* @__PURE__ */ Id.map((A) => (9 * A + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let A = 0; A < 4; A++)
  for (let B of [idxL, idxR])
    B.push(B[A].map((L) => Rho[L]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((A) => new Uint8Array(A)), shiftsL = /* @__PURE__ */ idxL.map((A, B) => A.map((L) => shifts[B][L])), shiftsR = /* @__PURE__ */ idxR.map((A, B) => A.map((L) => shifts[B][L])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(A, B, L, K) {
  return A === 0 ? B ^ L ^ K : A === 1 ? B & L | ~B & K : A === 2 ? (B | ~L) ^ K : A === 3 ? B & K | L & ~K : B ^ (L | ~K);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: B, h1: L, h2: K, h3: re, h4: W } = this;
    return [B, L, K, re, W];
  }
  set(B, L, K, re, W) {
    this.h0 = B | 0, this.h1 = L | 0, this.h2 = K | 0, this.h3 = re | 0, this.h4 = W | 0;
  }
  process(B, L) {
    for (let Ce = 0; Ce < 16; Ce++, L += 4)
      R_BUF[Ce] = B.getUint32(L, !0);
    let K = this.h0 | 0, re = K, W = this.h1 | 0, J = W, ne = this.h2 | 0, ie = ne, oe = this.h3 | 0, V = oe, ce = this.h4 | 0, ke = ce;
    for (let Ce = 0; Ce < 5; Ce++) {
      const it = 4 - Ce, at = Kl[Ce], lt = Kr[Ce], ht = idxL[Ce], dt = idxR[Ce], bt = shiftsL[Ce], vt = shiftsR[Ce];
      for (let Bt = 0; Bt < 16; Bt++) {
        const At = (0, utils_js_1$1.rotl)(K + f(Ce, W, ne, oe) + R_BUF[ht[Bt]] + at, bt[Bt]) + ce | 0;
        K = ce, ce = oe, oe = (0, utils_js_1$1.rotl)(ne, 10) | 0, ne = W, W = At;
      }
      for (let Bt = 0; Bt < 16; Bt++) {
        const At = (0, utils_js_1$1.rotl)(re + f(it, J, ie, V) + R_BUF[dt[Bt]] + lt, vt[Bt]) + ke | 0;
        re = ke, ke = V, V = (0, utils_js_1$1.rotl)(ie, 10) | 0, ie = J, J = At;
      }
    }
    this.set(this.h1 + ne + V | 0, this.h2 + oe + ke | 0, this.h3 + ce + re | 0, this.h4 + K + J | 0, this.h0 + W + ie | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: re, E: W } = this;
    return [B, L, K, re, W];
  }
  set(B, L, K, re, W) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = re | 0, this.E = W | 0;
  }
  process(B, L) {
    for (let ie = 0; ie < 16; ie++, L += 4)
      SHA1_W[ie] = B.getUint32(L, !1);
    for (let ie = 16; ie < 80; ie++)
      SHA1_W[ie] = (0, utils_js_1.rotl)(SHA1_W[ie - 3] ^ SHA1_W[ie - 8] ^ SHA1_W[ie - 14] ^ SHA1_W[ie - 16], 1);
    let { A: K, B: re, C: W, D: J, E: ne } = this;
    for (let ie = 0; ie < 80; ie++) {
      let oe, V;
      ie < 20 ? (oe = (0, _md_js_1.Chi)(re, W, J), V = 1518500249) : ie < 40 ? (oe = re ^ W ^ J, V = 1859775393) : ie < 60 ? (oe = (0, _md_js_1.Maj)(re, W, J), V = 2400959708) : (oe = re ^ W ^ J, V = 3395469782);
      const ce = (0, utils_js_1.rotl)(K, 5) + oe + ne + V + SHA1_W[ie] | 0;
      ne = J, J = W, W = (0, utils_js_1.rotl)(re, 30), re = K, K = ce;
    }
    K = K + this.A | 0, re = re + this.B | 0, W = W + this.C | 0, J = J + this.D | 0, ne = ne + this.E | 0, this.set(K, re, W, J, ne);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.taggedHash = A.TAGGED_HASH_PREFIXES = A.TAGS = A.hash256 = A.hash160 = A.sha256 = A.sha1 = A.ripemd160 = void 0;
  const B = ripemd160, L = sha1, K = sha256$4;
  function re(V) {
    return Buffer$1.from((0, B.ripemd160)(Uint8Array.from(V)));
  }
  A.ripemd160 = re;
  function W(V) {
    return Buffer$1.from((0, L.sha1)(Uint8Array.from(V)));
  }
  A.sha1 = W;
  function J(V) {
    return Buffer$1.from((0, K.sha256)(Uint8Array.from(V)));
  }
  A.sha256 = J;
  function ne(V) {
    return Buffer$1.from(
      (0, B.ripemd160)((0, K.sha256)(Uint8Array.from(V)))
    );
  }
  A.hash160 = ne;
  function ie(V) {
    return Buffer$1.from(
      (0, K.sha256)((0, K.sha256)(Uint8Array.from(V)))
    );
  }
  A.hash256 = ie, A.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], A.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function oe(V, ce) {
    return J(Buffer$1.concat([A.TAGGED_HASH_PREFIXES[V], ce]));
  }
  A.taggedHash = oe;
})(crypto$1);
function base$1(A) {
  if (A.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var B = new Uint8Array(256), L = 0; L < B.length; L++)
    B[L] = 255;
  for (var K = 0; K < A.length; K++) {
    var re = A.charAt(K), W = re.charCodeAt(0);
    if (B[W] !== 255)
      throw new TypeError(re + " is ambiguous");
    B[W] = K;
  }
  var J = A.length, ne = A.charAt(0), ie = Math.log(J) / Math.log(256), oe = Math.log(256) / Math.log(J);
  function V(Ce) {
    if (Ce instanceof Uint8Array || (ArrayBuffer.isView(Ce) ? Ce = new Uint8Array(Ce.buffer, Ce.byteOffset, Ce.byteLength) : Array.isArray(Ce) && (Ce = Uint8Array.from(Ce))), !(Ce instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ce.length === 0)
      return "";
    for (var it = 0, at = 0, lt = 0, ht = Ce.length; lt !== ht && Ce[lt] === 0; )
      lt++, it++;
    for (var dt = (ht - lt) * oe + 1 >>> 0, bt = new Uint8Array(dt); lt !== ht; ) {
      for (var vt = Ce[lt], Bt = 0, At = dt - 1; (vt !== 0 || Bt < at) && At !== -1; At--, Bt++)
        vt += 256 * bt[At] >>> 0, bt[At] = vt % J >>> 0, vt = vt / J >>> 0;
      if (vt !== 0)
        throw new Error("Non-zero carry");
      at = Bt, lt++;
    }
    for (var Nt = dt - at; Nt !== dt && bt[Nt] === 0; )
      Nt++;
    for (var $t = ne.repeat(it); Nt < dt; ++Nt)
      $t += A.charAt(bt[Nt]);
    return $t;
  }
  function ce(Ce) {
    if (typeof Ce != "string")
      throw new TypeError("Expected String");
    if (Ce.length === 0)
      return new Uint8Array();
    for (var it = 0, at = 0, lt = 0; Ce[it] === ne; )
      at++, it++;
    for (var ht = (Ce.length - it) * ie + 1 >>> 0, dt = new Uint8Array(ht); Ce[it]; ) {
      var bt = B[Ce.charCodeAt(it)];
      if (bt === 255)
        return;
      for (var vt = 0, Bt = ht - 1; (bt !== 0 || vt < lt) && Bt !== -1; Bt--, vt++)
        bt += J * dt[Bt] >>> 0, dt[Bt] = bt % 256 >>> 0, bt = bt / 256 >>> 0;
      if (bt !== 0)
        throw new Error("Non-zero carry");
      lt = vt, it++;
    }
    for (var At = ht - lt; At !== ht && dt[At] === 0; )
      At++;
    for (var Nt = new Uint8Array(at + (ht - At)), $t = at; At !== ht; )
      Nt[$t++] = dt[At++];
    return Nt;
  }
  function ke(Ce) {
    var it = ce(Ce);
    if (it)
      return it;
    throw new Error("Non-base" + J + " character");
  }
  return {
    encode: V,
    decodeUnsafe: ce,
    decode: ke
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(A) {
  function B(W) {
    var J = Uint8Array.from(W), ne = A(J), ie = J.length + 4, oe = new Uint8Array(ie);
    return oe.set(J, 0), oe.set(ne.subarray(0, 4), J.length), base58.encode(oe, ie);
  }
  function L(W) {
    var J = W.slice(0, -4), ne = W.slice(-4), ie = A(J);
    if (!(ne[0] ^ ie[0] | ne[1] ^ ie[1] | ne[2] ^ ie[2] | ne[3] ^ ie[3]))
      return J;
  }
  function K(W) {
    var J = base58.decodeUnsafe(W);
    if (J)
      return L(J);
  }
  function re(W) {
    var J = base58.decode(W), ne = L(J);
    if (!ne) throw new Error("Invalid checksum");
    return ne;
  }
  return {
    encode: B,
    decode: re,
    decodeUnsafe: K
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(A) {
  return sha256(sha256(A));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    A
  );
  const L = lazy$3.value(() => {
    const J = Buffer$1.from(bs58check$1.decode(A.address)), ne = J.readUInt8(0), ie = J.slice(1);
    return { version: ne, hash: ie };
  }), K = lazy$3.value(() => bscript$6.decompile(A.input)), re = A.network || networks_1$4.bitcoin, W = { name: "p2pkh", network: re };
  if (lazy$3.prop(W, "address", () => {
    if (!W.hash) return;
    const J = Buffer$1.allocUnsafe(21);
    return J.writeUInt8(re.pubKeyHash, 0), W.hash.copy(J, 1), bs58check$1.encode(J);
  }), lazy$3.prop(W, "hash", () => {
    if (A.output) return A.output.slice(3, 23);
    if (A.address) return L().hash;
    if (A.pubkey || W.pubkey) return bcrypto$5.hash160(A.pubkey || W.pubkey);
  }), lazy$3.prop(W, "output", () => {
    if (W.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        W.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(W, "pubkey", () => {
    if (A.input)
      return K()[1];
  }), lazy$3.prop(W, "signature", () => {
    if (A.input)
      return K()[0];
  }), lazy$3.prop(W, "input", () => {
    if (A.pubkey && A.signature)
      return bscript$6.compile([A.signature, A.pubkey]);
  }), lazy$3.prop(W, "witness", () => {
    if (W.input)
      return [];
  }), B.validate) {
    let J = Buffer$1.from([]);
    if (A.address) {
      if (L().version !== re.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (L().hash.length !== 20) throw new TypeError("Invalid address");
      J = L().hash;
    }
    if (A.hash) {
      if (J.length > 0 && !J.equals(A.hash))
        throw new TypeError("Hash mismatch");
      J = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 25 || A.output[0] !== OPS$3.OP_DUP || A.output[1] !== OPS$3.OP_HASH160 || A.output[2] !== 20 || A.output[23] !== OPS$3.OP_EQUALVERIFY || A.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(3, 23);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.pubkey) {
      const ne = bcrypto$5.hash160(A.pubkey);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.input) {
      const ne = K();
      if (ne.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ne[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ne[1]))
        throw new TypeError("Input has invalid pubkey");
      if (A.signature && !A.signature.equals(ne[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(ne[1]))
        throw new TypeError("Pubkey mismatch");
      const ie = bcrypto$5.hash160(ne[1]);
      if (J.length > 0 && !J.equals(ie))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(W, A);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    A
  );
  let L = A.network;
  L || (L = A.redeem && A.redeem.network || networks_1$3.bitcoin);
  const K = { network: L }, re = lazy$2.value(() => {
    const ne = Buffer$1.from(bs58check.decode(A.address)), ie = ne.readUInt8(0), oe = ne.slice(1);
    return { version: ie, hash: oe };
  }), W = lazy$2.value(() => bscript$5.decompile(A.input)), J = lazy$2.value(() => {
    const ne = W(), ie = ne[ne.length - 1];
    return {
      network: L,
      output: ie === OPS$2.OP_FALSE ? Buffer$1.from([]) : ie,
      input: bscript$5.compile(ne.slice(0, -1)),
      witness: A.witness || []
    };
  });
  if (lazy$2.prop(K, "address", () => {
    if (!K.hash) return;
    const ne = Buffer$1.allocUnsafe(21);
    return ne.writeUInt8(K.network.scriptHash, 0), K.hash.copy(ne, 1), bs58check.encode(ne);
  }), lazy$2.prop(K, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return re().hash;
    if (K.redeem && K.redeem.output) return bcrypto$4.hash160(K.redeem.output);
  }), lazy$2.prop(K, "output", () => {
    if (K.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, K.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(K, "redeem", () => {
    if (A.input)
      return J();
  }), lazy$2.prop(K, "input", () => {
    if (!(!A.redeem || !A.redeem.input || !A.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(A.redeem.input), A.redeem.output)
      );
  }), lazy$2.prop(K, "witness", () => {
    if (K.redeem && K.redeem.witness) return K.redeem.witness;
    if (K.input) return [];
  }), lazy$2.prop(K, "name", () => {
    const ne = ["p2sh"];
    return K.redeem !== void 0 && K.redeem.name !== void 0 && ne.push(K.redeem.name), ne.join("-");
  }), B.validate) {
    let ne = Buffer$1.from([]);
    if (A.address) {
      if (re().version !== L.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (re().hash.length !== 20) throw new TypeError("Invalid address");
      ne = re().hash;
    }
    if (A.hash) {
      if (ne.length > 0 && !ne.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ne = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 23 || A.output[0] !== OPS$2.OP_HASH160 || A.output[1] !== 20 || A.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const oe = A.output.slice(2, 22);
      if (ne.length > 0 && !ne.equals(oe))
        throw new TypeError("Hash mismatch");
      ne = oe;
    }
    const ie = (oe) => {
      if (oe.output) {
        const V = bscript$5.decompile(oe.output);
        if (!V || V.length < 1)
          throw new TypeError("Redeem.output too short");
        if (oe.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(V) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ce = bcrypto$4.hash160(oe.output);
        if (ne.length > 0 && !ne.equals(ce))
          throw new TypeError("Hash mismatch");
        ne = ce;
      }
      if (oe.input) {
        const V = oe.input.length > 0, ce = oe.witness && oe.witness.length > 0;
        if (!V && !ce) throw new TypeError("Empty input");
        if (V && ce)
          throw new TypeError("Input and witness provided");
        if (V) {
          const ke = bscript$5.decompile(oe.input);
          if (!bscript$5.isPushOnly(ke))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (A.input) {
      const oe = W();
      if (!oe || oe.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(J().output))
        throw new TypeError("Input is invalid");
      ie(J());
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== L)
        throw new TypeError("Network mismatch");
      if (A.input) {
        const oe = J();
        if (A.redeem.output && !A.redeem.output.equals(oe.output))
          throw new TypeError("Redeem.output mismatch");
        if (A.redeem.input && !A.redeem.input.equals(oe.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ie(A.redeem);
    }
    if (A.witness && A.redeem && A.redeem.witness && !(0, types_1$3.stacksEqual)(A.redeem.witness, A.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(K, A);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let A = 0; A < ALPHABET.length; A++) {
  const B = ALPHABET.charAt(A);
  ALPHABET_MAP[B] = A;
}
function polymodStep(A) {
  const B = A >> 25;
  return (A & 33554431) << 5 ^ -(B >> 0 & 1) & 996825010 ^ -(B >> 1 & 1) & 642813549 ^ -(B >> 2 & 1) & 513874426 ^ -(B >> 3 & 1) & 1027748829 ^ -(B >> 4 & 1) & 705979059;
}
function prefixChk(A) {
  let B = 1;
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    if (K < 33 || K > 126)
      return "Invalid prefix (" + A + ")";
    B = polymodStep(B) ^ K >> 5;
  }
  B = polymodStep(B);
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    B = polymodStep(B) ^ K & 31;
  }
  return B;
}
function convert$2(A, B, L, K) {
  let re = 0, W = 0;
  const J = (1 << L) - 1, ne = [];
  for (let ie = 0; ie < A.length; ++ie)
    for (re = re << B | A[ie], W += B; W >= L; )
      W -= L, ne.push(re >> W & J);
  if (K)
    W > 0 && ne.push(re << L - W & J);
  else {
    if (W >= B)
      return "Excess padding";
    if (re << L - W & J)
      return "Non-zero padding";
  }
  return ne;
}
function toWords(A) {
  return convert$2(A, 8, 5, !0);
}
function fromWordsUnsafe(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
}
function fromWords(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
  throw new Error(B);
}
function getLibraryFromEncoding(A) {
  let B;
  A === "bech32" ? B = 1 : B = 734539939;
  function L(J, ne, ie) {
    if (ie = ie || 90, J.length + 7 + ne.length > ie)
      throw new TypeError("Exceeds length limit");
    J = J.toLowerCase();
    let oe = prefixChk(J);
    if (typeof oe == "string")
      throw new Error(oe);
    let V = J + "1";
    for (let ce = 0; ce < ne.length; ++ce) {
      const ke = ne[ce];
      if (ke >> 5)
        throw new Error("Non 5-bit word");
      oe = polymodStep(oe) ^ ke, V += ALPHABET.charAt(ke);
    }
    for (let ce = 0; ce < 6; ++ce)
      oe = polymodStep(oe);
    oe ^= B;
    for (let ce = 0; ce < 6; ++ce) {
      const ke = oe >> (5 - ce) * 5 & 31;
      V += ALPHABET.charAt(ke);
    }
    return V;
  }
  function K(J, ne) {
    if (ne = ne || 90, J.length < 8)
      return J + " too short";
    if (J.length > ne)
      return "Exceeds length limit";
    const ie = J.toLowerCase(), oe = J.toUpperCase();
    if (J !== ie && J !== oe)
      return "Mixed-case string " + J;
    J = ie;
    const V = J.lastIndexOf("1");
    if (V === -1)
      return "No separator character for " + J;
    if (V === 0)
      return "Missing prefix for " + J;
    const ce = J.slice(0, V), ke = J.slice(V + 1);
    if (ke.length < 6)
      return "Data too short";
    let Ce = prefixChk(ce);
    if (typeof Ce == "string")
      return Ce;
    const it = [];
    for (let at = 0; at < ke.length; ++at) {
      const lt = ke.charAt(at), ht = ALPHABET_MAP[lt];
      if (ht === void 0)
        return "Unknown character " + lt;
      Ce = polymodStep(Ce) ^ ht, !(at + 6 >= ke.length) && it.push(ht);
    }
    return Ce !== B ? "Invalid checksum for " + J : { prefix: ce, words: it };
  }
  function re(J, ne) {
    const ie = K(J, ne);
    if (typeof ie == "object")
      return ie;
  }
  function W(J, ne) {
    const ie = K(J, ne);
    if (typeof ie == "object")
      return ie;
    throw new Error(ie);
  }
  return {
    decodeUnsafe: re,
    decode: W,
    encode: L,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy$1.value(() => {
    const W = bech32_1$1.bech32.decode(A.address), J = W.words.shift(), ne = bech32_1$1.bech32.fromWords(W.words);
    return {
      version: J,
      prefix: W.prefix,
      data: Buffer$1.from(ne)
    };
  }), K = A.network || networks_1$2.bitcoin, re = { name: "p2wpkh", network: K };
  if (lazy$1.prop(re, "address", () => {
    if (!re.hash) return;
    const W = bech32_1$1.bech32.toWords(re.hash);
    return W.unshift(0), bech32_1$1.bech32.encode(K.bech32, W);
  }), lazy$1.prop(re, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return L().data;
    if (A.pubkey || re.pubkey) return bcrypto$3.hash160(A.pubkey || re.pubkey);
  }), lazy$1.prop(re, "output", () => {
    if (re.hash)
      return bscript$4.compile([OPS$1.OP_0, re.hash]);
  }), lazy$1.prop(re, "pubkey", () => {
    if (A.pubkey) return A.pubkey;
    if (A.witness)
      return A.witness[1];
  }), lazy$1.prop(re, "signature", () => {
    if (A.witness)
      return A.witness[0];
  }), lazy$1.prop(re, "input", () => {
    if (re.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(re, "witness", () => {
    if (A.pubkey && A.signature)
      return [A.signature, A.pubkey];
  }), B.validate) {
    let W = Buffer$1.from([]);
    if (A.address) {
      if (K && K.bech32 !== L().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 20)
        throw new TypeError("Invalid address data");
      W = L().data;
    }
    if (A.hash) {
      if (W.length > 0 && !W.equals(A.hash))
        throw new TypeError("Hash mismatch");
      W = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 22 || A.output[0] !== OPS$1.OP_0 || A.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (W.length > 0 && !W.equals(A.output.slice(2)))
        throw new TypeError("Hash mismatch");
      W = A.output.slice(2);
    }
    if (A.pubkey) {
      const J = bcrypto$3.hash160(A.pubkey);
      if (W.length > 0 && !W.equals(J))
        throw new TypeError("Hash mismatch");
      if (W = J, !(0, types_1$2.isPoint)(A.pubkey) || A.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (A.witness) {
      if (A.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(A.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(A.witness[1]) || A.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (A.signature && !A.signature.equals(A.witness[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(A.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const J = bcrypto$3.hash160(A.witness[1]);
      if (W.length > 0 && !W.equals(J))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(re, A);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(A) {
  return !!(Buffer$1.isBuffer(A) && A.length === 65 && A[0] === 4 && (0, types_1$1.isPoint)(A));
}
function p2wsh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy.value(() => {
    const J = bech32_1.bech32.decode(A.address), ne = J.words.shift(), ie = bech32_1.bech32.fromWords(J.words);
    return {
      version: ne,
      prefix: J.prefix,
      data: Buffer$1.from(ie)
    };
  }), K = lazy.value(() => bscript$3.decompile(A.redeem.input));
  let re = A.network;
  re || (re = A.redeem && A.redeem.network || networks_1$1.bitcoin);
  const W = { network: re };
  if (lazy.prop(W, "address", () => {
    if (!W.hash) return;
    const J = bech32_1.bech32.toWords(W.hash);
    return J.unshift(0), bech32_1.bech32.encode(re.bech32, J);
  }), lazy.prop(W, "hash", () => {
    if (A.output) return A.output.slice(2);
    if (A.address) return L().data;
    if (W.redeem && W.redeem.output) return bcrypto$2.sha256(W.redeem.output);
  }), lazy.prop(W, "output", () => {
    if (W.hash)
      return bscript$3.compile([OPS.OP_0, W.hash]);
  }), lazy.prop(W, "redeem", () => {
    if (A.witness)
      return {
        output: A.witness[A.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: A.witness.slice(0, -1)
      };
  }), lazy.prop(W, "input", () => {
    if (W.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(W, "witness", () => {
    if (A.redeem && A.redeem.input && A.redeem.input.length > 0 && A.redeem.output && A.redeem.output.length > 0) {
      const J = bscript$3.toStack(K());
      return W.redeem = Object.assign({ witness: J }, A.redeem), W.redeem.input = EMPTY_BUFFER$1, [].concat(J, A.redeem.output);
    }
    if (A.redeem && A.redeem.output && A.redeem.witness)
      return [].concat(A.redeem.witness, A.redeem.output);
  }), lazy.prop(W, "name", () => {
    const J = ["p2wsh"];
    return W.redeem !== void 0 && W.redeem.name !== void 0 && J.push(W.redeem.name), J.join("-");
  }), B.validate) {
    let J = Buffer$1.from([]);
    if (A.address) {
      if (L().prefix !== re.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 32)
        throw new TypeError("Invalid address data");
      J = L().data;
    }
    if (A.hash) {
      if (J.length > 0 && !J.equals(A.hash))
        throw new TypeError("Hash mismatch");
      J = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 34 || A.output[0] !== OPS.OP_0 || A.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(2);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== re)
        throw new TypeError("Network mismatch");
      if (A.redeem.input && A.redeem.input.length > 0 && A.redeem.witness && A.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (A.redeem.output) {
        const ne = bscript$3.decompile(A.redeem.output);
        if (!ne || ne.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (A.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ne) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ie = bcrypto$2.sha256(A.redeem.output);
        if (J.length > 0 && !J.equals(ie))
          throw new TypeError("Hash mismatch");
        J = ie;
      }
      if (A.redeem.input && !bscript$3.isPushOnly(K()))
        throw new TypeError("Non push-only scriptSig");
      if (A.witness && A.redeem.witness && !(0, types_1$1.stacksEqual)(A.witness, A.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (A.redeem.input && K().some(chunkHasUncompressedPubkey) || A.redeem.output && (bscript$3.decompile(A.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (A.witness && A.witness.length > 0) {
      const ne = A.witness[A.witness.length - 1];
      if (A.redeem && A.redeem.output && !A.redeem.output.equals(ne))
        throw new TypeError("Witness and redeem.output mismatch");
      if (A.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ne) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(W, A);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(A) {
  A ? A !== _ECCLIB_CACHE.eccLib && (verifyEcc(A), _ECCLIB_CACHE.eccLib = A) : _ECCLIB_CACHE.eccLib = A;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (A) => Buffer$1.from(A, "hex");
function verifyEcc(A) {
  assert(typeof A.isXOnlyPoint == "function"), assert(
    A.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    A.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof A.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((B) => {
    const L = A.xOnlyPointAddTweak(h(B.pubkey), h(B.tweak));
    B.result === null ? assert(L === null) : (assert(L !== null), assert(L.parity === B.parity), assert(Buffer$1.from(L.xOnlyPubkey).equals(h(B.result))));
  });
}
function assert(A) {
  if (!A) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER$1 || A % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(A, B, L) {
  if (checkUInt53$1(A), B || (B = Buffer.allocUnsafe(encodingLength$1(A))), !Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), encode$f.bytes = 1) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), encode$f.bytes = 3) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), encode$f.bytes = 5) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), encode$f.bytes = 9), B;
}
function decode$e(A, B) {
  if (!Buffer.isBuffer(A)) throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  var L = A.readUInt8(B);
  if (L < 253)
    return decode$e.bytes = 1, L;
  if (L === 253)
    return decode$e.bytes = 3, A.readUInt16LE(B + 1);
  if (L === 254)
    return decode$e.bytes = 5, A.readUInt32LE(B + 1);
  decode$e.bytes = 9;
  var K = A.readUInt32LE(B + 1), re = A.readUInt32LE(B + 5), W = re * 4294967296 + K;
  return checkUInt53$1(W), W;
}
function encodingLength$1(A) {
  return checkUInt53$1(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint$1(K + L, 9007199254740991), K + L;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(A, B, L) {
  return verifuint$1(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(A) {
  const B = Buffer$1.allocUnsafe(A.length);
  return A.copy(B), B;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(B) {
    return new BufferWriter(Buffer$1.alloc(B));
  }
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  writeUInt8(B) {
    this.offset = this.buffer.writeUInt8(B, this.offset);
  }
  writeInt32(B) {
    this.offset = this.buffer.writeInt32LE(B, this.offset);
  }
  writeUInt32(B) {
    this.offset = this.buffer.writeUInt32LE(B, this.offset);
  }
  writeUInt64(B) {
    this.offset = writeUInt64LE$1(this.buffer, B, this.offset);
  }
  writeVarInt(B) {
    varuint$7.encode(B, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(B) {
    if (this.buffer.length < this.offset + B.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += B.copy(this.buffer, this.offset);
  }
  writeVarSlice(B) {
    this.writeVarInt(B.length), this.writeSlice(B);
  }
  writeVector(B) {
    this.writeVarInt(B.length), B.forEach((L) => this.writeVarSlice(L));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  readUInt8() {
    const B = this.buffer.readUInt8(this.offset);
    return this.offset++, B;
  }
  readInt32() {
    const B = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt32() {
    const B = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt64() {
    const B = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, B;
  }
  readVarInt() {
    const B = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, B;
  }
  readSlice(B) {
    if (this.buffer.length < this.offset + B)
      throw new Error("Cannot read slice out of bounds");
    const L = this.buffer.slice(this.offset, this.offset + B);
    return this.offset += B, L;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const B = this.readVarInt(), L = [];
    for (let K = 0; K < B; K++) L.push(this.readVarSlice());
    return L;
  }
}
bufferutils.BufferReader = BufferReader;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.tweakKey = A.tapTweakHash = A.tapleafHash = A.findScriptPath = A.toHashTree = A.rootHashFromPath = A.MAX_TAPTREE_DEPTH = A.LEAF_VERSION_TAPSCRIPT = void 0;
  const B = require$$0$1, L = ecc_lib, K = crypto$1, re = bufferutils, W = types$4;
  A.LEAF_VERSION_TAPSCRIPT = 192, A.MAX_TAPTREE_DEPTH = 128;
  const J = (at) => "left" in at && "right" in at;
  function ne(at, lt) {
    if (at.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${at.length}, expected min 33.`
      );
    const ht = (at.length - 33) / 32;
    let dt = lt;
    for (let bt = 0; bt < ht; bt++) {
      const vt = at.slice(33 + 32 * bt, 65 + 32 * bt);
      dt.compare(vt) < 0 ? dt = Ce(dt, vt) : dt = Ce(vt, dt);
    }
    return dt;
  }
  A.rootHashFromPath = ne;
  function ie(at) {
    if ((0, W.isTapleaf)(at))
      return { hash: V(at) };
    const lt = [ie(at[0]), ie(at[1])];
    lt.sort((bt, vt) => bt.hash.compare(vt.hash));
    const [ht, dt] = lt;
    return {
      hash: Ce(ht.hash, dt.hash),
      left: ht,
      right: dt
    };
  }
  A.toHashTree = ie;
  function oe(at, lt) {
    if (J(at)) {
      const ht = oe(at.left, lt);
      if (ht !== void 0) return [...ht, at.right.hash];
      const dt = oe(at.right, lt);
      if (dt !== void 0) return [...dt, at.left.hash];
    } else if (at.hash.equals(lt))
      return [];
  }
  A.findScriptPath = oe;
  function V(at) {
    const lt = at.version || A.LEAF_VERSION_TAPSCRIPT;
    return K.taggedHash(
      "TapLeaf",
      B.Buffer.concat([
        B.Buffer.from([lt]),
        it(at.output)
      ])
    );
  }
  A.tapleafHash = V;
  function ce(at, lt) {
    return K.taggedHash(
      "TapTweak",
      B.Buffer.concat(lt ? [at, lt] : [at])
    );
  }
  A.tapTweakHash = ce;
  function ke(at, lt) {
    if (!B.Buffer.isBuffer(at) || at.length !== 32 || lt && lt.length !== 32) return null;
    const ht = ce(at, lt), dt = (0, L.getEccLib)().xOnlyPointAddTweak(at, ht);
    return !dt || dt.xOnlyPubkey === null ? null : {
      parity: dt.parity,
      x: B.Buffer.from(dt.xOnlyPubkey)
    };
  }
  A.tweakKey = ke;
  function Ce(at, lt) {
    return K.taggedHash("TapBranch", B.Buffer.concat([at, lt]));
  }
  function it(at) {
    const lt = re.varuint.encodingLength(at.length), ht = B.Buffer.allocUnsafe(lt);
    return re.varuint.encode(at.length, ht), B.Buffer.concat([ht, at]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const A = require$$0$1, B = networks, L = requireScript(), K = types$4, re = ecc_lib, W = bip341, J = lazy$7, ne = dist, ie = requireAddress(), oe = L.OPS, V = 1, ce = 80;
  function ke(Ce, it) {
    if (!Ce.address && !Ce.output && !Ce.pubkey && !Ce.internalPubkey && !(Ce.witness && Ce.witness.length > 1))
      throw new TypeError("Not enough data");
    it = Object.assign({ validate: !0 }, it || {}), (0, K.typeforce)(
      {
        address: K.typeforce.maybe(K.typeforce.String),
        input: K.typeforce.maybe(K.typeforce.BufferN(0)),
        network: K.typeforce.maybe(K.typeforce.Object),
        output: K.typeforce.maybe(K.typeforce.BufferN(34)),
        internalPubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        hash: K.typeforce.maybe(K.typeforce.BufferN(32)),
        pubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        signature: K.typeforce.maybe(
          K.typeforce.anyOf(
            K.typeforce.BufferN(64),
            K.typeforce.BufferN(65)
          )
        ),
        witness: K.typeforce.maybe(
          K.typeforce.arrayOf(K.typeforce.Buffer)
        ),
        scriptTree: K.typeforce.maybe(K.isTaptree),
        redeem: K.typeforce.maybe({
          output: K.typeforce.maybe(K.typeforce.Buffer),
          redeemVersion: K.typeforce.maybe(K.typeforce.Number),
          witness: K.typeforce.maybe(
            K.typeforce.arrayOf(K.typeforce.Buffer)
          )
        }),
        redeemVersion: K.typeforce.maybe(K.typeforce.Number)
      },
      Ce
    );
    const at = J.value(() => (0, ie.fromBech32)(Ce.address)), lt = J.value(() => {
      if (!(!Ce.witness || !Ce.witness.length))
        return Ce.witness.length >= 2 && Ce.witness[Ce.witness.length - 1][0] === ce ? Ce.witness.slice(0, -1) : Ce.witness.slice();
    }), ht = J.value(() => {
      if (Ce.scriptTree) return (0, W.toHashTree)(Ce.scriptTree);
      if (Ce.hash) return { hash: Ce.hash };
    }), dt = Ce.network || B.bitcoin, bt = { name: "p2tr", network: dt };
    if (J.prop(bt, "address", () => {
      if (!bt.pubkey) return;
      const vt = ne.bech32m.toWords(bt.pubkey);
      return vt.unshift(V), ne.bech32m.encode(dt.bech32, vt);
    }), J.prop(bt, "hash", () => {
      const vt = ht();
      if (vt) return vt.hash;
      const Bt = lt();
      if (Bt && Bt.length > 1) {
        const At = Bt[Bt.length - 1], Nt = At[0] & K.TAPLEAF_VERSION_MASK, $t = Bt[Bt.length - 2], mt = (0, W.tapleafHash)({
          output: $t,
          version: Nt
        });
        return (0, W.rootHashFromPath)(At, mt);
      }
      return null;
    }), J.prop(bt, "output", () => {
      if (bt.pubkey)
        return L.compile([oe.OP_1, bt.pubkey]);
    }), J.prop(bt, "redeemVersion", () => Ce.redeemVersion ? Ce.redeemVersion : Ce.redeem && Ce.redeem.redeemVersion !== void 0 && Ce.redeem.redeemVersion !== null ? Ce.redeem.redeemVersion : W.LEAF_VERSION_TAPSCRIPT), J.prop(bt, "redeem", () => {
      const vt = lt();
      if (!(!vt || vt.length < 2))
        return {
          output: vt[vt.length - 2],
          witness: vt.slice(0, -2),
          redeemVersion: vt[vt.length - 1][0] & K.TAPLEAF_VERSION_MASK
        };
    }), J.prop(bt, "pubkey", () => {
      if (Ce.pubkey) return Ce.pubkey;
      if (Ce.output) return Ce.output.slice(2);
      if (Ce.address) return at().data;
      if (bt.internalPubkey) {
        const vt = (0, W.tweakKey)(bt.internalPubkey, bt.hash);
        if (vt) return vt.x;
      }
    }), J.prop(bt, "internalPubkey", () => {
      if (Ce.internalPubkey) return Ce.internalPubkey;
      const vt = lt();
      if (vt && vt.length > 1)
        return vt[vt.length - 1].slice(1, 33);
    }), J.prop(bt, "signature", () => {
      if (Ce.signature) return Ce.signature;
      const vt = lt();
      if (!(!vt || vt.length !== 1))
        return vt[0];
    }), J.prop(bt, "witness", () => {
      if (Ce.witness) return Ce.witness;
      const vt = ht();
      if (vt && Ce.redeem && Ce.redeem.output && Ce.internalPubkey) {
        const Bt = (0, W.tapleafHash)({
          output: Ce.redeem.output,
          version: bt.redeemVersion
        }), At = (0, W.findScriptPath)(vt, Bt);
        if (!At) return;
        const Nt = (0, W.tweakKey)(Ce.internalPubkey, vt.hash);
        if (!Nt) return;
        const $t = A.Buffer.concat(
          [
            A.Buffer.from([bt.redeemVersion | Nt.parity]),
            Ce.internalPubkey
          ].concat(At)
        );
        return [Ce.redeem.output, $t];
      }
      if (Ce.signature) return [Ce.signature];
    }), it.validate) {
      let vt = A.Buffer.from([]);
      if (Ce.address) {
        if (dt && dt.bech32 !== at().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (at().version !== V)
          throw new TypeError("Invalid address version");
        if (at().data.length !== 32)
          throw new TypeError("Invalid address data");
        vt = at().data;
      }
      if (Ce.pubkey) {
        if (vt.length > 0 && !vt.equals(Ce.pubkey))
          throw new TypeError("Pubkey mismatch");
        vt = Ce.pubkey;
      }
      if (Ce.output) {
        if (Ce.output.length !== 34 || Ce.output[0] !== oe.OP_1 || Ce.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (vt.length > 0 && !vt.equals(Ce.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        vt = Ce.output.slice(2);
      }
      if (Ce.internalPubkey) {
        const Nt = (0, W.tweakKey)(Ce.internalPubkey, bt.hash);
        if (vt.length > 0 && !vt.equals(Nt.x))
          throw new TypeError("Pubkey mismatch");
        vt = Nt.x;
      }
      if (vt && vt.length && !(0, re.getEccLib)().isXOnlyPoint(vt))
        throw new TypeError("Invalid pubkey for p2tr");
      const Bt = ht();
      if (Ce.hash && Bt && !Ce.hash.equals(Bt.hash))
        throw new TypeError("Hash mismatch");
      if (Ce.redeem && Ce.redeem.output && Bt) {
        const Nt = (0, W.tapleafHash)({
          output: Ce.redeem.output,
          version: bt.redeemVersion
        });
        if (!(0, W.findScriptPath)(Bt, Nt))
          throw new TypeError("Redeem script not in tree");
      }
      const At = lt();
      if (Ce.redeem && bt.redeem) {
        if (Ce.redeem.redeemVersion && Ce.redeem.redeemVersion !== bt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Ce.redeem.output) {
          if (L.decompile(Ce.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (bt.redeem.output && !Ce.redeem.output.equals(bt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Ce.redeem.witness && bt.redeem.witness && !(0, K.stacksEqual)(Ce.redeem.witness, bt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (At && At.length)
        if (At.length === 1) {
          if (Ce.signature && !Ce.signature.equals(At[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Nt = At[At.length - 1];
          if (Nt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Nt.length}, expected min 33.`
            );
          if ((Nt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Nt.length} is incorrect!`
            );
          const $t = (Nt.length - 33) / 32;
          if ($t > 128)
            throw new TypeError(
              `The script path is too long. Got ${$t}, expected max 128.`
            );
          const mt = Nt.slice(1, 33);
          if (Ce.internalPubkey && !Ce.internalPubkey.equals(mt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, re.getEccLib)().isXOnlyPoint(mt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const xt = Nt[0] & K.TAPLEAF_VERSION_MASK, wt = At[At.length - 2], Oe = (0, W.tapleafHash)({
            output: wt,
            version: xt
          }), rt = (0, W.rootHashFromPath)(Nt, Oe), pe = (0, W.tweakKey)(mt, rt);
          if (!pe)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (vt.length && !vt.equals(pe.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (pe.parity !== (Nt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(bt, Ce);
  }
  return p2tr.p2tr = ke, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.p2tr = A.p2wsh = A.p2wpkh = A.p2sh = A.p2pkh = A.p2pk = A.p2ms = A.embed = void 0;
    const B = embed;
    Object.defineProperty(A, "embed", {
      enumerable: !0,
      get: function() {
        return B.p2data;
      }
    });
    const L = p2ms$1;
    Object.defineProperty(A, "p2ms", {
      enumerable: !0,
      get: function() {
        return L.p2ms;
      }
    });
    const K = p2pk$1;
    Object.defineProperty(A, "p2pk", {
      enumerable: !0,
      get: function() {
        return K.p2pk;
      }
    });
    const re = p2pkh$1;
    Object.defineProperty(A, "p2pkh", {
      enumerable: !0,
      get: function() {
        return re.p2pkh;
      }
    });
    const W = p2sh$1;
    Object.defineProperty(A, "p2sh", {
      enumerable: !0,
      get: function() {
        return W.p2sh;
      }
    });
    const J = p2wpkh$1;
    Object.defineProperty(A, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return J.p2wpkh;
      }
    });
    const ne = p2wsh$1;
    Object.defineProperty(A, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ne.p2wsh;
      }
    });
    const ie = requireP2tr();
    Object.defineProperty(A, "p2tr", {
      enumerable: !0,
      get: function() {
        return ie.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const A = networks, B = requirePayments(), L = requireScript(), K = types$4, re = dist, W = bs58check$2, J = 40, ne = 2, ie = 16, oe = 2, V = 80, ce = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function ke(bt, vt) {
    const Bt = bt.slice(2);
    if (Bt.length < ne || Bt.length > J)
      throw new TypeError("Invalid program length for segwit address");
    const At = bt[0] - V;
    if (At < oe || At > ie)
      throw new TypeError("Invalid version for segwit address");
    if (bt[1] !== Bt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(ce), lt(Bt, At, vt.bech32);
  }
  function Ce(bt) {
    const vt = Buffer$1.from(W.decode(bt));
    if (vt.length < 21) throw new TypeError(bt + " is too short");
    if (vt.length > 21) throw new TypeError(bt + " is too long");
    const Bt = vt.readUInt8(0), At = vt.slice(1);
    return { version: Bt, hash: At };
  }
  address.fromBase58Check = Ce;
  function it(bt) {
    let vt, Bt;
    try {
      vt = re.bech32.decode(bt);
    } catch {
    }
    if (vt) {
      if (Bt = vt.words[0], Bt !== 0) throw new TypeError(bt + " uses wrong encoding");
    } else if (vt = re.bech32m.decode(bt), Bt = vt.words[0], Bt === 0) throw new TypeError(bt + " uses wrong encoding");
    const At = re.bech32.fromWords(vt.words.slice(1));
    return {
      version: Bt,
      prefix: vt.prefix,
      data: Buffer$1.from(At)
    };
  }
  address.fromBech32 = it;
  function at(bt, vt) {
    (0, K.typeforce)(
      (0, K.tuple)(K.Hash160bit, K.UInt8),
      arguments
    );
    const Bt = Buffer$1.allocUnsafe(21);
    return Bt.writeUInt8(vt, 0), bt.copy(Bt, 1), W.encode(Bt);
  }
  address.toBase58Check = at;
  function lt(bt, vt, Bt) {
    const At = re.bech32.toWords(bt);
    return At.unshift(vt), vt === 0 ? re.bech32.encode(Bt, At) : re.bech32m.encode(Bt, At);
  }
  address.toBech32 = lt;
  function ht(bt, vt) {
    vt = vt || A.bitcoin;
    try {
      return B.p2pkh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2sh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2wpkh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2wsh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2tr({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return ke(bt, vt);
    } catch {
    }
    throw new Error(L.toASM(bt) + " has no matching Address");
  }
  address.fromOutputScript = ht;
  function dt(bt, vt) {
    vt = vt || A.bitcoin;
    let Bt, At;
    try {
      Bt = Ce(bt);
    } catch {
    }
    if (Bt) {
      if (Bt.version === vt.pubKeyHash)
        return B.p2pkh({ hash: Bt.hash }).output;
      if (Bt.version === vt.scriptHash)
        return B.p2sh({ hash: Bt.hash }).output;
    } else {
      try {
        At = it(bt);
      } catch {
      }
      if (At) {
        if (At.prefix !== vt.bech32)
          throw new Error(bt + " has an invalid prefix");
        if (At.version === 0) {
          if (At.data.length === 20)
            return B.p2wpkh({ hash: At.data }).output;
          if (At.data.length === 32)
            return B.p2wsh({ hash: At.data }).output;
        } else if (At.version === 1) {
          if (At.data.length === 32)
            return B.p2tr({ pubkey: At.data }).output;
        } else if (At.version >= oe && At.version <= ie && At.data.length >= ne && At.data.length <= J)
          return console.warn(ce), L.compile([
            At.version + V,
            At.data
          ]);
      }
    }
    throw new Error(bt + " has no matching Script");
  }
  return address.toOutputScript = dt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(A, B) {
  if (!Array.isArray(A)) throw TypeError("Expected values Array");
  if (typeof B != "function")
    throw TypeError("Expected digest Function");
  let L = A.length;
  const K = A.concat();
  for (; L > 1; ) {
    let re = 0;
    for (let W = 0; W < L; W += 2, ++re) {
      const J = K[W], ne = W + 1 === L ? J : K[W + 1], ie = Buffer$1.concat([J, ne]);
      K[re] = B(ie);
    }
    L = re;
  }
  return K[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + B;
}
function vectorSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + A.reduce((L, K) => L + varSliceSize(K), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(A) {
  return A.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(B, L) {
    const K = new bufferutils_1$2.BufferReader(B), re = new Transaction();
    re.version = K.readInt32();
    const W = K.readUInt8(), J = K.readUInt8();
    let ne = !1;
    W === Transaction.ADVANCED_TRANSACTION_MARKER && J === Transaction.ADVANCED_TRANSACTION_FLAG ? ne = !0 : K.offset -= 2;
    const ie = K.readVarInt();
    for (let V = 0; V < ie; ++V)
      re.ins.push({
        hash: K.readSlice(32),
        index: K.readUInt32(),
        script: K.readVarSlice(),
        sequence: K.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const oe = K.readVarInt();
    for (let V = 0; V < oe; ++V)
      re.outs.push({
        value: K.readUInt64(),
        script: K.readVarSlice()
      });
    if (ne) {
      for (let V = 0; V < ie; ++V)
        re.ins[V].witness = K.readVector();
      if (!re.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (re.locktime = K.readUInt32(), L) return re;
    if (K.offset !== B.length)
      throw new Error("Transaction has unexpected data");
    return re;
  }
  static fromHex(B) {
    return Transaction.fromBuffer(Buffer$1.from(B, "hex"), !1);
  }
  static isCoinbaseHash(B) {
    typeforce$1(types$1.Hash256bit, B);
    for (let L = 0; L < 32; ++L)
      if (B[L] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(B, L, K, re) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(K) && (K = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: B,
      index: L,
      script: re || EMPTY_BUFFER,
      sequence: K,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(B, L) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: B,
      value: L
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((B) => B.witness.length !== 0);
  }
  weight() {
    const B = this.byteLength(!1), L = this.byteLength(!0);
    return B * 3 + L;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(B = !0) {
    const L = B && this.hasWitnesses();
    return (L ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((K, re) => K + 40 + varSliceSize(re.script), 0) + this.outs.reduce((K, re) => K + 8 + varSliceSize(re.script), 0) + (L ? this.ins.reduce((K, re) => K + vectorSize(re.witness), 0) : 0);
  }
  clone() {
    const B = new Transaction();
    return B.version = this.version, B.locktime = this.locktime, B.ins = this.ins.map((L) => ({
      hash: L.hash,
      index: L.index,
      script: L.script,
      sequence: L.sequence,
      witness: L.witness
    })), B.outs = this.outs.map((L) => ({
      script: L.script,
      value: L.value
    })), B;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(B, L, K) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), B >= this.ins.length) return ONE;
    const re = bscript$2.compile(
      bscript$2.decompile(L).filter((ne) => ne !== script_1.OPS.OP_CODESEPARATOR)
    ), W = this.clone();
    if ((K & 31) === Transaction.SIGHASH_NONE)
      W.outs = [], W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    else if ((K & 31) === Transaction.SIGHASH_SINGLE) {
      if (B >= this.outs.length) return ONE;
      W.outs.length = B + 1;
      for (let ne = 0; ne < B; ne++)
        W.outs[ne] = BLANK_OUTPUT;
      W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    }
    K & Transaction.SIGHASH_ANYONECANPAY ? (W.ins = [W.ins[B]], W.ins[0].script = re) : (W.ins.forEach((ne) => {
      ne.script = EMPTY_BUFFER;
    }), W.ins[B].script = re);
    const J = Buffer$1.allocUnsafe(W.byteLength(!1) + 4);
    return J.writeInt32LE(K, J.length - 4), W.__toBuffer(J, 0, !1), bcrypto$1.hash256(J);
  }
  hashForWitnessV1(B, L, K, re, W, J) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), K.length !== this.ins.length || L.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ne = re === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : re & Transaction.SIGHASH_OUTPUT_MASK, oe = (re & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, V = ne === Transaction.SIGHASH_NONE, ce = ne === Transaction.SIGHASH_SINGLE;
    let ke = EMPTY_BUFFER, Ce = EMPTY_BUFFER, it = EMPTY_BUFFER, at = EMPTY_BUFFER, lt = EMPTY_BUFFER;
    if (!oe) {
      let vt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Bt) => {
        vt.writeSlice(Bt.hash), vt.writeUInt32(Bt.index);
      }), ke = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), K.forEach((Bt) => vt.writeUInt64(Bt)), Ce = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        L.map(varSliceSize).reduce((Bt, At) => Bt + At)
      ), L.forEach(
        (Bt) => vt.writeVarSlice(Bt)
      ), it = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Bt) => vt.writeUInt32(Bt.sequence)), at = bcrypto$1.sha256(vt.end());
    }
    if (V || ce) {
      if (ce && B < this.outs.length) {
        const vt = this.outs[B], Bt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(vt.script)
        );
        Bt.writeUInt64(vt.value), Bt.writeVarSlice(vt.script), lt = bcrypto$1.sha256(Bt.end());
      }
    } else {
      const vt = this.outs.map((At) => 8 + varSliceSize(At.script)).reduce((At, Nt) => At + Nt), Bt = bufferutils_1$2.BufferWriter.withCapacity(vt);
      this.outs.forEach((At) => {
        Bt.writeUInt64(At.value), Bt.writeVarSlice(At.script);
      }), lt = bcrypto$1.sha256(Bt.end());
    }
    const ht = (W ? 2 : 0) + (J ? 1 : 0), dt = 174 - (oe ? 49 : 0) - (V ? 32 : 0) + (J ? 32 : 0) + (W ? 37 : 0), bt = bufferutils_1$2.BufferWriter.withCapacity(dt);
    if (bt.writeUInt8(re), bt.writeInt32(this.version), bt.writeUInt32(this.locktime), bt.writeSlice(ke), bt.writeSlice(Ce), bt.writeSlice(it), bt.writeSlice(at), V || ce || bt.writeSlice(lt), bt.writeUInt8(ht), oe) {
      const vt = this.ins[B];
      bt.writeSlice(vt.hash), bt.writeUInt32(vt.index), bt.writeUInt64(K[B]), bt.writeVarSlice(L[B]), bt.writeUInt32(vt.sequence);
    } else
      bt.writeUInt32(B);
    if (J) {
      const vt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(J)
      );
      vt.writeVarSlice(J), bt.writeSlice(bcrypto$1.sha256(vt.end()));
    }
    return ce && bt.writeSlice(lt), W && (bt.writeSlice(W), bt.writeUInt8(0), bt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), bt.end()])
    );
  }
  hashForWitnessV0(B, L, K, re) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let W = Buffer$1.from([]), J, ne = ZERO, ie = ZERO, oe = ZERO;
    if (re & Transaction.SIGHASH_ANYONECANPAY || (W = Buffer$1.allocUnsafe(36 * this.ins.length), J = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((ce) => {
      J.writeSlice(ce.hash), J.writeUInt32(ce.index);
    }), ie = bcrypto$1.hash256(W)), !(re & Transaction.SIGHASH_ANYONECANPAY) && (re & 31) !== Transaction.SIGHASH_SINGLE && (re & 31) !== Transaction.SIGHASH_NONE && (W = Buffer$1.allocUnsafe(4 * this.ins.length), J = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((ce) => {
      J.writeUInt32(ce.sequence);
    }), oe = bcrypto$1.hash256(W)), (re & 31) !== Transaction.SIGHASH_SINGLE && (re & 31) !== Transaction.SIGHASH_NONE) {
      const ce = this.outs.reduce((ke, Ce) => ke + 8 + varSliceSize(Ce.script), 0);
      W = Buffer$1.allocUnsafe(ce), J = new bufferutils_1$2.BufferWriter(W, 0), this.outs.forEach((ke) => {
        J.writeUInt64(ke.value), J.writeVarSlice(ke.script);
      }), ne = bcrypto$1.hash256(W);
    } else if ((re & 31) === Transaction.SIGHASH_SINGLE && B < this.outs.length) {
      const ce = this.outs[B];
      W = Buffer$1.allocUnsafe(8 + varSliceSize(ce.script)), J = new bufferutils_1$2.BufferWriter(W, 0), J.writeUInt64(ce.value), J.writeVarSlice(ce.script), ne = bcrypto$1.hash256(W);
    }
    W = Buffer$1.allocUnsafe(156 + varSliceSize(L)), J = new bufferutils_1$2.BufferWriter(W, 0);
    const V = this.ins[B];
    return J.writeInt32(this.version), J.writeSlice(ie), J.writeSlice(oe), J.writeSlice(V.hash), J.writeUInt32(V.index), J.writeVarSlice(L), J.writeUInt64(K), J.writeUInt32(V.sequence), J.writeSlice(ne), J.writeUInt32(this.locktime), J.writeUInt32(re), bcrypto$1.hash256(W);
  }
  getHash(B) {
    return B && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, B));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(B, L) {
    return this.__toBuffer(B, L, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[B].script = L;
  }
  setWitness(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[B].witness = L;
  }
  __toBuffer(B, L, K = !1) {
    B || (B = Buffer$1.allocUnsafe(this.byteLength(K)));
    const re = new bufferutils_1$2.BufferWriter(
      B,
      L || 0
    );
    re.writeInt32(this.version);
    const W = K && this.hasWitnesses();
    return W && (re.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), re.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), re.writeVarInt(this.ins.length), this.ins.forEach((J) => {
      re.writeSlice(J.hash), re.writeUInt32(J.index), re.writeVarSlice(J.script), re.writeUInt32(J.sequence);
    }), re.writeVarInt(this.outs.length), this.outs.forEach((J) => {
      isOutput(J) ? re.writeUInt64(J.value) : re.writeSlice(J.valueBuffer), re.writeVarSlice(J.script);
    }), W && this.ins.forEach((J) => {
      re.writeVector(J.witness);
    }), re.writeUInt32(this.locktime), L !== void 0 ? B.slice(L, re.offset) : B;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(B) {
    if (B.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const L = new bufferutils_1$1.BufferReader(B), K = new Block();
    if (K.version = L.readInt32(), K.prevHash = L.readSlice(32), K.merkleRoot = L.readSlice(32), K.timestamp = L.readUInt32(), K.bits = L.readUInt32(), K.nonce = L.readUInt32(), B.length === 80) return K;
    const re = () => {
      const ne = transaction_1$3.Transaction.fromBuffer(
        L.buffer.slice(L.offset),
        !0
      );
      return L.offset += ne.byteLength(), ne;
    }, W = L.readVarInt();
    K.transactions = [];
    for (let ne = 0; ne < W; ++ne) {
      const ie = re();
      K.transactions.push(ie);
    }
    const J = K.getWitnessCommit();
    return J && (K.witnessCommit = J), K;
  }
  static fromHex(B) {
    return Block.fromBuffer(Buffer$1.from(B, "hex"));
  }
  static calculateTarget(B) {
    const L = ((B & 4278190080) >> 24) - 3, K = B & 8388607, re = Buffer$1.alloc(32, 0);
    return re.writeUIntBE(K, 29 - L, 3), re;
  }
  static calculateMerkleRoot(B, L) {
    if (typeforce([{ getHash: types.Function }], B), B.length === 0) throw errorMerkleNoTxes;
    if (L && !txesHaveWitnessCommit(B))
      throw errorWitnessNotSegwit;
    const K = B.map(
      (W) => W.getHash(L)
    ), re = (0, merkle_1.fastMerkleRoot)(K, bcrypto.hash256);
    return L ? bcrypto.hash256(
      Buffer$1.concat([re, B[0].ins[0].witness[0]])
    ) : re;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const B = this.transactions[0].outs.filter(
      (K) => K.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((K) => K.script.slice(6, 38));
    if (B.length === 0) return null;
    const L = B[B.length - 1];
    return L instanceof Buffer$1 && L.length === 32 ? L : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const B = this.byteLength(!1, !1), L = this.byteLength(!1, !0);
    return B * 3 + L;
  }
  byteLength(B, L = !0) {
    return B || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((K, re) => K + re.byteLength(L), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const B = /* @__PURE__ */ new Date(0);
    return B.setUTCSeconds(this.timestamp), B;
  }
  // TODO: buffer, offset compatibility
  toBuffer(B) {
    const L = Buffer$1.allocUnsafe(this.byteLength(B)), K = new bufferutils_1$1.BufferWriter(L);
    return K.writeInt32(this.version), K.writeSlice(this.prevHash), K.writeSlice(this.merkleRoot), K.writeUInt32(this.timestamp), K.writeUInt32(this.bits), K.writeUInt32(this.nonce), B || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      L,
      K.offset
    ), K.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((re) => {
      const W = re.byteLength();
      re.toBuffer(L, K.offset), K.offset += W;
    })), L;
  }
  toHex(B) {
    return this.toBuffer(B).toString("hex");
  }
  checkTxRoots() {
    const B = this.hasWitnessCommit();
    return !B && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (B ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const B = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), L = Block.calculateTarget(this.bits);
    return B.compare(L) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const B = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(B) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const B = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(B) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(A) {
  return A instanceof Array && A[0] && A[0].ins && A[0].ins instanceof Array && A[0].ins[0] && A[0].ins[0].witness && A[0].ins[0].witness instanceof Array && A[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(A) {
  return A instanceof Array && A.some(
    (B) => typeof B == "object" && B.ins instanceof Array && B.ins.some(
      (L) => typeof L == "object" && L.witness instanceof Array && L.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), function(B) {
    B[B.UNSIGNED_TX = 0] = "UNSIGNED_TX", B[B.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(A.GlobalTypes || (A.GlobalTypes = {})), A.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(B) {
    B[B.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", B[B.WITNESS_UTXO = 1] = "WITNESS_UTXO", B[B.PARTIAL_SIG = 2] = "PARTIAL_SIG", B[B.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", B[B.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", B[B.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", B[B.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", B[B.POR_COMMITMENT = 9] = "POR_COMMITMENT", B[B.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", B[B.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", B[B.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", B[B.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", B[B.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(A.InputTypes || (A.InputTypes = {})), A.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(B) {
    B[B.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", B[B.TAP_TREE = 6] = "TAP_TREE", B[B.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(A.OutputTypes || (A.OutputTypes = {})), A.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (A) => [...Array(A).keys()];
function decode$d(A) {
  if (A.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 79 || ![2, 3].includes(A.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + A.key.toString("hex")
    );
  if (A.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const B = A.key.slice(1), L = {
    masterFingerprint: A.value.slice(0, 4),
    extendedPubkey: B,
    path: "m"
  };
  for (const K of range$2(A.value.length / 4 - 1)) {
    const re = A.value.readUInt32LE(K * 4 + 4), W = !!(re & 2147483648), J = re & 2147483647;
    L.path += "/" + J.toString(10) + (W ? "'" : "");
  }
  return L;
}
globalXpub$1.decode = decode$d;
function encode$e(A) {
  const B = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), L = Buffer$1.concat([B, A.extendedPubkey]), K = A.path.split("/"), re = Buffer$1.allocUnsafe(K.length * 4);
  A.masterFingerprint.copy(re, 0);
  let W = 4;
  return K.slice(1).forEach((J) => {
    const ne = J.slice(-1) === "'";
    let ie = 2147483647 & parseInt(ne ? J.slice(0, -1) : J, 10);
    ne && (ie += 2147483648), re.writeUInt32LE(ie, W), W += 4;
  }), {
    key: L,
    value: re
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(A) {
  const B = A.extendedPubkey, L = A.masterFingerprint, K = A.path;
  return Buffer$1.isBuffer(B) && B.length === 78 && [2, 3].indexOf(B[45]) > -1 && Buffer$1.isBuffer(L) && L.length === 4 && typeof K == "string" && !!K.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(A, B, L) {
  const K = B.extendedPubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((re) => re.extendedPubkey.equals(B.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(A) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: A.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(A) {
  if (A.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(A) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: A
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptSig$1.check = check$b;
function canAdd$8(A, B) {
  return !!A && !!B && A.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(A) {
  if (A.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(A) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: A
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(A, B) {
  return !!A && !!B && A.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(A) {
  if (A.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(A) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: A
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(A) {
  return Buffer$1.isBuffer(A);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(A, B) {
  return !!A && !!B && A.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(A) {
  if (A.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + A.key.toString("hex")
    );
  if (!(A.key.length === 34 || A.key.length === 66) || ![2, 3, 4].includes(A.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + A.key.toString("hex")
    );
  return {
    pubkey: A.key.slice(1),
    signature: A.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(A) {
  const B = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey]),
    value: A.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.signature) && [33, 65].includes(A.pubkey.length) && [2, 3, 4].includes(A.pubkey[0]) && isDerSigWithSighash(A.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(A) {
  if (!Buffer$1.isBuffer(A) || A.length < 9 || A[0] !== 48 || A.length !== A[1] + 3 || A[2] !== 2) return !1;
  const B = A[3];
  if (B > 33 || B < 1 || A[3 + B + 1] !== 2) return !1;
  const L = A[3 + B + 2];
  return !(L > 33 || L < 1 || A.length !== 3 + B + 2 + L + 2);
}
function canAddToArray$2(A, B, L) {
  const K = B.pubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((re) => re.pubkey.equals(B.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(A) {
  if (A.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + A.key.toString("hex")
    );
  return A.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(A) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(A, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(A) {
  return typeof A == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(A, B) {
  return !!A && !!B && A.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(A) {
  if (A.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + A.key.toString("hex")
    );
  return A.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(A) {
  const B = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), L = Buffer$1.allocUnsafe(4);
  return L.writeUInt32LE(A, 0), {
    key: B,
    value: L
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(A) {
  return typeof A == "number";
}
sighashType$1.check = check$6;
function canAdd$4(A, B) {
  return !!A && !!B && A.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(A) {
  if (A.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + A.key.toString("hex")
    );
  if (!check$5(A.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return A.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(A) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: A };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(A) {
  return Buffer$1.isBuffer(A) && (A.length === 64 || A.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(A, B) {
  return !!A && !!B && A.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(A) {
  if (A.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + A.key.toString("hex")
    );
  if ((A.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + A.key.toString("hex")
    );
  const B = A.value[A.value.length - 1];
  if ((A.key[1] & 254) !== B)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + A.key.toString("hex")
    );
  const L = A.value.slice(0, -1);
  return { controlBlock: A.key.slice(1), script: L, leafVersion: B };
}
tapLeafScript$1.decode = decode$5;
function encode$5(A) {
  const B = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), L = Buffer$1.from([A.leafVersion]);
  return {
    key: Buffer$1.concat([B, A.controlBlock]),
    value: Buffer$1.concat([A.script, L])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(A) {
  return Buffer$1.isBuffer(A.controlBlock) && (A.controlBlock.length - 1) % 32 === 0 && (A.controlBlock[0] & 254) === A.leafVersion && Buffer$1.isBuffer(A.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(A, B, L) {
  const K = B.controlBlock.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((re) => re.controlBlock.equals(B.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(A) {
  if (A.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + A.key.toString("hex")
    );
  if (!check$3(A.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return A.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(A) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: A };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(A) {
  return Buffer$1.isBuffer(A) && A.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(A, B) {
  return !!A && !!B && A.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(A) {
  if (A.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + A.key.toString("hex")
    );
  if (A.value.length !== 64 && A.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + A.key.toString("hex")
    );
  const B = A.key.slice(1, 33), L = A.key.slice(33);
  return {
    pubkey: B,
    leafHash: L,
    signature: A.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(A) {
  const B = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey, A.leafHash]),
    value: A.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.leafHash) && Buffer$1.isBuffer(A.signature) && A.pubkey.length === 32 && A.leafHash.length === 32 && (A.signature.length === 64 || A.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(A, B, L) {
  const K = B.pubkey.toString("hex") + B.leafHash.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter(
    (re) => re.pubkey.equals(B.pubkey) && re.leafHash.equals(B.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER || A % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(A, B, L) {
  if (checkUInt53(A), B || (B = Buffer$1.allocUnsafe(encodingLength(A))), !Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), Object.assign(encode$2, { bytes: 1 })) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), Object.assign(encode$2, { bytes: 3 })) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), Object.assign(encode$2, { bytes: 5 })) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), Object.assign(encode$2, { bytes: 9 })), B;
}
varint.encode = encode$2;
function decode$2(A, B) {
  if (!Buffer$1.isBuffer(A))
    throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  const L = A.readUInt8(B);
  if (L < 253)
    return Object.assign(decode$2, { bytes: 1 }), L;
  if (L === 253)
    return Object.assign(decode$2, { bytes: 3 }), A.readUInt16LE(B + 1);
  if (L === 254)
    return Object.assign(decode$2, { bytes: 5 }), A.readUInt32LE(B + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const K = A.readUInt32LE(B + 1), W = A.readUInt32LE(B + 5) * 4294967296 + K;
    return checkUInt53(W), W;
  }
}
varint.decode = decode$2;
function encodingLength(A) {
  return checkUInt53(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (A) => [...Array(A).keys()];
function reverseBuffer(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(A) {
  const B = A.map(keyValToBuffer);
  return B.push(Buffer$1.from([0])), Buffer$1.concat(B);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(A) {
  const B = A.key.length, L = A.value.length, K = varuint$6.encodingLength(B), re = varuint$6.encodingLength(L), W = Buffer$1.allocUnsafe(
    K + B + re + L
  );
  return varuint$6.encode(B, W, 0), A.key.copy(W, K), varuint$6.encode(L, W, K + B), A.value.copy(W, K + B + re), W;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint(K + L, 9007199254740991), K + L;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(A, B, L) {
  return verifuint(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(A) {
  if (A.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + A.key.toString("hex")
    );
  const B = tools_1$2.readUInt64LE(A.value, 0);
  let L = 8;
  const K = varuint$5.decode(A.value, L);
  L += varuint$5.encodingLength(K);
  const re = A.value.slice(L);
  if (re.length !== K)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: re,
    value: B
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(A) {
  const { script: B, value: L } = A, K = varuint$5.encodingLength(B.length), re = Buffer$1.allocUnsafe(8 + K + B.length);
  return tools_1$2.writeUInt64LE(re, L, 0), varuint$5.encode(B.length, re, 8), B.copy(re, 8 + K), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: re
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(A) {
  return Buffer$1.isBuffer(A.script) && typeof A.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(A, B) {
  return !!A && !!B && A.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(A) {
  if (A.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + A.key.toString("hex")
    );
  let B = 0;
  const L = [];
  for (; B < A.value.length; ) {
    const K = A.value[B++], re = A.value[B++], W = varuint$4.decode(A.value, B);
    B += varuint$4.encodingLength(W), L.push({
      depth: K,
      leafVersion: re,
      script: A.value.slice(B, B + W)
    }), B += W;
  }
  return { leaves: L };
}
tapTree$1.decode = decode;
function encode(A) {
  const B = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), L = [].concat(
    ...A.leaves.map((K) => [
      Buffer$1.of(K.depth, K.leafVersion),
      varuint$4.encode(K.script.length),
      K.script
    ])
  );
  return {
    key: B,
    value: Buffer$1.concat(L)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(A) {
  return Array.isArray(A.leaves) && A.leaves.every(
    (B) => B.depth >= 0 && B.depth <= 128 && (B.leafVersion & 254) === B.leafVersion && Buffer$1.isBuffer(B.script)
  );
}
tapTree$1.check = check;
function canAdd(A, B) {
  return !!A && !!B && A.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (A) => [...Array(A).keys()], isValidDERKey = (A) => A.length === 33 && [2, 3].includes(A[0]) || A.length === 65 && A[0] === 4;
function makeConverter$4(A, B = isValidDERKey) {
  function L(ne) {
    if (ne.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ne.key.toString("hex")
      );
    const ie = ne.key.slice(1);
    if (!B(ie))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ne.key.toString("hex")
      );
    if (ne.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const oe = {
      masterFingerprint: ne.value.slice(0, 4),
      pubkey: ie,
      path: "m"
    };
    for (const V of range$1(ne.value.length / 4 - 1)) {
      const ce = ne.value.readUInt32LE(V * 4 + 4), ke = !!(ce & 2147483648), Ce = ce & 2147483647;
      oe.path += "/" + Ce.toString(10) + (ke ? "'" : "");
    }
    return oe;
  }
  function K(ne) {
    const ie = Buffer$1.from([A]), oe = Buffer$1.concat([ie, ne.pubkey]), V = ne.path.split("/"), ce = Buffer$1.allocUnsafe(V.length * 4);
    ne.masterFingerprint.copy(ce, 0);
    let ke = 4;
    return V.slice(1).forEach((Ce) => {
      const it = Ce.slice(-1) === "'";
      let at = 2147483647 & parseInt(it ? Ce.slice(0, -1) : Ce, 10);
      it && (at += 2147483648), ce.writeUInt32LE(at, ke), ke += 4;
    }), {
      key: oe,
      value: ce
    };
  }
  const re = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function W(ne) {
    return Buffer$1.isBuffer(ne.pubkey) && Buffer$1.isBuffer(ne.masterFingerprint) && typeof ne.path == "string" && B(ne.pubkey) && ne.masterFingerprint.length === 4;
  }
  function J(ne, ie, oe) {
    const V = ie.pubkey.toString("hex");
    return oe.has(V) ? !1 : (oe.add(V), ne.filter((ce) => ce.pubkey.equals(ie.pubkey)).length === 0);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: re,
    canAddToArray: J
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(A) {
  return B;
  function B(L) {
    let K;
    if (A.includes(L.key[0]) && (K = L.key.slice(1), !(K.length === 33 || K.length === 65) || ![2, 3, 4].includes(K[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + L.key.toString("hex")
      );
    return K;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(A) {
  function B(J) {
    if (J.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + J.key.toString("hex")
      );
    return J.value;
  }
  function L(J) {
    return {
      key: Buffer$1.from([A]),
      value: J
    };
  }
  const K = "Buffer";
  function re(J) {
    return Buffer$1.isBuffer(J);
  }
  function W(J, ne) {
    return !!J && !!ne && J.redeemScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: re,
    expected: K,
    canAdd: W
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (A) => A.length === 32;
function makeConverter$2(A) {
  const B = bip32Derivation$1.makeConverter(A, isValidBIP340Key);
  function L(J) {
    const ne = varuint$3.decode(J.value), ie = varuint$3.encodingLength(ne), oe = B.decode({
      key: J.key,
      value: J.value.slice(ie + ne * 32)
    }), V = new Array(ne);
    for (let ce = 0, ke = ie; ce < ne; ce++, ke += 32)
      V[ce] = J.value.slice(ke, ke + 32);
    return Object.assign({}, oe, { leafHashes: V });
  }
  function K(J) {
    const ne = B.encode(J), ie = varuint$3.encodingLength(J.leafHashes.length), oe = Buffer$1.allocUnsafe(ie);
    varuint$3.encode(J.leafHashes.length, oe);
    const V = Buffer$1.concat([oe, ...J.leafHashes, ne.value]);
    return Object.assign({}, ne, { value: V });
  }
  const re = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function W(J) {
    return Array.isArray(J.leafHashes) && J.leafHashes.every(
      (ne) => Buffer$1.isBuffer(ne) && ne.length === 32
    ) && B.check(J);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: re,
    canAddToArray: B.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(A) {
  function B(J) {
    if (J.key[0] !== A || J.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + J.key.toString("hex")
      );
    if (J.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return J.value;
  }
  function L(J) {
    return { key: Buffer$1.from([A]), value: J };
  }
  const K = "Buffer";
  function re(J) {
    return Buffer$1.isBuffer(J) && J.length === 32;
  }
  function W(J, ne) {
    return !!J && !!ne && J.tapInternalKey === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: re,
    expected: K,
    canAdd: W
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(A) {
  function B(J) {
    if (J.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + J.key.toString("hex")
      );
    return J.value;
  }
  function L(J) {
    return {
      key: Buffer$1.from([A]),
      value: J
    };
  }
  const K = "Buffer";
  function re(J) {
    return Buffer$1.isBuffer(J);
  }
  function W(J, ne) {
    return !!J && !!ne && J.witnessScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: re,
    expected: K,
    canAdd: W
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(A, B) {
  let L = 0;
  function K() {
    const lt = varuint$2.decode(A, L);
    L += varuint$2.encodingLength(lt);
    const ht = A.slice(L, L + lt);
    return L += lt, ht;
  }
  function re() {
    const lt = A.readUInt32BE(L);
    return L += 4, lt;
  }
  function W() {
    const lt = A.readUInt8(L);
    return L += 1, lt;
  }
  function J() {
    const lt = K(), ht = K();
    return {
      key: lt,
      value: ht
    };
  }
  function ne() {
    if (L >= A.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const lt = A.readUInt8(L) === 0;
    return lt && L++, lt;
  }
  if (re() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (W() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ie = [], oe = {};
  for (; !ne(); ) {
    const lt = J(), ht = lt.key.toString("hex");
    if (oe[ht])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + ht
      );
    oe[ht] = 1, ie.push(lt);
  }
  const V = ie.filter(
    (lt) => lt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (V.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const ce = B(V[0].value), { inputCount: ke, outputCount: Ce } = ce.getInputOutputCounts(), it = [], at = [];
  for (const lt of tools_1$1.range(ke)) {
    const ht = {}, dt = [];
    for (; !ne(); ) {
      const bt = J(), vt = bt.key.toString("hex");
      if (ht[vt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + lt + " key " + vt
        );
      ht[vt] = 1, dt.push(bt);
    }
    it.push(dt);
  }
  for (const lt of tools_1$1.range(Ce)) {
    const ht = {}, dt = [];
    for (; !ne(); ) {
      const bt = J(), vt = bt.key.toString("hex");
      if (ht[vt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + lt + " key " + vt
        );
      ht[vt] = 1, dt.push(bt);
    }
    at.push(dt);
  }
  return psbtFromKeyVals(ce, {
    globalMapKeyVals: ie,
    inputKeyVals: it,
    outputKeyVals: at
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(A, B, L) {
  if (!B.equals(Buffer$1.from([L])))
    throw new Error(
      `Format Error: Invalid ${A} key: ${B.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(A, { globalMapKeyVals: B, inputKeyVals: L, outputKeyVals: K }) {
  const re = {
    unsignedTx: A
  };
  let W = 0;
  for (const V of B)
    switch (V.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          V.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), W > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        W++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        re.globalXpub === void 0 && (re.globalXpub = []), re.globalXpub.push(convert$1.globals.globalXpub.decode(V));
        break;
      default:
        re.unknownKeyVals || (re.unknownKeyVals = []), re.unknownKeyVals.push(V);
    }
  const J = L.length, ne = K.length, ie = [], oe = [];
  for (const V of tools_1$1.range(J)) {
    const ce = {};
    for (const ke of L[V])
      switch (convert$1.inputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), ce.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          ce.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), ce.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          ce.witnessUtxo = convert$1.inputs.witnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          ce.partialSig === void 0 && (ce.partialSig = []), ce.partialSig.push(convert$1.inputs.partialSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), ce.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          ce.sighashType = convert$1.inputs.sighashType.decode(ke);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), ce.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          ce.redeemScript = convert$1.inputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), ce.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          ce.witnessScript = convert$1.inputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          ce.bip32Derivation === void 0 && (ce.bip32Derivation = []), ce.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), ce.finalScriptSig = convert$1.inputs.finalScriptSig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), ce.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            ke
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), ce.porCommitment = convert$1.inputs.porCommitment.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), ce.tapKeySig = convert$1.inputs.tapKeySig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          ce.tapScriptSig === void 0 && (ce.tapScriptSig = []), ce.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          ce.tapLeafScript === void 0 && (ce.tapLeafScript = []), ce.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          ce.tapBip32Derivation === void 0 && (ce.tapBip32Derivation = []), ce.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), ce.tapInternalKey = convert$1.inputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), ce.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(ke);
          break;
        default:
          ce.unknownKeyVals || (ce.unknownKeyVals = []), ce.unknownKeyVals.push(ke);
      }
    ie.push(ce);
  }
  for (const V of tools_1$1.range(ne)) {
    const ce = {};
    for (const ke of K[V])
      switch (convert$1.outputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), ce.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          ce.redeemScript = convert$1.outputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), ce.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          ce.witnessScript = convert$1.outputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          ce.bip32Derivation === void 0 && (ce.bip32Derivation = []), ce.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), ce.tapInternalKey = convert$1.outputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), ce.tapTree = convert$1.outputs.tapTree.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          ce.tapBip32Derivation === void 0 && (ce.tapBip32Derivation = []), ce.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(ke)
          );
          break;
        default:
          ce.unknownKeyVals || (ce.unknownKeyVals = []), ce.unknownKeyVals.push(ke);
      }
    oe.push(ce);
  }
  return { globalMap: re, inputs: ie, outputs: oe };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: A, inputs: B, outputs: L }) {
  const { globalKeyVals: K, inputKeyVals: re, outputKeyVals: W } = psbtToKeyVals({
    globalMap: A,
    inputs: B,
    outputs: L
  }), J = tools_1.keyValsToBuffer(K), ne = (ce) => ce.length === 0 ? [Buffer$1.from([0])] : ce.map(tools_1.keyValsToBuffer), ie = ne(re), oe = ne(W), V = Buffer$1.allocUnsafe(5);
  return V.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [V, J].concat(ie, oe)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (A, B) => A.key.compare(B.key);
function keyValsFromMap(A, B) {
  const L = /* @__PURE__ */ new Set(), K = Object.entries(A).reduce((W, [J, ne]) => {
    if (J === "unknownKeyVals") return W;
    const ie = B[J];
    if (ie === void 0) return W;
    const oe = (Array.isArray(ne) ? ne : [ne]).map(
      ie.encode
    );
    return oe.map((ce) => ce.key.toString("hex")).forEach((ce) => {
      if (L.has(ce))
        throw new Error("Serialize Error: Duplicate key: " + ce);
      L.add(ce);
    }), W.concat(oe);
  }, []), re = A.unknownKeyVals ? A.unknownKeyVals.filter((W) => !L.has(W.key.toString("hex"))) : [];
  return K.concat(re).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: A, inputs: B, outputs: L }) {
  return {
    globalKeyVals: keyValsFromMap(A, convert.globals),
    inputKeyVals: B.map((K) => keyValsFromMap(K, convert.inputs)),
    outputKeyVals: L.map((K) => keyValsFromMap(K, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(A) {
  function B(L) {
    for (var K in L) A.hasOwnProperty(K) || (A[K] = L[K]);
  }
  Object.defineProperty(A, "__esModule", { value: !0 }), B(fromBuffer), B(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(A) {
  const B = A[0], L = parser_1$1.psbtToKeyVals(B), K = A.slice(1);
  if (K.length === 0) throw new Error("Combine: Nothing to combine");
  const re = getTx(B);
  if (re === void 0)
    throw new Error("Combine: Self missing transaction");
  const W = getKeySet(L.globalKeyVals), J = L.inputKeyVals.map(getKeySet), ne = L.outputKeyVals.map(getKeySet);
  for (const ie of K) {
    const oe = getTx(ie);
    if (oe === void 0 || !oe.toBuffer().equals(re.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const V = parser_1$1.psbtToKeyVals(ie);
    getKeySet(V.globalKeyVals).forEach(
      keyPusher(
        W,
        L.globalKeyVals,
        V.globalKeyVals
      )
    ), V.inputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          J[at],
          L.inputKeyVals[at],
          V.inputKeyVals[at]
        )
      )
    ), V.outputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          ne[at],
          L.outputKeyVals[at],
          V.outputKeyVals[at]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(re, {
    globalMapKeyVals: L.globalKeyVals,
    inputKeyVals: L.inputKeyVals,
    outputKeyVals: L.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(A, B, L) {
  return (K) => {
    if (A.has(K)) return;
    const re = L.filter((W) => W.key.toString("hex") === K)[0];
    B.push(re), A.add(K);
  };
}
function getTx(A) {
  return A.globalMap.unsignedTx;
}
function getKeySet(A) {
  const B = /* @__PURE__ */ new Set();
  return A.forEach((L) => {
    const K = L.key.toString("hex");
    if (B.has(K))
      throw new Error("Combine: KeyValue Map keys should be unique");
    B.add(K);
  }), B;
}
var utils = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 });
  const B = converter;
  function L(Ce, it) {
    const at = Ce[it];
    if (at === void 0) throw new Error(`No input #${it}`);
    return at;
  }
  A.checkForInput = L;
  function K(Ce, it) {
    const at = Ce[it];
    if (at === void 0) throw new Error(`No output #${it}`);
    return at;
  }
  A.checkForOutput = K;
  function re(Ce, it, at) {
    if (Ce.key[0] < at)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (it && it.filter((lt) => lt.key.equals(Ce.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Ce.key.toString("hex")}`);
  }
  A.checkHasKey = re;
  function W(Ce) {
    let it = 0;
    return Object.keys(Ce).forEach((at) => {
      Number(isNaN(Number(at))) && it++;
    }), it;
  }
  A.getEnumLength = W;
  function J(Ce, it) {
    let at = !1;
    if (it.nonWitnessUtxo || it.witnessUtxo) {
      const lt = !!it.redeemScript, ht = !!it.witnessScript, dt = !lt || !!it.finalScriptSig, bt = !ht || !!it.finalScriptWitness, vt = !!it.finalScriptSig || !!it.finalScriptWitness;
      at = dt && bt && vt;
    }
    if (at === !1)
      throw new Error(
        `Input #${Ce} has too much or too little data to clean`
      );
  }
  A.inputCheckUncleanFinalized = J;
  function ne(Ce, it, at, lt) {
    throw new Error(
      `Data for ${Ce} key ${it} is incorrect: Expected ${at} and got ${JSON.stringify(lt)}`
    );
  }
  function ie(Ce) {
    return (it, at) => {
      for (const lt of Object.keys(it)) {
        const ht = it[lt], { canAdd: dt, canAddToArray: bt, check: vt, expected: Bt } = (
          // @ts-ignore
          B[Ce + "s"][lt] || {}
        ), At = !!bt;
        if (vt)
          if (At) {
            if (!Array.isArray(ht) || // @ts-ignore
            at[lt] && !Array.isArray(at[lt]))
              throw new Error(`Key type ${lt} must be an array`);
            ht.every(vt) || ne(Ce, lt, Bt, ht);
            const Nt = at[lt] || [], $t = /* @__PURE__ */ new Set();
            if (!ht.every((mt) => bt(Nt, mt, $t)))
              throw new Error("Can not add duplicate data to array");
            at[lt] = Nt.concat(ht);
          } else {
            if (vt(ht) || ne(Ce, lt, Bt, ht), !dt(at, ht))
              throw new Error(`Can not add duplicate data to ${Ce}`);
            at[lt] = ht;
          }
      }
    };
  }
  A.updateGlobal = ie("global"), A.updateInput = ie("input"), A.updateOutput = ie("output");
  function oe(Ce, it) {
    const at = Ce.length - 1, lt = L(Ce, at);
    A.updateInput(it, lt);
  }
  A.addInputAttributes = oe;
  function V(Ce, it) {
    const at = Ce.length - 1, lt = K(Ce, at);
    A.updateOutput(it, lt);
  }
  A.addOutputAttributes = V;
  function ce(Ce, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return it.writeUInt32LE(Ce, 0), it;
  }
  A.defaultVersionSetter = ce;
  function ke(Ce, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return it.writeUInt32LE(Ce, it.length - 4), it;
  }
  A.defaultLocktimeSetter = ke;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: B
    };
  }
  static fromBase64(B, L) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L) {
    const K = parser_1.psbtFromBuffer(B, L), re = new this(K.globalMap.unsignedTx);
    return Object.assign(re, K), re;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$1.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.updateInput(L, K), this;
  }
  updateOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.updateOutput(L, K), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$1.checkHasKey(
      B,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (re) => this.addUnknownKeyValToInput(K, re)
    ), utils_1$1.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (re) => this.addUnknownKeyValToOutput(K, re)
    ), utils_1$1.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const L = utils_1$1.checkForInput(this.inputs, B);
    utils_1$1.inputCheckUncleanFinalized(B, L);
    for (const K of Object.keys(L))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(K) || delete L[K];
    return this;
  }
  combine(...B) {
    const L = combiner_1.combine([this].concat(B));
    return Object.assign(this, L), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(A) {
  return (B) => {
    try {
      return A({ output: B }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(A) {
  let B = Buffer$1.allocUnsafe(0);
  function L(J) {
    B = Buffer$1.concat([B, Buffer$1.from(J)]);
  }
  function K(J) {
    const ne = B.length, ie = varuint$1.encodingLength(J);
    B = Buffer$1.concat([B, Buffer$1.allocUnsafe(ie)]), varuint$1.encode(J, B, ne);
  }
  function re(J) {
    K(J.length), L(J);
  }
  function W(J) {
    K(J.length), J.forEach(re);
  }
  return W(A), B;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(A, B) {
  const L = (0, crypto_1.hash160)(A), K = A.slice(1, 33), re = bscript$1.decompile(B);
  if (re === null) throw new Error("Unknown script error");
  return re.findIndex((W) => typeof W == "number" ? !1 : W.equals(A) || W.equals(L) || W.equals(K));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(A, B) {
  return pubkeyPositionInScript(A, B) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(A, B) {
  return extractPartialSigs(A).some(
    (K) => signatureBlocksAction(K, bscript$1.signature.decode, B)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(A, B, L) {
  const { hashType: K } = B(A), re = [];
  switch (K & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && re.push("addInput"), K & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      re.push("addOutput"), re.push("setInputSequence");
      break;
  }
  return re.indexOf(L) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(A) {
  let B = [];
  if ((A.partialSig || []).length === 0) {
    if (!A.finalScriptSig && !A.finalScriptWitness) return [];
    B = getPsigsFromInputFinalScripts(A);
  } else
    B = A.partialSig;
  return B.map((L) => L.signature);
}
function getPsigsFromInputFinalScripts(A) {
  const B = A.finalScriptSig ? bscript$1.decompile(A.finalScriptSig) || [] : [], L = A.finalScriptWitness ? bscript$1.decompile(A.finalScriptWitness) || [] : [];
  return B.concat(L).filter((K) => Buffer$1.isBuffer(K) && bscript$1.isCanonicalScriptSignature(K)).map((K) => ({ signature: K }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (A) => A.length === 32 ? A : A.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(A, B, L) {
  const K = findTapLeafToFinalize(
    B,
    A,
    L
  );
  try {
    const W = sortSignatures(B, K).concat(K.script).concat(K.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(W)
    };
  } catch (re) {
    throw new Error(`Can not finalize taproot input #${A}: ${re}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(A, B) {
  const L = B ? Buffer$1.from([B]) : Buffer$1.from([]);
  return Buffer$1.concat([A, L]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(A) {
  return A && !!(A.tapInternalKey || A.tapMerkleRoot || A.tapLeafScript && A.tapLeafScript.length || A.tapBip32Derivation && A.tapBip32Derivation.length || A.witnessUtxo && (0, psbtutils_1$1.isP2TR)(A.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(A, B) {
  return A && !!(A.tapInternalKey || A.tapTree || A.tapBip32Derivation && A.tapBip32Derivation.length || B && (0, psbtutils_1$1.isP2TR)(B));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootInputFields(A, B, L), checkIfTapLeafInTree(A, B, L);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootOutputFields(A, B, L), checkTaprootScriptPubkey(A, B);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(A, B) {
  if (!B.tapTree && !B.tapInternalKey) return;
  const L = B.tapInternalKey || A.tapInternalKey, K = B.tapTree || A.tapTree;
  if (L) {
    const { script: re } = A, W = getTaprootScripPubkey(L, K);
    if (re && !re.equals(W))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(A, B) {
  const L = B && tapTreeFromList(B.leaves), { output: K } = (0, payments_1.p2tr)({
    internalPubkey: A,
    scriptTree: L
  });
  return K;
}
function tweakInternalPubKey(A, B) {
  const L = B.tapInternalKey, K = L && (0, bip341_1$1.tweakKey)(L, B.tapMerkleRoot);
  if (!K)
    throw new Error(
      `Cannot tweak tap internal key for input #${A}. Public key: ${L && L.toString("hex")}`
    );
  return K.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(A) {
  if (!(0, types_1.isTaptree)(A))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(A);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(A = []) {
  return A.length === 1 && A[0].depth === 0 ? {
    output: A[0].script,
    version: A[0].leafVersion
  } : instertLeavesInTree(A);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(A, B) {
  return extractTaprootSigs(A).some(
    (K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, B)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(A) {
  return {
    signature: A.slice(0, 64),
    hashType: A.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(A) {
  const B = [];
  if (A.tapKeySig && B.push(A.tapKeySig), A.tapScriptSig && B.push(...A.tapScriptSig.map((L) => L.signature)), !B.length) {
    const L = getTapKeySigFromWithness(A.finalScriptWitness);
    L && B.push(L);
  }
  return B;
}
function getTapKeySigFromWithness(A) {
  if (!A) return;
  const B = A.slice(2);
  if (B.length === 64 || B.length === 65) return B;
}
function _tapTreeToList(A, B = [], L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return A ? (0, types_1.isTapleaf)(A) ? (B.push({
    depth: L,
    leafVersion: A.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: A.output
  }), B) : (A[0] && _tapTreeToList(A[0], B, L + 1), A[1] && _tapTreeToList(A[1], B, L + 1), B) : [];
}
function instertLeavesInTree(A) {
  let B;
  for (const L of A)
    if (B = instertLeafInTree(L, B), !B) throw new Error("No room left to insert tapleaf in tree");
  return B;
}
function instertLeafInTree(A, B, L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (A.depth === L)
    return B ? void 0 : {
      output: A.script,
      version: A.leafVersion
    };
  if ((0, types_1.isTapleaf)(B)) return;
  const K = instertLeafInTree(A, B && B[0], L + 1);
  if (K) return [K, B && B[1]];
  const re = instertLeafInTree(A, B && B[1], L + 1);
  if (re) return [B && B[0], re];
}
function checkMixedTaprootAndNonTaprootInputFields(A, B, L) {
  const K = isTaprootInput(A) && hasNonTaprootFields(B), re = hasNonTaprootFields(A) && isTaprootInput(B), W = A === B && isTaprootInput(B) && hasNonTaprootFields(B);
  if (K || re || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(A, B, L) {
  const K = isTaprootOutput(A) && hasNonTaprootFields(B), re = hasNonTaprootFields(A) && isTaprootOutput(B), W = A === B && isTaprootOutput(B) && hasNonTaprootFields(B);
  if (K || re || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(A, B, L) {
  if (B.tapMerkleRoot) {
    const K = (B.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    ), re = (A.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    );
    if (!K || !re)
      throw new Error(
        `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
      );
  } else if (A.tapMerkleRoot && !(B.tapLeafScript || []).every(
    (re) => isTapLeafInTree(re, A.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(A, B) {
  if (!B) return !0;
  const L = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    A.controlBlock,
    L
  ).equals(B);
}
function sortSignatures(A, B) {
  const L = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (A.tapScriptSig || []).filter((K) => K.leafHash.equals(L)).map((K) => addPubkeyPositionInScript(B.script, K)).sort((K, re) => re.positionInScript - K.positionInScript).map((K) => K.signature);
}
function addPubkeyPositionInScript(A, B) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        B.pubkey,
        A
      )
    },
    B
  );
}
function findTapLeafToFinalize(A, B, L) {
  if (!A.tapScriptSig || !A.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${B}. No tapleaf script signature provided.`
    );
  const K = (A.tapLeafScript || []).sort((re, W) => re.controlBlock.length - W.controlBlock.length).find(
    (re) => canFinalizeLeaf(re, A.tapScriptSig, L)
  );
  if (!K)
    throw new Error(
      `Can not finalize taproot input #${B}. Signature for tapleaf script not found.`
    );
  return K;
}
function canFinalizeLeaf(A, B, L) {
  const K = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (!L || L.equals(K)) && B.find((W) => W.leafHash.equals(K)) !== void 0;
}
function hasNonTaprootFields(A) {
  return A && !!(A.redeemScript || A.witnessScript || A.bip32Derivation && A.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(B, L = {}) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L = {}) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L = {}) {
    const K = bip174_1.Psbt.fromBuffer(B, transactionFromBuffer), re = new Psbt(L, K);
    return checkTxForDupeIns(re.__CACHE.__TX, re.__CACHE), re;
  }
  constructor(B = {}, L = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = L, this.opts = Object.assign({}, DEFAULT_OPTS, B), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const K = (re, W, J, ne) => Object.defineProperty(re, W, {
      enumerable: J,
      writable: ne
    });
    K(this, "__CACHE", !1, !0), K(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(B) {
    this.setVersion(B);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(B) {
    this.setLocktime(B);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((B) => ({
      hash: (0, bufferutils_1.cloneBuffer)(B.hash),
      index: B.index,
      sequence: B.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((B) => {
      let L;
      try {
        L = (0, address_1.fromOutputScript)(
          B.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(B.script),
        value: B.value,
        address: L
      };
    });
  }
  combine(...B) {
    return this.data.combine(...B.map((L) => L.data)), this;
  }
  clone() {
    const B = Psbt.fromBuffer(this.data.toBuffer());
    return B.opts = JSON.parse(JSON.stringify(this.opts)), B;
  }
  setMaximumFeeRate(B) {
    check32Bit(B), this.opts.maximumFeeRate = B;
  }
  setVersion(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const L = this.__CACHE;
    return L.__TX.version = B, L.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const L = this.__CACHE;
    return L.__TX.locktime = B, L.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(B, L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const K = this.__CACHE;
    if (K.__TX.ins.length <= B)
      throw new Error("Input index too high");
    return K.__TX.ins[B].sequence = L, K.__EXTRACTED_TX = void 0, this;
  }
  addInputs(B) {
    return B.forEach((L) => this.addInput(L)), this;
  }
  addInput(B) {
    if (arguments.length > 1 || !B || B.hash === void 0 || B.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(B, B, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), B.witnessScript && checkInvalidP2WSH(B.witnessScript);
    const L = this.__CACHE;
    this.data.addInput(B);
    const K = L.__TX.ins[L.__TX.ins.length - 1];
    checkTxInputCache(L, K);
    const re = this.data.inputs.length - 1, W = this.data.inputs[re];
    return W.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, W, re), L.__FEE = void 0, L.__FEE_RATE = void 0, L.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(B) {
    return B.forEach((L) => this.addOutput(L)), this;
  }
  addOutput(B) {
    if (arguments.length > 1 || !B || B.value === void 0 || B.address === void 0 && B.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: L } = B;
    if (typeof L == "string") {
      const { network: re } = this.opts, W = (0, address_1.toOutputScript)(L, re);
      B = Object.assign({}, B, { script: W });
    }
    (0, bip371_1.checkTaprootOutputFields)(B, B, "addOutput");
    const K = this.__CACHE;
    return this.data.addOutput(B), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(B) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const L = this.__CACHE;
    if (B || checkFees(this, L, this.opts), L.__EXTRACTED_TX) return L.__EXTRACTED_TX;
    const K = L.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, K, L, !0), K;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((B) => this.finalizeInput(B)), this;
  }
  finalizeInput(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(K) ? this._finalizeTaprootInput(
      B,
      K,
      void 0,
      L
    ) : this._finalizeInput(B, K, L);
  }
  finalizeTaprootInput(B, L, K = bip371_1.tapScriptFinalizer) {
    const re = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(re))
      return this._finalizeTaprootInput(
        B,
        re,
        L,
        K
      );
    throw new Error(`Cannot finalize input #${B}. Not Taproot.`);
  }
  _finalizeInput(B, L, K = getFinalScripts) {
    const { script: re, isP2SH: W, isP2WSH: J, isSegwit: ne } = getScriptFromInput(
      B,
      L,
      this.__CACHE
    );
    if (!re) throw new Error(`No script found for input #${B}`);
    checkPartialSigSighashes(L);
    const { finalScriptSig: ie, finalScriptWitness: oe } = K(
      B,
      L,
      re,
      ne,
      W,
      J
    );
    if (ie && this.data.updateInput(B, { finalScriptSig: ie }), oe && this.data.updateInput(B, { finalScriptWitness: oe }), !ie && !oe)
      throw new Error(`Unknown error finalizing input #${B}`);
    return this.data.clearFinalizedInput(B), this;
  }
  _finalizeTaprootInput(B, L, K, re = bip371_1.tapScriptFinalizer) {
    if (!L.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${B}. Missing withness utxo.`
      );
    if (L.tapKeySig) {
      const W = payments.p2tr({
        output: L.witnessUtxo.script,
        signature: L.tapKeySig
      }), J = (0, psbtutils_1.witnessStackToScriptWitness)(
        W.witness
      );
      this.data.updateInput(B, { finalScriptWitness: J });
    } else {
      const { finalScriptWitness: W } = re(
        B,
        L,
        K
      );
      this.data.updateInput(B, { finalScriptWitness: W });
    }
    return this.data.clearFinalizedInput(B), this;
  }
  getInputType(B) {
    const L = (0, utils_1.checkForInput)(this.data.inputs, B), K = getScriptFromUtxo(B, L, this.__CACHE), re = getMeaningfulScript(
      K,
      B,
      "input",
      L.redeemScript || redeemFromFinalScriptSig(L.finalScriptSig),
      L.witnessScript || redeemFromFinalWitnessScript(L.finalScriptWitness)
    ), W = re.type === "raw" ? "" : re.type + "-", J = classifyScript(re.meaningfulScript);
    return W + J;
  }
  inputHasPubkey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return pubkeyInInput(L, K, B, this.__CACHE);
  }
  inputHasHDKey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B), re = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(re);
  }
  outputHasPubkey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B);
    return pubkeyInOutput(L, K, B, this.__CACHE);
  }
  outputHasHDKey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B), re = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(re);
  }
  validateSignaturesOfAllInputs(B) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (K) => this.validateSignaturesOfInput(K, B)
    ).reduce((K, re) => re === !0 && K, !0);
  }
  validateSignaturesOfInput(B, L, K) {
    const re = this.data.inputs[B];
    return (0, bip371_1.isTaprootInput)(re) ? this.validateSignaturesOfTaprootInput(
      B,
      L,
      K
    ) : this._validateSignaturesOfInput(B, L, K);
  }
  _validateSignaturesOfInput(B, L, K) {
    const re = this.data.inputs[B], W = (re || {}).partialSig;
    if (!re || !W || W.length < 1)
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    const J = K ? W.filter((ce) => ce.pubkey.equals(K)) : W;
    if (J.length < 1) throw new Error("No signatures for this pubkey");
    const ne = [];
    let ie, oe, V;
    for (const ce of J) {
      const ke = bscript.signature.decode(ce.signature), { hash: Ce, script: it } = V !== ke.hashType ? getHashForSig(
        B,
        Object.assign({}, re, { sighashType: ke.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ie, script: oe };
      V = ke.hashType, ie = Ce, oe = it, checkScriptForPubkey(ce.pubkey, it, "verify"), ne.push(L(ce.pubkey, Ce, ke.signature));
    }
    return ne.every((ce) => ce === !0);
  }
  validateSignaturesOfTaprootInput(B, L, K) {
    const re = this.data.inputs[B], W = (re || {}).tapKeySig, J = (re || {}).tapScriptSig;
    if (!re && !W && !(J && !J.length))
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    K = K && (0, bip371_1.toXOnly)(K);
    const ne = K ? getTaprootHashesForSig(
      B,
      re,
      this.data.inputs,
      K,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      B,
      re,
      this.data.inputs,
      this.__CACHE
    );
    if (!ne.length) throw new Error("No signatures for this pubkey");
    const ie = ne.find((V) => !V.leafHash);
    let oe = 0;
    if (W && ie) {
      if (!L(
        ie.pubkey,
        ie.hash,
        trimTaprootSig(W)
      )) return !1;
      oe++;
    }
    if (J)
      for (const V of J) {
        const ce = ne.find((ke) => V.pubkey.equals(ke.pubkey));
        if (ce) {
          if (!L(
            V.pubkey,
            ce.hash,
            trimTaprootSig(V.signature)
          )) return !1;
          oe++;
        }
      }
    return oe > 0;
  }
  signAllInputsHD(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!B || !B.publicKey || !B.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const K = [];
    for (const re of range(this.data.inputs.length))
      try {
        this.signInputHD(re, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((re) => re === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((K, re) => {
      if (!B || !B.publicKey || !B.fingerprint)
        return re(new Error("Need HDSigner to sign input"));
      const W = [], J = [];
      for (const ne of range(this.data.inputs.length))
        J.push(
          this.signInputHDAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(J).then(() => {
        if (W.every((ne) => ne === !1))
          return re(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInputHD(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(B, this.data.inputs, L).forEach((W) => this.signInput(B, W, K)), this;
  }
  signInputHDAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((re, W) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return W(new Error("Need HDSigner to sign input"));
      const ne = getSignersFromHD(B, this.data.inputs, L).map(
        (ie) => this.signInputAsync(B, ie, K)
      );
      return Promise.all(ne).then(() => {
        re();
      }).catch(W);
    });
  }
  signAllInputs(B, L) {
    if (!B || !B.publicKey)
      throw new Error("Need Signer to sign input");
    const K = [];
    for (const re of range(this.data.inputs.length))
      try {
        this.signInput(re, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((re) => re === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(B, L) {
    return new Promise((K, re) => {
      if (!B || !B.publicKey)
        return re(new Error("Need Signer to sign input"));
      const W = [], J = [];
      for (const [ne] of this.data.inputs.entries())
        J.push(
          this.signInputAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(J).then(() => {
        if (W.every((ne) => ne === !1))
          return re(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInput(B, L, K) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const re = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(re) ? this._signTaprootInput(
      B,
      re,
      L,
      void 0,
      K
    ) : this._signInput(B, L, K);
  }
  signTaprootInput(B, L, K, re) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const W = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(W))
      return this._signTaprootInput(
        B,
        W,
        L,
        K,
        re
      );
    throw new Error(`Input #${B} is not of type Taproot.`);
  }
  _signInput(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: re, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    ), J = [
      {
        pubkey: L.publicKey,
        signature: bscript.signature.encode(L.sign(re), W)
      }
    ];
    return this.data.updateInput(B, { partialSig: J }), this;
  }
  _signTaprootInput(B, L, K, re, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const J = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      re,
      W
    ), ne = J.filter((oe) => !oe.leafHash).map(
      (oe) => (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(oe.hash),
        L.sighashType
      )
    )[0], ie = J.filter((oe) => !!oe.leafHash).map((oe) => ({
      pubkey: (0, bip371_1.toXOnly)(K.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(oe.hash),
        L.sighashType
      ),
      leafHash: oe.leafHash
    }));
    return ne && this.data.updateInput(B, { tapKeySig: ne }), ie.length && this.data.updateInput(B, { tapScriptSig: ie }), this;
  }
  signInputAsync(B, L, K) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const re = (0, utils_1.checkForInput)(this.data.inputs, B);
      return (0, bip371_1.isTaprootInput)(re) ? this._signTaprootInputAsync(
        B,
        re,
        L,
        void 0,
        K
      ) : this._signInputAsync(B, L, K);
    });
  }
  signTaprootInputAsync(B, L, K, re) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const W = (0, utils_1.checkForInput)(this.data.inputs, B);
      if ((0, bip371_1.isTaprootInput)(W))
        return this._signTaprootInputAsync(
          B,
          W,
          L,
          K,
          re
        );
      throw new Error(`Input #${B} is not of type Taproot.`);
    });
  }
  _signInputAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: re, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    );
    return Promise.resolve(L.sign(re)).then((J) => {
      const ne = [
        {
          pubkey: L.publicKey,
          signature: bscript.signature.encode(J, W)
        }
      ];
      this.data.updateInput(B, { partialSig: ne });
    });
  }
  async _signTaprootInputAsync(B, L, K, re, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const J = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      re,
      W
    ), ne = [], ie = J.filter((V) => !V.leafHash)[0];
    if (ie) {
      const V = Promise.resolve(
        K.signSchnorr(ie.hash)
      ).then((ce) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          ce,
          L.sighashType
        )
      }));
      ne.push(V);
    }
    const oe = J.filter((V) => !!V.leafHash);
    if (oe.length) {
      const V = oe.map((ce) => Promise.resolve(K.signSchnorr(ce.hash)).then(
        (ke) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(K.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              ke,
              L.sighashType
            ),
            leafHash: ce.leafHash
          }
        ] })
      ));
      ne.push(...V);
    }
    return Promise.all(ne).then((V) => {
      V.forEach((ce) => this.data.updateInput(B, ce));
    });
  }
  checkTaprootHashesForSig(B, L, K, re, W) {
    if (typeof K.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${B}.`
      );
    const J = getTaprootHashesForSig(
      B,
      L,
      this.data.inputs,
      K.publicKey,
      this.__CACHE,
      re,
      W
    );
    if (!J || !J.length)
      throw new Error(
        `Can not sign for input #${B} with the key ${K.publicKey.toString(
          "hex"
        )}`
      );
    return J;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(B) {
    return this.data.updateGlobal(B), this;
  }
  updateInput(B, L) {
    return L.witnessScript && checkInvalidP2WSH(L.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[B],
      L,
      "updateInput"
    ), this.data.updateInput(B, L), L.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[B],
      B
    ), this;
  }
  updateOutput(B, L) {
    const K = this.data.outputs[B];
    return (0, bip371_1.checkTaprootOutputFields)(
      K,
      L,
      "updateOutput"
    ), this.data.updateOutput(B, L), this;
  }
  addUnknownKeyValToGlobal(B) {
    return this.data.addUnknownKeyValToGlobal(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    return this.data.addUnknownKeyValToInput(B, L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    return this.data.addUnknownKeyValToOutput(B, L), this;
  }
  clearFinalizedInput(B) {
    return this.data.clearFinalizedInput(B), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (A) => new PsbtTransaction(A);
class PsbtTransaction {
  constructor(B = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(B), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(B) {
    if (B.hash === void 0 || B.index === void 0 || !Buffer$1.isBuffer(B.hash) && typeof B.hash != "string" || typeof B.index != "number")
      throw new Error("Error adding input.");
    const L = typeof B.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash, "hex")) : B.hash;
    this.tx.addInput(L, B.index, B.sequence);
  }
  addOutput(B) {
    if (B.script === void 0 || B.value === void 0 || !Buffer$1.isBuffer(B.script) || typeof B.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(B.script, B.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(A, B, L) {
  switch (L) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, A.partialSig);
    case "multisig":
      const K = payments.p2ms({ output: B });
      return hasSigs(K.m, A.partialSig, K.pubkeys);
    default:
      return !1;
  }
}
function checkCache(A) {
  if (A.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(A, B, L) {
  if (!B) return !1;
  let K;
  if (L ? K = L.map((re) => {
    const W = compressPubkey(re);
    return B.find((J) => J.pubkey.equals(W));
  }).filter((re) => !!re) : K = B, K.length > A) throw new Error("Too many signatures");
  return K.length === A;
}
function isFinalized(A) {
  return !!A.finalScriptSig || !!A.finalScriptWitness;
}
function bip32DerivationIsMine(A) {
  return (B) => !(!B.masterFingerprint.equals(A.fingerprint) || !A.derivePath(B.path).publicKey.equals(B.pubkey));
}
function check32Bit(A) {
  if (typeof A != "number" || A !== Math.floor(A) || A > 4294967295 || A < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(A, B, L) {
  const K = B.__FEE_RATE || A.getFeeRate(), re = B.__EXTRACTED_TX.virtualSize(), W = K * re;
  if (K >= L.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(W / 1e8).toFixed(8)} in fees, which is ${K} satoshi per byte for a transaction with a VSize of ${re} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(A, B) {
  A.forEach((L) => {
    if ((0, bip371_1.isTaprootInput)(L) ? (0, bip371_1.checkTaprootInputForSigs)(L, B) : (0, psbtutils_1.checkInputForSig)(L, B))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(A) {
  if (!A.sighashType || !A.partialSig) return;
  const { partialSig: B, sighashType: L } = A;
  B.forEach((K) => {
    const { hashType: re } = bscript.signature.decode(K.signature);
    if (L !== re)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(A, B, L) {
  if (!(0, psbtutils_1.pubkeyInScript)(A, B))
    throw new Error(
      `Can not ${L} for this input with the key ${A.toString("hex")}`
    );
}
function checkTxEmpty(A) {
  if (!A.ins.every(
    (L) => L.script && L.script.length === 0 && L.witness && L.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(A, B) {
  A.ins.forEach((L) => {
    checkTxInputCache(B, L);
  });
}
function checkTxInputCache(A, B) {
  const L = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash)).toString("hex") + ":" + B.index;
  if (A.__TX_IN_CACHE[L]) throw new Error("Duplicate input detected.");
  A.__TX_IN_CACHE[L] = 1;
}
function scriptCheckerFactory(A, B) {
  return (L, K, re, W) => {
    const J = A({
      redeem: { output: re }
    }).output;
    if (!K.equals(J))
      throw new Error(
        `${B} for ${W} #${L} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(A, B, L, K) {
  if (!L.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${B}`);
  if (A === "__FEE_RATE" && K.__FEE_RATE) return K.__FEE_RATE;
  if (A === "__FEE" && K.__FEE) return K.__FEE;
  let re, W = !0;
  if (K.__EXTRACTED_TX ? (re = K.__EXTRACTED_TX, W = !1) : re = K.__TX.clone(), inputFinalizeGetAmts(L, re, K, W), A === "__FEE_RATE") return K.__FEE_RATE;
  if (A === "__FEE") return K.__FEE;
}
function getFinalScripts(A, B, L, K, re, W) {
  const J = classifyScript(L);
  if (!canFinalize(B, L, J))
    throw new Error(`Can not finalize input #${A}`);
  return prepareFinalScripts(
    L,
    J,
    B.partialSig,
    K,
    re,
    W
  );
}
function prepareFinalScripts(A, B, L, K, re, W) {
  let J, ne;
  const ie = getPayment(A, B, L), oe = W ? payments.p2wsh({ redeem: ie }) : null, V = re ? payments.p2sh({ redeem: oe || ie }) : null;
  return K ? (oe ? ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    oe.witness
  ) : ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    ie.witness
  ), V && (J = V.input)) : V ? J = V.input : J = ie.input, {
    finalScriptSig: J,
    finalScriptWitness: ne
  };
}
function getHashAndSighashType(A, B, L, K, re) {
  const W = (0, utils_1.checkForInput)(A, B), { hash: J, sighashType: ne, script: ie } = getHashForSig(
    B,
    W,
    K,
    !1,
    re
  );
  return checkScriptForPubkey(L, ie, "sign"), {
    hash: J,
    sighashType: ne
  };
}
function getHashForSig(A, B, L, K, re) {
  const W = L.__TX, J = B.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(J, re);
  let ne, ie;
  if (B.nonWitnessUtxo) {
    const ce = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), ke = W.ins[A].hash, Ce = ce.getHash();
    if (!ke.equals(Ce))
      throw new Error(
        `Non-witness UTXO hash for input #${A} doesn't match the hash specified in the prevout`
      );
    const it = W.ins[A].index;
    ie = ce.outs[it];
  } else if (B.witnessUtxo)
    ie = B.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: oe, type: V } = getMeaningfulScript(
    ie.script,
    A,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(V) >= 0)
    ne = W.hashForWitnessV0(
      A,
      oe,
      ie.value,
      J
    );
  else if ((0, psbtutils_1.isP2WPKH)(oe)) {
    const ce = payments.p2pkh({
      hash: oe.slice(2)
    }).output;
    ne = W.hashForWitnessV0(
      A,
      ce,
      ie.value,
      J
    );
  } else {
    if (B.nonWitnessUtxo === void 0 && L.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${A} has witnessUtxo but non-segwit script: ${oe.toString("hex")}`
      );
    !K && L.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ne = W.hashForSignature(
      A,
      oe,
      J
    );
  }
  return {
    script: oe,
    sighashType: J,
    hash: ne
  };
}
function getAllTaprootHashesForSig(A, B, L, K) {
  const re = [];
  if (B.tapInternalKey) {
    const J = getPrevoutTaprootKey(A, B, K);
    J && re.push(J);
  }
  if (B.tapScriptSig) {
    const J = B.tapScriptSig.map((ne) => ne.pubkey);
    re.push(...J);
  }
  return re.map(
    (J) => getTaprootHashesForSig(A, B, L, J, K)
  ).flat();
}
function getPrevoutTaprootKey(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return (0, psbtutils_1.isP2TR)(K) ? K.subarray(2, 34) : null;
}
function trimTaprootSig(A) {
  return A.length === 64 ? A : A.subarray(0, 64);
}
function getTaprootHashesForSig(A, B, L, K, re, W, J) {
  const ne = re.__TX, ie = B.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ie, J);
  const oe = L.map(
    (it, at) => getScriptAndAmountFromUtxo(at, it, re)
  ), V = oe.map((it) => it.script), ce = oe.map((it) => it.value), ke = [];
  if (B.tapInternalKey && !W) {
    const it = getPrevoutTaprootKey(A, B, re) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(K).equals(it)) {
      const at = ne.hashForWitnessV1(
        A,
        V,
        ce,
        ie
      );
      ke.push({ pubkey: K, hash: at });
    }
  }
  const Ce = (B.tapLeafScript || []).filter((it) => (0, psbtutils_1.pubkeyInScript)(K, it.script)).map((it) => {
    const at = (0, bip341_1.tapleafHash)({
      output: it.script,
      version: it.leafVersion
    });
    return Object.assign({ hash: at }, it);
  }).filter(
    (it) => !W || W.equals(it.hash)
  ).map((it) => {
    const at = ne.hashForWitnessV1(
      A,
      V,
      ce,
      ie,
      it.hash
    );
    return {
      pubkey: K,
      hash: at,
      leafHash: it.hash
    };
  });
  return ke.concat(Ce);
}
function checkSighashTypeAllowed(A, B) {
  if (B && B.indexOf(A) < 0) {
    const L = sighashTypeToString(A);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${L}`
    );
  }
}
function getPayment(A, B, L) {
  let K;
  switch (B) {
    case "multisig":
      const re = getSortedSigs(A, L);
      K = payments.p2ms({
        output: A,
        signatures: re
      });
      break;
    case "pubkey":
      K = payments.p2pk({
        output: A,
        signature: L[0].signature
      });
      break;
    case "pubkeyhash":
      K = payments.p2pkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
    case "witnesspubkeyhash":
      K = payments.p2wpkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
  }
  return K;
}
function getScriptFromInput(A, B, L) {
  const K = L.__TX, re = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (re.isP2SH = !!B.redeemScript, re.isP2WSH = !!B.witnessScript, B.witnessScript)
    re.script = B.witnessScript;
  else if (B.redeemScript)
    re.script = B.redeemScript;
  else if (B.nonWitnessUtxo) {
    const W = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), J = K.ins[A].index;
    re.script = W.outs[J].script;
  } else B.witnessUtxo && (re.script = B.witnessUtxo.script);
  return (B.witnessScript || (0, psbtutils_1.isP2WPKH)(re.script)) && (re.isSegwit = !0), re;
}
function getSignersFromHD(A, B, L) {
  const K = (0, utils_1.checkForInput)(B, A);
  if (!K.bip32Derivation || K.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const re = K.bip32Derivation.map((J) => {
    if (J.masterFingerprint.equals(L.fingerprint))
      return J;
  }).filter((J) => !!J);
  if (re.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return re.map((J) => {
    const ne = L.derivePath(J.path);
    if (!J.pubkey.equals(ne.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ne;
  });
}
function getSortedSigs(A, B) {
  return payments.p2ms({ output: A }).pubkeys.map((K) => (B.filter((re) => re.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(A) {
  let B = 0;
  function L(J) {
    return B += J, A.slice(B - J, B);
  }
  function K() {
    const J = varuint.decode(A, B);
    return B += varuint.decode.bytes, J;
  }
  function re() {
    return L(K());
  }
  function W() {
    const J = K(), ne = [];
    for (let ie = 0; ie < J; ie++) ne.push(re());
    return ne;
  }
  return W();
}
function sighashTypeToString(A) {
  let B = A & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (A & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      B += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      B += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      B += "SIGHASH_NONE";
      break;
  }
  return B;
}
function addNonWitnessTxCache(A, B, L) {
  A.__NON_WITNESS_UTXO_BUF_CACHE[L] = B.nonWitnessUtxo;
  const K = transaction_1.Transaction.fromBuffer(B.nonWitnessUtxo);
  A.__NON_WITNESS_UTXO_TX_CACHE[L] = K;
  const re = A, W = L;
  delete B.nonWitnessUtxo, Object.defineProperty(B, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const J = re.__NON_WITNESS_UTXO_BUF_CACHE[W], ne = re.__NON_WITNESS_UTXO_TX_CACHE[W];
      if (J !== void 0)
        return J;
      {
        const ie = ne.toBuffer();
        return re.__NON_WITNESS_UTXO_BUF_CACHE[W] = ie, ie;
      }
    },
    set(J) {
      re.__NON_WITNESS_UTXO_BUF_CACHE[W] = J;
    }
  });
}
function inputFinalizeGetAmts(A, B, L, K) {
  let re = 0;
  A.forEach((ie, oe) => {
    if (K && ie.finalScriptSig && (B.ins[oe].script = ie.finalScriptSig), K && ie.finalScriptWitness && (B.ins[oe].witness = scriptWitnessToWitnessStack(
      ie.finalScriptWitness
    )), ie.witnessUtxo)
      re += ie.witnessUtxo.value;
    else if (ie.nonWitnessUtxo) {
      const V = nonWitnessUtxoTxFromCache(L, ie, oe), ce = B.ins[oe].index, ke = V.outs[ce];
      re += ke.value;
    }
  });
  const W = B.outs.reduce((ie, oe) => ie + oe.value, 0), J = re - W;
  if (J < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ne = B.virtualSize();
  L.__FEE = J, L.__EXTRACTED_TX = B, L.__FEE_RATE = Math.floor(J / ne);
}
function nonWitnessUtxoTxFromCache(A, B, L) {
  const K = A.__NON_WITNESS_UTXO_TX_CACHE;
  return K[L] || addNonWitnessTxCache(A, B, L), K[L];
}
function getScriptFromUtxo(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return K;
}
function getScriptAndAmountFromUtxo(A, B, L) {
  if (B.witnessUtxo !== void 0)
    return {
      script: B.witnessUtxo.script,
      value: B.witnessUtxo.value
    };
  if (B.nonWitnessUtxo !== void 0) {
    const re = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ).outs[L.__TX.ins[A].index];
    return { script: re.script, value: re.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(A, B, L, K) {
  const re = getScriptFromUtxo(L, B, K), { meaningfulScript: W } = getMeaningfulScript(
    re,
    L,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function pubkeyInOutput(A, B, L, K) {
  const re = K.__TX.outs[L].script, { meaningfulScript: W } = getMeaningfulScript(
    re,
    L,
    "output",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function redeemFromFinalScriptSig(A) {
  if (!A) return;
  const B = bscript.decompile(A);
  if (!B) return;
  const L = B[B.length - 1];
  if (!(!Buffer$1.isBuffer(L) || isPubkeyLike(L) || isSigLike(L) || !bscript.decompile(L)))
    return L;
}
function redeemFromFinalWitnessScript(A) {
  if (!A) return;
  const B = scriptWitnessToWitnessStack(A), L = B[B.length - 1];
  if (!(isPubkeyLike(L) || !bscript.decompile(L)))
    return L;
}
function compressPubkey(A) {
  if (A.length === 65) {
    const B = A[64] & 1, L = A.slice(0, 33);
    return L[0] = 2 | B, L;
  }
  return A.slice();
}
function isPubkeyLike(A) {
  return A.length === 33 && bscript.isCanonicalPubKey(A);
}
function isSigLike(A) {
  return bscript.isCanonicalScriptSignature(A);
}
function getMeaningfulScript(A, B, L, K, re) {
  const W = (0, psbtutils_1.isP2SHScript)(A), J = W && K && (0, psbtutils_1.isP2WSHScript)(K), ne = (0, psbtutils_1.isP2WSHScript)(A);
  if (W && K === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ne || J) && re === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ie;
  return J ? (ie = re, checkRedeemScript(B, A, K, L), checkWitnessScript(B, K, re, L), checkInvalidP2WSH(ie)) : ne ? (ie = re, checkWitnessScript(B, A, re, L), checkInvalidP2WSH(ie)) : W ? (ie = K, checkRedeemScript(B, A, K, L)) : ie = A, {
    meaningfulScript: ie,
    type: J ? "p2sh-p2wsh" : W ? "p2sh" : ne ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(A) {
  if ((0, psbtutils_1.isP2WPKH)(A) || (0, psbtutils_1.isP2SHScript)(A))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(A) {
  return (0, psbtutils_1.isP2WPKH)(A) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(A) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(A) ? "multisig" : (0, psbtutils_1.isP2PK)(A) ? "pubkey" : "nonstandard";
}
function range(A) {
  return [...Array(A).keys()];
}
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.initEccLib = A.Transaction = A.opcodes = A.Psbt = A.Block = A.script = A.payments = A.networks = A.crypto = A.address = void 0;
  const B = requireAddress();
  A.address = B;
  const L = crypto$1;
  A.crypto = L;
  const K = networks;
  A.networks = K;
  const re = requirePayments();
  A.payments = re;
  const W = requireScript();
  A.script = W;
  var J = block;
  Object.defineProperty(A, "Block", {
    enumerable: !0,
    get: function() {
      return J.Block;
    }
  });
  var ne = psbt$1;
  Object.defineProperty(A, "Psbt", {
    enumerable: !0,
    get: function() {
      return ne.Psbt;
    }
  });
  var ie = ops;
  Object.defineProperty(A, "opcodes", {
    enumerable: !0,
    get: function() {
      return ie.OPS;
    }
  });
  var oe = transaction;
  Object.defineProperty(A, "Transaction", {
    enumerable: !0,
    get: function() {
      return oe.Transaction;
    }
  });
  var V = ecc_lib;
  Object.defineProperty(A, "initEccLib", {
    enumerable: !0,
    get: function() {
      return V.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: A, publicKey: B, format: L, wallet: K } = useWallie(), [re, W] = useState(null), [J, ne] = useState(!1);
  return { sign: useCallback(
    async (oe, V, ce) => {
      ne(!0);
      try {
        if (W(null), !L || !B || !K)
          throw new Error("No wallet is connected");
        const ke = src$1.Psbt.fromBase64(V), Ce = await signPsbt({
          address: oe,
          wallet: K,
          network: A,
          psbt: ke,
          options: ce
        });
        return ne(!1), Ce;
      } catch (ke) {
        throw W(ke.message), ne(!1), ke;
      }
    },
    [L, A, B, K]
  ), error: re, loading: J };
}
function leatherPaymentTypeFromFormat(A) {
  if (A === "segwit")
    return LeatherAddressType.P2WPKH;
  if (A === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: A,
  wallet: B,
  address: L,
  network: K,
  format: re
}) {
  if (B === Wallet.MAGICEDEN) {
    const { base64: W } = await signMessage$1(A, L, K);
    return W;
  }
  if (B === Wallet.UNISAT) {
    const { base64: W } = await signMessage$2(A, "bip322-simple");
    return W;
  }
  if (B === Wallet.XVERSE) {
    const { base64: W } = await signMessage$3(A, L, K);
    return W;
  }
  if (B === Wallet.LEATHER) {
    const W = leatherPaymentTypeFromFormat(re), { base64: J } = await signMessage$4(A, {
      paymentType: W,
      network: K
    });
    return J;
  }
  if (B === Wallet.OKX) {
    const { base64: W } = await signMessage$5(A, "bip322-simple", K);
    return W;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: A,
    wallet: B,
    publicKey: L,
    format: K,
    address: re
  } = useWallie(), [W, J] = useState(null), [ne, ie] = useState(!1);
  return { signMsg: useCallback(
    async (V, ce) => {
      ie(!0);
      try {
        if (J(null), !K || !L || !B)
          throw new Error("No wallet is connected");
        if (re.ordinals !== V && re.payments !== V)
          throw new Error("Address supplied is not connected address");
        const ke = await signMessage({
          address: V,
          wallet: B,
          message: ce,
          network: A,
          format: re.ordinals === V ? K.ordinals : K.payments
        });
        return ie(!1), ke;
      } catch (ke) {
        throw J(ke.message), ie(!1), ke;
      }
    },
    [K, A, L, B, re]
  ), error: W, isLoading: ne };
}
export {
  Network,
  OrdConnectKit,
  SelectWalletModal,
  Wallet,
  WallieProvider,
  useBalance,
  useSend,
  useSendBtc,
  useSendV2,
  useSign,
  useSignMessage,
  useWallie
};
