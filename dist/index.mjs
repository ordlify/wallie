(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=Poppins:wght@400;500;600;700&display=swap";/*! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.wallie-fixed{position:fixed}.wallie-relative{position:relative}.wallie-inset-0{top:0;right:0;bottom:0;left:0}.wallie-z-10{z-index:10}.wallie-z-50{z-index:50}.wallie-mx-auto{margin-left:auto;margin-right:auto}.wallie--mt-1{margin-top:-.25rem}.wallie-mb-1{margin-bottom:.25rem}.wallie-ml-auto{margin-left:auto}.wallie-block{display:block}.wallie-inline-block{display:inline-block}.wallie-flex{display:flex}.wallie-hidden{display:none}.wallie-h-\\[19px\\]{height:19px}.wallie-h-screen{height:100vh}.wallie-min-h-full{min-height:100%}.wallie-w-5{width:1.25rem}.wallie-w-6{width:1.5rem}.wallie-w-\\[19px\\]{width:19px}.wallie-w-full{width:100%}.wallie-scale-100{--tw-scale-x:1;--tw-scale-y:1}.wallie-scale-100,.wallie-scale-95{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wallie-scale-95{--tw-scale-x:.95;--tw-scale-y:.95}.wallie-transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wallie-flex-row{flex-direction:row}.wallie-flex-col{flex-direction:column}.wallie-items-end{align-items:flex-end}.wallie-items-center{align-items:center}.wallie-justify-center{justify-content:center}.wallie-justify-between{justify-content:space-between}.wallie-space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.wallie-space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(1rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(1rem*var(--tw-space-x-reverse))}.wallie-space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(1rem*var(--tw-space-y-reverse));margin-top:calc(1rem*(1 - var(--tw-space-y-reverse)))}.wallie-overflow-hidden{overflow:hidden}.wallie-overflow-y-auto{overflow-y:auto}.wallie-break-all{word-break:break-all}.wallie-rounded-full{border-radius:9999px}.wallie-rounded-lg{border-radius:.5rem}.wallie-bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.wallie-bg-ord-blue-600{--tw-bg-opacity:1;background-color:rgb(23 30 45/var(--tw-bg-opacity))}.wallie-bg-ord-light-blue{--tw-bg-opacity:1;background-color:rgb(48 55 70/var(--tw-bg-opacity))}.wallie-bg-ord-light-blue-400{--tw-bg-opacity:1;background-color:rgb(73 82 102/var(--tw-bg-opacity))}.wallie-bg-ord-orange{--tw-bg-opacity:1;background-color:rgb(255 108 58/var(--tw-bg-opacity))}.wallie-bg-opacity-90{--tw-bg-opacity:.9}.wallie-p-1{padding:.25rem}.wallie-p-2{padding:.5rem}.wallie-p-4{padding:1rem}.wallie-p-8{padding:2rem}.wallie-px-1{padding-left:.25rem;padding-right:.25rem}.wallie-py-3{padding-bottom:.75rem;padding-top:.75rem}.wallie-pb-4{padding-bottom:1rem}.wallie-pr-2{padding-right:.5rem}.wallie-pr-3{padding-right:.75rem}.wallie-pt-4{padding-top:1rem}.wallie-text-left{text-align:left}.wallie-text-\\[21px\\]{font-size:21px}.wallie-text-lg{font-size:1.125rem;line-height:1.75rem}.wallie-text-sm{font-size:.875rem;line-height:1.25rem}.wallie-font-medium{font-weight:500}.wallie-leading-8{line-height:2rem}.wallie-text-ord-alert{--tw-text-opacity:1;color:rgb(248 242 94/var(--tw-text-opacity))}.wallie-text-ord-blue{--tw-text-opacity:1;color:rgb(17 22 33/var(--tw-text-opacity))}.wallie-text-ord-gray{--tw-text-opacity:1;color:rgb(137 138 149/var(--tw-text-opacity))}.wallie-text-ord-light-blue-400{--tw-text-opacity:1;color:rgb(73 82 102/var(--tw-text-opacity))}.wallie-text-ord-light-gray{--tw-text-opacity:1;color:rgb(217 213 210/var(--tw-text-opacity))}.wallie-opacity-0{opacity:0}.wallie-opacity-100{opacity:1}.wallie-transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-duration-100{transition-duration:.1s}.wallie-duration-200{transition-duration:.2s}.wallie-duration-300{transition-duration:.3s}.wallie-ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.wallie-ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}body,html{font-family:Outfit,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;scroll-behavior:smooth}@media (min-width:640px){.sm\\:wallie-items-center{align-items:center}.sm\\:wallie-p-0{padding:0}}@media (min-width:768px){.md\\:wallie-block{display:block}.md\\:wallie-w-7{width:1.75rem}.md\\:wallie-w-8{width:2rem}.md\\:wallie-w-96{width:24rem}.md\\:wallie-space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.md\\:wallie-bg-opacity-75{--tw-bg-opacity:.75}.md\\:wallie-px-3{padding-left:.75rem}.md\\:wallie-pr-3,.md\\:wallie-px-3{padding-right:.75rem}.md\\:wallie-text-xl{font-size:1.25rem;line-height:1.75rem}}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
var $e = Object.defineProperty;
var Je = (s, e, n) => e in s ? $e(s, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[e] = n;
var S = (s, e, n) => Je(s, typeof e != "symbol" ? e + "" : e, n);
import { j as h, q as R, a as ee, s as Ye, e as he, B as H, b as I, O as Qe, z as we, c as se, g as et, d as tt, f as nt, h as He, _ as ue, i as Te, k as ke, r as st, l as at } from "./vendor-ByoEvwJu.js";
import { useState as j, useEffect as re, useCallback as O, createContext as it, useMemo as rt, useContext as ot, Fragment as te } from "react";
const Ue = "wallie";
function Ke() {
  return typeof window < "u";
}
function Ee(s, e) {
  if (!Ke()) return;
  const n = `${Ue}_${s}`;
  try {
    e ? window.localStorage.setItem(n, JSON.stringify(e)) : window.localStorage.removeItem(n);
  } catch {
  }
}
function q(s, e, n = {}) {
  const { initializeWithValue: a = !0 } = n, t = O(() => function(w) {
    if (!Ke()) return null;
    const p = `${Ue}_${w}`;
    try {
      const c = window.localStorage.getItem(p);
      return c != null ? JSON.parse(c) : null;
    } catch {
      return null;
    }
  }(s) || (Ee(s, e), e), [e, s]), [i, r] = j(() => a ? t() : e), o = O((d) => {
    Ee(s, d), r(d);
  }, [s]);
  return re(() => {
    r(t());
  }, [s]), [i, o];
}
var ne = ((s) => (s.MAINNET = "mainnet", s.TESTNET = "testnet", s.SIGNET = "signet", s))(ne || {}), C = ((s) => (s.UNISAT = "unisat", s.XVERSE = "xverse", s.MAGICEDEN = "magiceden", s.LEATHER = "leather", s.OKX = "okx", s))(C || {});
const W = { payments: null, ordinals: null }, Le = it(void 0);
function Bt({ children: s, initialNetwork: e, ssr: n = !1 }) {
  if (!e) throw new Error("Initial network cannot be empty");
  const [a, t] = j(e), [i, r] = q("address", W, { initializeWithValue: !n }), [o, d] = q("wallet", null, { initializeWithValue: !n }), [w, p] = q("publicKey", W, { initializeWithValue: !n }), [c, u] = q("format", W, { initializeWithValue: !n }), [l, f] = j(!1), g = O(() => f(!0), []), E = O(() => f(!1), []), v = O(() => {
    r(W), p(W), u(W), d(null);
  }, [r, u, p, d]), k = rt(() => ({ address: i, updateAddress: r, publicKey: w, updatePublicKey: p, network: a, updateNetwork: t, wallet: o, updateWallet: d, isModalOpen: l, openModal: g, closeModal: E, format: c, updateFormat: u, disconnectWallet: v }), [i, r, w, p, a, t, o, d, l, g, E, c, u, v]);
  return re(() => {
    t(e);
  }, [e]), h.jsx(Le.Provider, { value: k, children: s });
}
function L() {
  const s = ot(Le);
  if (!s) throw new Error("useWallie must be used within WallieProvider");
  return s;
}
const lt = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", Xe = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.2692%206.04835H10.6729C7.79592%2012.2004%2012.4577%2014.8894%2015.1483%2015.4648L13.9495%2019.3884C12.7348%2018.4467%2010.7795%2018.0282%209.79384%2017.8974C5.55824%2017.662%204.20118%2020.7103%204.03982%2021.9779C3.72015%2024.4889%205.31849%2026.9215%209.07459%2026.9215C12.0795%2026.9215%2014.3758%2025.2998%2015.1483%2024.4889C18.0892%2027%2020.7958%2027.1569%2021.7814%2026.9215C26.7043%2026.5449%2027.5621%2022.004%2027.3756%2019.7807H24.1789C23.4117%2025.8072%2019.0642%2023.338%2016.9864%2021.3501L18.6646%2015.7002C30.0128%2013.1892%2029.9329%204.322%2024.1789%204.00811C19.5757%203.75701%2016.8265%209.39643%2016.0274%2012.2475C12.1914%2011.6198%2013.2569%207.85317%2014.2692%206.04835Z'%20fill='white'/%3e%3cpath%20d='M19.5437%2012.2475C19.9699%2010.6258%2021.7814%206.99461%2023.7793%207.2254C26.4965%207.53927%2022.6605%2011.5413%2019.5437%2012.2475Z'%20fill='%23303746'/%3e%3cpath%20d='M12.8307%2022.2918C11.7918%2021.2716%208.03567%2020.0946%207.31642%2022.2918C7.00817%2023.2334%209.47418%2024.8813%2012.8307%2022.2918Z'%20fill='%23303746'/%3e%3c/svg%3e", ct = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", Fe = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21.403%2011.0761L22.9233%2012.9126C23.0973%2013.1219%2023.2486%2013.2846%2023.3167%2013.3853C23.7705%2013.8503%2024.0277%2014.478%2024.0277%2015.1289C23.9823%2015.8961%2023.4982%2016.423%2023.0444%2016.9887L21.9779%2018.2673L21.4257%2018.9338C21.403%2018.957%2021.3954%2018.988%2021.3879%2019.019C21.3803%2019.05%2021.3879%2019.081%2021.403%2019.1043C21.4181%2019.1353%2021.4332%2019.1585%2021.4635%2019.174C21.4862%2019.1895%2021.5165%2019.1973%2021.5467%2019.1973H27.0986C27.9458%2019.1973%2029.0123%2019.9257%2028.9518%2021.0338C28.9518%2021.5375%2028.7476%2022.018%2028.3996%2022.3744C28.0441%2022.7309%2027.5676%2022.9324%2027.0684%2022.9324H18.3699C17.795%2022.9324%2016.2595%2022.9944%2015.8284%2021.6538C15.7376%2021.3748%2015.7225%2021.0726%2015.7906%2020.7858C15.9192%2020.3596%2016.1158%2019.9567%2016.373%2019.6002C16.8117%2018.9338%2017.2807%2018.2751%2017.7496%2017.6319C18.3547%2016.7872%2018.9674%2015.9736%2019.5801%2015.1134C19.6028%2015.0824%2019.6103%2015.0514%2019.6103%2015.0127C19.6103%2014.9739%2019.5952%2014.9429%2019.5801%2014.9119L17.3714%2012.254C17.3563%2012.2385%2017.3412%2012.223%2017.3185%2012.2075C17.2958%2012.1997%2017.2731%2012.192%2017.2504%2012.192C17.2277%2012.192%2017.205%2012.1997%2017.1823%2012.2075C17.1596%2012.2152%2017.1445%2012.2307%2017.1294%2012.254C16.5394%2013.0599%2013.945%2016.6323%2013.3928%2017.3607C12.8406%2018.0814%2011.4791%2018.1279%2010.7228%2017.3607L7.26605%2013.8581C7.24335%2013.8348%207.2131%2013.8193%207.18284%2013.8116C7.15259%2013.8038%207.12233%2013.8116%207.09208%2013.8193C7.06182%2013.8348%207.03913%2013.8503%207.024%2013.8813C7.00887%2013.9045%206.99374%2013.9355%207.00131%2013.9665V20.7006C7.00887%2021.181%206.87272%2021.646%206.60042%2022.0412C6.32812%2022.4364%205.94993%2022.7309%205.50365%2022.8936C5.21623%2022.9944%204.91367%2023.0254%204.61868%2022.9789C4.32368%2022.9324%204.03626%2022.8239%203.79421%2022.6456C3.5446%2022.4674%203.34794%2022.2349%203.21179%2021.9637C3.07564%2021.6925%203%2021.3903%203%2021.0881V8.97605C3.02269%208.54209%203.17397%208.12364%203.44627%207.77492C3.71857%207.43396%204.08164%207.18598%204.49765%207.06974C4.85316%206.97675%205.23135%206.97675%205.58686%207.06974C5.94236%207.17048%206.26761%207.35646%206.53235%207.62769L11.8498%2012.9979C11.8649%2013.0134%2011.8876%2013.0289%2011.9027%2013.0366C11.9254%2013.0444%2011.9481%2013.0444%2011.9708%2013.0444C11.9935%2013.0444%2012.0162%2013.0366%2012.0313%2013.0211C12.054%2013.0134%2012.0691%2012.9979%2012.0843%2012.9746L15.8586%207.69743C16.0326%207.48045%2016.252%207.30997%2016.5016%207.19373C16.7512%207.07749%2017.0235%207.00775%2017.2958%207.00775H27.1137C27.386%207.00775%2027.6508%207.06974%2027.8928%207.17823C28.1349%207.29447%2028.3542%207.4572%2028.5358%207.65868C28.7097%207.86016%2028.8459%208.10039%2028.9215%208.36386C28.9972%208.62733%2029.0199%208.89856%2028.982%209.16978C28.914%209.63473%2028.6795%2010.0609%2028.324%2010.3632C27.9685%2010.6654%2027.5146%2010.8359%2027.0457%2010.8281H21.5467C21.5165%2010.8281%2021.4938%2010.8359%2021.4711%2010.8514C21.4484%2010.8669%2021.4257%2010.8901%2021.4181%2010.9134C21.403%2010.9366%2021.403%2010.9676%2021.403%2010.9908C21.3803%2011.0218%2021.3879%2011.0528%2021.403%2011.0761Z'%20fill='url(%23paint0_linear_3119_13568)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13568'%20x1='4.08333'%20y1='11'%20x2='29'%20y2='11'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23EF2690'/%3e%3cstop%20offset='1'%20stop-color='%23AB27FE'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", ze = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.2892%204.87219L26.2505%2010.3415C26.7579%2010.8061%2027.0077%2011.2762%2026.9998%2011.7498C26.992%2012.2235%2026.7737%2012.6553%2026.3469%2013.047C25.9004%2013.457%2025.4185%2013.6647%2024.9032%2013.6738C24.3879%2013.6811%2023.8766%2013.4515%2023.3691%2012.9869L17.2721%207.39369C16.5798%206.75785%2015.9111%206.30785%2015.268%206.04367C14.6248%205.7795%2013.9482%205.73759%2013.2402%205.91978C12.5302%206.10015%2011.769%206.56473%2010.9528%207.31171C9.82782%208.34472%209.29089%209.31397%209.34596%2010.2195C9.40103%2011.1249%209.9596%2012.065%2011.0197%2013.0361L17.1659%2018.6767C17.6792%2019.1467%2017.931%2019.6168%2017.9231%2020.0832C17.9152%2020.5514%2017.695%2020.9832%2017.2603%2021.3822C16.8276%2021.7794%2016.3497%2021.9871%2015.8305%2022.0035C15.3112%2022.0199%2014.794%2021.7921%2014.2826%2021.3221L8.32127%2015.8528C7.35164%2014.9637%206.65146%2014.122%206.22074%2013.3276C5.79001%2012.5333%205.62874%2011.6351%205.74084%2010.633C5.84115%209.77491%206.13813%208.94413%206.63376%208.13885C7.12743%207.33357%207.83547%206.51008%208.75396%205.66654C9.84749%204.66268%2010.8919%203.89384%2011.887%203.3582C12.8803%202.82256%2013.842%202.52559%2014.7704%202.46365C15.7006%202.4017%2016.6172%202.57296%2017.5239%202.97742C18.4305%203.38188%2019.351%204.01226%2020.2872%204.87219H20.2892Z'%20fill='url(%23paint0_linear_3119_13572)'/%3e%3cpath%20d='M10.9371%2026.9408L4.97771%2021.4714C4.47027%2021.005%204.22049%2020.5368%204.22836%2020.0631C4.23623%2019.5894%204.45454%2019.1576%204.88133%2018.7659C5.32779%2018.356%205.80966%2018.1483%206.32495%2018.1392C6.84025%2018.1319%207.35162%2018.3596%207.85905%2018.826L13.9541%2024.4193C14.6484%2025.0551%2015.3151%2025.5051%2015.9583%2025.7693C16.6014%2026.0335%2017.278%2026.0735%2017.988%2025.8932C18.698%2025.7128%2019.4591%2025.2482%2020.2754%2024.4994C21.4004%2023.4664%2021.9373%2022.4972%2021.8822%2021.5917C21.8272%2020.6862%2021.2686%2019.7461%2020.2085%2018.7732L16.9338%2015.7944C16.4205%2015.3244%2016.1687%2014.8543%2016.1766%2014.3879C16.1845%2013.9197%2016.4047%2013.4879%2016.8394%2013.0889C17.2721%2012.6917%2017.75%2012.484%2018.2692%2012.4676C18.7885%2012.4512%2019.3057%2012.679%2019.8171%2013.149L22.905%2015.9566C23.8746%2016.8457%2024.5748%2017.6874%2025.0055%2018.4817C25.4362%2019.2761%2025.5975%2020.1743%2025.4854%2021.1763C25.3851%2022.0344%2025.0881%2022.8652%2024.5925%2023.6705C24.0988%2024.4757%2023.3908%2025.2992%2022.4723%2026.1428C21.3787%2027.1466%2020.3344%2027.9155%2019.3392%2028.4511C18.344%2028.9868%2017.3822%2029.2856%2016.4519%2029.3475C15.5216%2029.4094%2014.6051%2029.2382%2013.6984%2028.8337C12.7917%2028.4293%2011.8713%2027.7989%2010.9351%2026.9389L10.9371%2026.9408Z'%20fill='url(%23paint1_linear_3119_13572)'/%3e%3cpath%20d='M14.6543%2012.8284C15.8633%2012.8284%2016.8433%2011.9205%2016.8433%2010.8006C16.8433%209.6807%2015.8633%208.77284%2014.6543%208.77284C13.4453%208.77284%2012.4653%209.6807%2012.4653%2010.8006C12.4653%2011.9205%2013.4453%2012.8284%2014.6543%2012.8284Z'%20fill='url(%23paint2_radial_3119_13572)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_3119_13572'%20x1='25.27'%20y1='8.05866'%20x2='7.28614'%20y2='16.6864'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_3119_13572'%20x1='6.4668'%20y1='23.9797'%20x2='27.5911'%20y2='17.1926'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_3119_13572'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(14.6543%2010.8024)%20scale(2.18903%202.02777)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", De = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M27.0042%2026.6428V22.6649C27.0042%2022.5072%2026.9416%2022.3568%2026.8298%2022.245L9.90453%205.31965C9.79276%205.20788%209.64232%205.14521%209.4846%205.14521H5.50684C5.31046%205.14521%205.15063%205.30503%205.15063%205.50141V9.19714C5.15063%209.35487%205.21331%209.50528%205.32508%209.61706L11.4004%2015.6923C11.5393%2015.8313%2011.5393%2016.0569%2011.4004%2016.1959L5.25509%2022.3411C5.18824%2022.4079%205.15063%2022.4988%205.15063%2022.5929V26.6428C5.15063%2026.839%205.31046%2026.999%205.50684%2026.999H12.1535C12.3499%2026.999%2012.5097%2026.839%2012.5097%2026.6428V24.2569C12.5097%2024.1629%2012.5473%2024.072%2012.6142%2024.0051L15.9108%2020.7084C16.0498%2020.5695%2016.2754%2020.5695%2016.4144%2020.7084L22.5314%2026.8256C22.6432%2026.9373%2022.7936%2027%2022.9513%2027H26.647C26.8434%2027%2027.0032%2026.8401%2027.0032%2026.6438L27.0042%2026.6428Z'%20fill='white'/%3e%3cpath%20d='M18.1379%2010.413H21.467C21.6644%2010.413%2021.8253%2010.5739%2021.8253%2010.7713V14.1003C21.8253%2014.42%2022.2118%2014.5799%2022.4374%2014.3531L27.0043%209.77894C27.0711%209.71207%2027.1088%209.62121%2027.1088%209.52614V5.52017C27.1088%205.32275%2026.9488%205.16188%2026.7504%205.16188L22.6849%205.15666C22.5899%205.15666%2022.4991%205.19426%2022.4311%205.26112L17.8841%209.80087C17.6585%2010.0265%2017.8182%2010.413%2018.1369%2010.413H18.1379Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function pe(s, e = 4, n = 5) {
  return s.length <= e + n ? s : `${s.slice(0, e)}...${s.slice(s.length - n)}`;
}
const dt = { [C.XVERSE]: De, [C.MAGICEDEN]: Fe, [C.UNISAT]: ze, [C.LEATHER]: Xe, [C.OKX]: "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11.8444%205H5.48893C5.21893%205%205%205.21883%205%205.48892V11.8444C5%2012.1144%205.21893%2012.3334%205.48893%2012.3334H11.8444C12.1145%2012.3334%2012.3334%2012.1144%2012.3334%2011.8444V5.48892C12.3334%205.21883%2012.1145%205%2011.8444%205ZM19.1807%2012.3336H12.8252C12.5552%2012.3336%2012.3363%2012.5524%2012.3363%2012.8224V19.178C12.3363%2019.448%2012.5552%2019.6669%2012.8252%2019.6669H19.1807C19.4507%2019.6669%2019.6697%2019.448%2019.6697%2019.178V12.8224C19.6697%2012.5524%2019.4507%2012.3336%2019.1807%2012.3336ZM20.1556%205.00001H26.5112C26.7812%205.00001%2027%205.21884%2027%205.48893V11.8444C27%2012.1144%2026.7812%2012.3334%2026.5112%2012.3334H20.1556C19.8856%2012.3334%2019.6666%2012.1144%2019.6666%2011.8444V5.48893C19.6666%205.21884%2019.8856%205.00001%2020.1556%205.00001ZM11.8445%2019.6665H5.48895C5.21895%2019.6665%205.00002%2019.8853%205.00002%2020.1553V26.511C5.00002%2026.781%205.21895%2026.9999%205.48895%2026.9999H11.8445C12.1146%2026.9999%2012.3334%2026.781%2012.3334%2026.511V20.1553C12.3334%2019.8853%2012.1146%2019.6665%2011.8445%2019.6665ZM20.1556%2019.6665H26.5112C26.7812%2019.6665%2027%2019.8853%2027%2020.1553V26.511C27%2026.781%2026.7812%2026.9999%2026.5112%2026.9999H20.1556C19.8856%2026.9999%2019.6666%2026.781%2019.6666%2026.511V20.1553C19.6666%2019.8853%2019.8856%2019.6665%2020.1556%2019.6665Z'%20fill='white'/%3e%3c/svg%3e" }, ut = { [ne.MAINNET]: "Mainnet", [ne.TESTNET]: "Testnet", [ne.SIGNET]: "Signet" };
function wt({ address: s, network: e, onViewProfile: n, onChangeWallet: a, onDisconnectWallet: t }) {
  const { wallet: i } = L();
  return h.jsx(R, { as: "section", className: "wallie-relative wallie-inline-block wallie-text-left", children: ({ open: r }) => h.jsxs(h.Fragment, { children: [h.jsxs(R.Button, { children: [h.jsx("div", { className: "wallet-identifier-container", children: h.jsx("img", { src: dt[i], alt: `${i} is connected` }) }), h.jsxs("section", { className: "address-container", children: [h.jsx("p", { className: "address", children: pe(s) }), h.jsxs("section", { className: "network-container", children: [h.jsx("div", { className: "status-indicator" }), h.jsx("p", { className: "network", children: ut[e] ?? e })] })] }), h.jsx("img", { src: lt, className: "dropdown-button " + (r ? "close-dropdown-button" : "expand-dropdown-button"), alt: "ord connect dropdown" })] }), h.jsx(ee, { as: te, enter: "transition ease-out duration-100", enterFrom: "transform opacity-0 scale-95", enterTo: "transform opacity-100 scale-100", leave: "transition ease-in duration-75", leaveFrom: "transform opacity-100 scale-100", leaveTo: "transform opacity-0 scale-95", children: h.jsxs(R.Items, { className: "ord-wallet-connection-dropdown", children: [h.jsxs(R.Item, { as: "button", className: "dropdown-button", onClick: () => n == null ? void 0 : n(), children: [h.jsx("span", { className: "label", children: "View profile" }), h.jsx("span", { className: "value", children: pe(s) })] }), h.jsx(R.Item, { as: "button", className: "dropdown-button", onClick: () => a == null ? void 0 : a(), children: h.jsx("span", { className: "change-wallet-label", children: "Change wallet" }) }), h.jsx("hr", { className: "horizontal-separator" }), h.jsxs(R.Item, { as: "button", className: "dropdown-button", onClick: () => t == null ? void 0 : t(), children: [h.jsx("span", { className: "label", children: "Disconnect wallet" }), h.jsx("img", { src: ct, className: "logout-icon", alt: "logout" })] })] }) })] }) });
}
const pt = "data:image/svg+xml,%3csvg%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3cpath%20d='M9%206.25C7.61929%206.25%206.5%207.36929%206.5%208.75V21.25C6.5%2022.6308%207.61929%2023.75%209%2023.75H25C26.3808%2023.75%2027.5%2022.6308%2027.5%2021.25V18.75H23.75C21.6789%2018.75%2020%2017.0711%2020%2015C20%2012.9289%2021.6789%2011.25%2023.75%2011.25H27.5V8.75C27.5%207.36929%2026.3808%206.25%2025%206.25H9Z'%20fill='%231C2033'%20/%3e%3cpath%20d='M25%2015C25%2015.6904%2024.4404%2016.25%2023.75%2016.25C23.0596%2016.25%2022.5%2015.6904%2022.5%2015C22.5%2014.3096%2023.0596%2013.75%2023.75%2013.75C24.4404%2013.75%2025%2014.3096%2025%2015Z'%20fill='%231C2033'%20/%3e%3c/svg%3e";
function ht({ openModal: s, disabled: e, connectButton: n = "Wallet Connect", connectButtonComponent: a }) {
  return a ? h.jsx("button", { onClick: s, "aria-label": "Connect Button", type: "button", className: "wallie-w-full", children: a }) : h.jsxs("button", { type: "button", onClick: s, disabled: e, className: "wallie-bg-ord-orange wallie-rounded-full wallie-flex wallie-flex-row md:wallie-space-x-2 wallie-items-center wallie-p-1 wallie-pr-2 wallie-px-1 md:wallie-pr-3 md:wallie-px-3", children: [h.jsx("img", { className: "wallie-w-6 md:wallie-w-7", src: pt, alt: "" }), h.jsx("span", { className: "wallie-hidden md:wallie-block wallie-text-ord-blue wallie-mb-1 wallie-pr-2", children: n })] });
}
const ft = "data:image/svg+xml,%3csvg%20width='19'%20height='19'%20viewBox='0%200%2019%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.07844%204.07811C4.25659%203.90001%204.49818%203.79996%204.75009%203.79996C5.002%203.79996%205.24359%203.90001%205.42174%204.07811L9.50009%208.15646L13.5784%204.07811C13.6661%203.98738%2013.7709%203.915%2013.8868%203.86521C14.0027%203.81542%2014.1274%203.78922%2014.2535%203.78812C14.3796%203.78703%2014.5047%203.81106%2014.6215%203.85883C14.7382%203.9066%2014.8443%203.97714%2014.9335%204.06633C15.0227%204.15553%2015.0933%204.2616%2015.141%204.37835C15.1888%204.4951%2015.2128%204.6202%2015.2117%204.74634C15.2106%204.87248%2015.1844%204.99714%2015.1346%205.11304C15.0848%205.22895%2015.0125%205.33378%2014.9217%205.42141L10.8434%209.49976L14.9217%2013.5781C15.0948%2013.7573%2015.1905%2013.9973%2015.1884%2014.2463C15.1862%2014.4954%2015.0863%2014.7337%2014.9102%2014.9098C14.734%2015.086%2014.4958%2015.1859%2014.2467%2015.1881C13.9976%2015.1902%2013.7576%2015.0945%2013.5784%2014.9214L9.50009%2010.8431L5.42174%2014.9214C5.24257%2015.0945%205.0026%2015.1902%204.75351%2015.1881C4.50442%2015.1859%204.26615%2015.086%204.09001%2014.9098C3.91387%2014.7337%203.81396%2014.4954%203.8118%2014.2463C3.80964%2013.9973%203.90539%2013.7573%204.07844%2013.5781L8.15679%209.49976L4.07844%205.42141C3.90034%205.24326%203.80029%205.00167%203.80029%204.74976C3.80029%204.49785%203.90034%204.25626%204.07844%204.07811Z'%20fill='%23D9D5D2'/%3e%3c/svg%3e", Re = Ye.BIP32Factory(he), We = H.alloc(32, 1);
class F extends Error {
  constructor(e = "Cannot extract transaction from non-finalized psbt.") {
    super(e), this.name = "BrowserWalletExtractTxFromNonFinalizedPsbtError";
  }
}
class ae extends Error {
  constructor(e) {
    super(e), this.name = "BrowserWalletNetworkMismatchError";
  }
}
class M extends Error {
  constructor(e) {
    super(e), this.name = "BrowserWalletNotInstalledError";
  }
}
class X extends Error {
  constructor(e = "Request canceled by user.") {
    super(e), this.name = "BrowserWalletRequestCancelledByUserError";
  }
}
class D extends Error {
  constructor(e) {
    super(e), this.name = "BrowserWalletSigningError";
  }
}
class y extends Error {
  constructor(e) {
    super(e), this.name = "OrditSDKError";
  }
}
const K = { p2pkh: "legacy", p2sh: "p2sh-p2wpkh", p2wsh: "p2wsh", p2wpkh: "segwit", p2tr: "taproot" }, mt = (Se = K, Object.fromEntries(Object.entries(Se).map(([s, e]) => [e, s])));
var Se;
function z(s) {
  return s === "mainnet" ? I.networks.bitcoin : s === "signet" ? I.networks.testnet : I.networks[s];
}
function ie(s, e, n, a) {
  I.initEccLib(he);
  const t = typeof n == "string" ? z(n) : n;
  return e === "p2tr" ? I.payments.p2tr({ internalPubkey: s, network: t, ...a }) : e === "p2sh" ? I.payments.p2sh({ redeem: I.payments.p2wpkh({ pubkey: s, network: t }), network: t }) : I.payments[e]({ pubkey: s, network: t });
}
function Ie(s) {
  return s.subarray(1, 33);
}
const gt = (s) => (s == null ? void 0 : s.constructor) === Object, xt = (s) => s instanceof String || typeof s == "string";
function Ve(s, { encode: e, depth: n = 0 }) {
  if (n > 5) throw new y("Object too deep");
  for (const a in s) {
    if (!s.hasOwnProperty(a)) continue;
    const t = s[a];
    gt(t) ? s[a] = Ve(t, { encode: e, depth: n + 1 }) : xt(t) && (s[a] = e ? encodeURIComponent(t) : decodeURIComponent(t));
  }
  return s;
}
function yt(s) {
  return Ve(s, { encode: !1 });
}
function V(s, e) {
  return `${s}:${e}`;
}
function Ne(s) {
  return s.includes(":") ? s.replace(":", "i") : s.includes("i") ? s : `${s}i0`;
}
function Z(s, e) {
  return (n) => {
    try {
      return s({ output: n, network: z(e) });
    } catch {
      return !1;
    }
  };
}
function Me(s, e) {
  const n = ((r, o) => ({ type: "p2pkh", payload: Z(I.payments.p2pkh, o)(r) }))(s, e);
  if (n.payload) return { format: K.p2pkh, ...n };
  const a = ((r, o) => ({ type: "p2wpkh", payload: Z(I.payments.p2wpkh, o)(r) }))(s, e);
  if (a.payload) return { format: K.p2wpkh, ...a };
  const t = ((r, o) => ({ type: "p2sh", payload: Z(I.payments.p2sh, o)(r) }))(s, e);
  if (t.payload) return { format: K.p2sh, ...t };
  const i = ((r, o) => ({ type: "p2tr", payload: Z(I.payments.p2tr, o)(r) }))(s, e);
  if (i.payload) return { format: K.p2tr, ...i };
  throw new y("Unsupported input");
}
function _e(s, e) {
  if (e === "regtest") return function(a) {
    try {
      const { type: t, network: i, bech32: r } = we(a);
      if (!r && i !== "testnet" || r && i !== "regtest") throw new Error("Invalid address");
      return K[t];
    } catch {
      throw new y("Invalid address");
    }
  }(s);
  if (!Qe(s, e === "signet" ? "testnet" : e)) throw new y("Invalid address");
  const { type: n } = we(s);
  return K[n];
}
function je(s, e, n) {
  if (n === "p2tr") return function(t, i) {
    const r = t.subarray(1, 33), { address: o } = ie(r, "p2tr", i);
    return { address: o, format: K.p2tr, publicKey: t.toString("hex"), xKey: r.toString("hex") };
  }(s, e);
  const { address: a } = ie(s, n, e);
  return { address: a, format: K[n], publicKey: s.toString("hex") };
}
var _ = ((s) => (s.P2WPKH = "p2wpkh", s.P2TR = "p2tr", s))(_ || {});
async function fe(s, e) {
  try {
    return (await window.LeatherProvider.request(s, e)).result;
  } catch (n) {
    const a = n, { message: t } = a.error;
    throw a.error.code === 4001 ? new X(t) : new y(`Leather error: ${t}`);
  }
}
function me() {
  if (typeof window > "u") throw new y("Cannot call this function outside a browser");
  return window.LeatherProvider !== void 0;
}
const ge = { mainnet: se.Mainnet, testnet: se.Testnet };
async function Oe(s, e = "mainnet") {
  if (e === "signet") throw new y("signet network is not supported");
  const n = [], a = { payload: { purposes: ["ordinals", "payment"], message: "Provide access to Payment address and Ordinals address", network: { type: ge[e] } }, getProvider: s, onFinish: (t) => ((i) => {
    if (!i || !i.addresses || i.addresses.length !== 2) throw new D("Failed to retrieve addresses using selected wallet");
    i.addresses.forEach((r) => {
      const o = _e(r.address, e);
      let d = r.publicKey;
      var w;
      o === "taproot" && (w = r.publicKey, d = H.from(w, "hex").length === 33 ? w : `02${w}`), n.push({ publicKey: d, address: r.address, format: o });
    });
  })(t), onCancel: () => {
    throw new X();
  } };
  return await et(a), n;
}
async function Ae(s, e, { finalize: n = !0, extractTx: a = !0, network: t, inputsToSign: i } = { network: "mainnet", inputsToSign: [] }) {
  if (t === "signet") throw new y("signet network is not supported");
  if (!n && a) throw new F();
  if (!e || !t || !i.length) throw new y("Invalid options provided");
  let r, o = null;
  const d = { payload: { network: { type: ge[t] }, message: "Sign PSBT", psbtBase64: e.toBase64(), broadcast: !1, inputsToSign: i }, onFinish: (w) => {
    const { psbtBase64: p } = w;
    if (!p) throw new D("Failed to sign psbt using selected wallet");
    const c = I.Psbt.fromBase64(p);
    if (n && i.forEach((u) => {
      u.signingIndexes.forEach((l) => {
        try {
          c.finalizeInput(l);
        } catch {
          throw new y("Failed to finalize input");
        }
      });
    }), a) {
      try {
        r = c.extractTransaction().toHex();
      } catch (u) {
        throw u instanceof Error && u.message === "Not finalized" ? new F() : new y("Failed to extract transaction from PSBT");
      }
      o = null;
    } else r = c.toHex(), o = c.toBase64();
  }, onCancel: () => {
    throw new X();
  }, getProvider: s };
  return await tt(d), { hex: r, base64: o };
}
async function Pe(s, e, n, a = "mainnet") {
  if (a === "signet") throw new y("signet network is not supported");
  if (!e || !a || !n) throw new y("Invalid options provided");
  let t, i = null;
  const r = { payload: { network: { type: ge[a] }, message: e, address: n }, getProvider: s, onFinish: (o) => {
    if (!o) throw new D("Failed to sign message using selected wallet");
    t = H.from(o, "base64").toString("hex"), i = o;
  }, onCancel: () => {
    throw new X();
  } };
  return await nt(r), { hex: t, base64: i };
}
async function oe() {
  const { get: s } = He(), e = s().find((n) => {
    var a, t;
    return n.name === "Magic Eden" && ((t = (a = n.features["sats-connect:"]) == null ? void 0 : a.provider) == null ? void 0 : t.isMagicEden) === !0;
  });
  if (!e) throw new M("Magic Eden Wallet not installed.");
  return e.features["sats-connect:"].provider;
}
async function xe() {
  if (typeof window > "u") throw new y("Cannot call this function outside a browser");
  try {
    const s = await oe();
    return s.isMagicEden !== void 0 && s.isMagicEden === !0;
  } catch (s) {
    if (s instanceof M) return !1;
    throw s;
  }
}
I.initEccLib(he);
const bt = { mainnet: "livenet", testnet: "testnet" };
function ye() {
  if (typeof window > "u") throw new y("Cannot call this function outside a browser");
  return window.unisat !== void 0;
}
function le() {
  var s;
  if (typeof window > "u") throw new y("Cannot call this function outside a browser");
  return ((s = window.XverseProviders) == null ? void 0 : s.BitcoinProvider) !== void 0;
}
async function be() {
  if (!le()) throw new M("Selected wallet not installed");
  return window.XverseProviders.BitcoinProvider;
}
const Ct = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20200%20200'%3e%3cradialGradient%20id='a12'%20cx='.66'%20fx='.66'%20cy='.3125'%20fy='.3125'%20gradientTransform='scale(1.5)'%3e%3cstop%20offset='0'%20stop-color='%23D9D5D2'%3e%3c/stop%3e%3cstop%20offset='.3'%20stop-color='%23D9D5D2'%20stop-opacity='.9'%3e%3c/stop%3e%3cstop%20offset='.6'%20stop-color='%23D9D5D2'%20stop-opacity='.6'%3e%3c/stop%3e%3cstop%20offset='.8'%20stop-color='%23D9D5D2'%20stop-opacity='.3'%3e%3c/stop%3e%3cstop%20offset='1'%20stop-color='%23D9D5D2'%20stop-opacity='0'%3e%3c/stop%3e%3c/radialGradient%3e%3ccircle%20transform-origin='center'%20fill='none'%20stroke='url(%23a12)'%20stroke-width='15'%20stroke-linecap='round'%20stroke-dasharray='200%201000'%20stroke-dashoffset='0'%20cx='100'%20cy='100'%20r='70'%3e%3canimateTransform%20type='rotate'%20attributeName='transform'%20calcMode='spline'%20dur='2'%20values='360;0'%20keyTimes='0;1'%20keySplines='0%200%201%201'%20repeatCount='indefinite'%3e%3c/animateTransform%3e%3c/circle%3e%3ccircle%20transform-origin='center'%20fill='none'%20opacity='.2'%20stroke='%23D9D5D2'%20stroke-width='15'%20stroke-linecap='round'%20cx='100'%20cy='100'%20r='70'%3e%3c/circle%3e%3c/svg%3e", vt = { [C.MAGICEDEN]: "Magic Eden", [C.UNISAT]: "UniSat", [C.XVERSE]: "Xverse", [C.LEATHER]: "Leather", [C.OKX]: "OKX" };
function $({ wallet: s, subtitle: e, onConnect: n, icon: a, setErrorMessage: t, isDisabled: i, isMobileDevice: r }) {
  const { wallet: o, address: d } = L(), [{ connectedWallet: w, connectedAddress: p }] = j({ connectedWallet: o, connectedAddress: d }), [c, u] = j(!1), l = vt[s], f = O(async () => {
    u(!0), await Promise.race([n().then(() => u(!1)).catch(() => u(!1)), new Promise((g) => {
      setTimeout(() => g("timeout"), 5e3);
    })]) === "timeout" ? t("No wallet pop-up? The extension is not responding. Try reloading your browser.") : u(!1);
  }, [n, t]);
  return h.jsxs("button", { type: "button", className: "wallie-w-full wallie-flex wallie-flex-row wallie-justify-between wallie-items-center wallie-text-ord-light-gray wallie-bg-ord-light-blue wallie-hover:bg-ord-light-blue-250 wallie-p-2 wallie-rounded-lg md:wallie-text-xl wallie-space-x-4 md:space-x-6 wallie-ease-in wallie-transition-all wallie-duration-100 wallie-ease-in-outscale-120", onClick: f, disabled: i, children: [h.jsxs("div", { className: "wallie-flex wallie-flex-row wallie-space-x-2", children: [h.jsx("img", { className: "wallie-w-5 md:wallie-w-8", src: a, alt: "" }), h.jsx("span", { className: "wallie-text-lg wallie-block wallie-font-medium", children: l }), h.jsx("span", { className: "wallie-text-sm wallie-font-medium", style: { display: r ? "block" : "none" }, children: e })] }), w === s && p.ordinals ? h.jsx("div", { className: "wallie-flex wallie-flex-row wallie-ml-auto", children: h.jsx("span", { className: "wallie-text-sm wallie-font-medium wallie-pr-3", children: pe(p.ordinals) }) }) : null, c && h.jsx("img", { src: Ct, width: 24, alt: `${l} extension is loading` })] });
}
const Tt = { [C.OKX]: "https://www.okx.com/web3", [C.XVERSE]: "https://www.xverse.app/download", [C.LEATHER]: "https://leather.io/install-extension", [C.MAGICEDEN]: "https://wallet.magiceden.io/", [C.UNISAT]: "https://unisat.io/download" };
function kt({ isOpen: s, closeModal: e }) {
  const { updateAddress: n, network: a, updateWallet: t, updatePublicKey: i, updateFormat: r, wallet: o, format: d, address: w, publicKey: p, disconnectWallet: c } = L(), [u, l] = j(""), f = typeof window < "u" && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent), g = O((m, x) => {
    x instanceof M && window.open(Tt[m], "_blank", "noopener,noreferrer"), l(x.message ?? x.toString()), c();
  }, [c]), E = O(async () => {
    if (a === "testnet") {
      const m = new Error("Magic Eden wallet is not supported on testnet");
      return g(C.MAGICEDEN, m), !1;
    }
    try {
      l("");
      const m = await async function(T = "mainnet") {
        if (!xe()) throw new M("Magic Eden Wallet not installed.");
        if (T !== "mainnet") throw new ae("Magic Eden Wallet only supports mainnet");
        return Oe(oe, T);
      }(a);
      if (!m || m.length < 1) throw c(), new Error("Magic Eden via Ordit returned no addresses.");
      const x = m.find((T) => T.format === "segwit" || T.format === "p2sh-p2wpkh");
      if (!x) throw new Error("Magic Eden via Ordit did not return a P2SH or Segwit address.");
      const b = m.find((T) => T.format === "taproot");
      if (!b) throw new Error("Magic Eden via Ordit did not return a Taproot address.");
      return n({ ordinals: b.address, payments: x.address }), i({ ordinals: b.publicKey, payments: x.publicKey }), t(C.MAGICEDEN), r({ ordinals: b.format, payments: x.format }), e(), !0;
    } catch (m) {
      return g(C.MAGICEDEN, m), !1;
    }
  }, [e, c, a, g, n, r, i, t]), v = O(async ({ readOnly: m } = {}) => {
    try {
      l("");
      const x = await async function(T = "mainnet", U) {
        if (T === "signet") throw new y("signet network is not supported");
        if (!ye()) throw new M("Unisat not installed");
        try {
          const A = await window.unisat.getNetwork(), P = bt[T];
          A !== P && await window.unisat.switchNetwork(P);
          const ce = U ? await window.unisat.getAccounts() : await window.unisat.requestAccounts(), Ze = await window.unisat.getPublicKey(), de = ce[0];
          return de ? [{ publicKey: Ze, address: de, format: _e(de, T) }] : [];
        } catch (A) {
          if (A instanceof y) throw A;
          const P = A;
          throw (P == null ? void 0 : P.code) === 4001 ? new X() : new y(P.message);
        }
      }(a, m);
      if (!x || x.length < 1) throw c(), new Error("Unisat via Ordit returned no addresses.");
      const b = x[0];
      return n({ ordinals: b.address, payments: b.address }), i({ ordinals: b.publicKey, payments: b.publicKey }), t(C.UNISAT), r({ ordinals: b.format, payments: b.format }), e(), !0;
    } catch (x) {
      return g(C.UNISAT, x), !1;
    }
  }, [e, c, a, g, n, r, i, t]), k = O(async () => {
    try {
      l("");
      const m = await async function(T = "mainnet") {
        if (!le()) throw new M("Selected wallet not installed");
        return Oe(be, T);
      }(a);
      if (!m || m.length < 1) throw c(), new Error("Xverse via Ordit returned no addresses.");
      const x = m.find((T) => T.format === "p2sh-p2wpkh" || T.format === "segwit");
      if (!x) throw new Error("Xverse via Ordit did not return a P2SH or Segwit address.");
      const b = m.find((T) => T.format === "taproot");
      if (!b) throw new Error("Xverse via Ordit did not return a Taproot address.");
      return n({ ordinals: b.address, payments: x.address }), i({ ordinals: b.publicKey, payments: x.publicKey }), t(C.XVERSE), r({ ordinals: b.format, payments: x.format }), e(), !0;
    } catch (m) {
      return g(C.XVERSE, m), !1;
    }
  }, [e, c, a, g, n, r, i, t]), N = O(async () => {
    try {
      l("");
      const m = await async function(T = "mainnet") {
        if (!me()) throw new M("Leather not installed");
        const U = (await fe("getAddresses", { network: T })).addresses.filter((P) => P.type === _.P2TR || P.type === _.P2WPKH), A = function(P) {
          try {
            const { network: ce } = we(P);
            return ce;
          } catch {
            throw new y("Invalid address");
          }
        }(U[0].address);
        if (T !== "signet" && A !== T || T === "signet" && A !== "testnet") throw new ae("Leather network mismatch, please switch it manually");
        return U.map((P) => ({ publicKey: P.publicKey, address: P.address, format: K[P.type] }));
      }(a);
      if (!m || m.length < 1) throw c(), new Error("Leather via Ordit returned no addresses.");
      const x = m.find((T) => T.format === "segwit");
      if (!x) throw new Error("Leather via Ordit did not return a Segwit address.");
      const b = m.find((T) => T.format === "taproot");
      if (!b) throw new Error("Leather via Ordit did not return a Taproot address.");
      return n({ ordinals: b.address, payments: x.address }), i({ ordinals: b.publicKey, payments: x.publicKey }), t(C.LEATHER), r({ ordinals: b.format, payments: x.format }), e(), !0;
    } catch (m) {
      return g(C.LEATHER, m), !1;
    }
  }, [e, c, a, g, n, r, i, t]);
  return re(() => {
    if (o !== C.UNISAT) return;
    let m = !0, x = !1;
    const b = () => v();
    return w && p && d && (async () => {
      const T = await async function() {
        let U = 0;
        for (; U < 20; ) {
          if (typeof window < "u" && window.unisat) try {
            const A = await window.unisat.getAccounts();
            if (A && A.length > 0) return !0;
          } catch {
            break;
          }
          U += 1, await new Promise((A) => {
            setTimeout(A, 100);
          });
        }
        return !1;
      }();
      m && (T ? (x = await v({ readOnly: !0 }), m && x && window.unisat.addListener("accountsChanged", b)) : c());
    })(), () => {
      m = !1, x && window.unisat.removeListener("accountsChanged", b);
    };
  }, [o, v, c, w, p, d]), h.jsx(ee, { appear: !0, show: s, as: te, children: h.jsxs(ue, { as: "div", className: "wallie-z-50 wallie-fixed wallie-inset-0 wallie-overflow-y-auto", onClose: e, children: [h.jsx(ee.Child, { as: te, enter: "wallie-ease-out wallie-duration-300", enterFrom: "wallie-opacity-0", enterTo: "wallie-opacity-100", leave: "wallie-ease-in wallie-duration-200", leaveFrom: "wallie-opacity-100", leaveTo: "wallie-opacity-0", children: h.jsx("div", { className: "wallie-fixed wallie-inset-0 wallie-bg-black wallie-bg-opacity-90 md:wallie-bg-opacity-75 wallie-transition-opacity" }) }), h.jsx("section", { className: "wallie-fixed wallie-inset-0 wallie-z-10 wallie-overflow-y-auto", children: h.jsx("div", { className: "wallie-flex wallie-min-h-full wallie-w-full md:wallie-w-96 wallie-mx-auto wallie-items-end wallie-justify-center wallie-p-4 wallie-text-left sm:wallie-items-center sm:wallie-p-0", children: h.jsx(ee.Child, { as: te, enter: "wallie-ease-out wallie-duration-300", enterFrom: "wallie-opacity-0 wallie-scale-95", enterTo: "wallie-opacity-100 wallie-scale-100", leave: "wallie-ease-in wallie-duration-200", leaveFrom: "wallie-opacity-100 wallie-scale-100", leaveTo: "wallie-opacity-0 wallie-scale-95", children: h.jsxs(ue.Panel, { className: "wallie-relative wallie-bg-ord-blue-600 wallie-transform wallie-overflow-hidden wallie-rounded-lg wallie-p-8 wallie-transition-all wallie-w-full", children: [h.jsxs("section", { className: "wallie-flex wallie-flex-row", children: [h.jsx(ue.Title, { as: "h3", className: "wallie-text-[21px] wallie-font-medium wallie-leading-8 wallie--mt-1  wallie-text-ord-gray", children: "Connect a wallet to continue" }), h.jsx("button", { type: "button", onClick: e, className: "wallie-ml-auto", children: h.jsx("img", { src: ft, alt: "close modal", className: "wallie-w-[19px] wallie-h-[19px]" }) })] }), h.jsx("p", { className: "wallie-text-ord-light-blue-400 wallie-font-medium wallie-py-3", children: "Choose a wallet below to connect and continue" }), u && h.jsx("p", { className: "wallie-text-ord-alert wallie-pb-4", children: u }), h.jsx("section", { className: "wallie-w-full", children: h.jsxs("section", { className: "wallie-w-full wallie-space-y-4", children: [h.jsx($, { wallet: C.LEATHER, subtitle: "Coming soon on mobile browsing", onConnect: N, icon: Xe, setErrorMessage: l, isDisabled: f, isMobileDevice: f }), h.jsx($, { wallet: C.XVERSE, subtitle: "", onConnect: k, icon: De, setErrorMessage: l, isMobileDevice: f }), !f && h.jsx($, { wallet: C.UNISAT, subtitle: "Coming soon on mobile browsing", onConnect: v, icon: ze, setErrorMessage: l, isDisabled: f, isMobileDevice: f }), h.jsx($, { wallet: C.MAGICEDEN, subtitle: "", onConnect: E, icon: Fe, setErrorMessage: l, isMobileDevice: f })] }) })] }) }) }) })] }) });
}
function Ht({ connectButton: s, connectButtonComponent: e, hideConnectButton: n, onViewProfile: a, onChangeWalletClick: t, onDisconnectWalletClick: i }) {
  const { address: r, disconnectWallet: o, network: d, isModalOpen: w, openModal: p, closeModal: c } = L(), u = function() {
    const [l, f] = j(!1);
    return re(() => {
      f(!0);
    }, []), l;
  }();
  return h.jsxs(h.Fragment, { children: [n ? null : r != null && r.ordinals ? h.jsx(wt, { address: r.ordinals, network: d, onViewProfile: a, onChangeWallet: () => {
    p(), t == null || t();
  }, onDisconnectWallet: () => {
    o(), i == null || i();
  } }) : h.jsx(ht, { disabled: !u, connectButton: s, connectButtonComponent: e, openModal: p }), u ? h.jsx(kt, { isOpen: w, closeModal: c }) : null] });
}
class Et {
  constructor({ network: e }) {
    S(this, "network");
    this.network = e;
  }
}
class J {
  static parseInscription(e, { decodeMetadata: n }) {
    return { ...e, meta: n && e.meta ? yt(e.meta) : e.meta };
  }
  static parseInscriptions(e, { decodeMetadata: n }) {
    return e.map((a) => this.parseInscription(a, { decodeMetadata: n }));
  }
  static segregateUTXOsBySpendStatus({ utxos: e }) {
    const { spendableUTXOs: n, unspendableUTXOs: a } = e.reduce((t, i) => (i.safeToSpend ? t.spendableUTXOs.push(i) : t.unspendableUTXOs.push(i), t), { spendableUTXOs: [], unspendableUTXOs: [] });
    return { totalUTXOs: e.length, spendableUTXOs: n, unspendableUTXOs: a };
  }
}
const St = { batter: "https://mainnet.ordit.io/" }, It = { batter: "https://regtest.ordit.io/" }, Nt = { batter: "https://testnet.ordit.io/" }, Mt = { batter: "https://signet.ordit.io/" };
function Y(s) {
  return s[s.length - 1] === "/" ? s.substring(0, s.length - 1) : s;
}
class Q {
  constructor(e) {
    this.url = e;
  }
  async notify(e, n) {
    await Te(`${this.url}/rpc`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ jsonrpc: "2.0", method: e, params: n }) });
  }
  async call(e, n, a) {
    let t = {}, i = a;
    var r;
    /* @__PURE__ */ (function(d) {
      return typeof d == "string";
    })(r = n) || function(d) {
      return function(w) {
        return typeof w == "number" && w > Number.NEGATIVE_INFINITY && w < Number.POSITIVE_INFINITY;
      }(d) && d % 1 == 0;
    }(r) || r === null ? i = n : t = n;
    const o = await Te(`${this.url}/rpc`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ jsonrpc: "2.0", method: e, params: t, id: i }) });
    if (o.status === 200) {
      const d = await o.json();
      if (d.error) {
        const w = typeof d.error.data == "string" ? d.error.data : d.error.message;
        throw new y(w);
      }
      return d.result;
    }
    throw new y("Internal Server Error");
  }
}
const B = { get id() {
  return Math.floor(1e5 * Math.random());
}, mainnet: new Q(Y(St.batter)), testnet: new Q(Y(Nt.batter)), signet: new Q(Y(Mt.batter)), regtest: new Q(Y(It.batter)) };
class G extends Et {
  constructor({ network: e }) {
    super({ network: e });
  }
  async getBalance({ address: e }) {
    if (!e) throw new y("Invalid request");
    return B[this.network].call("Address.GetBalance", { address: e }, B.id);
  }
  async getInscription({ id: e, decodeMetadata: n = !1 }) {
    if (!e) throw new y("Invalid request");
    const a = Ne(e), t = await B[this.network].call("Ordinals.GetInscription", { id: a }, B.id);
    return J.parseInscription(t, { decodeMetadata: n });
  }
  async getInscriptionUTXO({ id: e }) {
    if (!e) throw new y("Invalid request");
    const n = Ne(e);
    return B[this.network].call("Ordinals.GetInscriptionUtxo", { id: n }, B.id);
  }
  async getInscriptions({ creator: e, owner: n, mimeType: a, mimeSubType: t, outpoint: i, decodeMetadata: r = !1, sort: o = "asc", limit: d = 25, next: w = null }) {
    let p = [], c = w;
    do {
      const { inscriptions: u, pagination: l } = await B[this.network].call("Ordinals.GetInscriptions", { filter: { creator: e, owner: n, mimeType: a, mimeSubType: t, outpoint: i }, sort: { number: o }, pagination: { limit: d, next: c } }, B.id);
      p = p.concat(u), c = l.next;
    } while (c !== null);
    return J.parseInscriptions(p, { decodeMetadata: r });
  }
  async getSpendables({ address: e, value: n, rarity: a = ["common"], filter: t = [], limit: i = 200, type: r = "spendable" }) {
    if (!e || Number.isNaN(n) || !n) throw new y("Invalid request");
    return B[this.network].call("Address.GetSpendables", { address: e, value: n, safetospend: r === "spendable", allowedrarity: a, filter: t, limit: i }, B.id);
  }
  async getTransaction({ txId: e, ordinals: n = !0, hex: a = !1, witness: t = !0, decodeMetadata: i = !0 }) {
    if (!e) throw new y("Invalid request");
    const r = await B[this.network].call("Transactions.GetTransaction", { txid: e, options: { ord: n, hex: a, witness: t } }, B.id);
    return r.vout = r.vout.map((o) => ({ ...o, inscriptions: J.parseInscriptions(o.inscriptions, { decodeMetadata: i }) })), { tx: r, rawTx: a && r.hex ? I.Transaction.fromHex(r.hex) : void 0 };
  }
  async getUnspents({ address: e, type: n = "spendable", rarity: a = ["common"], sort: t = "desc", limit: i = 50, next: r = null }) {
    if (!e) throw new y("Invalid request");
    let o = [], d = r;
    do {
      const { unspents: w, pagination: p } = await B[this.network].call("Address.GetUnspents", { address: e, options: { allowedrarity: a, safetospend: n === "spendable" }, pagination: { limit: i, next: d }, sort: { value: t } }, B.id);
      o = o.concat(w), d = p.next;
    } while (d !== null);
    return J.segregateUTXOsBySpendStatus({ utxos: o });
  }
  async relay({ hex: e, maxFeeRate: n, validate: a = !0 }) {
    if (!e) throw new y("Invalid request");
    if (n && (n < 0 || Number.isNaN(n))) throw new y("Invalid max fee rate");
    return B[this.network].call("Transactions.Relay", { hex: e, maxFeeRate: n, validate: a }, B.id);
  }
}
function Ut() {
  const { network: s, publicKey: e, format: n } = L(), [a, t] = j(null), [i, r] = j(!1);
  return { getBalance: O(async () => {
    r(!0);
    try {
      if (t(null), !(n && n.payments && e && e.payments)) throw new Error("No wallet is connected");
      const { address: o } = function(c, u = "mainnet", l = "all") {
        const f = H.isBuffer(c) ? c : H.from(c, "hex"), { publicKey: g } = Re.fromPublicKey(f, We, z(u));
        return l === "all" ? Object.keys(K).filter((E) => E !== "p2wsh").map((E) => je(g, u, E)) : [je(g, u, l)];
      }(e.payments, s, mt[n.payments])[0], d = new G({ network: s }), w = await d.getBalance({ address: o }), p = Number(new ke(w).multipliedBy(1e8).toFixed(0, ke.ROUND_HALF_DOWN));
      return r(!1), p;
    } catch (o) {
      throw t(o.message), r(!1), o;
    }
  }, [n, s, e]), error: a, loading: i };
}
function Ce() {
  if (typeof window > "u") throw new y("Cannot call this function outside a browser");
  return window.okxwallet !== void 0;
}
function Ge(s = "mainnet") {
  if (!Ce()) throw new M("OKX Wallet not installed");
  let e;
  switch (s) {
    case "mainnet":
      e = window.okxwallet.bitcoin;
      break;
    case "testnet":
      e = window.okxwallet.bitcoinTestnet;
      break;
    case "signet":
      e = window.okxwallet.bitcoinSignet;
      break;
    default:
      throw new y("Invalid network");
  }
  if (!e) throw new y("Failed to get OKX Wallet provider");
  return e;
}
async function ve({ address: s, wallet: e, network: n, psbt: a, options: t }) {
  var d, w;
  if ((d = t == null ? void 0 : t.signingIndexes) != null && d.length && ((w = t == null ? void 0 : t.inputsToSign) != null && w.length)) throw new Error("Cannot have both indexes and inputs to sign together");
  const i = (t == null ? void 0 : t.finalize) ?? !0, r = (t == null ? void 0 : t.extractTx) ?? !0, o = () => a.data.inputs.map((p, c) => c);
  if (e === C.MAGICEDEN)
    return await async function(c, { finalize: u = !0, extractTx: l = !0, network: f, inputsToSign: g } = { network: "mainnet", inputsToSign: [] }) {
      if (!xe()) throw new M("Magic Eden Wallet not installed.");
      if (f !== "mainnet") throw new ae("Magic Eden Wallet only supports mainnet");
      return Ae(oe, c, { finalize: u, extractTx: l, network: f, inputsToSign: g });
    }(a, { network: n, inputsToSign: (t == null ? void 0 : t.inputsToSign) ?? [{ address: s, signingIndexes: (t == null ? void 0 : t.signingIndexes) ?? o(), sigHash: t == null ? void 0 : t.sigHash }], finalize: i, extractTx: r });
  if (e === C.UNISAT)
    return await async function(c, { finalize: u = !0, extractTx: l = !0 } = {}) {
      if (!ye()) throw new M("Unisat not installed");
      if (l && !u) throw new F();
      const f = c.toHex();
      let g = "";
      try {
        g = await window.unisat.signPsbt(f, { autoFinalized: u });
      } catch (v) {
        const k = v;
        if ((k == null ? void 0 : k.code) === 4001) throw new X();
      }
      if (!g) throw new D("Failed to sign psbt hex using Unisat");
      const E = I.Psbt.fromHex(g);
      if (!l) return { base64: E.toBase64(), hex: E.toHex() };
      try {
        return { base64: null, hex: E.extractTransaction().toHex() };
      } catch (v) {
        throw v instanceof Error && v.message === "Not finalized" ? new F() : new y("Failed to extract transaction from PSBT");
      }
    }(a, { finalize: i, extractTx: r });
  if (e === C.XVERSE)
    return await async function(c, { finalize: u = !0, extractTx: l = !0, network: f, inputsToSign: g } = { network: "mainnet", inputsToSign: [] }) {
      if (!le()) throw new M("Selected wallet not installed");
      return Ae(be, c, { finalize: u, extractTx: l, network: f, inputsToSign: g });
    }(a, { network: n, inputsToSign: (t == null ? void 0 : t.inputsToSign) ?? [{ address: s, signingIndexes: (t == null ? void 0 : t.signingIndexes) ?? o(), sigHash: t == null ? void 0 : t.sigHash }], finalize: i, extractTx: r });
  if (e === C.LEATHER)
    return await async function(c, { finalize: u = !0, extractTx: l = !0, allowedSighash: f, accountNumber: g, network: E = "mainnet", signAtIndexes: v = [] } = {}) {
      if (!me()) throw new M("Leather not installed");
      if (l && !u) throw new F();
      const k = c.toHex(), N = await fe("signPsbt", { hex: k, allowedSighash: f, account: g, network: E, signAtIndex: v, broadcast: !1 }), m = I.Psbt.fromHex(N.hex);
      if (u && v.forEach((x) => {
        try {
          m.finalizeInput(x);
        } catch {
          throw new y("Failed to finalize input");
        }
      }), l) try {
        return { base64: null, hex: m.extractTransaction().toHex() };
      } catch (x) {
        throw x instanceof Error && x.message === "Not finalized" ? new F() : new y("Failed to extract transaction from PSBT");
      }
      return { base64: m.toBase64(), hex: m.toHex() };
    }(a, { network: n, finalize: i, extractTx: r, allowedSighash: t != null && t.sigHash ? [t == null ? void 0 : t.sigHash] : [], signAtIndexes: (t == null ? void 0 : t.signingIndexes) ?? o() });
  if (e === C.OKX)
    return await async function(c, { finalize: u = !0, extractTx: l = !0, network: f, inputsToSign: g } = { network: "mainnet", inputsToSign: [] }) {
      if (!Ce()) throw new M("OKX Wallet not installed");
      if (l && !u) throw new F();
      const E = Ge(f), v = c.toHex();
      let k = "";
      const N = [];
      g.forEach((x) => {
        const { address: b, signingIndexes: T, sigHash: U } = x;
        T.forEach((A) => {
          N.push({ index: A, address: b, sighashTypes: U ? [U] : void 0 });
        });
      });
      try {
        k = await E.signPsbt(v, { autoFinalized: u, toSignInputs: N });
      } catch (x) {
        const b = x;
        throw b.code === 4001 ? new X() : new y(b.message);
      }
      if (!k) throw new D("Failed to sign psbt hex using OKX Wallet");
      const m = I.Psbt.fromHex(k);
      if (!l) return { base64: m.toBase64(), hex: m.toHex() };
      try {
        return { base64: null, hex: m.extractTransaction().toHex() };
      } catch (x) {
        throw x instanceof Error && x.message === "Not finalized" ? new F() : new y("Failed to extract transaction from PSBT");
      }
    }(a, { finalize: i, extractTx: r, network: n, inputsToSign: (t == null ? void 0 : t.inputsToSign) ?? [{ address: s, signingIndexes: (t == null ? void 0 : t.signingIndexes) ?? o(), sigHash: t == null ? void 0 : t.sigHash }] });
  throw new Error("Invalid wallet selected");
}
function Be(s) {
  switch (s) {
    case "taproot":
      return { input: 42, output: 43, witness: 66 };
    case "segwit":
      return { input: 41, output: 31, witness: 105 };
    case "p2sh-p2wpkh":
      return { input: 64, output: 32, witness: 105 };
    case "legacy":
      return { input: 148, output: 34, witness: 0 };
    default:
      throw new y("Invalid type");
  }
}
class jt {
  constructor({ feeRate: e, network: n, psbt: a, witness: t }) {
    S(this, "fee", 0);
    S(this, "feeRate");
    S(this, "network");
    S(this, "psbt");
    S(this, "witness", []);
    S(this, "virtualSize", 0);
    S(this, "weight", 0);
    if (e < 0 || !Number.isSafeInteger(e)) throw new y("Invalid feeRate");
    this.feeRate = e, this.network = n, this.witness = t || [], this.psbt = a || new I.Psbt({ network: z(this.network) });
  }
  get data() {
    return { fee: this.fee, virtualSize: this.virtualSize, weight: this.weight };
  }
  calculateNetworkFee() {
    if (this.fee = this.calculateVirtualSize() * this.feeRate, this.fee > 5e6) throw new y("Error while calculating fees");
    return this.fee;
  }
  getInputAndOutputScriptTypes() {
    const { inputs: e } = this.psbt.data, n = this.psbt.txOutputs;
    if (e.length === 0) throw new y("PSBT must have at least one input");
    if (n.length === 0) throw new y("PSBT must have at least one output");
    return { inputTypes: e.map((a) => {
      const t = a.witnessUtxo && a.witnessUtxo.script ? a.witnessUtxo.script : null;
      if (!t) throw new y("Invalid script");
      return Me(t, this.network).format;
    }), outputTypes: n.map((a) => Me(a.script, this.network).format) };
  }
  calculateScriptWitnessSize() {
    var n;
    const { inputTypes: e } = this.getInputAndOutputScriptTypes();
    return e.includes("taproot") && ((n = this.witness) != null && n.length) ? this.witness.reduce((a, t) => a + t.byteLength, 0) : 0;
  }
  getBaseSize() {
    var o, d;
    const { inputTypes: e, outputTypes: n } = this.getInputAndOutputScriptTypes(), a = e.reduce((w, p) => {
      const { input: c, witness: u } = Be(p);
      return w.input += c, w.witness += u, w;
    }, { input: 0, witness: 0 }), t = n.reduce((w, p) => {
      const { output: c } = Be(p);
      return w + c;
    }, 0), i = a.witness + ((o = this.witness) != null && o.length ? this.calculateScriptWitnessSize() : 0);
    let r = 0;
    return (d = this.witness) != null && d.length ? r = i : i > 0 && (r = 2 + i), { baseSize: a.input + 10.5 + t, witnessSize: r };
  }
  calculateVirtualSize() {
    const { baseSize: e, witnessSize: n } = this.getBaseSize();
    return this.weight = 3 * e + (e + n), this.virtualSize = Math.ceil(this.weight / 4), this.virtualSize;
  }
}
class qe extends jt {
  constructor({ address: n, changeAddress: a, datasource: t, feeRate: i, network: r = "mainnet", publicKey: o, outputs: d, autoAdjustment: w = !0, instantTradeMode: p = !1 }) {
    super({ feeRate: i, network: r });
    S(this, "address");
    S(this, "changeAddress");
    S(this, "changeAmount", 0);
    S(this, "datasource");
    S(this, "injectableInputs", []);
    S(this, "injectableOutputs", []);
    S(this, "inputAmount", 0);
    S(this, "inputs", []);
    S(this, "outputAmount", 0);
    S(this, "outputs", []);
    S(this, "psbt");
    S(this, "publicKey");
    S(this, "rbf", !0);
    S(this, "utxos", []);
    S(this, "usedUTXOs", []);
    S(this, "autoAdjustment");
    S(this, "instantTradeMode");
    S(this, "noMoreUTXOS", !1);
    this.address = n, this.changeAddress = a, this.datasource = t || new G({ network: this.network }), this.outputs = d, this.publicKey = o, this.autoAdjustment = w, this.instantTradeMode = p, this.psbt = new I.Psbt({ network: z(r) });
  }
  get data() {
    return { fee: this.fee, virtualSize: this.virtualSize, weight: this.weight, changeAmount: this.changeAmount, inputAmount: this.inputAmount, outputAmount: this.outputAmount };
  }
  toPSBT() {
    return this.psbt;
  }
  toHex() {
    return this.psbt.toHex();
  }
  toBase64() {
    return this.psbt.toBase64();
  }
  setRBF(n) {
    this.rbf = n, this.addInputs();
  }
  get xKey() {
    return Ie(H.from(this.publicKey, "hex")).toString("hex");
  }
  get inputsToSign() {
    const n = this.instantTradeMode && !this.autoAdjustment;
    return this.psbt.txInputs.reduce((a, t, i) => ((!this.instantTradeMode || this.instantTradeMode && i !== 2) && (a.signingIndexes = a.signingIndexes.concat(i)), n && (a.sigHash = I.Transaction.SIGHASH_SINGLE | I.Transaction.SIGHASH_ANYONECANPAY), a), { address: this.address, signingIndexes: [] });
  }
  initPSBT() {
    this.psbt = new I.Psbt({ network: z(this.network) }), this.psbt.setMaximumFeeRate(this.feeRate);
  }
  getInputSequence() {
    return this.rbf ? 4294967293 : 4294967295;
  }
  injectInput(n) {
    this.psbt.data.globalMap.unsignedTx.tx.ins[n.injectionIndex] = n.txInput, this.psbt.data.inputs[n.injectionIndex] = n.standardInput;
  }
  injectOutput(n) {
    let a = n.injectionIndex;
    do {
      if (!this.psbt.data.globalMap.unsignedTx.tx.outs[a]) {
        this.psbt.data.globalMap.unsignedTx.tx.outs[a] = n.txOutput, this.psbt.data.outputs[a] = n.standardOutput;
        break;
      }
      a += 1;
    } while (a);
  }
  addInputs() {
    const n = this.injectableInputs.map((t) => t.injectionIndex), a = [];
    this.inputs.forEach((t, i) => {
      const r = n.includes(i);
      if (r) {
        const o = this.injectableInputs.find((d) => d.injectionIndex === i);
        this.injectInput(o), a.push(o.injectionIndex);
      }
      this.psbt.txInputs.map((o) => V(st(o.hash).toString("hex"), o.index)).includes(V(t.hash, t.index)) || (this.psbt.addInput(t), this.psbt.setInputSequence(r ? i + 1 : i, this.getInputSequence()));
    }), this.injectableInputs.forEach((t) => {
      a.includes(t.injectionIndex) || (this.injectInput(t), a.push(t.injectionIndex));
    });
  }
  addOutputs() {
    const n = this.injectableOutputs.map((t) => t.injectionIndex), a = [];
    this.outputs.forEach((t, i) => {
      if (n.includes(i)) {
        const r = this.injectableOutputs.find((o) => o.injectionIndex === i);
        this.injectOutput(r), a.push(r.injectionIndex);
      }
      this.psbt.addOutput({ address: t.address, value: t.value });
    }), this.injectableOutputs.forEach((t) => {
      a.includes(t.injectionIndex) || (this.injectOutput(t), a.push(t.injectionIndex));
    }), this.changeAmount >= 600 && this.psbt.addOutput({ address: this.changeAddress || this.address, value: this.changeAmount });
  }
  calculateOutputAmount() {
    if (this.outputAmount = Math.floor(this.outputs.reduce((n, a) => n + a.value, 0) + this.injectableOutputs.reduce((n, a) => n + a.sats, 0)), this.outputAmount < 600) throw new Error("Output amount too low. Minimum output amount needs to be 600 sats");
  }
  async recursivelyCalculateChangeAmount() {
    if (this.autoAdjustment && (this.changeAmount = Math.floor(this.inputAmount - this.outputAmount - this.fee), this.changeAmount < 0 && (await this.prepare(), this.noMoreUTXOS))) throw new Error(`Insufficient balance. Decrease the output amount by ${-1 * this.changeAmount} sats`);
  }
  getRetrievedUTXOsValue() {
    return this.utxos.reduce((n, a) => n + a.sats, 0);
  }
  getReservedUTXOs() {
    return this.utxos.map((n) => V(n.txid, n.n));
  }
  getUTXOAmountToRequestFromChangeAmount() {
    return this.changeAmount < 0 ? Math.abs(this.changeAmount) : this.outputAmount - this.getRetrievedUTXOsValue();
  }
  async retrieveUTXOs(n, a) {
    if (!this.autoAdjustment && !n) return;
    const t = a && a > 0 ? a : this.getUTXOAmountToRequestFromChangeAmount();
    if (a && this.getRetrievedUTXOsValue() >= a || t <= 0) return;
    const i = await this.datasource.getSpendables({ address: n || this.address, value: (r = t, r / 10 ** 8), filter: this.getReservedUTXOs() });
    var r;
    this.noMoreUTXOS = i.length === 0, this.utxos.push(...i);
  }
  async retrieveSelectedUTXOs(n, a) {
    await this.retrieveUTXOs(n, a);
    const t = this.utxos.find((i) => i.sats >= a);
    return this.utxos = t ? [t] : [], this.utxos;
  }
  async prepareInputs() {
    if (!this.autoAdjustment) return;
    const n = [];
    this.utxos.forEach((t) => {
      if (this.usedUTXOs.includes(V(t.txid, t.n))) return;
      this.inputAmount += t.sats;
      const i = async function({ utxo: r, pubKey: o, network: d, sighashType: w, witness: p, datasource: c }) {
        const u = c || new G({ network: d });
        switch (r.scriptPubKey.type) {
          case "witness_v1_taproot":
            return function({ utxo: l, pubKey: f, network: g, sighashType: E, witness: v }) {
              const k = Ie(Re.fromPublicKey(H.from(f, "hex"), We, z(g)).publicKey);
              if (!l.scriptPubKey.hex) throw new Error("Unable to process p2tr input");
              return { type: "taproot", hash: l.txid, index: l.n, tapInternalKey: k, witnessUtxo: { script: H.from(l.scriptPubKey.hex, "hex"), value: l.sats }, witness: v, ...E ? { sighashType: E } : void 0 };
            }({ utxo: r, pubKey: o, network: d, sighashType: w, witness: p });
          case "witness_v0_scripthash":
          case "witness_v0_keyhash":
            return function({ utxo: l, sighashType: f }) {
              if (!l.scriptPubKey.hex) throw new Error("Unable to process Segwit input");
              return { type: "segwit", hash: l.txid, index: l.n, witnessUtxo: { script: H.from(l.scriptPubKey.hex, "hex"), value: l.sats }, ...f ? { sighashType: f } : void 0 };
            }({ utxo: r, sighashType: w });
          case "scripthash":
            return function({ utxo: l, pubKey: f, network: g, sighashType: E }) {
              const v = ie(H.from(f, "hex"), "p2sh", g);
              if (!v || !v.output || !v.redeem) throw new Error("Unable to process P2SH input");
              return { type: "p2sh-p2wpkh", hash: l.txid, index: l.n, redeemScript: v.redeem.output, witnessUtxo: { script: H.from(l.scriptPubKey.hex, "hex"), value: l.sats }, ...E ? { sighashType: E } : void 0 };
            }({ utxo: r, pubKey: o, network: d, sighashType: w });
          case "pubkeyhash":
            return async function({ utxo: l, sighashType: f, network: g, pubKey: E, datasource: v }) {
              const { rawTx: k } = await v.getTransaction({ txId: l.txid, hex: !0 });
              if (!k) throw new Error("Unable to process legacy input");
              const N = ie(H.from(E, "hex"), "p2pkh", g);
              return { type: "legacy", hash: l.txid, index: l.n, nonWitnessUtxo: k == null ? void 0 : k.toBuffer(), witnessUtxo: { script: N.output, value: l.sats }, ...f ? { sighashType: f } : void 0 };
            }({ utxo: r, sighashType: w, network: d, pubKey: o, datasource: u });
          default:
            throw new Error("invalid script pub type");
        }
      }({ utxo: t, pubKey: this.publicKey, network: this.network, datasource: this.datasource });
      n.push(i);
    });
    const a = await Promise.all(n);
    this.inputAmount += this.injectableInputs.reduce((t, i) => t + i.sats, 0), a.forEach((t) => {
      const i = V(t.hash, t.index);
      this.usedUTXOs.includes(i) || this.usedUTXOs.push(i);
    }), this.inputs = this.inputs.concat(a);
  }
  async prepare() {
    this.calculateOutputAmount(), await this.retrieveUTXOs(), await this.prepareInputs(), await this.recursivelyCalculateChangeAmount(), this.process(), await this.recursivelyCalculateChangeAmount(), this.calculateOutputAmount(), this.process();
  }
  process() {
    return this.initPSBT(), this.addInputs(), this.addOutputs(), this.calculateNetworkFee(), this;
  }
}
function Kt() {
  const { wallet: s, network: e, address: n, publicKey: a } = L(), [t, i] = j(null), [r, o] = j(!1);
  return { send: O(async (d, w, p, c = !0) => {
    o(!0);
    try {
      if (i(null), !(n && n.payments && a && a.payments && s)) throw new Error("No wallet is connected");
      const u = new qe({ address: n.payments, feeRate: p, network: e, publicKey: a.payments, outputs: [{ address: d, value: w }] });
      await u.prepare();
      const l = await ve({ address: n.payments, wallet: s, network: e, psbt: u.toPSBT() });
      if (c) {
        const f = new G({ network: e }), g = await f.relay({ hex: l.hex });
        return o(!1), g;
      }
      return o(!1), l.hex;
    } catch (u) {
      return i(u.message), o(!1), null;
    }
  }, [n, e, a, s]), error: t, loading: r };
}
function Lt() {
  const { wallet: s, network: e, address: n, publicKey: a } = L(), [t, i] = j(null), [r, o] = j(!1);
  return { send: O(async (d, w) => {
    o(!0);
    try {
      if (i(null), !(n && n.payments && a && a.payments && s)) throw new Error("No wallet is connected");
      if (s === "magiceden" || s === "xverse") {
        const p = s === "magiceden" ? await async function() {
          const { get: u } = He(), l = u().find((f) => {
            var g, E;
            return f.name === "Magic Eden" && ((E = (g = f.features["sats-connect:"]) == null ? void 0 : g.provider) == null ? void 0 : E.isMagicEden) === !0;
          });
          if (!l) throw new Error("Magic Eden wallet not found");
          return l.features["sats-connect:"].provider;
        }() : void 0;
        let c = null;
        return c = await new Promise((u, l) => {
          at({ payload: { network: { type: e === "mainnet" ? se.Mainnet : se.Testnet }, message: "Sign Transaction", recipients: [{ address: d, amountSats: BigInt(w) }], senderAddress: n.payments }, getProvider: async () => p, onFinish: (f) => {
            u(f);
          }, onCancel: () => {
            l(new Error("Transaction canceled"));
          } });
        }), o(!1), c;
      }
      if (s === "unisat") {
        let p = "";
        return p = await window.unisat.sendBitcoin(d, w, {}), o(!1), p;
      }
      if (s === "leather") {
        let p = "";
        return p = (await async function(c, u) {
          if (typeof window > "u" || !window.LeatherProvider) throw new Error("LeatherProvider not found");
          try {
            return (await window.LeatherProvider.request("sendTransfer", u)).result;
          } catch (l) {
            const f = l, { message: g } = f.error;
            throw f.error.code === 4001 ? new Error(g) : new Error(`Leather error: ${g}`);
          }
        }(0, { recipients: [{ address: d, amount: w }], network: e })).txid, o(!1), p;
      }
      if (s === "okx") {
        let p = "";
        if (e === "mainnet") return p = await window.okxwallet.bitcoin.sendBitcoin(d, w, {}), o(!1), p;
        if (e === "testnet") return p = await window.okxwallet.bitcoinTestnet.sendBitcoin(d, w, {}), o(!1), p;
      }
      return o(!1), null;
    } catch (p) {
      return i(p.message), o(!1), null;
    }
  }, [n, e, a, s]), error: t, loading: r };
}
function Xt() {
  const { wallet: s, network: e, address: n, publicKey: a } = L(), [t, i] = j(!1);
  return { send: O(async ({ toAddress: r, satoshis: o, feeRate: d, relay: w = !0, rbf: p = !1 }) => {
    i(!0);
    try {
      if (!(n && n.payments && a && a.payments && s)) throw new Error("No wallet is connected");
      const c = new qe({ address: n.payments, feeRate: d, network: e, publicKey: a.payments, outputs: [{ address: r, value: o }] });
      c.setRBF(p), await c.prepare();
      const u = await ve({ address: n.payments, wallet: s, network: e, psbt: c.toPSBT() });
      if (w) {
        const l = new G({ network: e }), f = await l.relay({ hex: u.hex });
        return i(!1), { txId: f };
      }
      return i(!1), { signedPsbtHex: u.hex };
    } catch (c) {
      return i(!1), { error: c.message };
    }
  }, [n, e, a, s]), isLoading: t };
}
function Ft() {
  const { network: s, publicKey: e, format: n, wallet: a } = L(), [t, i] = j(null), [r, o] = j(!1);
  return { sign: O(async (d, w, p) => {
    o(!0);
    try {
      if (i(null), !n || !e || !a) throw new Error("No wallet is connected");
      const c = I.Psbt.fromBase64(w), u = await ve({ address: d, wallet: a, network: s, psbt: c, options: p });
      return o(!1), u;
    } catch (c) {
      throw i(c.message), o(!1), c;
    }
  }, [n, s, e, a]), error: t, loading: r };
}
function zt() {
  const { network: s, wallet: e, publicKey: n, format: a, address: t } = L(), [i, r] = j(null), [o, d] = j(!1);
  return { signMsg: O(async (w, p) => {
    d(!0);
    try {
      if (r(null), !a || !n || !e) throw new Error("No wallet is connected");
      if (t.ordinals !== w && t.payments !== w) throw new Error("Address supplied is not connected address");
      const c = await async function({ message: u, wallet: l, address: f, network: g, format: E }) {
        if (l === C.MAGICEDEN) {
          const { base64: v } = await async function(k, N, m = "mainnet") {
            if (!xe()) throw new M("Magic Eden Wallet not installed.");
            if (m !== "mainnet") throw new ae("Magic Eden Wallet only supports mainnet");
            return Pe(oe, k, N, m);
          }(u, f, g);
          return v;
        }
        if (l === C.UNISAT) {
          const { base64: v } = await async function(k, N = "ecdsa") {
            if (!ye()) throw new M("Unisat not installed");
            let m = "";
            try {
              m = await window.unisat.signMessage(k, N);
            } catch (x) {
              const b = x;
              if ((b == null ? void 0 : b.code) === 4001) throw new X();
            }
            if (!m) throw new D("Failed to sign message using Unisat");
            return { base64: m, hex: H.from(m, "base64").toString("hex") };
          }(u, "bip322-simple");
          return v;
        }
        if (l === C.XVERSE) {
          const { base64: v } = await async function(k, N, m = "mainnet") {
            if (!le()) throw new M("Selected wallet not installed");
            return Pe(be, k, N, m);
          }(u, f, g);
          return v;
        }
        if (l === C.LEATHER) {
          const v = function(N) {
            if (N === "segwit") return _.P2WPKH;
            if (N === "taproot") return _.P2TR;
            throw new Error("Leather payment address format is not supported");
          }(E), { base64: k } = await async function(N, { network: m = "mainnet", paymentType: x }) {
            if (!me()) throw new M("Leather not installed");
            const { signature: b } = await fe("signMessage", { message: N, paymentType: x, network: m });
            return { base64: b, hex: H.from(b, "base64").toString("hex") };
          }(u, { paymentType: v, network: g });
          return k;
        }
        if (l === C.OKX) {
          const { base64: v } = await async function(k, N = "ecdsa", m = "mainnet") {
            if (!Ce()) throw new M("OKX Wallet not installed");
            const x = Ge(m);
            let b = "";
            try {
              b = await x.signMessage(k, N);
            } catch (T) {
              const U = T;
              throw U.code === 4001 ? new X() : new y(U.message);
            }
            if (!b) throw new D("Failed to sign message using OKX Wallet");
            return { base64: b, hex: H.from(b, "base64").toString("hex") };
          }(u, "bip322-simple", g);
          return v;
        }
        throw new Error("Invalid wallet selected");
      }({ address: w, wallet: e, message: p, network: s, format: t.ordinals === w ? a.ordinals : a.payments });
      return d(!1), c;
    } catch (c) {
      throw r(c.message), d(!1), c;
    }
  }, [a, s, n, e, t]), error: i, isLoading: o };
}
export {
  ne as Network,
  Ht as OrdConnectKit,
  kt as SelectWalletModal,
  C as Wallet,
  Bt as WallieProvider,
  Ut as useBalance,
  Kt as useSend,
  Lt as useSendBtc,
  Xt as useSendV2,
  Ft as useSign,
  zt as useSignMessage,
  L as useWallie
};
