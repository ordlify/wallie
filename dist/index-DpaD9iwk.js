(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=Poppins:wght@400;500;600;700&display=swap";*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*! tailwindcss v3.4.13 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-size:1em;font-variation-settings:normal}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-feature-settings:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}.wallie-fixed{position:fixed}.wallie-relative{position:relative}.wallie-inset-0{top:0;right:0;bottom:0;left:0}.wallie-z-50{z-index:50}.wallie-z-\\[200\\]{z-index:200}.wallie-mx-auto{margin-left:auto;margin-right:auto}.wallie--mt-1{margin-top:-.25rem}.wallie-mb-0\\.5{margin-bottom:.125rem}.wallie-mb-1{margin-bottom:.25rem}.wallie-ml-auto{margin-left:auto}.wallie-block{display:block}.wallie-inline-block{display:inline-block}.wallie-flex{display:flex}.wallie-hidden{display:none}.wallie-h-\\[19px\\]{height:19px}.wallie-h-screen{height:100vh}.wallie-min-h-full{min-height:100%}.wallie-w-5{width:1.25rem}.wallie-w-6{width:1.5rem}.wallie-w-\\[19px\\]{width:19px}.wallie-w-full{width:100%}.wallie-max-w-4xl{max-width:56rem}.wallie-scale-100{--tw-scale-x:1;--tw-scale-y:1}.wallie-scale-100,.wallie-scale-95{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wallie-scale-95{--tw-scale-x:.95;--tw-scale-y:.95}.wallie-transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wallie-flex-row{flex-direction:row}.wallie-flex-col{flex-direction:column}.wallie-items-center{align-items:center}.wallie-justify-center{justify-content:center}.wallie-justify-between{justify-content:space-between}.wallie-justify-items-center{justify-items:center}.wallie-space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.wallie-space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(1rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(1rem*var(--tw-space-x-reverse))}.wallie-space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(1rem*var(--tw-space-y-reverse));margin-top:calc(1rem*(1 - var(--tw-space-y-reverse)))}.wallie-overflow-hidden{overflow:hidden}.wallie-overflow-y-auto{overflow-y:auto}.wallie-break-all{word-break:break-all}.wallie-rounded-full{border-radius:9999px}.wallie-rounded-lg{border-radius:.5rem}.wallie-bg-black\\/90{background-color:#000000e6}.wallie-bg-ord-blue-600{--tw-bg-opacity:1;background-color:rgb(23 30 45/var(--tw-bg-opacity))}.wallie-bg-ord-light-blue{--tw-bg-opacity:1;background-color:rgb(48 55 70/var(--tw-bg-opacity))}.wallie-bg-ord-light-blue-400{--tw-bg-opacity:1;background-color:rgb(73 82 102/var(--tw-bg-opacity))}.wallie-bg-ord-orange{--tw-bg-opacity:1;background-color:rgb(255 108 58/var(--tw-bg-opacity))}.wallie-p-1{padding:.25rem}.wallie-p-2{padding:.5rem}.wallie-p-4{padding:1rem}.wallie-p-8{padding:2rem}.wallie-px-1{padding-left:.25rem;padding-right:.25rem}.wallie-py-3{padding-bottom:.75rem;padding-top:.75rem}.wallie-pb-4{padding-bottom:1rem}.wallie-pr-2{padding-right:.5rem}.wallie-pr-3{padding-right:.75rem}.wallie-pt-4{padding-top:1rem}.wallie-text-left{text-align:left}.wallie-text-2xl{font-size:1.5rem;line-height:2rem}.wallie-text-\\[21px\\]{font-size:21px}.wallie-text-lg{font-size:1.125rem;line-height:1.75rem}.wallie-text-sm{font-size:.875rem;line-height:1.25rem}.wallie-font-medium{font-weight:500}.wallie-leading-8{line-height:2rem}.wallie-text-orange-600{--tw-text-opacity:1;color:rgb(234 88 12/var(--tw-text-opacity))}.wallie-text-ord-alert{--tw-text-opacity:1;color:rgb(248 242 94/var(--tw-text-opacity))}.wallie-text-ord-blue{--tw-text-opacity:1;color:rgb(17 22 33/var(--tw-text-opacity))}.wallie-text-ord-gray{--tw-text-opacity:1;color:rgb(137 138 149/var(--tw-text-opacity))}.wallie-text-ord-light-blue-400{--tw-text-opacity:1;color:rgb(73 82 102/var(--tw-text-opacity))}.wallie-text-ord-light-gray{--tw-text-opacity:1;color:rgb(217 213 210/var(--tw-text-opacity))}.wallie-text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}.wallie-opacity-0{opacity:0}.wallie-opacity-100{opacity:1}.wallie-transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-duration-100{transition-duration:.1s}.wallie-duration-200{transition-duration:.2s}.wallie-duration-300{transition-duration:.3s}.wallie-ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.wallie-ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.wallie-ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}body,html{font-family:Outfit,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;scroll-behavior:smooth}@media (min-width:640px){.sm\\:wallie-items-center{align-items:center}.sm\\:wallie-p-0{padding:0}}@media (min-width:768px){.md\\:wallie-block{display:block}.md\\:wallie-w-7{width:1.75rem}.md\\:wallie-w-8{width:2rem}.md\\:wallie-w-96{width:24rem}.md\\:wallie-space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.md\\:wallie-bg-black\\/80{background-color:#000c}.md\\:wallie-px-3{padding-left:.75rem}.md\\:wallie-pr-3,.md\\:wallie-px-3{padding-right:.75rem}.md\\:wallie-text-xl{font-size:1.25rem;line-height:1.75rem}}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
import { validate as Kr, getAddressInfo as rr } from "bitcoin-address-validation";
import { BIP32Factory as qr } from "bip32";
import * as dr from "@bitcoinerlab/secp256k1";
import { networks as Z, initEccLib as Hr, payments as N } from "bitcoinjs-lib";
import "ecpair";
var Br = {}, Y = {};
Y.byteLength = Vr;
Y.toByteArray = Zr;
Y.fromByteArray = rt;
var S = [], R = [], Xr = typeof Uint8Array < "u" ? Uint8Array : Array, Q = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var O = 0, zr = Q.length; O < zr; ++O)
  S[O] = Q[O], R[Q.charCodeAt(O)] = O;
R[45] = 62;
R[95] = 63;
function Er(c) {
  var s = c.length;
  if (s % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var f = c.indexOf("=");
  f === -1 && (f = s);
  var y = f === s ? 0 : 4 - f % 4;
  return [f, y];
}
function Vr(c) {
  var s = Er(c), f = s[0], y = s[1];
  return (f + y) * 3 / 4 - y;
}
function Jr(c, s, f) {
  return (s + f) * 3 / 4 - f;
}
function Zr(c) {
  var s, f = Er(c), y = f[0], l = f[1], p = new Xr(Jr(c, y, l)), a = 0, g = l > 0 ? y - 4 : y, d;
  for (d = 0; d < g; d += 4)
    s = R[c.charCodeAt(d)] << 18 | R[c.charCodeAt(d + 1)] << 12 | R[c.charCodeAt(d + 2)] << 6 | R[c.charCodeAt(d + 3)], p[a++] = s >> 16 & 255, p[a++] = s >> 8 & 255, p[a++] = s & 255;
  return l === 2 && (s = R[c.charCodeAt(d)] << 2 | R[c.charCodeAt(d + 1)] >> 4, p[a++] = s & 255), l === 1 && (s = R[c.charCodeAt(d)] << 10 | R[c.charCodeAt(d + 1)] << 4 | R[c.charCodeAt(d + 2)] >> 2, p[a++] = s >> 8 & 255, p[a++] = s & 255), p;
}
function Qr(c) {
  return S[c >> 18 & 63] + S[c >> 12 & 63] + S[c >> 6 & 63] + S[c & 63];
}
function vr(c, s, f) {
  for (var y, l = [], p = s; p < f; p += 3)
    y = (c[p] << 16 & 16711680) + (c[p + 1] << 8 & 65280) + (c[p + 2] & 255), l.push(Qr(y));
  return l.join("");
}
function rt(c) {
  for (var s, f = c.length, y = f % 3, l = [], p = 16383, a = 0, g = f - y; a < g; a += p)
    l.push(vr(c, a, a + p > g ? g : a + p));
  return y === 1 ? (s = c[f - 1], l.push(
    S[s >> 2] + S[s << 4 & 63] + "=="
  )) : y === 2 && (s = (c[f - 2] << 8) + c[f - 1], l.push(
    S[s >> 10] + S[s >> 4 & 63] + S[s << 2 & 63] + "="
  )), l.join("");
}
var tr = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
tr.read = function(c, s, f, y, l) {
  var p, a, g = l * 8 - y - 1, d = (1 << g) - 1, F = d >> 1, o = -7, A = f ? l - 1 : 0, k = f ? -1 : 1, T = c[s + A];
  for (A += k, p = T & (1 << -o) - 1, T >>= -o, o += g; o > 0; p = p * 256 + c[s + A], A += k, o -= 8)
    ;
  for (a = p & (1 << -o) - 1, p >>= -o, o += y; o > 0; a = a * 256 + c[s + A], A += k, o -= 8)
    ;
  if (p === 0)
    p = 1 - F;
  else {
    if (p === d)
      return a ? NaN : (T ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, y), p = p - F;
  }
  return (T ? -1 : 1) * a * Math.pow(2, p - y);
};
tr.write = function(c, s, f, y, l, p) {
  var a, g, d, F = p * 8 - l - 1, o = (1 << F) - 1, A = o >> 1, k = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, T = y ? 0 : p - 1, P = y ? 1 : -1, K = s < 0 || s === 0 && 1 / s < 0 ? 1 : 0;
  for (s = Math.abs(s), isNaN(s) || s === 1 / 0 ? (g = isNaN(s) ? 1 : 0, a = o) : (a = Math.floor(Math.log(s) / Math.LN2), s * (d = Math.pow(2, -a)) < 1 && (a--, d *= 2), a + A >= 1 ? s += k / d : s += k * Math.pow(2, 1 - A), s * d >= 2 && (a++, d /= 2), a + A >= o ? (g = 0, a = o) : a + A >= 1 ? (g = (s * d - 1) * Math.pow(2, l), a = a + A) : (g = s * Math.pow(2, A - 1) * Math.pow(2, l), a = 0)); l >= 8; c[f + T] = g & 255, T += P, g /= 256, l -= 8)
    ;
  for (a = a << l | g, F += l; F > 0; c[f + T] = a & 255, T += P, a /= 256, F -= 8)
    ;
  c[f + T - P] |= K * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(c) {
  const s = Y, f = tr, y = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  c.Buffer = o, c.SlowBuffer = Ar, c.INSPECT_MAX_BYTES = 50;
  const l = 2147483647;
  c.kMaxLength = l;
  const { Uint8Array: p, ArrayBuffer: a, SharedArrayBuffer: g } = globalThis;
  o.TYPED_ARRAY_SUPPORT = d(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const e = new p(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, p.prototype), Object.setPrototypeOf(e, r), e.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function F(e) {
    if (e > l)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
    const r = new p(e);
    return Object.setPrototypeOf(r, o.prototype), r;
  }
  function o(e, r, t) {
    if (typeof e == "number") {
      if (typeof r == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return P(e);
    }
    return A(e, r, t);
  }
  o.poolSize = 8192;
  function A(e, r, t) {
    if (typeof e == "string")
      return K(e, r);
    if (a.isView(e))
      return Ir(e);
    if (e == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e
      );
    if (C(e, a) || e && C(e.buffer, a) || typeof g < "u" && (C(e, g) || e && C(e.buffer, g)))
      return H(e, r, t);
    if (typeof e == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const n = e.valueOf && e.valueOf();
    if (n != null && n !== e)
      return o.from(n, r, t);
    const i = Fr(e);
    if (i) return i;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
      return o.from(e[Symbol.toPrimitive]("string"), r, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e
    );
  }
  o.from = function(e, r, t) {
    return A(e, r, t);
  }, Object.setPrototypeOf(o.prototype, p.prototype), Object.setPrototypeOf(o, p);
  function k(e) {
    if (typeof e != "number")
      throw new TypeError('"size" argument must be of type number');
    if (e < 0)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
  }
  function T(e, r, t) {
    return k(e), e <= 0 ? F(e) : r !== void 0 ? typeof t == "string" ? F(e).fill(r, t) : F(e).fill(r) : F(e);
  }
  o.alloc = function(e, r, t) {
    return T(e, r, t);
  };
  function P(e) {
    return k(e), F(e < 0 ? 0 : X(e) | 0);
  }
  o.allocUnsafe = function(e) {
    return P(e);
  }, o.allocUnsafeSlow = function(e) {
    return P(e);
  };
  function K(e, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !o.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    const t = nr(e, r) | 0;
    let n = F(t);
    const i = n.write(e, r);
    return i !== t && (n = n.slice(0, i)), n;
  }
  function q(e) {
    const r = e.length < 0 ? 0 : X(e.length) | 0, t = F(r);
    for (let n = 0; n < r; n += 1)
      t[n] = e[n] & 255;
    return t;
  }
  function Ir(e) {
    if (C(e, p)) {
      const r = new p(e);
      return H(r.buffer, r.byteOffset, r.byteLength);
    }
    return q(e);
  }
  function H(e, r, t) {
    if (r < 0 || e.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e.byteLength < r + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return r === void 0 && t === void 0 ? n = new p(e) : t === void 0 ? n = new p(e, r) : n = new p(e, r, t), Object.setPrototypeOf(n, o.prototype), n;
  }
  function Fr(e) {
    if (o.isBuffer(e)) {
      const r = X(e.length) | 0, t = F(r);
      return t.length === 0 || e.copy(t, 0, 0, r), t;
    }
    if (e.length !== void 0)
      return typeof e.length != "number" || J(e.length) ? F(0) : q(e);
    if (e.type === "Buffer" && Array.isArray(e.data))
      return q(e.data);
  }
  function X(e) {
    if (e >= l)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l.toString(16) + " bytes");
    return e | 0;
  }
  function Ar(e) {
    return +e != e && (e = 0), o.alloc(+e);
  }
  o.isBuffer = function(r) {
    return r != null && r._isBuffer === !0 && r !== o.prototype;
  }, o.compare = function(r, t) {
    if (C(r, p) && (r = o.from(r, r.offset, r.byteLength)), C(t, p) && (t = o.from(t, t.offset, t.byteLength)), !o.isBuffer(r) || !o.isBuffer(t))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (r === t) return 0;
    let n = r.length, i = t.length;
    for (let u = 0, h = Math.min(n, i); u < h; ++u)
      if (r[u] !== t[u]) {
        n = r[u], i = t[u];
        break;
      }
    return n < i ? -1 : i < n ? 1 : 0;
  }, o.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, o.concat = function(r, t) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return o.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < r.length; ++n)
        t += r[n].length;
    const i = o.allocUnsafe(t);
    let u = 0;
    for (n = 0; n < r.length; ++n) {
      let h = r[n];
      if (C(h, p))
        u + h.length > i.length ? (o.isBuffer(h) || (h = o.from(h)), h.copy(i, u)) : p.prototype.set.call(
          i,
          h,
          u
        );
      else if (o.isBuffer(h))
        h.copy(i, u);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      u += h.length;
    }
    return i;
  };
  function nr(e, r) {
    if (o.isBuffer(e))
      return e.length;
    if (a.isView(e) || C(e, a))
      return e.byteLength;
    if (typeof e != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e
      );
    const t = e.length, n = arguments.length > 2 && arguments[2] === !0;
    if (!n && t === 0) return 0;
    let i = !1;
    for (; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return V(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return wr(e).length;
        default:
          if (i)
            return n ? -1 : V(e).length;
          r = ("" + r).toLowerCase(), i = !0;
      }
  }
  o.byteLength = nr;
  function Ur(e, r, t) {
    let n = !1;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
      return "";
    for (e || (e = "utf8"); ; )
      switch (e) {
        case "hex":
          return Mr(this, r, t);
        case "utf8":
        case "utf-8":
          return ur(this, r, t);
        case "ascii":
          return Nr(this, r, t);
        case "latin1":
        case "binary":
          return Pr(this, r, t);
        case "base64":
          return kr(this, r, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Lr(this, r, t);
        default:
          if (n) throw new TypeError("Unknown encoding: " + e);
          e = (e + "").toLowerCase(), n = !0;
      }
  }
  o.prototype._isBuffer = !0;
  function M(e, r, t) {
    const n = e[r];
    e[r] = e[t], e[t] = n;
  }
  o.prototype.swap16 = function() {
    const r = this.length;
    if (r % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < r; t += 2)
      M(this, t, t + 1);
    return this;
  }, o.prototype.swap32 = function() {
    const r = this.length;
    if (r % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < r; t += 4)
      M(this, t, t + 3), M(this, t + 1, t + 2);
    return this;
  }, o.prototype.swap64 = function() {
    const r = this.length;
    if (r % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < r; t += 8)
      M(this, t, t + 7), M(this, t + 1, t + 6), M(this, t + 2, t + 5), M(this, t + 3, t + 4);
    return this;
  }, o.prototype.toString = function() {
    const r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? ur(this, 0, r) : Ur.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(r) {
    if (!o.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
    return this === r ? !0 : o.compare(this, r) === 0;
  }, o.prototype.inspect = function() {
    let r = "";
    const t = c.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
  }, y && (o.prototype[y] = o.prototype.inspect), o.prototype.compare = function(r, t, n, i, u) {
    if (C(r, p) && (r = o.from(r, r.offset, r.byteLength)), !o.isBuffer(r))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r
      );
    if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), i === void 0 && (i = 0), u === void 0 && (u = this.length), t < 0 || n > r.length || i < 0 || u > this.length)
      throw new RangeError("out of range index");
    if (i >= u && t >= n)
      return 0;
    if (i >= u)
      return -1;
    if (t >= n)
      return 1;
    if (t >>>= 0, n >>>= 0, i >>>= 0, u >>>= 0, this === r) return 0;
    let h = u - i, w = n - t;
    const E = Math.min(h, w), B = this.slice(i, u), m = r.slice(t, n);
    for (let x = 0; x < E; ++x)
      if (B[x] !== m[x]) {
        h = B[x], w = m[x];
        break;
      }
    return h < w ? -1 : w < h ? 1 : 0;
  };
  function ir(e, r, t, n, i) {
    if (e.length === 0) return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, J(t) && (t = i ? 0 : e.length - 1), t < 0 && (t = e.length + t), t >= e.length) {
      if (i) return -1;
      t = e.length - 1;
    } else if (t < 0)
      if (i) t = 0;
      else return -1;
    if (typeof r == "string" && (r = o.from(r, n)), o.isBuffer(r))
      return r.length === 0 ? -1 : or(e, r, t, n, i);
    if (typeof r == "number")
      return r = r & 255, typeof p.prototype.indexOf == "function" ? i ? p.prototype.indexOf.call(e, r, t) : p.prototype.lastIndexOf.call(e, r, t) : or(e, [r], t, n, i);
    throw new TypeError("val must be string, number or Buffer");
  }
  function or(e, r, t, n, i) {
    let u = 1, h = e.length, w = r.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (e.length < 2 || r.length < 2)
        return -1;
      u = 2, h /= 2, w /= 2, t /= 2;
    }
    function E(m, x) {
      return u === 1 ? m[x] : m.readUInt16BE(x * u);
    }
    let B;
    if (i) {
      let m = -1;
      for (B = t; B < h; B++)
        if (E(e, B) === E(r, m === -1 ? 0 : B - m)) {
          if (m === -1 && (m = B), B - m + 1 === w) return m * u;
        } else
          m !== -1 && (B -= B - m), m = -1;
    } else
      for (t + w > h && (t = h - w), B = t; B >= 0; B--) {
        let m = !0;
        for (let x = 0; x < w; x++)
          if (E(e, B + x) !== E(r, x)) {
            m = !1;
            break;
          }
        if (m) return B;
      }
    return -1;
  }
  o.prototype.includes = function(r, t, n) {
    return this.indexOf(r, t, n) !== -1;
  }, o.prototype.indexOf = function(r, t, n) {
    return ir(this, r, t, n, !0);
  }, o.prototype.lastIndexOf = function(r, t, n) {
    return ir(this, r, t, n, !1);
  };
  function Tr(e, r, t, n) {
    t = Number(t) || 0;
    const i = e.length - t;
    n ? (n = Number(n), n > i && (n = i)) : n = i;
    const u = r.length;
    n > u / 2 && (n = u / 2);
    let h;
    for (h = 0; h < n; ++h) {
      const w = parseInt(r.substr(h * 2, 2), 16);
      if (J(w)) return h;
      e[t + h] = w;
    }
    return h;
  }
  function Rr(e, r, t, n) {
    return G(V(r, e.length - t), e, t, n);
  }
  function Cr(e, r, t, n) {
    return G(Wr(r), e, t, n);
  }
  function Sr(e, r, t, n) {
    return G(wr(r), e, t, n);
  }
  function _r(e, r, t, n) {
    return G(Gr(r, e.length - t), e, t, n);
  }
  o.prototype.write = function(r, t, n, i) {
    if (t === void 0)
      i = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string")
      i = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const u = this.length - t;
    if ((n === void 0 || n > u) && (n = u), r.length > 0 && (n < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let h = !1;
    for (; ; )
      switch (i) {
        case "hex":
          return Tr(this, r, t, n);
        case "utf8":
        case "utf-8":
          return Rr(this, r, t, n);
        case "ascii":
        case "latin1":
        case "binary":
          return Cr(this, r, t, n);
        case "base64":
          return Sr(this, r, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _r(this, r, t, n);
        default:
          if (h) throw new TypeError("Unknown encoding: " + i);
          i = ("" + i).toLowerCase(), h = !0;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function kr(e, r, t) {
    return r === 0 && t === e.length ? s.fromByteArray(e) : s.fromByteArray(e.slice(r, t));
  }
  function ur(e, r, t) {
    t = Math.min(e.length, t);
    const n = [];
    let i = r;
    for (; i < t; ) {
      const u = e[i];
      let h = null, w = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
      if (i + w <= t) {
        let E, B, m, x;
        switch (w) {
          case 1:
            u < 128 && (h = u);
            break;
          case 2:
            E = e[i + 1], (E & 192) === 128 && (x = (u & 31) << 6 | E & 63, x > 127 && (h = x));
            break;
          case 3:
            E = e[i + 1], B = e[i + 2], (E & 192) === 128 && (B & 192) === 128 && (x = (u & 15) << 12 | (E & 63) << 6 | B & 63, x > 2047 && (x < 55296 || x > 57343) && (h = x));
            break;
          case 4:
            E = e[i + 1], B = e[i + 2], m = e[i + 3], (E & 192) === 128 && (B & 192) === 128 && (m & 192) === 128 && (x = (u & 15) << 18 | (E & 63) << 12 | (B & 63) << 6 | m & 63, x > 65535 && x < 1114112 && (h = x));
        }
      }
      h === null ? (h = 65533, w = 1) : h > 65535 && (h -= 65536, n.push(h >>> 10 & 1023 | 55296), h = 56320 | h & 1023), n.push(h), i += w;
    }
    return br(n);
  }
  const cr = 4096;
  function br(e) {
    const r = e.length;
    if (r <= cr)
      return String.fromCharCode.apply(String, e);
    let t = "", n = 0;
    for (; n < r; )
      t += String.fromCharCode.apply(
        String,
        e.slice(n, n += cr)
      );
    return t;
  }
  function Nr(e, r, t) {
    let n = "";
    t = Math.min(e.length, t);
    for (let i = r; i < t; ++i)
      n += String.fromCharCode(e[i] & 127);
    return n;
  }
  function Pr(e, r, t) {
    let n = "";
    t = Math.min(e.length, t);
    for (let i = r; i < t; ++i)
      n += String.fromCharCode(e[i]);
    return n;
  }
  function Mr(e, r, t) {
    const n = e.length;
    (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
    let i = "";
    for (let u = r; u < t; ++u)
      i += Yr[e[u]];
    return i;
  }
  function Lr(e, r, t) {
    const n = e.slice(r, t);
    let i = "";
    for (let u = 0; u < n.length - 1; u += 2)
      i += String.fromCharCode(n[u] + n[u + 1] * 256);
    return i;
  }
  o.prototype.slice = function(r, t) {
    const n = this.length;
    r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
    const i = this.subarray(r, t);
    return Object.setPrototypeOf(i, o.prototype), i;
  };
  function I(e, r, t) {
    if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
    if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I(r, t, this.length);
    let i = this[r], u = 1, h = 0;
    for (; ++h < t && (u *= 256); )
      i += this[r + h] * u;
    return i;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I(r, t, this.length);
    let i = this[r + --t], u = 1;
    for (; t > 0 && (u *= 256); )
      i += this[r + --t] * u;
    return i;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(r, t) {
    return r = r >>> 0, t || I(r, 1, this.length), this[r];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(r, t) {
    return r = r >>> 0, t || I(r, 2, this.length), this[r] | this[r + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(r, t) {
    return r = r >>> 0, t || I(r, 2, this.length), this[r] << 8 | this[r + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(r, t) {
    return r = r >>> 0, t || I(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(r, t) {
    return r = r >>> 0, t || I(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  }, o.prototype.readBigUInt64LE = b(function(r) {
    r = r >>> 0, D(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $(r, this.length - 8);
    const i = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, u = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
    return BigInt(i) + (BigInt(u) << BigInt(32));
  }), o.prototype.readBigUInt64BE = b(function(r) {
    r = r >>> 0, D(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $(r, this.length - 8);
    const i = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], u = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
    return (BigInt(i) << BigInt(32)) + BigInt(u);
  }), o.prototype.readIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I(r, t, this.length);
    let i = this[r], u = 1, h = 0;
    for (; ++h < t && (u *= 256); )
      i += this[r + h] * u;
    return u *= 128, i >= u && (i -= Math.pow(2, 8 * t)), i;
  }, o.prototype.readIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || I(r, t, this.length);
    let i = t, u = 1, h = this[r + --i];
    for (; i > 0 && (u *= 256); )
      h += this[r + --i] * u;
    return u *= 128, h >= u && (h -= Math.pow(2, 8 * t)), h;
  }, o.prototype.readInt8 = function(r, t) {
    return r = r >>> 0, t || I(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  }, o.prototype.readInt16LE = function(r, t) {
    r = r >>> 0, t || I(r, 2, this.length);
    const n = this[r] | this[r + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, o.prototype.readInt16BE = function(r, t) {
    r = r >>> 0, t || I(r, 2, this.length);
    const n = this[r + 1] | this[r] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, o.prototype.readInt32LE = function(r, t) {
    return r = r >>> 0, t || I(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  }, o.prototype.readInt32BE = function(r, t) {
    return r = r >>> 0, t || I(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  }, o.prototype.readBigInt64LE = b(function(r) {
    r = r >>> 0, D(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $(r, this.length - 8);
    const i = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
    return (BigInt(i) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  }), o.prototype.readBigInt64BE = b(function(r) {
    r = r >>> 0, D(r, "offset");
    const t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && $(r, this.length - 8);
    const i = (t << 24) + // Overflow
    this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(i) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
  }), o.prototype.readFloatLE = function(r, t) {
    return r = r >>> 0, t || I(r, 4, this.length), f.read(this, r, !0, 23, 4);
  }, o.prototype.readFloatBE = function(r, t) {
    return r = r >>> 0, t || I(r, 4, this.length), f.read(this, r, !1, 23, 4);
  }, o.prototype.readDoubleLE = function(r, t) {
    return r = r >>> 0, t || I(r, 8, this.length), f.read(this, r, !0, 52, 8);
  }, o.prototype.readDoubleBE = function(r, t) {
    return r = r >>> 0, t || I(r, 8, this.length), f.read(this, r, !1, 52, 8);
  };
  function U(e, r, t, n, i, u) {
    if (!o.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > i || r < u) throw new RangeError('"value" argument is out of bounds');
    if (t + n > e.length) throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(r, t, n, i) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !i) {
      const w = Math.pow(2, 8 * n) - 1;
      U(this, r, t, n, w, 0);
    }
    let u = 1, h = 0;
    for (this[t] = r & 255; ++h < n && (u *= 256); )
      this[t + h] = r / u & 255;
    return t + n;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(r, t, n, i) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !i) {
      const w = Math.pow(2, 8 * n) - 1;
      U(this, r, t, n, w, 0);
    }
    let u = n - 1, h = 1;
    for (this[t + u] = r & 255; --u >= 0 && (h *= 256); )
      this[t + u] = r / h & 255;
    return t + n;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  function hr(e, r, t, n, i) {
    yr(r, n, i, e, t, 7);
    let u = Number(r & BigInt(4294967295));
    e[t++] = u, u = u >> 8, e[t++] = u, u = u >> 8, e[t++] = u, u = u >> 8, e[t++] = u;
    let h = Number(r >> BigInt(32) & BigInt(4294967295));
    return e[t++] = h, h = h >> 8, e[t++] = h, h = h >> 8, e[t++] = h, h = h >> 8, e[t++] = h, t;
  }
  function sr(e, r, t, n, i) {
    yr(r, n, i, e, t, 7);
    let u = Number(r & BigInt(4294967295));
    e[t + 7] = u, u = u >> 8, e[t + 6] = u, u = u >> 8, e[t + 5] = u, u = u >> 8, e[t + 4] = u;
    let h = Number(r >> BigInt(32) & BigInt(4294967295));
    return e[t + 3] = h, h = h >> 8, e[t + 2] = h, h = h >> 8, e[t + 1] = h, h = h >> 8, e[t] = h, t + 8;
  }
  o.prototype.writeBigUInt64LE = b(function(r, t = 0) {
    return hr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeBigUInt64BE = b(function(r, t = 0) {
    return sr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeIntLE = function(r, t, n, i) {
    if (r = +r, t = t >>> 0, !i) {
      const E = Math.pow(2, 8 * n - 1);
      U(this, r, t, n, E - 1, -E);
    }
    let u = 0, h = 1, w = 0;
    for (this[t] = r & 255; ++u < n && (h *= 256); )
      r < 0 && w === 0 && this[t + u - 1] !== 0 && (w = 1), this[t + u] = (r / h >> 0) - w & 255;
    return t + n;
  }, o.prototype.writeIntBE = function(r, t, n, i) {
    if (r = +r, t = t >>> 0, !i) {
      const E = Math.pow(2, 8 * n - 1);
      U(this, r, t, n, E - 1, -E);
    }
    let u = n - 1, h = 1, w = 0;
    for (this[t + u] = r & 255; --u >= 0 && (h *= 256); )
      r < 0 && w === 0 && this[t + u + 1] !== 0 && (w = 1), this[t + u] = (r / h >> 0) - w & 255;
    return t + n;
  }, o.prototype.writeInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
  }, o.prototype.writeInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  }, o.prototype.writeInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  }, o.prototype.writeInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
  }, o.prototype.writeInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || U(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  }, o.prototype.writeBigInt64LE = b(function(r, t = 0) {
    return hr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o.prototype.writeBigInt64BE = b(function(r, t = 0) {
    return sr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function fr(e, r, t, n, i, u) {
    if (t + n > e.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function pr(e, r, t, n, i) {
    return r = +r, t = t >>> 0, i || fr(e, r, t, 4), f.write(e, r, t, n, 23, 4), t + 4;
  }
  o.prototype.writeFloatLE = function(r, t, n) {
    return pr(this, r, t, !0, n);
  }, o.prototype.writeFloatBE = function(r, t, n) {
    return pr(this, r, t, !1, n);
  };
  function ar(e, r, t, n, i) {
    return r = +r, t = t >>> 0, i || fr(e, r, t, 8), f.write(e, r, t, n, 52, 8), t + 8;
  }
  o.prototype.writeDoubleLE = function(r, t, n) {
    return ar(this, r, t, !0, n);
  }, o.prototype.writeDoubleBE = function(r, t, n) {
    return ar(this, r, t, !1, n);
  }, o.prototype.copy = function(r, t, n, i) {
    if (!o.isBuffer(r)) throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= r.length && (t = r.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || r.length === 0 || this.length === 0) return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length), r.length - t < i - n && (i = r.length - t + n);
    const u = i - n;
    return this === r && typeof p.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : p.prototype.set.call(
      r,
      this.subarray(n, i),
      t
    ), u;
  }, o.prototype.fill = function(r, t, n, i) {
    if (typeof r == "string") {
      if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !o.isEncoding(i))
        throw new TypeError("Unknown encoding: " + i);
      if (r.length === 1) {
        const h = r.charCodeAt(0);
        (i === "utf8" && h < 128 || i === "latin1") && (r = h);
      }
    } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (t < 0 || this.length < t || this.length < n)
      throw new RangeError("Out of range index");
    if (n <= t)
      return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
    let u;
    if (typeof r == "number")
      for (u = t; u < n; ++u)
        this[u] = r;
    else {
      const h = o.isBuffer(r) ? r : o.from(r, i), w = h.length;
      if (w === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (u = 0; u < n - t; ++u)
        this[u + t] = h[u % w];
    }
    return this;
  };
  const L = {};
  function z(e, r, t) {
    L[e] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: r.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
      }
      get code() {
        return e;
      }
      set code(i) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: i,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${e}]: ${this.message}`;
      }
    };
  }
  z(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), z(
    "ERR_INVALID_ARG_TYPE",
    function(e, r) {
      return `The "${e}" argument must be of type number. Received type ${typeof r}`;
    },
    TypeError
  ), z(
    "ERR_OUT_OF_RANGE",
    function(e, r, t) {
      let n = `The value of "${e}" is out of range.`, i = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = lr(String(t)) : typeof t == "bigint" && (i = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = lr(i)), i += "n"), n += ` It must be ${r}. Received ${i}`, n;
    },
    RangeError
  );
  function lr(e) {
    let r = "", t = e.length;
    const n = e[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3)
      r = `_${e.slice(t - 3, t)}${r}`;
    return `${e.slice(0, t)}${r}`;
  }
  function Dr(e, r, t) {
    D(r, "offset"), (e[r] === void 0 || e[r + t] === void 0) && $(r, e.length - (t + 1));
  }
  function yr(e, r, t, n, i, u) {
    if (e > t || e < r) {
      const h = typeof r == "bigint" ? "n" : "";
      let w;
      throw r === 0 || r === BigInt(0) ? w = `>= 0${h} and < 2${h} ** ${(u + 1) * 8}${h}` : w = `>= -(2${h} ** ${(u + 1) * 8 - 1}${h}) and < 2 ** ${(u + 1) * 8 - 1}${h}`, new L.ERR_OUT_OF_RANGE("value", w, e);
    }
    Dr(n, i, u);
  }
  function D(e, r) {
    if (typeof e != "number")
      throw new L.ERR_INVALID_ARG_TYPE(r, "number", e);
  }
  function $(e, r, t) {
    throw Math.floor(e) !== e ? (D(e, t), new L.ERR_OUT_OF_RANGE("offset", "an integer", e)) : r < 0 ? new L.ERR_BUFFER_OUT_OF_BOUNDS() : new L.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${r}`,
      e
    );
  }
  const Or = /[^+/0-9A-Za-z-_]/g;
  function $r(e) {
    if (e = e.split("=")[0], e = e.trim().replace(Or, ""), e.length < 2) return "";
    for (; e.length % 4 !== 0; )
      e = e + "=";
    return e;
  }
  function V(e, r) {
    r = r || 1 / 0;
    let t;
    const n = e.length;
    let i = null;
    const u = [];
    for (let h = 0; h < n; ++h) {
      if (t = e.charCodeAt(h), t > 55295 && t < 57344) {
        if (!i) {
          if (t > 56319) {
            (r -= 3) > -1 && u.push(239, 191, 189);
            continue;
          } else if (h + 1 === n) {
            (r -= 3) > -1 && u.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (r -= 3) > -1 && u.push(239, 191, 189), i = t;
          continue;
        }
        t = (i - 55296 << 10 | t - 56320) + 65536;
      } else i && (r -= 3) > -1 && u.push(239, 191, 189);
      if (i = null, t < 128) {
        if ((r -= 1) < 0) break;
        u.push(t);
      } else if (t < 2048) {
        if ((r -= 2) < 0) break;
        u.push(
          t >> 6 | 192,
          t & 63 | 128
        );
      } else if (t < 65536) {
        if ((r -= 3) < 0) break;
        u.push(
          t >> 12 | 224,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else if (t < 1114112) {
        if ((r -= 4) < 0) break;
        u.push(
          t >> 18 | 240,
          t >> 12 & 63 | 128,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return u;
  }
  function Wr(e) {
    const r = [];
    for (let t = 0; t < e.length; ++t)
      r.push(e.charCodeAt(t) & 255);
    return r;
  }
  function Gr(e, r) {
    let t, n, i;
    const u = [];
    for (let h = 0; h < e.length && !((r -= 2) < 0); ++h)
      t = e.charCodeAt(h), n = t >> 8, i = t % 256, u.push(i), u.push(n);
    return u;
  }
  function wr(e) {
    return s.toByteArray($r(e));
  }
  function G(e, r, t, n) {
    let i;
    for (i = 0; i < n && !(i + t >= r.length || i >= e.length); ++i)
      r[i + t] = e[i];
    return i;
  }
  function C(e, r) {
    return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
  }
  function J(e) {
    return e !== e;
  }
  const Yr = function() {
    const e = "0123456789abcdef", r = new Array(256);
    for (let t = 0; t < 16; ++t) {
      const n = t * 16;
      for (let i = 0; i < 16; ++i)
        r[n + i] = e[t] + e[i];
    }
    return r;
  }();
  function b(e) {
    return typeof BigInt > "u" ? jr : e;
  }
  function jr() {
    throw new Error("BigInt not supported");
  }
})(Br);
const v = Br.Buffer, dt = 600, Bt = 5e6, Et = 2, tt = qr(dr), et = v.alloc(32, 1);
class mt extends Error {
  constructor(s = "Cannot extract transaction from non-finalized psbt.") {
    super(s), this.name = "BrowserWalletExtractTxFromNonFinalizedPsbtError";
  }
}
class gt extends Error {
  constructor(s) {
    super(s), this.name = "BrowserWalletNotInstalledError";
  }
}
class It extends Error {
  constructor(s = "Request canceled by user.") {
    super(s), this.name = "BrowserWalletRequestCancelledByUserError";
  }
}
class W extends Error {
  constructor(s) {
    super(s), this.name = "OrditSDKError";
  }
}
function nt(c) {
  return Object.fromEntries(
    Object.entries(c).map(([s, f]) => [f, s])
  );
}
const _ = {
  p2pkh: "legacy",
  p2sh: "p2sh-p2wpkh",
  p2wsh: "p2wsh",
  p2wpkh: "segwit",
  p2tr: "taproot"
}, Ft = nt(_);
function er(c) {
  return c === "mainnet" ? Z.bitcoin : c === "signet" ? Z.testnet : Z[c];
}
function mr(c, s, f, y) {
  Hr(dr);
  const l = typeof f == "string" ? er(f) : f;
  return s === "p2tr" ? N.p2tr({
    internalPubkey: c,
    network: l,
    ...y
  }) : s === "p2sh" ? N.p2sh({
    redeem: N.p2wpkh({ pubkey: c, network: l }),
    network: l
  }) : N[s]({ pubkey: c, network: l });
}
function At(c) {
  return c.subarray(1, 33);
}
const it = (c) => (c == null ? void 0 : c.constructor) === Object, ot = (c) => c instanceof String || typeof c == "string";
function gr(c, { encode: s, depth: f = 0 }) {
  if (f > 5)
    throw new W("Object too deep");
  for (const l in c) {
    if (!c.hasOwnProperty(l))
      continue;
    const p = c[l];
    it(p) ? c[l] = gr(p, {
      encode: s,
      depth: f + 1
    }) : ot(p) && (c[l] = s ? encodeURIComponent(p) : decodeURIComponent(p));
  }
  return c;
}
function Ut(c) {
  return gr(c, { encode: !1 });
}
function Tt(c) {
  return c / 10 ** 8;
}
function Rt(c, s) {
  return `${c}:${s}`;
}
function Ct(c) {
  return c.includes(":") ? c.replace(":", "i") : c.includes("i") ? c : `${c}i0`;
}
function j(c, s) {
  return (f) => {
    try {
      return c({ output: f, network: er(s) });
    } catch {
      return !1;
    }
  };
}
const ut = (c, s) => ({
  type: "p2pkh",
  payload: j(N.p2pkh, s)(c)
}), ct = (c, s) => ({
  type: "p2wpkh",
  payload: j(N.p2wpkh, s)(c)
}), ht = (c, s) => ({
  type: "p2sh",
  payload: j(N.p2sh, s)(c)
}), st = (c, s) => ({
  type: "p2tr",
  payload: j(N.p2tr, s)(c)
});
function St(c, s) {
  const f = ut(c, s);
  if (f.payload)
    return {
      format: _.p2pkh,
      ...f
    };
  const y = ct(c, s);
  if (y.payload)
    return {
      format: _.p2wpkh,
      ...y
    };
  const l = ht(c, s);
  if (l.payload)
    return {
      format: _.p2sh,
      ...l
    };
  const p = st(c, s);
  if (p.payload)
    return {
      format: _.p2tr,
      ...p
    };
  throw new W("Unsupported input");
}
function ft(c) {
  try {
    const { type: s, network: f, bech32: y } = rr(c);
    if (!y && f !== "testnet" || y && f !== "regtest")
      throw new Error("Invalid address");
    return _[s];
  } catch {
    throw new W("Invalid address");
  }
}
function _t(c, s) {
  if (s === "regtest")
    return ft(c);
  if (!Kr(
    c,
    s === "signet" ? "testnet" : s
  ))
    throw new W("Invalid address");
  const { type: f } = rr(c);
  return _[f];
}
function pt(c, s) {
  const f = c.subarray(1, 33), { address: y } = mr(f, "p2tr", s);
  return {
    address: y,
    // address will never be undefined
    format: _.p2tr,
    publicKey: c.toString("hex"),
    xKey: f.toString("hex")
  };
}
function xr(c, s, f) {
  if (f === "p2tr")
    return pt(c, s);
  const { address: y } = mr(c, f, s);
  return {
    address: y,
    // address will never be undefined
    format: _[f],
    publicKey: c.toString("hex")
  };
}
function kt(c, s = "mainnet", f = "all") {
  const y = v.isBuffer(c) ? c : v.from(c, "hex"), { publicKey: l } = tt.fromPublicKey(
    y,
    et,
    er(s)
  );
  return f === "all" ? Object.keys(_).filter((a) => a !== "p2wsh").map(
    (a) => xr(l, s, a)
  ) : [xr(l, s, f)];
}
function bt(c) {
  try {
    const { network: s } = rr(c);
    return s;
  } catch {
    throw new W("Invalid address");
  }
}
export {
  Ft as A,
  gt as B,
  et as C,
  Et as I,
  Bt as M,
  W as O,
  Ut as U,
  er as a,
  St as b,
  tt as c,
  v as d,
  mr as e,
  Rt as f,
  kt as g,
  dt as h,
  Tt as i,
  _t as j,
  It as k,
  mt as l,
  bt as m,
  _ as n,
  Ct as o,
  At as t
};
