var Zr = Object.defineProperty;
var Qr = (B, L, K) => L in B ? Zr(B, L, { enumerable: !0, configurable: !0, writable: !0, value: K }) : B[L] = K;
var Xr = (B, L, K) => Qr(B, typeof L != "symbol" ? L + "" : L, K);
import * as C$3 from "react";
import C__default, { useEffect, useLayoutEffect, useRef, useState, useMemo, forwardRef, Fragment, isValidElement, cloneElement, createElement, createContext, useContext, useReducer, createRef, useCallback } from "react";
import { createPortal } from "react-dom";
function _mergeNamespaces(B, L) {
  for (var K = 0; K < L.length; K++) {
    const W = L[K];
    if (typeof W != "string" && !Array.isArray(W)) {
      for (const V in W) if (V !== "default" && !(V in B)) {
        const J = Object.getOwnPropertyDescriptor(W, V);
        J && Object.defineProperty(B, V, J.get ? J : { enumerable: !0, get: () => W[V] });
      }
    }
  }
  return Object.freeze(Object.defineProperty(B, Symbol.toStringTag, { value: "Module" }));
}
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout) return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout) return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
(function() {
  try {
    cachedSetTimeout = typeof setTimeout == "function" ? setTimeout : defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    cachedClearTimeout = typeof clearTimeout == "function" ? clearTimeout : defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var L = queue.length; L; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < L; ) currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, L = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
function Item(B, L) {
  this.fun = B, this.array = L;
}
function noop() {
}
process.nextTick = function(B) {
  var L = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var K = 1; K < arguments.length; K++) L[K - 1] = arguments[K];
  queue.push(new Item(B, L)), queue.length !== 1 || draining || runTimeout(drainQueue);
}, Item.prototype.run = function() {
  this.fun.apply(null, this.array);
}, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function(B) {
  return [];
}, process.binding = function(B) {
  throw new Error("process.binding is not supported");
}, process.cwd = function() {
  return "/";
}, process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
}, process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1 = getDefaultExportFromCjs$1(browserExports$1);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
function getAugmentedNamespace(B) {
  if (B.__esModule) return B;
  var L = B.default;
  if (typeof L == "function") {
    var K = function W() {
      return this instanceof W ? Reflect.construct(L, arguments, this.constructor) : L.apply(this, arguments);
    };
    K.prototype = L.prototype;
  } else K = {};
  return Object.defineProperty(K, "__esModule", { value: !0 }), Object.keys(B).forEach(function(W) {
    var V = Object.getOwnPropertyDescriptor(B, W);
    Object.defineProperty(K, W, V.get ? V : { enumerable: !0, get: function() {
      return B[W];
    } });
  }), K;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {}, hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = C__default, L = Symbol.for("react.element"), K = Symbol.for("react.fragment"), W = Object.prototype.hasOwnProperty, V = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, J = { key: !0, ref: !0, __self: !0, __source: !0 };
  function re(ie, ne, oe) {
    var ce, pe = {}, ke = null, ot = null;
    for (ce in oe !== void 0 && (ke = "" + oe), ne.key !== void 0 && (ke = "" + ne.key), ne.ref !== void 0 && (ot = ne.ref), ne) W.call(ne, ce) && !J.hasOwnProperty(ce) && (pe[ce] = ne[ce]);
    if (ie && ie.defaultProps) for (ce in ne = ie.defaultProps) pe[ce] === void 0 && (pe[ce] = ne[ce]);
    return { $$typeof: L, type: ie, key: ke, ref: ot, props: pe, _owner: V.current };
  }
  return reactJsxRuntime_production_min.Fragment = K, reactJsxRuntime_production_min.jsx = re, reactJsxRuntime_production_min.jsxs = re, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = C__default, L = Symbol.for("react.element"), K = Symbol.for("react.portal"), W = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), re = Symbol.for("react.provider"), ie = Symbol.for("react.context"), ne = Symbol.for("react.forward_ref"), oe = Symbol.for("react.suspense"), ce = Symbol.for("react.suspense_list"), pe = Symbol.for("react.memo"), ke = Symbol.for("react.lazy"), ot = Symbol.for("react.offscreen"), at = Symbol.iterator, ft = "@@iterator", dt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function lt(Dt) {
      for (var Zt = arguments.length, ar = new Array(Zt > 1 ? Zt - 1 : 0), qt = 1; qt < Zt; qt++) ar[qt - 1] = arguments[qt];
      (function(Pt, Ot, Ct) {
        var Lt = dt.ReactDebugCurrentFrame.getStackAddendum();
        Lt !== "" && (Ot += "%s", Ct = Ct.concat([Lt]));
        var Vt = Ct.map(function(Jt) {
          return String(Jt);
        });
        Vt.unshift("Warning: " + Ot), Function.prototype.apply.call(console.error, console, Vt);
      })(0, Dt, ar);
    }
    var yt;
    function St(Dt) {
      return Dt.displayName || "Context";
    }
    function mt(Dt) {
      if (Dt == null) return null;
      if (typeof Dt.tag == "number" && lt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Dt == "function") return Dt.displayName || Dt.name || null;
      if (typeof Dt == "string") return Dt;
      switch (Dt) {
        case W:
          return "Fragment";
        case K:
          return "Portal";
        case J:
          return "Profiler";
        case V:
          return "StrictMode";
        case oe:
          return "Suspense";
        case ce:
          return "SuspenseList";
      }
      if (typeof Dt == "object") switch (Dt.$$typeof) {
        case ie:
          return St(Dt) + ".Consumer";
        case re:
          return St(Dt._context) + ".Provider";
        case ne:
          return function(Ot, Ct, Lt) {
            var Vt = Ot.displayName;
            if (Vt) return Vt;
            var Jt = Ct.displayName || Ct.name || "";
            return Jt !== "" ? Lt + "(" + Jt + ")" : Lt;
          }(Dt, Dt.render, "ForwardRef");
        case pe:
          var Zt = Dt.displayName || null;
          return Zt !== null ? Zt : mt(Dt.type) || "Memo";
        case ke:
          var ar = Dt, qt = ar._payload, Pt = ar._init;
          try {
            return mt(Pt(qt));
          } catch {
            return null;
          }
      }
      return null;
    }
    yt = Symbol.for("react.module.reference");
    var $t, It, Ut, ut, ht, Ce, nt, rt = Object.assign, it = 0;
    function st() {
    }
    st.__reactDisabledLog = !0;
    var Oe, ct = dt.ReactCurrentDispatcher;
    function pt(Dt, Zt, ar) {
      if (Oe === void 0) try {
        throw Error();
      } catch (Pt) {
        var qt = Pt.stack.trim().match(/\n( *(at )?)/);
        Oe = qt && qt[1] || "";
      }
      return `
` + Oe + Dt;
    }
    var gt, vt = !1, Bt = typeof WeakMap == "function" ? WeakMap : Map;
    function kt(Dt, Zt) {
      if (!Dt || vt) return "";
      var ar, qt = gt.get(Dt);
      if (qt !== void 0) return qt;
      vt = !0;
      var Pt, Ot = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0, Pt = ct.current, ct.current = null, function() {
        if (it === 0) {
          $t = console.log, It = console.info, Ut = console.warn, ut = console.error, ht = console.group, Ce = console.groupCollapsed, nt = console.groupEnd;
          var sr = { configurable: !0, enumerable: !0, value: st, writable: !0 };
          Object.defineProperties(console, { info: sr, log: sr, warn: sr, error: sr, group: sr, groupCollapsed: sr, groupEnd: sr });
        }
        it++;
      }();
      try {
        if (Zt) {
          var Ct = function() {
            throw Error();
          };
          if (Object.defineProperty(Ct.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ct, []);
            } catch (sr) {
              ar = sr;
            }
            Reflect.construct(Dt, [], Ct);
          } else {
            try {
              Ct.call();
            } catch (sr) {
              ar = sr;
            }
            Dt.call(Ct.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (sr) {
            ar = sr;
          }
          Dt();
        }
      } catch (sr) {
        if (sr && ar && typeof sr.stack == "string") {
          for (var Lt = sr.stack.split(`
`), Vt = ar.stack.split(`
`), Jt = Lt.length - 1, Gt = Vt.length - 1; Jt >= 1 && Gt >= 0 && Lt[Jt] !== Vt[Gt]; ) Gt--;
          for (; Jt >= 1 && Gt >= 0; Jt--, Gt--) if (Lt[Jt] !== Vt[Gt]) {
            if (Jt !== 1 || Gt !== 1) do
              if (Jt--, --Gt < 0 || Lt[Jt] !== Vt[Gt]) {
                var er = `
` + Lt[Jt].replace(" at new ", " at ");
                return Dt.displayName && er.includes("<anonymous>") && (er = er.replace("<anonymous>", Dt.displayName)), typeof Dt == "function" && gt.set(Dt, er), er;
              }
            while (Jt >= 1 && Gt >= 0);
            break;
          }
        }
      } finally {
        vt = !1, ct.current = Pt, function() {
          if (--it == 0) {
            var sr = { configurable: !0, enumerable: !0, writable: !0 };
            Object.defineProperties(console, { log: rt({}, sr, { value: $t }), info: rt({}, sr, { value: It }), warn: rt({}, sr, { value: Ut }), error: rt({}, sr, { value: ut }), group: rt({}, sr, { value: ht }), groupCollapsed: rt({}, sr, { value: Ce }), groupEnd: rt({}, sr, { value: nt }) });
          }
          it < 0 && lt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }(), Error.prepareStackTrace = Ot;
      }
      var or = Dt ? Dt.displayName || Dt.name : "", tr = or ? pt(or) : "";
      return typeof Dt == "function" && gt.set(Dt, tr), tr;
    }
    function wt(Dt, Zt, ar) {
      if (Dt == null) return "";
      if (typeof Dt == "function") return kt(Dt, !(!(qt = Dt.prototype) || !qt.isReactComponent));
      var qt;
      if (typeof Dt == "string") return pt(Dt);
      switch (Dt) {
        case oe:
          return pt("Suspense");
        case ce:
          return pt("SuspenseList");
      }
      if (typeof Dt == "object") switch (Dt.$$typeof) {
        case ne:
          return kt(Dt.render, !1);
        case pe:
          return wt(Dt.type, Zt, ar);
        case ke:
          var Pt = Dt, Ot = Pt._payload, Ct = Pt._init;
          try {
            return wt(Ct(Ot), Zt, ar);
          } catch {
          }
      }
      return "";
    }
    gt = new Bt();
    var Et = Object.prototype.hasOwnProperty, Rt = {}, Mt = dt.ReactDebugCurrentFrame;
    function Ht(Dt) {
      if (Dt) {
        var Zt = Dt._owner, ar = wt(Dt.type, Dt._source, Zt ? Zt.type : null);
        Mt.setExtraStackFrame(ar);
      } else Mt.setExtraStackFrame(null);
    }
    var Kt = Array.isArray;
    function jt(Dt) {
      return Kt(Dt);
    }
    function Wt(Dt) {
      return "" + Dt;
    }
    function Yt(Dt) {
      if (function(Zt) {
        try {
          return Wt(Zt), !1;
        } catch {
          return !0;
        }
      }(Dt)) return lt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", function(Zt) {
        return typeof Symbol == "function" && Symbol.toStringTag && Zt[Symbol.toStringTag] || Zt.constructor.name || "Object";
      }(Dt)), Wt(Dt);
    }
    var Xt, ir, ur, Qt = dt.ReactCurrentOwner, hr = { key: !0, ref: !0, __self: !0, __source: !0 };
    ur = {};
    var pr = function(Dt, Zt, ar, qt, Pt, Ot, Ct) {
      var Lt = { $$typeof: L, type: Dt, key: Zt, ref: ar, props: Ct, _owner: Ot, _store: {} };
      return Object.defineProperty(Lt._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(Lt, "_self", { configurable: !1, enumerable: !1, writable: !1, value: qt }), Object.defineProperty(Lt, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Pt }), Object.freeze && (Object.freeze(Lt.props), Object.freeze(Lt)), Lt;
    }, cr, vr = dt.ReactCurrentOwner, bt = dt.ReactDebugCurrentFrame;
    function At(Dt) {
      if (Dt) {
        var Zt = Dt._owner, ar = wt(Dt.type, Dt._source, Zt ? Zt.type : null);
        bt.setExtraStackFrame(ar);
      } else bt.setExtraStackFrame(null);
    }
    function Tt(Dt) {
      return typeof Dt == "object" && Dt !== null && Dt.$$typeof === L;
    }
    function xt() {
      if (vr.current) {
        var Dt = mt(vr.current.type);
        if (Dt) return `

Check the render method of \`` + Dt + "`.";
      }
      return "";
    }
    cr = !1;
    var Nt = {};
    function Ft(Dt, Zt) {
      if (Dt._store && !Dt._store.validated && Dt.key == null) {
        Dt._store.validated = !0;
        var ar = function(Pt) {
          var Ot = xt();
          if (!Ot) {
            var Ct = typeof Pt == "string" ? Pt : Pt.displayName || Pt.name;
            Ct && (Ot = `

Check the top-level render call using <` + Ct + ">.");
          }
          return Ot;
        }(Zt);
        if (!Nt[ar]) {
          Nt[ar] = !0;
          var qt = "";
          Dt && Dt._owner && Dt._owner !== vr.current && (qt = " It was passed a child from " + mt(Dt._owner.type) + "."), At(Dt), lt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ar, qt), At(null);
        }
      }
    }
    function zt(Dt, Zt) {
      if (typeof Dt == "object") {
        if (jt(Dt)) for (var ar = 0; ar < Dt.length; ar++) {
          var qt = Dt[ar];
          Tt(qt) && Ft(qt, Zt);
        }
        else if (Tt(Dt)) Dt._store && (Dt._store.validated = !0);
        else if (Dt) {
          var Pt = function(Lt) {
            if (Lt === null || typeof Lt != "object") return null;
            var Vt = at && Lt[at] || Lt[ft];
            return typeof Vt == "function" ? Vt : null;
          }(Dt);
          if (typeof Pt == "function" && Pt !== Dt.entries) for (var Ot, Ct = Pt.call(Dt); !(Ot = Ct.next()).done; ) Tt(Ot.value) && Ft(Ot.value, Zt);
        }
      }
    }
    var nr = {};
    function lr(Dt, Zt, ar, qt, Pt, Ot) {
      var Ct = function(rr) {
        return typeof rr == "string" || typeof rr == "function" || !(rr !== W && rr !== J && rr !== V && rr !== oe && rr !== ce && rr !== ot) || typeof rr == "object" && rr !== null && (rr.$$typeof === ke || rr.$$typeof === pe || rr.$$typeof === re || rr.$$typeof === ie || rr.$$typeof === ne || rr.$$typeof === yt || rr.getModuleId !== void 0);
      }(Dt);
      if (!Ct) {
        var Lt, Vt = "";
        (Dt === void 0 || typeof Dt == "object" && Dt !== null && Object.keys(Dt).length === 0) && (Vt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), Vt += xt(), Dt === null ? Lt = "null" : jt(Dt) ? Lt = "array" : Dt !== void 0 && Dt.$$typeof === L ? (Lt = "<" + (mt(Dt.type) || "Unknown") + " />", Vt = " Did you accidentally export a JSX literal instead of a component?") : Lt = typeof Dt, lt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Lt, Vt);
      }
      var Jt = function(rr, fr, dr, Sr, br) {
        var Er, $r = {}, yr = null, kr = null;
        for (Er in dr !== void 0 && (Yt(dr), yr = "" + dr), function(_r) {
          if (Et.call(_r, "key")) {
            var Ar = Object.getOwnPropertyDescriptor(_r, "key").get;
            if (Ar && Ar.isReactWarning) return !1;
          }
          return _r.key !== void 0;
        }(fr) && (Yt(fr.key), yr = "" + fr.key), function(_r) {
          if (Et.call(_r, "ref")) {
            var Ar = Object.getOwnPropertyDescriptor(_r, "ref").get;
            if (Ar && Ar.isReactWarning) return !1;
          }
          return _r.ref !== void 0;
        }(fr) && (kr = fr.ref, function(_r, Ar) {
          if (typeof _r.ref == "string" && Qt.current && Ar && Qt.current.stateNode !== Ar) {
            var wr = mt(Qt.current.type);
            ur[wr] || (lt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mt(Qt.current.type), _r.ref), ur[wr] = !0);
          }
        }(fr, br)), fr) Et.call(fr, Er) && !hr.hasOwnProperty(Er) && ($r[Er] = fr[Er]);
        if (rr && rr.defaultProps) {
          var Tr = rr.defaultProps;
          for (Er in Tr) $r[Er] === void 0 && ($r[Er] = Tr[Er]);
        }
        if (yr || kr) {
          var gr = typeof rr == "function" ? rr.displayName || rr.name || "Unknown" : rr;
          yr && function(_r, Ar) {
            var wr = function() {
              Xt || (Xt = !0, lt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ar));
            };
            wr.isReactWarning = !0, Object.defineProperty(_r, "key", { get: wr, configurable: !0 });
          }($r, gr), kr && function(_r, Ar) {
            var wr = function() {
              ir || (ir = !0, lt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ar));
            };
            wr.isReactWarning = !0, Object.defineProperty(_r, "ref", { get: wr, configurable: !0 });
          }($r, gr);
        }
        return pr(rr, yr, kr, br, Sr, Qt.current, $r);
      }(Dt, Zt, ar, Pt, Ot);
      if (Jt == null) return Jt;
      if (Ct) {
        var Gt = Zt.children;
        if (Gt !== void 0) if (qt) if (jt(Gt)) {
          for (var er = 0; er < Gt.length; er++) zt(Gt[er], Dt);
          Object.freeze && Object.freeze(Gt);
        } else lt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else zt(Gt, Dt);
      }
      if (Et.call(Zt, "key")) {
        var or = mt(Dt), tr = Object.keys(Zt).filter(function(rr) {
          return rr !== "key";
        }), sr = tr.length > 0 ? "{key: someKey, " + tr.join(": ..., ") + ": ...}" : "{key: someKey}";
        nr[or + sr] || (lt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, or, tr.length > 0 ? "{" + tr.join(": ..., ") + ": ...}" : "{}", or), nr[or + sr] = !0);
      }
      return Dt === W ? function(rr) {
        for (var fr = Object.keys(rr.props), dr = 0; dr < fr.length; dr++) {
          var Sr = fr[dr];
          if (Sr !== "children" && Sr !== "key") {
            At(rr), lt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Sr), At(null);
            break;
          }
        }
        rr.ref !== null && (At(rr), lt("Invalid attribute `ref` supplied to `React.Fragment`."), At(null));
      }(Jt) : function(rr) {
        var fr, dr = rr.type;
        if (dr != null && typeof dr != "string") {
          if (typeof dr == "function") fr = dr.propTypes;
          else {
            if (typeof dr != "object" || dr.$$typeof !== ne && dr.$$typeof !== pe) return;
            fr = dr.propTypes;
          }
          if (fr) {
            var Sr = mt(dr);
            (function(br, Er, $r, yr, kr) {
              var Tr = Function.call.bind(Et);
              for (var gr in br) if (Tr(br, gr)) {
                var _r = void 0;
                try {
                  if (typeof br[gr] != "function") {
                    var Ar = Error((yr || "React class") + ": " + $r + " type `" + gr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof br[gr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    throw Ar.name = "Invariant Violation", Ar;
                  }
                  _r = br[gr](Er, gr, yr, $r, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (wr) {
                  _r = wr;
                }
                !_r || _r instanceof Error || (Ht(kr), lt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", yr || "React class", $r, gr, typeof _r), Ht(null)), _r instanceof Error && !(_r.message in Rt) && (Rt[_r.message] = !0, Ht(kr), lt("Failed %s type: %s", $r, _r.message), Ht(null));
              }
            })(fr, rr.props, "prop", Sr, rr);
          } else dr.PropTypes === void 0 || cr || (cr = !0, lt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", mt(dr) || "Unknown"));
          typeof dr.getDefaultProps != "function" || dr.getDefaultProps.isReactClassApproved || lt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }(Jt), Jt;
    }
    reactJsxRuntime_development.Fragment = W, reactJsxRuntime_development.jsx = function(Dt, Zt, ar) {
      return lr(Dt, Zt, ar, !1);
    }, reactJsxRuntime_development.jsxs = function(Dt, Zt, ar) {
      return lr(Dt, Zt, ar, !0);
    };
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports, i$7 = Object.defineProperty, d$6 = (B, L, K) => L in B ? i$7(B, L, { enumerable: !0, configurable: !0, writable: !0, value: K }) : B[L] = K, r$4 = (B, L, K) => (d$6(B, typeof L != "symbol" ? L + "" : L, K), K);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$6 = (B, L) => {
  s$a.isServer ? useEffect(B, L) : useLayoutEffect(B, L);
};
function s$9(B) {
  let L = useRef(B);
  return l$6(() => {
    L.current = B;
  }, [B]), L;
}
let o$6 = function(B) {
  let L = s$9(B);
  return C__default.useCallback((...K) => L.current(...K), [L]);
};
function t$8(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((L) => setTimeout(() => {
    throw L;
  }));
}
function o$5() {
  let B = [], L = { addEventListener: (K, W, V, J) => (K.addEventListener(W, V, J), L.add(() => K.removeEventListener(W, V, J))), requestAnimationFrame(...K) {
    let W = requestAnimationFrame(...K);
    return L.add(() => cancelAnimationFrame(W));
  }, nextFrame: (...K) => L.requestAnimationFrame(() => L.requestAnimationFrame(...K)), setTimeout(...K) {
    let W = setTimeout(...K);
    return L.add(() => clearTimeout(W));
  }, microTask(...K) {
    let W = { current: !0 };
    return t$8(() => {
      W.current && K[0]();
    }), L.add(() => {
      W.current = !1;
    });
  }, style(K, W, V) {
    let J = K.style.getPropertyValue(W);
    return Object.assign(K.style, { [W]: V }), this.add(() => {
      Object.assign(K.style, { [W]: J });
    });
  }, group(K) {
    let W = o$5();
    return K(W), this.add(() => W.dispose());
  }, add: (K) => (B.push(K), () => {
    let W = B.indexOf(K);
    if (W >= 0) for (let V of B.splice(W, 1)) V();
  }), dispose() {
    for (let K of B.splice(0)) K();
  } };
  return L;
}
function p$4() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
function s$8() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in C$3 && C$3.useSyncExternalStore(() => () => {
  }, () => !1, () => !B);
}
function l$5() {
  let B = s$8(), [L, K] = C$3.useState(s$a.isHandoffComplete);
  return L && s$a.isHandoffComplete === !1 && K(!1), C$3.useEffect(() => {
    L !== !0 && K(!0);
  }, [L]), C$3.useEffect(() => s$a.handoff(), []), !B && L;
}
var o$4;
let I$6 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let B = l$5(), [L, K] = C__default.useState(B ? () => s$a.nextId() : null);
  return l$6(() => {
    L === null && K(s$a.nextId());
  }, [L]), L != null ? "" + L : void 0;
};
function u$7(B, L, ...K) {
  if (B in L) {
    let V = L[B];
    return typeof V == "function" ? V(...K) : V;
  }
  let W = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(L).map((V) => `"${V}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(W, u$7), W;
}
function o$3(B) {
  return s$a.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
let c$6 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var M$2 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B))(M$2 || {}), N$2 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(N$2 || {}), F$3 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(F$3 || {});
function f$7(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(c$6)).sort((L, K) => Math.sign((L.tabIndex || Number.MAX_SAFE_INTEGER) - (K.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(T$2 || {});
function h$6(B, L = 0) {
  var K;
  return B !== ((K = o$3(B)) == null ? void 0 : K.body) && u$7(L, { 0: () => B.matches(c$6), 1() {
    let W = B;
    for (; W !== null; ) {
      if (W.matches(c$6)) return !0;
      W = W.parentElement;
    }
    return !1;
  } });
}
function D$3(B) {
  let L = o$3(B);
  o$5().nextFrame(() => {
    L && !h$6(L.activeElement, 0) && y$4(B);
  });
}
var w$3 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(w$3 || {});
function y$4(B) {
  B == null || B.focus({ preventScroll: !0 });
}
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
let S$5 = ["textarea", "input"].join(",");
function H(B) {
  var L, K;
  return (K = (L = B == null ? void 0 : B.matches) == null ? void 0 : L.call(B, S$5)) != null && K;
}
function I$5(B, L = (K) => K) {
  return B.slice().sort((K, W) => {
    let V = L(K), J = L(W);
    if (V === null || J === null) return 0;
    let re = V.compareDocumentPosition(J);
    return re & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : re & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$3(B, L) {
  return O$2(f$7(), L, { relativeTo: B });
}
function O$2(B, L, { sorted: K = !0, relativeTo: W = null, skipElements: V = [] } = {}) {
  let J = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, re = Array.isArray(B) ? K ? I$5(B) : B : f$7(B);
  V.length > 0 && re.length > 1 && (re = re.filter((ot) => !V.includes(ot))), W = W ?? J.activeElement;
  let ie, ne = (() => {
    if (5 & L) return 1;
    if (10 & L) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), oe = (() => {
    if (1 & L) return 0;
    if (2 & L) return Math.max(0, re.indexOf(W)) - 1;
    if (4 & L) return Math.max(0, re.indexOf(W)) + 1;
    if (8 & L) return re.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ce = 32 & L ? { preventScroll: !0 } : {}, pe = 0, ke = re.length;
  do {
    if (pe >= ke || pe + ke <= 0) return 0;
    let ot = oe + pe;
    if (16 & L) ot = (ot + ke) % ke;
    else {
      if (ot < 0) return 3;
      if (ot >= ke) return 1;
    }
    ie = re[ot], ie == null || ie.focus(ce), pe += ne;
  } while (ie !== J.activeElement);
  return 6 & L && H(ie) && ie.select(), 2;
}
function t$7() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$4() {
  return t$7() || i$6();
}
function d$5(B, L, K) {
  let W = s$9(L);
  useEffect(() => {
    function V(J) {
      W.current(J);
    }
    return document.addEventListener(B, V, K), () => document.removeEventListener(B, V, K);
  }, [B, K]);
}
function s$7(B, L, K) {
  let W = s$9(L);
  useEffect(() => {
    function V(J) {
      W.current(J);
    }
    return window.addEventListener(B, V, K), () => window.removeEventListener(B, V, K);
  }, [B, K]);
}
function y$3(B, L, K = !0) {
  let W = useRef(!1);
  function V(re, ie) {
    if (!W.current || re.defaultPrevented) return;
    let ne = ie(re);
    if (ne === null || !ne.getRootNode().contains(ne) || !ne.isConnected) return;
    let oe = function ce(pe) {
      return typeof pe == "function" ? ce(pe()) : Array.isArray(pe) || pe instanceof Set ? pe : [pe];
    }(B);
    for (let ce of oe) {
      if (ce === null) continue;
      let pe = ce instanceof HTMLElement ? ce : ce.current;
      if (pe != null && pe.contains(ne) || re.composed && re.composedPath().includes(pe)) return;
    }
    return !h$6(ne, T$2.Loose) && ne.tabIndex !== -1 && re.preventDefault(), L(re, ne);
  }
  useEffect(() => {
    requestAnimationFrame(() => {
      W.current = K;
    });
  }, [K]);
  let J = useRef(null);
  d$5("pointerdown", (re) => {
    var ie, ne;
    W.current && (J.current = ((ne = (ie = re.composedPath) == null ? void 0 : ie.call(re)) == null ? void 0 : ne[0]) || re.target);
  }, !0), d$5("mousedown", (re) => {
    var ie, ne;
    W.current && (J.current = ((ne = (ie = re.composedPath) == null ? void 0 : ie.call(re)) == null ? void 0 : ne[0]) || re.target);
  }, !0), d$5("click", (re) => {
    n$4() || J.current && (V(re, () => J.current), J.current = null);
  }, !0), d$5("touchend", (re) => V(re, () => re.target instanceof HTMLElement ? re.target : null), !0), s$7("blur", (re) => V(re, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$3(...B) {
  return useMemo(() => o$3(...B), [...B]);
}
function i$5(B) {
  var L;
  if (B.type) return B.type;
  let K = (L = B.as) != null ? L : "button";
  return typeof K == "string" && K.toLowerCase() === "button" ? "button" : void 0;
}
function T$1(B, L) {
  let [K, W] = useState(() => i$5(B));
  return l$6(() => {
    W(i$5(B));
  }, [B.type, B.as]), l$6(() => {
    K || L.current && L.current instanceof HTMLButtonElement && !L.current.hasAttribute("type") && W("button");
  }, [K, L]), K;
}
let u$6 = Symbol();
function T(B, L = !0) {
  return Object.assign(B, { [u$6]: L });
}
function y$2(...B) {
  let L = useRef(B);
  useEffect(() => {
    L.current = B;
  }, [B]);
  let K = o$6((W) => {
    for (let V of L.current) V != null && (typeof V == "function" ? V(W) : V.current = W);
  });
  return B.every((W) => W == null || (W == null ? void 0 : W[u$6])) ? void 0 : K;
}
function t$6(B) {
  return [B.screenX, B.screenY];
}
function u$5() {
  let B = useRef([-1, -1]);
  return { wasMoved(L) {
    let K = t$6(L);
    return (B.current[0] !== K[0] || B.current[1] !== K[1]) && (B.current = K, !0);
  }, update(L) {
    B.current = t$6(L);
  } };
}
function F$2({ container: B, accept: L, walk: K, enabled: W = !0 }) {
  let V = useRef(L), J = useRef(K);
  useEffect(() => {
    V.current = L, J.current = K;
  }, [L, K]), l$6(() => {
    if (!B || !W) return;
    let re = o$3(B);
    if (!re) return;
    let ie = V.current, ne = J.current, oe = Object.assign((pe) => ie(pe), { acceptNode: ie }), ce = re.createTreeWalker(B, NodeFilter.SHOW_ELEMENT, oe, !1);
    for (; ce.nextNode(); ) ne(ce.currentNode);
  }, [B, W, V, J]);
}
function m$3(B, L) {
  let K = useRef([]), W = o$6(B);
  useEffect(() => {
    let V = [...K.current];
    for (let [J, re] of L.entries()) if (K.current[J] !== re) {
      let ie = W(L, V);
      return K.current = L, ie;
    }
  }, [W, ...L]);
}
function t$5(...B) {
  return Array.from(new Set(B.flatMap((L) => typeof L == "string" ? L.split(" ") : []))).filter(Boolean).join(" ");
}
var O$1 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$1 || {}), v$2 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(v$2 || {});
function C$2({ ourProps: B, theirProps: L, slot: K, defaultTag: W, features: V, visible: J = !0, name: re, mergeRefs: ie }) {
  ie = ie ?? k$1;
  let ne = R(L, B);
  if (J) return m$2(ne, K, W, re, ie);
  let oe = V ?? 0;
  if (2 & oe) {
    let { static: ce = !1, ...pe } = ne;
    if (ce) return m$2(pe, K, W, re, ie);
  }
  if (1 & oe) {
    let { unmount: ce = !0, ...pe } = ne;
    return u$7(ce ? 0 : 1, { 0: () => null, 1: () => m$2({ ...pe, hidden: !0, style: { display: "none" } }, K, W, re, ie) });
  }
  return m$2(ne, K, W, re, ie);
}
function m$2(B, L = {}, K, W, V) {
  let { as: J = K, children: re, refName: ie = "ref", ...ne } = F$1(B, ["unmount", "static"]), oe = B.ref !== void 0 ? { [ie]: B.ref } : {}, ce = typeof re == "function" ? re(L) : re;
  "className" in ne && ne.className && typeof ne.className == "function" && (ne.className = ne.className(L));
  let pe = {};
  if (L) {
    let ke = !1, ot = [];
    for (let [at, ft] of Object.entries(L)) typeof ft == "boolean" && (ke = !0), ft === !0 && ot.push(at);
    ke && (pe["data-headlessui-state"] = ot.join(" "));
  }
  if (J === Fragment && Object.keys(x$2(ne)).length > 0) {
    if (!isValidElement(ce) || Array.isArray(ce) && ce.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${W} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(ne).map((ft) => `  - ${ft}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((ft) => `  - ${ft}`).join(`
`)].join(`
`));
    let ke = ce.props, ot = typeof (ke == null ? void 0 : ke.className) == "function" ? (...ft) => t$5(ke == null ? void 0 : ke.className(...ft), ne.className) : t$5(ke == null ? void 0 : ke.className, ne.className), at = ot ? { className: ot } : {};
    return cloneElement(ce, Object.assign({}, R(ce.props, x$2(F$1(ne, ["ref"]))), pe, oe, { ref: V(ce.ref, oe.ref) }, at));
  }
  return createElement(J, Object.assign({}, F$1(ne, ["ref"]), J !== Fragment && oe, J !== Fragment && pe), ce);
}
function k$1(...B) {
  return B.every((L) => L == null) ? void 0 : (L) => {
    for (let K of B) K != null && (typeof K == "function" ? K(L) : K.current = L);
  };
}
function R(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let L = {}, K = {};
  for (let W of B) for (let V in W) V.startsWith("on") && typeof W[V] == "function" ? (K[V] != null || (K[V] = []), K[V].push(W[V])) : L[V] = W[V];
  if (L.disabled || L["aria-disabled"]) return Object.assign(L, Object.fromEntries(Object.keys(K).map((W) => [W, void 0])));
  for (let W in K) Object.assign(L, { [W](V, ...J) {
    let re = K[W];
    for (let ie of re) {
      if ((V instanceof Event || (V == null ? void 0 : V.nativeEvent) instanceof Event) && V.defaultPrevented) return;
      ie(V, ...J);
    }
  } });
  return L;
}
function U$3(B) {
  var L;
  return Object.assign(forwardRef(B), { displayName: (L = B.displayName) != null ? L : B.name });
}
function x$2(B) {
  let L = Object.assign({}, B);
  for (let K in L) L[K] === void 0 && delete L[K];
  return L;
}
function F$1(B, L = []) {
  let K = Object.assign({}, B);
  for (let W of L) W in K && delete K[W];
  return K;
}
let p$3 = "div";
var s$6 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$6 || {});
function l$4(B, L) {
  var K;
  let { features: W = 1, ...V } = B;
  return C$2({ ourProps: { ref: L, "aria-hidden": !(2 & ~W) || ((K = V["aria-hidden"]) != null ? K : void 0), hidden: !(4 & ~W) || void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...!(4 & ~W) && !!(2 & ~W) && { display: "none" } } }, theirProps: V, slot: {}, defaultTag: p$3, name: "Hidden" });
}
let u$4 = U$3(l$4), n$2 = createContext(null);
n$2.displayName = "OpenClosedContext";
var d$4 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(d$4 || {});
function u$3() {
  return useContext(n$2);
}
function s$5({ value: B, children: L }) {
  return C__default.createElement(n$2.Provider, { value: B }, L);
}
function t$4(B) {
  function L() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", L));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", L), L());
}
let t$3 = [];
function r$3(B) {
  let L = B.parentElement, K = null;
  for (; L && !(L instanceof HTMLFieldSetElement); ) L instanceof HTMLLegendElement && (K = L), L = L.parentElement;
  let W = (L == null ? void 0 : L.getAttribute("disabled")) === "";
  return (!W || !i$4(K)) && W;
}
function i$4(B) {
  if (!B) return !1;
  let L = B.previousElementSibling;
  for (; L !== null; ) {
    if (L instanceof HTMLLegendElement) return !1;
    L = L.previousElementSibling;
  }
  return !0;
}
function u$2(B) {
  throw new Error("Unexpected object: " + B);
}
t$4(() => {
  function B(L) {
    L.target instanceof HTMLElement && L.target !== document.body && t$3[0] !== L.target && (t$3.unshift(L.target), t$3 = t$3.filter((K) => K != null && K.isConnected), t$3.splice(10));
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
var c$5 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$5 || {});
function f$6(B, L) {
  let K = L.resolveItems();
  if (K.length <= 0) return null;
  let W = L.resolveActiveIndex(), V = W ?? -1;
  switch (B.focus) {
    case 0:
      for (let J = 0; J < K.length; ++J) if (!L.resolveDisabled(K[J], J, K)) return J;
      return W;
    case 1:
      for (let J = V - 1; J >= 0; --J) if (!L.resolveDisabled(K[J], J, K)) return J;
      return W;
    case 2:
      for (let J = V + 1; J < K.length; ++J) if (!L.resolveDisabled(K[J], J, K)) return J;
      return W;
    case 3:
      for (let J = K.length - 1; J >= 0; --J) if (!L.resolveDisabled(K[J], J, K)) return J;
      return W;
    case 4:
      for (let J = 0; J < K.length; ++J) if (L.resolveId(K[J], J, K) === B.id) return J;
      return W;
    case 5:
      return null;
    default:
      u$2(B);
  }
}
var o$2 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$2 || {});
function E$1(B, L, K, W) {
  let V = s$9(K);
  useEffect(() => {
    function J(re) {
      V.current(re);
    }
    return (B = B ?? window).addEventListener(L, J, W), () => B.removeEventListener(L, J, W);
  }, [B, L, W]);
}
function f$5() {
  let B = useRef(!1);
  return l$6(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
function c$4(B) {
  let L = o$6(B), K = useRef(!1);
  useEffect(() => (K.current = !1, () => {
    K.current = !0, t$8(() => {
      K.current && L();
    });
  }), [L]);
}
var s$4 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(s$4 || {});
function n$1() {
  let B = useRef(0);
  return s$7("keydown", (L) => {
    L.key === "Tab" && (B.current = L.shiftKey ? 1 : 0);
  }, !0), B;
}
function P(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let L = /* @__PURE__ */ new Set();
  for (let K of B.current) K.current instanceof HTMLElement && L.add(K.current);
  return L;
}
let X = "div";
var _$2 = ((B) => (B[B.None = 1] = "None", B[B.InitialFocus = 2] = "InitialFocus", B[B.TabLock = 4] = "TabLock", B[B.FocusLock = 8] = "FocusLock", B[B.RestoreFocus = 16] = "RestoreFocus", B[B.All = 30] = "All", B))(_$2 || {});
function z$1(B, L) {
  let K = useRef(null), W = y$2(K, L), { initialFocus: V, containers: J, features: re = 30, ...ie } = B;
  l$5() || (re = 1);
  let ne = n$3(K);
  Y({ ownerDocument: ne }, !!(16 & re));
  let oe = Z({ ownerDocument: ne, container: K, initialFocus: V }, !!(2 & re));
  $({ ownerDocument: ne, container: K, containers: J, previousActiveElement: oe }, !!(8 & re));
  let ce = n$1(), pe = o$6((ft) => {
    let dt = K.current;
    dt && u$7(ce.current, { [s$4.Forwards]: () => {
      O$2(dt, M$2.First, { skipElements: [ft.relatedTarget] });
    }, [s$4.Backwards]: () => {
      O$2(dt, M$2.Last, { skipElements: [ft.relatedTarget] });
    } });
  }), ke = p$4(), ot = useRef(!1), at = { ref: W, onKeyDown(ft) {
    ft.key == "Tab" && (ot.current = !0, ke.requestAnimationFrame(() => {
      ot.current = !1;
    }));
  }, onBlur(ft) {
    let dt = P(J);
    K.current instanceof HTMLElement && dt.add(K.current);
    let lt = ft.relatedTarget;
    lt instanceof HTMLElement && lt.dataset.headlessuiFocusGuard !== "true" && (S$4(dt, lt) || (ot.current ? O$2(K.current, u$7(ce.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: ft.target }) : ft.target instanceof HTMLElement && y$4(ft.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(4 & re) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: pe, features: s$6.Focusable }), C$2({ ourProps: at, theirProps: ie, defaultTag: X, name: "FocusTrap" }), !!(4 & re) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: pe, features: s$6.Focusable }));
}
let D$2 = U$3(z$1), de$1 = Object.assign(D$2, { features: _$2 });
function Q(B = !0) {
  let L = useRef(t$3.slice());
  return m$3(([K], [W]) => {
    W === !0 && K === !1 && t$8(() => {
      L.current.splice(0);
    }), W === !1 && K === !0 && (L.current = t$3.slice());
  }, [B, t$3, L]), o$6(() => {
    var K;
    return (K = L.current.find((W) => W != null && W.isConnected)) != null ? K : null;
  });
}
function Y({ ownerDocument: B }, L) {
  let K = Q(L);
  m$3(() => {
    L || (B == null ? void 0 : B.activeElement) === (B == null ? void 0 : B.body) && y$4(K());
  }, [L]), c$4(() => {
    L && y$4(K());
  });
}
function Z({ ownerDocument: B, container: L, initialFocus: K }, W) {
  let V = useRef(null), J = f$5();
  return m$3(() => {
    if (!W) return;
    let re = L.current;
    re && t$8(() => {
      if (!J.current) return;
      let ie = B == null ? void 0 : B.activeElement;
      if (K != null && K.current) {
        if ((K == null ? void 0 : K.current) === ie) return void (V.current = ie);
      } else if (re.contains(ie)) return void (V.current = ie);
      K != null && K.current ? y$4(K.current) : (O$2(re, M$2.First), N$2.Error), V.current = B == null ? void 0 : B.activeElement;
    });
  }, [W]), V;
}
function $({ ownerDocument: B, container: L, containers: K, previousActiveElement: W }, V) {
  let J = f$5();
  E$1(B == null ? void 0 : B.defaultView, "focus", (re) => {
    if (!V || !J.current) return;
    let ie = P(K);
    L.current instanceof HTMLElement && ie.add(L.current);
    let ne = W.current;
    if (!ne) return;
    let oe = re.target;
    oe && oe instanceof HTMLElement ? S$4(ie, oe) ? (W.current = oe, y$4(oe)) : (re.preventDefault(), re.stopPropagation(), y$4(ne)) : y$4(W.current);
  }, !0);
}
function S$4(B, L) {
  for (let K of B) if (K.contains(L)) return !0;
  return !1;
}
let e$1 = createContext(!1);
function a$6() {
  return useContext(e$1);
}
function l$3(B) {
  return C__default.createElement(e$1.Provider, { value: B.force }, B.children);
}
function F(B) {
  let L = a$6(), K = useContext(_$1), W = n$3(B), [V, J] = useState(() => {
    if (!L && K !== null || s$a.isServer) return null;
    let re = W == null ? void 0 : W.getElementById("headlessui-portal-root");
    if (re) return re;
    if (W === null) return null;
    let ie = W.createElement("div");
    return ie.setAttribute("id", "headlessui-portal-root"), W.body.appendChild(ie);
  });
  return useEffect(() => {
    V !== null && (W != null && W.body.contains(V) || W == null || W.body.appendChild(V));
  }, [V, W]), useEffect(() => {
    L || K !== null && J(K.current);
  }, [K, J, L]), V;
}
let U$2 = Fragment;
function N$1(B, L) {
  let K = B, W = useRef(null), V = y$2(T((ce) => {
    W.current = ce;
  }), L), J = n$3(W), re = F(W), [ie] = useState(() => {
    var ce;
    return s$a.isServer ? null : (ce = J == null ? void 0 : J.createElement("div")) != null ? ce : null;
  }), ne = useContext(f$4), oe = l$5();
  return l$6(() => {
    !re || !ie || re.contains(ie) || (ie.setAttribute("data-headlessui-portal", ""), re.appendChild(ie));
  }, [re, ie]), l$6(() => {
    if (ie && ne) return ne.register(ie);
  }, [ne, ie]), c$4(() => {
    var ce;
    !re || !ie || (ie instanceof Node && re.contains(ie) && re.removeChild(ie), re.childNodes.length <= 0 && ((ce = re.parentElement) == null || ce.removeChild(re)));
  }), oe && re && ie ? createPortal(C$2({ ourProps: { ref: V }, theirProps: K, defaultTag: U$2, name: "Portal" }), ie) : null;
}
let S$3 = Fragment, _$1 = createContext(null);
function j(B, L) {
  let { target: K, ...W } = B, V = { ref: y$2(L) };
  return C__default.createElement(_$1.Provider, { value: K }, C$2({ ourProps: V, theirProps: W, defaultTag: S$3, name: "Popover.Group" }));
}
let f$4 = createContext(null);
function ee() {
  let B = useContext(f$4), L = useRef([]), K = o$6((J) => (L.current.push(J), B && B.register(J), () => W(J))), W = o$6((J) => {
    let re = L.current.indexOf(J);
    re !== -1 && L.current.splice(re, 1), B && B.unregister(J);
  }), V = useMemo(() => ({ register: K, unregister: W, portals: L }), [K, W, L]);
  return [L, useMemo(() => function({ children: J }) {
    return C__default.createElement(f$4.Provider, { value: V }, J);
  }, [V])];
}
let D$1 = U$3(N$1), I$4 = U$3(j), te = Object.assign(D$1, { Group: I$4 });
function i$3(B, L) {
  return B === L && (B !== 0 || 1 / B == 1 / L) || B != B && L != L;
}
const d$3 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$5, useLayoutEffect: f$3, useDebugValue: p$2 } = C$3;
function y$1(B, L, K) {
  const W = L(), [{ inst: V }, J] = u$1({ inst: { value: W, getSnapshot: L } });
  return f$3(() => {
    V.value = W, V.getSnapshot = L, r$2(V) && J({ inst: V });
  }, [B, W, L]), h$5(() => (r$2(V) && J({ inst: V }), B(() => {
    r$2(V) && J({ inst: V });
  })), [B]), p$2(W), W;
}
function r$2(B) {
  const L = B.getSnapshot, K = B.value;
  try {
    const W = L();
    return !d$3(K, W);
  } catch {
    return !0;
  }
}
function t$2(B, L, K) {
  return L();
}
const r$1 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, s$3 = !r$1, c$3 = s$3 ? t$2 : y$1, a$5 = "useSyncExternalStore" in C$3 ? C$3.useSyncExternalStore : c$3;
function S$2(B) {
  return a$5(B.subscribe, B.getSnapshot, B.getSnapshot);
}
function a$4(B, L) {
  let K = B(), W = /* @__PURE__ */ new Set();
  return { getSnapshot: () => K, subscribe: (V) => (W.add(V), () => W.delete(V)), dispatch(V, ...J) {
    let re = L[V].call(K, ...J);
    re && (K = re, W.forEach((ie) => ie()));
  } };
}
function c$2() {
  let B;
  return { before({ doc: L }) {
    var K;
    let W = L.documentElement;
    B = ((K = L.defaultView) != null ? K : window).innerWidth - W.clientWidth;
  }, after({ doc: L, d: K }) {
    let W = L.documentElement, V = W.clientWidth - W.offsetWidth, J = B - V;
    K.style(W, "paddingRight", `${J}px`);
  } };
}
function d$2() {
  return t$7() ? { before({ doc: B, d: L, meta: K }) {
    function W(V) {
      return K.containers.flatMap((J) => J()).some((J) => J.contains(V));
    }
    L.microTask(() => {
      var V;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let ie = o$5();
        ie.style(B.documentElement, "scrollBehavior", "auto"), L.add(() => L.microTask(() => ie.dispose()));
      }
      let J = (V = window.scrollY) != null ? V : window.pageYOffset, re = null;
      L.addEventListener(B, "click", (ie) => {
        if (ie.target instanceof HTMLElement) try {
          let ne = ie.target.closest("a");
          if (!ne) return;
          let { hash: oe } = new URL(ne.href), ce = B.querySelector(oe);
          ce && !W(ce) && (re = ce);
        } catch {
        }
      }, !0), L.addEventListener(B, "touchstart", (ie) => {
        if (ie.target instanceof HTMLElement) if (W(ie.target)) {
          let ne = ie.target;
          for (; ne.parentElement && W(ne.parentElement); ) ne = ne.parentElement;
          L.style(ne, "overscrollBehavior", "contain");
        } else L.style(ie.target, "touchAction", "none");
      }), L.addEventListener(B, "touchmove", (ie) => {
        if (ie.target instanceof HTMLElement) if (W(ie.target)) {
          let ne = ie.target;
          for (; ne.parentElement && ne.dataset.headlessuiPortal !== "" && !(ne.scrollHeight > ne.clientHeight || ne.scrollWidth > ne.clientWidth); ) ne = ne.parentElement;
          ne.dataset.headlessuiPortal === "" && ie.preventDefault();
        } else ie.preventDefault();
      }, { passive: !1 }), L.add(() => {
        var ie;
        let ne = (ie = window.scrollY) != null ? ie : window.pageYOffset;
        J !== ne && window.scrollTo(0, J), re && re.isConnected && (re.scrollIntoView({ block: "nearest" }), re = null);
      });
    });
  } } : {};
}
function l$2() {
  return { before({ doc: B, d: L }) {
    L.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let L = {};
  for (let K of B) Object.assign(L, K(L));
  return L;
}
let a$3 = a$4(() => /* @__PURE__ */ new Map(), { PUSH(B, L) {
  var K;
  let W = (K = this.get(B)) != null ? K : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return W.count++, W.meta.add(L), this.set(B, W), this;
}, POP(B, L) {
  let K = this.get(B);
  return K && (K.count--, K.meta.delete(L)), this;
}, SCROLL_PREVENT({ doc: B, d: L, meta: K }) {
  let W = { doc: B, d: L, meta: m$1(K) }, V = [d$2(), c$2(), l$2()];
  V.forEach(({ before: J }) => J == null ? void 0 : J(W)), V.forEach(({ after: J }) => J == null ? void 0 : J(W));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
function p$1(B, L, K) {
  let W = S$2(a$3), V = B ? W.get(B) : void 0, J = !!V && V.count > 0;
  return l$6(() => {
    if (B && L) return a$3.dispatch("PUSH", B, K), () => a$3.dispatch("POP", B, K);
  }, [L, B]), J;
}
a$3.subscribe(() => {
  let B = a$3.getSnapshot(), L = /* @__PURE__ */ new Map();
  for (let [K] of B) L.set(K, K.documentElement.style.overflow);
  for (let K of B.values()) {
    let W = L.get(K.doc) === "hidden", V = K.count !== 0;
    (V && !W || !V && W) && a$3.dispatch(K.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", K), K.count === 0 && a$3.dispatch("TEARDOWN", K);
  }
});
let u = /* @__PURE__ */ new Map(), t$1 = /* @__PURE__ */ new Map();
function b$4(B, L = !0) {
  l$6(() => {
    var K;
    if (!L) return;
    let W = typeof B == "function" ? B() : B.current;
    if (!W) return;
    let V = (K = t$1.get(W)) != null ? K : 0;
    return t$1.set(W, V + 1), V !== 0 || (u.set(W, { "aria-hidden": W.getAttribute("aria-hidden"), inert: W.inert }), W.setAttribute("aria-hidden", "true"), W.inert = !0), function() {
      var J;
      if (!W) return;
      let re = (J = t$1.get(W)) != null ? J : 1;
      if (re === 1 ? t$1.delete(W) : t$1.set(W, re - 1), re !== 1) return;
      let ie = u.get(W);
      ie && (ie["aria-hidden"] === null ? W.removeAttribute("aria-hidden") : W.setAttribute("aria-hidden", ie["aria-hidden"]), W.inert = ie.inert, u.delete(W));
    };
  }, [B, L]);
}
function N({ defaultContainers: B = [], portals: L, mainTreeNodeRef: K } = {}) {
  var W;
  let V = useRef((W = K == null ? void 0 : K.current) != null ? W : null), J = n$3(V), re = o$6(() => {
    var ie, ne, oe;
    let ce = [];
    for (let pe of B) pe !== null && (pe instanceof HTMLElement ? ce.push(pe) : "current" in pe && pe.current instanceof HTMLElement && ce.push(pe.current));
    if (L != null && L.current) for (let pe of L.current) ce.push(pe);
    for (let pe of (ie = J == null ? void 0 : J.querySelectorAll("html > *, body > *")) != null ? ie : []) pe !== document.body && pe !== document.head && pe instanceof HTMLElement && pe.id !== "headlessui-portal-root" && (pe.contains(V.current) || pe.contains((oe = (ne = V.current) == null ? void 0 : ne.getRootNode()) == null ? void 0 : oe.host) || ce.some((ke) => pe.contains(ke)) || ce.push(pe));
    return ce;
  });
  return { resolveContainers: re, contains: o$6((ie) => re().some((ne) => ne.contains(ie))), mainTreeNodeRef: V, MainTreeNode: useMemo(() => function() {
    return K != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: V });
  }, [V, K]) };
}
let a$2 = createContext(() => {
});
a$2.displayName = "StackContext";
var s$2 = ((B) => (B[B.Add = 0] = "Add", B[B.Remove = 1] = "Remove", B))(s$2 || {});
function x$1() {
  return useContext(a$2);
}
function b$3({ children: B, onUpdate: L, type: K, element: W, enabled: V }) {
  let J = x$1(), re = o$6((...ie) => {
    L == null || L(...ie), J(...ie);
  });
  return l$6(() => {
    let ie = V === void 0 || V === !0;
    return ie && re(0, K, W), () => {
      ie && re(1, K, W);
    };
  }, [re, K, W, V]), C__default.createElement(a$2.Provider, { value: re }, B);
}
let d$1 = createContext(null);
function f$2() {
  let B = useContext(d$1);
  if (B === null) {
    let L = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(L, f$2), L;
  }
  return B;
}
function w$2() {
  let [B, L] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(K) {
    let W = o$6((J) => (L((re) => [...re, J]), () => L((re) => {
      let ie = re.slice(), ne = ie.indexOf(J);
      return ne !== -1 && ie.splice(ne, 1), ie;
    }))), V = useMemo(() => ({ register: W, slot: K.slot, name: K.name, props: K.props }), [W, K.slot, K.name, K.props]);
    return C__default.createElement(d$1.Provider, { value: V }, K.children);
  }, [L])];
}
let I$3 = "p";
function S$1(B, L) {
  let K = I$6(), { id: W = `headlessui-description-${K}`, ...V } = B, J = f$2(), re = y$2(L);
  return l$6(() => J.register(W), [W, J.register]), C$2({ ourProps: { ref: re, ...J.props, id: W }, theirProps: V, slot: J.slot || {}, defaultTag: I$3, name: J.name || "Description" });
}
let h$4 = U$3(S$1), G = Object.assign(h$4, {});
var Me$1 = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Me$1 || {}), we = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(we || {});
let He$1 = { 0: (B, L) => B.titleId === L.id ? B : { ...B, titleId: L.id } }, I$2 = createContext(null);
function b$2(B) {
  let L = useContext(I$2);
  if (L === null) {
    let K = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(K, b$2), K;
  }
  return L;
}
function Be(B, L, K = () => [document.body]) {
  p$1(B, L, (W) => {
    var V;
    return { containers: [...(V = W.containers) != null ? V : [], K] };
  });
}
function Ge(B, L) {
  return u$7(L.type, He$1, B, L);
}
I$2.displayName = "DialogContext";
let Ne$1 = "div", Ue = O$1.RenderStrategy | O$1.Static;
function We(B, L) {
  let K = I$6(), { id: W = `headlessui-dialog-${K}`, open: V, onClose: J, initialFocus: re, role: ie = "dialog", __demoMode: ne = !1, ...oe } = B, [ce, pe] = useState(0), ke = useRef(!1);
  ie = ie === "dialog" || ie === "alertdialog" ? ie : (ke.current || (ke.current = !0), "dialog");
  let ot = u$3();
  V === void 0 && ot !== null && (V = (ot & d$4.Open) === d$4.Open);
  let at = useRef(null), ft = y$2(at, L), dt = n$3(at), lt = B.hasOwnProperty("open") || ot !== null, yt = B.hasOwnProperty("onClose");
  if (!lt && !yt) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!lt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!yt) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof V != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${V}`);
  if (typeof J != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${J}`);
  let St = V ? 0 : 1, [mt, $t] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), It = o$6(() => J(!1)), Ut = o$6((Wt) => $t({ type: 0, id: Wt })), ut = !!l$5() && !ne && St === 0, ht = ce > 1, Ce = useContext(I$2) !== null, [nt, rt] = ee(), it = { get current() {
    var Wt;
    return (Wt = mt.panelRef.current) != null ? Wt : at.current;
  } }, { resolveContainers: st, mainTreeNodeRef: Oe, MainTreeNode: ct } = N({ portals: nt, defaultContainers: [it] }), pt = ht ? "parent" : "leaf", gt = ot !== null && (ot & d$4.Closing) === d$4.Closing, vt = !Ce && !gt && ut, Bt = useCallback(() => {
    var Wt, Yt;
    return (Yt = Array.from((Wt = dt == null ? void 0 : dt.querySelectorAll("body > *")) != null ? Wt : []).find((Xt) => Xt.id !== "headlessui-portal-root" && Xt.contains(Oe.current) && Xt instanceof HTMLElement)) != null ? Yt : null;
  }, [Oe]);
  b$4(Bt, vt);
  let kt = !!ht || ut, wt = useCallback(() => {
    var Wt, Yt;
    return (Yt = Array.from((Wt = dt == null ? void 0 : dt.querySelectorAll("[data-headlessui-portal]")) != null ? Wt : []).find((Xt) => Xt.contains(Oe.current) && Xt instanceof HTMLElement)) != null ? Yt : null;
  }, [Oe]);
  b$4(wt, kt), y$3(st, (Wt) => {
    Wt.preventDefault(), It();
  }, !(!ut || ht));
  let Et = !(ht || St !== 0);
  E$1(dt == null ? void 0 : dt.defaultView, "keydown", (Wt) => {
    Et && (Wt.defaultPrevented || Wt.key === o$2.Escape && (Wt.preventDefault(), Wt.stopPropagation(), It()));
  }), Be(dt, !(gt || St !== 0 || Ce), st), useEffect(() => {
    if (St !== 0 || !at.current) return;
    let Wt = new ResizeObserver((Yt) => {
      for (let Xt of Yt) {
        let ir = Xt.target.getBoundingClientRect();
        ir.x === 0 && ir.y === 0 && ir.width === 0 && ir.height === 0 && It();
      }
    });
    return Wt.observe(at.current), () => Wt.disconnect();
  }, [St, at, It]);
  let [Rt, Mt] = w$2(), Ht = useMemo(() => [{ dialogState: St, close: It, setTitleId: Ut }, mt], [St, mt, It, Ut]), Kt = useMemo(() => ({ open: St === 0 }), [St]), jt = { ref: ft, id: W, role: ie, "aria-modal": St === 0 || void 0, "aria-labelledby": mt.titleId, "aria-describedby": Rt };
  return C__default.createElement(b$3, { type: "Dialog", enabled: St === 0, element: at, onUpdate: o$6((Wt, Yt) => {
    Yt === "Dialog" && u$7(Wt, { [s$2.Add]: () => pe((Xt) => Xt + 1), [s$2.Remove]: () => pe((Xt) => Xt - 1) });
  }) }, C__default.createElement(l$3, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$2.Provider, { value: Ht }, C__default.createElement(te.Group, { target: at }, C__default.createElement(l$3, { force: !1 }, C__default.createElement(Mt, { slot: Kt, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: re, containers: st, features: ut ? u$7(pt, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(rt, null, C$2({ ourProps: jt, theirProps: oe, slot: Kt, defaultTag: Ne$1, features: Ue, visible: St === 0, name: "Dialog" }))))))))), C__default.createElement(ct, null));
}
let $e = "div";
function Ye(B, L) {
  let K = I$6(), { id: W = `headlessui-dialog-overlay-${K}`, ...V } = B, [{ dialogState: J, close: re }] = b$2("Dialog.Overlay"), ie = y$2(L), ne = o$6((oe) => {
    if (oe.target === oe.currentTarget) {
      if (r$3(oe.currentTarget)) return oe.preventDefault();
      oe.preventDefault(), oe.stopPropagation(), re();
    }
  });
  return C$2({ ourProps: { ref: ie, id: W, "aria-hidden": !0, onClick: ne }, theirProps: V, slot: useMemo(() => ({ open: J === 0 }), [J]), defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(B, L) {
  let K = I$6(), { id: W = `headlessui-dialog-backdrop-${K}`, ...V } = B, [{ dialogState: J }, re] = b$2("Dialog.Backdrop"), ie = y$2(L);
  useEffect(() => {
    if (re.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [re.panelRef]);
  let ne = useMemo(() => ({ open: J === 0 }), [J]);
  return C__default.createElement(l$3, { force: !0 }, C__default.createElement(te, null, C$2({ ourProps: { ref: ie, id: W, "aria-hidden": !0 }, theirProps: V, slot: ne, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(B, L) {
  let K = I$6(), { id: W = `headlessui-dialog-panel-${K}`, ...V } = B, [{ dialogState: J }, re] = b$2("Dialog.Panel"), ie = y$2(L, re.panelRef), ne = useMemo(() => ({ open: J === 0 }), [J]), oe = o$6((ce) => {
    ce.stopPropagation();
  });
  return C$2({ ourProps: { ref: ie, id: W, onClick: oe }, theirProps: V, slot: ne, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(B, L) {
  let K = I$6(), { id: W = `headlessui-dialog-title-${K}`, ...V } = B, [{ dialogState: J, setTitleId: re }] = b$2("Dialog.Title"), ie = y$2(L);
  useEffect(() => (re(W), () => re(null)), [W, re]);
  let ne = useMemo(() => ({ open: J === 0 }), [J]);
  return C$2({ ourProps: { ref: ie, id: W }, theirProps: V, slot: ne, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a$1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var L, K;
  let W = (L = B.innerText) != null ? L : "", V = B.cloneNode(!0);
  if (!(V instanceof HTMLElement)) return W;
  let J = !1;
  for (let ie of V.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ie.remove(), J = !0;
  let re = J ? (K = V.innerText) != null ? K : "" : W;
  return a$1.test(re) && (re = re.replace(a$1, "")), re;
}
function g$2(B) {
  let L = B.getAttribute("aria-label");
  if (typeof L == "string") return L.trim();
  let K = B.getAttribute("aria-labelledby");
  if (K) {
    let W = K.split(" ").map((V) => {
      let J = document.getElementById(V);
      if (J) {
        let re = J.getAttribute("aria-label");
        return typeof re == "string" ? re.trim() : o$1(J).trim();
      }
      return null;
    }).filter(Boolean);
    if (W.length > 0) return W.join(", ");
  }
  return o$1(B).trim();
}
function s$1(B) {
  let L = useRef(""), K = useRef("");
  return o$6(() => {
    let W = B.current;
    if (!W) return "";
    let V = W.innerText;
    if (L.current === V) return K.current;
    let J = g$2(W).trim().toLowerCase();
    return L.current = V, K.current = J, J;
  });
}
var me = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(me || {}), de = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(de || {}), fe = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B))(fe || {});
function w$1(B, L = (K) => K) {
  let K = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, W = I$5(L(B.items.slice()), (J) => J.dataRef.current.domRef.current), V = K ? W.indexOf(K) : null;
  return V === -1 && (V = null), { items: W, activeItemIndex: V };
}
let Te = { 1: (B) => B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 }, 0: (B) => B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 }, 2: (B, L) => {
  var K;
  let W = w$1(B), V = f$6(L, { resolveItems: () => W.items, resolveActiveIndex: () => W.activeItemIndex, resolveId: (J) => J.id, resolveDisabled: (J) => J.dataRef.current.disabled });
  return { ...B, ...W, searchQuery: "", activeItemIndex: V, activationTrigger: (K = L.trigger) != null ? K : 1 };
}, 3: (B, L) => {
  let K = B.searchQuery !== "" ? 0 : 1, W = B.searchQuery + L.value.toLowerCase(), V = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + K).concat(B.items.slice(0, B.activeItemIndex + K)) : B.items).find((re) => {
    var ie;
    return ((ie = re.dataRef.current.textValue) == null ? void 0 : ie.startsWith(W)) && !re.dataRef.current.disabled;
  }), J = V ? B.items.indexOf(V) : -1;
  return J === -1 || J === B.activeItemIndex ? { ...B, searchQuery: W } : { ...B, searchQuery: W, activeItemIndex: J, activationTrigger: 1 };
}, 4: (B) => B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null }, 5: (B, L) => {
  let K = w$1(B, (W) => [...W, { id: L.id, dataRef: L.dataRef }]);
  return { ...B, ...K };
}, 6: (B, L) => {
  let K = w$1(B, (W) => {
    let V = W.findIndex((J) => J.id === L.id);
    return V !== -1 && W.splice(V, 1), W;
  });
  return { ...B, ...K, activationTrigger: 1 };
} }, U$1 = createContext(null);
function C$1(B) {
  let L = useContext(U$1);
  if (L === null) {
    let K = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(K, C$1), K;
  }
  return L;
}
function ye$1(B, L) {
  return u$7(L.type, Te, B, L);
}
U$1.displayName = "MenuContext";
let Ie = Fragment;
function Me(B, L) {
  let { __demoMode: K = !1, ...W } = B, V = useReducer(ye$1, { __demoMode: K, menuState: K ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: J, itemsRef: re, buttonRef: ie }, ne] = V, oe = y$2(L);
  y$3([ie, re], (ot, at) => {
    var ft;
    ne({ type: 1 }), h$6(at, T$2.Loose) || (ot.preventDefault(), (ft = ie.current) == null || ft.focus());
  }, J === 0);
  let ce = o$6(() => {
    ne({ type: 1 });
  }), pe = useMemo(() => ({ open: J === 0, close: ce }), [J, ce]), ke = { ref: oe };
  return C__default.createElement(U$1.Provider, { value: V }, C__default.createElement(s$5, { value: u$7(J, { 0: d$4.Open, 1: d$4.Closed }) }, C$2({ ourProps: ke, theirProps: W, slot: pe, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(B, L) {
  var K;
  let W = I$6(), { id: V = `headlessui-menu-button-${W}`, ...J } = B, [re, ie] = C$1("Menu.Button"), ne = y$2(re.buttonRef, L), oe = p$4(), ce = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        at.preventDefault(), at.stopPropagation(), ie({ type: 0 }), oe.nextFrame(() => ie({ type: 2, focus: c$5.First }));
        break;
      case o$2.ArrowUp:
        at.preventDefault(), at.stopPropagation(), ie({ type: 0 }), oe.nextFrame(() => ie({ type: 2, focus: c$5.Last }));
    }
  }), pe = o$6((at) => {
    at.key === o$2.Space && at.preventDefault();
  }), ke = o$6((at) => {
    if (r$3(at.currentTarget)) return at.preventDefault();
    B.disabled || (re.menuState === 0 ? (ie({ type: 1 }), oe.nextFrame(() => {
      var ft;
      return (ft = re.buttonRef.current) == null ? void 0 : ft.focus({ preventScroll: !0 });
    })) : (at.preventDefault(), ie({ type: 0 })));
  }), ot = useMemo(() => ({ open: re.menuState === 0 }), [re]);
  return C$2({ ourProps: { ref: ne, id: V, type: T$1(B, re.buttonRef), "aria-haspopup": "menu", "aria-controls": (K = re.itemsRef.current) == null ? void 0 : K.id, "aria-expanded": re.menuState === 0, onKeyDown: ce, onKeyUp: pe, onClick: ke }, theirProps: J, slot: ot, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O$1.RenderStrategy | O$1.Static;
function Ee(B, L) {
  var K, W;
  let V = I$6(), { id: J = `headlessui-menu-items-${V}`, ...re } = B, [ie, ne] = C$1("Menu.Items"), oe = y$2(ie.itemsRef, L), ce = n$3(ie.itemsRef), pe = p$4(), ke = u$3(), ot = ke !== null ? (ke & d$4.Open) === d$4.Open : ie.menuState === 0;
  useEffect(() => {
    let lt = ie.itemsRef.current;
    lt && ie.menuState === 0 && lt !== (ce == null ? void 0 : ce.activeElement) && lt.focus({ preventScroll: !0 });
  }, [ie.menuState, ie.itemsRef, ce]), F$2({ container: ie.itemsRef.current, enabled: ie.menuState === 0, accept: (lt) => lt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : lt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT, walk(lt) {
    lt.setAttribute("role", "none");
  } });
  let at = o$6((lt) => {
    var yt, St;
    switch (pe.dispose(), lt.key) {
      case o$2.Space:
        if (ie.searchQuery !== "") return lt.preventDefault(), lt.stopPropagation(), ne({ type: 3, value: lt.key });
      case o$2.Enter:
        if (lt.preventDefault(), lt.stopPropagation(), ne({ type: 1 }), ie.activeItemIndex !== null) {
          let { dataRef: mt } = ie.items[ie.activeItemIndex];
          (St = (yt = mt.current) == null ? void 0 : yt.domRef.current) == null || St.click();
        }
        D$3(ie.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return lt.preventDefault(), lt.stopPropagation(), ne({ type: 2, focus: c$5.Next });
      case o$2.ArrowUp:
        return lt.preventDefault(), lt.stopPropagation(), ne({ type: 2, focus: c$5.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return lt.preventDefault(), lt.stopPropagation(), ne({ type: 2, focus: c$5.First });
      case o$2.End:
      case o$2.PageDown:
        return lt.preventDefault(), lt.stopPropagation(), ne({ type: 2, focus: c$5.Last });
      case o$2.Escape:
        lt.preventDefault(), lt.stopPropagation(), ne({ type: 1 }), o$5().nextFrame(() => {
          var mt;
          return (mt = ie.buttonRef.current) == null ? void 0 : mt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        lt.preventDefault(), lt.stopPropagation(), ne({ type: 1 }), o$5().nextFrame(() => {
          _$3(ie.buttonRef.current, lt.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        lt.key.length === 1 && (ne({ type: 3, value: lt.key }), pe.setTimeout(() => ne({ type: 4 }), 350));
    }
  }), ft = o$6((lt) => {
    lt.key === o$2.Space && lt.preventDefault();
  }), dt = useMemo(() => ({ open: ie.menuState === 0 }), [ie]);
  return C$2({ ourProps: { "aria-activedescendant": ie.activeItemIndex === null || (K = ie.items[ie.activeItemIndex]) == null ? void 0 : K.id, "aria-labelledby": (W = ie.buttonRef.current) == null ? void 0 : W.id, id: J, onKeyDown: at, onKeyUp: ft, role: "menu", tabIndex: 0, ref: oe }, theirProps: re, slot: dt, defaultTag: Ae, features: be, visible: ot, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(B, L) {
  let K = I$6(), { id: W = `headlessui-menu-item-${K}`, disabled: V = !1, ...J } = B, [re, ie] = C$1("Menu.Item"), ne = re.activeItemIndex !== null && re.items[re.activeItemIndex].id === W, oe = useRef(null), ce = y$2(L, oe);
  l$6(() => {
    if (re.__demoMode || re.menuState !== 0 || !ne || re.activationTrigger === 0) return;
    let $t = o$5();
    return $t.requestAnimationFrame(() => {
      var It, Ut;
      (Ut = (It = oe.current) == null ? void 0 : It.scrollIntoView) == null || Ut.call(It, { block: "nearest" });
    }), $t.dispose;
  }, [re.__demoMode, oe, ne, re.menuState, re.activationTrigger, re.activeItemIndex]);
  let pe = s$1(oe), ke = useRef({ disabled: V, domRef: oe, get textValue() {
    return pe();
  } });
  l$6(() => {
    ke.current.disabled = V;
  }, [ke, V]), l$6(() => (ie({ type: 5, id: W, dataRef: ke }), () => ie({ type: 6, id: W })), [ke, W]);
  let ot = o$6(() => {
    ie({ type: 1 });
  }), at = o$6(($t) => {
    if (V) return $t.preventDefault();
    ie({ type: 1 }), D$3(re.buttonRef.current);
  }), ft = o$6(() => {
    if (V) return ie({ type: 2, focus: c$5.Nothing });
    ie({ type: 2, focus: c$5.Specific, id: W });
  }), dt = u$5(), lt = o$6(($t) => dt.update($t)), yt = o$6(($t) => {
    dt.wasMoved($t) && (V || ne || ie({ type: 2, focus: c$5.Specific, id: W, trigger: 0 }));
  }), St = o$6(($t) => {
    dt.wasMoved($t) && (V || ne && ie({ type: 2, focus: c$5.Nothing }));
  }), mt = useMemo(() => ({ active: ne, disabled: V, close: ot }), [ne, V, ot]);
  return C$2({ ourProps: { id: W, ref: ce, role: "menuitem", tabIndex: V === !0 ? void 0 : -1, "aria-disabled": V === !0 || void 0, disabled: void 0, onClick: at, onFocus: ft, onPointerEnter: lt, onMouseEnter: lt, onPointerMove: yt, onMouseMove: yt, onPointerLeave: St, onMouseLeave: St }, theirProps: J, slot: mt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c$1(B = 0) {
  let [L, K] = useState(B), W = f$5(), V = useCallback((ne) => {
    W.current && K((oe) => oe | ne);
  }, [L, W]), J = useCallback((ne) => !!(L & ne), [L]), re = useCallback((ne) => {
    W.current && K((oe) => oe & ~ne);
  }, [K, W]), ie = useCallback((ne) => {
    W.current && K((oe) => oe ^ ne);
  }, [K]);
  return { flags: L, addFlag: V, hasFlag: J, removeFlag: re, toggleFlag: ie };
}
function l$1(B) {
  let L = { called: !1 };
  return (...K) => {
    if (!L.called) return L.called = !0, B(...K);
  };
}
function g$1(B, ...L) {
  B && L.length > 0 && B.classList.add(...L);
}
function v$1(B, ...L) {
  B && L.length > 0 && B.classList.remove(...L);
}
function b$1(B, L) {
  let K = o$5();
  if (!B) return K.dispose;
  let { transitionDuration: W, transitionDelay: V } = getComputedStyle(B), [J, re] = [W, V].map((ne) => {
    let [oe = 0] = ne.split(",").filter(Boolean).map((ce) => ce.includes("ms") ? parseFloat(ce) : 1e3 * parseFloat(ce)).sort((ce, pe) => pe - ce);
    return oe;
  }), ie = J + re;
  if (ie !== 0) {
    K.group((oe) => {
      oe.setTimeout(() => {
        L(), oe.dispose();
      }, ie), oe.addEventListener(B, "transitionrun", (ce) => {
        ce.target === ce.currentTarget && oe.dispose();
      });
    });
    let ne = K.addEventListener(B, "transitionend", (oe) => {
      oe.target === oe.currentTarget && (L(), ne());
    });
  } else L();
  return K.add(() => L()), K.dispose;
}
function M$1(B, L, K, W) {
  let V = K ? "enter" : "leave", J = o$5(), re = W !== void 0 ? l$1(W) : () => {
  };
  V === "enter" && (B.removeAttribute("hidden"), B.style.display = "");
  let ie = u$7(V, { enter: () => L.enter, leave: () => L.leave }), ne = u$7(V, { enter: () => L.enterTo, leave: () => L.leaveTo }), oe = u$7(V, { enter: () => L.enterFrom, leave: () => L.leaveFrom });
  return v$1(B, ...L.base, ...L.enter, ...L.enterTo, ...L.enterFrom, ...L.leave, ...L.leaveFrom, ...L.leaveTo, ...L.entered), g$1(B, ...L.base, ...ie, ...oe), J.nextFrame(() => {
    v$1(B, ...L.base, ...ie, ...oe), g$1(B, ...L.base, ...ie, ...ne), b$1(B, () => (v$1(B, ...L.base, ...ie), g$1(B, ...L.base, ...L.entered), re()));
  }), J.dispose;
}
function D({ immediate: B, container: L, direction: K, classes: W, onStart: V, onStop: J }) {
  let re = f$5(), ie = p$4(), ne = s$9(K);
  l$6(() => {
    B && (ne.current = "enter");
  }, [B]), l$6(() => {
    let oe = o$5();
    ie.add(oe.dispose);
    let ce = L.current;
    if (ce && ne.current !== "idle" && re.current) return oe.dispose(), V.current(ne.current), oe.add(M$1(ce, W.current, ne.current === "enter", () => {
      oe.dispose(), J.current(ne.current);
    })), oe.dispose;
  }, [K]);
}
function S(B = "") {
  return B.split(/\s+/).filter((L) => L.length > 1);
}
let I$1 = createContext(null);
I$1.displayName = "TransitionContext";
var Se = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(Se || {});
function ye() {
  let B = useContext(I$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function xe() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: L }) => L.current !== null).filter(({ state: L }) => L === "visible").length > 0;
}
function se(B, L) {
  let K = s$9(B), W = useRef([]), V = f$5(), J = p$4(), re = o$6((ot, at = v$2.Hidden) => {
    let ft = W.current.findIndex(({ el: dt }) => dt === ot);
    ft !== -1 && (u$7(at, { [v$2.Unmount]() {
      W.current.splice(ft, 1);
    }, [v$2.Hidden]() {
      W.current[ft].state = "hidden";
    } }), J.microTask(() => {
      var dt;
      !U(W) && V.current && ((dt = K.current) == null || dt.call(K));
    }));
  }), ie = o$6((ot) => {
    let at = W.current.find(({ el: ft }) => ft === ot);
    return at ? at.state !== "visible" && (at.state = "visible") : W.current.push({ el: ot, state: "visible" }), () => re(ot, v$2.Unmount);
  }), ne = useRef([]), oe = useRef(Promise.resolve()), ce = useRef({ enter: [], leave: [], idle: [] }), pe = o$6((ot, at, ft) => {
    ne.current.splice(0), L && (L.chains.current[at] = L.chains.current[at].filter(([dt]) => dt !== ot)), L == null || L.chains.current[at].push([ot, new Promise((dt) => {
      ne.current.push(dt);
    })]), L == null || L.chains.current[at].push([ot, new Promise((dt) => {
      Promise.all(ce.current[at].map(([lt, yt]) => yt)).then(() => dt());
    })]), at === "enter" ? oe.current = oe.current.then(() => L == null ? void 0 : L.wait.current).then(() => ft(at)) : ft(at);
  }), ke = o$6((ot, at, ft) => {
    Promise.all(ce.current[at].splice(0).map(([dt, lt]) => lt)).then(() => {
      var dt;
      (dt = ne.current.shift()) == null || dt();
    }).then(() => ft(at));
  });
  return useMemo(() => ({ children: W, register: ie, unregister: re, onStart: pe, onStop: ke, wait: oe, chains: ce }), [ie, re, W, pe, ke, ce, oe]);
}
function Ne() {
}
M.displayName = "NestingContext";
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(B) {
  var L;
  let K = {};
  for (let W of Pe) K[W] = (L = B[W]) != null ? L : Ne;
  return K;
}
function Re(B) {
  let L = useRef(ae(B));
  return useEffect(() => {
    L.current = ae(B);
  }, [B]), L;
}
let De = "div", le = O$1.RenderStrategy;
function He(B, L) {
  var K, W;
  let { beforeEnter: V, afterEnter: J, beforeLeave: re, afterLeave: ie, enter: ne, enterFrom: oe, enterTo: ce, entered: pe, leave: ke, leaveFrom: ot, leaveTo: at, ...ft } = B, dt = useRef(null), lt = y$2(dt, L), yt = (K = ft.unmount) == null || K ? v$2.Unmount : v$2.Hidden, { show: St, appear: mt, initial: $t } = ye(), [It, Ut] = useState(St ? "visible" : "hidden"), ut = xe(), { register: ht, unregister: Ce } = ut;
  useEffect(() => ht(dt), [ht, dt]), useEffect(() => {
    if (yt === v$2.Hidden && dt.current) return St && It !== "visible" ? void Ut("visible") : u$7(It, { hidden: () => Ce(dt), visible: () => ht(dt) });
  }, [It, dt, ht, Ce, St, yt]);
  let nt = s$9({ base: S(ft.className), enter: S(ne), enterFrom: S(oe), enterTo: S(ce), entered: S(pe), leave: S(ke), leaveFrom: S(ot), leaveTo: S(at) }), rt = Re({ beforeEnter: V, afterEnter: J, beforeLeave: re, afterLeave: ie }), it = l$5();
  useEffect(() => {
    if (it && It === "visible" && dt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [dt, It, it]);
  let st = mt && St && $t, Oe = !it || $t && !mt ? "idle" : St ? "enter" : "leave", ct = c$1(0), pt = o$6((Et) => u$7(Et, { enter: () => {
    ct.addFlag(d$4.Opening), rt.current.beforeEnter();
  }, leave: () => {
    ct.addFlag(d$4.Closing), rt.current.beforeLeave();
  }, idle: () => {
  } })), gt = o$6((Et) => u$7(Et, { enter: () => {
    ct.removeFlag(d$4.Opening), rt.current.afterEnter();
  }, leave: () => {
    ct.removeFlag(d$4.Closing), rt.current.afterLeave();
  }, idle: () => {
  } })), vt = se(() => {
    Ut("hidden"), Ce(dt);
  }, ut), Bt = useRef(!1);
  D({ immediate: st, container: dt, classes: nt, direction: Oe, onStart: s$9((Et) => {
    Bt.current = !0, vt.onStart(dt, Et, pt);
  }), onStop: s$9((Et) => {
    Bt.current = !1, vt.onStop(dt, Et, gt), Et === "leave" && !U(vt) && (Ut("hidden"), Ce(dt));
  }) });
  let kt = ft, wt = { ref: lt };
  return st ? kt = { ...kt, className: t$5(ft.className, ...nt.current.enter, ...nt.current.enterFrom) } : Bt.current && (kt.className = t$5(ft.className, (W = dt.current) == null ? void 0 : W.className), kt.className === "" && delete kt.className), C__default.createElement(M.Provider, { value: vt }, C__default.createElement(s$5, { value: u$7(It, { visible: d$4.Open, hidden: d$4.Closed }) | ct.flags }, C$2({ ourProps: wt, theirProps: kt, defaultTag: De, features: le, visible: It === "visible", name: "Transition.Child" })));
}
function Fe(B, L) {
  let { show: K, appear: W = !1, unmount: V = !0, ...J } = B, re = useRef(null), ie = y$2(re, L);
  l$5();
  let ne = u$3();
  if (K === void 0 && ne !== null && (K = (ne & d$4.Open) === d$4.Open), ![!0, !1].includes(K)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [oe, ce] = useState(K ? "visible" : "hidden"), pe = se(() => {
    ce("hidden");
  }), [ke, ot] = useState(!0), at = useRef([K]);
  l$6(() => {
    ke !== !1 && at.current[at.current.length - 1] !== K && (at.current.push(K), ot(!1));
  }, [at, K]);
  let ft = useMemo(() => ({ show: K, appear: W, initial: ke }), [K, W, ke]);
  useEffect(() => {
    if (K) ce("visible");
    else if (U(pe)) {
      let St = re.current;
      if (!St) return;
      let mt = St.getBoundingClientRect();
      mt.x === 0 && mt.y === 0 && mt.width === 0 && mt.height === 0 && ce("hidden");
    } else ce("hidden");
  }, [K, pe]);
  let dt = { unmount: V }, lt = o$6(() => {
    var St;
    ke && ot(!1), (St = B.beforeEnter) == null || St.call(B);
  }), yt = o$6(() => {
    var St;
    ke && ot(!1), (St = B.beforeLeave) == null || St.call(B);
  });
  return C__default.createElement(M.Provider, { value: pe }, C__default.createElement(I$1.Provider, { value: ft }, C$2({ ourProps: { ...dt, as: Fragment, children: C__default.createElement(ue, { ref: ie, ...dt, ...J, beforeEnter: lt, beforeLeave: yt }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: oe === "visible", name: "Transition" })));
}
function _e(B, L) {
  let K = useContext(I$1) !== null, W = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !K && W ? C__default.createElement(q, { ref: L, ...B }) : C__default.createElement(ue, { ref: L, ...B }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1, base64Js$1.toByteArray = toByteArray$1, base64Js$1.fromByteArray = fromByteArray$1;
for (var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2) lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
function getLens$1(B) {
  var L = B.length;
  if (L % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  var K = B.indexOf("=");
  return K === -1 && (K = L), [K, K === L ? 0 : 4 - K % 4];
}
function byteLength$1(B) {
  var L = getLens$1(B), K = L[0], W = L[1];
  return 3 * (K + W) / 4 - W;
}
function _byteLength$1(B, L, K) {
  return 3 * (L + K) / 4 - K;
}
function toByteArray$1(B) {
  var L, K, W = getLens$1(B), V = W[0], J = W[1], re = new Arr$1(_byteLength$1(B, V, J)), ie = 0, ne = J > 0 ? V - 4 : V;
  for (K = 0; K < ne; K += 4) L = revLookup$1[B.charCodeAt(K)] << 18 | revLookup$1[B.charCodeAt(K + 1)] << 12 | revLookup$1[B.charCodeAt(K + 2)] << 6 | revLookup$1[B.charCodeAt(K + 3)], re[ie++] = L >> 16 & 255, re[ie++] = L >> 8 & 255, re[ie++] = 255 & L;
  return J === 2 && (L = revLookup$1[B.charCodeAt(K)] << 2 | revLookup$1[B.charCodeAt(K + 1)] >> 4, re[ie++] = 255 & L), J === 1 && (L = revLookup$1[B.charCodeAt(K)] << 10 | revLookup$1[B.charCodeAt(K + 1)] << 4 | revLookup$1[B.charCodeAt(K + 2)] >> 2, re[ie++] = L >> 8 & 255, re[ie++] = 255 & L), re;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[63 & B];
}
function encodeChunk$1(B, L, K) {
  for (var W, V = [], J = L; J < K; J += 3) W = (B[J] << 16 & 16711680) + (B[J + 1] << 8 & 65280) + (255 & B[J + 2]), V.push(tripletToBase64$1(W));
  return V.join("");
}
function fromByteArray$1(B) {
  for (var L, K = B.length, W = K % 3, V = [], J = 16383, re = 0, ie = K - W; re < ie; re += J) V.push(encodeChunk$1(B, re, re + J > ie ? ie : re + J));
  return W === 1 ? (L = B[K - 1], V.push(lookup$1[L >> 2] + lookup$1[L << 4 & 63] + "==")) : W === 2 && (L = (B[K - 2] << 8) + B[K - 1], V.push(lookup$1[L >> 10] + lookup$1[L >> 4 & 63] + lookup$1[L << 2 & 63] + "=")), V.join("");
}
revLookup$1[45] = 62, revLookup$1[95] = 63;
var ieee754 = { read: function(B, L, K, W, V) {
  var J, re, ie = 8 * V - W - 1, ne = (1 << ie) - 1, oe = ne >> 1, ce = -7, pe = K ? V - 1 : 0, ke = K ? -1 : 1, ot = B[L + pe];
  for (pe += ke, J = ot & (1 << -ce) - 1, ot >>= -ce, ce += ie; ce > 0; J = 256 * J + B[L + pe], pe += ke, ce -= 8) ;
  for (re = J & (1 << -ce) - 1, J >>= -ce, ce += W; ce > 0; re = 256 * re + B[L + pe], pe += ke, ce -= 8) ;
  if (J === 0) J = 1 - oe;
  else {
    if (J === ne) return re ? NaN : 1 / 0 * (ot ? -1 : 1);
    re += Math.pow(2, W), J -= oe;
  }
  return (ot ? -1 : 1) * re * Math.pow(2, J - W);
}, write: function(B, L, K, W, V, J) {
  var re, ie, ne, oe = 8 * J - V - 1, ce = (1 << oe) - 1, pe = ce >> 1, ke = V === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ot = W ? 0 : J - 1, at = W ? 1 : -1, ft = L < 0 || L === 0 && 1 / L < 0 ? 1 : 0;
  for (L = Math.abs(L), isNaN(L) || L === 1 / 0 ? (ie = isNaN(L) ? 1 : 0, re = ce) : (re = Math.floor(Math.log(L) / Math.LN2), L * (ne = Math.pow(2, -re)) < 1 && (re--, ne *= 2), (L += re + pe >= 1 ? ke / ne : ke * Math.pow(2, 1 - pe)) * ne >= 2 && (re++, ne /= 2), re + pe >= ce ? (ie = 0, re = ce) : re + pe >= 1 ? (ie = (L * ne - 1) * Math.pow(2, V), re += pe) : (ie = L * Math.pow(2, pe - 1) * Math.pow(2, V), re = 0)); V >= 8; B[K + ot] = 255 & ie, ot += at, ie /= 256, V -= 8) ;
  for (re = re << V | ie, oe += V; oe > 0; B[K + ot] = 255 & re, ot += at, re /= 256, oe -= 8) ;
  B[K + ot - at] |= 128 * ft;
} };
(function(B) {
  const L = base64Js$1, K = ieee754, W = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = oe, B.SlowBuffer = function(bt) {
    return +bt != bt && (bt = 0), oe.alloc(+bt);
  }, B.INSPECT_MAX_BYTES = 50;
  const V = 2147483647;
  B.kMaxLength = V;
  const { Uint8Array: J, ArrayBuffer: re, SharedArrayBuffer: ie } = globalThis;
  function ne(bt) {
    if (bt > V) throw new RangeError('The value "' + bt + '" is invalid for option "size"');
    const At = new J(bt);
    return Object.setPrototypeOf(At, oe.prototype), At;
  }
  function oe(bt, At, Tt) {
    if (typeof bt == "number") {
      if (typeof At == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
      return ke(bt);
    }
    return ce(bt, At, Tt);
  }
  function ce(bt, At, Tt) {
    if (typeof bt == "string") return function(Ft, zt) {
      if (typeof zt == "string" && zt !== "" || (zt = "utf8"), !oe.isEncoding(zt)) throw new TypeError("Unknown encoding: " + zt);
      const nr = 0 | dt(Ft, zt);
      let lr = ne(nr);
      const Dt = lr.write(Ft, zt);
      return Dt !== nr && (lr = lr.slice(0, Dt)), lr;
    }(bt, At);
    if (re.isView(bt)) return function(Ft) {
      if (Qt(Ft, J)) {
        const zt = new J(Ft);
        return at(zt.buffer, zt.byteOffset, zt.byteLength);
      }
      return ot(Ft);
    }(bt);
    if (bt == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof bt);
    if (Qt(bt, re) || bt && Qt(bt.buffer, re) || ie !== void 0 && (Qt(bt, ie) || bt && Qt(bt.buffer, ie))) return at(bt, At, Tt);
    if (typeof bt == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const xt = bt.valueOf && bt.valueOf();
    if (xt != null && xt !== bt) return oe.from(xt, At, Tt);
    const Nt = function(Ft) {
      if (oe.isBuffer(Ft)) {
        const zt = 0 | ft(Ft.length), nr = ne(zt);
        return nr.length === 0 || Ft.copy(nr, 0, 0, zt), nr;
      }
      return Ft.length !== void 0 ? typeof Ft.length != "number" || hr(Ft.length) ? ne(0) : ot(Ft) : Ft.type === "Buffer" && Array.isArray(Ft.data) ? ot(Ft.data) : void 0;
    }(bt);
    if (Nt) return Nt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof bt[Symbol.toPrimitive] == "function") return oe.from(bt[Symbol.toPrimitive]("string"), At, Tt);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof bt);
  }
  function pe(bt) {
    if (typeof bt != "number") throw new TypeError('"size" argument must be of type number');
    if (bt < 0) throw new RangeError('The value "' + bt + '" is invalid for option "size"');
  }
  function ke(bt) {
    return pe(bt), ne(bt < 0 ? 0 : 0 | ft(bt));
  }
  function ot(bt) {
    const At = bt.length < 0 ? 0 : 0 | ft(bt.length), Tt = ne(At);
    for (let xt = 0; xt < At; xt += 1) Tt[xt] = 255 & bt[xt];
    return Tt;
  }
  function at(bt, At, Tt) {
    if (At < 0 || bt.byteLength < At) throw new RangeError('"offset" is outside of buffer bounds');
    if (bt.byteLength < At + (Tt || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let xt;
    return xt = At === void 0 && Tt === void 0 ? new J(bt) : Tt === void 0 ? new J(bt, At) : new J(bt, At, Tt), Object.setPrototypeOf(xt, oe.prototype), xt;
  }
  function ft(bt) {
    if (bt >= V) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + V.toString(16) + " bytes");
    return 0 | bt;
  }
  function dt(bt, At) {
    if (oe.isBuffer(bt)) return bt.length;
    if (re.isView(bt) || Qt(bt, re)) return bt.byteLength;
    if (typeof bt != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof bt);
    const Tt = bt.length, xt = arguments.length > 2 && arguments[2] === !0;
    if (!xt && Tt === 0) return 0;
    let Nt = !1;
    for (; ; ) switch (At) {
      case "ascii":
      case "latin1":
      case "binary":
        return Tt;
      case "utf8":
      case "utf-8":
        return Xt(bt).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * Tt;
      case "hex":
        return Tt >>> 1;
      case "base64":
        return ir(bt).length;
      default:
        if (Nt) return xt ? -1 : Xt(bt).length;
        At = ("" + At).toLowerCase(), Nt = !0;
    }
  }
  function lt(bt, At, Tt) {
    let xt = !1;
    if ((At === void 0 || At < 0) && (At = 0), At > this.length || ((Tt === void 0 || Tt > this.length) && (Tt = this.length), Tt <= 0) || (Tt >>>= 0) <= (At >>>= 0)) return "";
    for (bt || (bt = "utf8"); ; ) switch (bt) {
      case "hex":
        return Oe(this, At, Tt);
      case "utf8":
      case "utf-8":
        return nt(this, At, Tt);
      case "ascii":
        return it(this, At, Tt);
      case "latin1":
      case "binary":
        return st(this, At, Tt);
      case "base64":
        return Ce(this, At, Tt);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ct(this, At, Tt);
      default:
        if (xt) throw new TypeError("Unknown encoding: " + bt);
        bt = (bt + "").toLowerCase(), xt = !0;
    }
  }
  function yt(bt, At, Tt) {
    const xt = bt[At];
    bt[At] = bt[Tt], bt[Tt] = xt;
  }
  function St(bt, At, Tt, xt, Nt) {
    if (bt.length === 0) return -1;
    if (typeof Tt == "string" ? (xt = Tt, Tt = 0) : Tt > 2147483647 ? Tt = 2147483647 : Tt < -2147483648 && (Tt = -2147483648), hr(Tt = +Tt) && (Tt = Nt ? 0 : bt.length - 1), Tt < 0 && (Tt = bt.length + Tt), Tt >= bt.length) {
      if (Nt) return -1;
      Tt = bt.length - 1;
    } else if (Tt < 0) {
      if (!Nt) return -1;
      Tt = 0;
    }
    if (typeof At == "string" && (At = oe.from(At, xt)), oe.isBuffer(At)) return At.length === 0 ? -1 : mt(bt, At, Tt, xt, Nt);
    if (typeof At == "number") return At &= 255, typeof J.prototype.indexOf == "function" ? Nt ? J.prototype.indexOf.call(bt, At, Tt) : J.prototype.lastIndexOf.call(bt, At, Tt) : mt(bt, [At], Tt, xt, Nt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function mt(bt, At, Tt, xt, Nt) {
    let Ft, zt = 1, nr = bt.length, lr = At.length;
    if (xt !== void 0 && ((xt = String(xt).toLowerCase()) === "ucs2" || xt === "ucs-2" || xt === "utf16le" || xt === "utf-16le")) {
      if (bt.length < 2 || At.length < 2) return -1;
      zt = 2, nr /= 2, lr /= 2, Tt /= 2;
    }
    function Dt(Zt, ar) {
      return zt === 1 ? Zt[ar] : Zt.readUInt16BE(ar * zt);
    }
    if (Nt) {
      let Zt = -1;
      for (Ft = Tt; Ft < nr; Ft++) if (Dt(bt, Ft) === Dt(At, Zt === -1 ? 0 : Ft - Zt)) {
        if (Zt === -1 && (Zt = Ft), Ft - Zt + 1 === lr) return Zt * zt;
      } else Zt !== -1 && (Ft -= Ft - Zt), Zt = -1;
    } else for (Tt + lr > nr && (Tt = nr - lr), Ft = Tt; Ft >= 0; Ft--) {
      let Zt = !0;
      for (let ar = 0; ar < lr; ar++) if (Dt(bt, Ft + ar) !== Dt(At, ar)) {
        Zt = !1;
        break;
      }
      if (Zt) return Ft;
    }
    return -1;
  }
  function $t(bt, At, Tt, xt) {
    Tt = Number(Tt) || 0;
    const Nt = bt.length - Tt;
    xt ? (xt = Number(xt)) > Nt && (xt = Nt) : xt = Nt;
    const Ft = At.length;
    let zt;
    for (xt > Ft / 2 && (xt = Ft / 2), zt = 0; zt < xt; ++zt) {
      const nr = parseInt(At.substr(2 * zt, 2), 16);
      if (hr(nr)) return zt;
      bt[Tt + zt] = nr;
    }
    return zt;
  }
  function It(bt, At, Tt, xt) {
    return ur(Xt(At, bt.length - Tt), bt, Tt, xt);
  }
  function Ut(bt, At, Tt, xt) {
    return ur(function(Nt) {
      const Ft = [];
      for (let zt = 0; zt < Nt.length; ++zt) Ft.push(255 & Nt.charCodeAt(zt));
      return Ft;
    }(At), bt, Tt, xt);
  }
  function ut(bt, At, Tt, xt) {
    return ur(ir(At), bt, Tt, xt);
  }
  function ht(bt, At, Tt, xt) {
    return ur(function(Nt, Ft) {
      let zt, nr, lr;
      const Dt = [];
      for (let Zt = 0; Zt < Nt.length && !((Ft -= 2) < 0); ++Zt) zt = Nt.charCodeAt(Zt), nr = zt >> 8, lr = zt % 256, Dt.push(lr), Dt.push(nr);
      return Dt;
    }(At, bt.length - Tt), bt, Tt, xt);
  }
  function Ce(bt, At, Tt) {
    return At === 0 && Tt === bt.length ? L.fromByteArray(bt) : L.fromByteArray(bt.slice(At, Tt));
  }
  function nt(bt, At, Tt) {
    Tt = Math.min(bt.length, Tt);
    const xt = [];
    let Nt = At;
    for (; Nt < Tt; ) {
      const Ft = bt[Nt];
      let zt = null, nr = Ft > 239 ? 4 : Ft > 223 ? 3 : Ft > 191 ? 2 : 1;
      if (Nt + nr <= Tt) {
        let lr, Dt, Zt, ar;
        switch (nr) {
          case 1:
            Ft < 128 && (zt = Ft);
            break;
          case 2:
            lr = bt[Nt + 1], (192 & lr) == 128 && (ar = (31 & Ft) << 6 | 63 & lr, ar > 127 && (zt = ar));
            break;
          case 3:
            lr = bt[Nt + 1], Dt = bt[Nt + 2], (192 & lr) == 128 && (192 & Dt) == 128 && (ar = (15 & Ft) << 12 | (63 & lr) << 6 | 63 & Dt, ar > 2047 && (ar < 55296 || ar > 57343) && (zt = ar));
            break;
          case 4:
            lr = bt[Nt + 1], Dt = bt[Nt + 2], Zt = bt[Nt + 3], (192 & lr) == 128 && (192 & Dt) == 128 && (192 & Zt) == 128 && (ar = (15 & Ft) << 18 | (63 & lr) << 12 | (63 & Dt) << 6 | 63 & Zt, ar > 65535 && ar < 1114112 && (zt = ar));
        }
      }
      zt === null ? (zt = 65533, nr = 1) : zt > 65535 && (zt -= 65536, xt.push(zt >>> 10 & 1023 | 55296), zt = 56320 | 1023 & zt), xt.push(zt), Nt += nr;
    }
    return function(Ft) {
      const zt = Ft.length;
      if (zt <= rt) return String.fromCharCode.apply(String, Ft);
      let nr = "", lr = 0;
      for (; lr < zt; ) nr += String.fromCharCode.apply(String, Ft.slice(lr, lr += rt));
      return nr;
    }(xt);
  }
  oe.TYPED_ARRAY_SUPPORT = function() {
    try {
      const bt = new J(1), At = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(At, J.prototype), Object.setPrototypeOf(bt, At), bt.foo() === 42;
    } catch {
      return !1;
    }
  }(), !oe.TYPED_ARRAY_SUPPORT && typeof console < "u", Object.defineProperty(oe.prototype, "parent", { enumerable: !0, get: function() {
    if (oe.isBuffer(this)) return this.buffer;
  } }), Object.defineProperty(oe.prototype, "offset", { enumerable: !0, get: function() {
    if (oe.isBuffer(this)) return this.byteOffset;
  } }), oe.poolSize = 8192, oe.from = function(bt, At, Tt) {
    return ce(bt, At, Tt);
  }, Object.setPrototypeOf(oe.prototype, J.prototype), Object.setPrototypeOf(oe, J), oe.alloc = function(bt, At, Tt) {
    return function(xt, Nt, Ft) {
      return pe(xt), xt <= 0 ? ne(xt) : Nt !== void 0 ? typeof Ft == "string" ? ne(xt).fill(Nt, Ft) : ne(xt).fill(Nt) : ne(xt);
    }(bt, At, Tt);
  }, oe.allocUnsafe = function(bt) {
    return ke(bt);
  }, oe.allocUnsafeSlow = function(bt) {
    return ke(bt);
  }, oe.isBuffer = function(bt) {
    return bt != null && bt._isBuffer === !0 && bt !== oe.prototype;
  }, oe.compare = function(bt, At) {
    if (Qt(bt, J) && (bt = oe.from(bt, bt.offset, bt.byteLength)), Qt(At, J) && (At = oe.from(At, At.offset, At.byteLength)), !oe.isBuffer(bt) || !oe.isBuffer(At)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (bt === At) return 0;
    let Tt = bt.length, xt = At.length;
    for (let Nt = 0, Ft = Math.min(Tt, xt); Nt < Ft; ++Nt) if (bt[Nt] !== At[Nt]) {
      Tt = bt[Nt], xt = At[Nt];
      break;
    }
    return Tt < xt ? -1 : xt < Tt ? 1 : 0;
  }, oe.isEncoding = function(bt) {
    switch (String(bt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, oe.concat = function(bt, At) {
    if (!Array.isArray(bt)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (bt.length === 0) return oe.alloc(0);
    let Tt;
    if (At === void 0) for (At = 0, Tt = 0; Tt < bt.length; ++Tt) At += bt[Tt].length;
    const xt = oe.allocUnsafe(At);
    let Nt = 0;
    for (Tt = 0; Tt < bt.length; ++Tt) {
      let Ft = bt[Tt];
      if (Qt(Ft, J)) Nt + Ft.length > xt.length ? (oe.isBuffer(Ft) || (Ft = oe.from(Ft)), Ft.copy(xt, Nt)) : J.prototype.set.call(xt, Ft, Nt);
      else {
        if (!oe.isBuffer(Ft)) throw new TypeError('"list" argument must be an Array of Buffers');
        Ft.copy(xt, Nt);
      }
      Nt += Ft.length;
    }
    return xt;
  }, oe.byteLength = dt, oe.prototype._isBuffer = !0, oe.prototype.swap16 = function() {
    const bt = this.length;
    if (bt % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let At = 0; At < bt; At += 2) yt(this, At, At + 1);
    return this;
  }, oe.prototype.swap32 = function() {
    const bt = this.length;
    if (bt % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let At = 0; At < bt; At += 4) yt(this, At, At + 3), yt(this, At + 1, At + 2);
    return this;
  }, oe.prototype.swap64 = function() {
    const bt = this.length;
    if (bt % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let At = 0; At < bt; At += 8) yt(this, At, At + 7), yt(this, At + 1, At + 6), yt(this, At + 2, At + 5), yt(this, At + 3, At + 4);
    return this;
  }, oe.prototype.toString = function() {
    const bt = this.length;
    return bt === 0 ? "" : arguments.length === 0 ? nt(this, 0, bt) : lt.apply(this, arguments);
  }, oe.prototype.toLocaleString = oe.prototype.toString, oe.prototype.equals = function(bt) {
    if (!oe.isBuffer(bt)) throw new TypeError("Argument must be a Buffer");
    return this === bt || oe.compare(this, bt) === 0;
  }, oe.prototype.inspect = function() {
    let bt = "";
    const At = B.INSPECT_MAX_BYTES;
    return bt = this.toString("hex", 0, At).replace(/(.{2})/g, "$1 ").trim(), this.length > At && (bt += " ... "), "<Buffer " + bt + ">";
  }, W && (oe.prototype[W] = oe.prototype.inspect), oe.prototype.compare = function(bt, At, Tt, xt, Nt) {
    if (Qt(bt, J) && (bt = oe.from(bt, bt.offset, bt.byteLength)), !oe.isBuffer(bt)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof bt);
    if (At === void 0 && (At = 0), Tt === void 0 && (Tt = bt ? bt.length : 0), xt === void 0 && (xt = 0), Nt === void 0 && (Nt = this.length), At < 0 || Tt > bt.length || xt < 0 || Nt > this.length) throw new RangeError("out of range index");
    if (xt >= Nt && At >= Tt) return 0;
    if (xt >= Nt) return -1;
    if (At >= Tt) return 1;
    if (this === bt) return 0;
    let Ft = (Nt >>>= 0) - (xt >>>= 0), zt = (Tt >>>= 0) - (At >>>= 0);
    const nr = Math.min(Ft, zt), lr = this.slice(xt, Nt), Dt = bt.slice(At, Tt);
    for (let Zt = 0; Zt < nr; ++Zt) if (lr[Zt] !== Dt[Zt]) {
      Ft = lr[Zt], zt = Dt[Zt];
      break;
    }
    return Ft < zt ? -1 : zt < Ft ? 1 : 0;
  }, oe.prototype.includes = function(bt, At, Tt) {
    return this.indexOf(bt, At, Tt) !== -1;
  }, oe.prototype.indexOf = function(bt, At, Tt) {
    return St(this, bt, At, Tt, !0);
  }, oe.prototype.lastIndexOf = function(bt, At, Tt) {
    return St(this, bt, At, Tt, !1);
  }, oe.prototype.write = function(bt, At, Tt, xt) {
    if (At === void 0) xt = "utf8", Tt = this.length, At = 0;
    else if (Tt === void 0 && typeof At == "string") xt = At, Tt = this.length, At = 0;
    else {
      if (!isFinite(At)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      At >>>= 0, isFinite(Tt) ? (Tt >>>= 0, xt === void 0 && (xt = "utf8")) : (xt = Tt, Tt = void 0);
    }
    const Nt = this.length - At;
    if ((Tt === void 0 || Tt > Nt) && (Tt = Nt), bt.length > 0 && (Tt < 0 || At < 0) || At > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    xt || (xt = "utf8");
    let Ft = !1;
    for (; ; ) switch (xt) {
      case "hex":
        return $t(this, bt, At, Tt);
      case "utf8":
      case "utf-8":
        return It(this, bt, At, Tt);
      case "ascii":
      case "latin1":
      case "binary":
        return Ut(this, bt, At, Tt);
      case "base64":
        return ut(this, bt, At, Tt);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ht(this, bt, At, Tt);
      default:
        if (Ft) throw new TypeError("Unknown encoding: " + xt);
        xt = ("" + xt).toLowerCase(), Ft = !0;
    }
  }, oe.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const rt = 4096;
  function it(bt, At, Tt) {
    let xt = "";
    Tt = Math.min(bt.length, Tt);
    for (let Nt = At; Nt < Tt; ++Nt) xt += String.fromCharCode(127 & bt[Nt]);
    return xt;
  }
  function st(bt, At, Tt) {
    let xt = "";
    Tt = Math.min(bt.length, Tt);
    for (let Nt = At; Nt < Tt; ++Nt) xt += String.fromCharCode(bt[Nt]);
    return xt;
  }
  function Oe(bt, At, Tt) {
    const xt = bt.length;
    (!At || At < 0) && (At = 0), (!Tt || Tt < 0 || Tt > xt) && (Tt = xt);
    let Nt = "";
    for (let Ft = At; Ft < Tt; ++Ft) Nt += pr[bt[Ft]];
    return Nt;
  }
  function ct(bt, At, Tt) {
    const xt = bt.slice(At, Tt);
    let Nt = "";
    for (let Ft = 0; Ft < xt.length - 1; Ft += 2) Nt += String.fromCharCode(xt[Ft] + 256 * xt[Ft + 1]);
    return Nt;
  }
  function pt(bt, At, Tt) {
    if (bt % 1 != 0 || bt < 0) throw new RangeError("offset is not uint");
    if (bt + At > Tt) throw new RangeError("Trying to access beyond buffer length");
  }
  function gt(bt, At, Tt, xt, Nt, Ft) {
    if (!oe.isBuffer(bt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (At > Nt || At < Ft) throw new RangeError('"value" argument is out of bounds');
    if (Tt + xt > bt.length) throw new RangeError("Index out of range");
  }
  function vt(bt, At, Tt, xt, Nt) {
    Kt(At, xt, Nt, bt, Tt, 7);
    let Ft = Number(At & BigInt(4294967295));
    bt[Tt++] = Ft, Ft >>= 8, bt[Tt++] = Ft, Ft >>= 8, bt[Tt++] = Ft, Ft >>= 8, bt[Tt++] = Ft;
    let zt = Number(At >> BigInt(32) & BigInt(4294967295));
    return bt[Tt++] = zt, zt >>= 8, bt[Tt++] = zt, zt >>= 8, bt[Tt++] = zt, zt >>= 8, bt[Tt++] = zt, Tt;
  }
  function Bt(bt, At, Tt, xt, Nt) {
    Kt(At, xt, Nt, bt, Tt, 7);
    let Ft = Number(At & BigInt(4294967295));
    bt[Tt + 7] = Ft, Ft >>= 8, bt[Tt + 6] = Ft, Ft >>= 8, bt[Tt + 5] = Ft, Ft >>= 8, bt[Tt + 4] = Ft;
    let zt = Number(At >> BigInt(32) & BigInt(4294967295));
    return bt[Tt + 3] = zt, zt >>= 8, bt[Tt + 2] = zt, zt >>= 8, bt[Tt + 1] = zt, zt >>= 8, bt[Tt] = zt, Tt + 8;
  }
  function kt(bt, At, Tt, xt, Nt, Ft) {
    if (Tt + xt > bt.length) throw new RangeError("Index out of range");
    if (Tt < 0) throw new RangeError("Index out of range");
  }
  function wt(bt, At, Tt, xt, Nt) {
    return At = +At, Tt >>>= 0, Nt || kt(bt, 0, Tt, 4), K.write(bt, At, Tt, xt, 23, 4), Tt + 4;
  }
  function Et(bt, At, Tt, xt, Nt) {
    return At = +At, Tt >>>= 0, Nt || kt(bt, 0, Tt, 8), K.write(bt, At, Tt, xt, 52, 8), Tt + 8;
  }
  oe.prototype.slice = function(bt, At) {
    const Tt = this.length;
    (bt = ~~bt) < 0 ? (bt += Tt) < 0 && (bt = 0) : bt > Tt && (bt = Tt), (At = At === void 0 ? Tt : ~~At) < 0 ? (At += Tt) < 0 && (At = 0) : At > Tt && (At = Tt), At < bt && (At = bt);
    const xt = this.subarray(bt, At);
    return Object.setPrototypeOf(xt, oe.prototype), xt;
  }, oe.prototype.readUintLE = oe.prototype.readUIntLE = function(bt, At, Tt) {
    bt >>>= 0, At >>>= 0, Tt || pt(bt, At, this.length);
    let xt = this[bt], Nt = 1, Ft = 0;
    for (; ++Ft < At && (Nt *= 256); ) xt += this[bt + Ft] * Nt;
    return xt;
  }, oe.prototype.readUintBE = oe.prototype.readUIntBE = function(bt, At, Tt) {
    bt >>>= 0, At >>>= 0, Tt || pt(bt, At, this.length);
    let xt = this[bt + --At], Nt = 1;
    for (; At > 0 && (Nt *= 256); ) xt += this[bt + --At] * Nt;
    return xt;
  }, oe.prototype.readUint8 = oe.prototype.readUInt8 = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 1, this.length), this[bt];
  }, oe.prototype.readUint16LE = oe.prototype.readUInt16LE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 2, this.length), this[bt] | this[bt + 1] << 8;
  }, oe.prototype.readUint16BE = oe.prototype.readUInt16BE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 2, this.length), this[bt] << 8 | this[bt + 1];
  }, oe.prototype.readUint32LE = oe.prototype.readUInt32LE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 4, this.length), (this[bt] | this[bt + 1] << 8 | this[bt + 2] << 16) + 16777216 * this[bt + 3];
  }, oe.prototype.readUint32BE = oe.prototype.readUInt32BE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 4, this.length), 16777216 * this[bt] + (this[bt + 1] << 16 | this[bt + 2] << 8 | this[bt + 3]);
  }, oe.prototype.readBigUInt64LE = cr(function(bt) {
    jt(bt >>>= 0, "offset");
    const At = this[bt], Tt = this[bt + 7];
    At !== void 0 && Tt !== void 0 || Wt(bt, this.length - 8);
    const xt = At + 256 * this[++bt] + 65536 * this[++bt] + this[++bt] * 2 ** 24, Nt = this[++bt] + 256 * this[++bt] + 65536 * this[++bt] + Tt * 2 ** 24;
    return BigInt(xt) + (BigInt(Nt) << BigInt(32));
  }), oe.prototype.readBigUInt64BE = cr(function(bt) {
    jt(bt >>>= 0, "offset");
    const At = this[bt], Tt = this[bt + 7];
    At !== void 0 && Tt !== void 0 || Wt(bt, this.length - 8);
    const xt = At * 2 ** 24 + 65536 * this[++bt] + 256 * this[++bt] + this[++bt], Nt = this[++bt] * 2 ** 24 + 65536 * this[++bt] + 256 * this[++bt] + Tt;
    return (BigInt(xt) << BigInt(32)) + BigInt(Nt);
  }), oe.prototype.readIntLE = function(bt, At, Tt) {
    bt >>>= 0, At >>>= 0, Tt || pt(bt, At, this.length);
    let xt = this[bt], Nt = 1, Ft = 0;
    for (; ++Ft < At && (Nt *= 256); ) xt += this[bt + Ft] * Nt;
    return Nt *= 128, xt >= Nt && (xt -= Math.pow(2, 8 * At)), xt;
  }, oe.prototype.readIntBE = function(bt, At, Tt) {
    bt >>>= 0, At >>>= 0, Tt || pt(bt, At, this.length);
    let xt = At, Nt = 1, Ft = this[bt + --xt];
    for (; xt > 0 && (Nt *= 256); ) Ft += this[bt + --xt] * Nt;
    return Nt *= 128, Ft >= Nt && (Ft -= Math.pow(2, 8 * At)), Ft;
  }, oe.prototype.readInt8 = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 1, this.length), 128 & this[bt] ? -1 * (255 - this[bt] + 1) : this[bt];
  }, oe.prototype.readInt16LE = function(bt, At) {
    bt >>>= 0, At || pt(bt, 2, this.length);
    const Tt = this[bt] | this[bt + 1] << 8;
    return 32768 & Tt ? 4294901760 | Tt : Tt;
  }, oe.prototype.readInt16BE = function(bt, At) {
    bt >>>= 0, At || pt(bt, 2, this.length);
    const Tt = this[bt + 1] | this[bt] << 8;
    return 32768 & Tt ? 4294901760 | Tt : Tt;
  }, oe.prototype.readInt32LE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 4, this.length), this[bt] | this[bt + 1] << 8 | this[bt + 2] << 16 | this[bt + 3] << 24;
  }, oe.prototype.readInt32BE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 4, this.length), this[bt] << 24 | this[bt + 1] << 16 | this[bt + 2] << 8 | this[bt + 3];
  }, oe.prototype.readBigInt64LE = cr(function(bt) {
    jt(bt >>>= 0, "offset");
    const At = this[bt], Tt = this[bt + 7];
    At !== void 0 && Tt !== void 0 || Wt(bt, this.length - 8);
    const xt = this[bt + 4] + 256 * this[bt + 5] + 65536 * this[bt + 6] + (Tt << 24);
    return (BigInt(xt) << BigInt(32)) + BigInt(At + 256 * this[++bt] + 65536 * this[++bt] + this[++bt] * 2 ** 24);
  }), oe.prototype.readBigInt64BE = cr(function(bt) {
    jt(bt >>>= 0, "offset");
    const At = this[bt], Tt = this[bt + 7];
    At !== void 0 && Tt !== void 0 || Wt(bt, this.length - 8);
    const xt = (At << 24) + 65536 * this[++bt] + 256 * this[++bt] + this[++bt];
    return (BigInt(xt) << BigInt(32)) + BigInt(this[++bt] * 2 ** 24 + 65536 * this[++bt] + 256 * this[++bt] + Tt);
  }), oe.prototype.readFloatLE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 4, this.length), K.read(this, bt, !0, 23, 4);
  }, oe.prototype.readFloatBE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 4, this.length), K.read(this, bt, !1, 23, 4);
  }, oe.prototype.readDoubleLE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 8, this.length), K.read(this, bt, !0, 52, 8);
  }, oe.prototype.readDoubleBE = function(bt, At) {
    return bt >>>= 0, At || pt(bt, 8, this.length), K.read(this, bt, !1, 52, 8);
  }, oe.prototype.writeUintLE = oe.prototype.writeUIntLE = function(bt, At, Tt, xt) {
    bt = +bt, At >>>= 0, Tt >>>= 0, xt || gt(this, bt, At, Tt, Math.pow(2, 8 * Tt) - 1, 0);
    let Nt = 1, Ft = 0;
    for (this[At] = 255 & bt; ++Ft < Tt && (Nt *= 256); ) this[At + Ft] = bt / Nt & 255;
    return At + Tt;
  }, oe.prototype.writeUintBE = oe.prototype.writeUIntBE = function(bt, At, Tt, xt) {
    bt = +bt, At >>>= 0, Tt >>>= 0, xt || gt(this, bt, At, Tt, Math.pow(2, 8 * Tt) - 1, 0);
    let Nt = Tt - 1, Ft = 1;
    for (this[At + Nt] = 255 & bt; --Nt >= 0 && (Ft *= 256); ) this[At + Nt] = bt / Ft & 255;
    return At + Tt;
  }, oe.prototype.writeUint8 = oe.prototype.writeUInt8 = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 1, 255, 0), this[At] = 255 & bt, At + 1;
  }, oe.prototype.writeUint16LE = oe.prototype.writeUInt16LE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 2, 65535, 0), this[At] = 255 & bt, this[At + 1] = bt >>> 8, At + 2;
  }, oe.prototype.writeUint16BE = oe.prototype.writeUInt16BE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 2, 65535, 0), this[At] = bt >>> 8, this[At + 1] = 255 & bt, At + 2;
  }, oe.prototype.writeUint32LE = oe.prototype.writeUInt32LE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 4, 4294967295, 0), this[At + 3] = bt >>> 24, this[At + 2] = bt >>> 16, this[At + 1] = bt >>> 8, this[At] = 255 & bt, At + 4;
  }, oe.prototype.writeUint32BE = oe.prototype.writeUInt32BE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 4, 4294967295, 0), this[At] = bt >>> 24, this[At + 1] = bt >>> 16, this[At + 2] = bt >>> 8, this[At + 3] = 255 & bt, At + 4;
  }, oe.prototype.writeBigUInt64LE = cr(function(bt, At = 0) {
    return vt(this, bt, At, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeBigUInt64BE = cr(function(bt, At = 0) {
    return Bt(this, bt, At, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeIntLE = function(bt, At, Tt, xt) {
    if (bt = +bt, At >>>= 0, !xt) {
      const nr = Math.pow(2, 8 * Tt - 1);
      gt(this, bt, At, Tt, nr - 1, -nr);
    }
    let Nt = 0, Ft = 1, zt = 0;
    for (this[At] = 255 & bt; ++Nt < Tt && (Ft *= 256); ) bt < 0 && zt === 0 && this[At + Nt - 1] !== 0 && (zt = 1), this[At + Nt] = (bt / Ft | 0) - zt & 255;
    return At + Tt;
  }, oe.prototype.writeIntBE = function(bt, At, Tt, xt) {
    if (bt = +bt, At >>>= 0, !xt) {
      const nr = Math.pow(2, 8 * Tt - 1);
      gt(this, bt, At, Tt, nr - 1, -nr);
    }
    let Nt = Tt - 1, Ft = 1, zt = 0;
    for (this[At + Nt] = 255 & bt; --Nt >= 0 && (Ft *= 256); ) bt < 0 && zt === 0 && this[At + Nt + 1] !== 0 && (zt = 1), this[At + Nt] = (bt / Ft | 0) - zt & 255;
    return At + Tt;
  }, oe.prototype.writeInt8 = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 1, 127, -128), bt < 0 && (bt = 255 + bt + 1), this[At] = 255 & bt, At + 1;
  }, oe.prototype.writeInt16LE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 2, 32767, -32768), this[At] = 255 & bt, this[At + 1] = bt >>> 8, At + 2;
  }, oe.prototype.writeInt16BE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 2, 32767, -32768), this[At] = bt >>> 8, this[At + 1] = 255 & bt, At + 2;
  }, oe.prototype.writeInt32LE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 4, 2147483647, -2147483648), this[At] = 255 & bt, this[At + 1] = bt >>> 8, this[At + 2] = bt >>> 16, this[At + 3] = bt >>> 24, At + 4;
  }, oe.prototype.writeInt32BE = function(bt, At, Tt) {
    return bt = +bt, At >>>= 0, Tt || gt(this, bt, At, 4, 2147483647, -2147483648), bt < 0 && (bt = 4294967295 + bt + 1), this[At] = bt >>> 24, this[At + 1] = bt >>> 16, this[At + 2] = bt >>> 8, this[At + 3] = 255 & bt, At + 4;
  }, oe.prototype.writeBigInt64LE = cr(function(bt, At = 0) {
    return vt(this, bt, At, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), oe.prototype.writeBigInt64BE = cr(function(bt, At = 0) {
    return Bt(this, bt, At, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), oe.prototype.writeFloatLE = function(bt, At, Tt) {
    return wt(this, bt, At, !0, Tt);
  }, oe.prototype.writeFloatBE = function(bt, At, Tt) {
    return wt(this, bt, At, !1, Tt);
  }, oe.prototype.writeDoubleLE = function(bt, At, Tt) {
    return Et(this, bt, At, !0, Tt);
  }, oe.prototype.writeDoubleBE = function(bt, At, Tt) {
    return Et(this, bt, At, !1, Tt);
  }, oe.prototype.copy = function(bt, At, Tt, xt) {
    if (!oe.isBuffer(bt)) throw new TypeError("argument should be a Buffer");
    if (Tt || (Tt = 0), xt || xt === 0 || (xt = this.length), At >= bt.length && (At = bt.length), At || (At = 0), xt > 0 && xt < Tt && (xt = Tt), xt === Tt || bt.length === 0 || this.length === 0) return 0;
    if (At < 0) throw new RangeError("targetStart out of bounds");
    if (Tt < 0 || Tt >= this.length) throw new RangeError("Index out of range");
    if (xt < 0) throw new RangeError("sourceEnd out of bounds");
    xt > this.length && (xt = this.length), bt.length - At < xt - Tt && (xt = bt.length - At + Tt);
    const Nt = xt - Tt;
    return this === bt && typeof J.prototype.copyWithin == "function" ? this.copyWithin(At, Tt, xt) : J.prototype.set.call(bt, this.subarray(Tt, xt), At), Nt;
  }, oe.prototype.fill = function(bt, At, Tt, xt) {
    if (typeof bt == "string") {
      if (typeof At == "string" ? (xt = At, At = 0, Tt = this.length) : typeof Tt == "string" && (xt = Tt, Tt = this.length), xt !== void 0 && typeof xt != "string") throw new TypeError("encoding must be a string");
      if (typeof xt == "string" && !oe.isEncoding(xt)) throw new TypeError("Unknown encoding: " + xt);
      if (bt.length === 1) {
        const Ft = bt.charCodeAt(0);
        (xt === "utf8" && Ft < 128 || xt === "latin1") && (bt = Ft);
      }
    } else typeof bt == "number" ? bt &= 255 : typeof bt == "boolean" && (bt = Number(bt));
    if (At < 0 || this.length < At || this.length < Tt) throw new RangeError("Out of range index");
    if (Tt <= At) return this;
    let Nt;
    if (At >>>= 0, Tt = Tt === void 0 ? this.length : Tt >>> 0, bt || (bt = 0), typeof bt == "number") for (Nt = At; Nt < Tt; ++Nt) this[Nt] = bt;
    else {
      const Ft = oe.isBuffer(bt) ? bt : oe.from(bt, xt), zt = Ft.length;
      if (zt === 0) throw new TypeError('The value "' + bt + '" is invalid for argument "value"');
      for (Nt = 0; Nt < Tt - At; ++Nt) this[Nt + At] = Ft[Nt % zt];
    }
    return this;
  };
  const Rt = {};
  function Mt(bt, At, Tt) {
    Rt[bt] = class extends Tt {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: At.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${bt}]`, this.stack, delete this.name;
      }
      get code() {
        return bt;
      }
      set code(xt) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: xt, writable: !0 });
      }
      toString() {
        return `${this.name} [${bt}]: ${this.message}`;
      }
    };
  }
  function Ht(bt) {
    let At = "", Tt = bt.length;
    const xt = bt[0] === "-" ? 1 : 0;
    for (; Tt >= xt + 4; Tt -= 3) At = `_${bt.slice(Tt - 3, Tt)}${At}`;
    return `${bt.slice(0, Tt)}${At}`;
  }
  function Kt(bt, At, Tt, xt, Nt, Ft) {
    if (bt > Tt || bt < At) {
      const zt = typeof At == "bigint" ? "n" : "";
      let nr;
      throw nr = At === 0 || At === BigInt(0) ? `>= 0${zt} and < 2${zt} ** ${8 * (Ft + 1)}${zt}` : `>= -(2${zt} ** ${8 * (Ft + 1) - 1}${zt}) and < 2 ** ${8 * (Ft + 1) - 1}${zt}`, new Rt.ERR_OUT_OF_RANGE("value", nr, bt);
    }
    (function(zt, nr, lr) {
      jt(nr, "offset"), zt[nr] !== void 0 && zt[nr + lr] !== void 0 || Wt(nr, zt.length - (lr + 1));
    })(xt, Nt, Ft);
  }
  function jt(bt, At) {
    if (typeof bt != "number") throw new Rt.ERR_INVALID_ARG_TYPE(At, "number", bt);
  }
  function Wt(bt, At, Tt) {
    throw Math.floor(bt) !== bt ? (jt(bt, Tt), new Rt.ERR_OUT_OF_RANGE("offset", "an integer", bt)) : At < 0 ? new Rt.ERR_BUFFER_OUT_OF_BOUNDS() : new Rt.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${At}`, bt);
  }
  Mt("ERR_BUFFER_OUT_OF_BOUNDS", function(bt) {
    return bt ? `${bt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), Mt("ERR_INVALID_ARG_TYPE", function(bt, At) {
    return `The "${bt}" argument must be of type number. Received type ${typeof At}`;
  }, TypeError), Mt("ERR_OUT_OF_RANGE", function(bt, At, Tt) {
    let xt = `The value of "${bt}" is out of range.`, Nt = Tt;
    return Number.isInteger(Tt) && Math.abs(Tt) > 2 ** 32 ? Nt = Ht(String(Tt)) : typeof Tt == "bigint" && (Nt = String(Tt), (Tt > BigInt(2) ** BigInt(32) || Tt < -(BigInt(2) ** BigInt(32))) && (Nt = Ht(Nt)), Nt += "n"), xt += ` It must be ${At}. Received ${Nt}`, xt;
  }, RangeError);
  const Yt = /[^+/0-9A-Za-z-_]/g;
  function Xt(bt, At) {
    let Tt;
    At = At || 1 / 0;
    const xt = bt.length;
    let Nt = null;
    const Ft = [];
    for (let zt = 0; zt < xt; ++zt) {
      if (Tt = bt.charCodeAt(zt), Tt > 55295 && Tt < 57344) {
        if (!Nt) {
          if (Tt > 56319) {
            (At -= 3) > -1 && Ft.push(239, 191, 189);
            continue;
          }
          if (zt + 1 === xt) {
            (At -= 3) > -1 && Ft.push(239, 191, 189);
            continue;
          }
          Nt = Tt;
          continue;
        }
        if (Tt < 56320) {
          (At -= 3) > -1 && Ft.push(239, 191, 189), Nt = Tt;
          continue;
        }
        Tt = 65536 + (Nt - 55296 << 10 | Tt - 56320);
      } else Nt && (At -= 3) > -1 && Ft.push(239, 191, 189);
      if (Nt = null, Tt < 128) {
        if ((At -= 1) < 0) break;
        Ft.push(Tt);
      } else if (Tt < 2048) {
        if ((At -= 2) < 0) break;
        Ft.push(Tt >> 6 | 192, 63 & Tt | 128);
      } else if (Tt < 65536) {
        if ((At -= 3) < 0) break;
        Ft.push(Tt >> 12 | 224, Tt >> 6 & 63 | 128, 63 & Tt | 128);
      } else {
        if (!(Tt < 1114112)) throw new Error("Invalid code point");
        if ((At -= 4) < 0) break;
        Ft.push(Tt >> 18 | 240, Tt >> 12 & 63 | 128, Tt >> 6 & 63 | 128, 63 & Tt | 128);
      }
    }
    return Ft;
  }
  function ir(bt) {
    return L.toByteArray(function(At) {
      if ((At = (At = At.split("=")[0]).trim().replace(Yt, "")).length < 2) return "";
      for (; At.length % 4 != 0; ) At += "=";
      return At;
    }(bt));
  }
  function ur(bt, At, Tt, xt) {
    let Nt;
    for (Nt = 0; Nt < xt && !(Nt + Tt >= At.length || Nt >= bt.length); ++Nt) At[Nt + Tt] = bt[Nt];
    return Nt;
  }
  function Qt(bt, At) {
    return bt instanceof At || bt != null && bt.constructor != null && bt.constructor.name != null && bt.constructor.name === At.name;
  }
  function hr(bt) {
    return bt != bt;
  }
  const pr = function() {
    const bt = "0123456789abcdef", At = new Array(256);
    for (let Tt = 0; Tt < 16; ++Tt) {
      const xt = 16 * Tt;
      for (let Nt = 0; Nt < 16; ++Nt) At[xt + Nt] = bt[Tt] + bt[Nt];
    }
    return At;
  }();
  function cr(bt) {
    return typeof BigInt > "u" ? vr : bt;
  }
  function vr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$3 = buffer$1.Buffer, Blob$1 = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$2 = Object.freeze(Object.defineProperty({ __proto__: null, Blob: Blob$1, BlobOptions, Buffer: Buffer$1$1, File, FileOptions, INSPECT_MAX_BYTES, SlowBuffer, TranscodeEncoding, atob, btoa, constants: constants$1, default: Buffer$3, isAscii, isUtf8, kMaxLength, kStringMaxLength, resolveObjectURL, transcode }, Symbol.toStringTag, { value: "Module" }));
var src$4 = {}, address = {}, networks$2 = {};
Object.defineProperty(networks$2, "__esModule", { value: !0 }), networks$2.testnet = networks$2.regtest = networks$2.bitcoin = void 0, networks$2.bitcoin = { messagePrefix: `Bitcoin Signed Message:
`, bech32: "bc", bip32: { public: 76067358, private: 76066276 }, pubKeyHash: 0, scriptHash: 5, wif: 128 }, networks$2.regtest = { messagePrefix: `Bitcoin Signed Message:
`, bech32: "bcrt", bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 }, networks$2.testnet = { messagePrefix: `Bitcoin Signed Message:
`, bech32: "tb", bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 };
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const L = B[3];
  if (L === 0 || 5 + L >= B.length || B[4 + L] !== 2) return !1;
  const K = B[5 + L];
  return !(K === 0 || 6 + L + K !== B.length || 128 & B[4] || L > 1 && B[4] === 0 && !(128 & B[5]) || 128 & B[L + 6] || K > 1 && B[L + 6] === 0 && !(128 & B[L + 7]));
}
function decode$k(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2) throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const L = B[3];
  if (L === 0) throw new Error("R length is zero");
  if (5 + L >= B.length) throw new Error("R length is too long");
  if (B[4 + L] !== 2) throw new Error("Expected DER integer (2)");
  const K = B[5 + L];
  if (K === 0) throw new Error("S length is zero");
  if (6 + L + K !== B.length) throw new Error("S length is invalid");
  if (128 & B[4]) throw new Error("R value is negative");
  if (L > 1 && B[4] === 0 && !(128 & B[5])) throw new Error("R value excessively padded");
  if (128 & B[L + 6]) throw new Error("S value is negative");
  if (K > 1 && B[L + 6] === 0 && !(128 & B[L + 7])) throw new Error("S value excessively padded");
  return { r: B.slice(4, 4 + L), s: B.slice(6 + L) };
}
function encode$k(B, L) {
  const K = B.length, W = L.length;
  if (K === 0) throw new Error("R length is zero");
  if (W === 0) throw new Error("S length is zero");
  if (K > 33) throw new Error("R length is too long");
  if (W > 33) throw new Error("S length is too long");
  if (128 & B[0]) throw new Error("R value is negative");
  if (128 & L[0]) throw new Error("S value is negative");
  if (K > 1 && B[0] === 0 && !(128 & B[1])) throw new Error("R value excessively padded");
  if (W > 1 && L[0] === 0 && !(128 & L[1])) throw new Error("S value excessively padded");
  const V = Buffer$3.allocUnsafe(6 + K + W);
  return V[0] = 48, V[1] = V.length - 2, V[2] = 2, V[3] = B.length, B.copy(V, 4), V[4 + K] = 2, V[5 + K] = L.length, L.copy(V, 6 + K), V;
}
Object.defineProperty(bip66, "__esModule", { value: !0 }), bip66.encode = bip66.decode = bip66.check = void 0, bip66.check = check$d, bip66.decode = decode$k, bip66.encode = encode$k;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 }), ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = { OP_FALSE: 0, OP_0: 0, OP_PUSHDATA1: 76, OP_PUSHDATA2: 77, OP_PUSHDATA4: 78, OP_1NEGATE: 79, OP_RESERVED: 80, OP_TRUE: 81, OP_1: 81, OP_2: 82, OP_3: 83, OP_4: 84, OP_5: 85, OP_6: 86, OP_7: 87, OP_8: 88, OP_9: 89, OP_10: 90, OP_11: 91, OP_12: 92, OP_13: 93, OP_14: 94, OP_15: 95, OP_16: 96, OP_NOP: 97, OP_VER: 98, OP_IF: 99, OP_NOTIF: 100, OP_VERIF: 101, OP_VERNOTIF: 102, OP_ELSE: 103, OP_ENDIF: 104, OP_VERIFY: 105, OP_RETURN: 106, OP_TOALTSTACK: 107, OP_FROMALTSTACK: 108, OP_2DROP: 109, OP_2DUP: 110, OP_3DUP: 111, OP_2OVER: 112, OP_2ROT: 113, OP_2SWAP: 114, OP_IFDUP: 115, OP_DEPTH: 116, OP_DROP: 117, OP_DUP: 118, OP_NIP: 119, OP_OVER: 120, OP_PICK: 121, OP_ROLL: 122, OP_ROT: 123, OP_SWAP: 124, OP_TUCK: 125, OP_CAT: 126, OP_SUBSTR: 127, OP_LEFT: 128, OP_RIGHT: 129, OP_SIZE: 130, OP_INVERT: 131, OP_AND: 132, OP_OR: 133, OP_XOR: 134, OP_EQUAL: 135, OP_EQUALVERIFY: 136, OP_RESERVED1: 137, OP_RESERVED2: 138, OP_1ADD: 139, OP_1SUB: 140, OP_2MUL: 141, OP_2DIV: 142, OP_NEGATE: 143, OP_ABS: 144, OP_NOT: 145, OP_0NOTEQUAL: 146, OP_ADD: 147, OP_SUB: 148, OP_MUL: 149, OP_DIV: 150, OP_MOD: 151, OP_LSHIFT: 152, OP_RSHIFT: 153, OP_BOOLAND: 154, OP_BOOLOR: 155, OP_NUMEQUAL: 156, OP_NUMEQUALVERIFY: 157, OP_NUMNOTEQUAL: 158, OP_LESSTHAN: 159, OP_GREATERTHAN: 160, OP_LESSTHANOREQUAL: 161, OP_GREATERTHANOREQUAL: 162, OP_MIN: 163, OP_MAX: 164, OP_WITHIN: 165, OP_RIPEMD160: 166, OP_SHA1: 167, OP_SHA256: 168, OP_HASH160: 169, OP_HASH256: 170, OP_CODESEPARATOR: 171, OP_CHECKSIG: 172, OP_CHECKSIGVERIFY: 173, OP_CHECKMULTISIG: 174, OP_CHECKMULTISIGVERIFY: 175, OP_NOP1: 176, OP_NOP2: 177, OP_CHECKLOCKTIMEVERIFY: 177, OP_NOP3: 178, OP_CHECKSEQUENCEVERIFY: 178, OP_NOP4: 179, OP_NOP5: 180, OP_NOP6: 181, OP_NOP7: 182, OP_NOP8: 183, OP_NOP9: 184, OP_NOP10: 185, OP_CHECKSIGADD: 186, OP_PUBKEYHASH: 253, OP_PUBKEY: 254, OP_INVALIDOPCODE: 255 };
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const L = OPS$7[B];
  REVERSE_OPS[L] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 }), push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
function encode$j(B, L, K) {
  const W = encodingLength$2(L);
  return W === 1 ? B.writeUInt8(L, K) : W === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, K), B.writeUInt8(L, K + 1)) : W === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, K), B.writeUInt16LE(L, K + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, K), B.writeUInt32LE(L, K + 1)), W;
}
function decode$j(B, L) {
  const K = B.readUInt8(L);
  let W, V;
  if (K < ops_1.OPS.OP_PUSHDATA1) W = K, V = 1;
  else if (K === ops_1.OPS.OP_PUSHDATA1) {
    if (L + 2 > B.length) return null;
    W = B.readUInt8(L + 1), V = 2;
  } else if (K === ops_1.OPS.OP_PUSHDATA2) {
    if (L + 3 > B.length) return null;
    W = B.readUInt16LE(L + 1), V = 3;
  } else {
    if (L + 5 > B.length) return null;
    if (K !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    W = B.readUInt32LE(L + 1), V = 5;
  }
  return { opcode: K, number: W, size: V };
}
push_data.encodingLength = encodingLength$2, push_data.encode = encode$j, push_data.decode = decode$j;
var script_number = {};
function decode$i(B, L, K) {
  L = L || 4, K = K === void 0 || K;
  const W = B.length;
  if (W === 0) return 0;
  if (W > L) throw new TypeError("Script number overflow");
  if (K && !(127 & B[W - 1] || !(W <= 1) && 128 & B[W - 2])) throw new Error("Non-minimally encoded script number");
  if (W === 5) {
    const J = B.readUInt32LE(0), re = B.readUInt8(4);
    return 128 & re ? -(4294967296 * (-129 & re) + J) : 4294967296 * re + J;
  }
  let V = 0;
  for (let J = 0; J < W; ++J) V |= B[J] << 8 * J;
  return 128 & B[W - 1] ? -(V & ~(128 << 8 * (W - 1))) : V;
}
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$i(B) {
  let L = Math.abs(B);
  const K = scriptNumSize(L), W = Buffer$3.allocUnsafe(K), V = B < 0;
  for (let J = 0; J < K; ++J) W.writeUInt8(255 & L, J), L >>= 8;
  return 128 & W[K - 1] ? W.writeUInt8(V ? 128 : 0, K - 1) : V && (W[K - 1] |= 128), W;
}
Object.defineProperty(script_number, "__esModule", { value: !0 }), script_number.encode = script_number.decode = void 0, script_number.decode = decode$i, script_number.encode = encode$i;
var script_signature = {}, types$7 = {};
const require$$1$2 = getAugmentedNamespace(dist$2);
var types$6 = { Array: function(B) {
  return B != null && B.constructor === Array;
}, Boolean: function(B) {
  return typeof B == "boolean";
}, Function: function(B) {
  return typeof B == "function";
}, Nil: function(B) {
  return B == null;
}, Number: function(B) {
  return typeof B == "number";
}, Object: function(B) {
  return typeof B == "object";
}, String: function(B) {
  return typeof B == "string";
}, "": function() {
  return !0;
} };
for (var typeName$1 in types$6.Null = types$6.Nil, types$6) types$6[typeName$1].toJSON = (function(B) {
  return B;
}).bind(null, typeName$1);
var native$1 = types$6, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue$1(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, L) {
  Error.captureStackTrace && Error.captureStackTrace(B, L);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, L, K) {
  var W = getValue$1(L);
  return "Expected " + tfJSON$1(B) + ", got" + (K !== "" ? " " + K : "") + (W !== "" ? " " + W : "");
}
function TfTypeError$1(B, L, K) {
  K = K || getValueTypeName$1(L), this.message = tfErrorString(B, L, K), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = L, this.__valueTypeName = K;
}
function tfPropertyErrorString(B, L, K, W, V) {
  var J = '" of type ';
  return L === "key" && (J = '" with key type '), tfErrorString('property "' + tfJSON$1(K) + J + tfJSON$1(B), W, V);
}
function TfPropertyTypeError$1(B, L, K, W, V) {
  B ? (V = V || getValueTypeName$1(W), this.message = tfPropertyErrorString(B, K, L, W, V)) : this.message = 'Unexpected property "' + L + '"', captureStackTrace(this, TfTypeError$1), this.__label = K, this.__property = L, this.__type = B, this.__value = W, this.__valueTypeName = V;
}
function tfCustomError(B, L) {
  return new TfTypeError$1(B, {}, L);
}
function tfSubError$1(B, L, K) {
  return B instanceof TfPropertyTypeError$1 ? (L = L + "." + B.__property, B = new TfPropertyTypeError$1(B.__type, L, B.__label, B.__value, B.__valueTypeName)) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(B.__type, L, K, B.__value, B.__valueTypeName)), captureStackTrace(B), B;
}
TfTypeError$1.prototype = Object.create(Error.prototype), TfTypeError$1.prototype.constructor = TfTypeError$1, TfPropertyTypeError$1.prototype = Object.create(Error.prototype), TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
var errors$1 = { TfTypeError: TfTypeError$1, TfPropertyTypeError: TfPropertyTypeError$1, tfCustomError, tfSubError: tfSubError$1, tfJSON: tfJSON$1, getValueTypeName: getValueTypeName$1 }, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, L = errors$1;
  function K(ke) {
    return Buffer$3.isBuffer(ke);
  }
  function W(ke) {
    return typeof ke == "string" && /^([0-9a-f]{2})+$/i.test(ke);
  }
  function V(ke, ot) {
    var at = ke.toJSON();
    function ft(dt) {
      if (!ke(dt)) return !1;
      if (dt.length === ot) return !0;
      throw L.tfCustomError(at + "(Length: " + ot + ")", at + "(Length: " + dt.length + ")");
    }
    return ft.toJSON = function() {
      return at;
    }, ft;
  }
  var J = V.bind(null, B.Array), re = V.bind(null, K), ie = V.bind(null, W), ne = V.bind(null, B.String), oe = Math.pow(2, 53) - 1, ce = { ArrayN: J, Buffer: K, BufferN: re, Finite: function(ke) {
    return typeof ke == "number" && isFinite(ke);
  }, Hex: W, HexN: ie, Int8: function(ke) {
    return ke << 24 >> 24 === ke;
  }, Int16: function(ke) {
    return ke << 16 >> 16 === ke;
  }, Int32: function(ke) {
    return (0 | ke) === ke;
  }, Int53: function(ke) {
    return typeof ke == "number" && ke >= -oe && ke <= oe && Math.floor(ke) === ke;
  }, Range: function(ke, ot, at) {
    function ft(dt, lt) {
      return at(dt, lt) && dt > ke && dt < ot;
    }
    return at = at || B.Number, ft.toJSON = function() {
      return `${at.toJSON()} between [${ke}, ${ot}]`;
    }, ft;
  }, StringN: ne, UInt8: function(ke) {
    return (255 & ke) === ke;
  }, UInt16: function(ke) {
    return (65535 & ke) === ke;
  }, UInt32: function(ke) {
    return ke >>> 0 === ke;
  }, UInt53: function(ke) {
    return typeof ke == "number" && ke >= 0 && ke <= oe && Math.floor(ke) === ke;
  } };
  for (var pe in ce) ce[pe].toJSON = (function(ke) {
    return ke;
  }).bind(null, pe);
  return extra = ce;
}
var ERRORS = errors$1, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = { arrayOf: function(B, L) {
  function K(W, V) {
    return !!NATIVE.Array(W) && !NATIVE.Nil(W) && !(L.minLength !== void 0 && W.length < L.minLength) && !(L.maxLength !== void 0 && W.length > L.maxLength) && (L.length === void 0 || W.length === L.length) && W.every(function(J, re) {
      try {
        return typeforce$4(B, J, V);
      } catch (ie) {
        throw tfSubError(ie, re);
      }
    });
  }
  return B = compile(B), L = L || {}, K.toJSON = function() {
    var W = "[" + tfJSON(B) + "]";
    return L.length !== void 0 ? W += "{" + L.length + "}" : L.minLength === void 0 && L.maxLength === void 0 || (W += "{" + (L.minLength === void 0 ? 0 : L.minLength) + "," + (L.maxLength === void 0 ? 1 / 0 : L.maxLength) + "}"), W;
  }, K;
}, maybe: function B(L) {
  function K(W, V) {
    return NATIVE.Nil(W) || L(W, V, B);
  }
  return L = compile(L), K.toJSON = function() {
    return "?" + tfJSON(L);
  }, K;
}, map: function(B, L) {
  function K(W, V) {
    if (!NATIVE.Object(W) || NATIVE.Nil(W)) return !1;
    for (var J in W) {
      try {
        L && typeforce$4(L, J, V);
      } catch (ie) {
        throw tfSubError(ie, J, "key");
      }
      try {
        var re = W[J];
        typeforce$4(B, re, V);
      } catch (ie) {
        throw tfSubError(ie, J);
      }
    }
    return !0;
  }
  return B = compile(B), L && (L = compile(L)), K.toJSON = L ? function() {
    return "{" + tfJSON(L) + ": " + tfJSON(B) + "}";
  } : function() {
    return "{" + tfJSON(B) + "}";
  }, K;
}, object: function(B) {
  var L = {};
  for (var K in B) L[K] = compile(B[K]);
  function W(V, J) {
    if (!NATIVE.Object(V) || NATIVE.Nil(V)) return !1;
    var re;
    try {
      for (re in L) typeforce$4(L[re], V[re], J);
    } catch (ie) {
      throw tfSubError(ie, re);
    }
    if (J) {
      for (re in V) if (!L[re]) throw new TfPropertyTypeError(void 0, re);
    }
    return !0;
  }
  return W.toJSON = function() {
    return tfJSON(L);
  }, W;
}, anyOf: function() {
  var B = [].slice.call(arguments).map(compile);
  function L(K, W) {
    return B.some(function(V) {
      try {
        return typeforce$4(V, K, W);
      } catch {
        return !1;
      }
    });
  }
  return L.toJSON = function() {
    return B.map(tfJSON).join("|");
  }, L;
}, allOf: function() {
  var B = [].slice.call(arguments).map(compile);
  function L(K, W) {
    return B.every(function(V) {
      try {
        return typeforce$4(V, K, W);
      } catch {
        return !1;
      }
    });
  }
  return L.toJSON = function() {
    return B.map(tfJSON).join(" & ");
  }, L;
}, quacksLike: function(B) {
  function L(K) {
    return B === getValueTypeName(K);
  }
  return L.toJSON = function() {
    return B;
  }, L;
}, tuple: function() {
  var B = [].slice.call(arguments).map(compile);
  function L(K, W) {
    return !NATIVE.Nil(K) && !NATIVE.Nil(K.length) && (!W || K.length === B.length) && B.every(function(V, J) {
      try {
        return typeforce$4(V, K[J], W);
      } catch (re) {
        throw tfSubError(re, J);
      }
    });
  }
  return L.toJSON = function() {
    return "(" + B.map(tfJSON).join(", ") + ")";
  }, L;
}, value: function(B) {
  function L(K) {
    return K === B;
  }
  return L.toJSON = function() {
    return B;
  }, L;
} };
function compile(B) {
  if (NATIVE.String(B)) return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  }
  return NATIVE.Function(B) ? B : TYPES.value(B);
}
function typeforce$4(B, L, K, W) {
  if (NATIVE.Function(B)) {
    if (B(L, K)) return !0;
    throw new TfTypeError(W || B, L);
  }
  return typeforce$4(compile(B), L, K);
}
for (var typeName in TYPES.oneOf = TYPES.anyOf, NATIVE) typeforce$4[typeName] = NATIVE[typeName];
for (typeName in TYPES) typeforce$4[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA) typeforce$4[typeName] = EXTRA[typeName];
typeforce$4.compile = compile, typeforce$4.TfTypeError = TfTypeError, typeforce$4.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$4, hasRequiredScript_signature, hasRequiredScript;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, L = requireScript(), K = types$7, { typeforce: W } = K, V = Buffer$3.alloc(1, 0);
  function J(ie) {
    let ne = 0;
    for (; ie[ne] === 0; ) ++ne;
    return ne === ie.length ? V : 128 & (ie = ie.slice(ne))[0] ? Buffer$3.concat([V, ie], 1 + ie.length) : ie;
  }
  function re(ie) {
    ie[0] === 0 && (ie = ie.slice(1));
    const ne = Buffer$3.alloc(32, 0), oe = Math.max(0, 32 - ie.length);
    return ie.copy(ne, oe), ne;
  }
  return script_signature.decode = function(ie) {
    const ne = ie.readUInt8(ie.length - 1);
    if (!(0, L.isDefinedHashType)(ne)) throw new Error("Invalid hashType " + ne);
    const oe = B.decode(ie.slice(0, -1)), ce = re(oe.r), pe = re(oe.s);
    return { signature: Buffer$3.concat([ce, pe], 64), hashType: ne };
  }, script_signature.encode = function(ie, ne) {
    if (W({ signature: K.BufferN(64), hashType: K.UInt8 }, { signature: ie, hashType: ne }), !(0, L.isDefinedHashType)(ne)) throw new Error("Invalid hashType " + ne);
    const oe = Buffer$3.allocUnsafe(1);
    oe.writeUInt8(ne, 0);
    const ce = J(ie.slice(0, 32)), pe = J(ie.slice(32, 64));
    return Buffer$3.concat([B.encode(ce, pe), oe]);
  }, script_signature;
}
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const L = bip66, K = ops;
    Object.defineProperty(B, "OPS", { enumerable: !0, get: function() {
      return K.OPS;
    } });
    const W = push_data, V = script_number, J = requireScript_signature(), re = types$7, { typeforce: ie } = re, ne = K.OPS.OP_RESERVED;
    function oe(lt) {
      return re.Buffer(lt) || function(yt) {
        return re.Number(yt) && (yt === K.OPS.OP_0 || yt >= K.OPS.OP_1 && yt <= K.OPS.OP_16 || yt === K.OPS.OP_1NEGATE);
      }(lt);
    }
    function ce(lt) {
      return re.Array(lt) && lt.every(oe);
    }
    function pe(lt) {
      return lt.length === 0 ? K.OPS.OP_0 : lt.length === 1 ? lt[0] >= 1 && lt[0] <= 16 ? ne + lt[0] : lt[0] === 129 ? K.OPS.OP_1NEGATE : void 0 : void 0;
    }
    function ke(lt) {
      return Buffer$3.isBuffer(lt);
    }
    function ot(lt) {
      return Buffer$3.isBuffer(lt);
    }
    function at(lt) {
      if (ke(lt)) return lt;
      ie(re.Array, lt);
      const yt = lt.reduce(($t, It) => ot(It) ? It.length === 1 && pe(It) !== void 0 ? $t + 1 : $t + W.encodingLength(It.length) + It.length : $t + 1, 0), St = Buffer$3.allocUnsafe(yt);
      let mt = 0;
      if (lt.forEach(($t) => {
        if (ot($t)) {
          const It = pe($t);
          if (It !== void 0) return St.writeUInt8(It, mt), void (mt += 1);
          mt += W.encode(St, $t.length, mt), $t.copy(St, mt), mt += $t.length;
        } else St.writeUInt8($t, mt), mt += 1;
      }), mt !== St.length) throw new Error("Could not decode chunks");
      return St;
    }
    function ft(lt) {
      if (yt = lt, re.Array(yt)) return lt;
      var yt;
      ie(re.Buffer, lt);
      const St = [];
      let mt = 0;
      for (; mt < lt.length; ) {
        const $t = lt[mt];
        if ($t > K.OPS.OP_0 && $t <= K.OPS.OP_PUSHDATA4) {
          const It = W.decode(lt, mt);
          if (It === null || (mt += It.size, mt + It.number > lt.length)) return null;
          const Ut = lt.slice(mt, mt + It.number);
          mt += It.number;
          const ut = pe(Ut);
          ut !== void 0 ? St.push(ut) : St.push(Ut);
        } else St.push($t), mt += 1;
      }
      return St;
    }
    function dt(lt) {
      const yt = -129 & lt;
      return yt > 0 && yt < 4;
    }
    B.isPushOnly = ce, B.countNonPushOnlyOPs = function(lt) {
      return lt.length - lt.filter(oe).length;
    }, B.compile = at, B.decompile = ft, B.toASM = function(lt) {
      if (ke(lt) && (lt = ft(lt)), !lt) throw new Error("Could not convert invalid chunks to ASM");
      return lt.map((yt) => {
        if (ot(yt)) {
          const St = pe(yt);
          if (St === void 0) return yt.toString("hex");
          yt = St;
        }
        return K.REVERSE_OPS[yt];
      }).join(" ");
    }, B.fromASM = function(lt) {
      return ie(re.String, lt), at(lt.split(" ").map((yt) => K.OPS[yt] !== void 0 ? K.OPS[yt] : (ie(re.Hex, yt), Buffer$3.from(yt, "hex"))));
    }, B.toStack = function(lt) {
      return lt = ft(lt), ie(ce, lt), lt.map((yt) => ot(yt) ? yt : yt === K.OPS.OP_0 ? Buffer$3.allocUnsafe(0) : V.encode(yt - ne));
    }, B.isCanonicalPubKey = function(lt) {
      return re.isPoint(lt);
    }, B.isDefinedHashType = dt, B.isCanonicalScriptSignature = function(lt) {
      return !!Buffer$3.isBuffer(lt) && !!dt(lt[lt.length - 1]) && L.check(lt.slice(0, -1));
    }, B.number = V, B.signature = J;
  }(script)), script;
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const L = require$$1$2;
  B.typeforce = typeforce_1;
  const K = L.Buffer.alloc(32, 0), W = L.Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex");
  function V(J) {
    return !(!J || !("output" in J) || !L.Buffer.isBuffer(J.output) || J.version !== void 0 && (J.version & B.TAPLEAF_VERSION_MASK) !== J.version);
  }
  B.stacksEqual = function(J, re) {
    return J.length === re.length && J.every((ie, ne) => ie.equals(re[ne]));
  }, B.isPoint = function(J) {
    if (!L.Buffer.isBuffer(J) || J.length < 33) return !1;
    const re = J[0], ie = J.slice(1, 33);
    if (ie.compare(K) === 0 || ie.compare(W) >= 0) return !1;
    if ((re === 2 || re === 3) && J.length === 33) return !0;
    const ne = J.slice(33);
    return ne.compare(K) !== 0 && !(ne.compare(W) >= 0) && re === 4 && J.length === 65;
  }, B.Satoshi = function(J) {
    return B.typeforce.UInt53(J) && J <= 21e14;
  }, B.TAPLEAF_VERSION_MASK = 254, B.isTapleaf = V, B.isTaptree = function J(re) {
    return (0, B.Array)(re) ? re.length === 2 && re.every((ie) => J(ie)) : V(re);
  }, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$7);
var lazy$7 = {};
function prop(B, L, K) {
  Object.defineProperty(B, L, { configurable: !0, enumerable: !0, get() {
    const W = K.call(this);
    return this[L] = W, W;
  }, set(W) {
    Object.defineProperty(this, L, { configurable: !0, enumerable: !0, value: W, writable: !0 });
  } });
}
function value(B) {
  let L;
  return () => (L !== void 0 || (L = B()), L);
}
Object.defineProperty(lazy$7, "__esModule", { value: !0 }), lazy$7.value = lazy$7.prop = void 0, lazy$7.prop = prop, lazy$7.value = value, Object.defineProperty(embed, "__esModule", { value: !0 }), embed.p2data = void 0;
const networks_1$7 = networks$2, bscript$9 = requireScript(), types_1$7 = types$7, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, L) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$7.typeforce)({ network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object), output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer), data: types_1$7.typeforce.maybe(types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)) }, B);
  const K = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (B.data) return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(K, "data", () => {
    if (B.output) return bscript$9.decompile(B.output).slice(1);
  }), L.validate && B.output) {
    const W = bscript$9.decompile(B.output);
    if (W[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!W.slice(1).every(types_1$7.typeforce.Buffer)) throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, K.data)) throw new TypeError("Data mismatch");
  }
  return Object.assign(K, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 }), p2ms$1.p2ms = void 0;
const networks_1$6 = networks$2, bscript$8 = requireScript(), types_1$6 = types$7, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, L) {
  if (!(B.input || B.output || B.pubkeys && B.m !== void 0 || B.signatures)) throw new TypeError("Not enough data");
  function K(ie) {
    return bscript$8.isCanonicalScriptSignature(ie) || (L.allowIncomplete && ie === OPS$5.OP_0) !== void 0;
  }
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$6.typeforce)({ network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object), m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number), n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number), output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer), pubkeys: types_1$6.typeforce.maybe(types_1$6.typeforce.arrayOf(types_1$6.isPoint)), signatures: types_1$6.typeforce.maybe(types_1$6.typeforce.arrayOf(K)), input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer) }, B);
  const W = { network: B.network || networks_1$6.bitcoin };
  let V = [], J = !1;
  function re(ie) {
    J || (J = !0, V = bscript$8.decompile(ie), W.m = V[0] - OP_INT_BASE, W.n = V[V.length - 2] - OP_INT_BASE, W.pubkeys = V.slice(1, -2));
  }
  if (lazy$5.prop(W, "output", () => {
    if (B.m && W.n && B.pubkeys) return bscript$8.compile([].concat(OP_INT_BASE + B.m, B.pubkeys, OP_INT_BASE + W.n, OPS$5.OP_CHECKMULTISIG));
  }), lazy$5.prop(W, "m", () => {
    if (W.output) return re(W.output), W.m;
  }), lazy$5.prop(W, "n", () => {
    if (W.pubkeys) return W.pubkeys.length;
  }), lazy$5.prop(W, "pubkeys", () => {
    if (B.output) return re(B.output), W.pubkeys;
  }), lazy$5.prop(W, "signatures", () => {
    if (B.input) return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(W, "input", () => {
    if (B.signatures) return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(W, "witness", () => {
    if (W.input) return [];
  }), lazy$5.prop(W, "name", () => {
    if (W.m && W.n) return `p2ms(${W.m} of ${W.n})`;
  }), L.validate) {
    if (B.output) {
      if (re(B.output), !types_1$6.typeforce.Number(V[0])) throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(V[V.length - 2])) throw new TypeError("Output is invalid");
      if (V[V.length - 1] !== OPS$5.OP_CHECKMULTISIG) throw new TypeError("Output is invalid");
      if (W.m <= 0 || W.n > 16 || W.m > W.n || W.n !== V.length - 3) throw new TypeError("Output is invalid");
      if (!W.pubkeys.every((ie) => (0, types_1$6.isPoint)(ie))) throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== W.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== W.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, W.pubkeys)) throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length) throw new TypeError("Pubkey count mismatch");
      if (W.n = B.pubkeys.length, W.n < W.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < W.m) throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > W.m) throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (W.signatures.length === 0 || !W.signatures.every(K)) throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, W.signatures)) throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length) throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(W, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 }), p2pk$1.p2pk = void 0;
const networks_1$5 = networks$2, bscript$7 = requireScript(), types_1$5 = types$7, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, L) {
  if (!(B.input || B.output || B.pubkey || B.input || B.signature)) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$5.typeforce)({ network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object), output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer), pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint), signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature), input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer) }, B);
  const K = lazy$4.value(() => bscript$7.decompile(B.input)), W = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(W, "output", () => {
    if (B.pubkey) return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(W, "pubkey", () => {
    if (B.output) return B.output.slice(1, -1);
  }), lazy$4.prop(W, "signature", () => {
    if (B.input) return K()[0];
  }), lazy$4.prop(W, "input", () => {
    if (B.signature) return bscript$7.compile([B.signature]);
  }), lazy$4.prop(W, "witness", () => {
    if (W.input) return [];
  }), L.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG) throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(W.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(W.pubkey)) throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(W.input)) throw new TypeError("Signature mismatch");
    if (B.input) {
      if (K().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(W.signature)) throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(W, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$5 = {}, ripemd160$1 = {}, _md = {}, _assert = {};
function number$1(B) {
  if (!Number.isSafeInteger(B) || B < 0) throw new Error(`positive integer expected, not ${B}`);
}
function bool(B) {
  if (typeof B != "boolean") throw new Error(`boolean expected, not ${B}`);
}
function isBytes(B) {
  return B instanceof Uint8Array || B != null && typeof B == "object" && B.constructor.name === "Uint8Array";
}
function bytes(B, ...L) {
  if (!isBytes(B)) throw new Error("Uint8Array expected");
  if (L.length > 0 && !L.includes(B.length)) throw new Error(`Uint8Array expected of length ${L}, not of length=${B.length}`);
}
function hash$2(B) {
  if (typeof B != "function" || typeof B.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(B.outputLen), number$1(B.blockLen);
}
function exists(B, L = !0) {
  if (B.destroyed) throw new Error("Hash instance has been destroyed");
  if (L && B.finished) throw new Error("Hash#digest() has already been called");
}
function output(B, L) {
  bytes(B);
  const K = L.outputLen;
  if (B.length < K) throw new Error(`digestInto() expects output buffer of length at least ${K}`);
}
Object.defineProperty(_assert, "__esModule", { value: !0 }), _assert.isBytes = isBytes, _assert.number = number$1, _assert.bool = bool, _assert.bytes = bytes, _assert.hash = hash$2, _assert.exists = exists, _assert.output = output;
const assert$3 = { number: number$1, bool, bytes, hash: hash$2, exists, output };
_assert.default = assert$3;
var utils$5 = {}, crypto$4 = {};
Object.defineProperty(crypto$4, "__esModule", { value: !0 }), crypto$4.crypto = void 0, crypto$4.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.byteSwap = B.isLE = B.rotl = B.rotr = B.createView = B.u32 = B.u8 = void 0, B.isBytes = function(oe) {
    return oe instanceof Uint8Array || oe != null && typeof oe == "object" && oe.constructor.name === "Uint8Array";
  }, B.byteSwap32 = function(oe) {
    for (let ce = 0; ce < oe.length; ce++) oe[ce] = (0, B.byteSwap)(oe[ce]);
  }, B.bytesToHex = function(oe) {
    (0, K.bytes)(oe);
    let ce = "";
    for (let pe = 0; pe < oe.length; pe++) ce += W[oe[pe]];
    return ce;
  }, B.hexToBytes = function(oe) {
    if (typeof oe != "string") throw new Error("hex string expected, got " + typeof oe);
    const ce = oe.length, pe = ce / 2;
    if (ce % 2) throw new Error("padded hex string expected, got unpadded hex of length " + ce);
    const ke = new Uint8Array(pe);
    for (let ot = 0, at = 0; ot < pe; ot++, at += 2) {
      const ft = J(oe.charCodeAt(at)), dt = J(oe.charCodeAt(at + 1));
      if (ft === void 0 || dt === void 0) {
        const lt = oe[at] + oe[at + 1];
        throw new Error('hex string expected, got non-hex character "' + lt + '" at index ' + at);
      }
      ke[ot] = 16 * ft + dt;
    }
    return ke;
  }, B.asyncLoop = async function(oe, ce, pe) {
    let ke = Date.now();
    for (let ot = 0; ot < oe; ot++) {
      pe(ot);
      const at = Date.now() - ke;
      at >= 0 && at < ce || (await (0, B.nextTick)(), ke += at);
    }
  }, B.utf8ToBytes = re, B.toBytes = ie, B.concatBytes = function(...oe) {
    let ce = 0;
    for (let ke = 0; ke < oe.length; ke++) {
      const ot = oe[ke];
      (0, K.bytes)(ot), ce += ot.length;
    }
    const pe = new Uint8Array(ce);
    for (let ke = 0, ot = 0; ke < oe.length; ke++) {
      const at = oe[ke];
      pe.set(at, ot), ot += at.length;
    }
    return pe;
  }, B.checkOpts = function(oe, ce) {
    if (ce !== void 0 && ne.call(ce) !== "[object Object]") throw new Error("Options should be object or undefined");
    return Object.assign(oe, ce);
  }, B.wrapConstructor = function(oe) {
    const ce = (ke) => oe().update(ie(ke)).digest(), pe = oe();
    return ce.outputLen = pe.outputLen, ce.blockLen = pe.blockLen, ce.create = () => oe(), ce;
  }, B.wrapConstructorWithOpts = function(oe) {
    const ce = (ke, ot) => oe(ot).update(ie(ke)).digest(), pe = oe({});
    return ce.outputLen = pe.outputLen, ce.blockLen = pe.blockLen, ce.create = (ke) => oe(ke), ce;
  }, B.wrapXOFConstructorWithOpts = function(oe) {
    const ce = (ke, ot) => oe(ot).update(ie(ke)).digest(), pe = oe({});
    return ce.outputLen = pe.outputLen, ce.blockLen = pe.blockLen, ce.create = (ke) => oe(ke), ce;
  }, B.randomBytes = function(oe = 32) {
    if (L.crypto && typeof L.crypto.getRandomValues == "function") return L.crypto.getRandomValues(new Uint8Array(oe));
    if (L.crypto && typeof L.crypto.randomBytes == "function") return L.crypto.randomBytes(oe);
    throw new Error("crypto.getRandomValues must be defined");
  };
  const L = crypto$4, K = _assert;
  B.u8 = (oe) => new Uint8Array(oe.buffer, oe.byteOffset, oe.byteLength), B.u32 = (oe) => new Uint32Array(oe.buffer, oe.byteOffset, Math.floor(oe.byteLength / 4)), B.createView = (oe) => new DataView(oe.buffer, oe.byteOffset, oe.byteLength), B.rotr = (oe, ce) => oe << 32 - ce | oe >>> ce, B.rotl = (oe, ce) => oe << ce | oe >>> 32 - ce >>> 0, B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, B.byteSwap = (oe) => oe << 24 & 4278190080 | oe << 8 & 16711680 | oe >>> 8 & 65280 | oe >>> 24 & 255, B.byteSwapIfBE = B.isLE ? (oe) => oe : (oe) => (0, B.byteSwap)(oe);
  const W = Array.from({ length: 256 }, (oe, ce) => ce.toString(16).padStart(2, "0")), V = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function J(oe) {
    return oe >= V._0 && oe <= V._9 ? oe - V._0 : oe >= V._A && oe <= V._F ? oe - (V._A - 10) : oe >= V._a && oe <= V._f ? oe - (V._a - 10) : void 0;
  }
  function re(oe) {
    if (typeof oe != "string") throw new Error("utf8ToBytes expected string, got " + typeof oe);
    return new Uint8Array(new TextEncoder().encode(oe));
  }
  function ie(oe) {
    return typeof oe == "string" && (oe = re(oe)), (0, K.bytes)(oe), oe;
  }
  B.nextTick = async () => {
  }, B.Hash = class {
    clone() {
      return this._cloneInto();
    }
  };
  const ne = {}.toString;
}(utils$5), Object.defineProperty(_md, "__esModule", { value: !0 }), _md.HashMD = _md.Maj = _md.Chi = void 0;
const _assert_js_1 = _assert, utils_js_1$4 = utils$5;
function setBigUint64(B, L, K, W) {
  if (typeof B.setBigUint64 == "function") return B.setBigUint64(L, K, W);
  const V = BigInt(32), J = BigInt(4294967295), re = Number(K >> V & J), ie = Number(K & J), ne = W ? 4 : 0, oe = W ? 0 : 4;
  B.setUint32(L + ne, re, W), B.setUint32(L + oe, ie, W);
}
const Chi = (B, L, K) => B & L ^ ~B & K;
_md.Chi = Chi;
const Maj = (B, L, K) => B & L ^ B & K ^ L & K;
_md.Maj = Maj;
class HashMD extends utils_js_1$4.Hash {
  constructor(L, K, W, V) {
    super(), this.blockLen = L, this.outputLen = K, this.padOffset = W, this.isLE = V, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(L), this.view = (0, utils_js_1$4.createView)(this.buffer);
  }
  update(L) {
    (0, _assert_js_1.exists)(this);
    const { view: K, buffer: W, blockLen: V } = this, J = (L = (0, utils_js_1$4.toBytes)(L)).length;
    for (let re = 0; re < J; ) {
      const ie = Math.min(V - this.pos, J - re);
      if (ie !== V) W.set(L.subarray(re, re + ie), this.pos), this.pos += ie, re += ie, this.pos === V && (this.process(K, 0), this.pos = 0);
      else {
        const ne = (0, utils_js_1$4.createView)(L);
        for (; V <= J - re; re += V) this.process(ne, re);
      }
    }
    return this.length += L.length, this.roundClean(), this;
  }
  digestInto(L) {
    (0, _assert_js_1.exists)(this), (0, _assert_js_1.output)(L, this), this.finished = !0;
    const { buffer: K, view: W, blockLen: V, isLE: J } = this;
    let { pos: re } = this;
    K[re++] = 128, this.buffer.subarray(re).fill(0), this.padOffset > V - re && (this.process(W, 0), re = 0);
    for (let pe = re; pe < V; pe++) K[pe] = 0;
    setBigUint64(W, V - 8, BigInt(8 * this.length), J), this.process(W, 0);
    const ie = (0, utils_js_1$4.createView)(L), ne = this.outputLen;
    if (ne % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const oe = ne / 4, ce = this.get();
    if (oe > ce.length) throw new Error("_sha2: outputLen bigger than state");
    for (let pe = 0; pe < oe; pe++) ie.setUint32(4 * pe, ce[pe], J);
  }
  digest() {
    const { buffer: L, outputLen: K } = this;
    this.digestInto(L);
    const W = L.slice(0, K);
    return this.destroy(), W;
  }
  _cloneInto(L) {
    L || (L = new this.constructor()), L.set(...this.get());
    const { blockLen: K, buffer: W, length: V, finished: J, destroyed: re, pos: ie } = this;
    return L.length = V, L.pos = ie, L.finished = J, L.destroyed = re, V % K && L.buffer.set(W), L;
  }
}
_md.HashMD = HashMD, Object.defineProperty(ripemd160$1, "__esModule", { value: !0 }), ripemd160$1.ripemd160 = ripemd160$1.RIPEMD160 = void 0;
const _md_js_1$3 = _md, utils_js_1$3 = utils$5, Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = new Uint8Array(new Array(16).fill(0).map((B, L) => L)), Pi = Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++) for (let L of [idxL, idxR]) L.push(L[B].map((K) => Rho[K]));
const shifts = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((B) => new Uint8Array(B)), shiftsL = idxL.map((B, L) => B.map((K) => shifts[L][K])), shiftsR = idxR.map((B, L) => B.map((K) => shifts[L][K])), Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
function f$1(B, L, K, W) {
  return B === 0 ? L ^ K ^ W : B === 1 ? L & K | ~L & W : B === 2 ? (L | ~K) ^ W : B === 3 ? L & W | K & ~W : L ^ (K | ~W);
}
const R_BUF = new Uint32Array(16);
class RIPEMD160 extends _md_js_1$3.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: L, h1: K, h2: W, h3: V, h4: J } = this;
    return [L, K, W, V, J];
  }
  set(L, K, W, V, J) {
    this.h0 = 0 | L, this.h1 = 0 | K, this.h2 = 0 | W, this.h3 = 0 | V, this.h4 = 0 | J;
  }
  process(L, K) {
    for (let ot = 0; ot < 16; ot++, K += 4) R_BUF[ot] = L.getUint32(K, !0);
    let W = 0 | this.h0, V = W, J = 0 | this.h1, re = J, ie = 0 | this.h2, ne = ie, oe = 0 | this.h3, ce = oe, pe = 0 | this.h4, ke = pe;
    for (let ot = 0; ot < 5; ot++) {
      const at = 4 - ot, ft = Kl[ot], dt = Kr[ot], lt = idxL[ot], yt = idxR[ot], St = shiftsL[ot], mt = shiftsR[ot];
      for (let $t = 0; $t < 16; $t++) {
        const It = (0, utils_js_1$3.rotl)(W + f$1(ot, J, ie, oe) + R_BUF[lt[$t]] + ft, St[$t]) + pe | 0;
        W = pe, pe = oe, oe = 0 | (0, utils_js_1$3.rotl)(ie, 10), ie = J, J = It;
      }
      for (let $t = 0; $t < 16; $t++) {
        const It = (0, utils_js_1$3.rotl)(V + f$1(at, re, ne, ce) + R_BUF[yt[$t]] + dt, mt[$t]) + ke | 0;
        V = ke, ke = ce, ce = 0 | (0, utils_js_1$3.rotl)(ne, 10), ne = re, re = It;
      }
    }
    this.set(this.h1 + ie + ce | 0, this.h2 + oe + ke | 0, this.h3 + pe + V | 0, this.h4 + W + re | 0, this.h0 + J + ne | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160$1.RIPEMD160 = RIPEMD160, ripemd160$1.ripemd160 = (0, utils_js_1$3.wrapConstructor)(() => new RIPEMD160());
var sha1$1 = {};
Object.defineProperty(sha1$1, "__esModule", { value: !0 }), sha1$1.sha1 = sha1$1.SHA1 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA1_IV = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), SHA1_W = new Uint32Array(80);
class SHA1 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = 0 | SHA1_IV[0], this.B = 0 | SHA1_IV[1], this.C = 0 | SHA1_IV[2], this.D = 0 | SHA1_IV[3], this.E = 0 | SHA1_IV[4];
  }
  get() {
    const { A: L, B: K, C: W, D: V, E: J } = this;
    return [L, K, W, V, J];
  }
  set(L, K, W, V, J) {
    this.A = 0 | L, this.B = 0 | K, this.C = 0 | W, this.D = 0 | V, this.E = 0 | J;
  }
  process(L, K) {
    for (let ne = 0; ne < 16; ne++, K += 4) SHA1_W[ne] = L.getUint32(K, !1);
    for (let ne = 16; ne < 80; ne++) SHA1_W[ne] = (0, utils_js_1$2.rotl)(SHA1_W[ne - 3] ^ SHA1_W[ne - 8] ^ SHA1_W[ne - 14] ^ SHA1_W[ne - 16], 1);
    let { A: W, B: V, C: J, D: re, E: ie } = this;
    for (let ne = 0; ne < 80; ne++) {
      let oe, ce;
      ne < 20 ? (oe = (0, _md_js_1$2.Chi)(V, J, re), ce = 1518500249) : ne < 40 ? (oe = V ^ J ^ re, ce = 1859775393) : ne < 60 ? (oe = (0, _md_js_1$2.Maj)(V, J, re), ce = 2400959708) : (oe = V ^ J ^ re, ce = 3395469782);
      const pe = (0, utils_js_1$2.rotl)(W, 5) + oe + ie + ce + SHA1_W[ne] | 0;
      ie = re, re = J, J = (0, utils_js_1$2.rotl)(V, 30), V = W, W = pe;
    }
    W = W + this.A | 0, V = V + this.B | 0, J = J + this.C | 0, re = re + this.D | 0, ie = ie + this.E | 0, this.set(W, V, J, re, ie);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1$1.SHA1 = SHA1, sha1$1.sha1 = (0, utils_js_1$2.wrapConstructor)(() => new SHA1());
var sha256$5 = {};
Object.defineProperty(sha256$5, "__esModule", { value: !0 }), sha256$5.sha224 = sha256$5.sha256 = sha256$5.SHA256 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, SHA256_K = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), SHA256_IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), SHA256_W = new Uint32Array(64);
class SHA256 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = 0 | SHA256_IV[0], this.B = 0 | SHA256_IV[1], this.C = 0 | SHA256_IV[2], this.D = 0 | SHA256_IV[3], this.E = 0 | SHA256_IV[4], this.F = 0 | SHA256_IV[5], this.G = 0 | SHA256_IV[6], this.H = 0 | SHA256_IV[7];
  }
  get() {
    const { A: L, B: K, C: W, D: V, E: J, F: re, G: ie, H: ne } = this;
    return [L, K, W, V, J, re, ie, ne];
  }
  set(L, K, W, V, J, re, ie, ne) {
    this.A = 0 | L, this.B = 0 | K, this.C = 0 | W, this.D = 0 | V, this.E = 0 | J, this.F = 0 | re, this.G = 0 | ie, this.H = 0 | ne;
  }
  process(L, K) {
    for (let pe = 0; pe < 16; pe++, K += 4) SHA256_W[pe] = L.getUint32(K, !1);
    for (let pe = 16; pe < 64; pe++) {
      const ke = SHA256_W[pe - 15], ot = SHA256_W[pe - 2], at = (0, utils_js_1$1.rotr)(ke, 7) ^ (0, utils_js_1$1.rotr)(ke, 18) ^ ke >>> 3, ft = (0, utils_js_1$1.rotr)(ot, 17) ^ (0, utils_js_1$1.rotr)(ot, 19) ^ ot >>> 10;
      SHA256_W[pe] = ft + SHA256_W[pe - 7] + at + SHA256_W[pe - 16] | 0;
    }
    let { A: W, B: V, C: J, D: re, E: ie, F: ne, G: oe, H: ce } = this;
    for (let pe = 0; pe < 64; pe++) {
      const ke = ce + ((0, utils_js_1$1.rotr)(ie, 6) ^ (0, utils_js_1$1.rotr)(ie, 11) ^ (0, utils_js_1$1.rotr)(ie, 25)) + (0, _md_js_1$1.Chi)(ie, ne, oe) + SHA256_K[pe] + SHA256_W[pe] | 0, ot = ((0, utils_js_1$1.rotr)(W, 2) ^ (0, utils_js_1$1.rotr)(W, 13) ^ (0, utils_js_1$1.rotr)(W, 22)) + (0, _md_js_1$1.Maj)(W, V, J) | 0;
      ce = oe, oe = ne, ne = ie, ie = re + ke | 0, re = J, J = V, V = W, W = ke + ot | 0;
    }
    W = W + this.A | 0, V = V + this.B | 0, J = J + this.C | 0, re = re + this.D | 0, ie = ie + this.E | 0, ne = ne + this.F | 0, oe = oe + this.G | 0, ce = ce + this.H | 0, this.set(W, V, J, re, ie, ne, oe, ce);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$5.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
function base$5(B) {
  if (B.length >= 255) throw new TypeError("Alphabet too long");
  for (var L = new Uint8Array(256), K = 0; K < L.length; K++) L[K] = 255;
  for (var W = 0; W < B.length; W++) {
    var V = B.charAt(W), J = V.charCodeAt(0);
    if (L[J] !== 255) throw new TypeError(V + " is ambiguous");
    L[J] = W;
  }
  var re = B.length, ie = B.charAt(0), ne = Math.log(re) / Math.log(256), oe = Math.log(256) / Math.log(re);
  function ce(pe) {
    if (typeof pe != "string") throw new TypeError("Expected String");
    if (pe.length === 0) return new Uint8Array();
    for (var ke = 0, ot = 0, at = 0; pe[ke] === ie; ) ot++, ke++;
    for (var ft = (pe.length - ke) * ne + 1 >>> 0, dt = new Uint8Array(ft); pe[ke]; ) {
      var lt = L[pe.charCodeAt(ke)];
      if (lt === 255) return;
      for (var yt = 0, St = ft - 1; (lt !== 0 || yt < at) && St !== -1; St--, yt++) lt += re * dt[St] >>> 0, dt[St] = lt % 256 >>> 0, lt = lt / 256 >>> 0;
      if (lt !== 0) throw new Error("Non-zero carry");
      at = yt, ke++;
    }
    for (var mt = ft - at; mt !== ft && dt[mt] === 0; ) mt++;
    for (var $t = new Uint8Array(ot + (ft - mt)), It = ot; mt !== ft; ) $t[It++] = dt[mt++];
    return $t;
  }
  return { encode: function(pe) {
    if (pe instanceof Uint8Array || (ArrayBuffer.isView(pe) ? pe = new Uint8Array(pe.buffer, pe.byteOffset, pe.byteLength) : Array.isArray(pe) && (pe = Uint8Array.from(pe))), !(pe instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (pe.length === 0) return "";
    for (var ke = 0, ot = 0, at = 0, ft = pe.length; at !== ft && pe[at] === 0; ) at++, ke++;
    for (var dt = (ft - at) * oe + 1 >>> 0, lt = new Uint8Array(dt); at !== ft; ) {
      for (var yt = pe[at], St = 0, mt = dt - 1; (yt !== 0 || St < ot) && mt !== -1; mt--, St++) yt += 256 * lt[mt] >>> 0, lt[mt] = yt % re >>> 0, yt = yt / re >>> 0;
      if (yt !== 0) throw new Error("Non-zero carry");
      ot = St, at++;
    }
    for (var $t = dt - ot; $t !== dt && lt[$t] === 0; ) $t++;
    for (var It = ie.repeat(ke); $t < dt; ++$t) It += B.charAt(lt[$t]);
    return It;
  }, decodeUnsafe: ce, decode: function(pe) {
    var ke = ce(pe);
    if (ke) return ke;
    throw new Error("Non-base" + re + " character");
  } };
}
sha256$5.sha256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA256()), sha256$5.sha224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA224()), function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const L = ripemd160$1, K = sha1$1, W = sha256$5;
  function V(J) {
    return Buffer$3.from((0, W.sha256)(Uint8Array.from(J)));
  }
  B.ripemd160 = function(J) {
    return Buffer$3.from((0, L.ripemd160)(Uint8Array.from(J)));
  }, B.sha1 = function(J) {
    return Buffer$3.from((0, K.sha1)(Uint8Array.from(J)));
  }, B.sha256 = V, B.hash160 = function(J) {
    return Buffer$3.from((0, L.ripemd160)((0, W.sha256)(Uint8Array.from(J))));
  }, B.hash256 = function(J) {
    return Buffer$3.from((0, W.sha256)((0, W.sha256)(Uint8Array.from(J))));
  }, B.TAGS = ["BIP0340/challenge", "BIP0340/aux", "BIP0340/nonce", "TapLeaf", "TapBranch", "TapSighash", "TapTweak", "KeyAgg list", "KeyAgg coefficient"], B.TAGGED_HASH_PREFIXES = { "BIP0340/challenge": Buffer$3.from([123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124]), "BIP0340/aux": Buffer$3.from([241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144]), "BIP0340/nonce": Buffer$3.from([7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47]), TapLeaf: Buffer$3.from([174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238]), TapBranch: Buffer$3.from([25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21]), TapSighash: Buffer$3.from([244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49]), TapTweak: Buffer$3.from([232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233]), "KeyAgg list": Buffer$3.from([72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240]), "KeyAgg coefficient": Buffer$3.from([191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129]) }, B.taggedHash = function(J, re) {
    return V(Buffer$3.concat([B.TAGGED_HASH_PREFIXES[J], re]));
  };
}(crypto$5);
var src$3 = base$5;
const basex$1 = src$3, ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$1 = basex$1(ALPHABET$2), base58$1 = bs58$1, base$4 = function(B) {
  function L(K) {
    var W = K.slice(0, -4), V = K.slice(-4), J = B(W);
    if (!(V[0] ^ J[0] | V[1] ^ J[1] | V[2] ^ J[2] | V[3] ^ J[3])) return W;
  }
  return { encode: function(K) {
    var W = Uint8Array.from(K), V = B(W), J = W.length + 4, re = new Uint8Array(J);
    return re.set(W, 0), re.set(V.subarray(0, 4), W.length), base58$1.encode(re, J);
  }, decode: function(K) {
    var W = L(base58$1.decode(K));
    if (!W) throw new Error("Invalid checksum");
    return W;
  }, decodeUnsafe: function(K) {
    var W = base58$1.decodeUnsafe(K);
    if (W) return L(W);
  } };
}, { sha256: sha256$4 } = sha256$5, bs58checkBase$1 = base$4;
function sha256x2$1(B) {
  return sha256$4(sha256$4(B));
}
var bs58check$5 = bs58checkBase$1(sha256x2$1);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 }), p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$5, networks_1$4 = networks$2, bscript$6 = requireScript(), types_1$4 = types$7, lazy$3 = lazy$7, bs58check$4 = bs58check$5, OPS$3 = bscript$6.OPS;
function p2pkh(B, L) {
  if (!(B.address || B.hash || B.output || B.pubkey || B.input)) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$4.typeforce)({ network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object), address: types_1$4.typeforce.maybe(types_1$4.typeforce.String), hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)), output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)), pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint), signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature), input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer) }, B);
  const K = lazy$3.value(() => {
    const re = Buffer$3.from(bs58check$4.decode(B.address));
    return { version: re.readUInt8(0), hash: re.slice(1) };
  }), W = lazy$3.value(() => bscript$6.decompile(B.input)), V = B.network || networks_1$4.bitcoin, J = { name: "p2pkh", network: V };
  if (lazy$3.prop(J, "address", () => {
    if (!J.hash) return;
    const re = Buffer$3.allocUnsafe(21);
    return re.writeUInt8(V.pubKeyHash, 0), J.hash.copy(re, 1), bs58check$4.encode(re);
  }), lazy$3.prop(J, "hash", () => B.output ? B.output.slice(3, 23) : B.address ? K().hash : B.pubkey || J.pubkey ? bcrypto$5.hash160(B.pubkey || J.pubkey) : void 0), lazy$3.prop(J, "output", () => {
    if (J.hash) return bscript$6.compile([OPS$3.OP_DUP, OPS$3.OP_HASH160, J.hash, OPS$3.OP_EQUALVERIFY, OPS$3.OP_CHECKSIG]);
  }), lazy$3.prop(J, "pubkey", () => {
    if (B.input) return W()[1];
  }), lazy$3.prop(J, "signature", () => {
    if (B.input) return W()[0];
  }), lazy$3.prop(J, "input", () => {
    if (B.pubkey && B.signature) return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(J, "witness", () => {
    if (J.input) return [];
  }), L.validate) {
    let re = Buffer$3.from([]);
    if (B.address) {
      if (K().version !== V.pubKeyHash) throw new TypeError("Invalid version or Network mismatch");
      if (K().hash.length !== 20) throw new TypeError("Invalid address");
      re = K().hash;
    }
    if (B.hash) {
      if (re.length > 0 && !re.equals(B.hash)) throw new TypeError("Hash mismatch");
      re = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG) throw new TypeError("Output is invalid");
      const ie = B.output.slice(3, 23);
      if (re.length > 0 && !re.equals(ie)) throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (B.pubkey) {
      const ie = bcrypto$5.hash160(B.pubkey);
      if (re.length > 0 && !re.equals(ie)) throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (B.input) {
      const ie = W();
      if (ie.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ie[0])) throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ie[1])) throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(ie[0])) throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(ie[1])) throw new TypeError("Pubkey mismatch");
      const ne = bcrypto$5.hash160(ie[1]);
      if (re.length > 0 && !re.equals(ne)) throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(J, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 }), p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$5, networks_1$3 = networks$2, bscript$5 = requireScript(), types_1$3 = types$7, lazy$2 = lazy$7, bs58check$3 = bs58check$5, OPS$2 = bscript$5.OPS;
function p2sh(B, L) {
  if (!(B.address || B.hash || B.output || B.redeem || B.input)) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$3.typeforce)({ network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object), address: types_1$3.typeforce.maybe(types_1$3.typeforce.String), hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)), output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)), redeem: types_1$3.typeforce.maybe({ network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object), output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer), input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer), witness: types_1$3.typeforce.maybe(types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)) }), input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer), witness: types_1$3.typeforce.maybe(types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)) }, B);
  let K = B.network;
  K || (K = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const W = { network: K }, V = lazy$2.value(() => {
    const ie = Buffer$3.from(bs58check$3.decode(B.address));
    return { version: ie.readUInt8(0), hash: ie.slice(1) };
  }), J = lazy$2.value(() => bscript$5.decompile(B.input)), re = lazy$2.value(() => {
    const ie = J(), ne = ie[ie.length - 1];
    return { network: K, output: ne === OPS$2.OP_FALSE ? Buffer$3.from([]) : ne, input: bscript$5.compile(ie.slice(0, -1)), witness: B.witness || [] };
  });
  if (lazy$2.prop(W, "address", () => {
    if (!W.hash) return;
    const ie = Buffer$3.allocUnsafe(21);
    return ie.writeUInt8(W.network.scriptHash, 0), W.hash.copy(ie, 1), bs58check$3.encode(ie);
  }), lazy$2.prop(W, "hash", () => B.output ? B.output.slice(2, 22) : B.address ? V().hash : W.redeem && W.redeem.output ? bcrypto$4.hash160(W.redeem.output) : void 0), lazy$2.prop(W, "output", () => {
    if (W.hash) return bscript$5.compile([OPS$2.OP_HASH160, W.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(W, "redeem", () => {
    if (B.input) return re();
  }), lazy$2.prop(W, "input", () => {
    if (B.redeem && B.redeem.input && B.redeem.output) return bscript$5.compile([].concat(bscript$5.decompile(B.redeem.input), B.redeem.output));
  }), lazy$2.prop(W, "witness", () => W.redeem && W.redeem.witness ? W.redeem.witness : W.input ? [] : void 0), lazy$2.prop(W, "name", () => {
    const ie = ["p2sh"];
    return W.redeem !== void 0 && W.redeem.name !== void 0 && ie.push(W.redeem.name), ie.join("-");
  }), L.validate) {
    let ie = Buffer$3.from([]);
    if (B.address) {
      if (V().version !== K.scriptHash) throw new TypeError("Invalid version or Network mismatch");
      if (V().hash.length !== 20) throw new TypeError("Invalid address");
      ie = V().hash;
    }
    if (B.hash) {
      if (ie.length > 0 && !ie.equals(B.hash)) throw new TypeError("Hash mismatch");
      ie = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL) throw new TypeError("Output is invalid");
      const oe = B.output.slice(2, 22);
      if (ie.length > 0 && !ie.equals(oe)) throw new TypeError("Hash mismatch");
      ie = oe;
    }
    const ne = (oe) => {
      if (oe.output) {
        const ce = bscript$5.decompile(oe.output);
        if (!ce || ce.length < 1) throw new TypeError("Redeem.output too short");
        if (oe.output.byteLength > 520) throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
        if (bscript$5.countNonPushOnlyOPs(ce) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
        const pe = bcrypto$4.hash160(oe.output);
        if (ie.length > 0 && !ie.equals(pe)) throw new TypeError("Hash mismatch");
        ie = pe;
      }
      if (oe.input) {
        const ce = oe.input.length > 0, pe = oe.witness && oe.witness.length > 0;
        if (!ce && !pe) throw new TypeError("Empty input");
        if (ce && pe) throw new TypeError("Input and witness provided");
        if (ce) {
          const ke = bscript$5.decompile(oe.input);
          if (!bscript$5.isPushOnly(ke)) throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const oe = J();
      if (!oe || oe.length < 1) throw new TypeError("Input too short");
      if (!Buffer$3.isBuffer(re().output)) throw new TypeError("Input is invalid");
      ne(re());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== K) throw new TypeError("Network mismatch");
      if (B.input) {
        const oe = re();
        if (B.redeem.output && !B.redeem.output.equals(oe.output)) throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(oe.input)) throw new TypeError("Redeem.input mismatch");
      }
      ne(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness)) throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(W, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: !0 }), dist$1.bech32m = dist$1.bech32 = void 0;
const ALPHABET$1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET$1.length; B++) {
  const L = ALPHABET$1.charAt(B);
  ALPHABET_MAP[L] = B;
}
function polymodStep(B) {
  const L = B >> 25;
  return (33554431 & B) << 5 ^ 996825010 & -(1 & L) ^ 642813549 & -(L >> 1 & 1) ^ 513874426 & -(L >> 2 & 1) ^ 1027748829 & -(L >> 3 & 1) ^ 705979059 & -(L >> 4 & 1);
}
function prefixChk(B) {
  let L = 1;
  for (let K = 0; K < B.length; ++K) {
    const W = B.charCodeAt(K);
    if (W < 33 || W > 126) return "Invalid prefix (" + B + ")";
    L = polymodStep(L) ^ W >> 5;
  }
  L = polymodStep(L);
  for (let K = 0; K < B.length; ++K) {
    const W = B.charCodeAt(K);
    L = polymodStep(L) ^ 31 & W;
  }
  return L;
}
function convert$2(B, L, K, W) {
  let V = 0, J = 0;
  const re = (1 << K) - 1, ie = [];
  for (let ne = 0; ne < B.length; ++ne) for (V = V << L | B[ne], J += L; J >= K; ) J -= K, ie.push(V >> J & re);
  if (W) J > 0 && ie.push(V << K - J & re);
  else {
    if (J >= L) return "Excess padding";
    if (V << K - J & re) return "Non-zero padding";
  }
  return ie;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const L = convert$2(B, 5, 8, !1);
  if (Array.isArray(L)) return L;
}
function fromWords(B) {
  const L = convert$2(B, 5, 8, !1);
  if (Array.isArray(L)) return L;
  throw new Error(L);
}
function getLibraryFromEncoding(B) {
  let L;
  function K(W, V) {
    if (V = V || 90, W.length < 8) return W + " too short";
    if (W.length > V) return "Exceeds length limit";
    const J = W.toLowerCase(), re = W.toUpperCase();
    if (W !== J && W !== re) return "Mixed-case string " + W;
    const ie = (W = J).lastIndexOf("1");
    if (ie === -1) return "No separator character for " + W;
    if (ie === 0) return "Missing prefix for " + W;
    const ne = W.slice(0, ie), oe = W.slice(ie + 1);
    if (oe.length < 6) return "Data too short";
    let ce = prefixChk(ne);
    if (typeof ce == "string") return ce;
    const pe = [];
    for (let ke = 0; ke < oe.length; ++ke) {
      const ot = oe.charAt(ke), at = ALPHABET_MAP[ot];
      if (at === void 0) return "Unknown character " + ot;
      ce = polymodStep(ce) ^ at, ke + 6 >= oe.length || pe.push(at);
    }
    return ce !== L ? "Invalid checksum for " + W : { prefix: ne, words: pe };
  }
  return L = B === "bech32" ? 1 : 734539939, { decodeUnsafe: function(W, V) {
    const J = K(W, V);
    if (typeof J == "object") return J;
  }, decode: function(W, V) {
    const J = K(W, V);
    if (typeof J == "object") return J;
    throw new Error(J);
  }, encode: function(W, V, J) {
    if (J = J || 90, W.length + 7 + V.length > J) throw new TypeError("Exceeds length limit");
    let re = prefixChk(W = W.toLowerCase());
    if (typeof re == "string") throw new Error(re);
    let ie = W + "1";
    for (let ne = 0; ne < V.length; ++ne) {
      const oe = V[ne];
      if (oe >> 5) throw new Error("Non 5-bit word");
      re = polymodStep(re) ^ oe, ie += ALPHABET$1.charAt(oe);
    }
    for (let ne = 0; ne < 6; ++ne) re = polymodStep(re);
    re ^= L;
    for (let ne = 0; ne < 6; ++ne) {
      const oe = re >> 5 * (5 - ne) & 31;
      ie += ALPHABET$1.charAt(oe);
    }
    return ie;
  }, toWords, fromWordsUnsafe, fromWords };
}
dist$1.bech32 = getLibraryFromEncoding("bech32"), dist$1.bech32m = getLibraryFromEncoding("bech32m"), Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 }), p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$5, networks_1$2 = networks$2, bscript$4 = requireScript(), types_1$2 = types$7, lazy$1 = lazy$7, bech32_1$1 = dist$1, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$3.alloc(0);
function p2wpkh(B, L) {
  if (!(B.address || B.hash || B.output || B.pubkey || B.witness)) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$2.typeforce)({ address: types_1$2.typeforce.maybe(types_1$2.typeforce.String), hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)), input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)), network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object), output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)), pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint), signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature), witness: types_1$2.typeforce.maybe(types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)) }, B);
  const K = lazy$1.value(() => {
    const J = bech32_1$1.bech32.decode(B.address), re = J.words.shift(), ie = bech32_1$1.bech32.fromWords(J.words);
    return { version: re, prefix: J.prefix, data: Buffer$3.from(ie) };
  }), W = B.network || networks_1$2.bitcoin, V = { name: "p2wpkh", network: W };
  if (lazy$1.prop(V, "address", () => {
    if (!V.hash) return;
    const J = bech32_1$1.bech32.toWords(V.hash);
    return J.unshift(0), bech32_1$1.bech32.encode(W.bech32, J);
  }), lazy$1.prop(V, "hash", () => B.output ? B.output.slice(2, 22) : B.address ? K().data : B.pubkey || V.pubkey ? bcrypto$3.hash160(B.pubkey || V.pubkey) : void 0), lazy$1.prop(V, "output", () => {
    if (V.hash) return bscript$4.compile([OPS$1.OP_0, V.hash]);
  }), lazy$1.prop(V, "pubkey", () => B.pubkey ? B.pubkey : B.witness ? B.witness[1] : void 0), lazy$1.prop(V, "signature", () => {
    if (B.witness) return B.witness[0];
  }), lazy$1.prop(V, "input", () => {
    if (V.witness) return EMPTY_BUFFER$2;
  }), lazy$1.prop(V, "witness", () => {
    if (B.pubkey && B.signature) return [B.signature, B.pubkey];
  }), L.validate) {
    let J = Buffer$3.from([]);
    if (B.address) {
      if (W && W.bech32 !== K().prefix) throw new TypeError("Invalid prefix or Network mismatch");
      if (K().version !== 0) throw new TypeError("Invalid address version");
      if (K().data.length !== 20) throw new TypeError("Invalid address data");
      J = K().data;
    }
    if (B.hash) {
      if (J.length > 0 && !J.equals(B.hash)) throw new TypeError("Hash mismatch");
      J = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20) throw new TypeError("Output is invalid");
      if (J.length > 0 && !J.equals(B.output.slice(2))) throw new TypeError("Hash mismatch");
      J = B.output.slice(2);
    }
    if (B.pubkey) {
      const re = bcrypto$3.hash160(B.pubkey);
      if (J.length > 0 && !J.equals(re)) throw new TypeError("Hash mismatch");
      if (J = re, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33) throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0])) throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33) throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0])) throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1])) throw new TypeError("Pubkey mismatch");
      const re = bcrypto$3.hash160(B.witness[1]);
      if (J.length > 0 && !J.equals(re)) throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(V, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 }), p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$5, networks_1$1 = networks$2, bscript$3 = requireScript(), types_1$1 = types$7, lazy = lazy$7, bech32_1 = dist$1, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$3.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !(!Buffer$3.isBuffer(B) || B.length !== 65 || B[0] !== 4 || !(0, types_1$1.isPoint)(B));
}
function p2wsh(B, L) {
  if (!(B.address || B.hash || B.output || B.redeem || B.witness)) throw new TypeError("Not enough data");
  L = Object.assign({ validate: !0 }, L || {}), (0, types_1$1.typeforce)({ network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object), address: types_1$1.typeforce.maybe(types_1$1.typeforce.String), hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)), output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)), redeem: types_1$1.typeforce.maybe({ input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer), network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object), output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer), witness: types_1$1.typeforce.maybe(types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)) }), input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)), witness: types_1$1.typeforce.maybe(types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)) }, B);
  const K = lazy.value(() => {
    const re = bech32_1.bech32.decode(B.address), ie = re.words.shift(), ne = bech32_1.bech32.fromWords(re.words);
    return { version: ie, prefix: re.prefix, data: Buffer$3.from(ne) };
  }), W = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let V = B.network;
  V || (V = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const J = { network: V };
  if (lazy.prop(J, "address", () => {
    if (!J.hash) return;
    const re = bech32_1.bech32.toWords(J.hash);
    return re.unshift(0), bech32_1.bech32.encode(V.bech32, re);
  }), lazy.prop(J, "hash", () => B.output ? B.output.slice(2) : B.address ? K().data : J.redeem && J.redeem.output ? bcrypto$2.sha256(J.redeem.output) : void 0), lazy.prop(J, "output", () => {
    if (J.hash) return bscript$3.compile([OPS.OP_0, J.hash]);
  }), lazy.prop(J, "redeem", () => {
    if (B.witness) return { output: B.witness[B.witness.length - 1], input: EMPTY_BUFFER$1, witness: B.witness.slice(0, -1) };
  }), lazy.prop(J, "input", () => {
    if (J.witness) return EMPTY_BUFFER$1;
  }), lazy.prop(J, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const re = bscript$3.toStack(W());
      return J.redeem = Object.assign({ witness: re }, B.redeem), J.redeem.input = EMPTY_BUFFER$1, [].concat(re, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness) return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(J, "name", () => {
    const re = ["p2wsh"];
    return J.redeem !== void 0 && J.redeem.name !== void 0 && re.push(J.redeem.name), re.join("-");
  }), L.validate) {
    let re = Buffer$3.from([]);
    if (B.address) {
      if (K().prefix !== V.bech32) throw new TypeError("Invalid prefix or Network mismatch");
      if (K().version !== 0) throw new TypeError("Invalid address version");
      if (K().data.length !== 32) throw new TypeError("Invalid address data");
      re = K().data;
    }
    if (B.hash) {
      if (re.length > 0 && !re.equals(B.hash)) throw new TypeError("Hash mismatch");
      re = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32) throw new TypeError("Output is invalid");
      const ie = B.output.slice(2);
      if (re.length > 0 && !re.equals(ie)) throw new TypeError("Hash mismatch");
      re = ie;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== V) throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0) throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const ie = bscript$3.decompile(B.redeem.output);
        if (!ie || ie.length < 1) throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600) throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
        if (bscript$3.countNonPushOnlyOPs(ie) > 201) throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
        const ne = bcrypto$2.sha256(B.redeem.output);
        if (re.length > 0 && !re.equals(ne)) throw new TypeError("Hash mismatch");
        re = ne;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(W())) throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness)) throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && W().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(chunkHasUncompressedPubkey)) throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
    }
    if (B.witness && B.witness.length > 0) {
      const ie = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(ie)) throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ie) || []).some(chunkHasUncompressedPubkey)) throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(J, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 }), ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib) throw new Error("No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance");
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.initEccLib = initEccLib, ecc_lib.getEccLib = getEccLib;
const h$3 = (B) => Buffer$3.from(B, "hex");
function verifyEcc(B) {
  assert$2(typeof B.isXOnlyPoint == "function"), assert$2(B.isXOnlyPoint(h$3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$2(B.isXOnlyPoint(h$3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e"))), assert$2(B.isXOnlyPoint(h$3("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9"))), assert$2(B.isXOnlyPoint(h$3("0000000000000000000000000000000000000000000000000000000000000001"))), assert$2(!B.isXOnlyPoint(h$3("0000000000000000000000000000000000000000000000000000000000000000"))), assert$2(!B.isXOnlyPoint(h$3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"))), assert$2(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((L) => {
    const K = B.xOnlyPointAddTweak(h$3(L.pubkey), h$3(L.tweak));
    L.result === null ? assert$2(K === null) : (assert$2(K !== null), assert$2(K.parity === L.parity), assert$2(Buffer$3.from(K.xOnlyPubkey).equals(h$3(L.result))));
  });
}
function assert$2(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [{ pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140", parity: -1, result: null }, { pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b", tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac", parity: 1, result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf" }, { pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991", tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47", parity: 0, result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c" }];
var bip341 = {}, bufferutils = {}, safeBuffer$1 = { exports: {} };
(function(B, L) {
  var K = require$$1$2, W = K.Buffer;
  function V(re, ie) {
    for (var ne in re) ie[ne] = re[ne];
  }
  function J(re, ie, ne) {
    return W(re, ie, ne);
  }
  W.from && W.alloc && W.allocUnsafe && W.allocUnsafeSlow ? B.exports = K : (V(K, L), L.Buffer = J), J.prototype = Object.create(W.prototype), V(W, J), J.from = function(re, ie, ne) {
    if (typeof re == "number") throw new TypeError("Argument must not be a number");
    return W(re, ie, ne);
  }, J.alloc = function(re, ie, ne) {
    if (typeof re != "number") throw new TypeError("Argument must be a number");
    var oe = W(re);
    return ie !== void 0 ? typeof ne == "string" ? oe.fill(ie, ne) : oe.fill(ie) : oe.fill(0), oe;
  }, J.allocUnsafe = function(re) {
    if (typeof re != "number") throw new TypeError("Argument must be a number");
    return W(re);
  }, J.allocUnsafeSlow = function(re) {
    if (typeof re != "number") throw new TypeError("Argument must be a number");
    return K.SlowBuffer(re);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, Buffer$2 = safeBufferExports.Buffer, MAX_SAFE_INTEGER$2 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$2 || B % 1 != 0) throw new RangeError("value out of range");
}
function encode$h(B, L, K) {
  if (checkUInt53$1(B), L || (L = Buffer$2.allocUnsafe(encodingLength$1(B))), !Buffer$2.isBuffer(L)) throw new TypeError("buffer must be a Buffer instance");
  return K || (K = 0), B < 253 ? (L.writeUInt8(B, K), encode$h.bytes = 1) : B <= 65535 ? (L.writeUInt8(253, K), L.writeUInt16LE(B, K + 1), encode$h.bytes = 3) : B <= 4294967295 ? (L.writeUInt8(254, K), L.writeUInt32LE(B, K + 1), encode$h.bytes = 5) : (L.writeUInt8(255, K), L.writeUInt32LE(B >>> 0, K + 1), L.writeUInt32LE(B / 4294967296 | 0, K + 5), encode$h.bytes = 9), L;
}
function decode$h(B, L) {
  if (!Buffer$2.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  L || (L = 0);
  var K = B.readUInt8(L);
  if (K < 253) return decode$h.bytes = 1, K;
  if (K === 253) return decode$h.bytes = 3, B.readUInt16LE(L + 1);
  if (K === 254) return decode$h.bytes = 5, B.readUInt32LE(L + 1);
  decode$h.bytes = 9;
  var W = B.readUInt32LE(L + 1), V = 4294967296 * B.readUInt32LE(L + 5) + W;
  return checkUInt53$1(V), V;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$h, decode: decode$h, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 }), bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$5 = types$7, { typeforce: typeforce$3 } = types$5, varuint$7 = varuintBitcoin;
function verifuint$1(B, L) {
  if (typeof B != "number") throw new Error("cannot write a non-number as a number");
  if (B < 0) throw new Error("specified a negative value for writing an unsigned value");
  if (B > L) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B) throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, L) {
  const K = B.readUInt32LE(L);
  let W = B.readUInt32LE(L + 4);
  return W *= 4294967296, verifuint$1(W + K, 9007199254740991), W + K;
}
function writeUInt64LE$1(B, L, K) {
  return verifuint$1(L, 9007199254740991), B.writeInt32LE(-1 & L, K), B.writeUInt32LE(Math.floor(L / 4294967296), K + 4), K + 8;
}
function reverseBuffer$2(B) {
  if (B.length < 1) return B;
  let L = B.length - 1, K = 0;
  for (let W = 0; W < B.length / 2; W++) K = B[W], B[W] = B[L], B[L] = K, L--;
  return B;
}
function cloneBuffer(B) {
  const L = Buffer$3.allocUnsafe(B.length);
  return B.copy(L), L;
}
bufferutils.varuint = varuint$7, bufferutils.readUInt64LE = readUInt64LE$1, bufferutils.writeUInt64LE = writeUInt64LE$1, bufferutils.reverseBuffer = reverseBuffer$2, bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(L) {
    return new BufferWriter(Buffer$3.alloc(L));
  }
  constructor(L, K = 0) {
    this.buffer = L, this.offset = K, typeforce$3(types$5.tuple(types$5.Buffer, types$5.UInt32), [L, K]);
  }
  writeUInt8(L) {
    this.offset = this.buffer.writeUInt8(L, this.offset);
  }
  writeInt32(L) {
    this.offset = this.buffer.writeInt32LE(L, this.offset);
  }
  writeUInt32(L) {
    this.offset = this.buffer.writeUInt32LE(L, this.offset);
  }
  writeUInt64(L) {
    this.offset = writeUInt64LE$1(this.buffer, L, this.offset);
  }
  writeVarInt(L) {
    varuint$7.encode(L, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(L) {
    if (this.buffer.length < this.offset + L.length) throw new Error("Cannot write slice out of bounds");
    this.offset += L.copy(this.buffer, this.offset);
  }
  writeVarSlice(L) {
    this.writeVarInt(L.length), this.writeSlice(L);
  }
  writeVector(L) {
    this.writeVarInt(L.length), L.forEach((K) => this.writeVarSlice(K));
  }
  end() {
    if (this.buffer.length === this.offset) return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(L, K = 0) {
    this.buffer = L, this.offset = K, typeforce$3(types$5.tuple(types$5.Buffer, types$5.UInt32), [L, K]);
  }
  readUInt8() {
    const L = this.buffer.readUInt8(this.offset);
    return this.offset++, L;
  }
  readInt32() {
    const L = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, L;
  }
  readUInt32() {
    const L = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, L;
  }
  readUInt64() {
    const L = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, L;
  }
  readVarInt() {
    const L = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, L;
  }
  readSlice(L) {
    if (this.buffer.length < this.offset + L) throw new Error("Cannot read slice out of bounds");
    const K = this.buffer.slice(this.offset, this.offset + L);
    return this.offset += L, K;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const L = this.readVarInt(), K = [];
    for (let W = 0; W < L; W++) K.push(this.readVarSlice());
    return K;
  }
}
var hasRequiredP2tr, hasRequiredPayments, hasRequiredAddress;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = require$$1$2, L = networks$2, K = requireScript(), W = types$7, V = ecc_lib, J = bip341, re = lazy$7, ie = dist$1, ne = requireAddress(), oe = K.OPS;
  return p2tr.p2tr = function(ce, pe) {
    if (!(ce.address || ce.output || ce.pubkey || ce.internalPubkey || ce.witness && ce.witness.length > 1)) throw new TypeError("Not enough data");
    pe = Object.assign({ validate: !0 }, pe || {}), (0, W.typeforce)({ address: W.typeforce.maybe(W.typeforce.String), input: W.typeforce.maybe(W.typeforce.BufferN(0)), network: W.typeforce.maybe(W.typeforce.Object), output: W.typeforce.maybe(W.typeforce.BufferN(34)), internalPubkey: W.typeforce.maybe(W.typeforce.BufferN(32)), hash: W.typeforce.maybe(W.typeforce.BufferN(32)), pubkey: W.typeforce.maybe(W.typeforce.BufferN(32)), signature: W.typeforce.maybe(W.typeforce.anyOf(W.typeforce.BufferN(64), W.typeforce.BufferN(65))), witness: W.typeforce.maybe(W.typeforce.arrayOf(W.typeforce.Buffer)), scriptTree: W.typeforce.maybe(W.isTaptree), redeem: W.typeforce.maybe({ output: W.typeforce.maybe(W.typeforce.Buffer), redeemVersion: W.typeforce.maybe(W.typeforce.Number), witness: W.typeforce.maybe(W.typeforce.arrayOf(W.typeforce.Buffer)) }), redeemVersion: W.typeforce.maybe(W.typeforce.Number) }, ce);
    const ke = re.value(() => (0, ne.fromBech32)(ce.address)), ot = re.value(() => {
      if (ce.witness && ce.witness.length) return ce.witness.length >= 2 && ce.witness[ce.witness.length - 1][0] === 80 ? ce.witness.slice(0, -1) : ce.witness.slice();
    }), at = re.value(() => ce.scriptTree ? (0, J.toHashTree)(ce.scriptTree) : ce.hash ? { hash: ce.hash } : void 0), ft = ce.network || L.bitcoin, dt = { name: "p2tr", network: ft };
    if (re.prop(dt, "address", () => {
      if (!dt.pubkey) return;
      const lt = ie.bech32m.toWords(dt.pubkey);
      return lt.unshift(1), ie.bech32m.encode(ft.bech32, lt);
    }), re.prop(dt, "hash", () => {
      const lt = at();
      if (lt) return lt.hash;
      const yt = ot();
      if (yt && yt.length > 1) {
        const St = yt[yt.length - 1], mt = St[0] & W.TAPLEAF_VERSION_MASK, $t = yt[yt.length - 2], It = (0, J.tapleafHash)({ output: $t, version: mt });
        return (0, J.rootHashFromPath)(St, It);
      }
      return null;
    }), re.prop(dt, "output", () => {
      if (dt.pubkey) return K.compile([oe.OP_1, dt.pubkey]);
    }), re.prop(dt, "redeemVersion", () => ce.redeemVersion ? ce.redeemVersion : ce.redeem && ce.redeem.redeemVersion !== void 0 && ce.redeem.redeemVersion !== null ? ce.redeem.redeemVersion : J.LEAF_VERSION_TAPSCRIPT), re.prop(dt, "redeem", () => {
      const lt = ot();
      if (lt && !(lt.length < 2)) return { output: lt[lt.length - 2], witness: lt.slice(0, -2), redeemVersion: lt[lt.length - 1][0] & W.TAPLEAF_VERSION_MASK };
    }), re.prop(dt, "pubkey", () => {
      if (ce.pubkey) return ce.pubkey;
      if (ce.output) return ce.output.slice(2);
      if (ce.address) return ke().data;
      if (dt.internalPubkey) {
        const lt = (0, J.tweakKey)(dt.internalPubkey, dt.hash);
        if (lt) return lt.x;
      }
    }), re.prop(dt, "internalPubkey", () => {
      if (ce.internalPubkey) return ce.internalPubkey;
      const lt = ot();
      return lt && lt.length > 1 ? lt[lt.length - 1].slice(1, 33) : void 0;
    }), re.prop(dt, "signature", () => {
      if (ce.signature) return ce.signature;
      const lt = ot();
      return lt && lt.length === 1 ? lt[0] : void 0;
    }), re.prop(dt, "witness", () => {
      if (ce.witness) return ce.witness;
      const lt = at();
      if (lt && ce.redeem && ce.redeem.output && ce.internalPubkey) {
        const yt = (0, J.tapleafHash)({ output: ce.redeem.output, version: dt.redeemVersion }), St = (0, J.findScriptPath)(lt, yt);
        if (!St) return;
        const mt = (0, J.tweakKey)(ce.internalPubkey, lt.hash);
        if (!mt) return;
        const $t = B.Buffer.concat([B.Buffer.from([dt.redeemVersion | mt.parity]), ce.internalPubkey].concat(St));
        return [ce.redeem.output, $t];
      }
      return ce.signature ? [ce.signature] : void 0;
    }), pe.validate) {
      let lt = B.Buffer.from([]);
      if (ce.address) {
        if (ft && ft.bech32 !== ke().prefix) throw new TypeError("Invalid prefix or Network mismatch");
        if (ke().version !== 1) throw new TypeError("Invalid address version");
        if (ke().data.length !== 32) throw new TypeError("Invalid address data");
        lt = ke().data;
      }
      if (ce.pubkey) {
        if (lt.length > 0 && !lt.equals(ce.pubkey)) throw new TypeError("Pubkey mismatch");
        lt = ce.pubkey;
      }
      if (ce.output) {
        if (ce.output.length !== 34 || ce.output[0] !== oe.OP_1 || ce.output[1] !== 32) throw new TypeError("Output is invalid");
        if (lt.length > 0 && !lt.equals(ce.output.slice(2))) throw new TypeError("Pubkey mismatch");
        lt = ce.output.slice(2);
      }
      if (ce.internalPubkey) {
        const mt = (0, J.tweakKey)(ce.internalPubkey, dt.hash);
        if (lt.length > 0 && !lt.equals(mt.x)) throw new TypeError("Pubkey mismatch");
        lt = mt.x;
      }
      if (lt && lt.length && !(0, V.getEccLib)().isXOnlyPoint(lt)) throw new TypeError("Invalid pubkey for p2tr");
      const yt = at();
      if (ce.hash && yt && !ce.hash.equals(yt.hash)) throw new TypeError("Hash mismatch");
      if (ce.redeem && ce.redeem.output && yt) {
        const mt = (0, J.tapleafHash)({ output: ce.redeem.output, version: dt.redeemVersion });
        if (!(0, J.findScriptPath)(yt, mt)) throw new TypeError("Redeem script not in tree");
      }
      const St = ot();
      if (ce.redeem && dt.redeem) {
        if (ce.redeem.redeemVersion && ce.redeem.redeemVersion !== dt.redeem.redeemVersion) throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (ce.redeem.output) {
          if (K.decompile(ce.redeem.output).length === 0) throw new TypeError("Redeem.output is invalid");
          if (dt.redeem.output && !ce.redeem.output.equals(dt.redeem.output)) throw new TypeError("Redeem.output and witness mismatch");
        }
        if (ce.redeem.witness && dt.redeem.witness && !(0, W.stacksEqual)(ce.redeem.witness, dt.redeem.witness)) throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (St && St.length) if (St.length === 1) {
        if (ce.signature && !ce.signature.equals(St[0])) throw new TypeError("Signature mismatch");
      } else {
        const mt = St[St.length - 1];
        if (mt.length < 33) throw new TypeError(`The control-block length is too small. Got ${mt.length}, expected min 33.`);
        if ((mt.length - 33) % 32 != 0) throw new TypeError(`The control-block length of ${mt.length} is incorrect!`);
        const $t = (mt.length - 33) / 32;
        if ($t > 128) throw new TypeError(`The script path is too long. Got ${$t}, expected max 128.`);
        const It = mt.slice(1, 33);
        if (ce.internalPubkey && !ce.internalPubkey.equals(It)) throw new TypeError("Internal pubkey mismatch");
        if (!(0, V.getEccLib)().isXOnlyPoint(It)) throw new TypeError("Invalid internalPubkey for p2tr witness");
        const Ut = mt[0] & W.TAPLEAF_VERSION_MASK, ut = St[St.length - 2], ht = (0, J.tapleafHash)({ output: ut, version: Ut }), Ce = (0, J.rootHashFromPath)(mt, ht), nt = (0, J.tweakKey)(It, Ce);
        if (!nt) throw new TypeError("Invalid outputKey for p2tr witness");
        if (lt.length && !lt.equals(nt.x)) throw new TypeError("Pubkey mismatch for p2tr witness");
        if (nt.parity !== (1 & mt[0])) throw new Error("Incorrect parity");
      }
    }
    return Object.assign(dt, ce);
  }, p2tr;
}
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const L = embed;
    Object.defineProperty(B, "embed", { enumerable: !0, get: function() {
      return L.p2data;
    } });
    const K = p2ms$1;
    Object.defineProperty(B, "p2ms", { enumerable: !0, get: function() {
      return K.p2ms;
    } });
    const W = p2pk$1;
    Object.defineProperty(B, "p2pk", { enumerable: !0, get: function() {
      return W.p2pk;
    } });
    const V = p2pkh$1;
    Object.defineProperty(B, "p2pkh", { enumerable: !0, get: function() {
      return V.p2pkh;
    } });
    const J = p2sh$1;
    Object.defineProperty(B, "p2sh", { enumerable: !0, get: function() {
      return J.p2sh;
    } });
    const re = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", { enumerable: !0, get: function() {
      return re.p2wpkh;
    } });
    const ie = p2wsh$1;
    Object.defineProperty(B, "p2wsh", { enumerable: !0, get: function() {
      return ie.p2wsh;
    } });
    const ne = requireP2tr();
    Object.defineProperty(B, "p2tr", { enumerable: !0, get: function() {
      return ne.p2tr;
    } });
  }(payments$2)), payments$2;
}
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks$2, L = requirePayments(), K = requireScript(), W = types$7, V = dist$1, J = bs58check$5;
  function re(oe) {
    const ce = Buffer$3.from(J.decode(oe));
    if (ce.length < 21) throw new TypeError(oe + " is too short");
    if (ce.length > 21) throw new TypeError(oe + " is too long");
    return { version: ce.readUInt8(0), hash: ce.slice(1) };
  }
  function ie(oe) {
    let ce, pe;
    try {
      ce = V.bech32.decode(oe);
    } catch {
    }
    if (ce) {
      if (pe = ce.words[0], pe !== 0) throw new TypeError(oe + " uses wrong encoding");
    } else if (ce = V.bech32m.decode(oe), pe = ce.words[0], pe === 0) throw new TypeError(oe + " uses wrong encoding");
    const ke = V.bech32.fromWords(ce.words.slice(1));
    return { version: pe, prefix: ce.prefix, data: Buffer$3.from(ke) };
  }
  function ne(oe, ce, pe) {
    const ke = V.bech32.toWords(oe);
    return ke.unshift(ce), ce === 0 ? V.bech32.encode(pe, ke) : V.bech32m.encode(pe, ke);
  }
  return address.fromBase58Check = re, address.fromBech32 = ie, address.toBase58Check = function(oe, ce) {
    (0, W.typeforce)((0, W.tuple)(W.Hash160bit, W.UInt8), arguments);
    const pe = Buffer$3.allocUnsafe(21);
    return pe.writeUInt8(ce, 0), oe.copy(pe, 1), J.encode(pe);
  }, address.toBech32 = ne, address.fromOutputScript = function(oe, ce) {
    ce = ce || B.bitcoin;
    try {
      return L.p2pkh({ output: oe, network: ce }).address;
    } catch {
    }
    try {
      return L.p2sh({ output: oe, network: ce }).address;
    } catch {
    }
    try {
      return L.p2wpkh({ output: oe, network: ce }).address;
    } catch {
    }
    try {
      return L.p2wsh({ output: oe, network: ce }).address;
    } catch {
    }
    try {
      return L.p2tr({ output: oe, network: ce }).address;
    } catch {
    }
    try {
      return function(pe, ke) {
        const ot = pe.slice(2);
        if (ot.length < 2 || ot.length > 40) throw new TypeError("Invalid program length for segwit address");
        const at = pe[0] - 80;
        if (at < 2 || at > 16) throw new TypeError("Invalid version for segwit address");
        if (pe[1] !== ot.length) throw new TypeError("Invalid script for segwit address");
        return ne(ot, at, ke.bech32);
      }(oe, ce);
    } catch {
    }
    throw new Error(K.toASM(oe) + " has no matching Address");
  }, address.toOutputScript = function(oe, ce) {
    let pe, ke;
    ce = ce || B.bitcoin;
    try {
      pe = re(oe);
    } catch {
    }
    if (pe) {
      if (pe.version === ce.pubKeyHash) return L.p2pkh({ hash: pe.hash }).output;
      if (pe.version === ce.scriptHash) return L.p2sh({ hash: pe.hash }).output;
    } else {
      try {
        ke = ie(oe);
      } catch {
      }
      if (ke) {
        if (ke.prefix !== ce.bech32) throw new Error(oe + " has an invalid prefix");
        if (ke.version === 0) {
          if (ke.data.length === 20) return L.p2wpkh({ hash: ke.data }).output;
          if (ke.data.length === 32) return L.p2wsh({ hash: ke.data }).output;
        } else if (ke.version === 1) {
          if (ke.data.length === 32) return L.p2tr({ pubkey: ke.data }).output;
        } else if (ke.version >= 2 && ke.version <= 16 && ke.data.length >= 2 && ke.data.length <= 40) return K.compile([ke.version + 80, ke.data]);
      }
    }
    throw new Error(oe + " has no matching Script");
  }, address;
}
bufferutils.BufferReader = BufferReader, function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const L = require$$1$2, K = ecc_lib, W = crypto$5, V = bufferutils, J = types$7;
  function re(ce) {
    const pe = ce.version || B.LEAF_VERSION_TAPSCRIPT;
    return W.taggedHash("TapLeaf", L.Buffer.concat([L.Buffer.from([pe]), oe(ce.output)]));
  }
  function ie(ce, pe) {
    return W.taggedHash("TapTweak", L.Buffer.concat(pe ? [ce, pe] : [ce]));
  }
  function ne(ce, pe) {
    return W.taggedHash("TapBranch", L.Buffer.concat([ce, pe]));
  }
  function oe(ce) {
    const pe = V.varuint.encodingLength(ce.length), ke = L.Buffer.allocUnsafe(pe);
    return V.varuint.encode(ce.length, ke), L.Buffer.concat([ke, ce]);
  }
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128, B.rootHashFromPath = function(ce, pe) {
    if (ce.length < 33) throw new TypeError(`The control-block length is too small. Got ${ce.length}, expected min 33.`);
    const ke = (ce.length - 33) / 32;
    let ot = pe;
    for (let at = 0; at < ke; at++) {
      const ft = ce.slice(33 + 32 * at, 65 + 32 * at);
      ot = ot.compare(ft) < 0 ? ne(ot, ft) : ne(ft, ot);
    }
    return ot;
  }, B.toHashTree = function ce(pe) {
    if ((0, J.isTapleaf)(pe)) return { hash: re(pe) };
    const ke = [ce(pe[0]), ce(pe[1])];
    ke.sort((ft, dt) => ft.hash.compare(dt.hash));
    const [ot, at] = ke;
    return { hash: ne(ot.hash, at.hash), left: ot, right: at };
  }, B.findScriptPath = function ce(pe, ke) {
    if ("left" in (ot = pe) && "right" in ot) {
      const at = ce(pe.left, ke);
      if (at !== void 0) return [...at, pe.right.hash];
      const ft = ce(pe.right, ke);
      if (ft !== void 0) return [...ft, pe.left.hash];
    } else if (pe.hash.equals(ke)) return [];
    var ot;
  }, B.tapleafHash = re, B.tapTweakHash = ie, B.tweakKey = function(ce, pe) {
    if (!L.Buffer.isBuffer(ce) || ce.length !== 32 || pe && pe.length !== 32) return null;
    const ke = ie(ce, pe), ot = (0, K.getEccLib)().xOnlyPointAddTweak(ce, ke);
    return ot && ot.xOnlyPubkey !== null ? { parity: ot.parity, x: L.Buffer.from(ot.xOnlyPubkey) } : null;
  };
}(bip341);
var block = {}, merkle = {};
function fastMerkleRoot(B, L) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof L != "function") throw TypeError("Expected digest Function");
  let K = B.length;
  const W = B.concat();
  for (; K > 1; ) {
    let V = 0;
    for (let J = 0; J < K; J += 2, ++V) {
      const re = W[J], ie = J + 1 === K ? re : W[J + 1], ne = Buffer$3.concat([re, ie]);
      W[V] = L(ne);
    }
    K = V;
  }
  return W[0];
}
Object.defineProperty(merkle, "__esModule", { value: !0 }), merkle.fastMerkleRoot = void 0, merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 }), transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$5, bscript$2 = requireScript(), script_1 = requireScript(), types$4 = types$7, { typeforce: typeforce$2 } = types$4;
function varSliceSize(B) {
  const L = B.length;
  return bufferutils_1$2.varuint.encodingLength(L) + L;
}
function vectorSize(B) {
  const L = B.length;
  return bufferutils_1$2.varuint.encodingLength(L) + B.reduce((K, W) => K + varSliceSize(W), 0);
}
const EMPTY_BUFFER = Buffer$3.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$3.from("0000000000000000000000000000000000000000000000000000000000000000", "hex"), ONE = Buffer$3.from("0000000000000000000000000000000000000000000000000000000000000001", "hex"), VALUE_UINT64_MAX = Buffer$3.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = { script: EMPTY_BUFFER, valueBuffer: VALUE_UINT64_MAX };
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(L, K) {
    const W = new bufferutils_1$2.BufferReader(L), V = new Transaction();
    V.version = W.readInt32();
    const J = W.readUInt8(), re = W.readUInt8();
    let ie = !1;
    J === Transaction.ADVANCED_TRANSACTION_MARKER && re === Transaction.ADVANCED_TRANSACTION_FLAG ? ie = !0 : W.offset -= 2;
    const ne = W.readVarInt();
    for (let ce = 0; ce < ne; ++ce) V.ins.push({ hash: W.readSlice(32), index: W.readUInt32(), script: W.readVarSlice(), sequence: W.readUInt32(), witness: EMPTY_WITNESS });
    const oe = W.readVarInt();
    for (let ce = 0; ce < oe; ++ce) V.outs.push({ value: W.readUInt64(), script: W.readVarSlice() });
    if (ie) {
      for (let ce = 0; ce < ne; ++ce) V.ins[ce].witness = W.readVector();
      if (!V.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
    }
    if (V.locktime = W.readUInt32(), K) return V;
    if (W.offset !== L.length) throw new Error("Transaction has unexpected data");
    return V;
  }
  static fromHex(L) {
    return Transaction.fromBuffer(Buffer$3.from(L, "hex"), !1);
  }
  static isCoinbaseHash(L) {
    typeforce$2(types$4.Hash256bit, L);
    for (let K = 0; K < 32; ++K) if (L[K] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(L, K, W, V) {
    return typeforce$2(types$4.tuple(types$4.Hash256bit, types$4.UInt32, types$4.maybe(types$4.UInt32), types$4.maybe(types$4.Buffer)), arguments), types$4.Null(W) && (W = Transaction.DEFAULT_SEQUENCE), this.ins.push({ hash: L, index: K, script: V || EMPTY_BUFFER, sequence: W, witness: EMPTY_WITNESS }) - 1;
  }
  addOutput(L, K) {
    return typeforce$2(types$4.tuple(types$4.Buffer, types$4.Satoshi), arguments), this.outs.push({ script: L, value: K }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((L) => L.witness.length !== 0);
  }
  weight() {
    return 3 * this.byteLength(!1) + this.byteLength(!0);
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(L = !0) {
    const K = L && this.hasWitnesses();
    return (K ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((W, V) => W + 40 + varSliceSize(V.script), 0) + this.outs.reduce((W, V) => W + 8 + varSliceSize(V.script), 0) + (K ? this.ins.reduce((W, V) => W + vectorSize(V.witness), 0) : 0);
  }
  clone() {
    const L = new Transaction();
    return L.version = this.version, L.locktime = this.locktime, L.ins = this.ins.map((K) => ({ hash: K.hash, index: K.index, script: K.script, sequence: K.sequence, witness: K.witness })), L.outs = this.outs.map((K) => ({ script: K.script, value: K.value })), L;
  }
  hashForSignature(L, K, W) {
    if (typeforce$2(types$4.tuple(types$4.UInt32, types$4.Buffer, types$4.Number), arguments), L >= this.ins.length) return ONE;
    const V = bscript$2.compile(bscript$2.decompile(K).filter((ie) => ie !== script_1.OPS.OP_CODESEPARATOR)), J = this.clone();
    if ((31 & W) === Transaction.SIGHASH_NONE) J.outs = [], J.ins.forEach((ie, ne) => {
      ne !== L && (ie.sequence = 0);
    });
    else if ((31 & W) === Transaction.SIGHASH_SINGLE) {
      if (L >= this.outs.length) return ONE;
      J.outs.length = L + 1;
      for (let ie = 0; ie < L; ie++) J.outs[ie] = BLANK_OUTPUT;
      J.ins.forEach((ie, ne) => {
        ne !== L && (ie.sequence = 0);
      });
    }
    W & Transaction.SIGHASH_ANYONECANPAY ? (J.ins = [J.ins[L]], J.ins[0].script = V) : (J.ins.forEach((ie) => {
      ie.script = EMPTY_BUFFER;
    }), J.ins[L].script = V);
    const re = Buffer$3.allocUnsafe(J.byteLength(!1) + 4);
    return re.writeInt32LE(W, re.length - 4), J.__toBuffer(re, 0, !1), bcrypto$1.hash256(re);
  }
  hashForWitnessV1(L, K, W, V, J, re) {
    if (typeforce$2(types$4.tuple(types$4.UInt32, typeforce$2.arrayOf(types$4.Buffer), typeforce$2.arrayOf(types$4.Satoshi), types$4.UInt32), arguments), W.length !== this.ins.length || K.length !== this.ins.length) throw new Error("Must supply prevout script and value for all inputs");
    const ie = V === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : V & Transaction.SIGHASH_OUTPUT_MASK, ne = (V & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, oe = ie === Transaction.SIGHASH_NONE, ce = ie === Transaction.SIGHASH_SINGLE;
    let pe = EMPTY_BUFFER, ke = EMPTY_BUFFER, ot = EMPTY_BUFFER, at = EMPTY_BUFFER, ft = EMPTY_BUFFER;
    if (!ne) {
      let St = bufferutils_1$2.BufferWriter.withCapacity(36 * this.ins.length);
      this.ins.forEach((mt) => {
        St.writeSlice(mt.hash), St.writeUInt32(mt.index);
      }), pe = bcrypto$1.sha256(St.end()), St = bufferutils_1$2.BufferWriter.withCapacity(8 * this.ins.length), W.forEach((mt) => St.writeUInt64(mt)), ke = bcrypto$1.sha256(St.end()), St = bufferutils_1$2.BufferWriter.withCapacity(K.map(varSliceSize).reduce((mt, $t) => mt + $t)), K.forEach((mt) => St.writeVarSlice(mt)), ot = bcrypto$1.sha256(St.end()), St = bufferutils_1$2.BufferWriter.withCapacity(4 * this.ins.length), this.ins.forEach((mt) => St.writeUInt32(mt.sequence)), at = bcrypto$1.sha256(St.end());
    }
    if (oe || ce) {
      if (ce && L < this.outs.length) {
        const St = this.outs[L], mt = bufferutils_1$2.BufferWriter.withCapacity(8 + varSliceSize(St.script));
        mt.writeUInt64(St.value), mt.writeVarSlice(St.script), ft = bcrypto$1.sha256(mt.end());
      }
    } else {
      const St = this.outs.map(($t) => 8 + varSliceSize($t.script)).reduce(($t, It) => $t + It), mt = bufferutils_1$2.BufferWriter.withCapacity(St);
      this.outs.forEach(($t) => {
        mt.writeUInt64($t.value), mt.writeVarSlice($t.script);
      }), ft = bcrypto$1.sha256(mt.end());
    }
    const dt = (J ? 2 : 0) + (re ? 1 : 0), lt = 174 - (ne ? 49 : 0) - (oe ? 32 : 0) + (re ? 32 : 0) + (J ? 37 : 0), yt = bufferutils_1$2.BufferWriter.withCapacity(lt);
    if (yt.writeUInt8(V), yt.writeInt32(this.version), yt.writeUInt32(this.locktime), yt.writeSlice(pe), yt.writeSlice(ke), yt.writeSlice(ot), yt.writeSlice(at), oe || ce || yt.writeSlice(ft), yt.writeUInt8(dt), ne) {
      const St = this.ins[L];
      yt.writeSlice(St.hash), yt.writeUInt32(St.index), yt.writeUInt64(W[L]), yt.writeVarSlice(K[L]), yt.writeUInt32(St.sequence);
    } else yt.writeUInt32(L);
    if (re) {
      const St = bufferutils_1$2.BufferWriter.withCapacity(varSliceSize(re));
      St.writeVarSlice(re), yt.writeSlice(bcrypto$1.sha256(St.end()));
    }
    return ce && yt.writeSlice(ft), J && (yt.writeSlice(J), yt.writeUInt8(0), yt.writeUInt32(4294967295)), bcrypto$1.taggedHash("TapSighash", Buffer$3.concat([Buffer$3.from([0]), yt.end()]));
  }
  hashForWitnessV0(L, K, W, V) {
    typeforce$2(types$4.tuple(types$4.UInt32, types$4.Buffer, types$4.Satoshi, types$4.UInt32), arguments);
    let J, re = Buffer$3.from([]), ie = ZERO, ne = ZERO, oe = ZERO;
    if (V & Transaction.SIGHASH_ANYONECANPAY || (re = Buffer$3.allocUnsafe(36 * this.ins.length), J = new bufferutils_1$2.BufferWriter(re, 0), this.ins.forEach((pe) => {
      J.writeSlice(pe.hash), J.writeUInt32(pe.index);
    }), ne = bcrypto$1.hash256(re)), V & Transaction.SIGHASH_ANYONECANPAY || (31 & V) === Transaction.SIGHASH_SINGLE || (31 & V) === Transaction.SIGHASH_NONE || (re = Buffer$3.allocUnsafe(4 * this.ins.length), J = new bufferutils_1$2.BufferWriter(re, 0), this.ins.forEach((pe) => {
      J.writeUInt32(pe.sequence);
    }), oe = bcrypto$1.hash256(re)), (31 & V) !== Transaction.SIGHASH_SINGLE && (31 & V) !== Transaction.SIGHASH_NONE) {
      const pe = this.outs.reduce((ke, ot) => ke + 8 + varSliceSize(ot.script), 0);
      re = Buffer$3.allocUnsafe(pe), J = new bufferutils_1$2.BufferWriter(re, 0), this.outs.forEach((ke) => {
        J.writeUInt64(ke.value), J.writeVarSlice(ke.script);
      }), ie = bcrypto$1.hash256(re);
    } else if ((31 & V) === Transaction.SIGHASH_SINGLE && L < this.outs.length) {
      const pe = this.outs[L];
      re = Buffer$3.allocUnsafe(8 + varSliceSize(pe.script)), J = new bufferutils_1$2.BufferWriter(re, 0), J.writeUInt64(pe.value), J.writeVarSlice(pe.script), ie = bcrypto$1.hash256(re);
    }
    re = Buffer$3.allocUnsafe(156 + varSliceSize(K)), J = new bufferutils_1$2.BufferWriter(re, 0);
    const ce = this.ins[L];
    return J.writeInt32(this.version), J.writeSlice(ne), J.writeSlice(oe), J.writeSlice(ce.hash), J.writeUInt32(ce.index), J.writeVarSlice(K), J.writeUInt64(W), J.writeUInt32(ce.sequence), J.writeSlice(ie), J.writeUInt32(this.locktime), J.writeUInt32(V), bcrypto$1.hash256(re);
  }
  getHash(L) {
    return L && this.isCoinbase() ? Buffer$3.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, L));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString("hex");
  }
  toBuffer(L, K) {
    return this.__toBuffer(L, K, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(L, K) {
    typeforce$2(types$4.tuple(types$4.Number, types$4.Buffer), arguments), this.ins[L].script = K;
  }
  setWitness(L, K) {
    typeforce$2(types$4.tuple(types$4.Number, [types$4.Buffer]), arguments), this.ins[L].witness = K;
  }
  __toBuffer(L, K, W = !1) {
    L || (L = Buffer$3.allocUnsafe(this.byteLength(W)));
    const V = new bufferutils_1$2.BufferWriter(L, K || 0);
    V.writeInt32(this.version);
    const J = W && this.hasWitnesses();
    return J && (V.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), V.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), V.writeVarInt(this.ins.length), this.ins.forEach((re) => {
      V.writeSlice(re.hash), V.writeUInt32(re.index), V.writeVarSlice(re.script), V.writeUInt32(re.sequence);
    }), V.writeVarInt(this.outs.length), this.outs.forEach((re) => {
      isOutput(re) ? V.writeUInt64(re.value) : V.writeSlice(re.valueBuffer), V.writeVarSlice(re.script);
    }), J && this.ins.forEach((re) => {
      V.writeVector(re.witness);
    }), V.writeUInt32(this.locktime), K !== void 0 ? L.slice(K, V.offset) : L;
  }
}
transaction.Transaction = Transaction, Transaction.DEFAULT_SEQUENCE = 4294967295, Transaction.SIGHASH_DEFAULT = 0, Transaction.SIGHASH_ALL = 1, Transaction.SIGHASH_NONE = 2, Transaction.SIGHASH_SINGLE = 3, Transaction.SIGHASH_ANYONECANPAY = 128, Transaction.SIGHASH_OUTPUT_MASK = 3, Transaction.SIGHASH_INPUT_MASK = 128, Transaction.ADVANCED_TRANSACTION_MARKER = 0, Transaction.ADVANCED_TRANSACTION_FLAG = 1, Object.defineProperty(block, "__esModule", { value: !0 }), block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$5, merkle_1 = merkle, transaction_1$3 = transaction, types$3 = types$7, { typeforce: typeforce$1 } = types$3, errorMerkleNoTxes = new TypeError("Cannot compute merkle root for zero transactions"), errorWitnessNotSegwit = new TypeError("Cannot compute witness commit for non-segwit block");
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(L) {
    if (L.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const K = new bufferutils_1$1.BufferReader(L), W = new Block();
    if (W.version = K.readInt32(), W.prevHash = K.readSlice(32), W.merkleRoot = K.readSlice(32), W.timestamp = K.readUInt32(), W.bits = K.readUInt32(), W.nonce = K.readUInt32(), L.length === 80) return W;
    const V = () => {
      const ie = transaction_1$3.Transaction.fromBuffer(K.buffer.slice(K.offset), !0);
      return K.offset += ie.byteLength(), ie;
    }, J = K.readVarInt();
    W.transactions = [];
    for (let ie = 0; ie < J; ++ie) {
      const ne = V();
      W.transactions.push(ne);
    }
    const re = W.getWitnessCommit();
    return re && (W.witnessCommit = re), W;
  }
  static fromHex(L) {
    return Block.fromBuffer(Buffer$3.from(L, "hex"));
  }
  static calculateTarget(L) {
    const K = ((4278190080 & L) >> 24) - 3, W = 8388607 & L, V = Buffer$3.alloc(32, 0);
    return V.writeUIntBE(W, 29 - K, 3), V;
  }
  static calculateMerkleRoot(L, K) {
    if (typeforce$1([{ getHash: types$3.Function }], L), L.length === 0) throw errorMerkleNoTxes;
    if (K && !txesHaveWitnessCommit(L)) throw errorWitnessNotSegwit;
    const W = L.map((J) => J.getHash(K)), V = (0, merkle_1.fastMerkleRoot)(W, bcrypto.hash256);
    return K ? bcrypto.hash256(Buffer$3.concat([V, L[0].ins[0].witness[0]])) : V;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const L = this.transactions[0].outs.filter((W) => W.script.slice(0, 6).equals(Buffer$3.from("6a24aa21a9ed", "hex"))).map((W) => W.script.slice(6, 38));
    if (L.length === 0) return null;
    const K = L[L.length - 1];
    return K instanceof Buffer$3 && K.length === 32 ? K : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$3 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    return 3 * this.byteLength(!1, !1) + this.byteLength(!1, !0);
  }
  byteLength(L, K = !0) {
    return L || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((W, V) => W + V.byteLength(K), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const L = /* @__PURE__ */ new Date(0);
    return L.setUTCSeconds(this.timestamp), L;
  }
  toBuffer(L) {
    const K = Buffer$3.allocUnsafe(this.byteLength(L)), W = new bufferutils_1$1.BufferWriter(K);
    return W.writeInt32(this.version), W.writeSlice(this.prevHash), W.writeSlice(this.merkleRoot), W.writeUInt32(this.timestamp), W.writeUInt32(this.bits), W.writeUInt32(this.nonce), L || !this.transactions || (bufferutils_1$1.varuint.encode(this.transactions.length, K, W.offset), W.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((V) => {
      const J = V.byteLength();
      V.toBuffer(K, W.offset), W.offset += J;
    })), K;
  }
  toHex(L) {
    return this.toBuffer(L).toString("hex");
  }
  checkTxRoots() {
    const L = this.hasWitnessCommit();
    return !(!L && this.hasWitness()) && this.__checkMerkleRoot() && (!L || this.__checkWitnessCommit());
  }
  checkProofOfWork() {
    const L = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), K = Block.calculateTarget(this.bits);
    return L.compare(K) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const L = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(L) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const L = Block.calculateMerkleRoot(this.transactions, !0);
    return this.witnessCommit.compare(L) === 0;
  }
}
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some((L) => typeof L == "object" && L.ins instanceof Array && L.ins.some((K) => typeof K == "object" && K.witness instanceof Array && K.witness.length > 0));
}
block.Block = Block;
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {}, exports, GlobalTypes, InputTypes, OutputTypes;
exports = typeFields, Object.defineProperty(exports, "__esModule", { value: !0 }), (GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {}))[GlobalTypes.UNSIGNED_TX = 0] = "UNSIGNED_TX", GlobalTypes[GlobalTypes.GLOBAL_XPUB = 1] = "GLOBAL_XPUB", exports.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], (InputTypes = exports.InputTypes || (exports.InputTypes = {}))[InputTypes.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", InputTypes[InputTypes.WITNESS_UTXO = 1] = "WITNESS_UTXO", InputTypes[InputTypes.PARTIAL_SIG = 2] = "PARTIAL_SIG", InputTypes[InputTypes.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", InputTypes[InputTypes.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", InputTypes[InputTypes.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", InputTypes[InputTypes.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", InputTypes[InputTypes.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", InputTypes[InputTypes.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", InputTypes[InputTypes.POR_COMMITMENT = 9] = "POR_COMMITMENT", InputTypes[InputTypes.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", InputTypes[InputTypes.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", InputTypes[InputTypes.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", InputTypes[InputTypes.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", InputTypes[InputTypes.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", InputTypes[InputTypes.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT", exports.INPUT_TYPE_NAMES = ["nonWitnessUtxo", "witnessUtxo", "partialSig", "sighashType", "redeemScript", "witnessScript", "bip32Derivation", "finalScriptSig", "finalScriptWitness", "porCommitment", "tapKeySig", "tapScriptSig", "tapLeafScript", "tapBip32Derivation", "tapInternalKey", "tapMerkleRoot"], (OutputTypes = exports.OutputTypes || (exports.OutputTypes = {}))[OutputTypes.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", OutputTypes[OutputTypes.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", OutputTypes[OutputTypes.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", OutputTypes[OutputTypes.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", OutputTypes[OutputTypes.TAP_TREE = 6] = "TAP_TREE", OutputTypes[OutputTypes.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION", exports.OUTPUT_TYPE_NAMES = ["redeemScript", "witnessScript", "bip32Derivation", "tapInternalKey", "tapTree", "tapBip32Derivation"];
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$3 = (B) => [...Array(B).keys()];
function decode$g(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB) throw new Error("Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex"));
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46])) throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex"));
  if (B.value.length / 4 % 1 != 0) throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");
  const L = B.key.slice(1), K = { masterFingerprint: B.value.slice(0, 4), extendedPubkey: L, path: "m" };
  for (const W of range$3(B.value.length / 4 - 1)) {
    const V = B.value.readUInt32LE(4 * W + 4), J = !!(2147483648 & V), re = 2147483647 & V;
    K.path += "/" + re.toString(10) + (J ? "'" : "");
  }
  return K;
}
function encode$g(B) {
  const L = Buffer$3.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), K = Buffer$3.concat([L, B.extendedPubkey]), W = B.path.split("/"), V = Buffer$3.allocUnsafe(4 * W.length);
  B.masterFingerprint.copy(V, 0);
  let J = 4;
  return W.slice(1).forEach((re) => {
    const ie = re.slice(-1) === "'";
    let ne = 2147483647 & parseInt(ie ? re.slice(0, -1) : re, 10);
    ie && (ne += 2147483648), V.writeUInt32LE(ne, J), J += 4;
  }), { key: K, value: V };
}
function check$c(B) {
  const L = B.extendedPubkey, K = B.masterFingerprint, W = B.path;
  return Buffer$3.isBuffer(L) && L.length === 78 && [2, 3].indexOf(L[45]) > -1 && Buffer$3.isBuffer(K) && K.length === 4 && typeof W == "string" && !!W.match(/^m(\/\d+'?)*$/);
}
function canAddToArray$3(B, L, K) {
  const W = L.extendedPubkey.toString("hex");
  return !K.has(W) && (K.add(W), B.filter((V) => V.extendedPubkey.equals(L.extendedPubkey)).length === 0);
}
globalXpub$1.decode = decode$g, globalXpub$1.encode = encode$g, globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }", globalXpub$1.check = check$c, globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$f(B) {
  return { key: Buffer$3.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]), value: B.toBuffer() };
}
unsignedTx$1.encode = encode$f;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$f(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG) throw new Error("Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex"));
  return B.value;
}
function encode$e(B) {
  return { key: Buffer$3.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]), value: B };
}
function check$b(B) {
  return Buffer$3.isBuffer(B);
}
function canAdd$8(B, L) {
  return !!B && !!L && B.finalScriptSig === void 0;
}
finalScriptSig$1.decode = decode$f, finalScriptSig$1.encode = encode$e, finalScriptSig$1.expected = "Buffer", finalScriptSig$1.check = check$b, finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$e(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS) throw new Error("Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex"));
  return B.value;
}
function encode$d(B) {
  return { key: Buffer$3.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]), value: B };
}
function check$a(B) {
  return Buffer$3.isBuffer(B);
}
function canAdd$7(B, L) {
  return !!B && !!L && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.decode = decode$e, finalScriptWitness$1.encode = encode$d, finalScriptWitness$1.expected = "Buffer", finalScriptWitness$1.check = check$a, finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$d(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO) throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex"));
  return B.value;
}
function encode$c(B) {
  return { key: Buffer$3.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]), value: B };
}
function check$9(B) {
  return Buffer$3.isBuffer(B);
}
function canAdd$6(B, L) {
  return !!B && !!L && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.decode = decode$d, nonWitnessUtxo$1.encode = encode$c, nonWitnessUtxo$1.expected = "Buffer", nonWitnessUtxo$1.check = check$9, nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG) throw new Error("Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex"));
  if (B.key.length !== 34 && B.key.length !== 66 || ![2, 3, 4].includes(B.key[1])) throw new Error("Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex"));
  return { pubkey: B.key.slice(1), signature: B.value };
}
function encode$b(B) {
  const L = Buffer$3.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return { key: Buffer$3.concat([L, B.pubkey]), value: B.signature };
}
function check$8(B) {
  return Buffer$3.isBuffer(B.pubkey) && Buffer$3.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
function isDerSigWithSighash(B) {
  if (!Buffer$3.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const L = B[3];
  if (L > 33 || L < 1 || B[3 + L + 1] !== 2) return !1;
  const K = B[3 + L + 2];
  return !(K > 33 || K < 1) && B.length === 3 + L + 2 + K + 2;
}
function canAddToArray$2(B, L, K) {
  const W = L.pubkey.toString("hex");
  return !K.has(W) && (K.add(W), B.filter((V) => V.pubkey.equals(L.pubkey)).length === 0);
}
partialSig$1.decode = decode$c, partialSig$1.encode = encode$b, partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }", partialSig$1.check = check$8, partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT) throw new Error("Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex"));
  return B.value.toString("utf8");
}
function encode$a(B) {
  return { key: Buffer$3.from([typeFields_1$a.InputTypes.POR_COMMITMENT]), value: Buffer$3.from(B, "utf8") };
}
function check$7(B) {
  return typeof B == "string";
}
function canAdd$5(B, L) {
  return !!B && !!L && B.porCommitment === void 0;
}
porCommitment$1.decode = decode$b, porCommitment$1.encode = encode$a, porCommitment$1.expected = "string", porCommitment$1.check = check$7, porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE) throw new Error("Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex"));
  return B.value.readUInt32LE(0);
}
function encode$9(B) {
  const L = Buffer$3.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), K = Buffer$3.allocUnsafe(4);
  return K.writeUInt32LE(B, 0), { key: L, value: K };
}
function check$6(B) {
  return typeof B == "number";
}
function canAdd$4(B, L) {
  return !!B && !!L && B.sighashType === void 0;
}
sighashType$1.decode = decode$a, sighashType$1.encode = encode$9, sighashType$1.expected = "number", sighashType$1.check = check$6, sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1) throw new Error("Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex"));
  if (!check$5(B.value)) throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");
  return B.value;
}
function encode$8(B) {
  return { key: Buffer$3.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
function check$5(B) {
  return Buffer$3.isBuffer(B) && (B.length === 64 || B.length === 65);
}
function canAdd$3(B, L) {
  return !!B && !!L && B.tapKeySig === void 0;
}
tapKeySig$1.decode = decode$9, tapKeySig$1.encode = encode$8, tapKeySig$1.expected = "Buffer", tapKeySig$1.check = check$5, tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT) throw new Error("Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex"));
  if ((B.key.length - 2) % 32 != 0) throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex"));
  const L = B.value[B.value.length - 1];
  if ((254 & B.key[1]) !== L) throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex"));
  const K = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: K, leafVersion: L };
}
function encode$7(B) {
  const L = Buffer$3.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), K = Buffer$3.from([B.leafVersion]);
  return { key: Buffer$3.concat([L, B.controlBlock]), value: Buffer$3.concat([B.script, K]) };
}
function check$4(B) {
  return Buffer$3.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 == 0 && (254 & B.controlBlock[0]) === B.leafVersion && Buffer$3.isBuffer(B.script);
}
function canAddToArray$1(B, L, K) {
  const W = L.controlBlock.toString("hex");
  return !K.has(W) && (K.add(W), B.filter((V) => V.controlBlock.equals(L.controlBlock)).length === 0);
}
tapLeafScript$1.decode = decode$8, tapLeafScript$1.encode = encode$7, tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }", tapLeafScript$1.check = check$4, tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1) throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex"));
  if (!check$3(B.value)) throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
function encode$6(B) {
  return { key: Buffer$3.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
function check$3(B) {
  return Buffer$3.isBuffer(B) && B.length === 32;
}
function canAdd$2(B, L) {
  return !!B && !!L && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.decode = decode$7, tapMerkleRoot$1.encode = encode$6, tapMerkleRoot$1.expected = "Buffer", tapMerkleRoot$1.check = check$3, tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG) throw new Error("Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex"));
  if (B.key.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex"));
  if (B.value.length !== 64 && B.value.length !== 65) throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex"));
  return { pubkey: B.key.slice(1, 33), leafHash: B.key.slice(33), signature: B.value };
}
function encode$5(B) {
  const L = Buffer$3.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return { key: Buffer$3.concat([L, B.pubkey, B.leafHash]), value: B.signature };
}
function check$2(B) {
  return Buffer$3.isBuffer(B.pubkey) && Buffer$3.isBuffer(B.leafHash) && Buffer$3.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
function canAddToArray(B, L, K) {
  const W = L.pubkey.toString("hex") + L.leafHash.toString("hex");
  return !K.has(W) && (K.add(W), B.filter((V) => V.pubkey.equals(L.pubkey) && V.leafHash.equals(L.leafHash)).length === 0);
}
tapScriptSig$1.decode = decode$6, tapScriptSig$1.encode = encode$5, tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }", tapScriptSig$1.check = check$2, tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 != 0) throw new RangeError("value out of range");
}
function encode$4(B, L, K) {
  if (checkUInt53(B), L || (L = Buffer$3.allocUnsafe(encodingLength(B))), !Buffer$3.isBuffer(L)) throw new TypeError("buffer must be a Buffer instance");
  return K || (K = 0), B < 253 ? (L.writeUInt8(B, K), Object.assign(encode$4, { bytes: 1 })) : B <= 65535 ? (L.writeUInt8(253, K), L.writeUInt16LE(B, K + 1), Object.assign(encode$4, { bytes: 3 })) : B <= 4294967295 ? (L.writeUInt8(254, K), L.writeUInt32LE(B, K + 1), Object.assign(encode$4, { bytes: 5 })) : (L.writeUInt8(255, K), L.writeUInt32LE(B >>> 0, K + 1), L.writeUInt32LE(B / 4294967296 | 0, K + 5), Object.assign(encode$4, { bytes: 9 })), L;
}
function decode$5(B, L) {
  if (!Buffer$3.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  L || (L = 0);
  const K = B.readUInt8(L);
  if (K < 253) return Object.assign(decode$5, { bytes: 1 }), K;
  if (K === 253) return Object.assign(decode$5, { bytes: 3 }), B.readUInt16LE(L + 1);
  if (K === 254) return Object.assign(decode$5, { bytes: 5 }), B.readUInt32LE(L + 1);
  {
    Object.assign(decode$5, { bytes: 9 });
    const W = B.readUInt32LE(L + 1), V = 4294967296 * B.readUInt32LE(L + 5) + W;
    return checkUInt53(V), V;
  }
}
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encode = encode$4, varint.decode = decode$5, varint.encodingLength = encodingLength, Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let L = B.length - 1, K = 0;
  for (let W = 0; W < B.length / 2; W++) K = B[W], B[W] = B[L], B[L] = K, L--;
  return B;
}
function keyValsToBuffer(B) {
  const L = B.map(keyValToBuffer);
  return L.push(Buffer$3.from([0])), Buffer$3.concat(L);
}
function keyValToBuffer(B) {
  const L = B.key.length, K = B.value.length, W = varuint$6.encodingLength(L), V = varuint$6.encodingLength(K), J = Buffer$3.allocUnsafe(W + L + V + K);
  return varuint$6.encode(L, J, 0), B.key.copy(J, W), varuint$6.encode(K, J, W + L), B.value.copy(J, W + L + V), J;
}
function verifuint(B, L) {
  if (typeof B != "number") throw new Error("cannot write a non-number as a number");
  if (B < 0) throw new Error("specified a negative value for writing an unsigned value");
  if (B > L) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B) throw new Error("value has a fractional component");
}
function readUInt64LE(B, L) {
  const K = B.readUInt32LE(L);
  let W = B.readUInt32LE(L + 4);
  return W *= 4294967296, verifuint(W + K, 9007199254740991), W + K;
}
function writeUInt64LE(B, L, K) {
  return verifuint(L, 9007199254740991), B.writeInt32LE(-1 & L, K), B.writeUInt32LE(Math.floor(L / 4294967296), K + 4), K + 8;
}
tools.range = (B) => [...Array(B).keys()], tools.reverseBuffer = reverseBuffer$1, tools.keyValsToBuffer = keyValsToBuffer, tools.keyValToBuffer = keyValToBuffer, tools.readUInt64LE = readUInt64LE, tools.writeUInt64LE = writeUInt64LE, Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO) throw new Error("Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex"));
  const L = tools_1$2.readUInt64LE(B.value, 0);
  let K = 8;
  const W = varuint$5.decode(B.value, K);
  K += varuint$5.encodingLength(W);
  const V = B.value.slice(K);
  if (V.length !== W) throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return { script: V, value: L };
}
function encode$3(B) {
  const { script: L, value: K } = B, W = varuint$5.encodingLength(L.length), V = Buffer$3.allocUnsafe(8 + W + L.length);
  return tools_1$2.writeUInt64LE(V, K, 0), varuint$5.encode(L.length, V, 8), L.copy(V, 8 + W), { key: Buffer$3.from([typeFields_1$4.InputTypes.WITNESS_UTXO]), value: V };
}
function check$1(B) {
  return Buffer$3.isBuffer(B.script) && typeof B.value == "number";
}
function canAdd$1(B, L) {
  return !!B && !!L && B.witnessUtxo === void 0;
}
witnessUtxo$1.decode = decode$4, witnessUtxo$1.encode = encode$3, witnessUtxo$1.expected = "{ script: Buffer; value: number; }", witnessUtxo$1.check = check$1, witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1) throw new Error("Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex"));
  let L = 0;
  const K = [];
  for (; L < B.value.length; ) {
    const W = B.value[L++], V = B.value[L++], J = varuint$4.decode(B.value, L);
    L += varuint$4.encodingLength(J), K.push({ depth: W, leafVersion: V, script: B.value.slice(L, L + J) }), L += J;
  }
  return { leaves: K };
}
function encode$2(B) {
  const L = Buffer$3.from([typeFields_1$3.OutputTypes.TAP_TREE]), K = [].concat(...B.leaves.map((W) => [Buffer$3.of(W.depth, W.leafVersion), varuint$4.encode(W.script.length), W.script]));
  return { key: L, value: Buffer$3.concat(K) };
}
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every((L) => L.depth >= 0 && L.depth <= 128 && (254 & L.leafVersion) === L.leafVersion && Buffer$3.isBuffer(L.script));
}
function canAdd(B, L) {
  return !!B && !!L && B.tapTree === void 0;
}
tapTree$1.decode = decode$3, tapTree$1.encode = encode$2, tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }", tapTree$1.check = check, tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$2 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, L = isValidDERKey) {
  return { decode: function(K) {
    if (K.key[0] !== B) throw new Error("Decode Error: could not decode bip32Derivation with key 0x" + K.key.toString("hex"));
    const W = K.key.slice(1);
    if (!L(W)) throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x" + K.key.toString("hex"));
    if (K.value.length / 4 % 1 != 0) throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");
    const V = { masterFingerprint: K.value.slice(0, 4), pubkey: W, path: "m" };
    for (const J of range$2(K.value.length / 4 - 1)) {
      const re = K.value.readUInt32LE(4 * J + 4), ie = !!(2147483648 & re), ne = 2147483647 & re;
      V.path += "/" + ne.toString(10) + (ie ? "'" : "");
    }
    return V;
  }, encode: function(K) {
    const W = Buffer$3.from([B]), V = Buffer$3.concat([W, K.pubkey]), J = K.path.split("/"), re = Buffer$3.allocUnsafe(4 * J.length);
    K.masterFingerprint.copy(re, 0);
    let ie = 4;
    return J.slice(1).forEach((ne) => {
      const oe = ne.slice(-1) === "'";
      let ce = 2147483647 & parseInt(oe ? ne.slice(0, -1) : ne, 10);
      oe && (ce += 2147483648), re.writeUInt32LE(ce, ie), ie += 4;
    }), { key: V, value: re };
  }, check: function(K) {
    return Buffer$3.isBuffer(K.pubkey) && Buffer$3.isBuffer(K.masterFingerprint) && typeof K.path == "string" && L(K.pubkey) && K.masterFingerprint.length === 4;
  }, expected: "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }", canAddToArray: function(K, W, V) {
    const J = W.pubkey.toString("hex");
    return !V.has(J) && (V.add(J), K.filter((re) => re.pubkey.equals(W.pubkey)).length === 0);
  } };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
function makeChecker(B) {
  return function(L) {
    let K;
    if (B.includes(L.key[0]) && (K = L.key.slice(1), K.length !== 33 && K.length !== 65 || ![2, 3, 4].includes(K[0]))) throw new Error("Format Error: invalid pubkey in key 0x" + L.key.toString("hex"));
    return K;
  };
}
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 }), checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
function makeConverter$3(B) {
  return { decode: function(L) {
    if (L.key[0] !== B) throw new Error("Decode Error: could not decode redeemScript with key 0x" + L.key.toString("hex"));
    return L.value;
  }, encode: function(L) {
    return { key: Buffer$3.from([B]), value: L };
  }, check: function(L) {
    return Buffer$3.isBuffer(L);
  }, expected: "Buffer", canAdd: function(L, K) {
    return !!L && !!K && L.redeemScript === void 0;
  } };
}
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 }), redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const L = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  return { decode: function(K) {
    const W = varuint$3.decode(K.value), V = varuint$3.encodingLength(W), J = L.decode({ key: K.key, value: K.value.slice(V + 32 * W) }), re = new Array(W);
    for (let ie = 0, ne = V; ie < W; ie++, ne += 32) re[ie] = K.value.slice(ne, ne + 32);
    return Object.assign({}, J, { leafHashes: re });
  }, encode: function(K) {
    const W = L.encode(K), V = varuint$3.encodingLength(K.leafHashes.length), J = Buffer$3.allocUnsafe(V);
    varuint$3.encode(K.leafHashes.length, J);
    const re = Buffer$3.concat([J, ...K.leafHashes, W.value]);
    return Object.assign({}, W, { value: re });
  }, check: function(K) {
    return Array.isArray(K.leafHashes) && K.leafHashes.every((W) => Buffer$3.isBuffer(W) && W.length === 32) && L.check(K);
  }, expected: "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }", canAddToArray: L.canAddToArray };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
function makeConverter$1(B) {
  return { decode: function(L) {
    if (L.key[0] !== B || L.key.length !== 1) throw new Error("Decode Error: could not decode tapInternalKey with key 0x" + L.key.toString("hex"));
    if (L.value.length !== 32) throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");
    return L.value;
  }, encode: function(L) {
    return { key: Buffer$3.from([B]), value: L };
  }, check: function(L) {
    return Buffer$3.isBuffer(L) && L.length === 32;
  }, expected: "Buffer", canAdd: function(L, K) {
    return !!L && !!K && L.tapInternalKey === void 0;
  } };
}
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 }), tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
function makeConverter(B) {
  return { decode: function(L) {
    if (L.key[0] !== B) throw new Error("Decode Error: could not decode witnessScript with key 0x" + L.key.toString("hex"));
    return L.value;
  }, encode: function(L) {
    return { key: Buffer$3.from([B]), value: L };
  }, check: function(L) {
    return Buffer$3.isBuffer(L);
  }, expected: "Buffer", canAdd: function(L, K) {
    return !!L && !!K && L.witnessScript === void 0;
  } };
}
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 }), witnessScript$1.makeConverter = makeConverter, Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = { unsignedTx, globalXpub, checkPubkey: checkPubkey.makeChecker([]) };
converter.globals = globals;
const inputs = { nonWitnessUtxo, partialSig, sighashType, finalScriptSig, finalScriptWitness, porCommitment, witnessUtxo, bip32Derivation: bip32Derivation.makeConverter(typeFields_1$2.InputTypes.BIP32_DERIVATION), redeemScript: redeemScript.makeConverter(typeFields_1$2.InputTypes.REDEEM_SCRIPT), witnessScript: witnessScript.makeConverter(typeFields_1$2.InputTypes.WITNESS_SCRIPT), checkPubkey: checkPubkey.makeChecker([typeFields_1$2.InputTypes.PARTIAL_SIG, typeFields_1$2.InputTypes.BIP32_DERIVATION]), tapKeySig, tapScriptSig, tapLeafScript, tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION), tapInternalKey: tapInternalKey.makeConverter(typeFields_1$2.InputTypes.TAP_INTERNAL_KEY), tapMerkleRoot };
converter.inputs = inputs;
const outputs = { bip32Derivation: bip32Derivation.makeConverter(typeFields_1$2.OutputTypes.BIP32_DERIVATION), redeemScript: redeemScript.makeConverter(typeFields_1$2.OutputTypes.REDEEM_SCRIPT), witnessScript: witnessScript.makeConverter(typeFields_1$2.OutputTypes.WITNESS_SCRIPT), checkPubkey: checkPubkey.makeChecker([typeFields_1$2.OutputTypes.BIP32_DERIVATION]), tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION), tapTree, tapInternalKey: tapInternalKey.makeConverter(typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY) };
converter.outputs = outputs, Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, L) {
  let K = 0;
  function W() {
    const at = varuint$2.decode(B, K);
    K += varuint$2.encodingLength(at);
    const ft = B.slice(K, K + at);
    return K += at, ft;
  }
  function V() {
    return { key: W(), value: W() };
  }
  function J() {
    if (K >= B.length) throw new Error("Format Error: Unexpected End of PSBT");
    const at = B.readUInt8(K) === 0;
    return at && K++, at;
  }
  if (function() {
    const at = B.readUInt32BE(K);
    return K += 4, at;
  }() !== 1886610036) throw new Error("Format Error: Invalid Magic Number");
  if (function() {
    const at = B.readUInt8(K);
    return K += 1, at;
  }() !== 255) throw new Error("Format Error: Magic Number must be followed by 0xff separator");
  const re = [], ie = {};
  for (; !J(); ) {
    const at = V(), ft = at.key.toString("hex");
    if (ie[ft]) throw new Error("Format Error: Keys must be unique for global keymap: key " + ft);
    ie[ft] = 1, re.push(at);
  }
  const ne = re.filter((at) => at.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX);
  if (ne.length !== 1) throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const oe = L(ne[0].value), { inputCount: ce, outputCount: pe } = oe.getInputOutputCounts(), ke = [], ot = [];
  for (const at of tools_1$1.range(ce)) {
    const ft = {}, dt = [];
    for (; !J(); ) {
      const lt = V(), yt = lt.key.toString("hex");
      if (ft[yt]) throw new Error("Format Error: Keys must be unique for each input: input index " + at + " key " + yt);
      ft[yt] = 1, dt.push(lt);
    }
    ke.push(dt);
  }
  for (const at of tools_1$1.range(pe)) {
    const ft = {}, dt = [];
    for (; !J(); ) {
      const lt = V(), yt = lt.key.toString("hex");
      if (ft[yt]) throw new Error("Format Error: Keys must be unique for each output: output index " + at + " key " + yt);
      ft[yt] = 1, dt.push(lt);
    }
    ot.push(dt);
  }
  return psbtFromKeyVals(oe, { globalMapKeyVals: re, inputKeyVals: ke, outputKeyVals: ot });
}
function checkKeyBuffer(B, L, K) {
  if (!L.equals(Buffer$3.from([K]))) throw new Error(`Format Error: Invalid ${B} key: ${L.toString("hex")}`);
}
function psbtFromKeyVals(B, { globalMapKeyVals: L, inputKeyVals: K, outputKeyVals: W }) {
  const V = { unsignedTx: B };
  let J = 0;
  for (const ce of L) switch (ce.key[0]) {
    case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
      if (checkKeyBuffer("global", ce.key, typeFields_1$1.GlobalTypes.UNSIGNED_TX), J > 0) throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
      J++;
      break;
    case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
      V.globalXpub === void 0 && (V.globalXpub = []), V.globalXpub.push(convert$1.globals.globalXpub.decode(ce));
      break;
    default:
      V.unknownKeyVals || (V.unknownKeyVals = []), V.unknownKeyVals.push(ce);
  }
  const re = K.length, ie = W.length, ne = [], oe = [];
  for (const ce of tools_1$1.range(re)) {
    const pe = {};
    for (const ke of K[ce]) switch (convert$1.inputs.checkPubkey(ke), ke.key[0]) {
      case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
        if (checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.NON_WITNESS_UTXO), pe.nonWitnessUtxo !== void 0) throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");
        pe.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(ke);
        break;
      case typeFields_1$1.InputTypes.WITNESS_UTXO:
        if (checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.WITNESS_UTXO), pe.witnessUtxo !== void 0) throw new Error("Format Error: Input has multiple WITNESS_UTXO");
        pe.witnessUtxo = convert$1.inputs.witnessUtxo.decode(ke);
        break;
      case typeFields_1$1.InputTypes.PARTIAL_SIG:
        pe.partialSig === void 0 && (pe.partialSig = []), pe.partialSig.push(convert$1.inputs.partialSig.decode(ke));
        break;
      case typeFields_1$1.InputTypes.SIGHASH_TYPE:
        if (checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.SIGHASH_TYPE), pe.sighashType !== void 0) throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
        pe.sighashType = convert$1.inputs.sighashType.decode(ke);
        break;
      case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
        if (checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.REDEEM_SCRIPT), pe.redeemScript !== void 0) throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
        pe.redeemScript = convert$1.inputs.redeemScript.decode(ke);
        break;
      case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
        if (checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.WITNESS_SCRIPT), pe.witnessScript !== void 0) throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
        pe.witnessScript = convert$1.inputs.witnessScript.decode(ke);
        break;
      case typeFields_1$1.InputTypes.BIP32_DERIVATION:
        pe.bip32Derivation === void 0 && (pe.bip32Derivation = []), pe.bip32Derivation.push(convert$1.inputs.bip32Derivation.decode(ke));
        break;
      case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
        checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.FINAL_SCRIPTSIG), pe.finalScriptSig = convert$1.inputs.finalScriptSig.decode(ke);
        break;
      case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
        checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS), pe.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(ke);
        break;
      case typeFields_1$1.InputTypes.POR_COMMITMENT:
        checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.POR_COMMITMENT), pe.porCommitment = convert$1.inputs.porCommitment.decode(ke);
        break;
      case typeFields_1$1.InputTypes.TAP_KEY_SIG:
        checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.TAP_KEY_SIG), pe.tapKeySig = convert$1.inputs.tapKeySig.decode(ke);
        break;
      case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
        pe.tapScriptSig === void 0 && (pe.tapScriptSig = []), pe.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(ke));
        break;
      case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
        pe.tapLeafScript === void 0 && (pe.tapLeafScript = []), pe.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(ke));
        break;
      case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
        pe.tapBip32Derivation === void 0 && (pe.tapBip32Derivation = []), pe.tapBip32Derivation.push(convert$1.inputs.tapBip32Derivation.decode(ke));
        break;
      case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
        checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.TAP_INTERNAL_KEY), pe.tapInternalKey = convert$1.inputs.tapInternalKey.decode(ke);
        break;
      case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
        checkKeyBuffer("input", ke.key, typeFields_1$1.InputTypes.TAP_MERKLE_ROOT), pe.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(ke);
        break;
      default:
        pe.unknownKeyVals || (pe.unknownKeyVals = []), pe.unknownKeyVals.push(ke);
    }
    ne.push(pe);
  }
  for (const ce of tools_1$1.range(ie)) {
    const pe = {};
    for (const ke of W[ce]) switch (convert$1.outputs.checkPubkey(ke), ke.key[0]) {
      case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
        if (checkKeyBuffer("output", ke.key, typeFields_1$1.OutputTypes.REDEEM_SCRIPT), pe.redeemScript !== void 0) throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
        pe.redeemScript = convert$1.outputs.redeemScript.decode(ke);
        break;
      case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
        if (checkKeyBuffer("output", ke.key, typeFields_1$1.OutputTypes.WITNESS_SCRIPT), pe.witnessScript !== void 0) throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
        pe.witnessScript = convert$1.outputs.witnessScript.decode(ke);
        break;
      case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
        pe.bip32Derivation === void 0 && (pe.bip32Derivation = []), pe.bip32Derivation.push(convert$1.outputs.bip32Derivation.decode(ke));
        break;
      case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
        checkKeyBuffer("output", ke.key, typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY), pe.tapInternalKey = convert$1.outputs.tapInternalKey.decode(ke);
        break;
      case typeFields_1$1.OutputTypes.TAP_TREE:
        checkKeyBuffer("output", ke.key, typeFields_1$1.OutputTypes.TAP_TREE), pe.tapTree = convert$1.outputs.tapTree.decode(ke);
        break;
      case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
        pe.tapBip32Derivation === void 0 && (pe.tapBip32Derivation = []), pe.tapBip32Derivation.push(convert$1.outputs.tapBip32Derivation.decode(ke));
        break;
      default:
        pe.unknownKeyVals || (pe.unknownKeyVals = []), pe.unknownKeyVals.push(ke);
    }
    oe.push(pe);
  }
  return { globalMap: V, inputs: ne, outputs: oe };
}
fromBuffer.psbtFromBuffer = psbtFromBuffer, fromBuffer.checkKeyBuffer = checkKeyBuffer, fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer$1 = {};
Object.defineProperty(toBuffer$1, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: L, outputs: K }) {
  const { globalKeyVals: W, inputKeyVals: V, outputKeyVals: J } = psbtToKeyVals({ globalMap: B, inputs: L, outputs: K }), re = tools_1.keyValsToBuffer(W), ie = (pe) => pe.length === 0 ? [Buffer$3.from([0])] : pe.map(tools_1.keyValsToBuffer), ne = ie(V), oe = ie(J), ce = Buffer$3.allocUnsafe(5);
  return ce.writeUIntBE(482972169471, 0, 5), Buffer$3.concat([ce, re].concat(ne, oe));
}
toBuffer$1.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, L) => B.key.compare(L.key);
function keyValsFromMap(B, L) {
  const K = /* @__PURE__ */ new Set(), W = Object.entries(B).reduce((J, [re, ie]) => {
    if (re === "unknownKeyVals") return J;
    const ne = L[re];
    if (ne === void 0) return J;
    const oe = (Array.isArray(ie) ? ie : [ie]).map(ne.encode);
    return oe.map((ce) => ce.key.toString("hex")).forEach((ce) => {
      if (K.has(ce)) throw new Error("Serialize Error: Duplicate key: " + ce);
      K.add(ce);
    }), J.concat(oe);
  }, []), V = B.unknownKeyVals ? B.unknownKeyVals.filter((J) => !K.has(J.key.toString("hex"))) : [];
  return W.concat(V).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: L, outputs: K }) {
  return { globalKeyVals: keyValsFromMap(B, convert.globals), inputKeyVals: L.map((W) => keyValsFromMap(W, convert.inputs)), outputKeyVals: K.map((W) => keyValsFromMap(W, convert.outputs)) };
}
toBuffer$1.psbtToKeyVals = psbtToKeyVals, function(B) {
  function L(K) {
    for (var W in K) B.hasOwnProperty(W) || (B[W] = K[W]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), L(fromBuffer), L(toBuffer$1);
}(parser), Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const L = B[0], K = parser_1$1.psbtToKeyVals(L), W = B.slice(1);
  if (W.length === 0) throw new Error("Combine: Nothing to combine");
  const V = getTx(L);
  if (V === void 0) throw new Error("Combine: Self missing transaction");
  const J = getKeySet(K.globalKeyVals), re = K.inputKeyVals.map(getKeySet), ie = K.outputKeyVals.map(getKeySet);
  for (const ne of W) {
    const oe = getTx(ne);
    if (oe === void 0 || !oe.toBuffer().equals(V.toBuffer())) throw new Error("Combine: One of the Psbts does not have the same transaction.");
    const ce = parser_1$1.psbtToKeyVals(ne);
    getKeySet(ce.globalKeyVals).forEach(keyPusher(J, K.globalKeyVals, ce.globalKeyVals)), ce.inputKeyVals.map(getKeySet).forEach((pe, ke) => pe.forEach(keyPusher(re[ke], K.inputKeyVals[ke], ce.inputKeyVals[ke]))), ce.outputKeyVals.map(getKeySet).forEach((pe, ke) => pe.forEach(keyPusher(ie[ke], K.outputKeyVals[ke], ce.outputKeyVals[ke])));
  }
  return parser_1$1.psbtFromKeyVals(V, { globalMapKeyVals: K.globalKeyVals, inputKeyVals: K.inputKeyVals, outputKeyVals: K.outputKeyVals });
}
function keyPusher(B, L, K) {
  return (W) => {
    if (B.has(W)) return;
    const V = K.filter((J) => J.key.toString("hex") === W)[0];
    L.push(V), B.add(W);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const L = /* @__PURE__ */ new Set();
  return B.forEach((K) => {
    const W = K.key.toString("hex");
    if (L.has(W)) throw new Error("Combine: KeyValue Map keys should be unique");
    L.add(W);
  }), L;
}
combiner.combine = combine;
var utils$4 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const L = converter;
  function K(re, ie) {
    const ne = re[ie];
    if (ne === void 0) throw new Error(`No input #${ie}`);
    return ne;
  }
  function W(re, ie) {
    const ne = re[ie];
    if (ne === void 0) throw new Error(`No output #${ie}`);
    return ne;
  }
  function V(re, ie, ne, oe) {
    throw new Error(`Data for ${re} key ${ie} is incorrect: Expected ${ne} and got ${JSON.stringify(oe)}`);
  }
  function J(re) {
    return (ie, ne) => {
      for (const oe of Object.keys(ie)) {
        const ce = ie[oe], { canAdd: pe, canAddToArray: ke, check: ot, expected: at } = L[re + "s"][oe] || {};
        if (ot) if (ke) {
          if (!Array.isArray(ce) || ne[oe] && !Array.isArray(ne[oe])) throw new Error(`Key type ${oe} must be an array`);
          ce.every(ot) || V(re, oe, at, ce);
          const ft = ne[oe] || [], dt = /* @__PURE__ */ new Set();
          if (!ce.every((lt) => ke(ft, lt, dt))) throw new Error("Can not add duplicate data to array");
          ne[oe] = ft.concat(ce);
        } else {
          if (ot(ce) || V(re, oe, at, ce), !pe(ne, ce)) throw new Error(`Can not add duplicate data to ${re}`);
          ne[oe] = ce;
        }
      }
    };
  }
  B.checkForInput = K, B.checkForOutput = W, B.checkHasKey = function(re, ie, ne) {
    if (re.key[0] < ne) throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");
    if (ie && ie.filter((oe) => oe.key.equals(re.key)).length !== 0) throw new Error(`Duplicate Key: ${re.key.toString("hex")}`);
  }, B.getEnumLength = function(re) {
    let ie = 0;
    return Object.keys(re).forEach((ne) => {
      Number(isNaN(Number(ne))) && ie++;
    }), ie;
  }, B.inputCheckUncleanFinalized = function(re, ie) {
    let ne = !1;
    if (ie.nonWitnessUtxo || ie.witnessUtxo) {
      const oe = !!ie.redeemScript, ce = !!ie.witnessScript, pe = !oe || !!ie.finalScriptSig, ke = !ce || !!ie.finalScriptWitness, ot = !!ie.finalScriptSig || !!ie.finalScriptWitness;
      ne = pe && ke && ot;
    }
    if (ne === !1) throw new Error(`Input #${re} has too much or too little data to clean`);
  }, B.updateGlobal = J("global"), B.updateInput = J("input"), B.updateOutput = J("output"), B.addInputAttributes = function(re, ie) {
    const ne = K(re, re.length - 1);
    B.updateInput(ie, ne);
  }, B.addOutputAttributes = function(re, ie) {
    const ne = W(re, re.length - 1);
    B.updateOutput(ie, ne);
  }, B.defaultVersionSetter = function(re, ie) {
    if (!Buffer$3.isBuffer(ie) || ie.length < 4) throw new Error("Set Version: Invalid Transaction");
    return ie.writeUInt32LE(re, 0), ie;
  }, B.defaultLocktimeSetter = function(re, ie) {
    if (!Buffer$3.isBuffer(ie) || ie.length < 4) throw new Error("Set Locktime: Invalid Transaction");
    return ie.writeUInt32LE(re, ie.length - 4), ie;
  };
})(utils$4), Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$2 = utils$4;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = { unsignedTx: B };
  }
  static fromBase64(B, L) {
    const K = Buffer$3.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L) {
    const K = Buffer$3.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L) {
    const K = parser_1.psbtFromBuffer(B, L), W = new this(K.globalMap.unsignedTx);
    return Object.assign(W, K), W;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$2.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, L) {
    const K = utils_1$2.checkForInput(this.inputs, B);
    return utils_1$2.updateInput(L, K), this;
  }
  updateOutput(B, L) {
    const K = utils_1$2.checkForOutput(this.outputs, B);
    return utils_1$2.updateOutput(L, K), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$2.checkHasKey(B, this.globalMap.unknownKeyVals, utils_1$2.getEnumLength(typeFields_1.GlobalTypes)), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    const K = utils_1$2.checkForInput(this.inputs, B);
    return utils_1$2.checkHasKey(L, K.unknownKeyVals, utils_1$2.getEnumLength(typeFields_1.InputTypes)), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    const K = utils_1$2.checkForOutput(this.outputs, B);
    return utils_1$2.checkHasKey(L, K.unknownKeyVals, utils_1$2.getEnumLength(typeFields_1.OutputTypes)), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({ unknownKeyVals: [] });
    const L = B.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(L)) throw new Error("unknownKeyVals must be an Array");
    return L.forEach((W) => this.addUnknownKeyValToInput(K, W)), utils_1$2.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({ unknownKeyVals: [] });
    const L = B.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(L)) throw new Error("unknownKeyVals must be an Array");
    return L.forEach((W) => this.addUnknownKeyValToOutput(K, W)), utils_1$2.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const L = utils_1$2.checkForInput(this.inputs, B);
    utils_1$2.inputCheckUncleanFinalized(B, L);
    for (const K of Object.keys(L)) ["witnessUtxo", "nonWitnessUtxo", "finalScriptSig", "finalScriptWitness", "unknownKeyVals"].includes(K) || delete L[K];
    return this;
  }
  combine(...B) {
    const L = combiner_1.combine([this].concat(B));
    return Object.assign(this, L), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 }), psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$5, payments$1 = requirePayments();
function isPaymentFactory(B) {
  return (L) => {
    try {
      return B({ output: L }), !0;
    } catch {
      return !1;
    }
  };
}
function witnessStackToScriptWitness(B) {
  let L = Buffer$3.allocUnsafe(0);
  function K(V) {
    const J = L.length, re = varuint$1.encodingLength(V);
    L = Buffer$3.concat([L, Buffer$3.allocUnsafe(re)]), varuint$1.encode(V, L, J);
  }
  var W;
  return K((W = B).length), W.forEach(function(V) {
    K(V.length), function(J) {
      L = Buffer$3.concat([L, Buffer$3.from(J)]);
    }(V);
  }), L;
}
function pubkeyPositionInScript(B, L) {
  const K = (0, crypto_1.hash160)(B), W = B.slice(1, 33), V = bscript$1.decompile(L);
  if (V === null) throw new Error("Unknown script error");
  return V.findIndex((J) => typeof J != "number" && (J.equals(B) || J.equals(K) || J.equals(W)));
}
function pubkeyInScript(B, L) {
  return pubkeyPositionInScript(B, L) !== -1;
}
function checkInputForSig(B, L) {
  return extractPartialSigs(B).some((K) => signatureBlocksAction(K, bscript$1.signature.decode, L));
}
function signatureBlocksAction(B, L, K) {
  const { hashType: W } = L(B), V = [];
  switch (W & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && V.push("addInput"), 31 & W) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      V.push("addOutput"), V.push("setInputSequence");
  }
  return V.indexOf(K) === -1;
}
function extractPartialSigs(B) {
  let L = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    L = getPsigsFromInputFinalScripts(B);
  } else L = B.partialSig;
  return L.map((K) => K.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const L = B.finalScriptSig && bscript$1.decompile(B.finalScriptSig) || [], K = B.finalScriptWitness && bscript$1.decompile(B.finalScriptWitness) || [];
  return L.concat(K).filter((W) => Buffer$3.isBuffer(W) && bscript$1.isCanonicalScriptSignature(W)).map((W) => ({ signature: W }));
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms), psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk), psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh), psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh), psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh), psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh), psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr), psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness, psbtutils.pubkeyPositionInScript = pubkeyPositionInScript, psbtutils.pubkeyInScript = pubkeyInScript, psbtutils.checkInputForSig = checkInputForSig, psbtutils.signatureBlocksAction = signatureBlocksAction, Object.defineProperty(bip371, "__esModule", { value: !0 }), bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$7, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly$1 = (B) => B.length === 32 ? B : B.slice(1, 33);
function tapScriptFinalizer(B, L, K) {
  const W = findTapLeafToFinalize(L, B, K);
  try {
    const V = sortSignatures(L, W).concat(W.script).concat(W.controlBlock);
    return { finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(V) };
  } catch (V) {
    throw new Error(`Can not finalize taproot input #${B}: ${V}`);
  }
}
function serializeTaprootSignature(B, L) {
  const K = L ? Buffer$3.from([L]) : Buffer$3.from([]);
  return Buffer$3.concat([B, K]);
}
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
function isTaprootOutput(B, L) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || L && (0, psbtutils_1$1.isP2TR)(L));
}
function checkTaprootInputFields(B, L, K) {
  checkMixedTaprootAndNonTaprootInputFields(B, L, K), checkIfTapLeafInTree(B, L, K);
}
function checkTaprootOutputFields(B, L, K) {
  checkMixedTaprootAndNonTaprootOutputFields(B, L, K), checkTaprootScriptPubkey(B, L);
}
function checkTaprootScriptPubkey(B, L) {
  if (!L.tapTree && !L.tapInternalKey) return;
  const K = L.tapInternalKey || B.tapInternalKey, W = L.tapTree || B.tapTree;
  if (K) {
    const { script: V } = B, J = getTaprootScripPubkey(K, W);
    if (V && !V.equals(J)) throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, L) {
  const K = L && tapTreeFromList(L.leaves), { output: W } = (0, payments_1.p2tr)({ internalPubkey: B, scriptTree: K });
  return W;
}
function tweakInternalPubKey(B, L) {
  const K = L.tapInternalKey, W = K && (0, bip341_1$1.tweakKey)(K, L.tapMerkleRoot);
  if (!W) throw new Error(`Cannot tweak tap internal key for input #${B}. Public key: ${K && K.toString("hex")}`);
  return W.x;
}
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B)) throw new Error("Cannot convert taptree to tapleaf list. Expecting a tapree structure.");
  return _tapTreeToList(B);
}
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? { output: B[0].script, version: B[0].leafVersion } : instertLeavesInTree(B);
}
function checkTaprootInputForSigs(B, L) {
  return extractTaprootSigs(B).some((K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, L));
}
function decodeSchnorrSignature(B) {
  return { signature: B.slice(0, 64), hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT };
}
function extractTaprootSigs(B) {
  const L = [];
  if (B.tapKeySig && L.push(B.tapKeySig), B.tapScriptSig && L.push(...B.tapScriptSig.map((K) => K.signature)), !L.length) {
    const K = getTapKeySigFromWithness(B.finalScriptWitness);
    K && L.push(K);
  }
  return L;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const L = B.slice(2);
  return L.length === 64 || L.length === 65 ? L : void 0;
}
function _tapTreeToList(B, L = [], K = 0) {
  if (K > bip341_1$1.MAX_TAPTREE_DEPTH) throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (L.push({ depth: K, leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT, script: B.output }), L) : (B[0] && _tapTreeToList(B[0], L, K + 1), B[1] && _tapTreeToList(B[1], L, K + 1), L) : [];
}
function instertLeavesInTree(B) {
  let L;
  for (const K of B) if (L = instertLeafInTree(K, L), !L) throw new Error("No room left to insert tapleaf in tree");
  return L;
}
function instertLeafInTree(B, L, K = 0) {
  if (K > bip341_1$1.MAX_TAPTREE_DEPTH) throw new Error("Max taptree depth exceeded.");
  if (B.depth === K) return L ? void 0 : { output: B.script, version: B.leafVersion };
  if ((0, types_1.isTapleaf)(L)) return;
  const W = instertLeafInTree(B, L && L[0], K + 1);
  if (W) return [W, L && L[1]];
  const V = instertLeafInTree(B, L && L[1], K + 1);
  return V ? [L && L[0], V] : void 0;
}
function checkMixedTaprootAndNonTaprootInputFields(B, L, K) {
  const W = isTaprootInput(B) && hasNonTaprootFields(L), V = hasNonTaprootFields(B) && isTaprootInput(L), J = B === L && isTaprootInput(L) && hasNonTaprootFields(L);
  if (W || V || J) throw new Error(`Invalid arguments for Psbt.${K}. Cannot use both taproot and non-taproot fields.`);
}
function checkMixedTaprootAndNonTaprootOutputFields(B, L, K) {
  const W = isTaprootOutput(B) && hasNonTaprootFields(L), V = hasNonTaprootFields(B) && isTaprootOutput(L), J = B === L && isTaprootOutput(L) && hasNonTaprootFields(L);
  if (W || V || J) throw new Error(`Invalid arguments for Psbt.${K}. Cannot use both taproot and non-taproot fields.`);
}
function checkIfTapLeafInTree(B, L, K) {
  if (L.tapMerkleRoot) {
    const W = (L.tapLeafScript || []).every((J) => isTapLeafInTree(J, L.tapMerkleRoot)), V = (B.tapLeafScript || []).every((J) => isTapLeafInTree(J, L.tapMerkleRoot));
    if (!W || !V) throw new Error(`Invalid arguments for Psbt.${K}. Tapleaf not part of taptree.`);
  } else if (B.tapMerkleRoot && !(L.tapLeafScript || []).every((V) => isTapLeafInTree(V, B.tapMerkleRoot)))
    throw new Error(`Invalid arguments for Psbt.${K}. Tapleaf not part of taptree.`);
}
function isTapLeafInTree(B, L) {
  if (!L) return !0;
  const K = (0, bip341_1$1.tapleafHash)({ output: B.script, version: B.leafVersion });
  return (0, bip341_1$1.rootHashFromPath)(B.controlBlock, K).equals(L);
}
function sortSignatures(B, L) {
  const K = (0, bip341_1$1.tapleafHash)({ output: L.script, version: L.leafVersion });
  return (B.tapScriptSig || []).filter((W) => W.leafHash.equals(K)).map((W) => addPubkeyPositionInScript(L.script, W)).sort((W, V) => V.positionInScript - W.positionInScript).map((W) => W.signature);
}
function addPubkeyPositionInScript(B, L) {
  return Object.assign({ positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(L.pubkey, B) }, L);
}
function findTapLeafToFinalize(B, L, K) {
  if (!B.tapScriptSig || !B.tapScriptSig.length) throw new Error(`Can not finalize taproot input #${L}. No tapleaf script signature provided.`);
  const W = (B.tapLeafScript || []).sort((V, J) => V.controlBlock.length - J.controlBlock.length).find((V) => canFinalizeLeaf(V, B.tapScriptSig, K));
  if (!W) throw new Error(`Can not finalize taproot input #${L}. Signature for tapleaf script not found.`);
  return W;
}
function canFinalizeLeaf(B, L, K) {
  const W = (0, bip341_1$1.tapleafHash)({ output: B.script, version: B.leafVersion });
  return (!K || K.equals(W)) && L.find((V) => V.leafHash.equals(W)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
bip371.toXOnly = toXOnly$1, bip371.tapScriptFinalizer = tapScriptFinalizer, bip371.serializeTaprootSignature = serializeTaprootSignature, bip371.isTaprootInput = isTaprootInput, bip371.isTaprootOutput = isTaprootOutput, bip371.checkTaprootInputFields = checkTaprootInputFields, bip371.checkTaprootOutputFields = checkTaprootOutputFields, bip371.tweakInternalPubKey = tweakInternalPubKey, bip371.tapTreeToList = tapTreeToList, bip371.tapTreeFromList = tapTreeFromList, bip371.checkTaprootInputForSigs = checkTaprootInputForSigs, Object.defineProperty(psbt$1, "__esModule", { value: !0 }), psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1$1 = utils$4, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks$2, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = { network: networks_1.bitcoin, maximumFeeRate: 5e3 };
class Psbt {
  static fromBase64(L, K = {}) {
    const W = Buffer$3.from(L, "base64");
    return this.fromBuffer(W, K);
  }
  static fromHex(L, K = {}) {
    const W = Buffer$3.from(L, "hex");
    return this.fromBuffer(W, K);
  }
  static fromBuffer(L, K = {}) {
    const W = bip174_1.Psbt.fromBuffer(L, transactionFromBuffer), V = new Psbt(K, W);
    return checkTxForDupeIns(V.__CACHE.__TX, V.__CACHE), V;
  }
  constructor(L = {}, K = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = K, this.opts = Object.assign({}, DEFAULT_OPTS, L), this.__CACHE = { __NON_WITNESS_UTXO_TX_CACHE: [], __NON_WITNESS_UTXO_BUF_CACHE: [], __TX_IN_CACHE: {}, __TX: this.data.globalMap.unsignedTx.tx, __UNSAFE_SIGN_NONSEGWIT: !1 }, this.data.inputs.length === 0 && this.setVersion(2);
    const W = (V, J, re, ie) => Object.defineProperty(V, J, { enumerable: re, writable: ie });
    W(this, "__CACHE", !1, !0), W(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(L) {
    this.setVersion(L);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(L) {
    this.setLocktime(L);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((L) => ({ hash: (0, bufferutils_1.cloneBuffer)(L.hash), index: L.index, sequence: L.sequence }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((L) => {
      let K;
      try {
        K = (0, address_1.fromOutputScript)(L.script, this.opts.network);
      } catch {
      }
      return { script: (0, bufferutils_1.cloneBuffer)(L.script), value: L.value, address: K };
    });
  }
  combine(...L) {
    return this.data.combine(...L.map((K) => K.data)), this;
  }
  clone() {
    const L = Psbt.fromBuffer(this.data.toBuffer());
    return L.opts = JSON.parse(JSON.stringify(this.opts)), L;
  }
  setMaximumFeeRate(L) {
    check32Bit(L), this.opts.maximumFeeRate = L;
  }
  setVersion(L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const K = this.__CACHE;
    return K.__TX.version = L, K.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const K = this.__CACHE;
    return K.__TX.locktime = L, K.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(L, K) {
    check32Bit(K), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const W = this.__CACHE;
    if (W.__TX.ins.length <= L) throw new Error("Input index too high");
    return W.__TX.ins[L].sequence = K, W.__EXTRACTED_TX = void 0, this;
  }
  addInputs(L) {
    return L.forEach((K) => this.addInput(K)), this;
  }
  addInput(L) {
    if (arguments.length > 1 || !L || L.hash === void 0 || L.index === void 0) throw new Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");
    (0, bip371_1.checkTaprootInputFields)(L, L, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), L.witnessScript && checkInvalidP2WSH(L.witnessScript);
    const K = this.__CACHE;
    this.data.addInput(L), checkTxInputCache(K, K.__TX.ins[K.__TX.ins.length - 1]);
    const W = this.data.inputs.length - 1, V = this.data.inputs[W];
    return V.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, V, W), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(L) {
    return L.forEach((K) => this.addOutput(K)), this;
  }
  addOutput(L) {
    if (arguments.length > 1 || !L || L.value === void 0 || L.address === void 0 && L.script === void 0) throw new Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: K } = L;
    if (typeof K == "string") {
      const { network: V } = this.opts, J = (0, address_1.toOutputScript)(K, V);
      L = Object.assign({}, L, { script: J });
    }
    (0, bip371_1.checkTaprootOutputFields)(L, L, "addOutput");
    const W = this.__CACHE;
    return this.data.addOutput(L), W.__FEE = void 0, W.__FEE_RATE = void 0, W.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(L) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const K = this.__CACHE;
    if (L || checkFees(this, K, this.opts), K.__EXTRACTED_TX) return K.__EXTRACTED_TX;
    const W = K.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, W, K, !0), W;
  }
  getFeeRate() {
    return getTxCacheValue("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE);
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1$1.checkForInput)(this.data.inputs, 0), range$1(this.data.inputs.length).forEach((L) => this.finalizeInput(L)), this;
  }
  finalizeInput(L, K) {
    const W = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return (0, bip371_1.isTaprootInput)(W) ? this._finalizeTaprootInput(L, W, void 0, K) : this._finalizeInput(L, W, K);
  }
  finalizeTaprootInput(L, K, W = bip371_1.tapScriptFinalizer) {
    const V = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    if ((0, bip371_1.isTaprootInput)(V)) return this._finalizeTaprootInput(L, V, K, W);
    throw new Error(`Cannot finalize input #${L}. Not Taproot.`);
  }
  _finalizeInput(L, K, W = getFinalScripts) {
    const { script: V, isP2SH: J, isP2WSH: re, isSegwit: ie } = getScriptFromInput(L, K, this.__CACHE);
    if (!V) throw new Error(`No script found for input #${L}`);
    checkPartialSigSighashes(K);
    const { finalScriptSig: ne, finalScriptWitness: oe } = W(L, K, V, ie, J, re);
    if (ne && this.data.updateInput(L, { finalScriptSig: ne }), oe && this.data.updateInput(L, { finalScriptWitness: oe }), !ne && !oe) throw new Error(`Unknown error finalizing input #${L}`);
    return this.data.clearFinalizedInput(L), this;
  }
  _finalizeTaprootInput(L, K, W, V = bip371_1.tapScriptFinalizer) {
    if (!K.witnessUtxo) throw new Error(`Cannot finalize input #${L}. Missing withness utxo.`);
    if (K.tapKeySig) {
      const J = payments.p2tr({ output: K.witnessUtxo.script, signature: K.tapKeySig }), re = (0, psbtutils_1.witnessStackToScriptWitness)(J.witness);
      this.data.updateInput(L, { finalScriptWitness: re });
    } else {
      const { finalScriptWitness: J } = V(L, K, W);
      this.data.updateInput(L, { finalScriptWitness: J });
    }
    return this.data.clearFinalizedInput(L), this;
  }
  getInputType(L) {
    const K = (0, utils_1$1.checkForInput)(this.data.inputs, L), W = getMeaningfulScript(getScriptFromUtxo(L, K, this.__CACHE), L, "input", K.redeemScript || redeemFromFinalScriptSig(K.finalScriptSig), K.witnessScript || redeemFromFinalWitnessScript(K.finalScriptWitness));
    return (W.type === "raw" ? "" : W.type + "-") + classifyScript(W.meaningfulScript);
  }
  inputHasPubkey(L, K) {
    return pubkeyInInput(K, (0, utils_1$1.checkForInput)(this.data.inputs, L), L, this.__CACHE);
  }
  inputHasHDKey(L, K) {
    const W = (0, utils_1$1.checkForInput)(this.data.inputs, L), V = bip32DerivationIsMine(K);
    return !!W.bip32Derivation && W.bip32Derivation.some(V);
  }
  outputHasPubkey(L, K) {
    return pubkeyInOutput(K, (0, utils_1$1.checkForOutput)(this.data.outputs, L), L, this.__CACHE);
  }
  outputHasHDKey(L, K) {
    const W = (0, utils_1$1.checkForOutput)(this.data.outputs, L), V = bip32DerivationIsMine(K);
    return !!W.bip32Derivation && W.bip32Derivation.some(V);
  }
  validateSignaturesOfAllInputs(L) {
    return (0, utils_1$1.checkForInput)(this.data.inputs, 0), range$1(this.data.inputs.length).map((K) => this.validateSignaturesOfInput(K, L)).reduce((K, W) => W === !0 && K, !0);
  }
  validateSignaturesOfInput(L, K, W) {
    const V = this.data.inputs[L];
    return (0, bip371_1.isTaprootInput)(V) ? this.validateSignaturesOfTaprootInput(L, K, W) : this._validateSignaturesOfInput(L, K, W);
  }
  _validateSignaturesOfInput(L, K, W) {
    const V = this.data.inputs[L], J = (V || {}).partialSig;
    if (!V || !J || J.length < 1) throw new Error("No signatures to validate");
    if (typeof K != "function") throw new Error("Need validator function to validate signatures");
    const re = W ? J.filter((pe) => pe.pubkey.equals(W)) : J;
    if (re.length < 1) throw new Error("No signatures for this pubkey");
    const ie = [];
    let ne, oe, ce;
    for (const pe of re) {
      const ke = bscript.signature.decode(pe.signature), { hash: ot, script: at } = ce !== ke.hashType ? getHashForSig(L, Object.assign({}, V, { sighashType: ke.hashType }), this.__CACHE, !0) : { hash: ne, script: oe };
      ce = ke.hashType, ne = ot, oe = at, checkScriptForPubkey(pe.pubkey, at, "verify"), ie.push(K(pe.pubkey, ot, ke.signature));
    }
    return ie.every((pe) => pe === !0);
  }
  validateSignaturesOfTaprootInput(L, K, W) {
    const V = this.data.inputs[L], J = (V || {}).tapKeySig, re = (V || {}).tapScriptSig;
    if (!V && !J && (!re || re.length)) throw new Error("No signatures to validate");
    if (typeof K != "function") throw new Error("Need validator function to validate signatures");
    const ie = (W = W && (0, bip371_1.toXOnly)(W)) ? getTaprootHashesForSig(L, V, this.data.inputs, W, this.__CACHE) : getAllTaprootHashesForSig(L, V, this.data.inputs, this.__CACHE);
    if (!ie.length) throw new Error("No signatures for this pubkey");
    const ne = ie.find((ce) => !ce.leafHash);
    let oe = 0;
    if (J && ne) {
      if (!K(ne.pubkey, ne.hash, trimTaprootSig(J))) return !1;
      oe++;
    }
    if (re) for (const ce of re) {
      const pe = ie.find((ke) => ce.pubkey.equals(ke.pubkey));
      if (pe) {
        if (!K(ce.pubkey, pe.hash, trimTaprootSig(ce.signature))) return !1;
        oe++;
      }
    }
    return oe > 0;
  }
  signAllInputsHD(L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint) throw new Error("Need HDSigner to sign input");
    const W = [];
    for (const V of range$1(this.data.inputs.length)) try {
      this.signInputHD(V, L, K), W.push(!0);
    } catch {
      W.push(!1);
    }
    if (W.every((V) => V === !1)) throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((W, V) => {
      if (!L || !L.publicKey || !L.fingerprint) return V(new Error("Need HDSigner to sign input"));
      const J = [], re = [];
      for (const ie of range$1(this.data.inputs.length)) re.push(this.signInputHDAsync(ie, L, K).then(() => {
        J.push(!0);
      }, () => {
        J.push(!1);
      }));
      return Promise.all(re).then(() => {
        if (J.every((ie) => ie === !1)) return V(new Error("No inputs were signed"));
        W();
      });
    });
  }
  signInputHD(L, K, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!K || !K.publicKey || !K.fingerprint) throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(L, this.data.inputs, K).forEach((V) => this.signInput(L, V, W)), this;
  }
  signInputHDAsync(L, K, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((V, J) => {
      if (!K || !K.publicKey || !K.fingerprint) return J(new Error("Need HDSigner to sign input"));
      const re = getSignersFromHD(L, this.data.inputs, K).map((ie) => this.signInputAsync(L, ie, W));
      return Promise.all(re).then(() => {
        V();
      }).catch(J);
    });
  }
  signAllInputs(L, K) {
    if (!L || !L.publicKey) throw new Error("Need Signer to sign input");
    const W = [];
    for (const V of range$1(this.data.inputs.length)) try {
      this.signInput(V, L, K), W.push(!0);
    } catch {
      W.push(!1);
    }
    if (W.every((V) => V === !1)) throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(L, K) {
    return new Promise((W, V) => {
      if (!L || !L.publicKey) return V(new Error("Need Signer to sign input"));
      const J = [], re = [];
      for (const [ie] of this.data.inputs.entries()) re.push(this.signInputAsync(ie, L, K).then(() => {
        J.push(!0);
      }, () => {
        J.push(!1);
      }));
      return Promise.all(re).then(() => {
        if (J.every((ie) => ie === !1)) return V(new Error("No inputs were signed"));
        W();
      });
    });
  }
  signInput(L, K, W) {
    if (!K || !K.publicKey) throw new Error("Need Signer to sign input");
    const V = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    return (0, bip371_1.isTaprootInput)(V) ? this._signTaprootInput(L, V, K, void 0, W) : this._signInput(L, K, W);
  }
  signTaprootInput(L, K, W, V) {
    if (!K || !K.publicKey) throw new Error("Need Signer to sign input");
    const J = (0, utils_1$1.checkForInput)(this.data.inputs, L);
    if ((0, bip371_1.isTaprootInput)(J)) return this._signTaprootInput(L, J, K, W, V);
    throw new Error(`Input #${L} is not of type Taproot.`);
  }
  _signInput(L, K, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: V, sighashType: J } = getHashAndSighashType(this.data.inputs, L, K.publicKey, this.__CACHE, W), re = [{ pubkey: K.publicKey, signature: bscript.signature.encode(K.sign(V), J) }];
    return this.data.updateInput(L, { partialSig: re }), this;
  }
  _signTaprootInput(L, K, W, V, J = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const re = this.checkTaprootHashesForSig(L, K, W, V, J), ie = re.filter((oe) => !oe.leafHash).map((oe) => (0, bip371_1.serializeTaprootSignature)(W.signSchnorr(oe.hash), K.sighashType))[0], ne = re.filter((oe) => !!oe.leafHash).map((oe) => ({ pubkey: (0, bip371_1.toXOnly)(W.publicKey), signature: (0, bip371_1.serializeTaprootSignature)(W.signSchnorr(oe.hash), K.sighashType), leafHash: oe.leafHash }));
    return ie && this.data.updateInput(L, { tapKeySig: ie }), ne.length && this.data.updateInput(L, { tapScriptSig: ne }), this;
  }
  signInputAsync(L, K, W) {
    return Promise.resolve().then(() => {
      if (!K || !K.publicKey) throw new Error("Need Signer to sign input");
      const V = (0, utils_1$1.checkForInput)(this.data.inputs, L);
      return (0, bip371_1.isTaprootInput)(V) ? this._signTaprootInputAsync(L, V, K, void 0, W) : this._signInputAsync(L, K, W);
    });
  }
  signTaprootInputAsync(L, K, W, V) {
    return Promise.resolve().then(() => {
      if (!K || !K.publicKey) throw new Error("Need Signer to sign input");
      const J = (0, utils_1$1.checkForInput)(this.data.inputs, L);
      if ((0, bip371_1.isTaprootInput)(J)) return this._signTaprootInputAsync(L, J, K, W, V);
      throw new Error(`Input #${L} is not of type Taproot.`);
    });
  }
  _signInputAsync(L, K, W = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: V, sighashType: J } = getHashAndSighashType(this.data.inputs, L, K.publicKey, this.__CACHE, W);
    return Promise.resolve(K.sign(V)).then((re) => {
      const ie = [{ pubkey: K.publicKey, signature: bscript.signature.encode(re, J) }];
      this.data.updateInput(L, { partialSig: ie });
    });
  }
  async _signTaprootInputAsync(L, K, W, V, J = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const re = this.checkTaprootHashesForSig(L, K, W, V, J), ie = [], ne = re.filter((ce) => !ce.leafHash)[0];
    if (ne) {
      const ce = Promise.resolve(W.signSchnorr(ne.hash)).then((pe) => ({ tapKeySig: (0, bip371_1.serializeTaprootSignature)(pe, K.sighashType) }));
      ie.push(ce);
    }
    const oe = re.filter((ce) => !!ce.leafHash);
    if (oe.length) {
      const ce = oe.map((pe) => Promise.resolve(W.signSchnorr(pe.hash)).then((ke) => ({ tapScriptSig: [{ pubkey: (0, bip371_1.toXOnly)(W.publicKey), signature: (0, bip371_1.serializeTaprootSignature)(ke, K.sighashType), leafHash: pe.leafHash }] })));
      ie.push(...ce);
    }
    return Promise.all(ie).then((ce) => {
      ce.forEach((pe) => this.data.updateInput(L, pe));
    });
  }
  checkTaprootHashesForSig(L, K, W, V, J) {
    if (typeof W.signSchnorr != "function") throw new Error(`Need Schnorr Signer to sign taproot input #${L}.`);
    const re = getTaprootHashesForSig(L, K, this.data.inputs, W.publicKey, this.__CACHE, V, J);
    if (!re || !re.length) throw new Error(`Can not sign for input #${L} with the key ${W.publicKey.toString("hex")}`);
    return re;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(L) {
    return this.data.updateGlobal(L), this;
  }
  updateInput(L, K) {
    return K.witnessScript && checkInvalidP2WSH(K.witnessScript), (0, bip371_1.checkTaprootInputFields)(this.data.inputs[L], K, "updateInput"), this.data.updateInput(L, K), K.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, this.data.inputs[L], L), this;
  }
  updateOutput(L, K) {
    const W = this.data.outputs[L];
    return (0, bip371_1.checkTaprootOutputFields)(W, K, "updateOutput"), this.data.updateOutput(L, K), this;
  }
  addUnknownKeyValToGlobal(L) {
    return this.data.addUnknownKeyValToGlobal(L), this;
  }
  addUnknownKeyValToInput(L, K) {
    return this.data.addUnknownKeyValToInput(L, K), this;
  }
  addUnknownKeyValToOutput(L, K) {
    return this.data.addUnknownKeyValToOutput(L, K), this;
  }
  clearFinalizedInput(L) {
    return this.data.clearFinalizedInput(L), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(L = Buffer$3.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(L), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", { enumerable: !1, writable: !0 });
  }
  getInputOutputCounts() {
    return { inputCount: this.tx.ins.length, outputCount: this.tx.outs.length };
  }
  addInput(L) {
    if (L.hash === void 0 || L.index === void 0 || !Buffer$3.isBuffer(L.hash) && typeof L.hash != "string" || typeof L.index != "number") throw new Error("Error adding input.");
    const K = typeof L.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$3.from(L.hash, "hex")) : L.hash;
    this.tx.addInput(K, L.index, L.sequence);
  }
  addOutput(L) {
    if (L.script === void 0 || L.value === void 0 || !Buffer$3.isBuffer(L.script) || typeof L.value != "number") throw new Error("Error adding output.");
    this.tx.addOutput(L.script, L.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, L, K) {
  switch (K) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const W = payments.p2ms({ output: L });
      return hasSigs(W.m, B.partialSig, W.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1) throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, L, K) {
  if (!L) return !1;
  let W;
  if (W = K ? K.map((V) => {
    const J = compressPubkey(V);
    return L.find((re) => re.pubkey.equals(J));
  }).filter((V) => !!V) : L, W.length > B) throw new Error("Too many signatures");
  return W.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (L) => !!L.masterFingerprint.equals(B.fingerprint) && !!B.derivePath(L.path).publicKey.equals(L.pubkey);
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0) throw new Error("Invalid 32 bit integer");
}
function checkFees(B, L, K) {
  const W = L.__FEE_RATE || B.getFeeRate(), V = L.__EXTRACTED_TX.virtualSize(), J = W * V;
  if (W >= K.maximumFeeRate) throw new Error(`Warning: You are paying around ${(J / 1e8).toFixed(8)} in fees, which is ${W} satoshi per byte for a transaction with a VSize of ${V} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`);
}
function checkInputsForPartialSig(B, L) {
  B.forEach((K) => {
    if ((0, bip371_1.isTaprootInput)(K) ? (0, bip371_1.checkTaprootInputForSigs)(K, L) : (0, psbtutils_1.checkInputForSig)(K, L)) throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: L, sighashType: K } = B;
  L.forEach((W) => {
    const { hashType: V } = bscript.signature.decode(W.signature);
    if (K !== V) throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, L, K) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, L)) throw new Error(`Can not ${K} for this input with the key ${B.toString("hex")}`);
}
function checkTxEmpty(B) {
  if (!B.ins.every((L) => L.script && L.script.length === 0 && L.witness && L.witness.length === 0)) throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, L) {
  B.ins.forEach((K) => {
    checkTxInputCache(L, K);
  });
}
function checkTxInputCache(B, L) {
  const K = (0, bufferutils_1.reverseBuffer)(Buffer$3.from(L.hash)).toString("hex") + ":" + L.index;
  if (B.__TX_IN_CACHE[K]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[K] = 1;
}
function scriptCheckerFactory(B, L) {
  return (K, W, V, J) => {
    const re = B({ redeem: { output: V } }).output;
    if (!W.equals(re)) throw new Error(`${L} for ${J} #${K} doesn't match the scriptPubKey in the prevout`);
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(payments.p2wsh, "Witness script");
function getTxCacheValue(B, L, K, W) {
  if (!K.every(isFinalized)) throw new Error(`PSBT must be finalized to calculate ${L}`);
  if (B === "__FEE_RATE" && W.__FEE_RATE) return W.__FEE_RATE;
  if (B === "__FEE" && W.__FEE) return W.__FEE;
  let V, J = !0;
  return W.__EXTRACTED_TX ? (V = W.__EXTRACTED_TX, J = !1) : V = W.__TX.clone(), inputFinalizeGetAmts(K, V, W, J), B === "__FEE_RATE" ? W.__FEE_RATE : B === "__FEE" ? W.__FEE : void 0;
}
function getFinalScripts(B, L, K, W, V, J) {
  const re = classifyScript(K);
  if (!canFinalize(L, K, re)) throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(K, re, L.partialSig, W, V, J);
}
function prepareFinalScripts(B, L, K, W, V, J) {
  let re, ie;
  const ne = getPayment(B, L, K), oe = J ? payments.p2wsh({ redeem: ne }) : null, ce = V ? payments.p2sh({ redeem: oe || ne }) : null;
  return W ? (ie = oe ? (0, psbtutils_1.witnessStackToScriptWitness)(oe.witness) : (0, psbtutils_1.witnessStackToScriptWitness)(ne.witness), ce && (re = ce.input)) : re = ce ? ce.input : ne.input, { finalScriptSig: re, finalScriptWitness: ie };
}
function getHashAndSighashType(B, L, K, W, V) {
  const J = (0, utils_1$1.checkForInput)(B, L), { hash: re, sighashType: ie, script: ne } = getHashForSig(L, J, W, !1, V);
  return checkScriptForPubkey(K, ne, "sign"), { hash: re, sighashType: ie };
}
function getHashForSig(B, L, K, W, V) {
  const J = K.__TX, re = L.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  let ie, ne;
  if (checkSighashTypeAllowed(re, V), L.nonWitnessUtxo) {
    const pe = nonWitnessUtxoTxFromCache(K, L, B), ke = J.ins[B].hash, ot = pe.getHash();
    if (!ke.equals(ot)) throw new Error(`Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`);
    const at = J.ins[B].index;
    ne = pe.outs[at];
  } else {
    if (!L.witnessUtxo) throw new Error("Need a Utxo input item for signing");
    ne = L.witnessUtxo;
  }
  const { meaningfulScript: oe, type: ce } = getMeaningfulScript(ne.script, B, "input", L.redeemScript, L.witnessScript);
  if (["p2sh-p2wsh", "p2wsh"].indexOf(ce) >= 0) ie = J.hashForWitnessV0(B, oe, ne.value, re);
  else if ((0, psbtutils_1.isP2WPKH)(oe)) {
    const pe = payments.p2pkh({ hash: oe.slice(2) }).output;
    ie = J.hashForWitnessV0(B, pe, ne.value, re);
  } else {
    if (L.nonWitnessUtxo === void 0 && K.__UNSAFE_SIGN_NONSEGWIT === !1) throw new Error(`Input #${B} has witnessUtxo but non-segwit script: ${oe.toString("hex")}`);
    !W && K.__UNSAFE_SIGN_NONSEGWIT, ie = J.hashForSignature(B, oe, re);
  }
  return { script: oe, sighashType: re, hash: ie };
}
function getAllTaprootHashesForSig(B, L, K, W) {
  const V = [];
  if (L.tapInternalKey) {
    const J = getPrevoutTaprootKey(B, L, W);
    J && V.push(J);
  }
  if (L.tapScriptSig) {
    const J = L.tapScriptSig.map((re) => re.pubkey);
    V.push(...J);
  }
  return V.map((J) => getTaprootHashesForSig(B, L, K, J, W)).flat();
}
function getPrevoutTaprootKey(B, L, K) {
  const { script: W } = getScriptAndAmountFromUtxo(B, L, K);
  return (0, psbtutils_1.isP2TR)(W) ? W.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, L, K, W, V, J, re) {
  const ie = V.__TX, ne = L.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ne, re);
  const oe = K.map((at, ft) => getScriptAndAmountFromUtxo(ft, at, V)), ce = oe.map((at) => at.script), pe = oe.map((at) => at.value), ke = [];
  if (L.tapInternalKey && !J) {
    const at = getPrevoutTaprootKey(B, L, V) || Buffer$3.from([]);
    if ((0, bip371_1.toXOnly)(W).equals(at)) {
      const ft = ie.hashForWitnessV1(B, ce, pe, ne);
      ke.push({ pubkey: W, hash: ft });
    }
  }
  const ot = (L.tapLeafScript || []).filter((at) => (0, psbtutils_1.pubkeyInScript)(W, at.script)).map((at) => {
    const ft = (0, bip341_1.tapleafHash)({ output: at.script, version: at.leafVersion });
    return Object.assign({ hash: ft }, at);
  }).filter((at) => !J || J.equals(at.hash)).map((at) => {
    const ft = ie.hashForWitnessV1(B, ce, pe, ne, at.hash);
    return { pubkey: W, hash: ft, leafHash: at.hash };
  });
  return ke.concat(ot);
}
function checkSighashTypeAllowed(B, L) {
  if (L && L.indexOf(B) < 0) {
    const K = sighashTypeToString(B);
    throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${K}`);
  }
}
function getPayment(B, L, K) {
  let W;
  switch (L) {
    case "multisig":
      const V = getSortedSigs(B, K);
      W = payments.p2ms({ output: B, signatures: V });
      break;
    case "pubkey":
      W = payments.p2pk({ output: B, signature: K[0].signature });
      break;
    case "pubkeyhash":
      W = payments.p2pkh({ output: B, pubkey: K[0].pubkey, signature: K[0].signature });
      break;
    case "witnesspubkeyhash":
      W = payments.p2wpkh({ output: B, pubkey: K[0].pubkey, signature: K[0].signature });
  }
  return W;
}
function getScriptFromInput(B, L, K) {
  const W = K.__TX, V = { script: null, isSegwit: !1, isP2SH: !1, isP2WSH: !1 };
  if (V.isP2SH = !!L.redeemScript, V.isP2WSH = !!L.witnessScript, L.witnessScript) V.script = L.witnessScript;
  else if (L.redeemScript) V.script = L.redeemScript;
  else if (L.nonWitnessUtxo) {
    const J = nonWitnessUtxoTxFromCache(K, L, B), re = W.ins[B].index;
    V.script = J.outs[re].script;
  } else L.witnessUtxo && (V.script = L.witnessUtxo.script);
  return (L.witnessScript || (0, psbtutils_1.isP2WPKH)(V.script)) && (V.isSegwit = !0), V;
}
function getSignersFromHD(B, L, K) {
  const W = (0, utils_1$1.checkForInput)(L, B);
  if (!W.bip32Derivation || W.bip32Derivation.length === 0) throw new Error("Need bip32Derivation to sign with HD");
  const V = W.bip32Derivation.map((re) => re.masterFingerprint.equals(K.fingerprint) ? re : void 0).filter((re) => !!re);
  if (V.length === 0) throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
  return V.map((re) => {
    const ie = K.derivePath(re.path);
    if (!re.pubkey.equals(ie.publicKey)) throw new Error("pubkey did not match bip32Derivation");
    return ie;
  });
}
function getSortedSigs(B, L) {
  return payments.p2ms({ output: B }).pubkeys.map((K) => (L.filter((W) => W.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(B) {
  let L = 0;
  function K() {
    const W = varuint.decode(B, L);
    return L += varuint.decode.bytes, W;
  }
  return function() {
    const W = K(), V = [];
    for (let J = 0; J < W; J++) V.push(function(re) {
      return L += re, B.slice(L - re, L);
    }(K()));
    return V;
  }();
}
function sighashTypeToString(B) {
  let L = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (31 & B) {
    case transaction_1.Transaction.SIGHASH_ALL:
      L += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      L += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      L += "SIGHASH_NONE";
  }
  return L;
}
function addNonWitnessTxCache(B, L, K) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[K] = L.nonWitnessUtxo;
  const W = transaction_1.Transaction.fromBuffer(L.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[K] = W;
  const V = B, J = K;
  delete L.nonWitnessUtxo, Object.defineProperty(L, "nonWitnessUtxo", { enumerable: !0, get() {
    const re = V.__NON_WITNESS_UTXO_BUF_CACHE[J], ie = V.__NON_WITNESS_UTXO_TX_CACHE[J];
    if (re !== void 0) return re;
    {
      const ne = ie.toBuffer();
      return V.__NON_WITNESS_UTXO_BUF_CACHE[J] = ne, ne;
    }
  }, set(re) {
    V.__NON_WITNESS_UTXO_BUF_CACHE[J] = re;
  } });
}
function inputFinalizeGetAmts(B, L, K, W) {
  let V = 0;
  B.forEach((ne, oe) => {
    if (W && ne.finalScriptSig && (L.ins[oe].script = ne.finalScriptSig), W && ne.finalScriptWitness && (L.ins[oe].witness = scriptWitnessToWitnessStack(ne.finalScriptWitness)), ne.witnessUtxo) V += ne.witnessUtxo.value;
    else if (ne.nonWitnessUtxo) {
      const ce = nonWitnessUtxoTxFromCache(K, ne, oe), pe = L.ins[oe].index, ke = ce.outs[pe];
      V += ke.value;
    }
  });
  const J = L.outs.reduce((ne, oe) => ne + oe.value, 0), re = V - J;
  if (re < 0) throw new Error("Outputs are spending more than Inputs");
  const ie = L.virtualSize();
  K.__FEE = re, K.__EXTRACTED_TX = L, K.__FEE_RATE = Math.floor(re / ie);
}
function nonWitnessUtxoTxFromCache(B, L, K) {
  const W = B.__NON_WITNESS_UTXO_TX_CACHE;
  return W[K] || addNonWitnessTxCache(B, L, K), W[K];
}
function getScriptFromUtxo(B, L, K) {
  const { script: W } = getScriptAndAmountFromUtxo(B, L, K);
  return W;
}
function getScriptAndAmountFromUtxo(B, L, K) {
  if (L.witnessUtxo !== void 0) return { script: L.witnessUtxo.script, value: L.witnessUtxo.value };
  if (L.nonWitnessUtxo !== void 0) {
    const W = nonWitnessUtxoTxFromCache(K, L, B).outs[K.__TX.ins[B].index];
    return { script: W.script, value: W.value };
  }
  throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, L, K, W) {
  const V = getScriptFromUtxo(K, L, W), { meaningfulScript: J } = getMeaningfulScript(V, K, "input", L.redeemScript, L.witnessScript);
  return (0, psbtutils_1.pubkeyInScript)(B, J);
}
function pubkeyInOutput(B, L, K, W) {
  const V = W.__TX.outs[K].script, { meaningfulScript: J } = getMeaningfulScript(V, K, "output", L.redeemScript, L.witnessScript);
  return (0, psbtutils_1.pubkeyInScript)(B, J);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const L = bscript.decompile(B);
  if (!L) return;
  const K = L[L.length - 1];
  return !Buffer$3.isBuffer(K) || isPubkeyLike(K) || isSigLike(K) ? void 0 : bscript.decompile(K) ? K : void 0;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const L = scriptWitnessToWitnessStack(B), K = L[L.length - 1];
  return isPubkeyLike(K) ? void 0 : bscript.decompile(K) ? K : void 0;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const L = 1 & B[64], K = B.slice(0, 33);
    return K[0] = 2 | L, K;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, L, K, W, V) {
  const J = (0, psbtutils_1.isP2SHScript)(B), re = J && W && (0, psbtutils_1.isP2WSHScript)(W), ie = (0, psbtutils_1.isP2WSHScript)(B);
  if (J && W === void 0) throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ie || re) && V === void 0) throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
  let ne;
  return re ? (ne = V, checkRedeemScript(L, B, W, K), checkWitnessScript(L, W, V, K), checkInvalidP2WSH(ne)) : ie ? (ne = V, checkWitnessScript(L, B, V, K), checkInvalidP2WSH(ne)) : J ? (ne = W, checkRedeemScript(L, B, W, K)) : ne = B, { meaningfulScript: ne, type: re ? "p2sh-p2wsh" : J ? "p2sh" : ie ? "p2wsh" : "raw" };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B)) throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range$1(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const L = requireAddress();
  B.address = L;
  const K = crypto$5;
  B.crypto = K;
  const W = networks$2;
  B.networks = W;
  const V = requirePayments();
  B.payments = V;
  const J = requireScript();
  B.script = J;
  var re = block;
  Object.defineProperty(B, "Block", { enumerable: !0, get: function() {
    return re.Block;
  } });
  var ie = psbt$1;
  Object.defineProperty(B, "Psbt", { enumerable: !0, get: function() {
    return ie.Psbt;
  } });
  var ne = ops;
  Object.defineProperty(B, "opcodes", { enumerable: !0, get: function() {
    return ne.OPS;
  } });
  var oe = transaction;
  Object.defineProperty(B, "Transaction", { enumerable: !0, get: function() {
    return oe.Transaction;
  } });
  var ce = ecc_lib;
  Object.defineProperty(B, "initEccLib", { enumerable: !0, get: function() {
    return ce.initEccLib;
  } });
})(src$4);
var t = function() {
  return t = Object.assign || function(B) {
    for (var L, K = 1, W = arguments.length; K < W; K++) for (var V in L = arguments[K]) Object.prototype.hasOwnProperty.call(L, V) && (B[V] = L[V]);
    return B;
  }, t.apply(this, arguments);
}, r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", e = (B) => {
  if (!B || typeof B != "string") throw new Error(`Expected base58 string but got ${B}`);
  if (B.match(/[IOl0]/gmu)) throw new Error(`Invalid base58 character ${B.match(/[IOl0]/gmu)}`);
  const L = B.match(/^1+/gmu), K = L ? L[0].length : 0, W = (B.length - K) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
  return new Uint8Array([...new Uint8Array(K), ...B.match(/.{1}/gmu).map((J) => r.indexOf(J)).reduce((J, re) => J.map((ie) => {
    const ne = 58 * ie + re;
    return re = ne >> 8, ne;
  }), new Uint8Array(W)).reverse().filter((V = !1, (J) => V = V || J))]);
  var V;
};
(() => {
  const B = Array(256).fill(-1);
  for (let L = 0; L < r.length; ++L) B[r.charCodeAt(L)] = L;
})();
var n = e, s, i$1, o, h$2 = (s = function(B, L) {
  Object.defineProperty(L, "__esModule", { value: !0 }), L.bech32m = L.bech32 = void 0;
  const K = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", W = {};
  for (let pe = 0; pe < 32; pe++) {
    const ke = K.charAt(pe);
    W[ke] = pe;
  }
  function V(pe) {
    const ke = pe >> 25;
    return (33554431 & pe) << 5 ^ 996825010 & -(1 & ke) ^ 642813549 & -(ke >> 1 & 1) ^ 513874426 & -(ke >> 2 & 1) ^ 1027748829 & -(ke >> 3 & 1) ^ 705979059 & -(ke >> 4 & 1);
  }
  function J(pe) {
    let ke = 1;
    for (let ot = 0; ot < pe.length; ++ot) {
      const at = pe.charCodeAt(ot);
      if (at < 33 || at > 126) return "Invalid prefix (" + pe + ")";
      ke = V(ke) ^ at >> 5;
    }
    ke = V(ke);
    for (let ot = 0; ot < pe.length; ++ot) {
      const at = pe.charCodeAt(ot);
      ke = V(ke) ^ 31 & at;
    }
    return ke;
  }
  function re(pe, ke, ot, at) {
    let ft = 0, dt = 0;
    const lt = (1 << ot) - 1, yt = [];
    for (let St = 0; St < pe.length; ++St) for (ft = ft << ke | pe[St], dt += ke; dt >= ot; ) dt -= ot, yt.push(ft >> dt & lt);
    if (at) dt > 0 && yt.push(ft << ot - dt & lt);
    else {
      if (dt >= ke) return "Excess padding";
      if (ft << ot - dt & lt) return "Non-zero padding";
    }
    return yt;
  }
  function ie(pe) {
    return re(pe, 8, 5, !0);
  }
  function ne(pe) {
    const ke = re(pe, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
  }
  function oe(pe) {
    const ke = re(pe, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
    throw new Error(ke);
  }
  function ce(pe) {
    let ke;
    function ot(at, ft) {
      if (ft = ft || 90, at.length < 8) return at + " too short";
      if (at.length > ft) return "Exceeds length limit";
      const dt = at.toLowerCase(), lt = at.toUpperCase();
      if (at !== dt && at !== lt) return "Mixed-case string " + at;
      const yt = (at = dt).lastIndexOf("1");
      if (yt === -1) return "No separator character for " + at;
      if (yt === 0) return "Missing prefix for " + at;
      const St = at.slice(0, yt), mt = at.slice(yt + 1);
      if (mt.length < 6) return "Data too short";
      let $t = J(St);
      if (typeof $t == "string") return $t;
      const It = [];
      for (let Ut = 0; Ut < mt.length; ++Ut) {
        const ut = mt.charAt(Ut), ht = W[ut];
        if (ht === void 0) return "Unknown character " + ut;
        $t = V($t) ^ ht, Ut + 6 >= mt.length || It.push(ht);
      }
      return $t !== ke ? "Invalid checksum for " + at : { prefix: St, words: It };
    }
    return ke = pe === "bech32" ? 1 : 734539939, { decodeUnsafe: function(at, ft) {
      const dt = ot(at, ft);
      if (typeof dt == "object") return dt;
    }, decode: function(at, ft) {
      const dt = ot(at, ft);
      if (typeof dt == "object") return dt;
      throw new Error(dt);
    }, encode: function(at, ft, dt) {
      if (dt = dt || 90, at.length + 7 + ft.length > dt) throw new TypeError("Exceeds length limit");
      let lt = J(at = at.toLowerCase());
      if (typeof lt == "string") throw new Error(lt);
      let yt = at + "1";
      for (let St = 0; St < ft.length; ++St) {
        const mt = ft[St];
        if (mt >> 5) throw new Error("Non 5-bit word");
        lt = V(lt) ^ mt, yt += K.charAt(mt);
      }
      for (let St = 0; St < 6; ++St) lt = V(lt);
      lt ^= ke;
      for (let St = 0; St < 6; ++St) yt += K.charAt(lt >> 5 * (5 - St) & 31);
      return yt;
    }, toWords: ie, fromWordsUnsafe: ne, fromWords: oe };
  }
  L.bech32 = ce("bech32"), L.bech32m = ce("bech32m");
}, s(i$1 = { exports: {} }, i$1.exports), i$1.exports);
(o = h$2) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
var c = h$2.bech32m, a = h$2.bech32;
const f = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];
class l {
  constructor() {
    this.A = 1779033703, this.B = -1150833019, this.C = 1013904242, this.D = -1521486534, this.E = 1359893119, this.F = -1694144372, this.G = 528734635, this.H = 1541459225, this._size = 0, this._sp = 0, (!p || w >= 8e3) && (p = new ArrayBuffer(8e3), w = 0), this._byte = new Uint8Array(p, w, 80), this._word = new Int32Array(p, w, 20), w += 80;
  }
  update(L) {
    if (typeof L == "string") return this._utf8(L);
    if (L == null) throw new TypeError("Invalid type: " + typeof L);
    const K = L.byteOffset, W = L.byteLength;
    let V = W / 64 | 0, J = 0;
    if (V && !(3 & K) && !(this._size % 64)) {
      const re = new Int32Array(L.buffer, K, 16 * V);
      for (; V--; ) this._int32(re, J >> 2), J += 64;
      this._size += J;
    }
    if (L.BYTES_PER_ELEMENT !== 1 && L.buffer) {
      const re = new Uint8Array(L.buffer, K + J, W - J);
      return this._uint8(re);
    }
    return J === W ? this : this._uint8(L, J);
  }
  _uint8(L, K) {
    const { _byte: W, _word: V } = this, J = L.length;
    for (K |= 0; K < J; ) {
      const re = this._size % 64;
      let ie = re;
      for (; K < J && ie < 64; ) W[ie++] = L[K++];
      ie >= 64 && this._int32(V), this._size += ie - re;
    }
    return this;
  }
  _utf8(L) {
    const { _byte: K, _word: W } = this, V = L.length;
    let J = this._sp;
    for (let re = 0; re < V; ) {
      const ie = this._size % 64;
      let ne = ie;
      for (; re < V && ne < 64; ) {
        let oe = 0 | L.charCodeAt(re++);
        oe < 128 ? K[ne++] = oe : oe < 2048 ? (K[ne++] = 192 | oe >>> 6, K[ne++] = 128 | 63 & oe) : oe < 55296 || oe > 57343 ? (K[ne++] = 224 | oe >>> 12, K[ne++] = 128 | oe >>> 6 & 63, K[ne++] = 128 | 63 & oe) : J ? (oe = ((1023 & J) << 10) + (1023 & oe) + 65536, K[ne++] = 240 | oe >>> 18, K[ne++] = 128 | oe >>> 12 & 63, K[ne++] = 128 | oe >>> 6 & 63, K[ne++] = 128 | 63 & oe, J = 0) : J = oe;
      }
      ne >= 64 && (this._int32(W), W[0] = W[16]), this._size += ne - ie;
    }
    return this._sp = J, this;
  }
  _int32(L, K) {
    let { A: W, B: V, C: J, D: re, E: ie, F: ne, G: oe, H: ce } = this, pe = 0;
    for (K |= 0; pe < 16; ) d[pe++] = g(L[K++]);
    for (pe = 16; pe < 64; pe++) d[pe] = A(d[pe - 2]) + d[pe - 7] + m(d[pe - 15]) + d[pe - 16] | 0;
    for (pe = 0; pe < 64; pe++) {
      const ke = ce + E(ie) + b(ie, ne, oe) + f[pe] + d[pe] | 0, ot = v(W) + _(W, V, J) | 0;
      ce = oe, oe = ne, ne = ie, ie = re + ke | 0, re = J, J = V, V = W, W = ke + ot | 0;
    }
    this.A = W + this.A | 0, this.B = V + this.B | 0, this.C = J + this.C | 0, this.D = re + this.D | 0, this.E = ie + this.E | 0, this.F = ne + this.F | 0, this.G = oe + this.G | 0, this.H = ce + this.H | 0;
  }
  digest(L) {
    const { _byte: K, _word: W } = this;
    let V = this._size % 64 | 0;
    for (K[V++] = 128; 3 & V; ) K[V++] = 0;
    if (V >>= 2, V > 14) {
      for (; V < 16; ) W[V++] = 0;
      V = 0, this._int32(W);
    }
    for (; V < 16; ) W[V++] = 0;
    const J = 8 * this._size, re = (4294967295 & J) >>> 0, ie = (J - re) / 4294967296;
    return ie && (W[14] = g(ie)), re && (W[15] = g(re)), this._int32(W), L === "hex" ? this._hex() : this._bin();
  }
  _hex() {
    const { A: L, B: K, C: W, D: V, E: J, F: re, G: ie, H: ne } = this;
    return y(L) + y(K) + y(W) + y(V) + y(J) + y(re) + y(ie) + y(ne);
  }
  _bin() {
    const { A: L, B: K, C: W, D: V, E: J, F: re, G: ie, H: ne, _byte: oe, _word: ce } = this;
    return ce[0] = g(L), ce[1] = g(K), ce[2] = g(W), ce[3] = g(V), ce[4] = g(J), ce[5] = g(re), ce[6] = g(ie), ce[7] = g(ne), oe.slice(0, 32);
  }
}
const d = new Int32Array(64);
let p, w = 0;
const y = (B) => (B + 4294967296).toString(16).substr(-8), g = new Uint8Array(new Uint16Array([65279]).buffer)[0] === 254 ? (B) => B : (B) => B << 24 & 4278190080 | B << 8 & 16711680 | B >> 8 & 65280 | B >> 24 & 255, b = (B, L, K) => K ^ B & (L ^ K), _ = (B, L, K) => B & L | K & (B | L), v = (B) => (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10), E = (B) => (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7), m = (B) => (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3, A = (B) => (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
var x, k, I = function(B) {
  return new l().update(B).digest();
};
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
var C = { 0: { type: k.p2pkh, network: x.mainnet }, 111: { type: k.p2pkh, network: x.testnet }, 5: { type: k.p2sh, network: x.mainnet }, 196: { type: k.p2sh, network: x.testnet } }, z = function(B) {
  var L, K = B.substr(0, 2).toLowerCase();
  if (K === "bc" || K === "tb") return function(ne) {
    var oe;
    try {
      oe = ne.startsWith("bc1p") || ne.startsWith("tb1p") || ne.startsWith("bcrt1p") ? c.decode(ne) : a.decode(ne);
    } catch {
      throw new Error("Invalid address");
    }
    var ce = { bc: x.mainnet, tb: x.testnet, bcrt: x.regtest }[oe.prefix];
    if (ce === void 0) throw new Error("Invalid address");
    var pe = oe.words[0];
    if (pe < 0 || pe > 16) throw new Error("Invalid address");
    return { bech32: !0, network: ce, address: ne, type: a.fromWords(oe.words.slice(1)).length === 20 ? k.p2wpkh : pe === 1 ? k.p2tr : k.p2wsh };
  }(B);
  try {
    L = n(B);
  } catch {
    throw new Error("Invalid address");
  }
  var W = L.length;
  if (W !== 25) throw new Error("Invalid address");
  var V = L[0], J = L.slice(W - 4, W), re = L.slice(0, W - 4), ie = I(I(re)).slice(0, 4);
  if (J.some(function(ne, oe) {
    return ne !== ie[oe];
  })) throw new Error("Invalid address");
  if (!Object.keys(C).map(Number).includes(V)) throw new Error("Invalid address");
  return t(t({}, C[V]), { address: B, bech32: !1 });
}, O = function(B, L) {
  try {
    var K = z(B);
    return !L || L === K.network;
  } catch {
    return !1;
  }
}, src$2 = {}, bip32 = {}, crypto$3 = {}, hmac$2 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const L = _assert, K = utils$5;
  class W extends K.Hash {
    constructor(J, re) {
      super(), this.finished = !1, this.destroyed = !1, (0, L.hash)(J);
      const ie = (0, K.toBytes)(re);
      if (this.iHash = J.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ne = this.blockLen, oe = new Uint8Array(ne);
      oe.set(ie.length > ne ? J.create().update(ie).digest() : ie);
      for (let ce = 0; ce < oe.length; ce++) oe[ce] ^= 54;
      this.iHash.update(oe), this.oHash = J.create();
      for (let ce = 0; ce < oe.length; ce++) oe[ce] ^= 106;
      this.oHash.update(oe), oe.fill(0);
    }
    update(J) {
      return (0, L.exists)(this), this.iHash.update(J), this;
    }
    digestInto(J) {
      (0, L.exists)(this), (0, L.bytes)(J, this.outputLen), this.finished = !0, this.iHash.digestInto(J), this.oHash.update(J), this.oHash.digestInto(J), this.destroy();
    }
    digest() {
      const J = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(J), J;
    }
    _cloneInto(J) {
      J || (J = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: re, iHash: ie, finished: ne, destroyed: oe, blockLen: ce, outputLen: pe } = this;
      return J.finished = ne, J.destroyed = oe, J.blockLen = ce, J.outputLen = pe, J.oHash = re._cloneInto(J.oHash), J.iHash = ie._cloneInto(J.iHash), J;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = W, B.hmac = (V, J, re) => new W(V, J).update(re).digest(), B.hmac.create = (V, J) => new W(V, J);
})(hmac$2);
var sha512$2 = {}, _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: !0 }), _u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = void 0, _u64.fromBig = fromBig, _u64.split = split, _u64.add = add;
const U32_MASK64 = BigInt(2 ** 32 - 1), _32n = BigInt(32);
function fromBig(B, L = !1) {
  return L ? { h: Number(B & U32_MASK64), l: Number(B >> _32n & U32_MASK64) } : { h: 0 | Number(B >> _32n & U32_MASK64), l: 0 | Number(B & U32_MASK64) };
}
function split(B, L = !1) {
  let K = new Uint32Array(B.length), W = new Uint32Array(B.length);
  for (let V = 0; V < B.length; V++) {
    const { h: J, l: re } = fromBig(B[V], L);
    [K[V], W[V]] = [J, re];
  }
  return [K, W];
}
const toBig = (B, L) => BigInt(B >>> 0) << _32n | BigInt(L >>> 0);
_u64.toBig = toBig;
const shrSH = (B, L, K) => B >>> K;
_u64.shrSH = shrSH;
const shrSL = (B, L, K) => B << 32 - K | L >>> K;
_u64.shrSL = shrSL;
const rotrSH = (B, L, K) => B >>> K | L << 32 - K;
_u64.rotrSH = rotrSH;
const rotrSL = (B, L, K) => B << 32 - K | L >>> K;
_u64.rotrSL = rotrSL;
const rotrBH = (B, L, K) => B << 64 - K | L >>> K - 32;
_u64.rotrBH = rotrBH;
const rotrBL = (B, L, K) => B >>> K - 32 | L << 64 - K;
_u64.rotrBL = rotrBL;
const rotr32H = (B, L) => L;
_u64.rotr32H = rotr32H;
const rotr32L = (B, L) => B;
_u64.rotr32L = rotr32L;
const rotlSH = (B, L, K) => B << K | L >>> 32 - K;
_u64.rotlSH = rotlSH;
const rotlSL = (B, L, K) => L << K | B >>> 32 - K;
_u64.rotlSL = rotlSL;
const rotlBH = (B, L, K) => L << K - 32 | B >>> 64 - K;
_u64.rotlBH = rotlBH;
const rotlBL = (B, L, K) => B << K - 32 | L >>> 64 - K;
function add(B, L, K, W) {
  const V = (L >>> 0) + (W >>> 0);
  return { h: B + K + (V / 2 ** 32 | 0) | 0, l: 0 | V };
}
_u64.rotlBL = rotlBL;
const add3L = (B, L, K) => (B >>> 0) + (L >>> 0) + (K >>> 0);
_u64.add3L = add3L;
const add3H = (B, L, K, W) => L + K + W + (B / 2 ** 32 | 0) | 0;
_u64.add3H = add3H;
const add4L = (B, L, K, W) => (B >>> 0) + (L >>> 0) + (K >>> 0) + (W >>> 0);
_u64.add4L = add4L;
const add4H = (B, L, K, W, V) => L + K + W + V + (B / 2 ** 32 | 0) | 0;
_u64.add4H = add4H;
const add5L = (B, L, K, W, V) => (B >>> 0) + (L >>> 0) + (K >>> 0) + (W >>> 0) + (V >>> 0);
_u64.add5L = add5L;
const add5H = (B, L, K, W, V, J) => L + K + W + V + J + (B / 2 ** 32 | 0) | 0;
_u64.add5H = add5H;
const u64 = { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L };
_u64.default = u64, Object.defineProperty(sha512$2, "__esModule", { value: !0 }), sha512$2.sha384 = sha512$2.sha512_256 = sha512$2.sha512_224 = sha512$2.sha512 = sha512$2.SHA384 = sha512$2.SHA512_256 = sha512$2.SHA512_224 = sha512$2.SHA512 = void 0;
const _md_js_1 = _md, _u64_js_1 = _u64, utils_js_1 = utils$5, [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((B) => BigInt(B))), SHA512_W_H = new Uint32Array(80), SHA512_W_L = new Uint32Array(80);
class SHA512 extends _md_js_1.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: L, Al: K, Bh: W, Bl: V, Ch: J, Cl: re, Dh: ie, Dl: ne, Eh: oe, El: ce, Fh: pe, Fl: ke, Gh: ot, Gl: at, Hh: ft, Hl: dt } = this;
    return [L, K, W, V, J, re, ie, ne, oe, ce, pe, ke, ot, at, ft, dt];
  }
  set(L, K, W, V, J, re, ie, ne, oe, ce, pe, ke, ot, at, ft, dt) {
    this.Ah = 0 | L, this.Al = 0 | K, this.Bh = 0 | W, this.Bl = 0 | V, this.Ch = 0 | J, this.Cl = 0 | re, this.Dh = 0 | ie, this.Dl = 0 | ne, this.Eh = 0 | oe, this.El = 0 | ce, this.Fh = 0 | pe, this.Fl = 0 | ke, this.Gh = 0 | ot, this.Gl = 0 | at, this.Hh = 0 | ft, this.Hl = 0 | dt;
  }
  process(L, K) {
    for (let St = 0; St < 16; St++, K += 4) SHA512_W_H[St] = L.getUint32(K), SHA512_W_L[St] = L.getUint32(K += 4);
    for (let St = 16; St < 80; St++) {
      const mt = 0 | SHA512_W_H[St - 15], $t = 0 | SHA512_W_L[St - 15], It = _u64_js_1.default.rotrSH(mt, $t, 1) ^ _u64_js_1.default.rotrSH(mt, $t, 8) ^ _u64_js_1.default.shrSH(mt, $t, 7), Ut = _u64_js_1.default.rotrSL(mt, $t, 1) ^ _u64_js_1.default.rotrSL(mt, $t, 8) ^ _u64_js_1.default.shrSL(mt, $t, 7), ut = 0 | SHA512_W_H[St - 2], ht = 0 | SHA512_W_L[St - 2], Ce = _u64_js_1.default.rotrSH(ut, ht, 19) ^ _u64_js_1.default.rotrBH(ut, ht, 61) ^ _u64_js_1.default.shrSH(ut, ht, 6), nt = _u64_js_1.default.rotrSL(ut, ht, 19) ^ _u64_js_1.default.rotrBL(ut, ht, 61) ^ _u64_js_1.default.shrSL(ut, ht, 6), rt = _u64_js_1.default.add4L(Ut, nt, SHA512_W_L[St - 7], SHA512_W_L[St - 16]), it = _u64_js_1.default.add4H(rt, It, Ce, SHA512_W_H[St - 7], SHA512_W_H[St - 16]);
      SHA512_W_H[St] = 0 | it, SHA512_W_L[St] = 0 | rt;
    }
    let { Ah: W, Al: V, Bh: J, Bl: re, Ch: ie, Cl: ne, Dh: oe, Dl: ce, Eh: pe, El: ke, Fh: ot, Fl: at, Gh: ft, Gl: dt, Hh: lt, Hl: yt } = this;
    for (let St = 0; St < 80; St++) {
      const mt = _u64_js_1.default.rotrSH(pe, ke, 14) ^ _u64_js_1.default.rotrSH(pe, ke, 18) ^ _u64_js_1.default.rotrBH(pe, ke, 41), $t = _u64_js_1.default.rotrSL(pe, ke, 14) ^ _u64_js_1.default.rotrSL(pe, ke, 18) ^ _u64_js_1.default.rotrBL(pe, ke, 41), It = pe & ot ^ ~pe & ft, Ut = ke & at ^ ~ke & dt, ut = _u64_js_1.default.add5L(yt, $t, Ut, SHA512_Kl[St], SHA512_W_L[St]), ht = _u64_js_1.default.add5H(ut, lt, mt, It, SHA512_Kh[St], SHA512_W_H[St]), Ce = 0 | ut, nt = _u64_js_1.default.rotrSH(W, V, 28) ^ _u64_js_1.default.rotrBH(W, V, 34) ^ _u64_js_1.default.rotrBH(W, V, 39), rt = _u64_js_1.default.rotrSL(W, V, 28) ^ _u64_js_1.default.rotrBL(W, V, 34) ^ _u64_js_1.default.rotrBL(W, V, 39), it = W & J ^ W & ie ^ J & ie, st = V & re ^ V & ne ^ re & ne;
      lt = 0 | ft, yt = 0 | dt, ft = 0 | ot, dt = 0 | at, ot = 0 | pe, at = 0 | ke, { h: pe, l: ke } = _u64_js_1.default.add(0 | oe, 0 | ce, 0 | ht, 0 | Ce), oe = 0 | ie, ce = 0 | ne, ie = 0 | J, ne = 0 | re, J = 0 | W, re = 0 | V;
      const Oe = _u64_js_1.default.add3L(Ce, rt, st);
      W = _u64_js_1.default.add3H(Oe, ht, nt, it), V = 0 | Oe;
    }
    ({ h: W, l: V } = _u64_js_1.default.add(0 | this.Ah, 0 | this.Al, 0 | W, 0 | V)), { h: J, l: re } = _u64_js_1.default.add(0 | this.Bh, 0 | this.Bl, 0 | J, 0 | re), { h: ie, l: ne } = _u64_js_1.default.add(0 | this.Ch, 0 | this.Cl, 0 | ie, 0 | ne), { h: oe, l: ce } = _u64_js_1.default.add(0 | this.Dh, 0 | this.Dl, 0 | oe, 0 | ce), { h: pe, l: ke } = _u64_js_1.default.add(0 | this.Eh, 0 | this.El, 0 | pe, 0 | ke), { h: ot, l: at } = _u64_js_1.default.add(0 | this.Fh, 0 | this.Fl, 0 | ot, 0 | at), { h: ft, l: dt } = _u64_js_1.default.add(0 | this.Gh, 0 | this.Gl, 0 | ft, 0 | dt), { h: lt, l: yt } = _u64_js_1.default.add(0 | this.Hh, 0 | this.Hl, 0 | lt, 0 | yt), this.set(W, V, J, re, ie, ne, oe, ce, pe, ke, ot, at, ft, dt, lt, yt);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
sha512$2.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
sha512$2.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
sha512$2.SHA512_256 = SHA512_256;
class SHA384 extends SHA512 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
sha512$2.SHA384 = SHA384, sha512$2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512()), sha512$2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224()), sha512$2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256()), sha512$2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384()), Object.defineProperty(crypto$3, "__esModule", { value: !0 }), crypto$3.hmacSHA512 = crypto$3.hash160 = void 0;
const hmac_1$1 = hmac$2, ripemd160_1 = ripemd160$1, sha256_1$5 = sha256$5, sha512_1 = sha512$2;
function hash160(B) {
  const L = (0, sha256_1$5.sha256)(Uint8Array.from(B));
  return Buffer$3.from((0, ripemd160_1.ripemd160)(L));
}
function hmacSHA512(B, L) {
  return Buffer$3.from((0, hmac_1$1.hmac)(sha512_1.sha512, B, L));
}
crypto$3.hash160 = hash160, crypto$3.hmacSHA512 = hmacSHA512;
var testecc$1 = {};
Object.defineProperty(testecc$1, "__esModule", { value: !0 }), testecc$1.testEcc = void 0;
const h$1 = (B) => Buffer$3.from(B, "hex");
function testEcc$1(B) {
  if (assert$1(B.isPoint(h$1("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$1(!B.isPoint(h$1("030000000000000000000000000000000000000000000000000000000000000005"))), assert$1(B.isPrivate(h$1("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert$1(B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert$1(!B.isPrivate(h$1("0000000000000000000000000000000000000000000000000000000000000000"))), assert$1(!B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), assert$1(!B.isPrivate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), assert$1(Buffer$3.from(B.pointFromScalar(h$1("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h$1("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99"))), B.xOnlyPointAddTweak) {
    assert$1(B.xOnlyPointAddTweak(h$1("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let L = B.xOnlyPointAddTweak(h$1("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h$1("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    assert$1(Buffer$3.from(L.xOnlyPubkey).equals(h$1("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) && L.parity === 1), L = B.xOnlyPointAddTweak(h$1("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h$1("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  assert$1(Buffer$3.from(B.pointAddScalar(h$1("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("0000000000000000000000000000000000000000000000000000000000000003"))).equals(h$1("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5"))), assert$1(Buffer$3.from(B.privateAdd(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h$1("0000000000000000000000000000000000000000000000000000000000000002"))).equals(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), B.privateNegate && (assert$1(Buffer$3.from(B.privateNegate(h$1("0000000000000000000000000000000000000000000000000000000000000001"))).equals(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert$1(Buffer$3.from(B.privateNegate(h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"))).equals(h$1("0000000000000000000000000000000000000000000000000000000000000003"))), assert$1(Buffer$3.from(B.privateNegate(h$1("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h$1("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")))), assert$1(Buffer$3.from(B.sign(h$1("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))).equals(h$1("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), assert$1(B.verify(h$1("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h$1("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h$1("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), B.signSchnorr && assert$1(Buffer$3.from(B.signSchnorr(h$1("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h$1("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h$1("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906"))).equals(h$1("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"))), B.verifySchnorr && assert$1(B.verifySchnorr(h$1("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h$1("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h$1("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function assert$1(B) {
  if (!B) throw new Error("ecc library invalid");
}
testecc$1.testEcc = testEcc$1;
var lib$2 = {};
(function(B) {
  function L(ut) {
    return ut instanceof Uint8Array || ut != null && typeof ut == "object" && ut.constructor.name === "Uint8Array";
  }
  function K(...ut) {
    const ht = (it) => it, Ce = (it, st) => (Oe) => it(st(Oe)), nt = ut.map((it) => it.encode).reduceRight(Ce, ht), rt = ut.map((it) => it.decode).reduce(Ce, ht);
    return { encode: nt, decode: rt };
  }
  function W(ut) {
    return { encode: (ht) => {
      if (!Array.isArray(ht) || ht.length && typeof ht[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
      return ht.map((Ce) => {
        if (Ce < 0 || Ce >= ut.length) throw new Error(`Digit index outside alphabet: ${Ce} (alphabet: ${ut.length})`);
        return ut[Ce];
      });
    }, decode: (ht) => {
      if (!Array.isArray(ht) || ht.length && typeof ht[0] != "string") throw new Error("alphabet.decode input should be array of strings");
      return ht.map((Ce) => {
        if (typeof Ce != "string") throw new Error(`alphabet.decode: not string element=${Ce}`);
        const nt = ut.indexOf(Ce);
        if (nt === -1) throw new Error(`Unknown letter: "${Ce}". Allowed: ${ut}`);
        return nt;
      });
    } };
  }
  function V(ut = "") {
    if (typeof ut != "string") throw new Error("join separator should be string");
    return { encode: (ht) => {
      if (!Array.isArray(ht) || ht.length && typeof ht[0] != "string") throw new Error("join.encode input should be array of strings");
      for (let Ce of ht) if (typeof Ce != "string") throw new Error(`join.encode: non-string input=${Ce}`);
      return ht.join(ut);
    }, decode: (ht) => {
      if (typeof ht != "string") throw new Error("join.decode input should be string");
      return ht.split(ut);
    } };
  }
  function J(ut, ht = "=") {
    if (typeof ht != "string") throw new Error("padding chr should be string");
    return { encode(Ce) {
      if (!Array.isArray(Ce) || Ce.length && typeof Ce[0] != "string") throw new Error("padding.encode input should be array of strings");
      for (let nt of Ce) if (typeof nt != "string") throw new Error(`padding.encode: non-string input=${nt}`);
      for (; Ce.length * ut % 8; ) Ce.push(ht);
      return Ce;
    }, decode(Ce) {
      if (!Array.isArray(Ce) || Ce.length && typeof Ce[0] != "string") throw new Error("padding.encode input should be array of strings");
      for (let rt of Ce) if (typeof rt != "string") throw new Error(`padding.decode: non-string input=${rt}`);
      let nt = Ce.length;
      if (nt * ut % 8) throw new Error("Invalid padding: string should have whole number of bytes");
      for (; nt > 0 && Ce[nt - 1] === ht; nt--) if (!((nt - 1) * ut % 8)) throw new Error("Invalid padding: string has too much padding");
      return Ce.slice(0, nt);
    } };
  }
  function re(ut) {
    if (typeof ut != "function") throw new Error("normalize fn should be function");
    return { encode: (ht) => ht, decode: (ht) => ut(ht) };
  }
  function ie(ut, ht, Ce) {
    if (ht < 2) throw new Error(`convertRadix: wrong from=${ht}, base cannot be less than 2`);
    if (Ce < 2) throw new Error(`convertRadix: wrong to=${Ce}, base cannot be less than 2`);
    if (!Array.isArray(ut)) throw new Error("convertRadix: data should be array");
    if (!ut.length) return [];
    let nt = 0;
    const rt = [], it = Array.from(ut);
    for (it.forEach((st) => {
      if (st < 0 || st >= ht) throw new Error(`Wrong integer: ${st}`);
    }); ; ) {
      let st = 0, Oe = !0;
      for (let ct = nt; ct < it.length; ct++) {
        const pt = it[ct], gt = ht * st + pt;
        if (!Number.isSafeInteger(gt) || ht * st / ht !== st || gt - pt != ht * st) throw new Error("convertRadix: carry overflow");
        st = gt % Ce;
        const vt = Math.floor(gt / Ce);
        if (it[ct] = vt, !Number.isSafeInteger(vt) || vt * Ce + st !== gt) throw new Error("convertRadix: carry overflow");
        Oe && (vt ? Oe = !1 : nt = ct);
      }
      if (rt.push(st), Oe) break;
    }
    for (let st = 0; st < ut.length - 1 && ut[st] === 0; st++) rt.push(0);
    return rt.reverse();
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bytes = B.stringToBytes = B.str = B.bytesToString = B.hex = B.utf8 = B.bech32m = B.bech32 = B.base58check = B.createBase58check = B.base58xmr = B.base58xrp = B.base58flickr = B.base58 = B.base64urlnopad = B.base64url = B.base64nopad = B.base64 = B.base32crockford = B.base32hexnopad = B.base32hex = B.base32nopad = B.base32 = B.base16 = B.utils = void 0, B.assertNumber = function(ut) {
    if (!Number.isSafeInteger(ut)) throw new Error(`Wrong integer: ${ut}`);
  };
  const ne = (ut, ht) => ht ? ne(ht, ut % ht) : ut, oe = (ut, ht) => ut + (ht - ne(ut, ht));
  function ce(ut, ht, Ce, nt) {
    if (!Array.isArray(ut)) throw new Error("convertRadix2: data should be array");
    if (ht <= 0 || ht > 32) throw new Error(`convertRadix2: wrong from=${ht}`);
    if (Ce <= 0 || Ce > 32) throw new Error(`convertRadix2: wrong to=${Ce}`);
    if (oe(ht, Ce) > 32) throw new Error(`convertRadix2: carry overflow from=${ht} to=${Ce} carryBits=${oe(ht, Ce)}`);
    let rt = 0, it = 0;
    const st = 2 ** Ce - 1, Oe = [];
    for (const ct of ut) {
      if (ct >= 2 ** ht) throw new Error(`convertRadix2: invalid data word=${ct} from=${ht}`);
      if (rt = rt << ht | ct, it + ht > 32) throw new Error(`convertRadix2: carry overflow pos=${it} from=${ht}`);
      for (it += ht; it >= Ce; it -= Ce) Oe.push((rt >> it - Ce & st) >>> 0);
      rt &= 2 ** it - 1;
    }
    if (rt = rt << Ce - it & st, !nt && it >= ht) throw new Error("Excess padding");
    if (!nt && rt) throw new Error(`Non-zero padding: ${rt}`);
    return nt && it > 0 && Oe.push(rt >>> 0), Oe;
  }
  function pe(ut) {
    return { encode: (ht) => {
      if (!L(ht)) throw new Error("radix.encode input should be Uint8Array");
      return ie(Array.from(ht), 256, ut);
    }, decode: (ht) => {
      if (!Array.isArray(ht) || ht.length && typeof ht[0] != "number") throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(ie(ht, ut, 256));
    } };
  }
  function ke(ut, ht = !1) {
    if (ut <= 0 || ut > 32) throw new Error("radix2: bits should be in (0..32]");
    if (oe(8, ut) > 32 || oe(ut, 8) > 32) throw new Error("radix2: carry overflow");
    return { encode: (Ce) => {
      if (!L(Ce)) throw new Error("radix2.encode input should be Uint8Array");
      return ce(Array.from(Ce), 8, ut, !ht);
    }, decode: (Ce) => {
      if (!Array.isArray(Ce) || Ce.length && typeof Ce[0] != "number") throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(ce(Ce, ut, 8, ht));
    } };
  }
  function ot(ut) {
    if (typeof ut != "function") throw new Error("unsafeWrapper fn should be function");
    return function(...ht) {
      try {
        return ut.apply(null, ht);
      } catch {
      }
    };
  }
  function at(ut, ht) {
    if (typeof ht != "function") throw new Error("checksum fn should be function");
    return { encode(Ce) {
      if (!L(Ce)) throw new Error("checksum.encode: input should be Uint8Array");
      const nt = ht(Ce).slice(0, ut), rt = new Uint8Array(Ce.length + ut);
      return rt.set(Ce), rt.set(nt, Ce.length), rt;
    }, decode(Ce) {
      if (!L(Ce)) throw new Error("checksum.decode: input should be Uint8Array");
      const nt = Ce.slice(0, -ut), rt = ht(nt).slice(0, ut), it = Ce.slice(-ut);
      for (let st = 0; st < ut; st++) if (rt[st] !== it[st]) throw new Error("Invalid checksum");
      return nt;
    } };
  }
  B.utils = { alphabet: W, chain: K, checksum: at, convertRadix: ie, convertRadix2: ce, radix: pe, radix2: ke, join: V, padding: J }, B.base16 = K(ke(4), W("0123456789ABCDEF"), V("")), B.base32 = K(ke(5), W("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), J(5), V("")), B.base32nopad = K(ke(5), W("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), V("")), B.base32hex = K(ke(5), W("0123456789ABCDEFGHIJKLMNOPQRSTUV"), J(5), V("")), B.base32hexnopad = K(ke(5), W("0123456789ABCDEFGHIJKLMNOPQRSTUV"), V("")), B.base32crockford = K(ke(5), W("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), V(""), re((ut) => ut.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), B.base64 = K(ke(6), W("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), J(6), V("")), B.base64nopad = K(ke(6), W("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), V("")), B.base64url = K(ke(6), W("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), J(6), V("")), B.base64urlnopad = K(ke(6), W("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), V(""));
  const ft = (ut) => K(pe(58), W(ut), V(""));
  B.base58 = ft("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), B.base58flickr = ft("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), B.base58xrp = ft("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const dt = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  B.base58xmr = { encode(ut) {
    let ht = "";
    for (let Ce = 0; Ce < ut.length; Ce += 8) {
      const nt = ut.subarray(Ce, Ce + 8);
      ht += B.base58.encode(nt).padStart(dt[nt.length], "1");
    }
    return ht;
  }, decode(ut) {
    let ht = [];
    for (let Ce = 0; Ce < ut.length; Ce += 11) {
      const nt = ut.slice(Ce, Ce + 11), rt = dt.indexOf(nt.length), it = B.base58.decode(nt);
      for (let st = 0; st < it.length - rt; st++) if (it[st] !== 0) throw new Error("base58xmr: wrong padding");
      ht = ht.concat(Array.from(it.slice(it.length - rt)));
    }
    return Uint8Array.from(ht);
  } }, B.createBase58check = (ut) => K(at(4, (ht) => ut(ut(ht))), B.base58), B.base58check = B.createBase58check;
  const lt = K(W("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), V("")), yt = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function St(ut) {
    const ht = ut >> 25;
    let Ce = (33554431 & ut) << 5;
    for (let nt = 0; nt < yt.length; nt++) (ht >> nt & 1) == 1 && (Ce ^= yt[nt]);
    return Ce;
  }
  function mt(ut, ht, Ce = 1) {
    const nt = ut.length;
    let rt = 1;
    for (let it = 0; it < nt; it++) {
      const st = ut.charCodeAt(it);
      if (st < 33 || st > 126) throw new Error(`Invalid prefix (${ut})`);
      rt = St(rt) ^ st >> 5;
    }
    rt = St(rt);
    for (let it = 0; it < nt; it++) rt = St(rt) ^ 31 & ut.charCodeAt(it);
    for (let it of ht) rt = St(rt) ^ it;
    for (let it = 0; it < 6; it++) rt = St(rt);
    return rt ^= Ce, lt.encode(ce([rt % 2 ** 30], 30, 5, !1));
  }
  function $t(ut) {
    const ht = ut === "bech32" ? 1 : 734539939, Ce = ke(5), nt = Ce.decode, rt = Ce.encode, it = ot(nt);
    function st(Oe, ct = 90) {
      if (typeof Oe != "string") throw new Error("bech32.decode input should be string, not " + typeof Oe);
      if (Oe.length < 8 || ct !== !1 && Oe.length > ct) throw new TypeError(`Wrong string length: ${Oe.length} (${Oe}). Expected (8..${ct})`);
      const pt = Oe.toLowerCase();
      if (Oe !== pt && Oe !== Oe.toUpperCase()) throw new Error("String must be lowercase or uppercase");
      const gt = pt.lastIndexOf("1");
      if (gt === 0 || gt === -1) throw new Error('Letter "1" must be present between prefix and data only');
      const vt = pt.slice(0, gt), Bt = pt.slice(gt + 1);
      if (Bt.length < 6) throw new Error("Data must be at least 6 characters long");
      const kt = lt.decode(Bt).slice(0, -6), wt = mt(vt, kt, ht);
      if (!Bt.endsWith(wt)) throw new Error(`Invalid checksum in ${Oe}: expected "${wt}"`);
      return { prefix: vt, words: kt };
    }
    return { encode: function(Oe, ct, pt = 90) {
      if (typeof Oe != "string") throw new Error("bech32.encode prefix should be string, not " + typeof Oe);
      if (!Array.isArray(ct) || ct.length && typeof ct[0] != "number") throw new Error("bech32.encode words should be array of numbers, not " + typeof ct);
      if (Oe.length === 0) throw new TypeError(`Invalid prefix length ${Oe.length}`);
      const gt = Oe.length + 7 + ct.length;
      if (pt !== !1 && gt > pt) throw new TypeError(`Length ${gt} exceeds limit ${pt}`);
      const vt = Oe.toLowerCase(), Bt = mt(vt, ct, ht);
      return `${vt}1${lt.encode(ct)}${Bt}`;
    }, decode: st, decodeToBytes: function(Oe) {
      const { prefix: ct, words: pt } = st(Oe, !1);
      return { prefix: ct, words: pt, bytes: nt(pt) };
    }, decodeUnsafe: ot(st), fromWords: nt, fromWordsUnsafe: it, toWords: rt };
  }
  B.bech32 = $t("bech32"), B.bech32m = $t("bech32m"), B.utf8 = { encode: (ut) => new TextDecoder().decode(ut), decode: (ut) => new TextEncoder().encode(ut) }, B.hex = K(ke(4), W("0123456789abcdef"), V(""), re((ut) => {
    if (typeof ut != "string" || ut.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof ut} with length ${ut.length}`);
    return ut.toLowerCase();
  }));
  const It = { utf8: B.utf8, hex: B.hex, base16: B.base16, base32: B.base32, base64: B.base64, base64url: B.base64url, base58: B.base58, base58xmr: B.base58xmr }, Ut = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
  B.bytesToString = (ut, ht) => {
    if (typeof ut != "string" || !It.hasOwnProperty(ut)) throw new TypeError(Ut);
    if (!L(ht)) throw new TypeError("bytesToString() expects Uint8Array");
    return It[ut].encode(ht);
  }, B.str = B.bytesToString, B.stringToBytes = (ut, ht) => {
    if (!It.hasOwnProperty(ut)) throw new TypeError(Ut);
    if (typeof ht != "string") throw new TypeError("stringToBytes() expects string");
    return It[ut].decode(ht);
  }, B.bytes = B.stringToBytes;
})(lib$2);
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(B, L) {
    L && (B.super_ = L, B.prototype = Object.create(L.prototype, { constructor: { value: B, enumerable: !1, writable: !0, configurable: !0 } }));
  } : inherits_browser.exports = function(B, L) {
    if (L) {
      B.super_ = L;
      var K = function() {
      };
      K.prototype = L.prototype, B.prototype = new K(), B.prototype.constructor = B;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents, streamBrowser$1, hasRequiredStreamBrowser$1;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var B, L = typeof Reflect == "object" ? Reflect : null, K = L && typeof L.apply == "function" ? L.apply : function(ft, dt, lt) {
    return Function.prototype.apply.call(ft, dt, lt);
  };
  B = L && typeof L.ownKeys == "function" ? L.ownKeys : Object.getOwnPropertySymbols ? function(ft) {
    return Object.getOwnPropertyNames(ft).concat(Object.getOwnPropertySymbols(ft));
  } : function(ft) {
    return Object.getOwnPropertyNames(ft);
  };
  var W = Number.isNaN || function(ft) {
    return ft != ft;
  };
  function V() {
    V.init.call(this);
  }
  events.exports = V, events.exports.once = function(ft, dt) {
    return new Promise(function(lt, yt) {
      function St($t) {
        ft.removeListener(dt, mt), yt($t);
      }
      function mt() {
        typeof ft.removeListener == "function" && ft.removeListener("error", St), lt([].slice.call(arguments));
      }
      at(ft, dt, mt, { once: !0 }), dt !== "error" && function($t, It) {
        typeof $t.on == "function" && at($t, "error", It, { once: !0 });
      }(ft, St);
    });
  }, V.EventEmitter = V, V.prototype._events = void 0, V.prototype._eventsCount = 0, V.prototype._maxListeners = void 0;
  var J = 10;
  function re(ft) {
    if (typeof ft != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof ft);
  }
  function ie(ft) {
    return ft._maxListeners === void 0 ? V.defaultMaxListeners : ft._maxListeners;
  }
  function ne(ft, dt, lt, yt) {
    var St, mt, $t;
    if (re(lt), (mt = ft._events) === void 0 ? (mt = ft._events = /* @__PURE__ */ Object.create(null), ft._eventsCount = 0) : (mt.newListener !== void 0 && (ft.emit("newListener", dt, lt.listener ? lt.listener : lt), mt = ft._events), $t = mt[dt]), $t === void 0) $t = mt[dt] = lt, ++ft._eventsCount;
    else if (typeof $t == "function" ? $t = mt[dt] = yt ? [lt, $t] : [$t, lt] : yt ? $t.unshift(lt) : $t.push(lt), (St = ie(ft)) > 0 && $t.length > St && !$t.warned) {
      $t.warned = !0;
      var It = new Error("Possible EventEmitter memory leak detected. " + $t.length + " " + String(dt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      It.name = "MaxListenersExceededWarning", It.emitter = ft, It.type = dt, It.count = $t.length;
    }
    return ft;
  }
  function oe() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function ce(ft, dt, lt) {
    var yt = { fired: !1, wrapFn: void 0, target: ft, type: dt, listener: lt }, St = oe.bind(yt);
    return St.listener = lt, yt.wrapFn = St, St;
  }
  function pe(ft, dt, lt) {
    var yt = ft._events;
    if (yt === void 0) return [];
    var St = yt[dt];
    return St === void 0 ? [] : typeof St == "function" ? lt ? [St.listener || St] : [St] : lt ? function(mt) {
      for (var $t = new Array(mt.length), It = 0; It < $t.length; ++It) $t[It] = mt[It].listener || mt[It];
      return $t;
    }(St) : ot(St, St.length);
  }
  function ke(ft) {
    var dt = this._events;
    if (dt !== void 0) {
      var lt = dt[ft];
      if (typeof lt == "function") return 1;
      if (lt !== void 0) return lt.length;
    }
    return 0;
  }
  function ot(ft, dt) {
    for (var lt = new Array(dt), yt = 0; yt < dt; ++yt) lt[yt] = ft[yt];
    return lt;
  }
  function at(ft, dt, lt, yt) {
    if (typeof ft.on == "function") yt.once ? ft.once(dt, lt) : ft.on(dt, lt);
    else {
      if (typeof ft.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof ft);
      ft.addEventListener(dt, function St(mt) {
        yt.once && ft.removeEventListener(dt, St), lt(mt);
      });
    }
  }
  return Object.defineProperty(V, "defaultMaxListeners", { enumerable: !0, get: function() {
    return J;
  }, set: function(ft) {
    if (typeof ft != "number" || ft < 0 || W(ft)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + ft + ".");
    J = ft;
  } }), V.init = function() {
    this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, V.prototype.setMaxListeners = function(ft) {
    if (typeof ft != "number" || ft < 0 || W(ft)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ft + ".");
    return this._maxListeners = ft, this;
  }, V.prototype.getMaxListeners = function() {
    return ie(this);
  }, V.prototype.emit = function(ft) {
    for (var dt = [], lt = 1; lt < arguments.length; lt++) dt.push(arguments[lt]);
    var yt = ft === "error", St = this._events;
    if (St !== void 0) yt = yt && St.error === void 0;
    else if (!yt) return !1;
    if (yt) {
      var mt;
      if (dt.length > 0 && (mt = dt[0]), mt instanceof Error) throw mt;
      var $t = new Error("Unhandled error." + (mt ? " (" + mt.message + ")" : ""));
      throw $t.context = mt, $t;
    }
    var It = St[ft];
    if (It === void 0) return !1;
    if (typeof It == "function") K(It, this, dt);
    else {
      var Ut = It.length, ut = ot(It, Ut);
      for (lt = 0; lt < Ut; ++lt) K(ut[lt], this, dt);
    }
    return !0;
  }, V.prototype.addListener = function(ft, dt) {
    return ne(this, ft, dt, !1);
  }, V.prototype.on = V.prototype.addListener, V.prototype.prependListener = function(ft, dt) {
    return ne(this, ft, dt, !0);
  }, V.prototype.once = function(ft, dt) {
    return re(dt), this.on(ft, ce(this, ft, dt)), this;
  }, V.prototype.prependOnceListener = function(ft, dt) {
    return re(dt), this.prependListener(ft, ce(this, ft, dt)), this;
  }, V.prototype.removeListener = function(ft, dt) {
    var lt, yt, St, mt, $t;
    if (re(dt), (yt = this._events) === void 0) return this;
    if ((lt = yt[ft]) === void 0) return this;
    if (lt === dt || lt.listener === dt) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete yt[ft], yt.removeListener && this.emit("removeListener", ft, lt.listener || dt));
    else if (typeof lt != "function") {
      for (St = -1, mt = lt.length - 1; mt >= 0; mt--) if (lt[mt] === dt || lt[mt].listener === dt) {
        $t = lt[mt].listener, St = mt;
        break;
      }
      if (St < 0) return this;
      St === 0 ? lt.shift() : function(It, Ut) {
        for (; Ut + 1 < It.length; Ut++) It[Ut] = It[Ut + 1];
        It.pop();
      }(lt, St), lt.length === 1 && (yt[ft] = lt[0]), yt.removeListener !== void 0 && this.emit("removeListener", ft, $t || dt);
    }
    return this;
  }, V.prototype.off = V.prototype.removeListener, V.prototype.removeAllListeners = function(ft) {
    var dt, lt, yt;
    if ((lt = this._events) === void 0) return this;
    if (lt.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : lt[ft] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete lt[ft]), this;
    if (arguments.length === 0) {
      var St, mt = Object.keys(lt);
      for (yt = 0; yt < mt.length; ++yt) (St = mt[yt]) !== "removeListener" && this.removeAllListeners(St);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (typeof (dt = lt[ft]) == "function") this.removeListener(ft, dt);
    else if (dt !== void 0) for (yt = dt.length - 1; yt >= 0; yt--) this.removeListener(ft, dt[yt]);
    return this;
  }, V.prototype.listeners = function(ft) {
    return pe(this, ft, !0);
  }, V.prototype.rawListeners = function(ft) {
    return pe(this, ft, !1);
  }, V.listenerCount = function(ft, dt) {
    return typeof ft.listenerCount == "function" ? ft.listenerCount(dt) : ke.call(ft, dt);
  }, V.prototype.listenerCount = ke, V.prototype.eventNames = function() {
    return this._eventsCount > 0 ? B(this._events) : [];
  }, events.exports;
}
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 ? streamBrowser$1 : (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter);
}
var util$1 = {}, types$2 = {}, shams$1, hasRequiredShams$1, shams, hasRequiredShams, esErrors, hasRequiredEsErrors, _eval, hasRequired_eval, range, hasRequiredRange, ref, hasRequiredRef, syntax, hasRequiredSyntax, type, hasRequiredType, uri, hasRequiredUri, hasSymbols, hasRequiredHasSymbols, hasProto, hasRequiredHasProto, implementation, hasRequiredImplementation, functionBind, hasRequiredFunctionBind, hasown, hasRequiredHasown, getIntrinsic, hasRequiredGetIntrinsic;
function requireShams$1() {
  return hasRequiredShams$1 ? shams$1 : (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var B = {}, L = Symbol("test"), K = Object(L);
    if (typeof L == "string" || Object.prototype.toString.call(L) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]") return !1;
    for (L in B[L] = 42, B) return !1;
    if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0) return !1;
    var W = Object.getOwnPropertySymbols(B);
    if (W.length !== 1 || W[0] !== L || !Object.prototype.propertyIsEnumerable.call(B, L)) return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var V = Object.getOwnPropertyDescriptor(B, L);
      if (V.value !== 42 || V.enumerable !== !0) return !1;
    }
    return !0;
  });
}
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var B = requireShams$1();
  return shams = function() {
    return B() && !!Symbol.toStringTag;
  };
}
function requireEsErrors() {
  return hasRequiredEsErrors ? esErrors : (hasRequiredEsErrors = 1, esErrors = Error);
}
function require_eval() {
  return hasRequired_eval ? _eval : (hasRequired_eval = 1, _eval = EvalError);
}
function requireRange() {
  return hasRequiredRange ? range : (hasRequiredRange = 1, range = RangeError);
}
function requireRef() {
  return hasRequiredRef ? ref : (hasRequiredRef = 1, ref = ReferenceError);
}
function requireSyntax() {
  return hasRequiredSyntax ? syntax : (hasRequiredSyntax = 1, syntax = SyntaxError);
}
function requireType() {
  return hasRequiredType ? type : (hasRequiredType = 1, type = TypeError);
}
function requireUri() {
  return hasRequiredUri ? uri : (hasRequiredUri = 1, uri = URIError);
}
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, L = requireShams$1();
  return hasSymbols = function() {
    return typeof B == "function" && typeof Symbol == "function" && typeof B("foo") == "symbol" && typeof Symbol("bar") == "symbol" && L();
  };
}
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var B = { __proto__: null, foo: {} }, L = Object;
  return hasProto = function() {
    return { __proto__: B }.foo === B.foo && !(B instanceof L);
  };
}
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var B = Object.prototype.toString, L = Math.max, K = function(W, V) {
    for (var J = [], re = 0; re < W.length; re += 1) J[re] = W[re];
    for (var ie = 0; ie < V.length; ie += 1) J[ie + W.length] = V[ie];
    return J;
  };
  return implementation = function(W) {
    var V = this;
    if (typeof V != "function" || B.apply(V) !== "[object Function]") throw new TypeError("Function.prototype.bind called on incompatible " + V);
    for (var J, re = function(pe) {
      for (var ke = [], ot = 1, at = 0; ot < pe.length; ot += 1, at += 1) ke[at] = pe[ot];
      return ke;
    }(arguments), ie = L(0, V.length - re.length), ne = [], oe = 0; oe < ie; oe++) ne[oe] = "$" + oe;
    if (J = Function("binder", "return function (" + function(pe) {
      for (var ke = "", ot = 0; ot < pe.length; ot += 1) ke += pe[ot], ot + 1 < pe.length && (ke += ",");
      return ke;
    }(ne) + "){ return binder.apply(this,arguments); }")(function() {
      if (this instanceof J) {
        var pe = V.apply(this, K(re, arguments));
        return Object(pe) === pe ? pe : this;
      }
      return V.apply(W, K(re, arguments));
    }), V.prototype) {
      var ce = function() {
      };
      ce.prototype = V.prototype, J.prototype = new ce(), ce.prototype = null;
    }
    return J;
  }, implementation;
}
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var B = requireImplementation();
  return functionBind = Function.prototype.bind || B;
}
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var B = Function.prototype.call, L = Object.prototype.hasOwnProperty, K = requireFunctionBind();
  return hasown = K.call(B, L);
}
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  var B;
  hasRequiredGetIntrinsic = 1;
  var L = requireEsErrors(), K = require_eval(), W = requireRange(), V = requireRef(), J = requireSyntax(), re = requireType(), ie = requireUri(), ne = Function, oe = function(ct) {
    try {
      return ne('"use strict"; return (' + ct + ").constructor;")();
    } catch {
    }
  }, ce = Object.getOwnPropertyDescriptor;
  if (ce) try {
    ce({}, "");
  } catch {
    ce = null;
  }
  var pe = function() {
    throw new re();
  }, ke = ce ? function() {
    try {
      return pe;
    } catch {
      try {
        return ce(arguments, "callee").get;
      } catch {
        return pe;
      }
    }
  }() : pe, ot = requireHasSymbols()(), at = requireHasProto()(), ft = Object.getPrototypeOf || (at ? function(ct) {
    return ct.__proto__;
  } : null), dt = {}, lt = typeof Uint8Array < "u" && ft ? ft(Uint8Array) : B, yt = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? B : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? B : ArrayBuffer, "%ArrayIteratorPrototype%": ot && ft ? ft([][Symbol.iterator]()) : B, "%AsyncFromSyncIteratorPrototype%": B, "%AsyncFunction%": dt, "%AsyncGenerator%": dt, "%AsyncGeneratorFunction%": dt, "%AsyncIteratorPrototype%": dt, "%Atomics%": typeof Atomics > "u" ? B : Atomics, "%BigInt%": typeof BigInt > "u" ? B : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? B : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? B : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? B : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": L, "%eval%": eval, "%EvalError%": K, "%Float32Array%": typeof Float32Array > "u" ? B : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? B : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? B : FinalizationRegistry, "%Function%": ne, "%GeneratorFunction%": dt, "%Int8Array%": typeof Int8Array > "u" ? B : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? B : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? B : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": ot && ft ? ft(ft([][Symbol.iterator]())) : B, "%JSON%": typeof JSON == "object" ? JSON : B, "%Map%": typeof Map > "u" ? B : Map, "%MapIteratorPrototype%": typeof Map < "u" && ot && ft ? ft((/* @__PURE__ */ new Map())[Symbol.iterator]()) : B, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? B : Promise, "%Proxy%": typeof Proxy > "u" ? B : Proxy, "%RangeError%": W, "%ReferenceError%": V, "%Reflect%": typeof Reflect > "u" ? B : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? B : Set, "%SetIteratorPrototype%": typeof Set < "u" && ot && ft ? ft((/* @__PURE__ */ new Set())[Symbol.iterator]()) : B, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? B : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": ot && ft ? ft(""[Symbol.iterator]()) : B, "%Symbol%": ot ? Symbol : B, "%SyntaxError%": J, "%ThrowTypeError%": ke, "%TypedArray%": lt, "%TypeError%": re, "%Uint8Array%": typeof Uint8Array > "u" ? B : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? B : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? B : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? B : Uint32Array, "%URIError%": ie, "%WeakMap%": typeof WeakMap > "u" ? B : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? B : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? B : WeakSet };
  if (ft) try {
    null.error;
  } catch (ct) {
    var St = ft(ft(ct));
    yt["%Error.prototype%"] = St;
  }
  var mt = function ct(pt) {
    var gt;
    if (pt === "%AsyncFunction%") gt = oe("async function () {}");
    else if (pt === "%GeneratorFunction%") gt = oe("function* () {}");
    else if (pt === "%AsyncGeneratorFunction%") gt = oe("async function* () {}");
    else if (pt === "%AsyncGenerator%") {
      var vt = ct("%AsyncGeneratorFunction%");
      vt && (gt = vt.prototype);
    } else if (pt === "%AsyncIteratorPrototype%") {
      var Bt = ct("%AsyncGenerator%");
      Bt && ft && (gt = ft(Bt.prototype));
    }
    return yt[pt] = gt, gt;
  }, $t = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, It = requireFunctionBind(), Ut = requireHasown(), ut = It.call(Function.call, Array.prototype.concat), ht = It.call(Function.apply, Array.prototype.splice), Ce = It.call(Function.call, String.prototype.replace), nt = It.call(Function.call, String.prototype.slice), rt = It.call(Function.call, RegExp.prototype.exec), it = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, st = /\\(\\)?/g, Oe = function(ct, pt) {
    var gt, vt = ct;
    if (Ut($t, vt) && (vt = "%" + (gt = $t[vt])[0] + "%"), Ut(yt, vt)) {
      var Bt = yt[vt];
      if (Bt === dt && (Bt = mt(vt)), Bt === void 0 && !pt) throw new re("intrinsic " + ct + " exists, but is not available. Please file an issue!");
      return { alias: gt, name: vt, value: Bt };
    }
    throw new J("intrinsic " + ct + " does not exist!");
  };
  return getIntrinsic = function(ct, pt) {
    if (typeof ct != "string" || ct.length === 0) throw new re("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof pt != "boolean") throw new re('"allowMissing" argument must be a boolean');
    if (rt(/^%?[^%]*%?$/, ct) === null) throw new J("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var gt = function(Xt) {
      var ir = nt(Xt, 0, 1), ur = nt(Xt, -1);
      if (ir === "%" && ur !== "%") throw new J("invalid intrinsic syntax, expected closing `%`");
      if (ur === "%" && ir !== "%") throw new J("invalid intrinsic syntax, expected opening `%`");
      var Qt = [];
      return Ce(Xt, it, function(hr, pr, cr, vr) {
        Qt[Qt.length] = cr ? Ce(vr, st, "$1") : pr || hr;
      }), Qt;
    }(ct), vt = gt.length > 0 ? gt[0] : "", Bt = Oe("%" + vt + "%", pt), kt = Bt.name, wt = Bt.value, Et = !1, Rt = Bt.alias;
    Rt && (vt = Rt[0], ht(gt, ut([0, 1], Rt)));
    for (var Mt = 1, Ht = !0; Mt < gt.length; Mt += 1) {
      var Kt = gt[Mt], jt = nt(Kt, 0, 1), Wt = nt(Kt, -1);
      if ((jt === '"' || jt === "'" || jt === "`" || Wt === '"' || Wt === "'" || Wt === "`") && jt !== Wt) throw new J("property names with quotes must have matching quotes");
      if (Kt !== "constructor" && Ht || (Et = !0), Ut(yt, kt = "%" + (vt += "." + Kt) + "%")) wt = yt[kt];
      else if (wt != null) {
        if (!(Kt in wt)) {
          if (!pt) throw new re("base intrinsic for " + ct + " exists, but the property is not available.");
          return;
        }
        if (ce && Mt + 1 >= gt.length) {
          var Yt = ce(wt, Kt);
          wt = (Ht = !!Yt) && "get" in Yt && !("originalValue" in Yt.get) ? Yt.get : wt[Kt];
        } else Ht = Ut(wt, Kt), wt = wt[Kt];
        Ht && !Et && (yt[kt] = wt);
      }
    }
    return wt;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty, gopd, hasRequiredGopd, defineDataProperty, hasRequiredDefineDataProperty, hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors, setFunctionLength, hasRequiredSetFunctionLength, hasRequiredCallBind, callBound, hasRequiredCallBound, isArguments, hasRequiredIsArguments, isGeneratorFunction, hasRequiredIsGeneratorFunction, isCallable, hasRequiredIsCallable, forEach_1, hasRequiredForEach, possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames, availableTypedArrays, hasRequiredAvailableTypedArrays, whichTypedArray, hasRequiredWhichTypedArray, isTypedArray, hasRequiredIsTypedArray, hasRequiredTypes, isBufferBrowser, hasRequiredIsBufferBrowser, hasRequiredUtil$1, buffer_list, hasRequiredBuffer_list, destroy_1$1, hasRequiredDestroy$1;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var B = requireGetIntrinsic()("%Object.defineProperty%", !0) || !1;
  if (B) try {
    B({}, "a", { value: 1 });
  } catch {
    B = !1;
  }
  return esDefineProperty = B;
}
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var B = requireGetIntrinsic()("%Object.getOwnPropertyDescriptor%", !0);
  if (B) try {
    B([], "length");
  } catch {
    B = null;
  }
  return gopd = B;
}
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var B = requireEsDefineProperty(), L = requireSyntax(), K = requireType(), W = requireGopd();
  return defineDataProperty = function(V, J, re) {
    if (!V || typeof V != "object" && typeof V != "function") throw new K("`obj` must be an object or a function`");
    if (typeof J != "string" && typeof J != "symbol") throw new K("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new K("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new K("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new K("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new K("`loose`, if provided, must be a boolean");
    var ie = arguments.length > 3 ? arguments[3] : null, ne = arguments.length > 4 ? arguments[4] : null, oe = arguments.length > 5 ? arguments[5] : null, ce = arguments.length > 6 && arguments[6], pe = !!W && W(V, J);
    if (B) B(V, J, { configurable: oe === null && pe ? pe.configurable : !oe, enumerable: ie === null && pe ? pe.enumerable : !ie, value: re, writable: ne === null && pe ? pe.writable : !ne });
    else {
      if (!ce && (ie || ne || oe)) throw new L("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      V[J] = re;
    }
  }, defineDataProperty;
}
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var B = requireEsDefineProperty(), L = function() {
    return !!B;
  };
  return L.hasArrayLengthDefineBug = function() {
    if (!B) return null;
    try {
      return B([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = L;
}
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var B = requireGetIntrinsic(), L = requireDefineDataProperty(), K = requireHasPropertyDescriptors()(), W = requireGopd(), V = requireType(), J = B("%Math.floor%");
  return setFunctionLength = function(re, ie) {
    if (typeof re != "function") throw new V("`fn` is not a function");
    if (typeof ie != "number" || ie < 0 || ie > 4294967295 || J(ie) !== ie) throw new V("`length` must be a positive 32-bit integer");
    var ne = arguments.length > 2 && !!arguments[2], oe = !0, ce = !0;
    if ("length" in re && W) {
      var pe = W(re, "length");
      pe && !pe.configurable && (oe = !1), pe && !pe.writable && (ce = !1);
    }
    return (oe || ce || !ne) && (K ? L(re, "length", ie, !0, !0) : L(re, "length", ie)), re;
  }, setFunctionLength;
}
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(B) {
    var L = requireFunctionBind(), K = requireGetIntrinsic(), W = requireSetFunctionLength(), V = requireType(), J = K("%Function.prototype.apply%"), re = K("%Function.prototype.call%"), ie = K("%Reflect.apply%", !0) || L.call(re, J), ne = requireEsDefineProperty(), oe = K("%Math.max%");
    B.exports = function(pe) {
      if (typeof pe != "function") throw new V("a function is required");
      var ke = ie(L, re, arguments);
      return W(ke, 1 + oe(0, pe.length - (arguments.length - 1)), !0);
    };
    var ce = function() {
      return ie(L, J, arguments);
    };
    ne ? ne(B.exports, "apply", { value: ce }) : B.exports.apply = ce;
  }(callBind)), callBind.exports;
}
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var B = requireGetIntrinsic(), L = requireCallBind(), K = L(B("String.prototype.indexOf"));
  return callBound = function(W, V) {
    var J = B(W, !!V);
    return typeof J == "function" && K(W, ".prototype.") > -1 ? L(J) : J;
  }, callBound;
}
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var B = requireShams()(), L = requireCallBound()("Object.prototype.toString"), K = function(J) {
    return !(B && J && typeof J == "object" && Symbol.toStringTag in J) && L(J) === "[object Arguments]";
  }, W = function(J) {
    return !!K(J) || J !== null && typeof J == "object" && typeof J.length == "number" && J.length >= 0 && L(J) !== "[object Array]" && L(J.callee) === "[object Function]";
  }, V = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = W, isArguments = V ? K : W;
}
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var B, L = Object.prototype.toString, K = Function.prototype.toString, W = /^\s*(?:function)?\*/, V = requireShams()(), J = Object.getPrototypeOf;
  return isGeneratorFunction = function(re) {
    if (typeof re != "function") return !1;
    if (W.test(K.call(re))) return !0;
    if (!V) return L.call(re) === "[object GeneratorFunction]";
    if (!J) return !1;
    if (B === void 0) {
      var ie = function() {
        if (!V) return !1;
        try {
          return Function("return function*() {}")();
        } catch {
        }
      }();
      B = !!ie && J(ie);
    }
    return J(re) === B;
  };
}
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var B, L, K = Function.prototype.toString, W = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
  if (typeof W == "function" && typeof Object.defineProperty == "function") try {
    B = Object.defineProperty({}, "length", { get: function() {
      throw L;
    } }), L = {}, W(function() {
      throw 42;
    }, null, B);
  } catch (ke) {
    ke !== L && (W = null);
  }
  else W = null;
  var V = /^\s*class\b/, J = function(ke) {
    try {
      var ot = K.call(ke);
      return V.test(ot);
    } catch {
      return !1;
    }
  }, re = function(ke) {
    try {
      return !J(ke) && (K.call(ke), !0);
    } catch {
      return !1;
    }
  }, ie = Object.prototype.toString, ne = typeof Symbol == "function" && !!Symbol.toStringTag, oe = !(0 in [,]), ce = function() {
    return !1;
  };
  if (typeof document == "object") {
    var pe = document.all;
    ie.call(pe) === ie.call(document.all) && (ce = function(ke) {
      if ((oe || !ke) && (ke === void 0 || typeof ke == "object")) try {
        var ot = ie.call(ke);
        return (ot === "[object HTMLAllCollection]" || ot === "[object HTML document.all class]" || ot === "[object HTMLCollection]" || ot === "[object Object]") && ke("") == null;
      } catch {
      }
      return !1;
    });
  }
  return isCallable = W ? function(ke) {
    if (ce(ke)) return !0;
    if (!ke || typeof ke != "function" && typeof ke != "object") return !1;
    try {
      W(ke, null, B);
    } catch (ot) {
      if (ot !== L) return !1;
    }
    return !J(ke) && re(ke);
  } : function(ke) {
    if (ce(ke)) return !0;
    if (!ke || typeof ke != "function" && typeof ke != "object") return !1;
    if (ne) return re(ke);
    if (J(ke)) return !1;
    var ot = ie.call(ke);
    return !(ot !== "[object Function]" && ot !== "[object GeneratorFunction]" && !/^\[object HTML/.test(ot)) && re(ke);
  }, isCallable;
}
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var B = requireIsCallable(), L = Object.prototype.toString, K = Object.prototype.hasOwnProperty;
  return forEach_1 = function(W, V, J) {
    if (!B(V)) throw new TypeError("iterator must be a function");
    var re;
    arguments.length >= 3 && (re = J), L.call(W) === "[object Array]" ? function(ie, ne, oe) {
      for (var ce = 0, pe = ie.length; ce < pe; ce++) K.call(ie, ce) && (oe == null ? ne(ie[ce], ce, ie) : ne.call(oe, ie[ce], ce, ie));
    }(W, V, re) : typeof W == "string" ? function(ie, ne, oe) {
      for (var ce = 0, pe = ie.length; ce < pe; ce++) oe == null ? ne(ie.charAt(ce), ce, ie) : ne.call(oe, ie.charAt(ce), ce, ie);
    }(W, V, re) : function(ie, ne, oe) {
      for (var ce in ie) K.call(ie, ce) && (oe == null ? ne(ie[ce], ce, ie) : ne.call(oe, ie[ce], ce, ie));
    }(W, V, re);
  }, forEach_1;
}
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames ? possibleTypedArrayNames : (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]);
}
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var B = requirePossibleTypedArrayNames(), L = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], W = 0; W < B.length; W++) typeof L[B[W]] == "function" && (K[K.length] = B[W]);
    return K;
  }, availableTypedArrays;
}
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var B = requireForEach(), L = requireAvailableTypedArrays(), K = requireCallBind(), W = requireCallBound(), V = requireGopd(), J = W("Object.prototype.toString"), re = requireShams()(), ie = typeof globalThis > "u" ? commonjsGlobal : globalThis, ne = L(), oe = W("String.prototype.slice"), ce = Object.getPrototypeOf, pe = W("Array.prototype.indexOf", !0) || function(ot, at) {
    for (var ft = 0; ft < ot.length; ft += 1) if (ot[ft] === at) return ft;
    return -1;
  }, ke = { __proto__: null };
  return B(ne, re && V && ce ? function(ot) {
    var at = new ie[ot]();
    if (Symbol.toStringTag in at) {
      var ft = ce(at), dt = V(ft, Symbol.toStringTag);
      if (!dt) {
        var lt = ce(ft);
        dt = V(lt, Symbol.toStringTag);
      }
      ke["$" + ot] = K(dt.get);
    }
  } : function(ot) {
    var at = new ie[ot](), ft = at.slice || at.set;
    ft && (ke["$" + ot] = K(ft));
  }), whichTypedArray = function(ot) {
    if (!ot || typeof ot != "object") return !1;
    if (!re) {
      var at = oe(J(ot), 8, -1);
      return pe(ne, at) > -1 ? at : at === "Object" && function(ft) {
        var dt = !1;
        return B(ke, function(lt, yt) {
          if (!dt) try {
            lt(ft), dt = oe(yt, 1);
          } catch {
          }
        }), dt;
      }(ot);
    }
    return V ? function(ft) {
      var dt = !1;
      return B(ke, function(lt, yt) {
        if (!dt) try {
          "$" + lt(ft) === yt && (dt = oe(yt, 1));
        } catch {
        }
      }), dt;
    }(ot) : null;
  }, whichTypedArray;
}
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var B = requireWhichTypedArray();
  return isTypedArray = function(L) {
    return !!B(L);
  }, isTypedArray;
}
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(B) {
    var L = requireIsArguments(), K = requireIsGeneratorFunction(), W = requireWhichTypedArray(), V = requireIsTypedArray();
    function J(Oe) {
      return Oe.call.bind(Oe);
    }
    var re = typeof BigInt < "u", ie = typeof Symbol < "u", ne = J(Object.prototype.toString), oe = J(Number.prototype.valueOf), ce = J(String.prototype.valueOf), pe = J(Boolean.prototype.valueOf);
    if (re) var ke = J(BigInt.prototype.valueOf);
    if (ie) var ot = J(Symbol.prototype.valueOf);
    function at(Oe, ct) {
      if (typeof Oe != "object") return !1;
      try {
        return ct(Oe), !0;
      } catch {
        return !1;
      }
    }
    function ft(Oe) {
      return ne(Oe) === "[object Map]";
    }
    function dt(Oe) {
      return ne(Oe) === "[object Set]";
    }
    function lt(Oe) {
      return ne(Oe) === "[object WeakMap]";
    }
    function yt(Oe) {
      return ne(Oe) === "[object WeakSet]";
    }
    function St(Oe) {
      return ne(Oe) === "[object ArrayBuffer]";
    }
    function mt(Oe) {
      return typeof ArrayBuffer < "u" && (St.working ? St(Oe) : Oe instanceof ArrayBuffer);
    }
    function $t(Oe) {
      return ne(Oe) === "[object DataView]";
    }
    function It(Oe) {
      return typeof DataView < "u" && ($t.working ? $t(Oe) : Oe instanceof DataView);
    }
    B.isArgumentsObject = L, B.isGeneratorFunction = K, B.isTypedArray = V, B.isPromise = function(Oe) {
      return typeof Promise < "u" && Oe instanceof Promise || Oe !== null && typeof Oe == "object" && typeof Oe.then == "function" && typeof Oe.catch == "function";
    }, B.isArrayBufferView = function(Oe) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Oe) : V(Oe) || It(Oe);
    }, B.isUint8Array = function(Oe) {
      return W(Oe) === "Uint8Array";
    }, B.isUint8ClampedArray = function(Oe) {
      return W(Oe) === "Uint8ClampedArray";
    }, B.isUint16Array = function(Oe) {
      return W(Oe) === "Uint16Array";
    }, B.isUint32Array = function(Oe) {
      return W(Oe) === "Uint32Array";
    }, B.isInt8Array = function(Oe) {
      return W(Oe) === "Int8Array";
    }, B.isInt16Array = function(Oe) {
      return W(Oe) === "Int16Array";
    }, B.isInt32Array = function(Oe) {
      return W(Oe) === "Int32Array";
    }, B.isFloat32Array = function(Oe) {
      return W(Oe) === "Float32Array";
    }, B.isFloat64Array = function(Oe) {
      return W(Oe) === "Float64Array";
    }, B.isBigInt64Array = function(Oe) {
      return W(Oe) === "BigInt64Array";
    }, B.isBigUint64Array = function(Oe) {
      return W(Oe) === "BigUint64Array";
    }, ft.working = typeof Map < "u" && ft(/* @__PURE__ */ new Map()), B.isMap = function(Oe) {
      return typeof Map < "u" && (ft.working ? ft(Oe) : Oe instanceof Map);
    }, dt.working = typeof Set < "u" && dt(/* @__PURE__ */ new Set()), B.isSet = function(Oe) {
      return typeof Set < "u" && (dt.working ? dt(Oe) : Oe instanceof Set);
    }, lt.working = typeof WeakMap < "u" && lt(/* @__PURE__ */ new WeakMap()), B.isWeakMap = function(Oe) {
      return typeof WeakMap < "u" && (lt.working ? lt(Oe) : Oe instanceof WeakMap);
    }, yt.working = typeof WeakSet < "u" && yt(/* @__PURE__ */ new WeakSet()), B.isWeakSet = function(Oe) {
      return yt(Oe);
    }, St.working = typeof ArrayBuffer < "u" && St(new ArrayBuffer()), B.isArrayBuffer = mt, $t.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && $t(new DataView(new ArrayBuffer(1), 0, 1)), B.isDataView = It;
    var Ut = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function ut(Oe) {
      return ne(Oe) === "[object SharedArrayBuffer]";
    }
    function ht(Oe) {
      return Ut !== void 0 && (ut.working === void 0 && (ut.working = ut(new Ut())), ut.working ? ut(Oe) : Oe instanceof Ut);
    }
    function Ce(Oe) {
      return at(Oe, oe);
    }
    function nt(Oe) {
      return at(Oe, ce);
    }
    function rt(Oe) {
      return at(Oe, pe);
    }
    function it(Oe) {
      return re && at(Oe, ke);
    }
    function st(Oe) {
      return ie && at(Oe, ot);
    }
    B.isSharedArrayBuffer = ht, B.isAsyncFunction = function(Oe) {
      return ne(Oe) === "[object AsyncFunction]";
    }, B.isMapIterator = function(Oe) {
      return ne(Oe) === "[object Map Iterator]";
    }, B.isSetIterator = function(Oe) {
      return ne(Oe) === "[object Set Iterator]";
    }, B.isGeneratorObject = function(Oe) {
      return ne(Oe) === "[object Generator]";
    }, B.isWebAssemblyCompiledModule = function(Oe) {
      return ne(Oe) === "[object WebAssembly.Module]";
    }, B.isNumberObject = Ce, B.isStringObject = nt, B.isBooleanObject = rt, B.isBigIntObject = it, B.isSymbolObject = st, B.isBoxedPrimitive = function(Oe) {
      return Ce(Oe) || nt(Oe) || rt(Oe) || it(Oe) || st(Oe);
    }, B.isAnyArrayBuffer = function(Oe) {
      return typeof Uint8Array < "u" && (mt(Oe) || ht(Oe));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Oe) {
      Object.defineProperty(B, Oe, { enumerable: !1, value: function() {
        throw new Error(Oe + " is not supported in userland");
      } });
    });
  }(types$2)), types$2;
}
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser ? isBufferBrowser : (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(B) {
    return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
  });
}
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(B) {
    var L = Object.getOwnPropertyDescriptors || function(nt) {
      for (var rt = Object.keys(nt), it = {}, st = 0; st < rt.length; st++) it[rt[st]] = Object.getOwnPropertyDescriptor(nt, rt[st]);
      return it;
    }, K = /%[sdj%]/g;
    B.format = function(nt) {
      if (!dt(nt)) {
        for (var rt = [], it = 0; it < arguments.length; it++) rt.push(re(arguments[it]));
        return rt.join(" ");
      }
      it = 1;
      for (var st = arguments, Oe = st.length, ct = String(nt).replace(K, function(gt) {
        if (gt === "%%") return "%";
        if (it >= Oe) return gt;
        switch (gt) {
          case "%s":
            return String(st[it++]);
          case "%d":
            return Number(st[it++]);
          case "%j":
            try {
              return JSON.stringify(st[it++]);
            } catch {
              return "[Circular]";
            }
          default:
            return gt;
        }
      }), pt = st[it]; it < Oe; pt = st[++it]) at(pt) || !St(pt) ? ct += " " + pt : ct += " " + re(pt);
      return ct;
    }, B.deprecate = function(nt, rt) {
      if (process$1 !== void 0 && process$1.noDeprecation === !0) return nt;
      if (process$1 === void 0) return function() {
        return B.deprecate(nt, rt).apply(this, arguments);
      };
      var it = !1;
      return function() {
        if (!it) {
          if (process$1.throwDeprecation) throw new Error(rt);
          process$1.traceDeprecation, it = !0;
        }
        return nt.apply(this, arguments);
      };
    };
    var W = {}, V = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var J = process$1.env.NODE_DEBUG;
      J = J.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), V = new RegExp("^" + J + "$", "i");
    }
    function re(nt, rt) {
      var it = { seen: [], stylize: ne };
      return arguments.length >= 3 && (it.depth = arguments[2]), arguments.length >= 4 && (it.colors = arguments[3]), ot(rt) ? it.showHidden = rt : rt && B._extend(it, rt), lt(it.showHidden) && (it.showHidden = !1), lt(it.depth) && (it.depth = 2), lt(it.colors) && (it.colors = !1), lt(it.customInspect) && (it.customInspect = !0), it.colors && (it.stylize = ie), oe(it, nt, it.depth);
    }
    function ie(nt, rt) {
      var it = re.styles[rt];
      return it ? "\x1B[" + re.colors[it][0] + "m" + nt + "\x1B[" + re.colors[it][1] + "m" : nt;
    }
    function ne(nt, rt) {
      return nt;
    }
    function oe(nt, rt, it) {
      if (nt.customInspect && rt && It(rt.inspect) && rt.inspect !== B.inspect && (!rt.constructor || rt.constructor.prototype !== rt)) {
        var st = rt.inspect(it, nt);
        return dt(st) || (st = oe(nt, st, it)), st;
      }
      var Oe = function(Et, Rt) {
        if (lt(Rt)) return Et.stylize("undefined", "undefined");
        if (dt(Rt)) {
          var Mt = "'" + JSON.stringify(Rt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return Et.stylize(Mt, "string");
        }
        return ft(Rt) ? Et.stylize("" + Rt, "number") : ot(Rt) ? Et.stylize("" + Rt, "boolean") : at(Rt) ? Et.stylize("null", "null") : void 0;
      }(nt, rt);
      if (Oe) return Oe;
      var ct = Object.keys(rt), pt = function(Et) {
        var Rt = {};
        return Et.forEach(function(Mt, Ht) {
          Rt[Mt] = !0;
        }), Rt;
      }(ct);
      if (nt.showHidden && (ct = Object.getOwnPropertyNames(rt)), $t(rt) && (ct.indexOf("message") >= 0 || ct.indexOf("description") >= 0)) return ce(rt);
      if (ct.length === 0) {
        if (It(rt)) {
          var gt = rt.name ? ": " + rt.name : "";
          return nt.stylize("[Function" + gt + "]", "special");
        }
        if (yt(rt)) return nt.stylize(RegExp.prototype.toString.call(rt), "regexp");
        if (mt(rt)) return nt.stylize(Date.prototype.toString.call(rt), "date");
        if ($t(rt)) return ce(rt);
      }
      var vt, Bt = "", kt = !1, wt = ["{", "}"];
      return ke(rt) && (kt = !0, wt = ["[", "]"]), It(rt) && (Bt = " [Function" + (rt.name ? ": " + rt.name : "") + "]"), yt(rt) && (Bt = " " + RegExp.prototype.toString.call(rt)), mt(rt) && (Bt = " " + Date.prototype.toUTCString.call(rt)), $t(rt) && (Bt = " " + ce(rt)), ct.length !== 0 || kt && rt.length != 0 ? it < 0 ? yt(rt) ? nt.stylize(RegExp.prototype.toString.call(rt), "regexp") : nt.stylize("[Object]", "special") : (nt.seen.push(rt), vt = kt ? function(Et, Rt, Mt, Ht, Kt) {
        for (var jt = [], Wt = 0, Yt = Rt.length; Wt < Yt; ++Wt) ut(Rt, String(Wt)) ? jt.push(pe(Et, Rt, Mt, Ht, String(Wt), !0)) : jt.push("");
        return Kt.forEach(function(Xt) {
          Xt.match(/^\d+$/) || jt.push(pe(Et, Rt, Mt, Ht, Xt, !0));
        }), jt;
      }(nt, rt, it, pt, ct) : ct.map(function(Et) {
        return pe(nt, rt, it, pt, Et, kt);
      }), nt.seen.pop(), function(Et, Rt, Mt) {
        return Et.reduce(function(Ht, Kt) {
          return Kt.indexOf(`
`), Ht + Kt.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? Mt[0] + (Rt === "" ? "" : Rt + `
 `) + " " + Et.join(`,
  `) + " " + Mt[1] : Mt[0] + Rt + " " + Et.join(", ") + " " + Mt[1];
      }(vt, Bt, wt)) : wt[0] + Bt + wt[1];
    }
    function ce(nt) {
      return "[" + Error.prototype.toString.call(nt) + "]";
    }
    function pe(nt, rt, it, st, Oe, ct) {
      var pt, gt, vt;
      if ((vt = Object.getOwnPropertyDescriptor(rt, Oe) || { value: rt[Oe] }).get ? gt = vt.set ? nt.stylize("[Getter/Setter]", "special") : nt.stylize("[Getter]", "special") : vt.set && (gt = nt.stylize("[Setter]", "special")), ut(st, Oe) || (pt = "[" + Oe + "]"), gt || (nt.seen.indexOf(vt.value) < 0 ? (gt = at(it) ? oe(nt, vt.value, null) : oe(nt, vt.value, it - 1)).indexOf(`
`) > -1 && (gt = ct ? gt.split(`
`).map(function(Bt) {
        return "  " + Bt;
      }).join(`
`).slice(2) : `
` + gt.split(`
`).map(function(Bt) {
        return "   " + Bt;
      }).join(`
`)) : gt = nt.stylize("[Circular]", "special")), lt(pt)) {
        if (ct && Oe.match(/^\d+$/)) return gt;
        (pt = JSON.stringify("" + Oe)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (pt = pt.slice(1, -1), pt = nt.stylize(pt, "name")) : (pt = pt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), pt = nt.stylize(pt, "string"));
      }
      return pt + ": " + gt;
    }
    function ke(nt) {
      return Array.isArray(nt);
    }
    function ot(nt) {
      return typeof nt == "boolean";
    }
    function at(nt) {
      return nt === null;
    }
    function ft(nt) {
      return typeof nt == "number";
    }
    function dt(nt) {
      return typeof nt == "string";
    }
    function lt(nt) {
      return nt === void 0;
    }
    function yt(nt) {
      return St(nt) && Ut(nt) === "[object RegExp]";
    }
    function St(nt) {
      return typeof nt == "object" && nt !== null;
    }
    function mt(nt) {
      return St(nt) && Ut(nt) === "[object Date]";
    }
    function $t(nt) {
      return St(nt) && (Ut(nt) === "[object Error]" || nt instanceof Error);
    }
    function It(nt) {
      return typeof nt == "function";
    }
    function Ut(nt) {
      return Object.prototype.toString.call(nt);
    }
    function ut(nt, rt) {
      return Object.prototype.hasOwnProperty.call(nt, rt);
    }
    B.debuglog = function(nt) {
      return nt = nt.toUpperCase(), W[nt] || (V.test(nt) ? (process$1.pid, W[nt] = function() {
        B.format.apply(B, arguments);
      }) : W[nt] = function() {
      }), W[nt];
    }, B.inspect = re, re.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, re.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, B.types = requireTypes(), B.isArray = ke, B.isBoolean = ot, B.isNull = at, B.isNullOrUndefined = function(nt) {
      return nt == null;
    }, B.isNumber = ft, B.isString = dt, B.isSymbol = function(nt) {
      return typeof nt == "symbol";
    }, B.isUndefined = lt, B.isRegExp = yt, B.types.isRegExp = yt, B.isObject = St, B.isDate = mt, B.types.isDate = mt, B.isError = $t, B.types.isNativeError = $t, B.isFunction = It, B.isPrimitive = function(nt) {
      return nt === null || typeof nt == "boolean" || typeof nt == "number" || typeof nt == "string" || typeof nt == "symbol" || nt === void 0;
    }, B.isBuffer = requireIsBufferBrowser(), B.log = function() {
    }, B.inherits = requireInherits_browser(), B._extend = function(nt, rt) {
      if (!rt || !St(rt)) return nt;
      for (var it = Object.keys(rt), st = it.length; st--; ) nt[it[st]] = rt[it[st]];
      return nt;
    };
    var ht = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    function Ce(nt, rt) {
      if (!nt) {
        var it = new Error("Promise was rejected with a falsy value");
        it.reason = nt, nt = it;
      }
      return rt(nt);
    }
    B.promisify = function(nt) {
      if (typeof nt != "function") throw new TypeError('The "original" argument must be of type Function');
      if (ht && nt[ht]) {
        var rt;
        if (typeof (rt = nt[ht]) != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(rt, ht, { value: rt, enumerable: !1, writable: !1, configurable: !0 }), rt;
      }
      function rt() {
        for (var it, st, Oe = new Promise(function(gt, vt) {
          it = gt, st = vt;
        }), ct = [], pt = 0; pt < arguments.length; pt++) ct.push(arguments[pt]);
        ct.push(function(gt, vt) {
          gt ? st(gt) : it(vt);
        });
        try {
          nt.apply(this, ct);
        } catch (gt) {
          st(gt);
        }
        return Oe;
      }
      return Object.setPrototypeOf(rt, Object.getPrototypeOf(nt)), ht && Object.defineProperty(rt, ht, { value: rt, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(rt, L(nt));
    }, B.promisify.custom = ht, B.callbackify = function(nt) {
      if (typeof nt != "function") throw new TypeError('The "original" argument must be of type Function');
      function rt() {
        for (var it = [], st = 0; st < arguments.length; st++) it.push(arguments[st]);
        var Oe = it.pop();
        if (typeof Oe != "function") throw new TypeError("The last argument must be of type Function");
        var ct = this, pt = function() {
          return Oe.apply(ct, arguments);
        };
        nt.apply(this, it).then(function(gt) {
          process$1.nextTick(pt.bind(null, null, gt));
        }, function(gt) {
          process$1.nextTick(Ce.bind(null, gt, pt));
        });
      }
      return Object.setPrototypeOf(rt, Object.getPrototypeOf(nt)), Object.defineProperties(rt, L(nt)), rt;
    };
  }(util$1)), util$1;
}
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  function B(ne, oe) {
    var ce = Object.keys(ne);
    if (Object.getOwnPropertySymbols) {
      var pe = Object.getOwnPropertySymbols(ne);
      oe && (pe = pe.filter(function(ke) {
        return Object.getOwnPropertyDescriptor(ne, ke).enumerable;
      })), ce.push.apply(ce, pe);
    }
    return ce;
  }
  function L(ne) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ce = arguments[oe] != null ? arguments[oe] : {};
      oe % 2 ? B(Object(ce), !0).forEach(function(pe) {
        K(ne, pe, ce[pe]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ne, Object.getOwnPropertyDescriptors(ce)) : B(Object(ce)).forEach(function(pe) {
        Object.defineProperty(ne, pe, Object.getOwnPropertyDescriptor(ce, pe));
      });
    }
    return ne;
  }
  function K(ne, oe, ce) {
    return (oe = W(oe)) in ne ? Object.defineProperty(ne, oe, { value: ce, enumerable: !0, configurable: !0, writable: !0 }) : ne[oe] = ce, ne;
  }
  function W(ne) {
    var oe = function(ce) {
      if (typeof ce != "object" || ce === null) return ce;
      var pe = ce[Symbol.toPrimitive];
      if (pe !== void 0) {
        var ke = pe.call(ce, "string");
        if (typeof ke != "object") return ke;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(ce);
    }(ne);
    return typeof oe == "symbol" ? oe : String(oe);
  }
  hasRequiredBuffer_list = 1;
  var V = require$$1$2.Buffer, J = requireUtil$1().inspect, re = J && J.custom || "inspect";
  function ie(ne, oe, ce) {
    V.prototype.copy.call(ne, oe, ce);
  }
  return buffer_list = function() {
    function ne() {
      (function(pe, ke) {
        if (!(pe instanceof ke)) throw new TypeError("Cannot call a class as a function");
      })(this, ne), this.head = null, this.tail = null, this.length = 0;
    }
    return oe = ne, ce = [{ key: "push", value: function(pe) {
      var ke = { data: pe, next: null };
      this.length > 0 ? this.tail.next = ke : this.head = ke, this.tail = ke, ++this.length;
    } }, { key: "unshift", value: function(pe) {
      var ke = { data: pe, next: this.head };
      this.length === 0 && (this.tail = ke), this.head = ke, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var pe = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, pe;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(pe) {
      if (this.length === 0) return "";
      for (var ke = this.head, ot = "" + ke.data; ke = ke.next; ) ot += pe + ke.data;
      return ot;
    } }, { key: "concat", value: function(pe) {
      if (this.length === 0) return V.alloc(0);
      for (var ke = V.allocUnsafe(pe >>> 0), ot = this.head, at = 0; ot; ) ie(ot.data, ke, at), at += ot.data.length, ot = ot.next;
      return ke;
    } }, { key: "consume", value: function(pe, ke) {
      var ot;
      return pe < this.head.data.length ? (ot = this.head.data.slice(0, pe), this.head.data = this.head.data.slice(pe)) : ot = pe === this.head.data.length ? this.shift() : ke ? this._getString(pe) : this._getBuffer(pe), ot;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(pe) {
      var ke = this.head, ot = 1, at = ke.data;
      for (pe -= at.length; ke = ke.next; ) {
        var ft = ke.data, dt = pe > ft.length ? ft.length : pe;
        if (dt === ft.length ? at += ft : at += ft.slice(0, pe), (pe -= dt) == 0) {
          dt === ft.length ? (++ot, ke.next ? this.head = ke.next : this.head = this.tail = null) : (this.head = ke, ke.data = ft.slice(dt));
          break;
        }
        ++ot;
      }
      return this.length -= ot, at;
    } }, { key: "_getBuffer", value: function(pe) {
      var ke = V.allocUnsafe(pe), ot = this.head, at = 1;
      for (ot.data.copy(ke), pe -= ot.data.length; ot = ot.next; ) {
        var ft = ot.data, dt = pe > ft.length ? ft.length : pe;
        if (ft.copy(ke, ke.length - pe, 0, dt), (pe -= dt) == 0) {
          dt === ft.length ? (++at, ot.next ? this.head = ot.next : this.head = this.tail = null) : (this.head = ot, ot.data = ft.slice(dt));
          break;
        }
        ++at;
      }
      return this.length -= at, ke;
    } }, { key: re, value: function(pe, ke) {
      return J(this, L(L({}, ke), {}, { depth: 0, customInspect: !1 }));
    } }], ce && function(pe, ke) {
      for (var ot = 0; ot < ke.length; ot++) {
        var at = ke[ot];
        at.enumerable = at.enumerable || !1, at.configurable = !0, "value" in at && (at.writable = !0), Object.defineProperty(pe, W(at.key), at);
      }
    }(oe.prototype, ce), Object.defineProperty(oe, "prototype", { writable: !1 }), ne;
    var oe, ce;
  }(), buffer_list;
}
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  function B(W, V) {
    K(W, V), L(W);
  }
  function L(W) {
    W._writableState && !W._writableState.emitClose || W._readableState && !W._readableState.emitClose || W.emit("close");
  }
  function K(W, V) {
    W.emit("error", V);
  }
  return hasRequiredDestroy$1 = 1, destroy_1$1 = { destroy: function(W, V) {
    var J = this, re = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
    return re || ie ? (V ? V(W) : W && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(K, this, W)) : process$1.nextTick(K, this, W)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(W || null, function(ne) {
      !V && ne ? J._writableState ? J._writableState.errorEmitted ? process$1.nextTick(L, J) : (J._writableState.errorEmitted = !0, process$1.nextTick(B, J, ne)) : process$1.nextTick(B, J, ne) : V ? (process$1.nextTick(L, J), V(ne)) : process$1.nextTick(L, J);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }, errorOrDestroy: function(W, V) {
    var J = W._readableState, re = W._writableState;
    J && J.autoDestroy || re && re.autoDestroy ? W.destroy(V) : W.emit("error", V);
  } };
}
var errorsBrowser = {}, hasRequiredErrorsBrowser, state, hasRequiredState, browser$b, hasRequiredBrowser$a, _stream_writable$1, hasRequired_stream_writable$1, _stream_duplex$1, hasRequired_stream_duplex$1;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  var B = {};
  function L(W, V, J) {
    J || (J = Error);
    var re = function(ie) {
      var ne, oe;
      function ce(pe, ke, ot) {
        return ie.call(this, function(at, ft, dt) {
          return typeof V == "string" ? V : V(at, ft, dt);
        }(pe, ke, ot)) || this;
      }
      return oe = ie, (ne = ce).prototype = Object.create(oe.prototype), ne.prototype.constructor = ne, ne.__proto__ = oe, ce;
    }(J);
    re.prototype.name = J.name, re.prototype.code = W, B[W] = re;
  }
  function K(W, V) {
    if (Array.isArray(W)) {
      var J = W.length;
      return W = W.map(function(re) {
        return String(re);
      }), J > 2 ? "one of ".concat(V, " ").concat(W.slice(0, J - 1).join(", "), ", or ") + W[J - 1] : J === 2 ? "one of ".concat(V, " ").concat(W[0], " or ").concat(W[1]) : "of ".concat(V, " ").concat(W[0]);
    }
    return "of ".concat(V, " ").concat(String(W));
  }
  return L("ERR_INVALID_OPT_VALUE", function(W, V) {
    return 'The value "' + V + '" is invalid for option "' + W + '"';
  }, TypeError), L("ERR_INVALID_ARG_TYPE", function(W, V, J) {
    var re, ie, ne, oe, ce;
    if (typeof V == "string" && (ie = "not ", V.substr(0, 4) === ie) ? (re = "must not be", V = V.replace(/^not /, "")) : re = "must be", function(ke, ot, at) {
      return (at === void 0 || at > ke.length) && (at = ke.length), ke.substring(at - 9, at) === ot;
    }(W, " argument")) ne = "The ".concat(W, " ").concat(re, " ").concat(K(V, "type"));
    else {
      var pe = (typeof ce != "number" && (ce = 0), ce + 1 > (oe = W).length || oe.indexOf(".", ce) === -1 ? "argument" : "property");
      ne = 'The "'.concat(W, '" ').concat(pe, " ").concat(re, " ").concat(K(V, "type"));
    }
    return ne + ". Received type ".concat(typeof J);
  }, TypeError), L("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), L("ERR_METHOD_NOT_IMPLEMENTED", function(W) {
    return "The " + W + " method is not implemented";
  }), L("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), L("ERR_STREAM_DESTROYED", function(W) {
    return "Cannot call " + W + " after a stream was destroyed";
  }), L("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), L("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), L("ERR_STREAM_WRITE_AFTER_END", "write after end"), L("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), L("ERR_UNKNOWN_ENCODING", function(W) {
    return "Unknown encoding: " + W;
  }, TypeError), L("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = B, errorsBrowser;
}
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  return state = { getHighWaterMark: function(L, K, W, V) {
    var J = function(re, ie, ne) {
      return re.highWaterMark != null ? re.highWaterMark : ie ? re[ne] : null;
    }(K, V, W);
    if (J != null) {
      if (!isFinite(J) || Math.floor(J) !== J || J < 0) throw new B(V ? W : "highWaterMark", J);
      return Math.floor(J);
    }
    return L.objectMode ? 16 : 16384;
  } };
}
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$b;
  function B(L) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[L];
    return K != null && String(K).toLowerCase() === "true";
  }
  return hasRequiredBrowser$a = 1, browser$b = function(L, K) {
    if (B("noDeprecation")) return L;
    var W = !1;
    return function() {
      if (!W) {
        if (B("throwDeprecation")) throw new Error(K);
        B("traceDeprecation"), W = !0;
      }
      return L.apply(this, arguments);
    };
  }, browser$b;
}
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  function B(rt) {
    var it = this;
    this.next = null, this.entry = null, this.finish = function() {
      (function(st, Oe) {
        var ct = st.entry;
        for (st.entry = null; ct; ) {
          var pt = ct.callback;
          Oe.pendingcb--, pt(void 0), ct = ct.next;
        }
        Oe.corkedRequestsFree.next = st;
      })(it, rt);
    };
  }
  var L;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = $t, $t.WritableState = mt;
  var K, W = { deprecate: requireBrowser$a() }, V = requireStreamBrowser$1(), J = require$$1$2.Buffer, re = (commonjsGlobal !== void 0 ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  }, ie = requireDestroy$1(), ne = requireState().getHighWaterMark, oe = requireErrorsBrowser().codes, ce = oe.ERR_INVALID_ARG_TYPE, pe = oe.ERR_METHOD_NOT_IMPLEMENTED, ke = oe.ERR_MULTIPLE_CALLBACK, ot = oe.ERR_STREAM_CANNOT_PIPE, at = oe.ERR_STREAM_DESTROYED, ft = oe.ERR_STREAM_NULL_VALUES, dt = oe.ERR_STREAM_WRITE_AFTER_END, lt = oe.ERR_UNKNOWN_ENCODING, yt = ie.errorOrDestroy;
  function St() {
  }
  function mt(rt, it, st) {
    L = L || require_stream_duplex$1(), rt = rt || {}, typeof st != "boolean" && (st = it instanceof L), this.objectMode = !!rt.objectMode, st && (this.objectMode = this.objectMode || !!rt.writableObjectMode), this.highWaterMark = ne(this, rt, "writableHighWaterMark", st), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Oe = rt.decodeStrings === !1;
    this.decodeStrings = !Oe, this.defaultEncoding = rt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ct) {
      (function(pt, gt) {
        var vt = pt._writableState, Bt = vt.sync, kt = vt.writecb;
        if (typeof kt != "function") throw new ke();
        if (function(Et) {
          Et.writing = !1, Et.writecb = null, Et.length -= Et.writelen, Et.writelen = 0;
        }(vt), gt) (function(Et, Rt, Mt, Ht, Kt) {
          --Rt.pendingcb, Mt ? (process$1.nextTick(Kt, Ht), process$1.nextTick(nt, Et, Rt), Et._writableState.errorEmitted = !0, yt(Et, Ht)) : (Kt(Ht), Et._writableState.errorEmitted = !0, yt(Et, Ht), nt(Et, Rt));
        })(pt, vt, Bt, gt, kt);
        else {
          var wt = ht(vt) || pt.destroyed;
          wt || vt.corked || vt.bufferProcessing || !vt.bufferedRequest || ut(pt, vt), Bt ? process$1.nextTick(Ut, pt, vt, wt, kt) : Ut(pt, vt, wt, kt);
        }
      })(it, ct);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = rt.emitClose !== !1, this.autoDestroy = !!rt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  function $t(rt) {
    var it = this instanceof (L = L || require_stream_duplex$1());
    if (!it && !K.call($t, this)) return new $t(rt);
    this._writableState = new mt(rt, this, it), this.writable = !0, rt && (typeof rt.write == "function" && (this._write = rt.write), typeof rt.writev == "function" && (this._writev = rt.writev), typeof rt.destroy == "function" && (this._destroy = rt.destroy), typeof rt.final == "function" && (this._final = rt.final)), V.call(this);
  }
  function It(rt, it, st, Oe, ct, pt, gt) {
    it.writelen = Oe, it.writecb = gt, it.writing = !0, it.sync = !0, it.destroyed ? it.onwrite(new at("write")) : st ? rt._writev(ct, it.onwrite) : rt._write(ct, pt, it.onwrite), it.sync = !1;
  }
  function Ut(rt, it, st, Oe) {
    st || function(ct, pt) {
      pt.length === 0 && pt.needDrain && (pt.needDrain = !1, ct.emit("drain"));
    }(rt, it), it.pendingcb--, Oe(), nt(rt, it);
  }
  function ut(rt, it) {
    it.bufferProcessing = !0;
    var st = it.bufferedRequest;
    if (rt._writev && st && st.next) {
      var Oe = it.bufferedRequestCount, ct = new Array(Oe), pt = it.corkedRequestsFree;
      pt.entry = st;
      for (var gt = 0, vt = !0; st; ) ct[gt] = st, st.isBuf || (vt = !1), st = st.next, gt += 1;
      ct.allBuffers = vt, It(rt, it, !0, it.length, ct, "", pt.finish), it.pendingcb++, it.lastBufferedRequest = null, pt.next ? (it.corkedRequestsFree = pt.next, pt.next = null) : it.corkedRequestsFree = new B(it), it.bufferedRequestCount = 0;
    } else {
      for (; st; ) {
        var Bt = st.chunk, kt = st.encoding, wt = st.callback;
        if (It(rt, it, !1, it.objectMode ? 1 : Bt.length, Bt, kt, wt), st = st.next, it.bufferedRequestCount--, it.writing) break;
      }
      st === null && (it.lastBufferedRequest = null);
    }
    it.bufferedRequest = st, it.bufferProcessing = !1;
  }
  function ht(rt) {
    return rt.ending && rt.length === 0 && rt.bufferedRequest === null && !rt.finished && !rt.writing;
  }
  function Ce(rt, it) {
    rt._final(function(st) {
      it.pendingcb--, st && yt(rt, st), it.prefinished = !0, rt.emit("prefinish"), nt(rt, it);
    });
  }
  function nt(rt, it) {
    var st = ht(it);
    if (st && (function(ct, pt) {
      pt.prefinished || pt.finalCalled || (typeof ct._final != "function" || pt.destroyed ? (pt.prefinished = !0, ct.emit("prefinish")) : (pt.pendingcb++, pt.finalCalled = !0, process$1.nextTick(Ce, ct, pt)));
    }(rt, it), it.pendingcb === 0 && (it.finished = !0, rt.emit("finish"), it.autoDestroy))) {
      var Oe = rt._readableState;
      (!Oe || Oe.autoDestroy && Oe.endEmitted) && rt.destroy();
    }
    return st;
  }
  return requireInherits_browser()($t, V), mt.prototype.getBuffer = function() {
    for (var rt = this.bufferedRequest, it = []; rt; ) it.push(rt), rt = rt.next;
    return it;
  }, function() {
    try {
      Object.defineProperty(mt.prototype, "buffer", { get: W.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (K = Function.prototype[Symbol.hasInstance], Object.defineProperty($t, Symbol.hasInstance, { value: function(rt) {
    return !!K.call(this, rt) || this === $t && rt && rt._writableState instanceof mt;
  } })) : K = function(rt) {
    return rt instanceof this;
  }, $t.prototype.pipe = function() {
    yt(this, new ot());
  }, $t.prototype.write = function(rt, it, st) {
    var Oe, ct = this._writableState, pt = !1, gt = !ct.objectMode && (Oe = rt, J.isBuffer(Oe) || Oe instanceof re);
    return gt && !J.isBuffer(rt) && (rt = function(vt) {
      return J.from(vt);
    }(rt)), typeof it == "function" && (st = it, it = null), gt ? it = "buffer" : it || (it = ct.defaultEncoding), typeof st != "function" && (st = St), ct.ending ? function(vt, Bt) {
      var kt = new dt();
      yt(vt, kt), process$1.nextTick(Bt, kt);
    }(this, st) : (gt || function(vt, Bt, kt, wt) {
      var Et;
      return kt === null ? Et = new ft() : typeof kt == "string" || Bt.objectMode || (Et = new ce("chunk", ["string", "Buffer"], kt)), !Et || (yt(vt, Et), process$1.nextTick(wt, Et), !1);
    }(this, ct, rt, st)) && (ct.pendingcb++, pt = function(vt, Bt, kt, wt, Et, Rt) {
      if (!kt) {
        var Mt = function(Wt, Yt, Xt) {
          return Wt.objectMode || Wt.decodeStrings === !1 || typeof Yt != "string" || (Yt = J.from(Yt, Xt)), Yt;
        }(Bt, wt, Et);
        wt !== Mt && (kt = !0, Et = "buffer", wt = Mt);
      }
      var Ht = Bt.objectMode ? 1 : wt.length;
      Bt.length += Ht;
      var Kt = Bt.length < Bt.highWaterMark;
      if (Kt || (Bt.needDrain = !0), Bt.writing || Bt.corked) {
        var jt = Bt.lastBufferedRequest;
        Bt.lastBufferedRequest = { chunk: wt, encoding: Et, isBuf: kt, callback: Rt, next: null }, jt ? jt.next = Bt.lastBufferedRequest : Bt.bufferedRequest = Bt.lastBufferedRequest, Bt.bufferedRequestCount += 1;
      } else It(vt, Bt, !1, Ht, wt, Et, Rt);
      return Kt;
    }(this, ct, gt, rt, it, st)), pt;
  }, $t.prototype.cork = function() {
    this._writableState.corked++;
  }, $t.prototype.uncork = function() {
    var rt = this._writableState;
    rt.corked && (rt.corked--, rt.writing || rt.corked || rt.bufferProcessing || !rt.bufferedRequest || ut(this, rt));
  }, $t.prototype.setDefaultEncoding = function(rt) {
    if (typeof rt == "string" && (rt = rt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((rt + "").toLowerCase()) > -1)) throw new lt(rt);
    return this._writableState.defaultEncoding = rt, this;
  }, Object.defineProperty($t.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty($t.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), $t.prototype._write = function(rt, it, st) {
    st(new pe("_write()"));
  }, $t.prototype._writev = null, $t.prototype.end = function(rt, it, st) {
    var Oe = this._writableState;
    return typeof rt == "function" ? (st = rt, rt = null, it = null) : typeof it == "function" && (st = it, it = null), rt != null && this.write(rt, it), Oe.corked && (Oe.corked = 1, this.uncork()), Oe.ending || function(ct, pt, gt) {
      pt.ending = !0, nt(ct, pt), gt && (pt.finished ? process$1.nextTick(gt) : ct.once("finish", gt)), pt.ended = !0, ct.writable = !1;
    }(this, Oe, st), this;
  }, Object.defineProperty($t.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty($t.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._writableState !== void 0 && this._writableState.destroyed;
  }, set: function(rt) {
    this._writableState && (this._writableState.destroyed = rt);
  } }), $t.prototype.destroy = ie.destroy, $t.prototype._undestroy = ie.undestroy, $t.prototype._destroy = function(rt, it) {
    it(rt);
  }, _stream_writable$1;
}
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(oe) {
    var ce = [];
    for (var pe in oe) ce.push(pe);
    return ce;
  };
  _stream_duplex$1 = re;
  var L = require_stream_readable$1(), K = require_stream_writable$1();
  requireInherits_browser()(re, L);
  for (var W = B(K.prototype), V = 0; V < W.length; V++) {
    var J = W[V];
    re.prototype[J] || (re.prototype[J] = K.prototype[J]);
  }
  function re(oe) {
    if (!(this instanceof re)) return new re(oe);
    L.call(this, oe), K.call(this, oe), this.allowHalfOpen = !0, oe && (oe.readable === !1 && (this.readable = !1), oe.writable === !1 && (this.writable = !1), oe.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ie)));
  }
  function ie() {
    this._writableState.ended || process$1.nextTick(ne, this);
  }
  function ne(oe) {
    oe.end();
  }
  return Object.defineProperty(re.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(re.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(re.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(re.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(oe) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = oe, this._writableState.destroyed = oe);
  } }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder, endOfStream, hasRequiredEndOfStream, async_iterator, hasRequiredAsync_iterator, fromBrowser, hasRequiredFromBrowser, _stream_readable$1, hasRequired_stream_readable$1, _stream_transform$1, hasRequired_stream_transform$1, _stream_passthrough$1, hasRequired_stream_passthrough$1, pipeline_1, hasRequiredPipeline, hasRequiredReadableBrowser$1, hashBase, hasRequiredHashBase, md5_js, hasRequiredMd5_js, ripemd160, hasRequiredRipemd160;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var B = safeBufferExports.Buffer, L = B.isEncoding || function(pe) {
    switch ((pe = "" + pe) && pe.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function K(pe) {
    var ke;
    switch (this.encoding = function(ot) {
      var at = function(ft) {
        if (!ft) return "utf8";
        for (var dt; ; ) switch (ft) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return ft;
          default:
            if (dt) return;
            ft = ("" + ft).toLowerCase(), dt = !0;
        }
      }(ot);
      if (typeof at != "string" && (B.isEncoding === L || !L(ot))) throw new Error("Unknown encoding: " + ot);
      return at || ot;
    }(pe), this.encoding) {
      case "utf16le":
        this.text = J, this.end = re, ke = 4;
        break;
      case "utf8":
        this.fillLast = V, ke = 4;
        break;
      case "base64":
        this.text = ie, this.end = ne, ke = 3;
        break;
      default:
        return this.write = oe, void (this.end = ce);
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = B.allocUnsafe(ke);
  }
  function W(pe) {
    return pe <= 127 ? 0 : pe >> 5 == 6 ? 2 : pe >> 4 == 14 ? 3 : pe >> 3 == 30 ? 4 : pe >> 6 == 2 ? -1 : -2;
  }
  function V(pe) {
    var ke = this.lastTotal - this.lastNeed, ot = function(at, ft) {
      if ((192 & ft[0]) != 128) return at.lastNeed = 0, "";
      if (at.lastNeed > 1 && ft.length > 1) {
        if ((192 & ft[1]) != 128) return at.lastNeed = 1, "";
        if (at.lastNeed > 2 && ft.length > 2 && (192 & ft[2]) != 128) return at.lastNeed = 2, "";
      }
    }(this, pe);
    return ot !== void 0 ? ot : this.lastNeed <= pe.length ? (pe.copy(this.lastChar, ke, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (pe.copy(this.lastChar, ke, 0, pe.length), void (this.lastNeed -= pe.length));
  }
  function J(pe, ke) {
    if ((pe.length - ke) % 2 == 0) {
      var ot = pe.toString("utf16le", ke);
      if (ot) {
        var at = ot.charCodeAt(ot.length - 1);
        if (at >= 55296 && at <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = pe[pe.length - 2], this.lastChar[1] = pe[pe.length - 1], ot.slice(0, -1);
      }
      return ot;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = pe[pe.length - 1], pe.toString("utf16le", ke, pe.length - 1);
  }
  function re(pe) {
    var ke = pe && pe.length ? this.write(pe) : "";
    if (this.lastNeed) {
      var ot = this.lastTotal - this.lastNeed;
      return ke + this.lastChar.toString("utf16le", 0, ot);
    }
    return ke;
  }
  function ie(pe, ke) {
    var ot = (pe.length - ke) % 3;
    return ot === 0 ? pe.toString("base64", ke) : (this.lastNeed = 3 - ot, this.lastTotal = 3, ot === 1 ? this.lastChar[0] = pe[pe.length - 1] : (this.lastChar[0] = pe[pe.length - 2], this.lastChar[1] = pe[pe.length - 1]), pe.toString("base64", ke, pe.length - ot));
  }
  function ne(pe) {
    var ke = pe && pe.length ? this.write(pe) : "";
    return this.lastNeed ? ke + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ke;
  }
  function oe(pe) {
    return pe.toString(this.encoding);
  }
  function ce(pe) {
    return pe && pe.length ? this.write(pe) : "";
  }
  return string_decoder.StringDecoder = K, K.prototype.write = function(pe) {
    if (pe.length === 0) return "";
    var ke, ot;
    if (this.lastNeed) {
      if ((ke = this.fillLast(pe)) === void 0) return "";
      ot = this.lastNeed, this.lastNeed = 0;
    } else ot = 0;
    return ot < pe.length ? ke ? ke + this.text(pe, ot) : this.text(pe, ot) : ke || "";
  }, K.prototype.end = function(pe) {
    var ke = pe && pe.length ? this.write(pe) : "";
    return this.lastNeed ? ke + "" : ke;
  }, K.prototype.text = function(pe, ke) {
    var ot = function(ft, dt, lt) {
      var yt = dt.length - 1;
      if (yt < lt) return 0;
      var St = W(dt[yt]);
      return St >= 0 ? (St > 0 && (ft.lastNeed = St - 1), St) : --yt < lt || St === -2 ? 0 : (St = W(dt[yt])) >= 0 ? (St > 0 && (ft.lastNeed = St - 2), St) : --yt < lt || St === -2 ? 0 : (St = W(dt[yt])) >= 0 ? (St > 0 && (St === 2 ? St = 0 : ft.lastNeed = St - 3), St) : 0;
    }(this, pe, ke);
    if (!this.lastNeed) return pe.toString("utf8", ke);
    this.lastTotal = ot;
    var at = pe.length - (ot - this.lastNeed);
    return pe.copy(this.lastChar, 0, at), pe.toString("utf8", ke, at);
  }, K.prototype.fillLast = function(pe) {
    if (this.lastNeed <= pe.length) return pe.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    pe.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, pe.length), this.lastNeed -= pe.length;
  }, string_decoder;
}
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function L() {
  }
  return endOfStream = function K(W, V, J) {
    if (typeof V == "function") return K(W, null, V);
    V || (V = {}), J = /* @__PURE__ */ function(dt) {
      var lt = !1;
      return function() {
        if (!lt) {
          lt = !0;
          for (var yt = arguments.length, St = new Array(yt), mt = 0; mt < yt; mt++) St[mt] = arguments[mt];
          dt.apply(this, St);
        }
      };
    }(J || L);
    var re = V.readable || V.readable !== !1 && W.readable, ie = V.writable || V.writable !== !1 && W.writable, ne = function() {
      W.writable || ce();
    }, oe = W._writableState && W._writableState.finished, ce = function() {
      ie = !1, oe = !0, re || J.call(W);
    }, pe = W._readableState && W._readableState.endEmitted, ke = function() {
      re = !1, pe = !0, ie || J.call(W);
    }, ot = function(dt) {
      J.call(W, dt);
    }, at = function() {
      var dt;
      return re && !pe ? (W._readableState && W._readableState.ended || (dt = new B()), J.call(W, dt)) : ie && !oe ? (W._writableState && W._writableState.ended || (dt = new B()), J.call(W, dt)) : void 0;
    }, ft = function() {
      W.req.on("finish", ce);
    };
    return function(dt) {
      return dt.setHeader && typeof dt.abort == "function";
    }(W) ? (W.on("complete", ce), W.on("abort", at), W.req ? ft() : W.on("request", ft)) : ie && !W._writableState && (W.on("end", ne), W.on("close", ne)), W.on("end", ke), W.on("finish", ce), V.error !== !1 && W.on("error", ot), W.on("close", at), function() {
      W.removeListener("complete", ce), W.removeListener("abort", at), W.removeListener("request", ft), W.req && W.req.removeListener("finish", ce), W.removeListener("end", ne), W.removeListener("close", ne), W.removeListener("finish", ce), W.removeListener("end", ke), W.removeListener("error", ot), W.removeListener("close", at);
    };
  }, endOfStream;
}
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  var B;
  function L(ft, dt, lt) {
    return (dt = function(yt) {
      var St = function(mt) {
        if (typeof mt != "object" || mt === null) return mt;
        var $t = mt[Symbol.toPrimitive];
        if ($t !== void 0) {
          var It = $t.call(mt, "string");
          if (typeof It != "object") return It;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(mt);
      }(yt);
      return typeof St == "symbol" ? St : String(St);
    }(dt)) in ft ? Object.defineProperty(ft, dt, { value: lt, enumerable: !0, configurable: !0, writable: !0 }) : ft[dt] = lt, ft;
  }
  hasRequiredAsync_iterator = 1;
  var K = requireEndOfStream(), W = Symbol("lastResolve"), V = Symbol("lastReject"), J = Symbol("error"), re = Symbol("ended"), ie = Symbol("lastPromise"), ne = Symbol("handlePromise"), oe = Symbol("stream");
  function ce(ft, dt) {
    return { value: ft, done: dt };
  }
  function pe(ft) {
    var dt = ft[W];
    if (dt !== null) {
      var lt = ft[oe].read();
      lt !== null && (ft[ie] = null, ft[W] = null, ft[V] = null, dt(ce(lt, !1)));
    }
  }
  function ke(ft) {
    process$1.nextTick(pe, ft);
  }
  var ot = Object.getPrototypeOf(function() {
  }), at = Object.setPrototypeOf((L(B = { get stream() {
    return this[oe];
  }, next: function() {
    var ft = this, dt = this[J];
    if (dt !== null) return Promise.reject(dt);
    if (this[re]) return Promise.resolve(ce(void 0, !0));
    if (this[oe].destroyed) return new Promise(function(mt, $t) {
      process$1.nextTick(function() {
        ft[J] ? $t(ft[J]) : mt(ce(void 0, !0));
      });
    });
    var lt, yt = this[ie];
    if (yt) lt = new Promise(/* @__PURE__ */ function(mt, $t) {
      return function(It, Ut) {
        mt.then(function() {
          $t[re] ? It(ce(void 0, !0)) : $t[ne](It, Ut);
        }, Ut);
      };
    }(yt, this));
    else {
      var St = this[oe].read();
      if (St !== null) return Promise.resolve(ce(St, !1));
      lt = new Promise(this[ne]);
    }
    return this[ie] = lt, lt;
  } }, Symbol.asyncIterator, function() {
    return this;
  }), L(B, "return", function() {
    var ft = this;
    return new Promise(function(dt, lt) {
      ft[oe].destroy(null, function(yt) {
        yt ? lt(yt) : dt(ce(void 0, !0));
      });
    });
  }), B), ot);
  return async_iterator = function(ft) {
    var dt, lt = Object.create(at, (L(dt = {}, oe, { value: ft, writable: !0 }), L(dt, W, { value: null, writable: !0 }), L(dt, V, { value: null, writable: !0 }), L(dt, J, { value: null, writable: !0 }), L(dt, re, { value: ft._readableState.endEmitted, writable: !0 }), L(dt, ne, { value: function(yt, St) {
      var mt = lt[oe].read();
      mt ? (lt[ie] = null, lt[W] = null, lt[V] = null, yt(ce(mt, !1))) : (lt[W] = yt, lt[V] = St);
    }, writable: !0 }), dt));
    return lt[ie] = null, K(ft, function(yt) {
      if (yt && yt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var St = lt[V];
        return St !== null && (lt[ie] = null, lt[W] = null, lt[V] = null, St(yt)), void (lt[J] = yt);
      }
      var mt = lt[W];
      mt !== null && (lt[ie] = null, lt[W] = null, lt[V] = null, mt(ce(void 0, !0))), lt[re] = !0;
    }), ft.on("readable", ke.bind(null, lt)), lt;
  };
}
function requireFromBrowser() {
  return hasRequiredFromBrowser ? fromBrowser : (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  });
}
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  var B;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = $t, $t.ReadableState = mt, requireEvents().EventEmitter;
  var L, K = function(wt, Et) {
    return wt.listeners(Et).length;
  }, W = requireStreamBrowser$1(), V = require$$1$2.Buffer, J = (commonjsGlobal !== void 0 ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  }, re = requireUtil$1();
  L = re && re.debuglog ? re.debuglog("stream") : function() {
  };
  var ie, ne, oe, ce = requireBuffer_list(), pe = requireDestroy$1(), ke = requireState().getHighWaterMark, ot = requireErrorsBrowser().codes, at = ot.ERR_INVALID_ARG_TYPE, ft = ot.ERR_STREAM_PUSH_AFTER_EOF, dt = ot.ERR_METHOD_NOT_IMPLEMENTED, lt = ot.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  requireInherits_browser()($t, W);
  var yt = pe.errorOrDestroy, St = ["error", "close", "destroy", "pause", "resume"];
  function mt(wt, Et, Rt) {
    B = B || require_stream_duplex$1(), wt = wt || {}, typeof Rt != "boolean" && (Rt = Et instanceof B), this.objectMode = !!wt.objectMode, Rt && (this.objectMode = this.objectMode || !!wt.readableObjectMode), this.highWaterMark = ke(this, wt, "readableHighWaterMark", Rt), this.buffer = new ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = wt.emitClose !== !1, this.autoDestroy = !!wt.autoDestroy, this.destroyed = !1, this.defaultEncoding = wt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, wt.encoding && (ie || (ie = requireString_decoder().StringDecoder), this.decoder = new ie(wt.encoding), this.encoding = wt.encoding);
  }
  function $t(wt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof $t)) return new $t(wt);
    var Et = this instanceof B;
    this._readableState = new mt(wt, this, Et), this.readable = !0, wt && (typeof wt.read == "function" && (this._read = wt.read), typeof wt.destroy == "function" && (this._destroy = wt.destroy)), W.call(this);
  }
  function It(wt, Et, Rt, Mt, Ht) {
    L("readableAddChunk", Et);
    var Kt, jt = wt._readableState;
    if (Et === null) jt.reading = !1, function(Wt, Yt) {
      if (L("onEofChunk"), !Yt.ended) {
        if (Yt.decoder) {
          var Xt = Yt.decoder.end();
          Xt && Xt.length && (Yt.buffer.push(Xt), Yt.length += Yt.objectMode ? 1 : Xt.length);
        }
        Yt.ended = !0, Yt.sync ? Ce(Wt) : (Yt.needReadable = !1, Yt.emittedReadable || (Yt.emittedReadable = !0, nt(Wt)));
      }
    }(wt, jt);
    else if (Ht || (Kt = function(Wt, Yt) {
      var Xt, ir;
      return ir = Yt, V.isBuffer(ir) || ir instanceof J || typeof Yt == "string" || Yt === void 0 || Wt.objectMode || (Xt = new at("chunk", ["string", "Buffer", "Uint8Array"], Yt)), Xt;
    }(jt, Et)), Kt) yt(wt, Kt);
    else if (jt.objectMode || Et && Et.length > 0) if (typeof Et == "string" || jt.objectMode || Object.getPrototypeOf(Et) === V.prototype || (Et = function(Wt) {
      return V.from(Wt);
    }(Et)), Mt) jt.endEmitted ? yt(wt, new lt()) : Ut(wt, jt, Et, !0);
    else if (jt.ended) yt(wt, new ft());
    else {
      if (jt.destroyed) return !1;
      jt.reading = !1, jt.decoder && !Rt ? (Et = jt.decoder.write(Et), jt.objectMode || Et.length !== 0 ? Ut(wt, jt, Et, !1) : rt(wt, jt)) : Ut(wt, jt, Et, !1);
    }
    else Mt || (jt.reading = !1, rt(wt, jt));
    return !jt.ended && (jt.length < jt.highWaterMark || jt.length === 0);
  }
  function Ut(wt, Et, Rt, Mt) {
    Et.flowing && Et.length === 0 && !Et.sync ? (Et.awaitDrain = 0, wt.emit("data", Rt)) : (Et.length += Et.objectMode ? 1 : Rt.length, Mt ? Et.buffer.unshift(Rt) : Et.buffer.push(Rt), Et.needReadable && Ce(wt)), rt(wt, Et);
  }
  Object.defineProperty($t.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._readableState.destroyed;
  }, set: function(wt) {
    this._readableState && (this._readableState.destroyed = wt);
  } }), $t.prototype.destroy = pe.destroy, $t.prototype._undestroy = pe.undestroy, $t.prototype._destroy = function(wt, Et) {
    Et(wt);
  }, $t.prototype.push = function(wt, Et) {
    var Rt, Mt = this._readableState;
    return Mt.objectMode ? Rt = !0 : typeof wt == "string" && ((Et = Et || Mt.defaultEncoding) !== Mt.encoding && (wt = V.from(wt, Et), Et = ""), Rt = !0), It(this, wt, Et, !1, Rt);
  }, $t.prototype.unshift = function(wt) {
    return It(this, wt, null, !0, !1);
  }, $t.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, $t.prototype.setEncoding = function(wt) {
    ie || (ie = requireString_decoder().StringDecoder);
    var Et = new ie(wt);
    this._readableState.decoder = Et, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Rt = this._readableState.buffer.head, Mt = ""; Rt !== null; ) Mt += Et.write(Rt.data), Rt = Rt.next;
    return this._readableState.buffer.clear(), Mt !== "" && this._readableState.buffer.push(Mt), this._readableState.length = Mt.length, this;
  };
  var ut = 1073741824;
  function ht(wt, Et) {
    return wt <= 0 || Et.length === 0 && Et.ended ? 0 : Et.objectMode ? 1 : wt != wt ? Et.flowing && Et.length ? Et.buffer.head.data.length : Et.length : (wt > Et.highWaterMark && (Et.highWaterMark = function(Rt) {
      return Rt >= ut ? Rt = ut : (Rt--, Rt |= Rt >>> 1, Rt |= Rt >>> 2, Rt |= Rt >>> 4, Rt |= Rt >>> 8, Rt |= Rt >>> 16, Rt++), Rt;
    }(wt)), wt <= Et.length ? wt : Et.ended ? Et.length : (Et.needReadable = !0, 0));
  }
  function Ce(wt) {
    var Et = wt._readableState;
    L("emitReadable", Et.needReadable, Et.emittedReadable), Et.needReadable = !1, Et.emittedReadable || (L("emitReadable", Et.flowing), Et.emittedReadable = !0, process$1.nextTick(nt, wt));
  }
  function nt(wt) {
    var Et = wt._readableState;
    L("emitReadable_", Et.destroyed, Et.length, Et.ended), Et.destroyed || !Et.length && !Et.ended || (wt.emit("readable"), Et.emittedReadable = !1), Et.needReadable = !Et.flowing && !Et.ended && Et.length <= Et.highWaterMark, pt(wt);
  }
  function rt(wt, Et) {
    Et.readingMore || (Et.readingMore = !0, process$1.nextTick(it, wt, Et));
  }
  function it(wt, Et) {
    for (; !Et.reading && !Et.ended && (Et.length < Et.highWaterMark || Et.flowing && Et.length === 0); ) {
      var Rt = Et.length;
      if (L("maybeReadMore read 0"), wt.read(0), Rt === Et.length) break;
    }
    Et.readingMore = !1;
  }
  function st(wt) {
    var Et = wt._readableState;
    Et.readableListening = wt.listenerCount("readable") > 0, Et.resumeScheduled && !Et.paused ? Et.flowing = !0 : wt.listenerCount("data") > 0 && wt.resume();
  }
  function Oe(wt) {
    L("readable nexttick read 0"), wt.read(0);
  }
  function ct(wt, Et) {
    L("resume", Et.reading), Et.reading || wt.read(0), Et.resumeScheduled = !1, wt.emit("resume"), pt(wt), Et.flowing && !Et.reading && wt.read(0);
  }
  function pt(wt) {
    var Et = wt._readableState;
    for (L("flow", Et.flowing); Et.flowing && wt.read() !== null; ) ;
  }
  function gt(wt, Et) {
    return Et.length === 0 ? null : (Et.objectMode ? Rt = Et.buffer.shift() : !wt || wt >= Et.length ? (Rt = Et.decoder ? Et.buffer.join("") : Et.buffer.length === 1 ? Et.buffer.first() : Et.buffer.concat(Et.length), Et.buffer.clear()) : Rt = Et.buffer.consume(wt, Et.decoder), Rt);
    var Rt;
  }
  function vt(wt) {
    var Et = wt._readableState;
    L("endReadable", Et.endEmitted), Et.endEmitted || (Et.ended = !0, process$1.nextTick(Bt, Et, wt));
  }
  function Bt(wt, Et) {
    if (L("endReadableNT", wt.endEmitted, wt.length), !wt.endEmitted && wt.length === 0 && (wt.endEmitted = !0, Et.readable = !1, Et.emit("end"), wt.autoDestroy)) {
      var Rt = Et._writableState;
      (!Rt || Rt.autoDestroy && Rt.finished) && Et.destroy();
    }
  }
  function kt(wt, Et) {
    for (var Rt = 0, Mt = wt.length; Rt < Mt; Rt++) if (wt[Rt] === Et) return Rt;
    return -1;
  }
  return $t.prototype.read = function(wt) {
    L("read", wt), wt = parseInt(wt, 10);
    var Et = this._readableState, Rt = wt;
    if (wt !== 0 && (Et.emittedReadable = !1), wt === 0 && Et.needReadable && ((Et.highWaterMark !== 0 ? Et.length >= Et.highWaterMark : Et.length > 0) || Et.ended)) return L("read: emitReadable", Et.length, Et.ended), Et.length === 0 && Et.ended ? vt(this) : Ce(this), null;
    if ((wt = ht(wt, Et)) === 0 && Et.ended) return Et.length === 0 && vt(this), null;
    var Mt, Ht = Et.needReadable;
    return L("need readable", Ht), (Et.length === 0 || Et.length - wt < Et.highWaterMark) && L("length less than watermark", Ht = !0), Et.ended || Et.reading ? L("reading or ended", Ht = !1) : Ht && (L("do read"), Et.reading = !0, Et.sync = !0, Et.length === 0 && (Et.needReadable = !0), this._read(Et.highWaterMark), Et.sync = !1, Et.reading || (wt = ht(Rt, Et))), (Mt = wt > 0 ? gt(wt, Et) : null) === null ? (Et.needReadable = Et.length <= Et.highWaterMark, wt = 0) : (Et.length -= wt, Et.awaitDrain = 0), Et.length === 0 && (Et.ended || (Et.needReadable = !0), Rt !== wt && Et.ended && vt(this)), Mt !== null && this.emit("data", Mt), Mt;
  }, $t.prototype._read = function(wt) {
    yt(this, new dt("_read()"));
  }, $t.prototype.pipe = function(wt, Et) {
    var Rt = this, Mt = this._readableState;
    switch (Mt.pipesCount) {
      case 0:
        Mt.pipes = wt;
        break;
      case 1:
        Mt.pipes = [Mt.pipes, wt];
        break;
      default:
        Mt.pipes.push(wt);
    }
    Mt.pipesCount += 1, L("pipe count=%d opts=%j", Mt.pipesCount, Et);
    var Ht = Et && Et.end === !1 || wt === process$1.stdout || wt === process$1.stderr ? Qt : Kt;
    function Kt() {
      L("onend"), wt.end();
    }
    Mt.endEmitted ? process$1.nextTick(Ht) : Rt.once("end", Ht), wt.on("unpipe", function hr(pr, cr) {
      L("onunpipe"), pr === Rt && cr && cr.hasUnpiped === !1 && (cr.hasUnpiped = !0, L("cleanup"), wt.removeListener("close", ir), wt.removeListener("finish", ur), wt.removeListener("drain", jt), wt.removeListener("error", Xt), wt.removeListener("unpipe", hr), Rt.removeListener("end", Kt), Rt.removeListener("end", Qt), Rt.removeListener("data", Yt), Wt = !0, !Mt.awaitDrain || wt._writableState && !wt._writableState.needDrain || jt());
    });
    var jt = /* @__PURE__ */ function(hr) {
      return function() {
        var pr = hr._readableState;
        L("pipeOnDrain", pr.awaitDrain), pr.awaitDrain && pr.awaitDrain--, pr.awaitDrain === 0 && K(hr, "data") && (pr.flowing = !0, pt(hr));
      };
    }(Rt);
    wt.on("drain", jt);
    var Wt = !1;
    function Yt(hr) {
      L("ondata");
      var pr = wt.write(hr);
      L("dest.write", pr), pr === !1 && ((Mt.pipesCount === 1 && Mt.pipes === wt || Mt.pipesCount > 1 && kt(Mt.pipes, wt) !== -1) && !Wt && (L("false write response, pause", Mt.awaitDrain), Mt.awaitDrain++), Rt.pause());
    }
    function Xt(hr) {
      L("onerror", hr), Qt(), wt.removeListener("error", Xt), K(wt, "error") === 0 && yt(wt, hr);
    }
    function ir() {
      wt.removeListener("finish", ur), Qt();
    }
    function ur() {
      L("onfinish"), wt.removeListener("close", ir), Qt();
    }
    function Qt() {
      L("unpipe"), Rt.unpipe(wt);
    }
    return Rt.on("data", Yt), function(hr, pr, cr) {
      if (typeof hr.prependListener == "function") return hr.prependListener(pr, cr);
      hr._events && hr._events[pr] ? Array.isArray(hr._events[pr]) ? hr._events[pr].unshift(cr) : hr._events[pr] = [cr, hr._events[pr]] : hr.on(pr, cr);
    }(wt, "error", Xt), wt.once("close", ir), wt.once("finish", ur), wt.emit("pipe", Rt), Mt.flowing || (L("pipe resume"), Rt.resume()), wt;
  }, $t.prototype.unpipe = function(wt) {
    var Et = this._readableState, Rt = { hasUnpiped: !1 };
    if (Et.pipesCount === 0) return this;
    if (Et.pipesCount === 1) return wt && wt !== Et.pipes || (wt || (wt = Et.pipes), Et.pipes = null, Et.pipesCount = 0, Et.flowing = !1, wt && wt.emit("unpipe", this, Rt)), this;
    if (!wt) {
      var Mt = Et.pipes, Ht = Et.pipesCount;
      Et.pipes = null, Et.pipesCount = 0, Et.flowing = !1;
      for (var Kt = 0; Kt < Ht; Kt++) Mt[Kt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var jt = kt(Et.pipes, wt);
    return jt === -1 || (Et.pipes.splice(jt, 1), Et.pipesCount -= 1, Et.pipesCount === 1 && (Et.pipes = Et.pipes[0]), wt.emit("unpipe", this, Rt)), this;
  }, $t.prototype.on = function(wt, Et) {
    var Rt = W.prototype.on.call(this, wt, Et), Mt = this._readableState;
    return wt === "data" ? (Mt.readableListening = this.listenerCount("readable") > 0, Mt.flowing !== !1 && this.resume()) : wt === "readable" && (Mt.endEmitted || Mt.readableListening || (Mt.readableListening = Mt.needReadable = !0, Mt.flowing = !1, Mt.emittedReadable = !1, L("on readable", Mt.length, Mt.reading), Mt.length ? Ce(this) : Mt.reading || process$1.nextTick(Oe, this))), Rt;
  }, $t.prototype.addListener = $t.prototype.on, $t.prototype.removeListener = function(wt, Et) {
    var Rt = W.prototype.removeListener.call(this, wt, Et);
    return wt === "readable" && process$1.nextTick(st, this), Rt;
  }, $t.prototype.removeAllListeners = function(wt) {
    var Et = W.prototype.removeAllListeners.apply(this, arguments);
    return wt !== "readable" && wt !== void 0 || process$1.nextTick(st, this), Et;
  }, $t.prototype.resume = function() {
    var wt = this._readableState;
    return wt.flowing || (L("resume"), wt.flowing = !wt.readableListening, function(Et, Rt) {
      Rt.resumeScheduled || (Rt.resumeScheduled = !0, process$1.nextTick(ct, Et, Rt));
    }(this, wt)), wt.paused = !1, this;
  }, $t.prototype.pause = function() {
    return L("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (L("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  }, $t.prototype.wrap = function(wt) {
    var Et = this, Rt = this._readableState, Mt = !1;
    for (var Ht in wt.on("end", function() {
      if (L("wrapped end"), Rt.decoder && !Rt.ended) {
        var jt = Rt.decoder.end();
        jt && jt.length && Et.push(jt);
      }
      Et.push(null);
    }), wt.on("data", function(jt) {
      L("wrapped data"), Rt.decoder && (jt = Rt.decoder.write(jt)), Rt.objectMode && jt == null || (Rt.objectMode || jt && jt.length) && (Et.push(jt) || (Mt = !0, wt.pause()));
    }), wt) this[Ht] === void 0 && typeof wt[Ht] == "function" && (this[Ht] = /* @__PURE__ */ function(jt) {
      return function() {
        return wt[jt].apply(wt, arguments);
      };
    }(Ht));
    for (var Kt = 0; Kt < St.length; Kt++) wt.on(St[Kt], this.emit.bind(this, St[Kt]));
    return this._read = function(jt) {
      L("wrapped _read", jt), Mt && (Mt = !1, wt.resume());
    }, this;
  }, typeof Symbol == "function" && ($t.prototype[Symbol.asyncIterator] = function() {
    return ne === void 0 && (ne = requireAsync_iterator()), ne(this);
  }), Object.defineProperty($t.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty($t.prototype, "readableBuffer", { enumerable: !1, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty($t.prototype, "readableFlowing", { enumerable: !1, get: function() {
    return this._readableState.flowing;
  }, set: function(wt) {
    this._readableState && (this._readableState.flowing = wt);
  } }), $t._fromList = gt, Object.defineProperty($t.prototype, "readableLength", { enumerable: !1, get: function() {
    return this._readableState.length;
  } }), typeof Symbol == "function" && ($t.from = function(wt, Et) {
    return oe === void 0 && (oe = requireFromBrowser()), oe($t, wt, Et);
  }), _stream_readable$1;
}
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ie;
  var B = requireErrorsBrowser().codes, L = B.ERR_METHOD_NOT_IMPLEMENTED, K = B.ERR_MULTIPLE_CALLBACK, W = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, V = B.ERR_TRANSFORM_WITH_LENGTH_0, J = require_stream_duplex$1();
  function re(ce, pe) {
    var ke = this._transformState;
    ke.transforming = !1;
    var ot = ke.writecb;
    if (ot === null) return this.emit("error", new K());
    ke.writechunk = null, ke.writecb = null, pe != null && this.push(pe), ot(ce);
    var at = this._readableState;
    at.reading = !1, (at.needReadable || at.length < at.highWaterMark) && this._read(at.highWaterMark);
  }
  function ie(ce) {
    if (!(this instanceof ie)) return new ie(ce);
    J.call(this, ce), this._transformState = { afterTransform: re.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, ce && (typeof ce.transform == "function" && (this._transform = ce.transform), typeof ce.flush == "function" && (this._flush = ce.flush)), this.on("prefinish", ne);
  }
  function ne() {
    var ce = this;
    typeof this._flush != "function" || this._readableState.destroyed ? oe(this, null, null) : this._flush(function(pe, ke) {
      oe(ce, pe, ke);
    });
  }
  function oe(ce, pe, ke) {
    if (pe) return ce.emit("error", pe);
    if (ke != null && ce.push(ke), ce._writableState.length) throw new V();
    if (ce._transformState.transforming) throw new W();
    return ce.push(null);
  }
  return requireInherits_browser()(ie, J), ie.prototype.push = function(ce, pe) {
    return this._transformState.needTransform = !1, J.prototype.push.call(this, ce, pe);
  }, ie.prototype._transform = function(ce, pe, ke) {
    ke(new L("_transform()"));
  }, ie.prototype._write = function(ce, pe, ke) {
    var ot = this._transformState;
    if (ot.writecb = ke, ot.writechunk = ce, ot.writeencoding = pe, !ot.transforming) {
      var at = this._readableState;
      (ot.needTransform || at.needReadable || at.length < at.highWaterMark) && this._read(at.highWaterMark);
    }
  }, ie.prototype._read = function(ce) {
    var pe = this._transformState;
    pe.writechunk === null || pe.transforming ? pe.needTransform = !0 : (pe.transforming = !0, this._transform(pe.writechunk, pe.writeencoding, pe.afterTransform));
  }, ie.prototype._destroy = function(ce, pe) {
    J.prototype._destroy.call(this, ce, function(ke) {
      pe(ke);
    });
  }, _stream_transform$1;
}
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = L;
  var B = require_stream_transform$1();
  function L(K) {
    if (!(this instanceof L)) return new L(K);
    B.call(this, K);
  }
  return requireInherits_browser()(L, B), L.prototype._transform = function(K, W, V) {
    V(null, K);
  }, _stream_passthrough$1;
}
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  var B;
  hasRequiredPipeline = 1;
  var L = requireErrorsBrowser().codes, K = L.ERR_MISSING_ARGS, W = L.ERR_STREAM_DESTROYED;
  function V(ie) {
    if (ie) throw ie;
  }
  function J(ie) {
    ie();
  }
  function re(ie, ne) {
    return ie.pipe(ne);
  }
  return pipeline_1 = function() {
    for (var ie = arguments.length, ne = new Array(ie), oe = 0; oe < ie; oe++) ne[oe] = arguments[oe];
    var ce, pe = function(ot) {
      return ot.length ? typeof ot[ot.length - 1] != "function" ? V : ot.pop() : V;
    }(ne);
    if (Array.isArray(ne[0]) && (ne = ne[0]), ne.length < 2) throw new K("streams");
    var ke = ne.map(function(ot, at) {
      var ft = at < ne.length - 1;
      return function(dt, lt, yt, St) {
        St = /* @__PURE__ */ function(It) {
          var Ut = !1;
          return function() {
            Ut || (Ut = !0, It.apply(void 0, arguments));
          };
        }(St);
        var mt = !1;
        dt.on("close", function() {
          mt = !0;
        }), B === void 0 && (B = requireEndOfStream()), B(dt, { readable: lt, writable: yt }, function(It) {
          if (It) return St(It);
          mt = !0, St();
        });
        var $t = !1;
        return function(It) {
          if (!mt && !$t) return $t = !0, function(Ut) {
            return Ut.setHeader && typeof Ut.abort == "function";
          }(dt) ? dt.abort() : typeof dt.destroy == "function" ? dt.destroy() : void St(It || new W("pipe"));
        };
      }(ot, ft, at > 0, function(dt) {
        ce || (ce = dt), dt && ke.forEach(J), ft || (ke.forEach(J), pe(ce));
      });
    });
    return ne.reduce(re);
  }, pipeline_1;
}
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(B, L) {
    (L = B.exports = require_stream_readable$1()).Stream = L, L.Readable = L, L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var B = safeBufferExports.Buffer, L = requireReadableBrowser$1().Transform;
  function K(W) {
    L.call(this), this._block = B.allocUnsafe(W), this._blockSize = W, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return requireInherits_browser()(K, L), K.prototype._transform = function(W, V, J) {
    var re = null;
    try {
      this.update(W, V);
    } catch (ie) {
      re = ie;
    }
    J(re);
  }, K.prototype._flush = function(W) {
    var V = null;
    try {
      this.push(this.digest());
    } catch (J) {
      V = J;
    }
    W(V);
  }, K.prototype.update = function(W, V) {
    if (function(ce) {
      if (!B.isBuffer(ce) && typeof ce != "string") throw new TypeError("Data must be a string or a buffer");
    }(W), this._finalized) throw new Error("Digest already called");
    B.isBuffer(W) || (W = B.from(W, V));
    for (var J = this._block, re = 0; this._blockOffset + W.length - re >= this._blockSize; ) {
      for (var ie = this._blockOffset; ie < this._blockSize; ) J[ie++] = W[re++];
      this._update(), this._blockOffset = 0;
    }
    for (; re < W.length; ) J[this._blockOffset++] = W[re++];
    for (var ne = 0, oe = 8 * W.length; oe > 0; ++ne) this._length[ne] += oe, (oe = this._length[ne] / 4294967296 | 0) > 0 && (this._length[ne] -= 4294967296 * oe);
    return this;
  }, K.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, K.prototype.digest = function(W) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var V = this._digest();
    W !== void 0 && (V = V.toString(W)), this._block.fill(0), this._blockOffset = 0;
    for (var J = 0; J < 4; ++J) this._length[J] = 0;
    return V;
  }, K.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = K;
}
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var B = requireInherits_browser(), L = requireHashBase(), K = safeBufferExports.Buffer, W = new Array(16);
  function V() {
    L.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  function J(ce, pe) {
    return ce << pe | ce >>> 32 - pe;
  }
  function re(ce, pe, ke, ot, at, ft, dt) {
    return J(ce + (pe & ke | ~pe & ot) + at + ft | 0, dt) + pe | 0;
  }
  function ie(ce, pe, ke, ot, at, ft, dt) {
    return J(ce + (pe & ot | ke & ~ot) + at + ft | 0, dt) + pe | 0;
  }
  function ne(ce, pe, ke, ot, at, ft, dt) {
    return J(ce + (pe ^ ke ^ ot) + at + ft | 0, dt) + pe | 0;
  }
  function oe(ce, pe, ke, ot, at, ft, dt) {
    return J(ce + (ke ^ (pe | ~ot)) + at + ft | 0, dt) + pe | 0;
  }
  return B(V, L), V.prototype._update = function() {
    for (var ce = W, pe = 0; pe < 16; ++pe) ce[pe] = this._block.readInt32LE(4 * pe);
    var ke = this._a, ot = this._b, at = this._c, ft = this._d;
    ke = re(ke, ot, at, ft, ce[0], 3614090360, 7), ft = re(ft, ke, ot, at, ce[1], 3905402710, 12), at = re(at, ft, ke, ot, ce[2], 606105819, 17), ot = re(ot, at, ft, ke, ce[3], 3250441966, 22), ke = re(ke, ot, at, ft, ce[4], 4118548399, 7), ft = re(ft, ke, ot, at, ce[5], 1200080426, 12), at = re(at, ft, ke, ot, ce[6], 2821735955, 17), ot = re(ot, at, ft, ke, ce[7], 4249261313, 22), ke = re(ke, ot, at, ft, ce[8], 1770035416, 7), ft = re(ft, ke, ot, at, ce[9], 2336552879, 12), at = re(at, ft, ke, ot, ce[10], 4294925233, 17), ot = re(ot, at, ft, ke, ce[11], 2304563134, 22), ke = re(ke, ot, at, ft, ce[12], 1804603682, 7), ft = re(ft, ke, ot, at, ce[13], 4254626195, 12), at = re(at, ft, ke, ot, ce[14], 2792965006, 17), ke = ie(ke, ot = re(ot, at, ft, ke, ce[15], 1236535329, 22), at, ft, ce[1], 4129170786, 5), ft = ie(ft, ke, ot, at, ce[6], 3225465664, 9), at = ie(at, ft, ke, ot, ce[11], 643717713, 14), ot = ie(ot, at, ft, ke, ce[0], 3921069994, 20), ke = ie(ke, ot, at, ft, ce[5], 3593408605, 5), ft = ie(ft, ke, ot, at, ce[10], 38016083, 9), at = ie(at, ft, ke, ot, ce[15], 3634488961, 14), ot = ie(ot, at, ft, ke, ce[4], 3889429448, 20), ke = ie(ke, ot, at, ft, ce[9], 568446438, 5), ft = ie(ft, ke, ot, at, ce[14], 3275163606, 9), at = ie(at, ft, ke, ot, ce[3], 4107603335, 14), ot = ie(ot, at, ft, ke, ce[8], 1163531501, 20), ke = ie(ke, ot, at, ft, ce[13], 2850285829, 5), ft = ie(ft, ke, ot, at, ce[2], 4243563512, 9), at = ie(at, ft, ke, ot, ce[7], 1735328473, 14), ke = ne(ke, ot = ie(ot, at, ft, ke, ce[12], 2368359562, 20), at, ft, ce[5], 4294588738, 4), ft = ne(ft, ke, ot, at, ce[8], 2272392833, 11), at = ne(at, ft, ke, ot, ce[11], 1839030562, 16), ot = ne(ot, at, ft, ke, ce[14], 4259657740, 23), ke = ne(ke, ot, at, ft, ce[1], 2763975236, 4), ft = ne(ft, ke, ot, at, ce[4], 1272893353, 11), at = ne(at, ft, ke, ot, ce[7], 4139469664, 16), ot = ne(ot, at, ft, ke, ce[10], 3200236656, 23), ke = ne(ke, ot, at, ft, ce[13], 681279174, 4), ft = ne(ft, ke, ot, at, ce[0], 3936430074, 11), at = ne(at, ft, ke, ot, ce[3], 3572445317, 16), ot = ne(ot, at, ft, ke, ce[6], 76029189, 23), ke = ne(ke, ot, at, ft, ce[9], 3654602809, 4), ft = ne(ft, ke, ot, at, ce[12], 3873151461, 11), at = ne(at, ft, ke, ot, ce[15], 530742520, 16), ke = oe(ke, ot = ne(ot, at, ft, ke, ce[2], 3299628645, 23), at, ft, ce[0], 4096336452, 6), ft = oe(ft, ke, ot, at, ce[7], 1126891415, 10), at = oe(at, ft, ke, ot, ce[14], 2878612391, 15), ot = oe(ot, at, ft, ke, ce[5], 4237533241, 21), ke = oe(ke, ot, at, ft, ce[12], 1700485571, 6), ft = oe(ft, ke, ot, at, ce[3], 2399980690, 10), at = oe(at, ft, ke, ot, ce[10], 4293915773, 15), ot = oe(ot, at, ft, ke, ce[1], 2240044497, 21), ke = oe(ke, ot, at, ft, ce[8], 1873313359, 6), ft = oe(ft, ke, ot, at, ce[15], 4264355552, 10), at = oe(at, ft, ke, ot, ce[6], 2734768916, 15), ot = oe(ot, at, ft, ke, ce[13], 1309151649, 21), ke = oe(ke, ot, at, ft, ce[4], 4149444226, 6), ft = oe(ft, ke, ot, at, ce[11], 3174756917, 10), at = oe(at, ft, ke, ot, ce[2], 718787259, 15), ot = oe(ot, at, ft, ke, ce[9], 3951481745, 21), this._a = this._a + ke | 0, this._b = this._b + ot | 0, this._c = this._c + at | 0, this._d = this._d + ft | 0;
  }, V.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var ce = K.allocUnsafe(16);
    return ce.writeInt32LE(this._a, 0), ce.writeInt32LE(this._b, 4), ce.writeInt32LE(this._c, 8), ce.writeInt32LE(this._d, 12), ce;
  }, md5_js = V;
}
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var B = require$$1$2.Buffer, L = requireInherits_browser(), K = requireHashBase(), W = new Array(16), V = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], J = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], re = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], ie = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], ne = [0, 1518500249, 1859775393, 2400959708, 2840853838], oe = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function ce() {
    K.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  function pe(lt, yt) {
    return lt << yt | lt >>> 32 - yt;
  }
  function ke(lt, yt, St, mt, $t, It, Ut, ut) {
    return pe(lt + (yt ^ St ^ mt) + It + Ut | 0, ut) + $t | 0;
  }
  function ot(lt, yt, St, mt, $t, It, Ut, ut) {
    return pe(lt + (yt & St | ~yt & mt) + It + Ut | 0, ut) + $t | 0;
  }
  function at(lt, yt, St, mt, $t, It, Ut, ut) {
    return pe(lt + ((yt | ~St) ^ mt) + It + Ut | 0, ut) + $t | 0;
  }
  function ft(lt, yt, St, mt, $t, It, Ut, ut) {
    return pe(lt + (yt & mt | St & ~mt) + It + Ut | 0, ut) + $t | 0;
  }
  function dt(lt, yt, St, mt, $t, It, Ut, ut) {
    return pe(lt + (yt ^ (St | ~mt)) + It + Ut | 0, ut) + $t | 0;
  }
  return L(ce, K), ce.prototype._update = function() {
    for (var lt = W, yt = 0; yt < 16; ++yt) lt[yt] = this._block.readInt32LE(4 * yt);
    for (var St = 0 | this._a, mt = 0 | this._b, $t = 0 | this._c, It = 0 | this._d, Ut = 0 | this._e, ut = 0 | this._a, ht = 0 | this._b, Ce = 0 | this._c, nt = 0 | this._d, rt = 0 | this._e, it = 0; it < 80; it += 1) {
      var st, Oe;
      it < 16 ? (st = ke(St, mt, $t, It, Ut, lt[V[it]], ne[0], re[it]), Oe = dt(ut, ht, Ce, nt, rt, lt[J[it]], oe[0], ie[it])) : it < 32 ? (st = ot(St, mt, $t, It, Ut, lt[V[it]], ne[1], re[it]), Oe = ft(ut, ht, Ce, nt, rt, lt[J[it]], oe[1], ie[it])) : it < 48 ? (st = at(St, mt, $t, It, Ut, lt[V[it]], ne[2], re[it]), Oe = at(ut, ht, Ce, nt, rt, lt[J[it]], oe[2], ie[it])) : it < 64 ? (st = ft(St, mt, $t, It, Ut, lt[V[it]], ne[3], re[it]), Oe = ot(ut, ht, Ce, nt, rt, lt[J[it]], oe[3], ie[it])) : (st = dt(St, mt, $t, It, Ut, lt[V[it]], ne[4], re[it]), Oe = ke(ut, ht, Ce, nt, rt, lt[J[it]], oe[4], ie[it])), St = Ut, Ut = It, It = pe($t, 10), $t = mt, mt = st, ut = rt, rt = nt, nt = pe(Ce, 10), Ce = ht, ht = Oe;
    }
    var ct = this._b + $t + nt | 0;
    this._b = this._c + It + rt | 0, this._c = this._d + Ut + ut | 0, this._d = this._e + St + ht | 0, this._e = this._a + mt + Ce | 0, this._a = ct;
  }, ce.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var lt = B.alloc ? B.alloc(20) : new B(20);
    return lt.writeInt32LE(this._a, 0), lt.writeInt32LE(this._b, 4), lt.writeInt32LE(this._c, 8), lt.writeInt32LE(this._d, 12), lt.writeInt32LE(this._e, 16), lt;
  }, ripemd160 = ce;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1, sha$1, hasRequiredSha$1, sha1, hasRequiredSha1, sha256$3, hasRequiredSha256, sha224$1, hasRequiredSha224, sha512$1, hasRequiredSha512, sha384$1, hasRequiredSha384, hasRequiredSha_js, streamBrowserify, hasRequiredStreamBrowserify, cipherBase, hasRequiredCipherBase, browser$a, hasRequiredBrowser$9;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var B = safeBufferExports.Buffer;
  function L(K, W) {
    this._block = B.alloc(K), this._finalSize = W, this._blockSize = K, this._len = 0;
  }
  return L.prototype.update = function(K, W) {
    typeof K == "string" && (W = W || "utf8", K = B.from(K, W));
    for (var V = this._block, J = this._blockSize, re = K.length, ie = this._len, ne = 0; ne < re; ) {
      for (var oe = ie % J, ce = Math.min(re - ne, J - oe), pe = 0; pe < ce; pe++) V[oe + pe] = K[ne + pe];
      ne += ce, (ie += ce) % J == 0 && this._update(V);
    }
    return this._len += re, this;
  }, L.prototype.digest = function(K) {
    var W = this._len % this._blockSize;
    this._block[W] = 128, this._block.fill(0, W + 1), W >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var V = 8 * this._len;
    if (V <= 4294967295) this._block.writeUInt32BE(V, this._blockSize - 4);
    else {
      var J = (4294967295 & V) >>> 0, re = (V - J) / 4294967296;
      this._block.writeUInt32BE(re, this._blockSize - 8), this._block.writeUInt32BE(J, this._blockSize - 4);
    }
    this._update(this._block);
    var ie = this._hash();
    return K ? ie.toString(K) : ie;
  }, L.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = L;
}
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), K = safeBufferExports.Buffer, W = [1518500249, 1859775393, -1894007588, -899497514], V = new Array(80);
  function J() {
    this.init(), this._w = V, L.call(this, 64, 56);
  }
  function re(ne) {
    return ne << 30 | ne >>> 2;
  }
  function ie(ne, oe, ce, pe) {
    return ne === 0 ? oe & ce | ~oe & pe : ne === 2 ? oe & ce | oe & pe | ce & pe : oe ^ ce ^ pe;
  }
  return B(J, L), J.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  }, J.prototype._update = function(ne) {
    for (var oe, ce = this._w, pe = 0 | this._a, ke = 0 | this._b, ot = 0 | this._c, at = 0 | this._d, ft = 0 | this._e, dt = 0; dt < 16; ++dt) ce[dt] = ne.readInt32BE(4 * dt);
    for (; dt < 80; ++dt) ce[dt] = ce[dt - 3] ^ ce[dt - 8] ^ ce[dt - 14] ^ ce[dt - 16];
    for (var lt = 0; lt < 80; ++lt) {
      var yt = ~~(lt / 20), St = 0 | ((oe = pe) << 5 | oe >>> 27) + ie(yt, ke, ot, at) + ft + ce[lt] + W[yt];
      ft = at, at = ot, ot = re(ke), ke = pe, pe = St;
    }
    this._a = pe + this._a | 0, this._b = ke + this._b | 0, this._c = ot + this._c | 0, this._d = at + this._d | 0, this._e = ft + this._e | 0;
  }, J.prototype._hash = function() {
    var ne = K.allocUnsafe(20);
    return ne.writeInt32BE(0 | this._a, 0), ne.writeInt32BE(0 | this._b, 4), ne.writeInt32BE(0 | this._c, 8), ne.writeInt32BE(0 | this._d, 12), ne.writeInt32BE(0 | this._e, 16), ne;
  }, sha$1 = J;
}
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), K = safeBufferExports.Buffer, W = [1518500249, 1859775393, -1894007588, -899497514], V = new Array(80);
  function J() {
    this.init(), this._w = V, L.call(this, 64, 56);
  }
  function re(oe) {
    return oe << 5 | oe >>> 27;
  }
  function ie(oe) {
    return oe << 30 | oe >>> 2;
  }
  function ne(oe, ce, pe, ke) {
    return oe === 0 ? ce & pe | ~ce & ke : oe === 2 ? ce & pe | ce & ke | pe & ke : ce ^ pe ^ ke;
  }
  return B(J, L), J.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  }, J.prototype._update = function(oe) {
    for (var ce, pe = this._w, ke = 0 | this._a, ot = 0 | this._b, at = 0 | this._c, ft = 0 | this._d, dt = 0 | this._e, lt = 0; lt < 16; ++lt) pe[lt] = oe.readInt32BE(4 * lt);
    for (; lt < 80; ++lt) pe[lt] = (ce = pe[lt - 3] ^ pe[lt - 8] ^ pe[lt - 14] ^ pe[lt - 16]) << 1 | ce >>> 31;
    for (var yt = 0; yt < 80; ++yt) {
      var St = ~~(yt / 20), mt = re(ke) + ne(St, ot, at, ft) + dt + pe[yt] + W[St] | 0;
      dt = ft, ft = at, at = ie(ot), ot = ke, ke = mt;
    }
    this._a = ke + this._a | 0, this._b = ot + this._b | 0, this._c = at + this._c | 0, this._d = ft + this._d | 0, this._e = dt + this._e | 0;
  }, J.prototype._hash = function() {
    var oe = K.allocUnsafe(20);
    return oe.writeInt32BE(0 | this._a, 0), oe.writeInt32BE(0 | this._b, 4), oe.writeInt32BE(0 | this._c, 8), oe.writeInt32BE(0 | this._d, 12), oe.writeInt32BE(0 | this._e, 16), oe;
  }, sha1 = J;
}
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), K = safeBufferExports.Buffer, W = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], V = new Array(64);
  function J() {
    this.init(), this._w = V, L.call(this, 64, 56);
  }
  function re(ke, ot, at) {
    return at ^ ke & (ot ^ at);
  }
  function ie(ke, ot, at) {
    return ke & ot | at & (ke | ot);
  }
  function ne(ke) {
    return (ke >>> 2 | ke << 30) ^ (ke >>> 13 | ke << 19) ^ (ke >>> 22 | ke << 10);
  }
  function oe(ke) {
    return (ke >>> 6 | ke << 26) ^ (ke >>> 11 | ke << 21) ^ (ke >>> 25 | ke << 7);
  }
  function ce(ke) {
    return (ke >>> 7 | ke << 25) ^ (ke >>> 18 | ke << 14) ^ ke >>> 3;
  }
  function pe(ke) {
    return (ke >>> 17 | ke << 15) ^ (ke >>> 19 | ke << 13) ^ ke >>> 10;
  }
  return B(J, L), J.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  }, J.prototype._update = function(ke) {
    for (var ot = this._w, at = 0 | this._a, ft = 0 | this._b, dt = 0 | this._c, lt = 0 | this._d, yt = 0 | this._e, St = 0 | this._f, mt = 0 | this._g, $t = 0 | this._h, It = 0; It < 16; ++It) ot[It] = ke.readInt32BE(4 * It);
    for (; It < 64; ++It) ot[It] = pe(ot[It - 2]) + ot[It - 7] + ce(ot[It - 15]) + ot[It - 16] | 0;
    for (var Ut = 0; Ut < 64; ++Ut) {
      var ut = $t + oe(yt) + re(yt, St, mt) + W[Ut] + ot[Ut] | 0, ht = ne(at) + ie(at, ft, dt) | 0;
      $t = mt, mt = St, St = yt, yt = lt + ut | 0, lt = dt, dt = ft, ft = at, at = ut + ht | 0;
    }
    this._a = at + this._a | 0, this._b = ft + this._b | 0, this._c = dt + this._c | 0, this._d = lt + this._d | 0, this._e = yt + this._e | 0, this._f = St + this._f | 0, this._g = mt + this._g | 0, this._h = $t + this._h | 0;
  }, J.prototype._hash = function() {
    var ke = K.allocUnsafe(32);
    return ke.writeInt32BE(this._a, 0), ke.writeInt32BE(this._b, 4), ke.writeInt32BE(this._c, 8), ke.writeInt32BE(this._d, 12), ke.writeInt32BE(this._e, 16), ke.writeInt32BE(this._f, 20), ke.writeInt32BE(this._g, 24), ke.writeInt32BE(this._h, 28), ke;
  }, sha256$3 = J;
}
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var B = requireInherits_browser(), L = requireSha256(), K = requireHash$1(), W = safeBufferExports.Buffer, V = new Array(64);
  function J() {
    this.init(), this._w = V, K.call(this, 64, 56);
  }
  return B(J, L), J.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, J.prototype._hash = function() {
    var re = W.allocUnsafe(28);
    return re.writeInt32BE(this._a, 0), re.writeInt32BE(this._b, 4), re.writeInt32BE(this._c, 8), re.writeInt32BE(this._d, 12), re.writeInt32BE(this._e, 16), re.writeInt32BE(this._f, 20), re.writeInt32BE(this._g, 24), re;
  }, sha224$1 = J;
}
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var B = requireInherits_browser(), L = requireHash$1(), K = safeBufferExports.Buffer, W = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], V = new Array(160);
  function J() {
    this.init(), this._w = V, L.call(this, 128, 112);
  }
  function re(ft, dt, lt) {
    return lt ^ ft & (dt ^ lt);
  }
  function ie(ft, dt, lt) {
    return ft & dt | lt & (ft | dt);
  }
  function ne(ft, dt) {
    return (ft >>> 28 | dt << 4) ^ (dt >>> 2 | ft << 30) ^ (dt >>> 7 | ft << 25);
  }
  function oe(ft, dt) {
    return (ft >>> 14 | dt << 18) ^ (ft >>> 18 | dt << 14) ^ (dt >>> 9 | ft << 23);
  }
  function ce(ft, dt) {
    return (ft >>> 1 | dt << 31) ^ (ft >>> 8 | dt << 24) ^ ft >>> 7;
  }
  function pe(ft, dt) {
    return (ft >>> 1 | dt << 31) ^ (ft >>> 8 | dt << 24) ^ (ft >>> 7 | dt << 25);
  }
  function ke(ft, dt) {
    return (ft >>> 19 | dt << 13) ^ (dt >>> 29 | ft << 3) ^ ft >>> 6;
  }
  function ot(ft, dt) {
    return (ft >>> 19 | dt << 13) ^ (dt >>> 29 | ft << 3) ^ (ft >>> 6 | dt << 26);
  }
  function at(ft, dt) {
    return ft >>> 0 < dt >>> 0 ? 1 : 0;
  }
  return B(J, L), J.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  }, J.prototype._update = function(ft) {
    for (var dt = this._w, lt = 0 | this._ah, yt = 0 | this._bh, St = 0 | this._ch, mt = 0 | this._dh, $t = 0 | this._eh, It = 0 | this._fh, Ut = 0 | this._gh, ut = 0 | this._hh, ht = 0 | this._al, Ce = 0 | this._bl, nt = 0 | this._cl, rt = 0 | this._dl, it = 0 | this._el, st = 0 | this._fl, Oe = 0 | this._gl, ct = 0 | this._hl, pt = 0; pt < 32; pt += 2) dt[pt] = ft.readInt32BE(4 * pt), dt[pt + 1] = ft.readInt32BE(4 * pt + 4);
    for (; pt < 160; pt += 2) {
      var gt = dt[pt - 30], vt = dt[pt - 30 + 1], Bt = ce(gt, vt), kt = pe(vt, gt), wt = ke(gt = dt[pt - 4], vt = dt[pt - 4 + 1]), Et = ot(vt, gt), Rt = dt[pt - 14], Mt = dt[pt - 14 + 1], Ht = dt[pt - 32], Kt = dt[pt - 32 + 1], jt = kt + Mt | 0, Wt = Bt + Rt + at(jt, kt) | 0;
      Wt = (Wt = Wt + wt + at(jt = jt + Et | 0, Et) | 0) + Ht + at(jt = jt + Kt | 0, Kt) | 0, dt[pt] = Wt, dt[pt + 1] = jt;
    }
    for (var Yt = 0; Yt < 160; Yt += 2) {
      Wt = dt[Yt], jt = dt[Yt + 1];
      var Xt = ie(lt, yt, St), ir = ie(ht, Ce, nt), ur = ne(lt, ht), Qt = ne(ht, lt), hr = oe($t, it), pr = oe(it, $t), cr = W[Yt], vr = W[Yt + 1], bt = re($t, It, Ut), At = re(it, st, Oe), Tt = ct + pr | 0, xt = ut + hr + at(Tt, ct) | 0;
      xt = (xt = (xt = xt + bt + at(Tt = Tt + At | 0, At) | 0) + cr + at(Tt = Tt + vr | 0, vr) | 0) + Wt + at(Tt = Tt + jt | 0, jt) | 0;
      var Nt = Qt + ir | 0, Ft = ur + Xt + at(Nt, Qt) | 0;
      ut = Ut, ct = Oe, Ut = It, Oe = st, It = $t, st = it, $t = mt + xt + at(it = rt + Tt | 0, rt) | 0, mt = St, rt = nt, St = yt, nt = Ce, yt = lt, Ce = ht, lt = xt + Ft + at(ht = Tt + Nt | 0, Tt) | 0;
    }
    this._al = this._al + ht | 0, this._bl = this._bl + Ce | 0, this._cl = this._cl + nt | 0, this._dl = this._dl + rt | 0, this._el = this._el + it | 0, this._fl = this._fl + st | 0, this._gl = this._gl + Oe | 0, this._hl = this._hl + ct | 0, this._ah = this._ah + lt + at(this._al, ht) | 0, this._bh = this._bh + yt + at(this._bl, Ce) | 0, this._ch = this._ch + St + at(this._cl, nt) | 0, this._dh = this._dh + mt + at(this._dl, rt) | 0, this._eh = this._eh + $t + at(this._el, it) | 0, this._fh = this._fh + It + at(this._fl, st) | 0, this._gh = this._gh + Ut + at(this._gl, Oe) | 0, this._hh = this._hh + ut + at(this._hl, ct) | 0;
  }, J.prototype._hash = function() {
    var ft = K.allocUnsafe(64);
    function dt(lt, yt, St) {
      ft.writeInt32BE(lt, St), ft.writeInt32BE(yt, St + 4);
    }
    return dt(this._ah, this._al, 0), dt(this._bh, this._bl, 8), dt(this._ch, this._cl, 16), dt(this._dh, this._dl, 24), dt(this._eh, this._el, 32), dt(this._fh, this._fl, 40), dt(this._gh, this._gl, 48), dt(this._hh, this._hl, 56), ft;
  }, sha512$1 = J;
}
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var B = requireInherits_browser(), L = requireSha512(), K = requireHash$1(), W = safeBufferExports.Buffer, V = new Array(160);
  function J() {
    this.init(), this._w = V, K.call(this, 128, 112);
  }
  return B(J, L), J.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, J.prototype._hash = function() {
    var re = W.allocUnsafe(48);
    function ie(ne, oe, ce) {
      re.writeInt32BE(ne, ce), re.writeInt32BE(oe, ce + 4);
    }
    return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), re;
  }, sha384$1 = J;
}
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var B = sha_js.exports = function(L) {
    L = L.toLowerCase();
    var K = B[L];
    if (!K) throw new Error(L + " is not supported (we accept pull requests)");
    return new K();
  };
  return B.sha = requireSha$1(), B.sha1 = requireSha1(), B.sha224 = requireSha224(), B.sha256 = requireSha256(), B.sha384 = requireSha384(), B.sha512 = requireSha512(), sha_js.exports;
}
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = L;
  var B = requireEvents().EventEmitter;
  function L() {
    B.call(this);
  }
  return requireInherits_browser()(L, B), L.Readable = require_stream_readable$1(), L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline(), L.Stream = L, L.prototype.pipe = function(K, W) {
    var V = this;
    function J(ke) {
      K.writable && K.write(ke) === !1 && V.pause && V.pause();
    }
    function re() {
      V.readable && V.resume && V.resume();
    }
    V.on("data", J), K.on("drain", re), K._isStdio || W && W.end === !1 || (V.on("end", ne), V.on("close", oe));
    var ie = !1;
    function ne() {
      ie || (ie = !0, K.end());
    }
    function oe() {
      ie || (ie = !0, typeof K.destroy == "function" && K.destroy());
    }
    function ce(ke) {
      if (pe(), B.listenerCount(this, "error") === 0) throw ke;
    }
    function pe() {
      V.removeListener("data", J), K.removeListener("drain", re), V.removeListener("end", ne), V.removeListener("close", oe), V.removeListener("error", ce), K.removeListener("error", ce), V.removeListener("end", pe), V.removeListener("close", pe), K.removeListener("close", pe);
    }
    return V.on("error", ce), K.on("error", ce), V.on("end", pe), V.on("close", pe), K.on("close", pe), K.emit("pipe", V), K;
  }, streamBrowserify;
}
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var B = safeBufferExports.Buffer, L = requireStreamBrowserify().Transform, K = requireString_decoder().StringDecoder;
  function W(V) {
    L.call(this), this.hashMode = typeof V == "string", this.hashMode ? this[V] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return requireInherits_browser()(W, L), W.prototype.update = function(V, J, re) {
    typeof V == "string" && (V = B.from(V, J));
    var ie = this._update(V);
    return this.hashMode ? this : (re && (ie = this._toString(ie, re)), ie);
  }, W.prototype.setAutoPadding = function() {
  }, W.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, W.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, W.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, W.prototype._transform = function(V, J, re) {
    var ie;
    try {
      this.hashMode ? this._update(V) : this.push(this._update(V));
    } catch (ne) {
      ie = ne;
    } finally {
      re(ie);
    }
  }, W.prototype._flush = function(V) {
    var J;
    try {
      this.push(this.__final());
    } catch (re) {
      J = re;
    }
    V(J);
  }, W.prototype._finalOrDigest = function(V) {
    var J = this.__final() || B.alloc(0);
    return V && (J = this._toString(J, V, !0)), J;
  }, W.prototype._toString = function(V, J, re) {
    if (this._decoder || (this._decoder = new K(J), this._encoding = J), this._encoding !== J) throw new Error("can't switch encodings");
    var ie = this._decoder.write(V);
    return re && (ie += this._decoder.end()), ie;
  }, cipherBase = W;
}
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$a;
  hasRequiredBrowser$9 = 1;
  var B = requireInherits_browser(), L = requireMd5_js(), K = requireRipemd160(), W = requireSha_js(), V = requireCipherBase();
  function J(re) {
    V.call(this, "digest"), this._hash = re;
  }
  return B(J, V), J.prototype._update = function(re) {
    this._hash.update(re);
  }, J.prototype._final = function() {
    return this._hash.digest();
  }, browser$a = function(re) {
    return (re = re.toLowerCase()) === "md5" ? new L() : re === "rmd160" || re === "ripemd160" ? new K() : new J(W(re));
  };
}
var _Buffer = safeBufferExports.Buffer;
function base$3(B) {
  if (B.length >= 255) throw new TypeError("Alphabet too long");
  for (var L = new Uint8Array(256), K = 0; K < L.length; K++) L[K] = 255;
  for (var W = 0; W < B.length; W++) {
    var V = B.charAt(W), J = V.charCodeAt(0);
    if (L[J] !== 255) throw new TypeError(V + " is ambiguous");
    L[J] = W;
  }
  var re = B.length, ie = B.charAt(0), ne = Math.log(re) / Math.log(256), oe = Math.log(256) / Math.log(re);
  function ce(pe) {
    if (typeof pe != "string") throw new TypeError("Expected String");
    if (pe.length === 0) return _Buffer.alloc(0);
    for (var ke = 0, ot = 0, at = 0; pe[ke] === ie; ) ot++, ke++;
    for (var ft = (pe.length - ke) * ne + 1 >>> 0, dt = new Uint8Array(ft); ke < pe.length; ) {
      var lt = L[pe.charCodeAt(ke)];
      if (lt === 255) return;
      for (var yt = 0, St = ft - 1; (lt !== 0 || yt < at) && St !== -1; St--, yt++) lt += re * dt[St] >>> 0, dt[St] = lt % 256 >>> 0, lt = lt / 256 >>> 0;
      if (lt !== 0) throw new Error("Non-zero carry");
      at = yt, ke++;
    }
    for (var mt = ft - at; mt !== ft && dt[mt] === 0; ) mt++;
    var $t = _Buffer.allocUnsafe(ot + (ft - mt));
    $t.fill(0, 0, ot);
    for (var It = ot; mt !== ft; ) $t[It++] = dt[mt++];
    return $t;
  }
  return { encode: function(pe) {
    if ((Array.isArray(pe) || pe instanceof Uint8Array) && (pe = _Buffer.from(pe)), !_Buffer.isBuffer(pe)) throw new TypeError("Expected Buffer");
    if (pe.length === 0) return "";
    for (var ke = 0, ot = 0, at = 0, ft = pe.length; at !== ft && pe[at] === 0; ) at++, ke++;
    for (var dt = (ft - at) * oe + 1 >>> 0, lt = new Uint8Array(dt); at !== ft; ) {
      for (var yt = pe[at], St = 0, mt = dt - 1; (yt !== 0 || St < ot) && mt !== -1; mt--, St++) yt += 256 * lt[mt] >>> 0, lt[mt] = yt % re >>> 0, yt = yt / re >>> 0;
      if (yt !== 0) throw new Error("Non-zero carry");
      ot = St, at++;
    }
    for (var $t = dt - ot; $t !== dt && lt[$t] === 0; ) $t++;
    for (var It = ie.repeat(ke); $t < dt; ++$t) It += B.charAt(lt[$t]);
    return It;
  }, decodeUnsafe: ce, decode: function(pe) {
    var ke = ce(pe);
    if (ke) return ke;
    throw new Error("Non-base" + re + " character");
  } };
}
var src$1 = base$3, basex = src$1, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET), base58 = bs58, Buffer$1 = safeBufferExports.Buffer, base$2 = function(B) {
  function L(K) {
    var W = K.slice(0, -4), V = K.slice(-4), J = B(W);
    if (!(V[0] ^ J[0] | V[1] ^ J[1] | V[2] ^ J[2] | V[3] ^ J[3])) return W;
  }
  return { encode: function(K) {
    var W = B(K);
    return base58.encode(Buffer$1.concat([K, W], K.length + 4));
  }, decode: function(K) {
    var W = L(base58.decode(K));
    if (!W) throw new Error("Invalid checksum");
    return W;
  }, decodeUnsafe: function(K) {
    var W = base58.decodeUnsafe(K);
    if (W) return L(W);
  } };
}, createHash = requireBrowser$9(), bs58checkBase = base$2;
function sha256x2(B) {
  var L = createHash("sha256").update(B).digest();
  return createHash("sha256").update(L).digest();
}
var bs58check$2 = bs58checkBase(sha256x2), bs58check$1 = bs58check$2;
function decodeRaw(B, L) {
  if (L !== void 0 && B[0] !== L) throw new Error("Invalid network version");
  if (B.length === 33) return { version: B[0], privateKey: B.slice(1, 33), compressed: !1 };
  if (B.length !== 34) throw new Error("Invalid WIF length");
  if (B[33] !== 1) throw new Error("Invalid compression flag");
  return { version: B[0], privateKey: B.slice(1, 33), compressed: !0 };
}
function encodeRaw(B, L, K) {
  var W = new Buffer$3(K ? 34 : 33);
  return W.writeUInt8(B, 0), L.copy(W, 1), K && (W[33] = 1), W;
}
function decode$2(B, L) {
  return decodeRaw(bs58check$1.decode(B), L);
}
function encode$1(B, L, K) {
  return typeof B == "number" ? bs58check$1.encode(encodeRaw(B, L, K)) : bs58check$1.encode(encodeRaw(B.version, B.privateKey, B.compressed));
}
var wif$2 = { decode: decode$2, decodeRaw, encode: encode$1, encodeRaw };
Object.defineProperty(bip32, "__esModule", { value: !0 }), bip32.BIP32Factory = void 0;
const crypto$2 = crypto$3, testecc_1$1 = testecc$1, base_1 = lib$2, sha256_1$4 = sha256$5, typeforce = typeforce_1, wif$1 = wif$2, _bs58check = (0, base_1.base58check)(sha256_1$4.sha256), bs58check = { encode: (B) => _bs58check.encode(Uint8Array.from(B)), decode: (B) => Buffer$3.from(_bs58check.decode(B)) };
function BIP32Factory(B) {
  (0, testecc_1$1.testEcc)(B);
  const L = typeforce.BufferN(32), K = typeforce.compile({ wif: typeforce.UInt8, bip32: { public: typeforce.UInt32, private: typeforce.UInt32 } }), W = { messagePrefix: `Bitcoin Signed Message:
`, bech32: "bc", bip32: { public: 76067358, private: 76066276 }, pubKeyHash: 0, scriptHash: 5, wif: 128 }, V = 2147483648, J = Math.pow(2, 31) - 1;
  function re(ot) {
    return typeforce.String(ot) && ot.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
  }
  function ie(ot) {
    return typeforce.UInt32(ot) && ot <= J;
  }
  class ne {
    constructor(at, ft) {
      this.__D = at, this.__Q = ft, this.lowR = !1;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = Buffer$3.from(B.pointFromScalar(this.__D, !0))), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(at, ft) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (ft === void 0 && (ft = this.lowR), ft === !1) return Buffer$3.from(B.sign(at, this.privateKey));
      {
        let dt = Buffer$3.from(B.sign(at, this.privateKey));
        const lt = Buffer$3.alloc(32, 0);
        let yt = 0;
        for (; dt[0] > 127; ) yt++, lt.writeUIntLE(yt, 0, 6), dt = Buffer$3.from(B.sign(at, this.privateKey, lt));
        return dt;
      }
    }
    signSchnorr(at) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (!B.signSchnorr) throw new Error("signSchnorr not supported by ecc library");
      return Buffer$3.from(B.signSchnorr(at, this.privateKey));
    }
    verify(at, ft) {
      return B.verify(at, this.publicKey, ft);
    }
    verifySchnorr(at, ft) {
      if (!B.verifySchnorr) throw new Error("verifySchnorr not supported by ecc library");
      return B.verifySchnorr(at, this.publicKey.subarray(1, 33), ft);
    }
  }
  class oe extends ne {
    constructor(at, ft, dt, lt, yt = 0, St = 0, mt = 0) {
      super(at, ft), this.chainCode = dt, this.network = lt, this.__DEPTH = yt, this.__INDEX = St, this.__PARENT_FINGERPRINT = mt, typeforce(K, lt);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return crypto$2.hash160(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return ke(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const at = this.network, ft = this.isNeutered() ? at.bip32.public : at.bip32.private, dt = Buffer$3.allocUnsafe(78);
      return dt.writeUInt32BE(ft, 0), dt.writeUInt8(this.depth, 4), dt.writeUInt32BE(this.parentFingerprint, 5), dt.writeUInt32BE(this.index, 9), this.chainCode.copy(dt, 13), this.isNeutered() ? this.publicKey.copy(dt, 45) : (dt.writeUInt8(0, 45), this.privateKey.copy(dt, 46)), bs58check.encode(dt);
    }
    toWIF() {
      if (!this.privateKey) throw new TypeError("Missing private key");
      return wif$1.encode(this.network.wif, this.privateKey, !0);
    }
    derive(at) {
      typeforce(typeforce.UInt32, at);
      const ft = at >= V, dt = Buffer$3.allocUnsafe(37);
      if (ft) {
        if (this.isNeutered()) throw new TypeError("Missing private key for hardened child key");
        dt[0] = 0, this.privateKey.copy(dt, 1), dt.writeUInt32BE(at, 33);
      } else this.publicKey.copy(dt, 0), dt.writeUInt32BE(at, 33);
      const lt = crypto$2.hmacSHA512(this.chainCode, dt), yt = lt.slice(0, 32), St = lt.slice(32);
      if (!B.isPrivate(yt)) return this.derive(at + 1);
      let mt;
      if (this.isNeutered()) {
        const $t = Buffer$3.from(B.pointAddScalar(this.publicKey, yt, !0));
        if ($t === null) return this.derive(at + 1);
        mt = ke($t, St, this.network, this.depth + 1, at, this.fingerprint.readUInt32BE(0));
      } else {
        const $t = Buffer$3.from(B.privateAdd(this.privateKey, yt));
        if ($t == null) return this.derive(at + 1);
        mt = pe($t, St, this.network, this.depth + 1, at, this.fingerprint.readUInt32BE(0));
      }
      return mt;
    }
    deriveHardened(at) {
      return typeforce(ie, at), this.derive(at + V);
    }
    derivePath(at) {
      typeforce(re, at);
      let ft = at.split("/");
      if (ft[0] === "m") {
        if (this.parentFingerprint) throw new TypeError("Expected master, got child");
        ft = ft.slice(1);
      }
      return ft.reduce((dt, lt) => {
        let yt;
        return lt.slice(-1) === "'" ? (yt = parseInt(lt.slice(0, -1), 10), dt.deriveHardened(yt)) : (yt = parseInt(lt, 10), dt.derive(yt));
      }, this);
    }
    tweak(at) {
      return this.privateKey ? this.tweakFromPrivateKey(at) : this.tweakFromPublicKey(at);
    }
    tweakFromPublicKey(at) {
      const ft = (dt = this.publicKey).length === 32 ? dt : dt.slice(1, 33);
      var dt;
      if (!B.xOnlyPointAddTweak) throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const lt = B.xOnlyPointAddTweak(ft, at);
      if (!lt || lt.xOnlyPubkey === null) throw new Error("Cannot tweak public key!");
      const yt = Buffer$3.from([lt.parity === 0 ? 2 : 3]), St = Buffer$3.concat([yt, lt.xOnlyPubkey]);
      return new ne(void 0, St);
    }
    tweakFromPrivateKey(at) {
      const ft = this.publicKey[0] === 3 || this.publicKey[0] === 4 && !(1 & ~this.publicKey[64]), dt = (() => {
        if (ft) {
          if (B.privateNegate) return B.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        }
        return this.privateKey;
      })(), lt = B.privateAdd(dt, at);
      if (!lt) throw new Error("Invalid tweaked private key!");
      return new ne(Buffer$3.from(lt), void 0);
    }
  }
  function ce(ot, at, ft) {
    return pe(ot, at, ft);
  }
  function pe(ot, at, ft, dt, lt, yt) {
    if (typeforce({ privateKey: L, chainCode: L }, { privateKey: ot, chainCode: at }), ft = ft || W, !B.isPrivate(ot)) throw new TypeError("Private key not in range [1, n)");
    return new oe(ot, void 0, at, ft, dt, lt, yt);
  }
  function ke(ot, at, ft, dt, lt, yt) {
    if (typeforce({ publicKey: typeforce.BufferN(33), chainCode: L }, { publicKey: ot, chainCode: at }), ft = ft || W, !B.isPoint(ot)) throw new TypeError("Point is not on the curve");
    return new oe(void 0, ot, at, ft, dt, lt, yt);
  }
  return { fromSeed: function(ot, at) {
    if (typeforce(typeforce.Buffer, ot), ot.length < 16) throw new TypeError("Seed should be at least 128 bits");
    if (ot.length > 64) throw new TypeError("Seed should be at most 512 bits");
    at = at || W;
    const ft = crypto$2.hmacSHA512(Buffer$3.from("Bitcoin seed", "utf8"), ot);
    return ce(ft.slice(0, 32), ft.slice(32), at);
  }, fromBase58: function(ot, at) {
    const ft = bs58check.decode(ot);
    if (ft.length !== 78) throw new TypeError("Invalid buffer length");
    at = at || W;
    const dt = ft.readUInt32BE(0);
    if (dt !== at.bip32.private && dt !== at.bip32.public) throw new TypeError("Invalid network version");
    const lt = ft[4], yt = ft.readUInt32BE(5);
    if (lt === 0 && yt !== 0) throw new TypeError("Invalid parent fingerprint");
    const St = ft.readUInt32BE(9);
    if (lt === 0 && St !== 0) throw new TypeError("Invalid index");
    const mt = ft.slice(13, 45);
    let $t;
    if (dt === at.bip32.private) {
      if (ft.readUInt8(45) !== 0) throw new TypeError("Invalid private key");
      $t = pe(ft.slice(46, 78), mt, at, lt, St, yt);
    } else $t = ke(ft.slice(45, 78), mt, at, lt, St, yt);
    return $t;
  }, fromPublicKey: function(ot, at, ft) {
    return ke(ot, at, ft);
  }, fromPrivateKey: ce };
}
bip32.BIP32Factory = BIP32Factory, function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.BIP32Factory = B.default = void 0;
  var L = bip32;
  Object.defineProperty(B, "default", { enumerable: !0, get: function() {
    return L.BIP32Factory;
  } }), Object.defineProperty(B, "BIP32Factory", { enumerable: !0, get: function() {
    return L.BIP32Factory;
  } });
}(src$2);
var dist = {}, lib$1 = {}, cryptoBrowserify = {}, browser$9 = { exports: {} }, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer = safeBufferExports.Buffer, crypto$1 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
function randomBytes$1(B, L) {
  if (B > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var K = Buffer.allocUnsafe(B);
  if (B > 0) if (B > MAX_BYTES) for (var W = 0; W < B; W += MAX_BYTES) crypto$1.getRandomValues(K.slice(W, W + MAX_BYTES));
  else crypto$1.getRandomValues(K);
  return typeof L == "function" ? process$1.nextTick(function() {
    L(null, K);
  }) : K;
}
crypto$1 && crypto$1.getRandomValues ? browser$9.exports = randomBytes$1 : browser$9.exports = oldBrowser;
var browserExports = browser$9.exports, legacy, hasRequiredLegacy, md5, hasRequiredMd5, browser$8, hasRequiredBrowser$8;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var B = requireInherits_browser(), L = safeBufferExports.Buffer, K = requireCipherBase(), W = L.alloc(128), V = 64;
  function J(re, ie) {
    K.call(this, "digest"), typeof ie == "string" && (ie = L.from(ie)), this._alg = re, this._key = ie, ie.length > V ? ie = re(ie) : ie.length < V && (ie = L.concat([ie, W], V));
    for (var ne = this._ipad = L.allocUnsafe(V), oe = this._opad = L.allocUnsafe(V), ce = 0; ce < V; ce++) ne[ce] = 54 ^ ie[ce], oe[ce] = 92 ^ ie[ce];
    this._hash = [ne];
  }
  return B(J, K), J.prototype._update = function(re) {
    this._hash.push(re);
  }, J.prototype._final = function() {
    var re = this._alg(L.concat(this._hash));
    return this._alg(L.concat([this._opad, re]));
  }, legacy = J;
}
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var B = requireMd5_js();
  return md5 = function(L) {
    return new B().update(L).digest();
  }, md5;
}
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var B = requireInherits_browser(), L = requireLegacy(), K = requireCipherBase(), W = safeBufferExports.Buffer, V = requireMd5(), J = requireRipemd160(), re = requireSha_js(), ie = W.alloc(128);
  function ne(oe, ce) {
    K.call(this, "digest"), typeof ce == "string" && (ce = W.from(ce));
    var pe = oe === "sha512" || oe === "sha384" ? 128 : 64;
    this._alg = oe, this._key = ce, ce.length > pe ? ce = (oe === "rmd160" ? new J() : re(oe)).update(ce).digest() : ce.length < pe && (ce = W.concat([ce, ie], pe));
    for (var ke = this._ipad = W.allocUnsafe(pe), ot = this._opad = W.allocUnsafe(pe), at = 0; at < pe; at++) ke[at] = 54 ^ ce[at], ot[at] = 92 ^ ce[at];
    this._hash = oe === "rmd160" ? new J() : re(oe), this._hash.update(ke);
  }
  return B(ne, K), ne.prototype._update = function(oe) {
    this._hash.update(oe);
  }, ne.prototype._final = function() {
    var oe = this._hash.digest();
    return (this._alg === "rmd160" ? new J() : re(this._alg)).update(this._opad).update(oe).digest();
  }, browser$8 = function(oe, ce) {
    return (oe = oe.toLowerCase()) === "rmd160" || oe === "ripemd160" ? new ne("rmd160", ce) : oe === "md5" ? new L(V, ce) : new ne(oe, ce);
  }, browser$8;
}
const sha224WithRSAEncryption = { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption = { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption = { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption = { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, sha256$2 = { sign: "ecdsa", hash: "sha256", id: "" }, sha224 = { sign: "ecdsa", hash: "sha224", id: "" }, sha384 = { sign: "ecdsa", hash: "sha384", id: "" }, sha512 = { sign: "ecdsa", hash: "sha512", id: "" }, DSA = { sign: "dsa", hash: "sha1", id: "" }, ripemd160WithRSA = { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption = { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, require$$6 = { sha224WithRSAEncryption, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: sha256$2, sha224, sha384, sha512, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos ? algos : (hasRequiredAlgos = 1, algos = require$$6);
}
var browser$7 = {}, precondition, hasRequiredPrecondition, defaultEncoding_1, hasRequiredDefaultEncoding, toBuffer, hasRequiredToBuffer, syncBrowser, hasRequiredSyncBrowser, async, hasRequiredAsync, hasRequiredBrowser$7;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var B = Math.pow(2, 30) - 1;
  return precondition = function(L, K) {
    if (typeof L != "number") throw new TypeError("Iterations not a number");
    if (L < 0) throw new TypeError("Bad iterations");
    if (typeof K != "number") throw new TypeError("Key length not a number");
    if (K < 0 || K > B || K != K) throw new TypeError("Bad key length");
  };
}
function requireDefaultEncoding() {
  return hasRequiredDefaultEncoding ? defaultEncoding_1 : (hasRequiredDefaultEncoding = 1, B = commonjsGlobal.process && commonjsGlobal.process.browser ? "utf-8" : commonjsGlobal.process && commonjsGlobal.process.version ? parseInt(process$1.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary" : "utf-8", defaultEncoding_1 = B);
  var B;
}
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer;
  hasRequiredToBuffer = 1;
  var B = safeBufferExports.Buffer;
  return toBuffer = function(L, K, W) {
    if (B.isBuffer(L)) return L;
    if (typeof L == "string") return B.from(L, K);
    if (ArrayBuffer.isView(L)) return B.from(L.buffer);
    throw new TypeError(W + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var B = requireMd5(), L = requireRipemd160(), K = requireSha_js(), W = safeBufferExports.Buffer, V = requirePrecondition(), J = requireDefaultEncoding(), re = requireToBuffer(), ie = W.alloc(128), ne = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function oe(ce, pe, ke) {
    var ot = /* @__PURE__ */ function(St) {
      return St === "rmd160" || St === "ripemd160" ? function(mt) {
        return new L().update(mt).digest();
      } : St === "md5" ? B : function(mt) {
        return K(St).update(mt).digest();
      };
    }(ce), at = ce === "sha512" || ce === "sha384" ? 128 : 64;
    pe.length > at ? pe = ot(pe) : pe.length < at && (pe = W.concat([pe, ie], at));
    for (var ft = W.allocUnsafe(at + ne[ce]), dt = W.allocUnsafe(at + ne[ce]), lt = 0; lt < at; lt++) ft[lt] = 54 ^ pe[lt], dt[lt] = 92 ^ pe[lt];
    var yt = W.allocUnsafe(at + ke + 4);
    ft.copy(yt, 0, 0, at), this.ipad1 = yt, this.ipad2 = ft, this.opad = dt, this.alg = ce, this.blocksize = at, this.hash = ot, this.size = ne[ce];
  }
  return oe.prototype.run = function(ce, pe) {
    return ce.copy(pe, this.blocksize), this.hash(pe).copy(this.opad, this.blocksize), this.hash(this.opad);
  }, syncBrowser = function(ce, pe, ke, ot, at) {
    V(ke, ot);
    var ft = new oe(at = at || "sha1", ce = re(ce, J, "Password"), (pe = re(pe, J, "Salt")).length), dt = W.allocUnsafe(ot), lt = W.allocUnsafe(pe.length + 4);
    pe.copy(lt, 0, 0, pe.length);
    for (var yt = 0, St = ne[at], mt = Math.ceil(ot / St), $t = 1; $t <= mt; $t++) {
      lt.writeUInt32BE($t, pe.length);
      for (var It = ft.run(lt, ft.ipad1), Ut = It, ut = 1; ut < ke; ut++) {
        Ut = ft.run(Ut, ft.ipad2);
        for (var ht = 0; ht < St; ht++) It[ht] ^= Ut[ht];
      }
      It.copy(dt, yt), yt += St;
    }
    return dt;
  }, syncBrowser;
}
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var B, L, K = safeBufferExports.Buffer, W = requirePrecondition(), V = requireDefaultEncoding(), J = requireSyncBrowser(), re = requireToBuffer(), ie = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ne = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, oe = [];
  function ce() {
    return L || (L = commonjsGlobal.process && commonjsGlobal.process.nextTick ? commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? commonjsGlobal.setImmediate : commonjsGlobal.setTimeout);
  }
  function pe(ke, ot, at, ft, dt) {
    return ie.importKey("raw", ke, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function(lt) {
      return ie.deriveBits({ name: "PBKDF2", salt: ot, iterations: at, hash: { name: dt } }, lt, ft << 3);
    }).then(function(lt) {
      return K.from(lt);
    });
  }
  return async = function(ke, ot, at, ft, dt, lt) {
    typeof dt == "function" && (lt = dt, dt = void 0);
    var yt = ne[(dt = dt || "sha1").toLowerCase()];
    if (yt && typeof commonjsGlobal.Promise == "function") {
      if (W(at, ft), ke = re(ke, V, "Password"), ot = re(ot, V, "Salt"), typeof lt != "function") throw new Error("No callback provided to pbkdf2");
      (function(St, mt) {
        St.then(function($t) {
          ce()(function() {
            mt(null, $t);
          });
        }, function($t) {
          ce()(function() {
            mt($t);
          });
        });
      })(function(St) {
        if (commonjsGlobal.process && !commonjsGlobal.process.browser || !ie || !ie.importKey || !ie.deriveBits) return Promise.resolve(!1);
        if (oe[St] !== void 0) return oe[St];
        var mt = pe(B = B || K.alloc(8), B, 10, 128, St).then(function() {
          return !0;
        }).catch(function() {
          return !1;
        });
        return oe[St] = mt, mt;
      }(yt).then(function(St) {
        return St ? pe(ke, ot, at, ft, yt) : J(ke, ot, at, ft, dt);
      }), lt);
    } else ce()(function() {
      var St;
      try {
        St = J(ke, ot, at, ft, dt);
      } catch (mt) {
        return lt(mt);
      }
      lt(null, St);
    });
  }, async;
}
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$3 = {}, hasRequiredUtils$3, minimalisticAssert, hasRequiredMinimalisticAssert, cipher, hasRequiredCipher, des, hasRequiredDes$1;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function(W, V) {
    return (W[0 + V] << 24 | W[1 + V] << 16 | W[2 + V] << 8 | W[3 + V]) >>> 0;
  }, utils$3.writeUInt32BE = function(W, V, J) {
    W[0 + J] = V >>> 24, W[1 + J] = V >>> 16 & 255, W[2 + J] = V >>> 8 & 255, W[3 + J] = 255 & V;
  }, utils$3.ip = function(W, V, J, re) {
    for (var ie = 0, ne = 0, oe = 6; oe >= 0; oe -= 2) {
      for (var ce = 0; ce <= 24; ce += 8) ie <<= 1, ie |= V >>> ce + oe & 1;
      for (ce = 0; ce <= 24; ce += 8) ie <<= 1, ie |= W >>> ce + oe & 1;
    }
    for (oe = 6; oe >= 0; oe -= 2) {
      for (ce = 1; ce <= 25; ce += 8) ne <<= 1, ne |= V >>> ce + oe & 1;
      for (ce = 1; ce <= 25; ce += 8) ne <<= 1, ne |= W >>> ce + oe & 1;
    }
    J[re + 0] = ie >>> 0, J[re + 1] = ne >>> 0;
  }, utils$3.rip = function(W, V, J, re) {
    for (var ie = 0, ne = 0, oe = 0; oe < 4; oe++) for (var ce = 24; ce >= 0; ce -= 8) ie <<= 1, ie |= V >>> ce + oe & 1, ie <<= 1, ie |= W >>> ce + oe & 1;
    for (oe = 4; oe < 8; oe++) for (ce = 24; ce >= 0; ce -= 8) ne <<= 1, ne |= V >>> ce + oe & 1, ne <<= 1, ne |= W >>> ce + oe & 1;
    J[re + 0] = ie >>> 0, J[re + 1] = ne >>> 0;
  }, utils$3.pc1 = function(W, V, J, re) {
    for (var ie = 0, ne = 0, oe = 7; oe >= 5; oe--) {
      for (var ce = 0; ce <= 24; ce += 8) ie <<= 1, ie |= V >> ce + oe & 1;
      for (ce = 0; ce <= 24; ce += 8) ie <<= 1, ie |= W >> ce + oe & 1;
    }
    for (ce = 0; ce <= 24; ce += 8) ie <<= 1, ie |= V >> ce + oe & 1;
    for (oe = 1; oe <= 3; oe++) {
      for (ce = 0; ce <= 24; ce += 8) ne <<= 1, ne |= V >> ce + oe & 1;
      for (ce = 0; ce <= 24; ce += 8) ne <<= 1, ne |= W >> ce + oe & 1;
    }
    for (ce = 0; ce <= 24; ce += 8) ne <<= 1, ne |= W >> ce + oe & 1;
    J[re + 0] = ie >>> 0, J[re + 1] = ne >>> 0;
  }, utils$3.r28shl = function(W, V) {
    return W << V & 268435455 | W >>> 28 - V;
  };
  var B = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  utils$3.pc2 = function(W, V, J, re) {
    for (var ie = 0, ne = 0, oe = B.length >>> 1, ce = 0; ce < oe; ce++) ie <<= 1, ie |= W >>> B[ce] & 1;
    for (ce = oe; ce < B.length; ce++) ne <<= 1, ne |= V >>> B[ce] & 1;
    J[re + 0] = ie >>> 0, J[re + 1] = ne >>> 0;
  }, utils$3.expand = function(W, V, J) {
    var re = 0, ie = 0;
    re = (1 & W) << 5 | W >>> 27;
    for (var ne = 23; ne >= 15; ne -= 4) re <<= 6, re |= W >>> ne & 63;
    for (ne = 11; ne >= 3; ne -= 4) ie |= W >>> ne & 63, ie <<= 6;
    ie |= (31 & W) << 1 | W >>> 31, V[J + 0] = re >>> 0, V[J + 1] = ie >>> 0;
  };
  var L = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  utils$3.substitute = function(W, V) {
    for (var J = 0, re = 0; re < 4; re++) J <<= 4, J |= L[64 * re + (W >>> 18 - 6 * re & 63)];
    for (re = 0; re < 4; re++) J <<= 4, J |= L[256 + 64 * re + (V >>> 18 - 6 * re & 63)];
    return J >>> 0;
  };
  var K = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  return utils$3.permute = function(W) {
    for (var V = 0, J = 0; J < K.length; J++) V <<= 1, V |= W >>> K[J] & 1;
    return V >>> 0;
  }, utils$3.padSplit = function(W, V, J) {
    for (var re = W.toString(2); re.length < V; ) re = "0" + re;
    for (var ie = [], ne = 0; ne < V; ne += J) ie.push(re.slice(ne, ne + J));
    return ie.join(" ");
  }, utils$3;
}
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  function B(L, K) {
    if (!L) throw new Error(K || "Assertion failed");
  }
  return hasRequiredMinimalisticAssert = 1, minimalisticAssert = B, B.equal = function(L, K, W) {
    if (L != K) throw new Error(W || "Assertion failed: " + L + " != " + K);
  }, minimalisticAssert;
}
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var B = requireMinimalisticAssert();
  function L(K) {
    this.options = K, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = K.padding !== !1;
  }
  return cipher = L, L.prototype._init = function() {
  }, L.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, L.prototype._buffer = function(K, W) {
    for (var V = Math.min(this.buffer.length - this.bufferOff, K.length - W), J = 0; J < V; J++) this.buffer[this.bufferOff + J] = K[W + J];
    return this.bufferOff += V, V;
  }, L.prototype._flushBuffer = function(K, W) {
    return this._update(this.buffer, 0, K, W), this.bufferOff = 0, this.blockSize;
  }, L.prototype._updateEncrypt = function(K) {
    var W = 0, V = 0, J = (this.bufferOff + K.length) / this.blockSize | 0, re = new Array(J * this.blockSize);
    this.bufferOff !== 0 && (W += this._buffer(K, W), this.bufferOff === this.buffer.length && (V += this._flushBuffer(re, V)));
    for (var ie = K.length - (K.length - W) % this.blockSize; W < ie; W += this.blockSize) this._update(K, W, re, V), V += this.blockSize;
    for (; W < K.length; W++, this.bufferOff++) this.buffer[this.bufferOff] = K[W];
    return re;
  }, L.prototype._updateDecrypt = function(K) {
    for (var W = 0, V = 0, J = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, re = new Array(J * this.blockSize); J > 0; J--) W += this._buffer(K, W), V += this._flushBuffer(re, V);
    return W += this._buffer(K, W), re;
  }, L.prototype.final = function(K) {
    var W, V;
    return K && (W = this.update(K)), V = this.type === "encrypt" ? this._finalEncrypt() : this._finalDecrypt(), W ? W.concat(V) : V;
  }, L.prototype._pad = function(K, W) {
    if (W === 0) return !1;
    for (; W < K.length; ) K[W++] = 0;
    return !0;
  }, L.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff)) return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, L.prototype._unpad = function(K) {
    return K;
  }, L.prototype._finalDecrypt = function() {
    B.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser(), K = requireUtils$3(), W = requireCipher();
  function V() {
    this.tmp = new Array(2), this.keys = null;
  }
  function J(ie) {
    W.call(this, ie);
    var ne = new V();
    this._desState = ne, this.deriveKeys(ne, ie.key);
  }
  L(J, W), des = J, J.create = function(ie) {
    return new J(ie);
  };
  var re = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  return J.prototype.deriveKeys = function(ie, ne) {
    ie.keys = new Array(32), B.equal(ne.length, this.blockSize, "Invalid key length");
    var oe = K.readUInt32BE(ne, 0), ce = K.readUInt32BE(ne, 4);
    K.pc1(oe, ce, ie.tmp, 0), oe = ie.tmp[0], ce = ie.tmp[1];
    for (var pe = 0; pe < ie.keys.length; pe += 2) {
      var ke = re[pe >>> 1];
      oe = K.r28shl(oe, ke), ce = K.r28shl(ce, ke), K.pc2(oe, ce, ie.keys, pe);
    }
  }, J.prototype._update = function(ie, ne, oe, ce) {
    var pe = this._desState, ke = K.readUInt32BE(ie, ne), ot = K.readUInt32BE(ie, ne + 4);
    K.ip(ke, ot, pe.tmp, 0), ke = pe.tmp[0], ot = pe.tmp[1], this.type === "encrypt" ? this._encrypt(pe, ke, ot, pe.tmp, 0) : this._decrypt(pe, ke, ot, pe.tmp, 0), ke = pe.tmp[0], ot = pe.tmp[1], K.writeUInt32BE(oe, ke, ce), K.writeUInt32BE(oe, ot, ce + 4);
  }, J.prototype._pad = function(ie, ne) {
    if (this.padding === !1) return !1;
    for (var oe = ie.length - ne, ce = ne; ce < ie.length; ce++) ie[ce] = oe;
    return !0;
  }, J.prototype._unpad = function(ie) {
    if (this.padding === !1) return ie;
    for (var ne = ie[ie.length - 1], oe = ie.length - ne; oe < ie.length; oe++) B.equal(ie[oe], ne);
    return ie.slice(0, ie.length - ne);
  }, J.prototype._encrypt = function(ie, ne, oe, ce, pe) {
    for (var ke = ne, ot = oe, at = 0; at < ie.keys.length; at += 2) {
      var ft = ie.keys[at], dt = ie.keys[at + 1];
      K.expand(ot, ie.tmp, 0), ft ^= ie.tmp[0], dt ^= ie.tmp[1];
      var lt = K.substitute(ft, dt), yt = ot;
      ot = (ke ^ K.permute(lt)) >>> 0, ke = yt;
    }
    K.rip(ot, ke, ce, pe);
  }, J.prototype._decrypt = function(ie, ne, oe, ce, pe) {
    for (var ke = oe, ot = ne, at = ie.keys.length - 2; at >= 0; at -= 2) {
      var ft = ie.keys[at], dt = ie.keys[at + 1];
      K.expand(ke, ie.tmp, 0), ft ^= ie.tmp[0], dt ^= ie.tmp[1];
      var lt = K.substitute(ft, dt), yt = ke;
      ke = (ot ^ K.permute(lt)) >>> 0, ot = yt;
    }
    K.rip(ke, ot, ce, pe);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1, ede, hasRequiredEde, hasRequiredDes, browserifyDes, hasRequiredBrowserifyDes;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser(), K = {};
  function W(V) {
    B.equal(V.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var J = 0; J < this.iv.length; J++) this.iv[J] = V[J];
  }
  return cbc$1.instantiate = function(V) {
    function J(oe) {
      V.call(this, oe), this._cbcInit();
    }
    L(J, V);
    for (var re = Object.keys(K), ie = 0; ie < re.length; ie++) {
      var ne = re[ie];
      J.prototype[ne] = K[ne];
    }
    return J.create = function(oe) {
      return new J(oe);
    }, J;
  }, K._cbcInit = function() {
    var V = new W(this.options.iv);
    this._cbcState = V;
  }, K._update = function(V, J, re, ie) {
    var ne = this._cbcState, oe = this.constructor.super_.prototype, ce = ne.iv;
    if (this.type === "encrypt") {
      for (var pe = 0; pe < this.blockSize; pe++) ce[pe] ^= V[J + pe];
      for (oe._update.call(this, ce, 0, re, ie), pe = 0; pe < this.blockSize; pe++) ce[pe] = re[ie + pe];
    } else {
      for (oe._update.call(this, V, J, re, ie), pe = 0; pe < this.blockSize; pe++) re[ie + pe] ^= ce[pe];
      for (pe = 0; pe < this.blockSize; pe++) ce[pe] = V[J + pe];
    }
  }, cbc$1;
}
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser(), K = requireCipher(), W = requireDes$1();
  function V(re, ie) {
    B.equal(ie.length, 24, "Invalid key length");
    var ne = ie.slice(0, 8), oe = ie.slice(8, 16), ce = ie.slice(16, 24);
    this.ciphers = re === "encrypt" ? [W.create({ type: "encrypt", key: ne }), W.create({ type: "decrypt", key: oe }), W.create({ type: "encrypt", key: ce })] : [W.create({ type: "decrypt", key: ce }), W.create({ type: "encrypt", key: oe }), W.create({ type: "decrypt", key: ne })];
  }
  function J(re) {
    K.call(this, re);
    var ie = new V(this.type, this.options.key);
    this._edeState = ie;
  }
  return L(J, K), ede = J, J.create = function(re) {
    return new J(re);
  }, J.prototype._update = function(re, ie, ne, oe) {
    var ce = this._edeState;
    ce.ciphers[0]._update(re, ie, ne, oe), ce.ciphers[1]._update(ne, oe, ne, oe), ce.ciphers[2]._update(ne, oe, ne, oe);
  }, J.prototype._pad = W.prototype._pad, J.prototype._unpad = W.prototype._unpad, ede;
}
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var B = requireCipherBase(), L = requireDes(), K = requireInherits_browser(), W = safeBufferExports.Buffer, V = { "des-ede3-cbc": L.CBC.instantiate(L.EDE), "des-ede3": L.EDE, "des-ede-cbc": L.CBC.instantiate(L.EDE), "des-ede": L.EDE, "des-cbc": L.CBC.instantiate(L.DES), "des-ecb": L.DES };
  function J(re) {
    B.call(this);
    var ie, ne = re.mode.toLowerCase(), oe = V[ne];
    ie = re.decrypt ? "decrypt" : "encrypt";
    var ce = re.key;
    W.isBuffer(ce) || (ce = W.from(ce)), ne !== "des-ede" && ne !== "des-ede-cbc" || (ce = W.concat([ce, ce.slice(0, 8)]));
    var pe = re.iv;
    W.isBuffer(pe) || (pe = W.from(pe)), this._des = oe.create({ key: ce, iv: pe, type: ie });
  }
  return V.des = V["des-cbc"], V.des3 = V["des-ede3-cbc"], browserifyDes = J, K(J, B), J.prototype._update = function(re) {
    return W.from(this._des.update(re));
  }, J.prototype._final = function() {
    return W.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(B, L) {
    return B._cipher.encryptBlock(L);
  }, ecb.decrypt = function(B, L) {
    return B._cipher.decryptBlock(L);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor, hasRequiredCbc;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(B, L) {
    for (var K = Math.min(B.length, L.length), W = new Buffer$3(K), V = 0; V < K; ++V) W[V] = B[V] ^ L[V];
    return W;
  }), bufferXor;
}
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var B = requireBufferXor();
  return cbc.encrypt = function(L, K) {
    var W = B(K, L._prev);
    return L._prev = L._cipher.encryptBlock(W), L._prev;
  }, cbc.decrypt = function(L, K) {
    var W = L._prev;
    L._prev = K;
    var V = L._cipher.decryptBlock(K);
    return B(V, W);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var B = safeBufferExports.Buffer, L = requireBufferXor();
  function K(W, V, J) {
    var re = V.length, ie = L(V, W._cache);
    return W._cache = W._cache.slice(re), W._prev = B.concat([W._prev, J ? V : ie]), ie;
  }
  return cfb.encrypt = function(W, V, J) {
    for (var re, ie = B.allocUnsafe(0); V.length; ) {
      if (W._cache.length === 0 && (W._cache = W._cipher.encryptBlock(W._prev), W._prev = B.allocUnsafe(0)), !(W._cache.length <= V.length)) {
        ie = B.concat([ie, K(W, V, J)]);
        break;
      }
      re = W._cache.length, ie = B.concat([ie, K(W, V.slice(0, re), J)]), V = V.slice(re);
    }
    return ie;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var B = safeBufferExports.Buffer;
  function L(K, W, V) {
    var J = K._cipher.encryptBlock(K._prev)[0] ^ W;
    return K._prev = B.concat([K._prev.slice(1), B.from([V ? W : J])]), J;
  }
  return cfb8.encrypt = function(K, W, V) {
    for (var J = W.length, re = B.allocUnsafe(J), ie = -1; ++ie < J; ) re[ie] = L(K, W[ie], V);
    return re;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var B = safeBufferExports.Buffer;
  function L(W, V, J) {
    for (var re, ie, ne = -1, oe = 0; ++ne < 8; ) re = V & 1 << 7 - ne ? 128 : 0, oe += (128 & (ie = W._cipher.encryptBlock(W._prev)[0] ^ re)) >> ne % 8, W._prev = K(W._prev, J ? re : ie);
    return oe;
  }
  function K(W, V) {
    var J = W.length, re = -1, ie = B.allocUnsafe(W.length);
    for (W = B.concat([W, B.from([V])]); ++re < J; ) ie[re] = W[re] << 1 | W[re + 1] >> 7;
    return ie;
  }
  return cfb1.encrypt = function(W, V, J) {
    for (var re = V.length, ie = B.allocUnsafe(re), ne = -1; ++ne < re; ) ie[ne] = L(W, V[ne], J);
    return ie;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var B = requireBufferXor();
  function L(K) {
    return K._prev = K._cipher.encryptBlock(K._prev), K._prev;
  }
  return ofb.encrypt = function(K, W) {
    for (; K._cache.length < W.length; ) K._cache = Buffer$3.concat([K._cache, L(K)]);
    var V = K._cache.slice(0, W.length);
    return K._cache = K._cache.slice(W.length), B(W, V);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32, hasRequiredCtr;
function requireIncr32() {
  return hasRequiredIncr32 || (hasRequiredIncr32 = 1, incr32_1 = function(B) {
    for (var L, K = B.length; K--; ) {
      if ((L = B.readUInt8(K)) !== 255) {
        L++, B.writeUInt8(L, K);
        break;
      }
      B.writeUInt8(0, K);
    }
  }), incr32_1;
}
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var B = requireBufferXor(), L = safeBufferExports.Buffer, K = requireIncr32();
  function W(V) {
    var J = V._cipher.encryptBlockRaw(V._prev);
    return K(V._prev), J;
  }
  return ctr.encrypt = function(V, J) {
    var re = Math.ceil(J.length / 16), ie = V._cache.length;
    V._cache = L.concat([V._cache, L.allocUnsafe(16 * re)]);
    for (var ne = 0; ne < re; ne++) {
      var oe = W(V), ce = ie + 16 * ne;
      V._cache.writeUInt32BE(oe[0], ce + 0), V._cache.writeUInt32BE(oe[1], ce + 4), V._cache.writeUInt32BE(oe[2], ce + 8), V._cache.writeUInt32BE(oe[3], ce + 12);
    }
    var pe = V._cache.slice(0, J.length);
    return V._cache = V._cache.slice(J.length), B(J, pe);
  }, ctr;
}
const aes128 = { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192 = { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256 = { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, require$$2 = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128, aes192, aes256, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var B = { ECB: requireEcb(), CBC: requireCbc(), CFB: requireCfb(), CFB8: requireCfb8(), CFB1: requireCfb1(), OFB: requireOfb(), CTR: requireCtr(), GCM: requireCtr() }, L = require$$2;
  for (var K in L) L[K].module = B[L[K].mode];
  return modes_1 = L;
}
var aes = {}, hasRequiredAes, ghash, hasRequiredGhash, authCipher, hasRequiredAuthCipher, streamCipher, hasRequiredStreamCipher, evp_bytestokey, hasRequiredEvp_bytestokey, hasRequiredEncrypter;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var B = safeBufferExports.Buffer;
  function L(ie) {
    B.isBuffer(ie) || (ie = B.from(ie));
    for (var ne = ie.length / 4 | 0, oe = new Array(ne), ce = 0; ce < ne; ce++) oe[ce] = ie.readUInt32BE(4 * ce);
    return oe;
  }
  function K(ie) {
    for (; 0 < ie.length; ie++) ie[0] = 0;
  }
  function W(ie, ne, oe, ce, pe) {
    for (var ke, ot, at, ft, dt = oe[0], lt = oe[1], yt = oe[2], St = oe[3], mt = ie[0] ^ ne[0], $t = ie[1] ^ ne[1], It = ie[2] ^ ne[2], Ut = ie[3] ^ ne[3], ut = 4, ht = 1; ht < pe; ht++) ke = dt[mt >>> 24] ^ lt[$t >>> 16 & 255] ^ yt[It >>> 8 & 255] ^ St[255 & Ut] ^ ne[ut++], ot = dt[$t >>> 24] ^ lt[It >>> 16 & 255] ^ yt[Ut >>> 8 & 255] ^ St[255 & mt] ^ ne[ut++], at = dt[It >>> 24] ^ lt[Ut >>> 16 & 255] ^ yt[mt >>> 8 & 255] ^ St[255 & $t] ^ ne[ut++], ft = dt[Ut >>> 24] ^ lt[mt >>> 16 & 255] ^ yt[$t >>> 8 & 255] ^ St[255 & It] ^ ne[ut++], mt = ke, $t = ot, It = at, Ut = ft;
    return ke = (ce[mt >>> 24] << 24 | ce[$t >>> 16 & 255] << 16 | ce[It >>> 8 & 255] << 8 | ce[255 & Ut]) ^ ne[ut++], ot = (ce[$t >>> 24] << 24 | ce[It >>> 16 & 255] << 16 | ce[Ut >>> 8 & 255] << 8 | ce[255 & mt]) ^ ne[ut++], at = (ce[It >>> 24] << 24 | ce[Ut >>> 16 & 255] << 16 | ce[mt >>> 8 & 255] << 8 | ce[255 & $t]) ^ ne[ut++], ft = (ce[Ut >>> 24] << 24 | ce[mt >>> 16 & 255] << 16 | ce[$t >>> 8 & 255] << 8 | ce[255 & It]) ^ ne[ut++], [ke >>>= 0, ot >>>= 0, at >>>= 0, ft >>>= 0];
  }
  var V = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], J = function() {
    for (var ie = new Array(256), ne = 0; ne < 256; ne++) ie[ne] = ne < 128 ? ne << 1 : ne << 1 ^ 283;
    for (var oe = [], ce = [], pe = [[], [], [], []], ke = [[], [], [], []], ot = 0, at = 0, ft = 0; ft < 256; ++ft) {
      var dt = at ^ at << 1 ^ at << 2 ^ at << 3 ^ at << 4;
      dt = dt >>> 8 ^ 255 & dt ^ 99, oe[ot] = dt, ce[dt] = ot;
      var lt = ie[ot], yt = ie[lt], St = ie[yt], mt = 257 * ie[dt] ^ 16843008 * dt;
      pe[0][ot] = mt << 24 | mt >>> 8, pe[1][ot] = mt << 16 | mt >>> 16, pe[2][ot] = mt << 8 | mt >>> 24, pe[3][ot] = mt, mt = 16843009 * St ^ 65537 * yt ^ 257 * lt ^ 16843008 * ot, ke[0][dt] = mt << 24 | mt >>> 8, ke[1][dt] = mt << 16 | mt >>> 16, ke[2][dt] = mt << 8 | mt >>> 24, ke[3][dt] = mt, ot === 0 ? ot = at = 1 : (ot = lt ^ ie[ie[ie[St ^ lt]]], at ^= ie[ie[at]]);
    }
    return { SBOX: oe, INV_SBOX: ce, SUB_MIX: pe, INV_SUB_MIX: ke };
  }();
  function re(ie) {
    this._key = L(ie), this._reset();
  }
  return re.blockSize = 16, re.keySize = 32, re.prototype.blockSize = re.blockSize, re.prototype.keySize = re.keySize, re.prototype._reset = function() {
    for (var ie = this._key, ne = ie.length, oe = ne + 6, ce = 4 * (oe + 1), pe = [], ke = 0; ke < ne; ke++) pe[ke] = ie[ke];
    for (ke = ne; ke < ce; ke++) {
      var ot = pe[ke - 1];
      ke % ne == 0 ? (ot = ot << 8 | ot >>> 24, ot = J.SBOX[ot >>> 24] << 24 | J.SBOX[ot >>> 16 & 255] << 16 | J.SBOX[ot >>> 8 & 255] << 8 | J.SBOX[255 & ot], ot ^= V[ke / ne | 0] << 24) : ne > 6 && ke % ne == 4 && (ot = J.SBOX[ot >>> 24] << 24 | J.SBOX[ot >>> 16 & 255] << 16 | J.SBOX[ot >>> 8 & 255] << 8 | J.SBOX[255 & ot]), pe[ke] = pe[ke - ne] ^ ot;
    }
    for (var at = [], ft = 0; ft < ce; ft++) {
      var dt = ce - ft, lt = pe[dt - (ft % 4 ? 0 : 4)];
      at[ft] = ft < 4 || dt <= 4 ? lt : J.INV_SUB_MIX[0][J.SBOX[lt >>> 24]] ^ J.INV_SUB_MIX[1][J.SBOX[lt >>> 16 & 255]] ^ J.INV_SUB_MIX[2][J.SBOX[lt >>> 8 & 255]] ^ J.INV_SUB_MIX[3][J.SBOX[255 & lt]];
    }
    this._nRounds = oe, this._keySchedule = pe, this._invKeySchedule = at;
  }, re.prototype.encryptBlockRaw = function(ie) {
    return W(ie = L(ie), this._keySchedule, J.SUB_MIX, J.SBOX, this._nRounds);
  }, re.prototype.encryptBlock = function(ie) {
    var ne = this.encryptBlockRaw(ie), oe = B.allocUnsafe(16);
    return oe.writeUInt32BE(ne[0], 0), oe.writeUInt32BE(ne[1], 4), oe.writeUInt32BE(ne[2], 8), oe.writeUInt32BE(ne[3], 12), oe;
  }, re.prototype.decryptBlock = function(ie) {
    var ne = (ie = L(ie))[1];
    ie[1] = ie[3], ie[3] = ne;
    var oe = W(ie, this._invKeySchedule, J.INV_SUB_MIX, J.INV_SBOX, this._nRounds), ce = B.allocUnsafe(16);
    return ce.writeUInt32BE(oe[0], 0), ce.writeUInt32BE(oe[3], 4), ce.writeUInt32BE(oe[2], 8), ce.writeUInt32BE(oe[1], 12), ce;
  }, re.prototype.scrub = function() {
    K(this._keySchedule), K(this._invKeySchedule), K(this._key);
  }, aes.AES = re, aes;
}
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var B = safeBufferExports.Buffer, L = B.alloc(16, 0);
  function K(V) {
    var J = B.allocUnsafe(16);
    return J.writeUInt32BE(V[0] >>> 0, 0), J.writeUInt32BE(V[1] >>> 0, 4), J.writeUInt32BE(V[2] >>> 0, 8), J.writeUInt32BE(V[3] >>> 0, 12), J;
  }
  function W(V) {
    this.h = V, this.state = B.alloc(16, 0), this.cache = B.allocUnsafe(0);
  }
  return W.prototype.ghash = function(V) {
    for (var J = -1; ++J < V.length; ) this.state[J] ^= V[J];
    this._multiply();
  }, W.prototype._multiply = function() {
    for (var V, J, re, ie = [(V = this.h).readUInt32BE(0), V.readUInt32BE(4), V.readUInt32BE(8), V.readUInt32BE(12)], ne = [0, 0, 0, 0], oe = -1; ++oe < 128; ) {
      for (this.state[~~(oe / 8)] & 1 << 7 - oe % 8 && (ne[0] ^= ie[0], ne[1] ^= ie[1], ne[2] ^= ie[2], ne[3] ^= ie[3]), re = !!(1 & ie[3]), J = 3; J > 0; J--) ie[J] = ie[J] >>> 1 | (1 & ie[J - 1]) << 31;
      ie[0] = ie[0] >>> 1, re && (ie[0] = ie[0] ^ 225 << 24);
    }
    this.state = K(ne);
  }, W.prototype.update = function(V) {
    var J;
    for (this.cache = B.concat([this.cache, V]); this.cache.length >= 16; ) J = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(J);
  }, W.prototype.final = function(V, J) {
    return this.cache.length && this.ghash(B.concat([this.cache, L], 16)), this.ghash(K([0, V, 0, J])), this.state;
  }, ghash = W;
}
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var B = requireAes(), L = safeBufferExports.Buffer, K = requireCipherBase(), W = requireInherits_browser(), V = requireGhash(), J = requireBufferXor(), re = requireIncr32();
  function ie(ne, oe, ce, pe) {
    K.call(this);
    var ke = L.alloc(4, 0);
    this._cipher = new B.AES(oe);
    var ot = this._cipher.encryptBlock(ke);
    this._ghash = new V(ot), ce = function(at, ft, dt) {
      if (ft.length === 12) return at._finID = L.concat([ft, L.from([0, 0, 0, 1])]), L.concat([ft, L.from([0, 0, 0, 2])]);
      var lt = new V(dt), yt = ft.length, St = yt % 16;
      lt.update(ft), St && (St = 16 - St, lt.update(L.alloc(St, 0))), lt.update(L.alloc(8, 0));
      var mt = 8 * yt, $t = L.alloc(8);
      $t.writeUIntBE(mt, 0, 8), lt.update($t), at._finID = lt.state;
      var It = L.from(at._finID);
      return re(It), It;
    }(this, ce, ot), this._prev = L.from(ce), this._cache = L.allocUnsafe(0), this._secCache = L.allocUnsafe(0), this._decrypt = pe, this._alen = 0, this._len = 0, this._mode = ne, this._authTag = null, this._called = !1;
  }
  return W(ie, K), ie.prototype._update = function(ne) {
    if (!this._called && this._alen) {
      var oe = 16 - this._alen % 16;
      oe < 16 && (oe = L.alloc(oe, 0), this._ghash.update(oe));
    }
    this._called = !0;
    var ce = this._mode.encrypt(this, ne);
    return this._decrypt ? this._ghash.update(ne) : this._ghash.update(ce), this._len += ne.length, ce;
  }, ie.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var ne = J(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && function(oe, ce) {
      var pe = 0;
      oe.length !== ce.length && pe++;
      for (var ke = Math.min(oe.length, ce.length), ot = 0; ot < ke; ++ot) pe += oe[ot] ^ ce[ot];
      return pe;
    }(ne, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = ne, this._cipher.scrub();
  }, ie.prototype.getAuthTag = function() {
    if (this._decrypt || !L.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ie.prototype.setAuthTag = function(ne) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = ne;
  }, ie.prototype.setAAD = function(ne) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(ne), this._alen += ne.length;
  }, authCipher = ie;
}
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var B = requireAes(), L = safeBufferExports.Buffer, K = requireCipherBase();
  function W(V, J, re, ie) {
    K.call(this), this._cipher = new B.AES(J), this._prev = L.from(re), this._cache = L.allocUnsafe(0), this._secCache = L.allocUnsafe(0), this._decrypt = ie, this._mode = V;
  }
  return requireInherits_browser()(W, K), W.prototype._update = function(V) {
    return this._mode.encrypt(this, V, this._decrypt);
  }, W.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = W;
}
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var B = safeBufferExports.Buffer, L = requireMd5_js();
  return evp_bytestokey = function(K, W, V, J) {
    if (B.isBuffer(K) || (K = B.from(K, "binary")), W && (B.isBuffer(W) || (W = B.from(W, "binary")), W.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
    for (var re = V / 8, ie = B.alloc(re), ne = B.alloc(J || 0), oe = B.alloc(0); re > 0 || J > 0; ) {
      var ce = new L();
      ce.update(oe), ce.update(K), W && ce.update(W), oe = ce.digest();
      var pe = 0;
      if (re > 0) {
        var ke = ie.length - re;
        pe = Math.min(re, oe.length), oe.copy(ie, ke, 0, pe), re -= pe;
      }
      if (pe < oe.length && J > 0) {
        var ot = ne.length - J, at = Math.min(J, oe.length - pe);
        oe.copy(ne, ot, pe, pe + at), J -= at;
      }
    }
    return oe.fill(0), { key: ie, iv: ne };
  }, evp_bytestokey;
}
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var B = requireModes$1(), L = requireAuthCipher(), K = safeBufferExports.Buffer, W = requireStreamCipher(), V = requireCipherBase(), J = requireAes(), re = requireEvp_bytestokey();
  function ie(pe, ke, ot) {
    V.call(this), this._cache = new oe(), this._cipher = new J.AES(ke), this._prev = K.from(ot), this._mode = pe, this._autopadding = !0;
  }
  requireInherits_browser()(ie, V), ie.prototype._update = function(pe) {
    var ke, ot;
    this._cache.add(pe);
    for (var at = []; ke = this._cache.get(); ) ot = this._mode.encrypt(this, ke), at.push(ot);
    return K.concat(at);
  };
  var ne = K.alloc(16, 16);
  function oe() {
    this.cache = K.allocUnsafe(0);
  }
  function ce(pe, ke, ot) {
    var at = B[pe.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    if (typeof ke == "string" && (ke = K.from(ke)), ke.length !== at.key / 8) throw new TypeError("invalid key length " + ke.length);
    if (typeof ot == "string" && (ot = K.from(ot)), at.mode !== "GCM" && ot.length !== at.iv) throw new TypeError("invalid iv length " + ot.length);
    return at.type === "stream" ? new W(at.module, ke, ot) : at.type === "auth" ? new L(at.module, ke, ot) : new ie(at.module, ke, ot);
  }
  return ie.prototype._final = function() {
    var pe = this._cache.flush();
    if (this._autopadding) return pe = this._mode.encrypt(this, pe), this._cipher.scrub(), pe;
    if (!pe.equals(ne)) throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(pe) {
    return this._autopadding = !!pe, this;
  }, oe.prototype.add = function(pe) {
    this.cache = K.concat([this.cache, pe]);
  }, oe.prototype.get = function() {
    if (this.cache.length > 15) {
      var pe = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), pe;
    }
    return null;
  }, oe.prototype.flush = function() {
    for (var pe = 16 - this.cache.length, ke = K.allocUnsafe(pe), ot = -1; ++ot < pe; ) ke.writeUInt8(pe, ot);
    return K.concat([this.cache, ke]);
  }, encrypter.createCipheriv = ce, encrypter.createCipher = function(pe, ke) {
    var ot = B[pe.toLowerCase()];
    if (!ot) throw new TypeError("invalid suite type");
    var at = re(ke, !1, ot.key, ot.iv);
    return ce(pe, at.key, at.iv);
  }, encrypter;
}
var decrypter = {}, hasRequiredDecrypter, hasRequiredBrowser$6;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var B = requireAuthCipher(), L = safeBufferExports.Buffer, K = requireModes$1(), W = requireStreamCipher(), V = requireCipherBase(), J = requireAes(), re = requireEvp_bytestokey();
  function ie(ce, pe, ke) {
    V.call(this), this._cache = new ne(), this._last = void 0, this._cipher = new J.AES(pe), this._prev = L.from(ke), this._mode = ce, this._autopadding = !0;
  }
  function ne() {
    this.cache = L.allocUnsafe(0);
  }
  function oe(ce, pe, ke) {
    var ot = K[ce.toLowerCase()];
    if (!ot) throw new TypeError("invalid suite type");
    if (typeof ke == "string" && (ke = L.from(ke)), ot.mode !== "GCM" && ke.length !== ot.iv) throw new TypeError("invalid iv length " + ke.length);
    if (typeof pe == "string" && (pe = L.from(pe)), pe.length !== ot.key / 8) throw new TypeError("invalid key length " + pe.length);
    return ot.type === "stream" ? new W(ot.module, pe, ke, !0) : ot.type === "auth" ? new B(ot.module, pe, ke, !0) : new ie(ot.module, pe, ke);
  }
  return requireInherits_browser()(ie, V), ie.prototype._update = function(ce) {
    var pe, ke;
    this._cache.add(ce);
    for (var ot = []; pe = this._cache.get(this._autopadding); ) ke = this._mode.decrypt(this, pe), ot.push(ke);
    return L.concat(ot);
  }, ie.prototype._final = function() {
    var ce = this._cache.flush();
    if (this._autopadding) return function(pe) {
      var ke = pe[15];
      if (ke < 1 || ke > 16) throw new Error("unable to decrypt data");
      for (var ot = -1; ++ot < ke; ) if (pe[ot + (16 - ke)] !== ke) throw new Error("unable to decrypt data");
      if (ke !== 16) return pe.slice(0, 16 - ke);
    }(this._mode.decrypt(this, ce));
    if (ce) throw new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(ce) {
    return this._autopadding = !!ce, this;
  }, ne.prototype.add = function(ce) {
    this.cache = L.concat([this.cache, ce]);
  }, ne.prototype.get = function(ce) {
    var pe;
    if (ce) {
      if (this.cache.length > 16) return pe = this.cache.slice(0, 16), this.cache = this.cache.slice(16), pe;
    } else if (this.cache.length >= 16) return pe = this.cache.slice(0, 16), this.cache = this.cache.slice(16), pe;
    return null;
  }, ne.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  }, decrypter.createDecipher = function(ce, pe) {
    var ke = K[ce.toLowerCase()];
    if (!ke) throw new TypeError("invalid suite type");
    var ot = re(pe, !1, ke.key, ke.iv);
    return oe(ce, ot.key, ot.iv);
  }, decrypter.createDecipheriv = oe, decrypter;
}
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var B = requireEncrypter(), L = requireDecrypter(), K = require$$2;
  return browser$5.createCipher = browser$5.Cipher = B.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = B.createCipheriv, browser$5.createDecipher = browser$5.Decipher = L.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = L.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = function() {
    return Object.keys(K);
  }, browser$5;
}
var modes = {}, hasRequiredModes, hasRequiredBrowser$5;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(B) {
    B["des-ecb"] = { key: 8, iv: 0 }, B["des-cbc"] = B.des = { key: 8, iv: 8 }, B["des-ede3-cbc"] = B.des3 = { key: 24, iv: 8 }, B["des-ede3"] = { key: 24, iv: 0 }, B["des-ede-cbc"] = { key: 16, iv: 8 }, B["des-ede"] = { key: 16, iv: 0 };
  }(modes)), modes;
}
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var B = requireBrowserifyDes(), L = requireBrowser$6(), K = requireModes$1(), W = requireModes(), V = requireEvp_bytestokey();
  function J(ie, ne, oe) {
    if (ie = ie.toLowerCase(), K[ie]) return L.createCipheriv(ie, ne, oe);
    if (W[ie]) return new B({ key: ne, iv: oe, mode: ie });
    throw new TypeError("invalid suite type");
  }
  function re(ie, ne, oe) {
    if (ie = ie.toLowerCase(), K[ie]) return L.createDecipheriv(ie, ne, oe);
    if (W[ie]) return new B({ key: ne, iv: oe, mode: ie, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  return browser$6.createCipher = browser$6.Cipher = function(ie, ne) {
    var oe, ce;
    if (ie = ie.toLowerCase(), K[ie]) oe = K[ie].key, ce = K[ie].iv;
    else {
      if (!W[ie]) throw new TypeError("invalid suite type");
      oe = 8 * W[ie].key, ce = W[ie].iv;
    }
    var pe = V(ne, !1, oe, ce);
    return J(ie, pe.key, pe.iv);
  }, browser$6.createCipheriv = browser$6.Cipheriv = J, browser$6.createDecipher = browser$6.Decipher = function(ie, ne) {
    var oe, ce;
    if (ie = ie.toLowerCase(), K[ie]) oe = K[ie].key, ce = K[ie].iv;
    else {
      if (!W[ie]) throw new TypeError("invalid suite type");
      oe = 8 * W[ie].key, ce = W[ie].iv;
    }
    var pe = V(ne, !1, oe, ce);
    return re(ie, pe.key, pe.iv);
  }, browser$6.createDecipheriv = browser$6.Decipheriv = re, browser$6.listCiphers = browser$6.getCiphers = function() {
    return Object.keys(W).concat(L.getCiphers());
  }, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} }, hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(B, L) {
    function K(ut, ht) {
      if (!ut) throw new Error(ht || "Assertion failed");
    }
    function W(ut, ht) {
      ut.super_ = ht;
      var Ce = function() {
      };
      Ce.prototype = ht.prototype, ut.prototype = new Ce(), ut.prototype.constructor = ut;
    }
    function V(ut, ht, Ce) {
      if (V.isBN(ut)) return ut;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, ut !== null && (ht !== "le" && ht !== "be" || (Ce = ht, ht = 10), this._init(ut || 0, ht || 10, Ce || "be"));
    }
    var J;
    typeof bn$1 == "object" ? bn$1.exports = V : L.BN = V, V.BN = V, V.wordSize = 26;
    try {
      J = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$1$2.Buffer;
    } catch {
    }
    function re(ut, ht) {
      var Ce = ut.charCodeAt(ht);
      return Ce >= 65 && Ce <= 70 ? Ce - 55 : Ce >= 97 && Ce <= 102 ? Ce - 87 : Ce - 48 & 15;
    }
    function ie(ut, ht, Ce) {
      var nt = re(ut, Ce);
      return Ce - 1 >= ht && (nt |= re(ut, Ce - 1) << 4), nt;
    }
    function ne(ut, ht, Ce, nt) {
      for (var rt = 0, it = Math.min(ut.length, Ce), st = ht; st < it; st++) {
        var Oe = ut.charCodeAt(st) - 48;
        rt *= nt, rt += Oe >= 49 ? Oe - 49 + 10 : Oe >= 17 ? Oe - 17 + 10 : Oe;
      }
      return rt;
    }
    V.isBN = function(ut) {
      return ut instanceof V || ut !== null && typeof ut == "object" && ut.constructor.wordSize === V.wordSize && Array.isArray(ut.words);
    }, V.max = function(ut, ht) {
      return ut.cmp(ht) > 0 ? ut : ht;
    }, V.min = function(ut, ht) {
      return ut.cmp(ht) < 0 ? ut : ht;
    }, V.prototype._init = function(ut, ht, Ce) {
      if (typeof ut == "number") return this._initNumber(ut, ht, Ce);
      if (typeof ut == "object") return this._initArray(ut, ht, Ce);
      ht === "hex" && (ht = 16), K(ht === (0 | ht) && ht >= 2 && ht <= 36);
      var nt = 0;
      (ut = ut.toString().replace(/\s+/g, ""))[0] === "-" && (nt++, this.negative = 1), nt < ut.length && (ht === 16 ? this._parseHex(ut, nt, Ce) : (this._parseBase(ut, ht, nt), Ce === "le" && this._initArray(this.toArray(), ht, Ce)));
    }, V.prototype._initNumber = function(ut, ht, Ce) {
      ut < 0 && (this.negative = 1, ut = -ut), ut < 67108864 ? (this.words = [67108863 & ut], this.length = 1) : ut < 4503599627370496 ? (this.words = [67108863 & ut, ut / 67108864 & 67108863], this.length = 2) : (K(ut < 9007199254740992), this.words = [67108863 & ut, ut / 67108864 & 67108863, 1], this.length = 3), Ce === "le" && this._initArray(this.toArray(), ht, Ce);
    }, V.prototype._initArray = function(ut, ht, Ce) {
      if (K(typeof ut.length == "number"), ut.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ut.length / 3), this.words = new Array(this.length);
      for (var nt = 0; nt < this.length; nt++) this.words[nt] = 0;
      var rt, it, st = 0;
      if (Ce === "be") for (nt = ut.length - 1, rt = 0; nt >= 0; nt -= 3) it = ut[nt] | ut[nt - 1] << 8 | ut[nt - 2] << 16, this.words[rt] |= it << st & 67108863, this.words[rt + 1] = it >>> 26 - st & 67108863, (st += 24) >= 26 && (st -= 26, rt++);
      else if (Ce === "le") for (nt = 0, rt = 0; nt < ut.length; nt += 3) it = ut[nt] | ut[nt + 1] << 8 | ut[nt + 2] << 16, this.words[rt] |= it << st & 67108863, this.words[rt + 1] = it >>> 26 - st & 67108863, (st += 24) >= 26 && (st -= 26, rt++);
      return this.strip();
    }, V.prototype._parseHex = function(ut, ht, Ce) {
      this.length = Math.ceil((ut.length - ht) / 6), this.words = new Array(this.length);
      for (var nt = 0; nt < this.length; nt++) this.words[nt] = 0;
      var rt, it = 0, st = 0;
      if (Ce === "be") for (nt = ut.length - 1; nt >= ht; nt -= 2) rt = ie(ut, ht, nt) << it, this.words[st] |= 67108863 & rt, it >= 18 ? (it -= 18, st += 1, this.words[st] |= rt >>> 26) : it += 8;
      else for (nt = (ut.length - ht) % 2 == 0 ? ht + 1 : ht; nt < ut.length; nt += 2) rt = ie(ut, ht, nt) << it, this.words[st] |= 67108863 & rt, it >= 18 ? (it -= 18, st += 1, this.words[st] |= rt >>> 26) : it += 8;
      this.strip();
    }, V.prototype._parseBase = function(ut, ht, Ce) {
      this.words = [0], this.length = 1;
      for (var nt = 0, rt = 1; rt <= 67108863; rt *= ht) nt++;
      nt--, rt = rt / ht | 0;
      for (var it = ut.length - Ce, st = it % nt, Oe = Math.min(it, it - st) + Ce, ct = 0, pt = Ce; pt < Oe; pt += nt) ct = ne(ut, pt, pt + nt, ht), this.imuln(rt), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
      if (st !== 0) {
        var gt = 1;
        for (ct = ne(ut, pt, ut.length, ht), pt = 0; pt < st; pt++) gt *= ht;
        this.imuln(gt), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
      }
      this.strip();
    }, V.prototype.copy = function(ut) {
      ut.words = new Array(this.length);
      for (var ht = 0; ht < this.length; ht++) ut.words[ht] = this.words[ht];
      ut.length = this.length, ut.negative = this.negative, ut.red = this.red;
    }, V.prototype.clone = function() {
      var ut = new V(null);
      return this.copy(ut), ut;
    }, V.prototype._expand = function(ut) {
      for (; this.length < ut; ) this.words[this.length++] = 0;
      return this;
    }, V.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, V.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, V.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var oe = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], ce = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], pe = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    function ke(ut, ht, Ce) {
      Ce.negative = ht.negative ^ ut.negative;
      var nt = ut.length + ht.length | 0;
      Ce.length = nt, nt = nt - 1 | 0;
      var rt = 0 | ut.words[0], it = 0 | ht.words[0], st = rt * it, Oe = 67108863 & st, ct = st / 67108864 | 0;
      Ce.words[0] = Oe;
      for (var pt = 1; pt < nt; pt++) {
        for (var gt = ct >>> 26, vt = 67108863 & ct, Bt = Math.min(pt, ht.length - 1), kt = Math.max(0, pt - ut.length + 1); kt <= Bt; kt++) {
          var wt = pt - kt | 0;
          gt += (st = (rt = 0 | ut.words[wt]) * (it = 0 | ht.words[kt]) + vt) / 67108864 | 0, vt = 67108863 & st;
        }
        Ce.words[pt] = 0 | vt, ct = 0 | gt;
      }
      return ct !== 0 ? Ce.words[pt] = 0 | ct : Ce.length--, Ce.strip();
    }
    V.prototype.toString = function(ut, ht) {
      var Ce;
      if (ht = 0 | ht || 1, (ut = ut || 10) === 16 || ut === "hex") {
        Ce = "";
        for (var nt = 0, rt = 0, it = 0; it < this.length; it++) {
          var st = this.words[it], Oe = (16777215 & (st << nt | rt)).toString(16);
          Ce = (rt = st >>> 24 - nt & 16777215) != 0 || it !== this.length - 1 ? oe[6 - Oe.length] + Oe + Ce : Oe + Ce, (nt += 2) >= 26 && (nt -= 26, it--);
        }
        for (rt !== 0 && (Ce = rt.toString(16) + Ce); Ce.length % ht != 0; ) Ce = "0" + Ce;
        return this.negative !== 0 && (Ce = "-" + Ce), Ce;
      }
      if (ut === (0 | ut) && ut >= 2 && ut <= 36) {
        var ct = ce[ut], pt = pe[ut];
        Ce = "";
        var gt = this.clone();
        for (gt.negative = 0; !gt.isZero(); ) {
          var vt = gt.modn(pt).toString(ut);
          Ce = (gt = gt.idivn(pt)).isZero() ? vt + Ce : oe[ct - vt.length] + vt + Ce;
        }
        for (this.isZero() && (Ce = "0" + Ce); Ce.length % ht != 0; ) Ce = "0" + Ce;
        return this.negative !== 0 && (Ce = "-" + Ce), Ce;
      }
      K(!1, "Base should be between 2 and 36");
    }, V.prototype.toNumber = function() {
      var ut = this.words[0];
      return this.length === 2 ? ut += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? ut += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ut : ut;
    }, V.prototype.toJSON = function() {
      return this.toString(16);
    }, V.prototype.toBuffer = function(ut, ht) {
      return K(J !== void 0), this.toArrayLike(J, ut, ht);
    }, V.prototype.toArray = function(ut, ht) {
      return this.toArrayLike(Array, ut, ht);
    }, V.prototype.toArrayLike = function(ut, ht, Ce) {
      var nt = this.byteLength(), rt = Ce || Math.max(1, nt);
      K(nt <= rt, "byte array longer than desired length"), K(rt > 0, "Requested array length <= 0"), this.strip();
      var it, st, Oe = ht === "le", ct = new ut(rt), pt = this.clone();
      if (Oe) {
        for (st = 0; !pt.isZero(); st++) it = pt.andln(255), pt.iushrn(8), ct[st] = it;
        for (; st < rt; st++) ct[st] = 0;
      } else {
        for (st = 0; st < rt - nt; st++) ct[st] = 0;
        for (st = 0; !pt.isZero(); st++) it = pt.andln(255), pt.iushrn(8), ct[rt - st - 1] = it;
      }
      return ct;
    }, Math.clz32 ? V.prototype._countBits = function(ut) {
      return 32 - Math.clz32(ut);
    } : V.prototype._countBits = function(ut) {
      var ht = ut, Ce = 0;
      return ht >= 4096 && (Ce += 13, ht >>>= 13), ht >= 64 && (Ce += 7, ht >>>= 7), ht >= 8 && (Ce += 4, ht >>>= 4), ht >= 2 && (Ce += 2, ht >>>= 2), Ce + ht;
    }, V.prototype._zeroBits = function(ut) {
      if (ut === 0) return 26;
      var ht = ut, Ce = 0;
      return 8191 & ht || (Ce += 13, ht >>>= 13), 127 & ht || (Ce += 7, ht >>>= 7), 15 & ht || (Ce += 4, ht >>>= 4), 3 & ht || (Ce += 2, ht >>>= 2), 1 & ht || Ce++, Ce;
    }, V.prototype.bitLength = function() {
      var ut = this.words[this.length - 1], ht = this._countBits(ut);
      return 26 * (this.length - 1) + ht;
    }, V.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ut = 0, ht = 0; ht < this.length; ht++) {
        var Ce = this._zeroBits(this.words[ht]);
        if (ut += Ce, Ce !== 26) break;
      }
      return ut;
    }, V.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, V.prototype.toTwos = function(ut) {
      return this.negative !== 0 ? this.abs().inotn(ut).iaddn(1) : this.clone();
    }, V.prototype.fromTwos = function(ut) {
      return this.testn(ut - 1) ? this.notn(ut).iaddn(1).ineg() : this.clone();
    }, V.prototype.isNeg = function() {
      return this.negative !== 0;
    }, V.prototype.neg = function() {
      return this.clone().ineg();
    }, V.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, V.prototype.iuor = function(ut) {
      for (; this.length < ut.length; ) this.words[this.length++] = 0;
      for (var ht = 0; ht < ut.length; ht++) this.words[ht] = this.words[ht] | ut.words[ht];
      return this.strip();
    }, V.prototype.ior = function(ut) {
      return K(!(this.negative | ut.negative)), this.iuor(ut);
    }, V.prototype.or = function(ut) {
      return this.length > ut.length ? this.clone().ior(ut) : ut.clone().ior(this);
    }, V.prototype.uor = function(ut) {
      return this.length > ut.length ? this.clone().iuor(ut) : ut.clone().iuor(this);
    }, V.prototype.iuand = function(ut) {
      var ht;
      ht = this.length > ut.length ? ut : this;
      for (var Ce = 0; Ce < ht.length; Ce++) this.words[Ce] = this.words[Ce] & ut.words[Ce];
      return this.length = ht.length, this.strip();
    }, V.prototype.iand = function(ut) {
      return K(!(this.negative | ut.negative)), this.iuand(ut);
    }, V.prototype.and = function(ut) {
      return this.length > ut.length ? this.clone().iand(ut) : ut.clone().iand(this);
    }, V.prototype.uand = function(ut) {
      return this.length > ut.length ? this.clone().iuand(ut) : ut.clone().iuand(this);
    }, V.prototype.iuxor = function(ut) {
      var ht, Ce;
      this.length > ut.length ? (ht = this, Ce = ut) : (ht = ut, Ce = this);
      for (var nt = 0; nt < Ce.length; nt++) this.words[nt] = ht.words[nt] ^ Ce.words[nt];
      if (this !== ht) for (; nt < ht.length; nt++) this.words[nt] = ht.words[nt];
      return this.length = ht.length, this.strip();
    }, V.prototype.ixor = function(ut) {
      return K(!(this.negative | ut.negative)), this.iuxor(ut);
    }, V.prototype.xor = function(ut) {
      return this.length > ut.length ? this.clone().ixor(ut) : ut.clone().ixor(this);
    }, V.prototype.uxor = function(ut) {
      return this.length > ut.length ? this.clone().iuxor(ut) : ut.clone().iuxor(this);
    }, V.prototype.inotn = function(ut) {
      K(typeof ut == "number" && ut >= 0);
      var ht = 0 | Math.ceil(ut / 26), Ce = ut % 26;
      this._expand(ht), Ce > 0 && ht--;
      for (var nt = 0; nt < ht; nt++) this.words[nt] = 67108863 & ~this.words[nt];
      return Ce > 0 && (this.words[nt] = ~this.words[nt] & 67108863 >> 26 - Ce), this.strip();
    }, V.prototype.notn = function(ut) {
      return this.clone().inotn(ut);
    }, V.prototype.setn = function(ut, ht) {
      K(typeof ut == "number" && ut >= 0);
      var Ce = ut / 26 | 0, nt = ut % 26;
      return this._expand(Ce + 1), this.words[Ce] = ht ? this.words[Ce] | 1 << nt : this.words[Ce] & ~(1 << nt), this.strip();
    }, V.prototype.iadd = function(ut) {
      var ht, Ce, nt;
      if (this.negative !== 0 && ut.negative === 0) return this.negative = 0, ht = this.isub(ut), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ut.negative !== 0) return ut.negative = 0, ht = this.isub(ut), ut.negative = 1, ht._normSign();
      this.length > ut.length ? (Ce = this, nt = ut) : (Ce = ut, nt = this);
      for (var rt = 0, it = 0; it < nt.length; it++) ht = (0 | Ce.words[it]) + (0 | nt.words[it]) + rt, this.words[it] = 67108863 & ht, rt = ht >>> 26;
      for (; rt !== 0 && it < Ce.length; it++) ht = (0 | Ce.words[it]) + rt, this.words[it] = 67108863 & ht, rt = ht >>> 26;
      if (this.length = Ce.length, rt !== 0) this.words[this.length] = rt, this.length++;
      else if (Ce !== this) for (; it < Ce.length; it++) this.words[it] = Ce.words[it];
      return this;
    }, V.prototype.add = function(ut) {
      var ht;
      return ut.negative !== 0 && this.negative === 0 ? (ut.negative = 0, ht = this.sub(ut), ut.negative ^= 1, ht) : ut.negative === 0 && this.negative !== 0 ? (this.negative = 0, ht = ut.sub(this), this.negative = 1, ht) : this.length > ut.length ? this.clone().iadd(ut) : ut.clone().iadd(this);
    }, V.prototype.isub = function(ut) {
      if (ut.negative !== 0) {
        ut.negative = 0;
        var ht = this.iadd(ut);
        return ut.negative = 1, ht._normSign();
      }
      if (this.negative !== 0) return this.negative = 0, this.iadd(ut), this.negative = 1, this._normSign();
      var Ce, nt, rt = this.cmp(ut);
      if (rt === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      rt > 0 ? (Ce = this, nt = ut) : (Ce = ut, nt = this);
      for (var it = 0, st = 0; st < nt.length; st++) it = (ht = (0 | Ce.words[st]) - (0 | nt.words[st]) + it) >> 26, this.words[st] = 67108863 & ht;
      for (; it !== 0 && st < Ce.length; st++) it = (ht = (0 | Ce.words[st]) + it) >> 26, this.words[st] = 67108863 & ht;
      if (it === 0 && st < Ce.length && Ce !== this) for (; st < Ce.length; st++) this.words[st] = Ce.words[st];
      return this.length = Math.max(this.length, st), Ce !== this && (this.negative = 1), this.strip();
    }, V.prototype.sub = function(ut) {
      return this.clone().isub(ut);
    };
    var ot = function(ut, ht, Ce) {
      var nt, rt, it, st = ut.words, Oe = ht.words, ct = Ce.words, pt = 0, gt = 0 | st[0], vt = 8191 & gt, Bt = gt >>> 13, kt = 0 | st[1], wt = 8191 & kt, Et = kt >>> 13, Rt = 0 | st[2], Mt = 8191 & Rt, Ht = Rt >>> 13, Kt = 0 | st[3], jt = 8191 & Kt, Wt = Kt >>> 13, Yt = 0 | st[4], Xt = 8191 & Yt, ir = Yt >>> 13, ur = 0 | st[5], Qt = 8191 & ur, hr = ur >>> 13, pr = 0 | st[6], cr = 8191 & pr, vr = pr >>> 13, bt = 0 | st[7], At = 8191 & bt, Tt = bt >>> 13, xt = 0 | st[8], Nt = 8191 & xt, Ft = xt >>> 13, zt = 0 | st[9], nr = 8191 & zt, lr = zt >>> 13, Dt = 0 | Oe[0], Zt = 8191 & Dt, ar = Dt >>> 13, qt = 0 | Oe[1], Pt = 8191 & qt, Ot = qt >>> 13, Ct = 0 | Oe[2], Lt = 8191 & Ct, Vt = Ct >>> 13, Jt = 0 | Oe[3], Gt = 8191 & Jt, er = Jt >>> 13, or = 0 | Oe[4], tr = 8191 & or, sr = or >>> 13, rr = 0 | Oe[5], fr = 8191 & rr, dr = rr >>> 13, Sr = 0 | Oe[6], br = 8191 & Sr, Er = Sr >>> 13, $r = 0 | Oe[7], yr = 8191 & $r, kr = $r >>> 13, Tr = 0 | Oe[8], gr = 8191 & Tr, _r = Tr >>> 13, Ar = 0 | Oe[9], wr = 8191 & Ar, Rr = Ar >>> 13;
      Ce.negative = ut.negative ^ ht.negative, Ce.length = 19;
      var Ir = (pt + (nt = Math.imul(vt, Zt)) | 0) + ((8191 & (rt = (rt = Math.imul(vt, ar)) + Math.imul(Bt, Zt) | 0)) << 13) | 0;
      pt = ((it = Math.imul(Bt, ar)) + (rt >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, nt = Math.imul(wt, Zt), rt = (rt = Math.imul(wt, ar)) + Math.imul(Et, Zt) | 0, it = Math.imul(Et, ar);
      var Br = (pt + (nt = nt + Math.imul(vt, Pt) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, Ot) | 0) + Math.imul(Bt, Pt) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, Ot) | 0) + (rt >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, nt = Math.imul(Mt, Zt), rt = (rt = Math.imul(Mt, ar)) + Math.imul(Ht, Zt) | 0, it = Math.imul(Ht, ar), nt = nt + Math.imul(wt, Pt) | 0, rt = (rt = rt + Math.imul(wt, Ot) | 0) + Math.imul(Et, Pt) | 0, it = it + Math.imul(Et, Ot) | 0;
      var Pr = (pt + (nt = nt + Math.imul(vt, Lt) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, Vt) | 0) + Math.imul(Bt, Lt) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, Vt) | 0) + (rt >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, nt = Math.imul(jt, Zt), rt = (rt = Math.imul(jt, ar)) + Math.imul(Wt, Zt) | 0, it = Math.imul(Wt, ar), nt = nt + Math.imul(Mt, Pt) | 0, rt = (rt = rt + Math.imul(Mt, Ot) | 0) + Math.imul(Ht, Pt) | 0, it = it + Math.imul(Ht, Ot) | 0, nt = nt + Math.imul(wt, Lt) | 0, rt = (rt = rt + Math.imul(wt, Vt) | 0) + Math.imul(Et, Lt) | 0, it = it + Math.imul(Et, Vt) | 0;
      var Mr = (pt + (nt = nt + Math.imul(vt, Gt) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, er) | 0) + Math.imul(Bt, Gt) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, er) | 0) + (rt >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, nt = Math.imul(Xt, Zt), rt = (rt = Math.imul(Xt, ar)) + Math.imul(ir, Zt) | 0, it = Math.imul(ir, ar), nt = nt + Math.imul(jt, Pt) | 0, rt = (rt = rt + Math.imul(jt, Ot) | 0) + Math.imul(Wt, Pt) | 0, it = it + Math.imul(Wt, Ot) | 0, nt = nt + Math.imul(Mt, Lt) | 0, rt = (rt = rt + Math.imul(Mt, Vt) | 0) + Math.imul(Ht, Lt) | 0, it = it + Math.imul(Ht, Vt) | 0, nt = nt + Math.imul(wt, Gt) | 0, rt = (rt = rt + Math.imul(wt, er) | 0) + Math.imul(Et, Gt) | 0, it = it + Math.imul(Et, er) | 0;
      var Or = (pt + (nt = nt + Math.imul(vt, tr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, sr) | 0) + Math.imul(Bt, tr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, sr) | 0) + (rt >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, nt = Math.imul(Qt, Zt), rt = (rt = Math.imul(Qt, ar)) + Math.imul(hr, Zt) | 0, it = Math.imul(hr, ar), nt = nt + Math.imul(Xt, Pt) | 0, rt = (rt = rt + Math.imul(Xt, Ot) | 0) + Math.imul(ir, Pt) | 0, it = it + Math.imul(ir, Ot) | 0, nt = nt + Math.imul(jt, Lt) | 0, rt = (rt = rt + Math.imul(jt, Vt) | 0) + Math.imul(Wt, Lt) | 0, it = it + Math.imul(Wt, Vt) | 0, nt = nt + Math.imul(Mt, Gt) | 0, rt = (rt = rt + Math.imul(Mt, er) | 0) + Math.imul(Ht, Gt) | 0, it = it + Math.imul(Ht, er) | 0, nt = nt + Math.imul(wt, tr) | 0, rt = (rt = rt + Math.imul(wt, sr) | 0) + Math.imul(Et, tr) | 0, it = it + Math.imul(Et, sr) | 0;
      var xr = (pt + (nt = nt + Math.imul(vt, fr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, dr) | 0) + Math.imul(Bt, fr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, dr) | 0) + (rt >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, nt = Math.imul(cr, Zt), rt = (rt = Math.imul(cr, ar)) + Math.imul(vr, Zt) | 0, it = Math.imul(vr, ar), nt = nt + Math.imul(Qt, Pt) | 0, rt = (rt = rt + Math.imul(Qt, Ot) | 0) + Math.imul(hr, Pt) | 0, it = it + Math.imul(hr, Ot) | 0, nt = nt + Math.imul(Xt, Lt) | 0, rt = (rt = rt + Math.imul(Xt, Vt) | 0) + Math.imul(ir, Lt) | 0, it = it + Math.imul(ir, Vt) | 0, nt = nt + Math.imul(jt, Gt) | 0, rt = (rt = rt + Math.imul(jt, er) | 0) + Math.imul(Wt, Gt) | 0, it = it + Math.imul(Wt, er) | 0, nt = nt + Math.imul(Mt, tr) | 0, rt = (rt = rt + Math.imul(Mt, sr) | 0) + Math.imul(Ht, tr) | 0, it = it + Math.imul(Ht, sr) | 0, nt = nt + Math.imul(wt, fr) | 0, rt = (rt = rt + Math.imul(wt, dr) | 0) + Math.imul(Et, fr) | 0, it = it + Math.imul(Et, dr) | 0;
      var qr = (pt + (nt = nt + Math.imul(vt, br) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, Er) | 0) + Math.imul(Bt, br) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, Er) | 0) + (rt >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, nt = Math.imul(At, Zt), rt = (rt = Math.imul(At, ar)) + Math.imul(Tt, Zt) | 0, it = Math.imul(Tt, ar), nt = nt + Math.imul(cr, Pt) | 0, rt = (rt = rt + Math.imul(cr, Ot) | 0) + Math.imul(vr, Pt) | 0, it = it + Math.imul(vr, Ot) | 0, nt = nt + Math.imul(Qt, Lt) | 0, rt = (rt = rt + Math.imul(Qt, Vt) | 0) + Math.imul(hr, Lt) | 0, it = it + Math.imul(hr, Vt) | 0, nt = nt + Math.imul(Xt, Gt) | 0, rt = (rt = rt + Math.imul(Xt, er) | 0) + Math.imul(ir, Gt) | 0, it = it + Math.imul(ir, er) | 0, nt = nt + Math.imul(jt, tr) | 0, rt = (rt = rt + Math.imul(jt, sr) | 0) + Math.imul(Wt, tr) | 0, it = it + Math.imul(Wt, sr) | 0, nt = nt + Math.imul(Mt, fr) | 0, rt = (rt = rt + Math.imul(Mt, dr) | 0) + Math.imul(Ht, fr) | 0, it = it + Math.imul(Ht, dr) | 0, nt = nt + Math.imul(wt, br) | 0, rt = (rt = rt + Math.imul(wt, Er) | 0) + Math.imul(Et, br) | 0, it = it + Math.imul(Et, Er) | 0;
      var Cr = (pt + (nt = nt + Math.imul(vt, yr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, kr) | 0) + Math.imul(Bt, yr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, kr) | 0) + (rt >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, nt = Math.imul(Nt, Zt), rt = (rt = Math.imul(Nt, ar)) + Math.imul(Ft, Zt) | 0, it = Math.imul(Ft, ar), nt = nt + Math.imul(At, Pt) | 0, rt = (rt = rt + Math.imul(At, Ot) | 0) + Math.imul(Tt, Pt) | 0, it = it + Math.imul(Tt, Ot) | 0, nt = nt + Math.imul(cr, Lt) | 0, rt = (rt = rt + Math.imul(cr, Vt) | 0) + Math.imul(vr, Lt) | 0, it = it + Math.imul(vr, Vt) | 0, nt = nt + Math.imul(Qt, Gt) | 0, rt = (rt = rt + Math.imul(Qt, er) | 0) + Math.imul(hr, Gt) | 0, it = it + Math.imul(hr, er) | 0, nt = nt + Math.imul(Xt, tr) | 0, rt = (rt = rt + Math.imul(Xt, sr) | 0) + Math.imul(ir, tr) | 0, it = it + Math.imul(ir, sr) | 0, nt = nt + Math.imul(jt, fr) | 0, rt = (rt = rt + Math.imul(jt, dr) | 0) + Math.imul(Wt, fr) | 0, it = it + Math.imul(Wt, dr) | 0, nt = nt + Math.imul(Mt, br) | 0, rt = (rt = rt + Math.imul(Mt, Er) | 0) + Math.imul(Ht, br) | 0, it = it + Math.imul(Ht, Er) | 0, nt = nt + Math.imul(wt, yr) | 0, rt = (rt = rt + Math.imul(wt, kr) | 0) + Math.imul(Et, yr) | 0, it = it + Math.imul(Et, kr) | 0;
      var Nr = (pt + (nt = nt + Math.imul(vt, gr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, _r) | 0) + Math.imul(Bt, gr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, _r) | 0) + (rt >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, nt = Math.imul(nr, Zt), rt = (rt = Math.imul(nr, ar)) + Math.imul(lr, Zt) | 0, it = Math.imul(lr, ar), nt = nt + Math.imul(Nt, Pt) | 0, rt = (rt = rt + Math.imul(Nt, Ot) | 0) + Math.imul(Ft, Pt) | 0, it = it + Math.imul(Ft, Ot) | 0, nt = nt + Math.imul(At, Lt) | 0, rt = (rt = rt + Math.imul(At, Vt) | 0) + Math.imul(Tt, Lt) | 0, it = it + Math.imul(Tt, Vt) | 0, nt = nt + Math.imul(cr, Gt) | 0, rt = (rt = rt + Math.imul(cr, er) | 0) + Math.imul(vr, Gt) | 0, it = it + Math.imul(vr, er) | 0, nt = nt + Math.imul(Qt, tr) | 0, rt = (rt = rt + Math.imul(Qt, sr) | 0) + Math.imul(hr, tr) | 0, it = it + Math.imul(hr, sr) | 0, nt = nt + Math.imul(Xt, fr) | 0, rt = (rt = rt + Math.imul(Xt, dr) | 0) + Math.imul(ir, fr) | 0, it = it + Math.imul(ir, dr) | 0, nt = nt + Math.imul(jt, br) | 0, rt = (rt = rt + Math.imul(jt, Er) | 0) + Math.imul(Wt, br) | 0, it = it + Math.imul(Wt, Er) | 0, nt = nt + Math.imul(Mt, yr) | 0, rt = (rt = rt + Math.imul(Mt, kr) | 0) + Math.imul(Ht, yr) | 0, it = it + Math.imul(Ht, kr) | 0, nt = nt + Math.imul(wt, gr) | 0, rt = (rt = rt + Math.imul(wt, _r) | 0) + Math.imul(Et, gr) | 0, it = it + Math.imul(Et, _r) | 0;
      var Ur = (pt + (nt = nt + Math.imul(vt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(vt, Rr) | 0) + Math.imul(Bt, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Bt, Rr) | 0) + (rt >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, nt = Math.imul(nr, Pt), rt = (rt = Math.imul(nr, Ot)) + Math.imul(lr, Pt) | 0, it = Math.imul(lr, Ot), nt = nt + Math.imul(Nt, Lt) | 0, rt = (rt = rt + Math.imul(Nt, Vt) | 0) + Math.imul(Ft, Lt) | 0, it = it + Math.imul(Ft, Vt) | 0, nt = nt + Math.imul(At, Gt) | 0, rt = (rt = rt + Math.imul(At, er) | 0) + Math.imul(Tt, Gt) | 0, it = it + Math.imul(Tt, er) | 0, nt = nt + Math.imul(cr, tr) | 0, rt = (rt = rt + Math.imul(cr, sr) | 0) + Math.imul(vr, tr) | 0, it = it + Math.imul(vr, sr) | 0, nt = nt + Math.imul(Qt, fr) | 0, rt = (rt = rt + Math.imul(Qt, dr) | 0) + Math.imul(hr, fr) | 0, it = it + Math.imul(hr, dr) | 0, nt = nt + Math.imul(Xt, br) | 0, rt = (rt = rt + Math.imul(Xt, Er) | 0) + Math.imul(ir, br) | 0, it = it + Math.imul(ir, Er) | 0, nt = nt + Math.imul(jt, yr) | 0, rt = (rt = rt + Math.imul(jt, kr) | 0) + Math.imul(Wt, yr) | 0, it = it + Math.imul(Wt, kr) | 0, nt = nt + Math.imul(Mt, gr) | 0, rt = (rt = rt + Math.imul(Mt, _r) | 0) + Math.imul(Ht, gr) | 0, it = it + Math.imul(Ht, _r) | 0;
      var Lr = (pt + (nt = nt + Math.imul(wt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(wt, Rr) | 0) + Math.imul(Et, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Et, Rr) | 0) + (rt >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, nt = Math.imul(nr, Lt), rt = (rt = Math.imul(nr, Vt)) + Math.imul(lr, Lt) | 0, it = Math.imul(lr, Vt), nt = nt + Math.imul(Nt, Gt) | 0, rt = (rt = rt + Math.imul(Nt, er) | 0) + Math.imul(Ft, Gt) | 0, it = it + Math.imul(Ft, er) | 0, nt = nt + Math.imul(At, tr) | 0, rt = (rt = rt + Math.imul(At, sr) | 0) + Math.imul(Tt, tr) | 0, it = it + Math.imul(Tt, sr) | 0, nt = nt + Math.imul(cr, fr) | 0, rt = (rt = rt + Math.imul(cr, dr) | 0) + Math.imul(vr, fr) | 0, it = it + Math.imul(vr, dr) | 0, nt = nt + Math.imul(Qt, br) | 0, rt = (rt = rt + Math.imul(Qt, Er) | 0) + Math.imul(hr, br) | 0, it = it + Math.imul(hr, Er) | 0, nt = nt + Math.imul(Xt, yr) | 0, rt = (rt = rt + Math.imul(Xt, kr) | 0) + Math.imul(ir, yr) | 0, it = it + Math.imul(ir, kr) | 0, nt = nt + Math.imul(jt, gr) | 0, rt = (rt = rt + Math.imul(jt, _r) | 0) + Math.imul(Wt, gr) | 0, it = it + Math.imul(Wt, _r) | 0;
      var jr = (pt + (nt = nt + Math.imul(Mt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(Mt, Rr) | 0) + Math.imul(Ht, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Ht, Rr) | 0) + (rt >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, nt = Math.imul(nr, Gt), rt = (rt = Math.imul(nr, er)) + Math.imul(lr, Gt) | 0, it = Math.imul(lr, er), nt = nt + Math.imul(Nt, tr) | 0, rt = (rt = rt + Math.imul(Nt, sr) | 0) + Math.imul(Ft, tr) | 0, it = it + Math.imul(Ft, sr) | 0, nt = nt + Math.imul(At, fr) | 0, rt = (rt = rt + Math.imul(At, dr) | 0) + Math.imul(Tt, fr) | 0, it = it + Math.imul(Tt, dr) | 0, nt = nt + Math.imul(cr, br) | 0, rt = (rt = rt + Math.imul(cr, Er) | 0) + Math.imul(vr, br) | 0, it = it + Math.imul(vr, Er) | 0, nt = nt + Math.imul(Qt, yr) | 0, rt = (rt = rt + Math.imul(Qt, kr) | 0) + Math.imul(hr, yr) | 0, it = it + Math.imul(hr, kr) | 0, nt = nt + Math.imul(Xt, gr) | 0, rt = (rt = rt + Math.imul(Xt, _r) | 0) + Math.imul(ir, gr) | 0, it = it + Math.imul(ir, _r) | 0;
      var Fr = (pt + (nt = nt + Math.imul(jt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(jt, Rr) | 0) + Math.imul(Wt, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Wt, Rr) | 0) + (rt >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, nt = Math.imul(nr, tr), rt = (rt = Math.imul(nr, sr)) + Math.imul(lr, tr) | 0, it = Math.imul(lr, sr), nt = nt + Math.imul(Nt, fr) | 0, rt = (rt = rt + Math.imul(Nt, dr) | 0) + Math.imul(Ft, fr) | 0, it = it + Math.imul(Ft, dr) | 0, nt = nt + Math.imul(At, br) | 0, rt = (rt = rt + Math.imul(At, Er) | 0) + Math.imul(Tt, br) | 0, it = it + Math.imul(Tt, Er) | 0, nt = nt + Math.imul(cr, yr) | 0, rt = (rt = rt + Math.imul(cr, kr) | 0) + Math.imul(vr, yr) | 0, it = it + Math.imul(vr, kr) | 0, nt = nt + Math.imul(Qt, gr) | 0, rt = (rt = rt + Math.imul(Qt, _r) | 0) + Math.imul(hr, gr) | 0, it = it + Math.imul(hr, _r) | 0;
      var Dr = (pt + (nt = nt + Math.imul(Xt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(Xt, Rr) | 0) + Math.imul(ir, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(ir, Rr) | 0) + (rt >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, nt = Math.imul(nr, fr), rt = (rt = Math.imul(nr, dr)) + Math.imul(lr, fr) | 0, it = Math.imul(lr, dr), nt = nt + Math.imul(Nt, br) | 0, rt = (rt = rt + Math.imul(Nt, Er) | 0) + Math.imul(Ft, br) | 0, it = it + Math.imul(Ft, Er) | 0, nt = nt + Math.imul(At, yr) | 0, rt = (rt = rt + Math.imul(At, kr) | 0) + Math.imul(Tt, yr) | 0, it = it + Math.imul(Tt, kr) | 0, nt = nt + Math.imul(cr, gr) | 0, rt = (rt = rt + Math.imul(cr, _r) | 0) + Math.imul(vr, gr) | 0, it = it + Math.imul(vr, _r) | 0;
      var Hr = (pt + (nt = nt + Math.imul(Qt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(Qt, Rr) | 0) + Math.imul(hr, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(hr, Rr) | 0) + (rt >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, nt = Math.imul(nr, br), rt = (rt = Math.imul(nr, Er)) + Math.imul(lr, br) | 0, it = Math.imul(lr, Er), nt = nt + Math.imul(Nt, yr) | 0, rt = (rt = rt + Math.imul(Nt, kr) | 0) + Math.imul(Ft, yr) | 0, it = it + Math.imul(Ft, kr) | 0, nt = nt + Math.imul(At, gr) | 0, rt = (rt = rt + Math.imul(At, _r) | 0) + Math.imul(Tt, gr) | 0, it = it + Math.imul(Tt, _r) | 0;
      var Wr = (pt + (nt = nt + Math.imul(cr, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(cr, Rr) | 0) + Math.imul(vr, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(vr, Rr) | 0) + (rt >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, nt = Math.imul(nr, yr), rt = (rt = Math.imul(nr, kr)) + Math.imul(lr, yr) | 0, it = Math.imul(lr, kr), nt = nt + Math.imul(Nt, gr) | 0, rt = (rt = rt + Math.imul(Nt, _r) | 0) + Math.imul(Ft, gr) | 0, it = it + Math.imul(Ft, _r) | 0;
      var Vr = (pt + (nt = nt + Math.imul(At, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(At, Rr) | 0) + Math.imul(Tt, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Tt, Rr) | 0) + (rt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, nt = Math.imul(nr, gr), rt = (rt = Math.imul(nr, _r)) + Math.imul(lr, gr) | 0, it = Math.imul(lr, _r);
      var zr = (pt + (nt = nt + Math.imul(Nt, wr) | 0) | 0) + ((8191 & (rt = (rt = rt + Math.imul(Nt, Rr) | 0) + Math.imul(Ft, wr) | 0)) << 13) | 0;
      pt = ((it = it + Math.imul(Ft, Rr) | 0) + (rt >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863;
      var Gr = (pt + (nt = Math.imul(nr, wr)) | 0) + ((8191 & (rt = (rt = Math.imul(nr, Rr)) + Math.imul(lr, wr) | 0)) << 13) | 0;
      return pt = ((it = Math.imul(lr, Rr)) + (rt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, ct[0] = Ir, ct[1] = Br, ct[2] = Pr, ct[3] = Mr, ct[4] = Or, ct[5] = xr, ct[6] = qr, ct[7] = Cr, ct[8] = Nr, ct[9] = Ur, ct[10] = Lr, ct[11] = jr, ct[12] = Fr, ct[13] = Dr, ct[14] = Hr, ct[15] = Wr, ct[16] = Vr, ct[17] = zr, ct[18] = Gr, pt !== 0 && (ct[19] = pt, Ce.length++), Ce;
    };
    function at(ut, ht, Ce) {
      return new ft().mulp(ut, ht, Ce);
    }
    function ft(ut, ht) {
      this.x = ut, this.y = ht;
    }
    Math.imul || (ot = ke), V.prototype.mulTo = function(ut, ht) {
      var Ce, nt = this.length + ut.length;
      return Ce = this.length === 10 && ut.length === 10 ? ot(this, ut, ht) : nt < 63 ? ke(this, ut, ht) : nt < 1024 ? function(rt, it, st) {
        st.negative = it.negative ^ rt.negative, st.length = rt.length + it.length;
        for (var Oe = 0, ct = 0, pt = 0; pt < st.length - 1; pt++) {
          var gt = ct;
          ct = 0;
          for (var vt = 67108863 & Oe, Bt = Math.min(pt, it.length - 1), kt = Math.max(0, pt - rt.length + 1); kt <= Bt; kt++) {
            var wt = pt - kt, Et = (0 | rt.words[wt]) * (0 | it.words[kt]), Rt = 67108863 & Et;
            vt = 67108863 & (Rt = Rt + vt | 0), ct += (gt = (gt = gt + (Et / 67108864 | 0) | 0) + (Rt >>> 26) | 0) >>> 26, gt &= 67108863;
          }
          st.words[pt] = vt, Oe = gt, gt = ct;
        }
        return Oe !== 0 ? st.words[pt] = Oe : st.length--, st.strip();
      }(this, ut, ht) : at(this, ut, ht), Ce;
    }, ft.prototype.makeRBT = function(ut) {
      for (var ht = new Array(ut), Ce = V.prototype._countBits(ut) - 1, nt = 0; nt < ut; nt++) ht[nt] = this.revBin(nt, Ce, ut);
      return ht;
    }, ft.prototype.revBin = function(ut, ht, Ce) {
      if (ut === 0 || ut === Ce - 1) return ut;
      for (var nt = 0, rt = 0; rt < ht; rt++) nt |= (1 & ut) << ht - rt - 1, ut >>= 1;
      return nt;
    }, ft.prototype.permute = function(ut, ht, Ce, nt, rt, it) {
      for (var st = 0; st < it; st++) nt[st] = ht[ut[st]], rt[st] = Ce[ut[st]];
    }, ft.prototype.transform = function(ut, ht, Ce, nt, rt, it) {
      this.permute(it, ut, ht, Ce, nt, rt);
      for (var st = 1; st < rt; st <<= 1) for (var Oe = st << 1, ct = Math.cos(2 * Math.PI / Oe), pt = Math.sin(2 * Math.PI / Oe), gt = 0; gt < rt; gt += Oe) for (var vt = ct, Bt = pt, kt = 0; kt < st; kt++) {
        var wt = Ce[gt + kt], Et = nt[gt + kt], Rt = Ce[gt + kt + st], Mt = nt[gt + kt + st], Ht = vt * Rt - Bt * Mt;
        Mt = vt * Mt + Bt * Rt, Rt = Ht, Ce[gt + kt] = wt + Rt, nt[gt + kt] = Et + Mt, Ce[gt + kt + st] = wt - Rt, nt[gt + kt + st] = Et - Mt, kt !== Oe && (Ht = ct * vt - pt * Bt, Bt = ct * Bt + pt * vt, vt = Ht);
      }
    }, ft.prototype.guessLen13b = function(ut, ht) {
      var Ce = 1 | Math.max(ht, ut), nt = 1 & Ce, rt = 0;
      for (Ce = Ce / 2 | 0; Ce; Ce >>>= 1) rt++;
      return 1 << rt + 1 + nt;
    }, ft.prototype.conjugate = function(ut, ht, Ce) {
      if (!(Ce <= 1)) for (var nt = 0; nt < Ce / 2; nt++) {
        var rt = ut[nt];
        ut[nt] = ut[Ce - nt - 1], ut[Ce - nt - 1] = rt, rt = ht[nt], ht[nt] = -ht[Ce - nt - 1], ht[Ce - nt - 1] = -rt;
      }
    }, ft.prototype.normalize13b = function(ut, ht) {
      for (var Ce = 0, nt = 0; nt < ht / 2; nt++) {
        var rt = 8192 * Math.round(ut[2 * nt + 1] / ht) + Math.round(ut[2 * nt] / ht) + Ce;
        ut[nt] = 67108863 & rt, Ce = rt < 67108864 ? 0 : rt / 67108864 | 0;
      }
      return ut;
    }, ft.prototype.convert13b = function(ut, ht, Ce, nt) {
      for (var rt = 0, it = 0; it < ht; it++) rt += 0 | ut[it], Ce[2 * it] = 8191 & rt, rt >>>= 13, Ce[2 * it + 1] = 8191 & rt, rt >>>= 13;
      for (it = 2 * ht; it < nt; ++it) Ce[it] = 0;
      K(rt === 0), K(!(-8192 & rt));
    }, ft.prototype.stub = function(ut) {
      for (var ht = new Array(ut), Ce = 0; Ce < ut; Ce++) ht[Ce] = 0;
      return ht;
    }, ft.prototype.mulp = function(ut, ht, Ce) {
      var nt = 2 * this.guessLen13b(ut.length, ht.length), rt = this.makeRBT(nt), it = this.stub(nt), st = new Array(nt), Oe = new Array(nt), ct = new Array(nt), pt = new Array(nt), gt = new Array(nt), vt = new Array(nt), Bt = Ce.words;
      Bt.length = nt, this.convert13b(ut.words, ut.length, st, nt), this.convert13b(ht.words, ht.length, pt, nt), this.transform(st, it, Oe, ct, nt, rt), this.transform(pt, it, gt, vt, nt, rt);
      for (var kt = 0; kt < nt; kt++) {
        var wt = Oe[kt] * gt[kt] - ct[kt] * vt[kt];
        ct[kt] = Oe[kt] * vt[kt] + ct[kt] * gt[kt], Oe[kt] = wt;
      }
      return this.conjugate(Oe, ct, nt), this.transform(Oe, ct, Bt, it, nt, rt), this.conjugate(Bt, it, nt), this.normalize13b(Bt, nt), Ce.negative = ut.negative ^ ht.negative, Ce.length = ut.length + ht.length, Ce.strip();
    }, V.prototype.mul = function(ut) {
      var ht = new V(null);
      return ht.words = new Array(this.length + ut.length), this.mulTo(ut, ht);
    }, V.prototype.mulf = function(ut) {
      var ht = new V(null);
      return ht.words = new Array(this.length + ut.length), at(this, ut, ht);
    }, V.prototype.imul = function(ut) {
      return this.clone().mulTo(ut, this);
    }, V.prototype.imuln = function(ut) {
      K(typeof ut == "number"), K(ut < 67108864);
      for (var ht = 0, Ce = 0; Ce < this.length; Ce++) {
        var nt = (0 | this.words[Ce]) * ut, rt = (67108863 & nt) + (67108863 & ht);
        ht >>= 26, ht += nt / 67108864 | 0, ht += rt >>> 26, this.words[Ce] = 67108863 & rt;
      }
      return ht !== 0 && (this.words[Ce] = ht, this.length++), this;
    }, V.prototype.muln = function(ut) {
      return this.clone().imuln(ut);
    }, V.prototype.sqr = function() {
      return this.mul(this);
    }, V.prototype.isqr = function() {
      return this.imul(this.clone());
    }, V.prototype.pow = function(ut) {
      var ht = function(it) {
        for (var st = new Array(it.bitLength()), Oe = 0; Oe < st.length; Oe++) {
          var ct = Oe / 26 | 0, pt = Oe % 26;
          st[Oe] = (it.words[ct] & 1 << pt) >>> pt;
        }
        return st;
      }(ut);
      if (ht.length === 0) return new V(1);
      for (var Ce = this, nt = 0; nt < ht.length && ht[nt] === 0; nt++, Ce = Ce.sqr()) ;
      if (++nt < ht.length) for (var rt = Ce.sqr(); nt < ht.length; nt++, rt = rt.sqr()) ht[nt] !== 0 && (Ce = Ce.mul(rt));
      return Ce;
    }, V.prototype.iushln = function(ut) {
      K(typeof ut == "number" && ut >= 0);
      var ht, Ce = ut % 26, nt = (ut - Ce) / 26, rt = 67108863 >>> 26 - Ce << 26 - Ce;
      if (Ce !== 0) {
        var it = 0;
        for (ht = 0; ht < this.length; ht++) {
          var st = this.words[ht] & rt, Oe = (0 | this.words[ht]) - st << Ce;
          this.words[ht] = Oe | it, it = st >>> 26 - Ce;
        }
        it && (this.words[ht] = it, this.length++);
      }
      if (nt !== 0) {
        for (ht = this.length - 1; ht >= 0; ht--) this.words[ht + nt] = this.words[ht];
        for (ht = 0; ht < nt; ht++) this.words[ht] = 0;
        this.length += nt;
      }
      return this.strip();
    }, V.prototype.ishln = function(ut) {
      return K(this.negative === 0), this.iushln(ut);
    }, V.prototype.iushrn = function(ut, ht, Ce) {
      var nt;
      K(typeof ut == "number" && ut >= 0), nt = ht ? (ht - ht % 26) / 26 : 0;
      var rt = ut % 26, it = Math.min((ut - rt) / 26, this.length), st = 67108863 ^ 67108863 >>> rt << rt, Oe = Ce;
      if (nt -= it, nt = Math.max(0, nt), Oe) {
        for (var ct = 0; ct < it; ct++) Oe.words[ct] = this.words[ct];
        Oe.length = it;
      }
      if (it !== 0) if (this.length > it) for (this.length -= it, ct = 0; ct < this.length; ct++) this.words[ct] = this.words[ct + it];
      else this.words[0] = 0, this.length = 1;
      var pt = 0;
      for (ct = this.length - 1; ct >= 0 && (pt !== 0 || ct >= nt); ct--) {
        var gt = 0 | this.words[ct];
        this.words[ct] = pt << 26 - rt | gt >>> rt, pt = gt & st;
      }
      return Oe && pt !== 0 && (Oe.words[Oe.length++] = pt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, V.prototype.ishrn = function(ut, ht, Ce) {
      return K(this.negative === 0), this.iushrn(ut, ht, Ce);
    }, V.prototype.shln = function(ut) {
      return this.clone().ishln(ut);
    }, V.prototype.ushln = function(ut) {
      return this.clone().iushln(ut);
    }, V.prototype.shrn = function(ut) {
      return this.clone().ishrn(ut);
    }, V.prototype.ushrn = function(ut) {
      return this.clone().iushrn(ut);
    }, V.prototype.testn = function(ut) {
      K(typeof ut == "number" && ut >= 0);
      var ht = ut % 26, Ce = (ut - ht) / 26, nt = 1 << ht;
      return !(this.length <= Ce || !(this.words[Ce] & nt));
    }, V.prototype.imaskn = function(ut) {
      K(typeof ut == "number" && ut >= 0);
      var ht = ut % 26, Ce = (ut - ht) / 26;
      if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ce) return this;
      if (ht !== 0 && Ce++, this.length = Math.min(Ce, this.length), ht !== 0) {
        var nt = 67108863 ^ 67108863 >>> ht << ht;
        this.words[this.length - 1] &= nt;
      }
      return this.strip();
    }, V.prototype.maskn = function(ut) {
      return this.clone().imaskn(ut);
    }, V.prototype.iaddn = function(ut) {
      return K(typeof ut == "number"), K(ut < 67108864), ut < 0 ? this.isubn(-ut) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < ut ? (this.words[0] = ut - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(ut), this.negative = 1, this) : this._iaddn(ut);
    }, V.prototype._iaddn = function(ut) {
      this.words[0] += ut;
      for (var ht = 0; ht < this.length && this.words[ht] >= 67108864; ht++) this.words[ht] -= 67108864, ht === this.length - 1 ? this.words[ht + 1] = 1 : this.words[ht + 1]++;
      return this.length = Math.max(this.length, ht + 1), this;
    }, V.prototype.isubn = function(ut) {
      if (K(typeof ut == "number"), K(ut < 67108864), ut < 0) return this.iaddn(-ut);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(ut), this.negative = 1, this;
      if (this.words[0] -= ut, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var ht = 0; ht < this.length && this.words[ht] < 0; ht++) this.words[ht] += 67108864, this.words[ht + 1] -= 1;
      return this.strip();
    }, V.prototype.addn = function(ut) {
      return this.clone().iaddn(ut);
    }, V.prototype.subn = function(ut) {
      return this.clone().isubn(ut);
    }, V.prototype.iabs = function() {
      return this.negative = 0, this;
    }, V.prototype.abs = function() {
      return this.clone().iabs();
    }, V.prototype._ishlnsubmul = function(ut, ht, Ce) {
      var nt, rt, it = ut.length + Ce;
      this._expand(it);
      var st = 0;
      for (nt = 0; nt < ut.length; nt++) {
        rt = (0 | this.words[nt + Ce]) + st;
        var Oe = (0 | ut.words[nt]) * ht;
        st = ((rt -= 67108863 & Oe) >> 26) - (Oe / 67108864 | 0), this.words[nt + Ce] = 67108863 & rt;
      }
      for (; nt < this.length - Ce; nt++) st = (rt = (0 | this.words[nt + Ce]) + st) >> 26, this.words[nt + Ce] = 67108863 & rt;
      if (st === 0) return this.strip();
      for (K(st === -1), st = 0, nt = 0; nt < this.length; nt++) st = (rt = -(0 | this.words[nt]) + st) >> 26, this.words[nt] = 67108863 & rt;
      return this.negative = 1, this.strip();
    }, V.prototype._wordDiv = function(ut, ht) {
      var Ce = (this.length, ut.length), nt = this.clone(), rt = ut, it = 0 | rt.words[rt.length - 1];
      (Ce = 26 - this._countBits(it)) != 0 && (rt = rt.ushln(Ce), nt.iushln(Ce), it = 0 | rt.words[rt.length - 1]);
      var st, Oe = nt.length - rt.length;
      if (ht !== "mod") {
        (st = new V(null)).length = Oe + 1, st.words = new Array(st.length);
        for (var ct = 0; ct < st.length; ct++) st.words[ct] = 0;
      }
      var pt = nt.clone()._ishlnsubmul(rt, 1, Oe);
      pt.negative === 0 && (nt = pt, st && (st.words[Oe] = 1));
      for (var gt = Oe - 1; gt >= 0; gt--) {
        var vt = 67108864 * (0 | nt.words[rt.length + gt]) + (0 | nt.words[rt.length + gt - 1]);
        for (vt = Math.min(vt / it | 0, 67108863), nt._ishlnsubmul(rt, vt, gt); nt.negative !== 0; ) vt--, nt.negative = 0, nt._ishlnsubmul(rt, 1, gt), nt.isZero() || (nt.negative ^= 1);
        st && (st.words[gt] = vt);
      }
      return st && st.strip(), nt.strip(), ht !== "div" && Ce !== 0 && nt.iushrn(Ce), { div: st || null, mod: nt };
    }, V.prototype.divmod = function(ut, ht, Ce) {
      return K(!ut.isZero()), this.isZero() ? { div: new V(0), mod: new V(0) } : this.negative !== 0 && ut.negative === 0 ? (it = this.neg().divmod(ut, ht), ht !== "mod" && (nt = it.div.neg()), ht !== "div" && (rt = it.mod.neg(), Ce && rt.negative !== 0 && rt.iadd(ut)), { div: nt, mod: rt }) : this.negative === 0 && ut.negative !== 0 ? (it = this.divmod(ut.neg(), ht), ht !== "mod" && (nt = it.div.neg()), { div: nt, mod: it.mod }) : this.negative & ut.negative ? (it = this.neg().divmod(ut.neg(), ht), ht !== "div" && (rt = it.mod.neg(), Ce && rt.negative !== 0 && rt.isub(ut)), { div: it.div, mod: rt }) : ut.length > this.length || this.cmp(ut) < 0 ? { div: new V(0), mod: this } : ut.length === 1 ? ht === "div" ? { div: this.divn(ut.words[0]), mod: null } : ht === "mod" ? { div: null, mod: new V(this.modn(ut.words[0])) } : { div: this.divn(ut.words[0]), mod: new V(this.modn(ut.words[0])) } : this._wordDiv(ut, ht);
      var nt, rt, it;
    }, V.prototype.div = function(ut) {
      return this.divmod(ut, "div", !1).div;
    }, V.prototype.mod = function(ut) {
      return this.divmod(ut, "mod", !1).mod;
    }, V.prototype.umod = function(ut) {
      return this.divmod(ut, "mod", !0).mod;
    }, V.prototype.divRound = function(ut) {
      var ht = this.divmod(ut);
      if (ht.mod.isZero()) return ht.div;
      var Ce = ht.div.negative !== 0 ? ht.mod.isub(ut) : ht.mod, nt = ut.ushrn(1), rt = ut.andln(1), it = Ce.cmp(nt);
      return it < 0 || rt === 1 && it === 0 ? ht.div : ht.div.negative !== 0 ? ht.div.isubn(1) : ht.div.iaddn(1);
    }, V.prototype.modn = function(ut) {
      K(ut <= 67108863);
      for (var ht = (1 << 26) % ut, Ce = 0, nt = this.length - 1; nt >= 0; nt--) Ce = (ht * Ce + (0 | this.words[nt])) % ut;
      return Ce;
    }, V.prototype.idivn = function(ut) {
      K(ut <= 67108863);
      for (var ht = 0, Ce = this.length - 1; Ce >= 0; Ce--) {
        var nt = (0 | this.words[Ce]) + 67108864 * ht;
        this.words[Ce] = nt / ut | 0, ht = nt % ut;
      }
      return this.strip();
    }, V.prototype.divn = function(ut) {
      return this.clone().idivn(ut);
    }, V.prototype.egcd = function(ut) {
      K(ut.negative === 0), K(!ut.isZero());
      var ht = this, Ce = ut.clone();
      ht = ht.negative !== 0 ? ht.umod(ut) : ht.clone();
      for (var nt = new V(1), rt = new V(0), it = new V(0), st = new V(1), Oe = 0; ht.isEven() && Ce.isEven(); ) ht.iushrn(1), Ce.iushrn(1), ++Oe;
      for (var ct = Ce.clone(), pt = ht.clone(); !ht.isZero(); ) {
        for (var gt = 0, vt = 1; !(ht.words[0] & vt) && gt < 26; ++gt, vt <<= 1) ;
        if (gt > 0) for (ht.iushrn(gt); gt-- > 0; ) (nt.isOdd() || rt.isOdd()) && (nt.iadd(ct), rt.isub(pt)), nt.iushrn(1), rt.iushrn(1);
        for (var Bt = 0, kt = 1; !(Ce.words[0] & kt) && Bt < 26; ++Bt, kt <<= 1) ;
        if (Bt > 0) for (Ce.iushrn(Bt); Bt-- > 0; ) (it.isOdd() || st.isOdd()) && (it.iadd(ct), st.isub(pt)), it.iushrn(1), st.iushrn(1);
        ht.cmp(Ce) >= 0 ? (ht.isub(Ce), nt.isub(it), rt.isub(st)) : (Ce.isub(ht), it.isub(nt), st.isub(rt));
      }
      return { a: it, b: st, gcd: Ce.iushln(Oe) };
    }, V.prototype._invmp = function(ut) {
      K(ut.negative === 0), K(!ut.isZero());
      var ht = this, Ce = ut.clone();
      ht = ht.negative !== 0 ? ht.umod(ut) : ht.clone();
      for (var nt, rt = new V(1), it = new V(0), st = Ce.clone(); ht.cmpn(1) > 0 && Ce.cmpn(1) > 0; ) {
        for (var Oe = 0, ct = 1; !(ht.words[0] & ct) && Oe < 26; ++Oe, ct <<= 1) ;
        if (Oe > 0) for (ht.iushrn(Oe); Oe-- > 0; ) rt.isOdd() && rt.iadd(st), rt.iushrn(1);
        for (var pt = 0, gt = 1; !(Ce.words[0] & gt) && pt < 26; ++pt, gt <<= 1) ;
        if (pt > 0) for (Ce.iushrn(pt); pt-- > 0; ) it.isOdd() && it.iadd(st), it.iushrn(1);
        ht.cmp(Ce) >= 0 ? (ht.isub(Ce), rt.isub(it)) : (Ce.isub(ht), it.isub(rt));
      }
      return (nt = ht.cmpn(1) === 0 ? rt : it).cmpn(0) < 0 && nt.iadd(ut), nt;
    }, V.prototype.gcd = function(ut) {
      if (this.isZero()) return ut.abs();
      if (ut.isZero()) return this.abs();
      var ht = this.clone(), Ce = ut.clone();
      ht.negative = 0, Ce.negative = 0;
      for (var nt = 0; ht.isEven() && Ce.isEven(); nt++) ht.iushrn(1), Ce.iushrn(1);
      for (; ; ) {
        for (; ht.isEven(); ) ht.iushrn(1);
        for (; Ce.isEven(); ) Ce.iushrn(1);
        var rt = ht.cmp(Ce);
        if (rt < 0) {
          var it = ht;
          ht = Ce, Ce = it;
        } else if (rt === 0 || Ce.cmpn(1) === 0) break;
        ht.isub(Ce);
      }
      return Ce.iushln(nt);
    }, V.prototype.invm = function(ut) {
      return this.egcd(ut).a.umod(ut);
    }, V.prototype.isEven = function() {
      return !(1 & this.words[0]);
    }, V.prototype.isOdd = function() {
      return !(1 & ~this.words[0]);
    }, V.prototype.andln = function(ut) {
      return this.words[0] & ut;
    }, V.prototype.bincn = function(ut) {
      K(typeof ut == "number");
      var ht = ut % 26, Ce = (ut - ht) / 26, nt = 1 << ht;
      if (this.length <= Ce) return this._expand(Ce + 1), this.words[Ce] |= nt, this;
      for (var rt = nt, it = Ce; rt !== 0 && it < this.length; it++) {
        var st = 0 | this.words[it];
        rt = (st += rt) >>> 26, st &= 67108863, this.words[it] = st;
      }
      return rt !== 0 && (this.words[it] = rt, this.length++), this;
    }, V.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, V.prototype.cmpn = function(ut) {
      var ht, Ce = ut < 0;
      if (this.negative !== 0 && !Ce) return -1;
      if (this.negative === 0 && Ce) return 1;
      if (this.strip(), this.length > 1) ht = 1;
      else {
        Ce && (ut = -ut), K(ut <= 67108863, "Number is too big");
        var nt = 0 | this.words[0];
        ht = nt === ut ? 0 : nt < ut ? -1 : 1;
      }
      return this.negative !== 0 ? 0 | -ht : ht;
    }, V.prototype.cmp = function(ut) {
      if (this.negative !== 0 && ut.negative === 0) return -1;
      if (this.negative === 0 && ut.negative !== 0) return 1;
      var ht = this.ucmp(ut);
      return this.negative !== 0 ? 0 | -ht : ht;
    }, V.prototype.ucmp = function(ut) {
      if (this.length > ut.length) return 1;
      if (this.length < ut.length) return -1;
      for (var ht = 0, Ce = this.length - 1; Ce >= 0; Ce--) {
        var nt = 0 | this.words[Ce], rt = 0 | ut.words[Ce];
        if (nt !== rt) {
          nt < rt ? ht = -1 : nt > rt && (ht = 1);
          break;
        }
      }
      return ht;
    }, V.prototype.gtn = function(ut) {
      return this.cmpn(ut) === 1;
    }, V.prototype.gt = function(ut) {
      return this.cmp(ut) === 1;
    }, V.prototype.gten = function(ut) {
      return this.cmpn(ut) >= 0;
    }, V.prototype.gte = function(ut) {
      return this.cmp(ut) >= 0;
    }, V.prototype.ltn = function(ut) {
      return this.cmpn(ut) === -1;
    }, V.prototype.lt = function(ut) {
      return this.cmp(ut) === -1;
    }, V.prototype.lten = function(ut) {
      return this.cmpn(ut) <= 0;
    }, V.prototype.lte = function(ut) {
      return this.cmp(ut) <= 0;
    }, V.prototype.eqn = function(ut) {
      return this.cmpn(ut) === 0;
    }, V.prototype.eq = function(ut) {
      return this.cmp(ut) === 0;
    }, V.red = function(ut) {
      return new It(ut);
    }, V.prototype.toRed = function(ut) {
      return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), ut.convertTo(this)._forceRed(ut);
    }, V.prototype.fromRed = function() {
      return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, V.prototype._forceRed = function(ut) {
      return this.red = ut, this;
    }, V.prototype.forceRed = function(ut) {
      return K(!this.red, "Already a number in reduction context"), this._forceRed(ut);
    }, V.prototype.redAdd = function(ut) {
      return K(this.red, "redAdd works only with red numbers"), this.red.add(this, ut);
    }, V.prototype.redIAdd = function(ut) {
      return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ut);
    }, V.prototype.redSub = function(ut) {
      return K(this.red, "redSub works only with red numbers"), this.red.sub(this, ut);
    }, V.prototype.redISub = function(ut) {
      return K(this.red, "redISub works only with red numbers"), this.red.isub(this, ut);
    }, V.prototype.redShl = function(ut) {
      return K(this.red, "redShl works only with red numbers"), this.red.shl(this, ut);
    }, V.prototype.redMul = function(ut) {
      return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, ut), this.red.mul(this, ut);
    }, V.prototype.redIMul = function(ut) {
      return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, ut), this.red.imul(this, ut);
    }, V.prototype.redSqr = function() {
      return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, V.prototype.redISqr = function() {
      return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, V.prototype.redSqrt = function() {
      return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, V.prototype.redInvm = function() {
      return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, V.prototype.redNeg = function() {
      return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, V.prototype.redPow = function(ut) {
      return K(this.red && !ut.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ut);
    };
    var dt = { k256: null, p224: null, p192: null, p25519: null };
    function lt(ut, ht) {
      this.name = ut, this.p = new V(ht, 16), this.n = this.p.bitLength(), this.k = new V(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    function yt() {
      lt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    function St() {
      lt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    function mt() {
      lt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    function $t() {
      lt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    function It(ut) {
      if (typeof ut == "string") {
        var ht = V._prime(ut);
        this.m = ht.p, this.prime = ht;
      } else K(ut.gtn(1), "modulus must be greater than 1"), this.m = ut, this.prime = null;
    }
    function Ut(ut) {
      It.call(this, ut), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new V(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    lt.prototype._tmp = function() {
      var ut = new V(null);
      return ut.words = new Array(Math.ceil(this.n / 13)), ut;
    }, lt.prototype.ireduce = function(ut) {
      var ht, Ce = ut;
      do
        this.split(Ce, this.tmp), ht = (Ce = (Ce = this.imulK(Ce)).iadd(this.tmp)).bitLength();
      while (ht > this.n);
      var nt = ht < this.n ? -1 : Ce.ucmp(this.p);
      return nt === 0 ? (Ce.words[0] = 0, Ce.length = 1) : nt > 0 ? Ce.isub(this.p) : Ce.strip !== void 0 ? Ce.strip() : Ce._strip(), Ce;
    }, lt.prototype.split = function(ut, ht) {
      ut.iushrn(this.n, 0, ht);
    }, lt.prototype.imulK = function(ut) {
      return ut.imul(this.k);
    }, W(yt, lt), yt.prototype.split = function(ut, ht) {
      for (var Ce = 4194303, nt = Math.min(ut.length, 9), rt = 0; rt < nt; rt++) ht.words[rt] = ut.words[rt];
      if (ht.length = nt, ut.length <= 9) return ut.words[0] = 0, void (ut.length = 1);
      var it = ut.words[9];
      for (ht.words[ht.length++] = it & Ce, rt = 10; rt < ut.length; rt++) {
        var st = 0 | ut.words[rt];
        ut.words[rt - 10] = (st & Ce) << 4 | it >>> 22, it = st;
      }
      it >>>= 22, ut.words[rt - 10] = it, it === 0 && ut.length > 10 ? ut.length -= 10 : ut.length -= 9;
    }, yt.prototype.imulK = function(ut) {
      ut.words[ut.length] = 0, ut.words[ut.length + 1] = 0, ut.length += 2;
      for (var ht = 0, Ce = 0; Ce < ut.length; Ce++) {
        var nt = 0 | ut.words[Ce];
        ht += 977 * nt, ut.words[Ce] = 67108863 & ht, ht = 64 * nt + (ht / 67108864 | 0);
      }
      return ut.words[ut.length - 1] === 0 && (ut.length--, ut.words[ut.length - 1] === 0 && ut.length--), ut;
    }, W(St, lt), W(mt, lt), W($t, lt), $t.prototype.imulK = function(ut) {
      for (var ht = 0, Ce = 0; Ce < ut.length; Ce++) {
        var nt = 19 * (0 | ut.words[Ce]) + ht, rt = 67108863 & nt;
        nt >>>= 26, ut.words[Ce] = rt, ht = nt;
      }
      return ht !== 0 && (ut.words[ut.length++] = ht), ut;
    }, V._prime = function(ut) {
      if (dt[ut]) return dt[ut];
      var ht;
      if (ut === "k256") ht = new yt();
      else if (ut === "p224") ht = new St();
      else if (ut === "p192") ht = new mt();
      else {
        if (ut !== "p25519") throw new Error("Unknown prime " + ut);
        ht = new $t();
      }
      return dt[ut] = ht, ht;
    }, It.prototype._verify1 = function(ut) {
      K(ut.negative === 0, "red works only with positives"), K(ut.red, "red works only with red numbers");
    }, It.prototype._verify2 = function(ut, ht) {
      K(!(ut.negative | ht.negative), "red works only with positives"), K(ut.red && ut.red === ht.red, "red works only with red numbers");
    }, It.prototype.imod = function(ut) {
      return this.prime ? this.prime.ireduce(ut)._forceRed(this) : ut.umod(this.m)._forceRed(this);
    }, It.prototype.neg = function(ut) {
      return ut.isZero() ? ut.clone() : this.m.sub(ut)._forceRed(this);
    }, It.prototype.add = function(ut, ht) {
      this._verify2(ut, ht);
      var Ce = ut.add(ht);
      return Ce.cmp(this.m) >= 0 && Ce.isub(this.m), Ce._forceRed(this);
    }, It.prototype.iadd = function(ut, ht) {
      this._verify2(ut, ht);
      var Ce = ut.iadd(ht);
      return Ce.cmp(this.m) >= 0 && Ce.isub(this.m), Ce;
    }, It.prototype.sub = function(ut, ht) {
      this._verify2(ut, ht);
      var Ce = ut.sub(ht);
      return Ce.cmpn(0) < 0 && Ce.iadd(this.m), Ce._forceRed(this);
    }, It.prototype.isub = function(ut, ht) {
      this._verify2(ut, ht);
      var Ce = ut.isub(ht);
      return Ce.cmpn(0) < 0 && Ce.iadd(this.m), Ce;
    }, It.prototype.shl = function(ut, ht) {
      return this._verify1(ut), this.imod(ut.ushln(ht));
    }, It.prototype.imul = function(ut, ht) {
      return this._verify2(ut, ht), this.imod(ut.imul(ht));
    }, It.prototype.mul = function(ut, ht) {
      return this._verify2(ut, ht), this.imod(ut.mul(ht));
    }, It.prototype.isqr = function(ut) {
      return this.imul(ut, ut.clone());
    }, It.prototype.sqr = function(ut) {
      return this.mul(ut, ut);
    }, It.prototype.sqrt = function(ut) {
      if (ut.isZero()) return ut.clone();
      var ht = this.m.andln(3);
      if (K(ht % 2 == 1), ht === 3) {
        var Ce = this.m.add(new V(1)).iushrn(2);
        return this.pow(ut, Ce);
      }
      for (var nt = this.m.subn(1), rt = 0; !nt.isZero() && nt.andln(1) === 0; ) rt++, nt.iushrn(1);
      K(!nt.isZero());
      var it = new V(1).toRed(this), st = it.redNeg(), Oe = this.m.subn(1).iushrn(1), ct = this.m.bitLength();
      for (ct = new V(2 * ct * ct).toRed(this); this.pow(ct, Oe).cmp(st) !== 0; ) ct.redIAdd(st);
      for (var pt = this.pow(ct, nt), gt = this.pow(ut, nt.addn(1).iushrn(1)), vt = this.pow(ut, nt), Bt = rt; vt.cmp(it) !== 0; ) {
        for (var kt = vt, wt = 0; kt.cmp(it) !== 0; wt++) kt = kt.redSqr();
        K(wt < Bt);
        var Et = this.pow(pt, new V(1).iushln(Bt - wt - 1));
        gt = gt.redMul(Et), pt = Et.redSqr(), vt = vt.redMul(pt), Bt = wt;
      }
      return gt;
    }, It.prototype.invm = function(ut) {
      var ht = ut._invmp(this.m);
      return ht.negative !== 0 ? (ht.negative = 0, this.imod(ht).redNeg()) : this.imod(ht);
    }, It.prototype.pow = function(ut, ht) {
      if (ht.isZero()) return new V(1).toRed(this);
      if (ht.cmpn(1) === 0) return ut.clone();
      var Ce = new Array(16);
      Ce[0] = new V(1).toRed(this), Ce[1] = ut;
      for (var nt = 2; nt < Ce.length; nt++) Ce[nt] = this.mul(Ce[nt - 1], ut);
      var rt = Ce[0], it = 0, st = 0, Oe = ht.bitLength() % 26;
      for (Oe === 0 && (Oe = 26), nt = ht.length - 1; nt >= 0; nt--) {
        for (var ct = ht.words[nt], pt = Oe - 1; pt >= 0; pt--) {
          var gt = ct >> pt & 1;
          rt !== Ce[0] && (rt = this.sqr(rt)), gt !== 0 || it !== 0 ? (it <<= 1, it |= gt, (++st == 4 || nt === 0 && pt === 0) && (rt = this.mul(rt, Ce[it]), st = 0, it = 0)) : st = 0;
        }
        Oe = 26;
      }
      return rt;
    }, It.prototype.convertTo = function(ut) {
      var ht = ut.umod(this.m);
      return ht === ut ? ht.clone() : ht;
    }, It.prototype.convertFrom = function(ut) {
      var ht = ut.clone();
      return ht.red = null, ht;
    }, V.mont = function(ut) {
      return new Ut(ut);
    }, W(Ut, It), Ut.prototype.convertTo = function(ut) {
      return this.imod(ut.ushln(this.shift));
    }, Ut.prototype.convertFrom = function(ut) {
      var ht = this.imod(ut.mul(this.rinv));
      return ht.red = null, ht;
    }, Ut.prototype.imul = function(ut, ht) {
      if (ut.isZero() || ht.isZero()) return ut.words[0] = 0, ut.length = 1, ut;
      var Ce = ut.imul(ht), nt = Ce.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), rt = Ce.isub(nt).iushrn(this.shift), it = rt;
      return rt.cmp(this.m) >= 0 ? it = rt.isub(this.m) : rt.cmpn(0) < 0 && (it = rt.iadd(this.m)), it._forceRed(this);
    }, Ut.prototype.mul = function(ut, ht) {
      if (ut.isZero() || ht.isZero()) return new V(0)._forceRed(this);
      var Ce = ut.mul(ht), nt = Ce.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), rt = Ce.isub(nt).iushrn(this.shift), it = rt;
      return rt.cmp(this.m) >= 0 ? it = rt.isub(this.m) : rt.cmpn(0) < 0 && (it = rt.iadd(this.m)), it._forceRed(this);
    }, Ut.prototype.invm = function(ut) {
      return this.imod(ut._invmp(this.m).mul(this.r2))._forceRed(this);
    };
  }(0, commonjsGlobal)), bn$1.exports;
}
bn$1.exports;
var brorand = { exports: {} }, hasRequiredBrorand, mr, hasRequiredMr, generatePrime, hasRequiredGeneratePrime;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  var B;
  function L(W) {
    this.rand = W;
  }
  if (hasRequiredBrorand = 1, brorand.exports = function(W) {
    return B || (B = new L(null)), B.generate(W);
  }, brorand.exports.Rand = L, L.prototype.generate = function(W) {
    return this._rand(W);
  }, L.prototype._rand = function(W) {
    if (this.rand.getBytes) return this.rand.getBytes(W);
    for (var V = new Uint8Array(W), J = 0; J < V.length; J++) V[J] = this.rand.getByte();
    return V;
  }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? L.prototype._rand = function(W) {
    var V = new Uint8Array(W);
    return self.crypto.getRandomValues(V), V;
  } : self.msCrypto && self.msCrypto.getRandomValues ? L.prototype._rand = function(W) {
    var V = new Uint8Array(W);
    return self.msCrypto.getRandomValues(V), V;
  } : typeof window == "object" && (L.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
  else try {
    var K = requireCryptoBrowserify();
    if (typeof K.randomBytes != "function") throw new Error("Not supported");
    L.prototype._rand = function(W) {
      return K.randomBytes(W);
    };
  } catch {
  }
  return brorand.exports;
}
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = requireBn$1(), L = requireBrorand();
  function K(W) {
    this.rand = W || new L.Rand();
  }
  return mr = K, K.create = function(W) {
    return new K(W);
  }, K.prototype._randbelow = function(W) {
    var V = W.bitLength(), J = Math.ceil(V / 8);
    do
      var re = new B(this.rand.generate(J));
    while (re.cmp(W) >= 0);
    return re;
  }, K.prototype._randrange = function(W, V) {
    var J = V.sub(W);
    return W.add(this._randbelow(J));
  }, K.prototype.test = function(W, V, J) {
    var re = W.bitLength(), ie = B.mont(W), ne = new B(1).toRed(ie);
    V || (V = Math.max(1, re / 48 | 0));
    for (var oe = W.subn(1), ce = 0; !oe.testn(ce); ce++) ;
    for (var pe = W.shrn(ce), ke = oe.toRed(ie); V > 0; V--) {
      var ot = this._randrange(new B(2), oe);
      J && J(ot);
      var at = ot.toRed(ie).redPow(pe);
      if (at.cmp(ne) !== 0 && at.cmp(ke) !== 0) {
        for (var ft = 1; ft < ce; ft++) {
          if ((at = at.redSqr()).cmp(ne) === 0) return !1;
          if (at.cmp(ke) === 0) break;
        }
        if (ft === ce) return !1;
      }
    }
    return !0;
  }, K.prototype.getDivisor = function(W, V) {
    var J = W.bitLength(), re = B.mont(W), ie = new B(1).toRed(re);
    V || (V = Math.max(1, J / 48 | 0));
    for (var ne = W.subn(1), oe = 0; !ne.testn(oe); oe++) ;
    for (var ce = W.shrn(oe), pe = ne.toRed(re); V > 0; V--) {
      var ke = this._randrange(new B(2), ne), ot = W.gcd(ke);
      if (ot.cmpn(1) !== 0) return ot;
      var at = ke.toRed(re).redPow(ce);
      if (at.cmp(ie) !== 0 && at.cmp(pe) !== 0) {
        for (var ft = 1; ft < oe; ft++) {
          if ((at = at.redSqr()).cmp(ie) === 0) return at.fromRed().subn(1).gcd(W);
          if (at.cmp(pe) === 0) break;
        }
        if (ft === oe) return (at = at.redSqr()).fromRed().subn(1).gcd(W);
      }
    }
    return !1;
  }, mr;
}
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = browserExports;
  generatePrime = ft, ft.simpleSieve = ot, ft.fermatTest = at;
  var L = requireBn$1(), K = new L(24), W = new (requireMr())(), V = new L(1), J = new L(2), re = new L(5);
  new L(16), new L(8);
  var ie = new L(10), ne = new L(3);
  new L(7);
  var oe = new L(11), ce = new L(4);
  new L(12);
  var pe = null;
  function ke() {
    if (pe !== null) return pe;
    var dt = [];
    dt[0] = 2;
    for (var lt = 1, yt = 3; yt < 1048576; yt += 2) {
      for (var St = Math.ceil(Math.sqrt(yt)), mt = 0; mt < lt && dt[mt] <= St && yt % dt[mt] != 0; mt++) ;
      lt !== mt && dt[mt] <= St || (dt[lt++] = yt);
    }
    return pe = dt, dt;
  }
  function ot(dt) {
    for (var lt = ke(), yt = 0; yt < lt.length; yt++) if (dt.modn(lt[yt]) === 0) return dt.cmpn(lt[yt]) === 0;
    return !0;
  }
  function at(dt) {
    var lt = L.mont(dt);
    return J.toRed(lt).redPow(dt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ft(dt, lt) {
    if (dt < 16) return new L(lt === 2 || lt === 5 ? [140, 123] : [140, 39]);
    var yt, St;
    for (lt = new L(lt); ; ) {
      for (yt = new L(B(Math.ceil(dt / 8))); yt.bitLength() > dt; ) yt.ishrn(1);
      if (yt.isEven() && yt.iadd(V), yt.testn(1) || yt.iadd(J), lt.cmp(J)) {
        if (!lt.cmp(re)) for (; yt.mod(ie).cmp(ne); ) yt.iadd(ce);
      } else for (; yt.mod(K).cmp(oe); ) yt.iadd(ce);
      if (ot(St = yt.shrn(1)) && ot(yt) && at(St) && at(yt) && W.test(St) && W.test(yt)) return yt;
    }
  }
  return generatePrime;
}
const modp1 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" }, require$$1$1 = { modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18 };
var dh, hasRequiredDh, hasRequiredBrowser$4;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = requireBn$1(), L = new (requireMr())(), K = new B(24), W = new B(11), V = new B(10), J = new B(3), re = new B(7), ie = requireGeneratePrime(), ne = browserExports;
  function oe(at, ft) {
    return ft = ft || "utf8", Buffer$3.isBuffer(at) || (at = new Buffer$3(at, ft)), this._pub = new B(at), this;
  }
  function ce(at, ft) {
    return ft = ft || "utf8", Buffer$3.isBuffer(at) || (at = new Buffer$3(at, ft)), this._priv = new B(at), this;
  }
  dh = ke;
  var pe = {};
  function ke(at, ft, dt) {
    this.setGenerator(ft), this.__prime = new B(at), this._prime = B.mont(this.__prime), this._primeLen = at.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, dt ? (this.setPublicKey = oe, this.setPrivateKey = ce) : this._primeCode = 8;
  }
  function ot(at, ft) {
    var dt = new Buffer$3(at.toArray());
    return ft ? dt.toString(ft) : dt;
  }
  return Object.defineProperty(ke.prototype, "verifyError", { enumerable: !0, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = function(at, ft) {
      var dt = ft.toString("hex"), lt = [dt, at.toString(16)].join("_");
      if (lt in pe) return pe[lt];
      var yt, St = 0;
      if (at.isEven() || !ie.simpleSieve || !ie.fermatTest(at) || !L.test(at)) return St += 1, St += dt === "02" || dt === "05" ? 8 : 4, pe[lt] = St, St;
      switch (L.test(at.shrn(1)) || (St += 2), dt) {
        case "02":
          at.mod(K).cmp(W) && (St += 8);
          break;
        case "05":
          (yt = at.mod(V)).cmp(J) && yt.cmp(re) && (St += 8);
          break;
        default:
          St += 4;
      }
      return pe[lt] = St, St;
    }(this.__prime, this.__gen)), this._primeCode;
  } }), ke.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(ne(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, ke.prototype.computeSecret = function(at) {
    var ft = (at = (at = new B(at)).toRed(this._prime)).redPow(this._priv).fromRed(), dt = new Buffer$3(ft.toArray()), lt = this.getPrime();
    if (dt.length < lt.length) {
      var yt = new Buffer$3(lt.length - dt.length);
      yt.fill(0), dt = Buffer$3.concat([yt, dt]);
    }
    return dt;
  }, ke.prototype.getPublicKey = function(at) {
    return ot(this._pub, at);
  }, ke.prototype.getPrivateKey = function(at) {
    return ot(this._priv, at);
  }, ke.prototype.getPrime = function(at) {
    return ot(this.__prime, at);
  }, ke.prototype.getGenerator = function(at) {
    return ot(this._gen, at);
  }, ke.prototype.setGenerator = function(at, ft) {
    return ft = ft || "utf8", Buffer$3.isBuffer(at) || (at = new Buffer$3(at, ft)), this.__gen = at, this._gen = new B(at), this;
  }, dh;
}
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var B = requireGeneratePrime(), L = require$$1$1, K = requireDh(), W = { binary: !0, hex: !0, base64: !0 };
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = function(V) {
    var J = new Buffer$3(L[V].prime, "hex"), re = new Buffer$3(L[V].gen, "hex");
    return new K(J, re);
  }, browser$4.createDiffieHellman = browser$4.DiffieHellman = function V(J, re, ie, ne) {
    return Buffer$3.isBuffer(re) || W[re] === void 0 ? V(J, "binary", re, ie) : (re = re || "binary", ne = ne || "binary", ie = ie || new Buffer$3([2]), Buffer$3.isBuffer(ie) || (ie = new Buffer$3(ie, ne)), typeof J == "number" ? new K(B(J, ie), ie, !0) : (Buffer$3.isBuffer(J) || (J = new Buffer$3(J, re)), new K(J, ie, !0)));
  }, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs, isarray, hasRequiredIsarray, streamBrowser, hasRequiredStreamBrowser;
function requireProcessNextickArgs() {
  return hasRequiredProcessNextickArgs || (hasRequiredProcessNextickArgs = 1, process$1 === void 0 || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: function(B, L, K, W) {
    if (typeof B != "function") throw new TypeError('"callback" argument must be a function');
    var V, J, re = arguments.length;
    switch (re) {
      case 0:
      case 1:
        return process$1.nextTick(B);
      case 2:
        return process$1.nextTick(function() {
          B.call(null, L);
        });
      case 3:
        return process$1.nextTick(function() {
          B.call(null, L, K);
        });
      case 4:
        return process$1.nextTick(function() {
          B.call(null, L, K, W);
        });
      default:
        for (V = new Array(re - 1), J = 0; J < V.length; ) V[J++] = arguments[J];
        return process$1.nextTick(function() {
          B.apply(null, V);
        });
    }
  } } : processNextickArgs.exports = process$1), processNextickArgs.exports;
}
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var B = {}.toString;
  return isarray = Array.isArray || function(L) {
    return B.call(L) == "[object Array]";
  };
}
function requireStreamBrowser() {
  return hasRequiredStreamBrowser ? streamBrowser : (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter);
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(B, L) {
    var K = require$$1$2, W = K.Buffer;
    function V(re, ie) {
      for (var ne in re) ie[ne] = re[ne];
    }
    function J(re, ie, ne) {
      return W(re, ie, ne);
    }
    W.from && W.alloc && W.allocUnsafe && W.allocUnsafeSlow ? B.exports = K : (V(K, L), L.Buffer = J), V(W, J), J.from = function(re, ie, ne) {
      if (typeof re == "number") throw new TypeError("Argument must not be a number");
      return W(re, ie, ne);
    }, J.alloc = function(re, ie, ne) {
      if (typeof re != "number") throw new TypeError("Argument must be a number");
      var oe = W(re);
      return ie !== void 0 ? typeof ne == "string" ? oe.fill(ie, ne) : oe.fill(ie) : oe.fill(0), oe;
    }, J.allocUnsafe = function(re) {
      if (typeof re != "number") throw new TypeError("Argument must be a number");
      return W(re);
    }, J.allocUnsafeSlow = function(re) {
      if (typeof re != "number") throw new TypeError("Argument must be a number");
      return K.SlowBuffer(re);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  function B(L) {
    return Object.prototype.toString.call(L);
  }
  return hasRequiredUtil = 1, util.isArray = function(L) {
    return Array.isArray ? Array.isArray(L) : B(L) === "[object Array]";
  }, util.isBoolean = function(L) {
    return typeof L == "boolean";
  }, util.isNull = function(L) {
    return L === null;
  }, util.isNullOrUndefined = function(L) {
    return L == null;
  }, util.isNumber = function(L) {
    return typeof L == "number";
  }, util.isString = function(L) {
    return typeof L == "string";
  }, util.isSymbol = function(L) {
    return typeof L == "symbol";
  }, util.isUndefined = function(L) {
    return L === void 0;
  }, util.isRegExp = function(L) {
    return B(L) === "[object RegExp]";
  }, util.isObject = function(L) {
    return typeof L == "object" && L !== null;
  }, util.isDate = function(L) {
    return B(L) === "[object Date]";
  }, util.isError = function(L) {
    return B(L) === "[object Error]" || L instanceof Error;
  }, util.isFunction = function(L) {
    return typeof L == "function";
  }, util.isPrimitive = function(L) {
    return L === null || typeof L == "boolean" || typeof L == "number" || typeof L == "string" || typeof L == "symbol" || L === void 0;
  }, util.isBuffer = require$$1$2.Buffer.isBuffer, util;
}
var BufferList = { exports: {} }, hasRequiredBufferList, destroy_1, hasRequiredDestroy, _stream_writable, hasRequired_stream_writable, _stream_duplex, hasRequired_stream_duplex, _stream_readable, hasRequired_stream_readable, _stream_transform, hasRequired_stream_transform, _stream_passthrough, hasRequired_stream_passthrough, hasRequiredReadableBrowser;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    var L = requireSafeBuffer().Buffer, K = requireUtil$1();
    function W(V, J, re) {
      V.copy(J, re);
    }
    B.exports = function() {
      function V() {
        (function(J, re) {
          if (!(J instanceof re)) throw new TypeError("Cannot call a class as a function");
        })(this, V), this.head = null, this.tail = null, this.length = 0;
      }
      return V.prototype.push = function(J) {
        var re = { data: J, next: null };
        this.length > 0 ? this.tail.next = re : this.head = re, this.tail = re, ++this.length;
      }, V.prototype.unshift = function(J) {
        var re = { data: J, next: this.head };
        this.length === 0 && (this.tail = re), this.head = re, ++this.length;
      }, V.prototype.shift = function() {
        if (this.length !== 0) {
          var J = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, J;
        }
      }, V.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, V.prototype.join = function(J) {
        if (this.length === 0) return "";
        for (var re = this.head, ie = "" + re.data; re = re.next; ) ie += J + re.data;
        return ie;
      }, V.prototype.concat = function(J) {
        if (this.length === 0) return L.alloc(0);
        for (var re = L.allocUnsafe(J >>> 0), ie = this.head, ne = 0; ie; ) W(ie.data, re, ne), ne += ie.data.length, ie = ie.next;
        return re;
      }, V;
    }(), K && K.inspect && K.inspect.custom && (B.exports.prototype[K.inspect.custom] = function() {
      var V = K.inspect({ length: this.length });
      return this.constructor.name + " " + V;
    });
  }(BufferList)), BufferList.exports;
}
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var B = requireProcessNextickArgs();
  function L(K, W) {
    K.emit("error", W);
  }
  return destroy_1 = { destroy: function(K, W) {
    var V = this, J = this._readableState && this._readableState.destroyed, re = this._writableState && this._writableState.destroyed;
    return J || re ? (W ? W(K) : K && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, B.nextTick(L, this, K)) : B.nextTick(L, this, K)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(K || null, function(ie) {
      !W && ie ? V._writableState ? V._writableState.errorEmitted || (V._writableState.errorEmitted = !0, B.nextTick(L, V, ie)) : B.nextTick(L, V, ie) : W && W(ie);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  } };
}
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = requireProcessNextickArgs();
  function L(mt) {
    var $t = this;
    this.next = null, this.entry = null, this.finish = function() {
      (function(It, Ut) {
        var ut = It.entry;
        for (It.entry = null; ut; ) {
          var ht = ut.callback;
          Ut.pendingcb--, ht(void 0), ut = ut.next;
        }
        Ut.corkedRequestsFree.next = It;
      })($t, mt);
    };
  }
  _stream_writable = ot;
  var K, W = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick;
  ot.WritableState = ke;
  var V = Object.create(requireUtil());
  V.inherits = requireInherits_browser();
  var J, re = { deprecate: requireBrowser$a() }, ie = requireStreamBrowser(), ne = requireSafeBuffer().Buffer, oe = (commonjsGlobal !== void 0 ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  }, ce = requireDestroy();
  function pe() {
  }
  function ke(mt, $t) {
    K = K || require_stream_duplex(), mt = mt || {};
    var It = $t instanceof K;
    this.objectMode = !!mt.objectMode, It && (this.objectMode = this.objectMode || !!mt.writableObjectMode);
    var Ut = mt.highWaterMark, ut = mt.writableHighWaterMark, ht = this.objectMode ? 16 : 16384;
    this.highWaterMark = Ut || Ut === 0 ? Ut : It && (ut || ut === 0) ? ut : ht, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ce = mt.decodeStrings === !1;
    this.decodeStrings = !Ce, this.defaultEncoding = mt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(nt) {
      (function(rt, it) {
        var st = rt._writableState, Oe = st.sync, ct = st.writecb;
        if (function(gt) {
          gt.writing = !1, gt.writecb = null, gt.length -= gt.writelen, gt.writelen = 0;
        }(st), it) (function(gt, vt, Bt, kt, wt) {
          --vt.pendingcb, Bt ? (B.nextTick(wt, kt), B.nextTick(St, gt, vt), gt._writableState.errorEmitted = !0, gt.emit("error", kt)) : (wt(kt), gt._writableState.errorEmitted = !0, gt.emit("error", kt), St(gt, vt));
        })(rt, st, Oe, it, ct);
        else {
          var pt = lt(st);
          pt || st.corked || st.bufferProcessing || !st.bufferedRequest || dt(rt, st), Oe ? W(ft, rt, st, pt, ct) : ft(rt, st, pt, ct);
        }
      })($t, nt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new L(this);
  }
  function ot(mt) {
    if (K = K || require_stream_duplex(), !(J.call(ot, this) || this instanceof K)) return new ot(mt);
    this._writableState = new ke(mt, this), this.writable = !0, mt && (typeof mt.write == "function" && (this._write = mt.write), typeof mt.writev == "function" && (this._writev = mt.writev), typeof mt.destroy == "function" && (this._destroy = mt.destroy), typeof mt.final == "function" && (this._final = mt.final)), ie.call(this);
  }
  function at(mt, $t, It, Ut, ut, ht, Ce) {
    $t.writelen = Ut, $t.writecb = Ce, $t.writing = !0, $t.sync = !0, It ? mt._writev(ut, $t.onwrite) : mt._write(ut, ht, $t.onwrite), $t.sync = !1;
  }
  function ft(mt, $t, It, Ut) {
    It || function(ut, ht) {
      ht.length === 0 && ht.needDrain && (ht.needDrain = !1, ut.emit("drain"));
    }(mt, $t), $t.pendingcb--, Ut(), St(mt, $t);
  }
  function dt(mt, $t) {
    $t.bufferProcessing = !0;
    var It = $t.bufferedRequest;
    if (mt._writev && It && It.next) {
      var Ut = $t.bufferedRequestCount, ut = new Array(Ut), ht = $t.corkedRequestsFree;
      ht.entry = It;
      for (var Ce = 0, nt = !0; It; ) ut[Ce] = It, It.isBuf || (nt = !1), It = It.next, Ce += 1;
      ut.allBuffers = nt, at(mt, $t, !0, $t.length, ut, "", ht.finish), $t.pendingcb++, $t.lastBufferedRequest = null, ht.next ? ($t.corkedRequestsFree = ht.next, ht.next = null) : $t.corkedRequestsFree = new L($t), $t.bufferedRequestCount = 0;
    } else {
      for (; It; ) {
        var rt = It.chunk, it = It.encoding, st = It.callback;
        if (at(mt, $t, !1, $t.objectMode ? 1 : rt.length, rt, it, st), It = It.next, $t.bufferedRequestCount--, $t.writing) break;
      }
      It === null && ($t.lastBufferedRequest = null);
    }
    $t.bufferedRequest = It, $t.bufferProcessing = !1;
  }
  function lt(mt) {
    return mt.ending && mt.length === 0 && mt.bufferedRequest === null && !mt.finished && !mt.writing;
  }
  function yt(mt, $t) {
    mt._final(function(It) {
      $t.pendingcb--, It && mt.emit("error", It), $t.prefinished = !0, mt.emit("prefinish"), St(mt, $t);
    });
  }
  function St(mt, $t) {
    var It = lt($t);
    return It && (function(Ut, ut) {
      ut.prefinished || ut.finalCalled || (typeof Ut._final == "function" ? (ut.pendingcb++, ut.finalCalled = !0, B.nextTick(yt, Ut, ut)) : (ut.prefinished = !0, Ut.emit("prefinish")));
    }(mt, $t), $t.pendingcb === 0 && ($t.finished = !0, mt.emit("finish"))), It;
  }
  return V.inherits(ot, ie), ke.prototype.getBuffer = function() {
    for (var mt = this.bufferedRequest, $t = []; mt; ) $t.push(mt), mt = mt.next;
    return $t;
  }, function() {
    try {
      Object.defineProperty(ke.prototype, "buffer", { get: re.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (J = Function.prototype[Symbol.hasInstance], Object.defineProperty(ot, Symbol.hasInstance, { value: function(mt) {
    return !!J.call(this, mt) || this === ot && mt && mt._writableState instanceof ke;
  } })) : J = function(mt) {
    return mt instanceof this;
  }, ot.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  }, ot.prototype.write = function(mt, $t, It) {
    var Ut, ut = this._writableState, ht = !1, Ce = !ut.objectMode && (Ut = mt, ne.isBuffer(Ut) || Ut instanceof oe);
    return Ce && !ne.isBuffer(mt) && (mt = function(nt) {
      return ne.from(nt);
    }(mt)), typeof $t == "function" && (It = $t, $t = null), Ce ? $t = "buffer" : $t || ($t = ut.defaultEncoding), typeof It != "function" && (It = pe), ut.ended ? function(nt, rt) {
      var it = new Error("write after end");
      nt.emit("error", it), B.nextTick(rt, it);
    }(this, It) : (Ce || function(nt, rt, it, st) {
      var Oe = !0, ct = !1;
      return it === null ? ct = new TypeError("May not write null values to stream") : typeof it == "string" || it === void 0 || rt.objectMode || (ct = new TypeError("Invalid non-string/buffer chunk")), ct && (nt.emit("error", ct), B.nextTick(st, ct), Oe = !1), Oe;
    }(this, ut, mt, It)) && (ut.pendingcb++, ht = function(nt, rt, it, st, Oe, ct) {
      if (!it) {
        var pt = function(kt, wt, Et) {
          return kt.objectMode || kt.decodeStrings === !1 || typeof wt != "string" || (wt = ne.from(wt, Et)), wt;
        }(rt, st, Oe);
        st !== pt && (it = !0, Oe = "buffer", st = pt);
      }
      var gt = rt.objectMode ? 1 : st.length;
      rt.length += gt;
      var vt = rt.length < rt.highWaterMark;
      if (vt || (rt.needDrain = !0), rt.writing || rt.corked) {
        var Bt = rt.lastBufferedRequest;
        rt.lastBufferedRequest = { chunk: st, encoding: Oe, isBuf: it, callback: ct, next: null }, Bt ? Bt.next = rt.lastBufferedRequest : rt.bufferedRequest = rt.lastBufferedRequest, rt.bufferedRequestCount += 1;
      } else at(nt, rt, !1, gt, st, Oe, ct);
      return vt;
    }(this, ut, Ce, mt, $t, It)), ht;
  }, ot.prototype.cork = function() {
    this._writableState.corked++;
  }, ot.prototype.uncork = function() {
    var mt = this._writableState;
    mt.corked && (mt.corked--, mt.writing || mt.corked || mt.bufferProcessing || !mt.bufferedRequest || dt(this, mt));
  }, ot.prototype.setDefaultEncoding = function(mt) {
    if (typeof mt == "string" && (mt = mt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((mt + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + mt);
    return this._writableState.defaultEncoding = mt, this;
  }, Object.defineProperty(ot.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), ot.prototype._write = function(mt, $t, It) {
    It(new Error("_write() is not implemented"));
  }, ot.prototype._writev = null, ot.prototype.end = function(mt, $t, It) {
    var Ut = this._writableState;
    typeof mt == "function" ? (It = mt, mt = null, $t = null) : typeof $t == "function" && (It = $t, $t = null), mt != null && this.write(mt, $t), Ut.corked && (Ut.corked = 1, this.uncork()), Ut.ending || function(ut, ht, Ce) {
      ht.ending = !0, St(ut, ht), Ce && (ht.finished ? B.nextTick(Ce) : ut.once("finish", Ce)), ht.ended = !0, ut.writable = !1;
    }(this, Ut, It);
  }, Object.defineProperty(ot.prototype, "destroyed", { get: function() {
    return this._writableState !== void 0 && this._writableState.destroyed;
  }, set: function(mt) {
    this._writableState && (this._writableState.destroyed = mt);
  } }), ot.prototype.destroy = ce.destroy, ot.prototype._undestroy = ce.undestroy, ot.prototype._destroy = function(mt, $t) {
    this.end(), $t(mt);
  }, _stream_writable;
}
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = requireProcessNextickArgs(), L = Object.keys || function(pe) {
    var ke = [];
    for (var ot in pe) ke.push(ot);
    return ke;
  };
  _stream_duplex = ne;
  var K = Object.create(requireUtil());
  K.inherits = requireInherits_browser();
  var W = require_stream_readable(), V = require_stream_writable();
  K.inherits(ne, W);
  for (var J = L(V.prototype), re = 0; re < J.length; re++) {
    var ie = J[re];
    ne.prototype[ie] || (ne.prototype[ie] = V.prototype[ie]);
  }
  function ne(pe) {
    if (!(this instanceof ne)) return new ne(pe);
    W.call(this, pe), V.call(this, pe), pe && pe.readable === !1 && (this.readable = !1), pe && pe.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, pe && pe.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", oe);
  }
  function oe() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(ce, this);
  }
  function ce(pe) {
    pe.end();
  }
  return Object.defineProperty(ne.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(ne.prototype, "destroyed", { get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(pe) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = pe, this._writableState.destroyed = pe);
  } }), ne.prototype._destroy = function(pe, ke) {
    this.push(null), this.end(), B.nextTick(ke, pe);
  }, _stream_duplex;
}
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = requireProcessNextickArgs();
  _stream_readable = ft;
  var L, K = requireIsarray();
  ft.ReadableState = at, requireEvents().EventEmitter;
  var W = function(Oe, ct) {
    return Oe.listeners(ct).length;
  }, V = requireStreamBrowser(), J = requireSafeBuffer().Buffer, re = (commonjsGlobal !== void 0 ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  }, ie = Object.create(requireUtil());
  ie.inherits = requireInherits_browser();
  var ne = requireUtil$1(), oe = void 0;
  oe = ne && ne.debuglog ? ne.debuglog("stream") : function() {
  };
  var ce, pe = requireBufferList(), ke = requireDestroy();
  ie.inherits(ft, V);
  var ot = ["error", "close", "destroy", "pause", "resume"];
  function at(Oe, ct) {
    Oe = Oe || {};
    var pt = ct instanceof (L = L || require_stream_duplex());
    this.objectMode = !!Oe.objectMode, pt && (this.objectMode = this.objectMode || !!Oe.readableObjectMode);
    var gt = Oe.highWaterMark, vt = Oe.readableHighWaterMark, Bt = this.objectMode ? 16 : 16384;
    this.highWaterMark = gt || gt === 0 ? gt : pt && (vt || vt === 0) ? vt : Bt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new pe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Oe.encoding && (ce || (ce = requireString_decoder().StringDecoder), this.decoder = new ce(Oe.encoding), this.encoding = Oe.encoding);
  }
  function ft(Oe) {
    if (L = L || require_stream_duplex(), !(this instanceof ft)) return new ft(Oe);
    this._readableState = new at(Oe, this), this.readable = !0, Oe && (typeof Oe.read == "function" && (this._read = Oe.read), typeof Oe.destroy == "function" && (this._destroy = Oe.destroy)), V.call(this);
  }
  function dt(Oe, ct, pt, gt, vt) {
    var Bt, kt = Oe._readableState;
    return ct === null ? (kt.reading = !1, function(wt, Et) {
      if (!Et.ended) {
        if (Et.decoder) {
          var Rt = Et.decoder.end();
          Rt && Rt.length && (Et.buffer.push(Rt), Et.length += Et.objectMode ? 1 : Rt.length);
        }
        Et.ended = !0, mt(wt);
      }
    }(Oe, kt)) : (vt || (Bt = function(wt, Et) {
      var Rt, Mt;
      return Mt = Et, J.isBuffer(Mt) || Mt instanceof re || typeof Et == "string" || Et === void 0 || wt.objectMode || (Rt = new TypeError("Invalid non-string/buffer chunk")), Rt;
    }(kt, ct)), Bt ? Oe.emit("error", Bt) : kt.objectMode || ct && ct.length > 0 ? (typeof ct == "string" || kt.objectMode || Object.getPrototypeOf(ct) === J.prototype || (ct = function(wt) {
      return J.from(wt);
    }(ct)), gt ? kt.endEmitted ? Oe.emit("error", new Error("stream.unshift() after end event")) : lt(Oe, kt, ct, !0) : kt.ended ? Oe.emit("error", new Error("stream.push() after EOF")) : (kt.reading = !1, kt.decoder && !pt ? (ct = kt.decoder.write(ct), kt.objectMode || ct.length !== 0 ? lt(Oe, kt, ct, !1) : It(Oe, kt)) : lt(Oe, kt, ct, !1))) : gt || (kt.reading = !1)), function(wt) {
      return !wt.ended && (wt.needReadable || wt.length < wt.highWaterMark || wt.length === 0);
    }(kt);
  }
  function lt(Oe, ct, pt, gt) {
    ct.flowing && ct.length === 0 && !ct.sync ? (Oe.emit("data", pt), Oe.read(0)) : (ct.length += ct.objectMode ? 1 : pt.length, gt ? ct.buffer.unshift(pt) : ct.buffer.push(pt), ct.needReadable && mt(Oe)), It(Oe, ct);
  }
  Object.defineProperty(ft.prototype, "destroyed", { get: function() {
    return this._readableState !== void 0 && this._readableState.destroyed;
  }, set: function(Oe) {
    this._readableState && (this._readableState.destroyed = Oe);
  } }), ft.prototype.destroy = ke.destroy, ft.prototype._undestroy = ke.undestroy, ft.prototype._destroy = function(Oe, ct) {
    this.push(null), ct(Oe);
  }, ft.prototype.push = function(Oe, ct) {
    var pt, gt = this._readableState;
    return gt.objectMode ? pt = !0 : typeof Oe == "string" && ((ct = ct || gt.defaultEncoding) !== gt.encoding && (Oe = J.from(Oe, ct), ct = ""), pt = !0), dt(this, Oe, ct, !1, pt);
  }, ft.prototype.unshift = function(Oe) {
    return dt(this, Oe, null, !0, !1);
  }, ft.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ft.prototype.setEncoding = function(Oe) {
    return ce || (ce = requireString_decoder().StringDecoder), this._readableState.decoder = new ce(Oe), this._readableState.encoding = Oe, this;
  };
  var yt = 8388608;
  function St(Oe, ct) {
    return Oe <= 0 || ct.length === 0 && ct.ended ? 0 : ct.objectMode ? 1 : Oe != Oe ? ct.flowing && ct.length ? ct.buffer.head.data.length : ct.length : (Oe > ct.highWaterMark && (ct.highWaterMark = function(pt) {
      return pt >= yt ? pt = yt : (pt--, pt |= pt >>> 1, pt |= pt >>> 2, pt |= pt >>> 4, pt |= pt >>> 8, pt |= pt >>> 16, pt++), pt;
    }(Oe)), Oe <= ct.length ? Oe : ct.ended ? ct.length : (ct.needReadable = !0, 0));
  }
  function mt(Oe) {
    var ct = Oe._readableState;
    ct.needReadable = !1, ct.emittedReadable || (oe("emitReadable", ct.flowing), ct.emittedReadable = !0, ct.sync ? B.nextTick($t, Oe) : $t(Oe));
  }
  function $t(Oe) {
    oe("emit readable"), Oe.emit("readable"), Ce(Oe);
  }
  function It(Oe, ct) {
    ct.readingMore || (ct.readingMore = !0, B.nextTick(Ut, Oe, ct));
  }
  function Ut(Oe, ct) {
    for (var pt = ct.length; !ct.reading && !ct.flowing && !ct.ended && ct.length < ct.highWaterMark && (oe("maybeReadMore read 0"), Oe.read(0), pt !== ct.length); ) pt = ct.length;
    ct.readingMore = !1;
  }
  function ut(Oe) {
    oe("readable nexttick read 0"), Oe.read(0);
  }
  function ht(Oe, ct) {
    ct.reading || (oe("resume read 0"), Oe.read(0)), ct.resumeScheduled = !1, ct.awaitDrain = 0, Oe.emit("resume"), Ce(Oe), ct.flowing && !ct.reading && Oe.read(0);
  }
  function Ce(Oe) {
    var ct = Oe._readableState;
    for (oe("flow", ct.flowing); ct.flowing && Oe.read() !== null; ) ;
  }
  function nt(Oe, ct) {
    return ct.length === 0 ? null : (ct.objectMode ? pt = ct.buffer.shift() : !Oe || Oe >= ct.length ? (pt = ct.decoder ? ct.buffer.join("") : ct.buffer.length === 1 ? ct.buffer.head.data : ct.buffer.concat(ct.length), ct.buffer.clear()) : pt = function(gt, vt, Bt) {
      var kt;
      return gt < vt.head.data.length ? (kt = vt.head.data.slice(0, gt), vt.head.data = vt.head.data.slice(gt)) : kt = gt === vt.head.data.length ? vt.shift() : Bt ? function(wt, Et) {
        var Rt = Et.head, Mt = 1, Ht = Rt.data;
        for (wt -= Ht.length; Rt = Rt.next; ) {
          var Kt = Rt.data, jt = wt > Kt.length ? Kt.length : wt;
          if (jt === Kt.length ? Ht += Kt : Ht += Kt.slice(0, wt), (wt -= jt) == 0) {
            jt === Kt.length ? (++Mt, Rt.next ? Et.head = Rt.next : Et.head = Et.tail = null) : (Et.head = Rt, Rt.data = Kt.slice(jt));
            break;
          }
          ++Mt;
        }
        return Et.length -= Mt, Ht;
      }(gt, vt) : function(wt, Et) {
        var Rt = J.allocUnsafe(wt), Mt = Et.head, Ht = 1;
        for (Mt.data.copy(Rt), wt -= Mt.data.length; Mt = Mt.next; ) {
          var Kt = Mt.data, jt = wt > Kt.length ? Kt.length : wt;
          if (Kt.copy(Rt, Rt.length - wt, 0, jt), (wt -= jt) == 0) {
            jt === Kt.length ? (++Ht, Mt.next ? Et.head = Mt.next : Et.head = Et.tail = null) : (Et.head = Mt, Mt.data = Kt.slice(jt));
            break;
          }
          ++Ht;
        }
        return Et.length -= Ht, Rt;
      }(gt, vt), kt;
    }(Oe, ct.buffer, ct.decoder), pt);
    var pt;
  }
  function rt(Oe) {
    var ct = Oe._readableState;
    if (ct.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    ct.endEmitted || (ct.ended = !0, B.nextTick(it, ct, Oe));
  }
  function it(Oe, ct) {
    Oe.endEmitted || Oe.length !== 0 || (Oe.endEmitted = !0, ct.readable = !1, ct.emit("end"));
  }
  function st(Oe, ct) {
    for (var pt = 0, gt = Oe.length; pt < gt; pt++) if (Oe[pt] === ct) return pt;
    return -1;
  }
  return ft.prototype.read = function(Oe) {
    oe("read", Oe), Oe = parseInt(Oe, 10);
    var ct = this._readableState, pt = Oe;
    if (Oe !== 0 && (ct.emittedReadable = !1), Oe === 0 && ct.needReadable && (ct.length >= ct.highWaterMark || ct.ended)) return oe("read: emitReadable", ct.length, ct.ended), ct.length === 0 && ct.ended ? rt(this) : mt(this), null;
    if ((Oe = St(Oe, ct)) === 0 && ct.ended) return ct.length === 0 && rt(this), null;
    var gt, vt = ct.needReadable;
    return oe("need readable", vt), (ct.length === 0 || ct.length - Oe < ct.highWaterMark) && oe("length less than watermark", vt = !0), ct.ended || ct.reading ? oe("reading or ended", vt = !1) : vt && (oe("do read"), ct.reading = !0, ct.sync = !0, ct.length === 0 && (ct.needReadable = !0), this._read(ct.highWaterMark), ct.sync = !1, ct.reading || (Oe = St(pt, ct))), (gt = Oe > 0 ? nt(Oe, ct) : null) === null ? (ct.needReadable = !0, Oe = 0) : ct.length -= Oe, ct.length === 0 && (ct.ended || (ct.needReadable = !0), pt !== Oe && ct.ended && rt(this)), gt !== null && this.emit("data", gt), gt;
  }, ft.prototype._read = function(Oe) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ft.prototype.pipe = function(Oe, ct) {
    var pt = this, gt = this._readableState;
    switch (gt.pipesCount) {
      case 0:
        gt.pipes = Oe;
        break;
      case 1:
        gt.pipes = [gt.pipes, Oe];
        break;
      default:
        gt.pipes.push(Oe);
    }
    gt.pipesCount += 1, oe("pipe count=%d opts=%j", gt.pipesCount, ct);
    var vt = ct && ct.end === !1 || Oe === process$1.stdout || Oe === process$1.stderr ? jt : Bt;
    function Bt() {
      oe("onend"), Oe.end();
    }
    gt.endEmitted ? B.nextTick(vt) : pt.once("end", vt), Oe.on("unpipe", function Wt(Yt, Xt) {
      oe("onunpipe"), Yt === pt && Xt && Xt.hasUnpiped === !1 && (Xt.hasUnpiped = !0, oe("cleanup"), Oe.removeListener("close", Ht), Oe.removeListener("finish", Kt), Oe.removeListener("drain", kt), Oe.removeListener("error", Mt), Oe.removeListener("unpipe", Wt), pt.removeListener("end", Bt), pt.removeListener("end", jt), pt.removeListener("data", Rt), wt = !0, !gt.awaitDrain || Oe._writableState && !Oe._writableState.needDrain || kt());
    });
    var kt = /* @__PURE__ */ function(Wt) {
      return function() {
        var Yt = Wt._readableState;
        oe("pipeOnDrain", Yt.awaitDrain), Yt.awaitDrain && Yt.awaitDrain--, Yt.awaitDrain === 0 && W(Wt, "data") && (Yt.flowing = !0, Ce(Wt));
      };
    }(pt);
    Oe.on("drain", kt);
    var wt = !1, Et = !1;
    function Rt(Wt) {
      oe("ondata"), Et = !1, Oe.write(Wt) !== !1 || Et || ((gt.pipesCount === 1 && gt.pipes === Oe || gt.pipesCount > 1 && st(gt.pipes, Oe) !== -1) && !wt && (oe("false write response, pause", gt.awaitDrain), gt.awaitDrain++, Et = !0), pt.pause());
    }
    function Mt(Wt) {
      oe("onerror", Wt), jt(), Oe.removeListener("error", Mt), W(Oe, "error") === 0 && Oe.emit("error", Wt);
    }
    function Ht() {
      Oe.removeListener("finish", Kt), jt();
    }
    function Kt() {
      oe("onfinish"), Oe.removeListener("close", Ht), jt();
    }
    function jt() {
      oe("unpipe"), pt.unpipe(Oe);
    }
    return pt.on("data", Rt), function(Wt, Yt, Xt) {
      if (typeof Wt.prependListener == "function") return Wt.prependListener(Yt, Xt);
      Wt._events && Wt._events[Yt] ? K(Wt._events[Yt]) ? Wt._events[Yt].unshift(Xt) : Wt._events[Yt] = [Xt, Wt._events[Yt]] : Wt.on(Yt, Xt);
    }(Oe, "error", Mt), Oe.once("close", Ht), Oe.once("finish", Kt), Oe.emit("pipe", pt), gt.flowing || (oe("pipe resume"), pt.resume()), Oe;
  }, ft.prototype.unpipe = function(Oe) {
    var ct = this._readableState, pt = { hasUnpiped: !1 };
    if (ct.pipesCount === 0) return this;
    if (ct.pipesCount === 1) return Oe && Oe !== ct.pipes || (Oe || (Oe = ct.pipes), ct.pipes = null, ct.pipesCount = 0, ct.flowing = !1, Oe && Oe.emit("unpipe", this, pt)), this;
    if (!Oe) {
      var gt = ct.pipes, vt = ct.pipesCount;
      ct.pipes = null, ct.pipesCount = 0, ct.flowing = !1;
      for (var Bt = 0; Bt < vt; Bt++) gt[Bt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var kt = st(ct.pipes, Oe);
    return kt === -1 || (ct.pipes.splice(kt, 1), ct.pipesCount -= 1, ct.pipesCount === 1 && (ct.pipes = ct.pipes[0]), Oe.emit("unpipe", this, pt)), this;
  }, ft.prototype.on = function(Oe, ct) {
    var pt = V.prototype.on.call(this, Oe, ct);
    if (Oe === "data") this._readableState.flowing !== !1 && this.resume();
    else if (Oe === "readable") {
      var gt = this._readableState;
      gt.endEmitted || gt.readableListening || (gt.readableListening = gt.needReadable = !0, gt.emittedReadable = !1, gt.reading ? gt.length && mt(this) : B.nextTick(ut, this));
    }
    return pt;
  }, ft.prototype.addListener = ft.prototype.on, ft.prototype.resume = function() {
    var Oe = this._readableState;
    return Oe.flowing || (oe("resume"), Oe.flowing = !0, function(ct, pt) {
      pt.resumeScheduled || (pt.resumeScheduled = !0, B.nextTick(ht, ct, pt));
    }(this, Oe)), this;
  }, ft.prototype.pause = function() {
    return oe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (oe("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  }, ft.prototype.wrap = function(Oe) {
    var ct = this, pt = this._readableState, gt = !1;
    for (var vt in Oe.on("end", function() {
      if (oe("wrapped end"), pt.decoder && !pt.ended) {
        var kt = pt.decoder.end();
        kt && kt.length && ct.push(kt);
      }
      ct.push(null);
    }), Oe.on("data", function(kt) {
      oe("wrapped data"), pt.decoder && (kt = pt.decoder.write(kt)), pt.objectMode && kt == null || (pt.objectMode || kt && kt.length) && (ct.push(kt) || (gt = !0, Oe.pause()));
    }), Oe) this[vt] === void 0 && typeof Oe[vt] == "function" && (this[vt] = /* @__PURE__ */ function(kt) {
      return function() {
        return Oe[kt].apply(Oe, arguments);
      };
    }(vt));
    for (var Bt = 0; Bt < ot.length; Bt++) Oe.on(ot[Bt], this.emit.bind(this, ot[Bt]));
    return this._read = function(kt) {
      oe("wrapped _read", kt), gt && (gt = !1, Oe.resume());
    }, this;
  }, Object.defineProperty(ft.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
    return this._readableState.highWaterMark;
  } }), ft._fromList = nt, _stream_readable;
}
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = W;
  var B = require_stream_duplex(), L = Object.create(requireUtil());
  function K(re, ie) {
    var ne = this._transformState;
    ne.transforming = !1;
    var oe = ne.writecb;
    if (!oe) return this.emit("error", new Error("write callback called multiple times"));
    ne.writechunk = null, ne.writecb = null, ie != null && this.push(ie), oe(re);
    var ce = this._readableState;
    ce.reading = !1, (ce.needReadable || ce.length < ce.highWaterMark) && this._read(ce.highWaterMark);
  }
  function W(re) {
    if (!(this instanceof W)) return new W(re);
    B.call(this, re), this._transformState = { afterTransform: K.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, re && (typeof re.transform == "function" && (this._transform = re.transform), typeof re.flush == "function" && (this._flush = re.flush)), this.on("prefinish", V);
  }
  function V() {
    var re = this;
    typeof this._flush == "function" ? this._flush(function(ie, ne) {
      J(re, ie, ne);
    }) : J(this, null, null);
  }
  function J(re, ie, ne) {
    if (ie) return re.emit("error", ie);
    if (ne != null && re.push(ne), re._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (re._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return re.push(null);
  }
  return L.inherits = requireInherits_browser(), L.inherits(W, B), W.prototype.push = function(re, ie) {
    return this._transformState.needTransform = !1, B.prototype.push.call(this, re, ie);
  }, W.prototype._transform = function(re, ie, ne) {
    throw new Error("_transform() is not implemented");
  }, W.prototype._write = function(re, ie, ne) {
    var oe = this._transformState;
    if (oe.writecb = ne, oe.writechunk = re, oe.writeencoding = ie, !oe.transforming) {
      var ce = this._readableState;
      (oe.needTransform || ce.needReadable || ce.length < ce.highWaterMark) && this._read(ce.highWaterMark);
    }
  }, W.prototype._read = function(re) {
    var ie = this._transformState;
    ie.writechunk !== null && ie.writecb && !ie.transforming ? (ie.transforming = !0, this._transform(ie.writechunk, ie.writeencoding, ie.afterTransform)) : ie.needTransform = !0;
  }, W.prototype._destroy = function(re, ie) {
    var ne = this;
    B.prototype._destroy.call(this, re, function(oe) {
      ie(oe), ne.emit("close");
    });
  }, _stream_transform;
}
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = K;
  var B = require_stream_transform(), L = Object.create(requireUtil());
  function K(W) {
    if (!(this instanceof K)) return new K(W);
    B.call(this, W);
  }
  return L.inherits = requireInherits_browser(), L.inherits(K, B), K.prototype._transform = function(W, V, J) {
    J(null, W);
  }, _stream_passthrough;
}
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(B, L) {
    (L = B.exports = require_stream_readable()).Stream = L, L.Readable = L, L.Writable = require_stream_writable(), L.Duplex = require_stream_duplex(), L.Transform = require_stream_transform(), L.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign$1 = { exports: {} }, bn = { exports: {} }, hasRequiredBn, browserifyRsa, hasRequiredBrowserifyRsa;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(B, L) {
    function K(Ce, nt) {
      if (!Ce) throw new Error(nt || "Assertion failed");
    }
    function W(Ce, nt) {
      Ce.super_ = nt;
      var rt = function() {
      };
      rt.prototype = nt.prototype, Ce.prototype = new rt(), Ce.prototype.constructor = Ce;
    }
    function V(Ce, nt, rt) {
      if (V.isBN(Ce)) return Ce;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Ce !== null && (nt !== "le" && nt !== "be" || (rt = nt, nt = 10), this._init(Ce || 0, nt || 10, rt || "be"));
    }
    var J;
    typeof bn == "object" ? bn.exports = V : L.BN = V, V.BN = V, V.wordSize = 26;
    try {
      J = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$1$2.Buffer;
    } catch {
    }
    function re(Ce, nt) {
      var rt = Ce.charCodeAt(nt);
      return rt >= 48 && rt <= 57 ? rt - 48 : rt >= 65 && rt <= 70 ? rt - 55 : rt >= 97 && rt <= 102 ? rt - 87 : void K(!1, "Invalid character in " + Ce);
    }
    function ie(Ce, nt, rt) {
      var it = re(Ce, rt);
      return rt - 1 >= nt && (it |= re(Ce, rt - 1) << 4), it;
    }
    function ne(Ce, nt, rt, it) {
      for (var st = 0, Oe = 0, ct = Math.min(Ce.length, rt), pt = nt; pt < ct; pt++) {
        var gt = Ce.charCodeAt(pt) - 48;
        st *= it, Oe = gt >= 49 ? gt - 49 + 10 : gt >= 17 ? gt - 17 + 10 : gt, K(gt >= 0 && Oe < it, "Invalid character"), st += Oe;
      }
      return st;
    }
    function oe(Ce, nt) {
      Ce.words = nt.words, Ce.length = nt.length, Ce.negative = nt.negative, Ce.red = nt.red;
    }
    if (V.isBN = function(Ce) {
      return Ce instanceof V || Ce !== null && typeof Ce == "object" && Ce.constructor.wordSize === V.wordSize && Array.isArray(Ce.words);
    }, V.max = function(Ce, nt) {
      return Ce.cmp(nt) > 0 ? Ce : nt;
    }, V.min = function(Ce, nt) {
      return Ce.cmp(nt) < 0 ? Ce : nt;
    }, V.prototype._init = function(Ce, nt, rt) {
      if (typeof Ce == "number") return this._initNumber(Ce, nt, rt);
      if (typeof Ce == "object") return this._initArray(Ce, nt, rt);
      nt === "hex" && (nt = 16), K(nt === (0 | nt) && nt >= 2 && nt <= 36);
      var it = 0;
      (Ce = Ce.toString().replace(/\s+/g, ""))[0] === "-" && (it++, this.negative = 1), it < Ce.length && (nt === 16 ? this._parseHex(Ce, it, rt) : (this._parseBase(Ce, nt, it), rt === "le" && this._initArray(this.toArray(), nt, rt)));
    }, V.prototype._initNumber = function(Ce, nt, rt) {
      Ce < 0 && (this.negative = 1, Ce = -Ce), Ce < 67108864 ? (this.words = [67108863 & Ce], this.length = 1) : Ce < 4503599627370496 ? (this.words = [67108863 & Ce, Ce / 67108864 & 67108863], this.length = 2) : (K(Ce < 9007199254740992), this.words = [67108863 & Ce, Ce / 67108864 & 67108863, 1], this.length = 3), rt === "le" && this._initArray(this.toArray(), nt, rt);
    }, V.prototype._initArray = function(Ce, nt, rt) {
      if (K(typeof Ce.length == "number"), Ce.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Ce.length / 3), this.words = new Array(this.length);
      for (var it = 0; it < this.length; it++) this.words[it] = 0;
      var st, Oe, ct = 0;
      if (rt === "be") for (it = Ce.length - 1, st = 0; it >= 0; it -= 3) Oe = Ce[it] | Ce[it - 1] << 8 | Ce[it - 2] << 16, this.words[st] |= Oe << ct & 67108863, this.words[st + 1] = Oe >>> 26 - ct & 67108863, (ct += 24) >= 26 && (ct -= 26, st++);
      else if (rt === "le") for (it = 0, st = 0; it < Ce.length; it += 3) Oe = Ce[it] | Ce[it + 1] << 8 | Ce[it + 2] << 16, this.words[st] |= Oe << ct & 67108863, this.words[st + 1] = Oe >>> 26 - ct & 67108863, (ct += 24) >= 26 && (ct -= 26, st++);
      return this._strip();
    }, V.prototype._parseHex = function(Ce, nt, rt) {
      this.length = Math.ceil((Ce.length - nt) / 6), this.words = new Array(this.length);
      for (var it = 0; it < this.length; it++) this.words[it] = 0;
      var st, Oe = 0, ct = 0;
      if (rt === "be") for (it = Ce.length - 1; it >= nt; it -= 2) st = ie(Ce, nt, it) << Oe, this.words[ct] |= 67108863 & st, Oe >= 18 ? (Oe -= 18, ct += 1, this.words[ct] |= st >>> 26) : Oe += 8;
      else for (it = (Ce.length - nt) % 2 == 0 ? nt + 1 : nt; it < Ce.length; it += 2) st = ie(Ce, nt, it) << Oe, this.words[ct] |= 67108863 & st, Oe >= 18 ? (Oe -= 18, ct += 1, this.words[ct] |= st >>> 26) : Oe += 8;
      this._strip();
    }, V.prototype._parseBase = function(Ce, nt, rt) {
      this.words = [0], this.length = 1;
      for (var it = 0, st = 1; st <= 67108863; st *= nt) it++;
      it--, st = st / nt | 0;
      for (var Oe = Ce.length - rt, ct = Oe % it, pt = Math.min(Oe, Oe - ct) + rt, gt = 0, vt = rt; vt < pt; vt += it) gt = ne(Ce, vt, vt + it, nt), this.imuln(st), this.words[0] + gt < 67108864 ? this.words[0] += gt : this._iaddn(gt);
      if (ct !== 0) {
        var Bt = 1;
        for (gt = ne(Ce, vt, Ce.length, nt), vt = 0; vt < ct; vt++) Bt *= nt;
        this.imuln(Bt), this.words[0] + gt < 67108864 ? this.words[0] += gt : this._iaddn(gt);
      }
      this._strip();
    }, V.prototype.copy = function(Ce) {
      Ce.words = new Array(this.length);
      for (var nt = 0; nt < this.length; nt++) Ce.words[nt] = this.words[nt];
      Ce.length = this.length, Ce.negative = this.negative, Ce.red = this.red;
    }, V.prototype._move = function(Ce) {
      oe(Ce, this);
    }, V.prototype.clone = function() {
      var Ce = new V(null);
      return this.copy(Ce), Ce;
    }, V.prototype._expand = function(Ce) {
      for (; this.length < Ce; ) this.words[this.length++] = 0;
      return this;
    }, V.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, V.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
      V.prototype[Symbol.for("nodejs.util.inspect.custom")] = ce;
    } catch {
      V.prototype.inspect = ce;
    }
    else V.prototype.inspect = ce;
    function ce() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var pe = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], ke = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], ot = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    function at(Ce, nt, rt) {
      rt.negative = nt.negative ^ Ce.negative;
      var it = Ce.length + nt.length | 0;
      rt.length = it, it = it - 1 | 0;
      var st = 0 | Ce.words[0], Oe = 0 | nt.words[0], ct = st * Oe, pt = 67108863 & ct, gt = ct / 67108864 | 0;
      rt.words[0] = pt;
      for (var vt = 1; vt < it; vt++) {
        for (var Bt = gt >>> 26, kt = 67108863 & gt, wt = Math.min(vt, nt.length - 1), Et = Math.max(0, vt - Ce.length + 1); Et <= wt; Et++) {
          var Rt = vt - Et | 0;
          Bt += (ct = (st = 0 | Ce.words[Rt]) * (Oe = 0 | nt.words[Et]) + kt) / 67108864 | 0, kt = 67108863 & ct;
        }
        rt.words[vt] = 0 | kt, gt = 0 | Bt;
      }
      return gt !== 0 ? rt.words[vt] = 0 | gt : rt.length--, rt._strip();
    }
    V.prototype.toString = function(Ce, nt) {
      var rt;
      if (nt = 0 | nt || 1, (Ce = Ce || 10) === 16 || Ce === "hex") {
        rt = "";
        for (var it = 0, st = 0, Oe = 0; Oe < this.length; Oe++) {
          var ct = this.words[Oe], pt = (16777215 & (ct << it | st)).toString(16);
          st = ct >>> 24 - it & 16777215, (it += 2) >= 26 && (it -= 26, Oe--), rt = st !== 0 || Oe !== this.length - 1 ? pe[6 - pt.length] + pt + rt : pt + rt;
        }
        for (st !== 0 && (rt = st.toString(16) + rt); rt.length % nt != 0; ) rt = "0" + rt;
        return this.negative !== 0 && (rt = "-" + rt), rt;
      }
      if (Ce === (0 | Ce) && Ce >= 2 && Ce <= 36) {
        var gt = ke[Ce], vt = ot[Ce];
        rt = "";
        var Bt = this.clone();
        for (Bt.negative = 0; !Bt.isZero(); ) {
          var kt = Bt.modrn(vt).toString(Ce);
          rt = (Bt = Bt.idivn(vt)).isZero() ? kt + rt : pe[gt - kt.length] + kt + rt;
        }
        for (this.isZero() && (rt = "0" + rt); rt.length % nt != 0; ) rt = "0" + rt;
        return this.negative !== 0 && (rt = "-" + rt), rt;
      }
      K(!1, "Base should be between 2 and 36");
    }, V.prototype.toNumber = function() {
      var Ce = this.words[0];
      return this.length === 2 ? Ce += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? Ce += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Ce : Ce;
    }, V.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, J && (V.prototype.toBuffer = function(Ce, nt) {
      return this.toArrayLike(J, Ce, nt);
    }), V.prototype.toArray = function(Ce, nt) {
      return this.toArrayLike(Array, Ce, nt);
    }, V.prototype.toArrayLike = function(Ce, nt, rt) {
      this._strip();
      var it = this.byteLength(), st = rt || Math.max(1, it);
      K(it <= st, "byte array longer than desired length"), K(st > 0, "Requested array length <= 0");
      var Oe = function(ct, pt) {
        return ct.allocUnsafe ? ct.allocUnsafe(pt) : new ct(pt);
      }(Ce, st);
      return this["_toArrayLike" + (nt === "le" ? "LE" : "BE")](Oe, it), Oe;
    }, V.prototype._toArrayLikeLE = function(Ce, nt) {
      for (var rt = 0, it = 0, st = 0, Oe = 0; st < this.length; st++) {
        var ct = this.words[st] << Oe | it;
        Ce[rt++] = 255 & ct, rt < Ce.length && (Ce[rt++] = ct >> 8 & 255), rt < Ce.length && (Ce[rt++] = ct >> 16 & 255), Oe === 6 ? (rt < Ce.length && (Ce[rt++] = ct >> 24 & 255), it = 0, Oe = 0) : (it = ct >>> 24, Oe += 2);
      }
      if (rt < Ce.length) for (Ce[rt++] = it; rt < Ce.length; ) Ce[rt++] = 0;
    }, V.prototype._toArrayLikeBE = function(Ce, nt) {
      for (var rt = Ce.length - 1, it = 0, st = 0, Oe = 0; st < this.length; st++) {
        var ct = this.words[st] << Oe | it;
        Ce[rt--] = 255 & ct, rt >= 0 && (Ce[rt--] = ct >> 8 & 255), rt >= 0 && (Ce[rt--] = ct >> 16 & 255), Oe === 6 ? (rt >= 0 && (Ce[rt--] = ct >> 24 & 255), it = 0, Oe = 0) : (it = ct >>> 24, Oe += 2);
      }
      if (rt >= 0) for (Ce[rt--] = it; rt >= 0; ) Ce[rt--] = 0;
    }, Math.clz32 ? V.prototype._countBits = function(Ce) {
      return 32 - Math.clz32(Ce);
    } : V.prototype._countBits = function(Ce) {
      var nt = Ce, rt = 0;
      return nt >= 4096 && (rt += 13, nt >>>= 13), nt >= 64 && (rt += 7, nt >>>= 7), nt >= 8 && (rt += 4, nt >>>= 4), nt >= 2 && (rt += 2, nt >>>= 2), rt + nt;
    }, V.prototype._zeroBits = function(Ce) {
      if (Ce === 0) return 26;
      var nt = Ce, rt = 0;
      return 8191 & nt || (rt += 13, nt >>>= 13), 127 & nt || (rt += 7, nt >>>= 7), 15 & nt || (rt += 4, nt >>>= 4), 3 & nt || (rt += 2, nt >>>= 2), 1 & nt || rt++, rt;
    }, V.prototype.bitLength = function() {
      var Ce = this.words[this.length - 1], nt = this._countBits(Ce);
      return 26 * (this.length - 1) + nt;
    }, V.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var Ce = 0, nt = 0; nt < this.length; nt++) {
        var rt = this._zeroBits(this.words[nt]);
        if (Ce += rt, rt !== 26) break;
      }
      return Ce;
    }, V.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, V.prototype.toTwos = function(Ce) {
      return this.negative !== 0 ? this.abs().inotn(Ce).iaddn(1) : this.clone();
    }, V.prototype.fromTwos = function(Ce) {
      return this.testn(Ce - 1) ? this.notn(Ce).iaddn(1).ineg() : this.clone();
    }, V.prototype.isNeg = function() {
      return this.negative !== 0;
    }, V.prototype.neg = function() {
      return this.clone().ineg();
    }, V.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, V.prototype.iuor = function(Ce) {
      for (; this.length < Ce.length; ) this.words[this.length++] = 0;
      for (var nt = 0; nt < Ce.length; nt++) this.words[nt] = this.words[nt] | Ce.words[nt];
      return this._strip();
    }, V.prototype.ior = function(Ce) {
      return K(!(this.negative | Ce.negative)), this.iuor(Ce);
    }, V.prototype.or = function(Ce) {
      return this.length > Ce.length ? this.clone().ior(Ce) : Ce.clone().ior(this);
    }, V.prototype.uor = function(Ce) {
      return this.length > Ce.length ? this.clone().iuor(Ce) : Ce.clone().iuor(this);
    }, V.prototype.iuand = function(Ce) {
      var nt;
      nt = this.length > Ce.length ? Ce : this;
      for (var rt = 0; rt < nt.length; rt++) this.words[rt] = this.words[rt] & Ce.words[rt];
      return this.length = nt.length, this._strip();
    }, V.prototype.iand = function(Ce) {
      return K(!(this.negative | Ce.negative)), this.iuand(Ce);
    }, V.prototype.and = function(Ce) {
      return this.length > Ce.length ? this.clone().iand(Ce) : Ce.clone().iand(this);
    }, V.prototype.uand = function(Ce) {
      return this.length > Ce.length ? this.clone().iuand(Ce) : Ce.clone().iuand(this);
    }, V.prototype.iuxor = function(Ce) {
      var nt, rt;
      this.length > Ce.length ? (nt = this, rt = Ce) : (nt = Ce, rt = this);
      for (var it = 0; it < rt.length; it++) this.words[it] = nt.words[it] ^ rt.words[it];
      if (this !== nt) for (; it < nt.length; it++) this.words[it] = nt.words[it];
      return this.length = nt.length, this._strip();
    }, V.prototype.ixor = function(Ce) {
      return K(!(this.negative | Ce.negative)), this.iuxor(Ce);
    }, V.prototype.xor = function(Ce) {
      return this.length > Ce.length ? this.clone().ixor(Ce) : Ce.clone().ixor(this);
    }, V.prototype.uxor = function(Ce) {
      return this.length > Ce.length ? this.clone().iuxor(Ce) : Ce.clone().iuxor(this);
    }, V.prototype.inotn = function(Ce) {
      K(typeof Ce == "number" && Ce >= 0);
      var nt = 0 | Math.ceil(Ce / 26), rt = Ce % 26;
      this._expand(nt), rt > 0 && nt--;
      for (var it = 0; it < nt; it++) this.words[it] = 67108863 & ~this.words[it];
      return rt > 0 && (this.words[it] = ~this.words[it] & 67108863 >> 26 - rt), this._strip();
    }, V.prototype.notn = function(Ce) {
      return this.clone().inotn(Ce);
    }, V.prototype.setn = function(Ce, nt) {
      K(typeof Ce == "number" && Ce >= 0);
      var rt = Ce / 26 | 0, it = Ce % 26;
      return this._expand(rt + 1), this.words[rt] = nt ? this.words[rt] | 1 << it : this.words[rt] & ~(1 << it), this._strip();
    }, V.prototype.iadd = function(Ce) {
      var nt, rt, it;
      if (this.negative !== 0 && Ce.negative === 0) return this.negative = 0, nt = this.isub(Ce), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Ce.negative !== 0) return Ce.negative = 0, nt = this.isub(Ce), Ce.negative = 1, nt._normSign();
      this.length > Ce.length ? (rt = this, it = Ce) : (rt = Ce, it = this);
      for (var st = 0, Oe = 0; Oe < it.length; Oe++) nt = (0 | rt.words[Oe]) + (0 | it.words[Oe]) + st, this.words[Oe] = 67108863 & nt, st = nt >>> 26;
      for (; st !== 0 && Oe < rt.length; Oe++) nt = (0 | rt.words[Oe]) + st, this.words[Oe] = 67108863 & nt, st = nt >>> 26;
      if (this.length = rt.length, st !== 0) this.words[this.length] = st, this.length++;
      else if (rt !== this) for (; Oe < rt.length; Oe++) this.words[Oe] = rt.words[Oe];
      return this;
    }, V.prototype.add = function(Ce) {
      var nt;
      return Ce.negative !== 0 && this.negative === 0 ? (Ce.negative = 0, nt = this.sub(Ce), Ce.negative ^= 1, nt) : Ce.negative === 0 && this.negative !== 0 ? (this.negative = 0, nt = Ce.sub(this), this.negative = 1, nt) : this.length > Ce.length ? this.clone().iadd(Ce) : Ce.clone().iadd(this);
    }, V.prototype.isub = function(Ce) {
      if (Ce.negative !== 0) {
        Ce.negative = 0;
        var nt = this.iadd(Ce);
        return Ce.negative = 1, nt._normSign();
      }
      if (this.negative !== 0) return this.negative = 0, this.iadd(Ce), this.negative = 1, this._normSign();
      var rt, it, st = this.cmp(Ce);
      if (st === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      st > 0 ? (rt = this, it = Ce) : (rt = Ce, it = this);
      for (var Oe = 0, ct = 0; ct < it.length; ct++) Oe = (nt = (0 | rt.words[ct]) - (0 | it.words[ct]) + Oe) >> 26, this.words[ct] = 67108863 & nt;
      for (; Oe !== 0 && ct < rt.length; ct++) Oe = (nt = (0 | rt.words[ct]) + Oe) >> 26, this.words[ct] = 67108863 & nt;
      if (Oe === 0 && ct < rt.length && rt !== this) for (; ct < rt.length; ct++) this.words[ct] = rt.words[ct];
      return this.length = Math.max(this.length, ct), rt !== this && (this.negative = 1), this._strip();
    }, V.prototype.sub = function(Ce) {
      return this.clone().isub(Ce);
    };
    var ft = function(Ce, nt, rt) {
      var it, st, Oe, ct = Ce.words, pt = nt.words, gt = rt.words, vt = 0, Bt = 0 | ct[0], kt = 8191 & Bt, wt = Bt >>> 13, Et = 0 | ct[1], Rt = 8191 & Et, Mt = Et >>> 13, Ht = 0 | ct[2], Kt = 8191 & Ht, jt = Ht >>> 13, Wt = 0 | ct[3], Yt = 8191 & Wt, Xt = Wt >>> 13, ir = 0 | ct[4], ur = 8191 & ir, Qt = ir >>> 13, hr = 0 | ct[5], pr = 8191 & hr, cr = hr >>> 13, vr = 0 | ct[6], bt = 8191 & vr, At = vr >>> 13, Tt = 0 | ct[7], xt = 8191 & Tt, Nt = Tt >>> 13, Ft = 0 | ct[8], zt = 8191 & Ft, nr = Ft >>> 13, lr = 0 | ct[9], Dt = 8191 & lr, Zt = lr >>> 13, ar = 0 | pt[0], qt = 8191 & ar, Pt = ar >>> 13, Ot = 0 | pt[1], Ct = 8191 & Ot, Lt = Ot >>> 13, Vt = 0 | pt[2], Jt = 8191 & Vt, Gt = Vt >>> 13, er = 0 | pt[3], or = 8191 & er, tr = er >>> 13, sr = 0 | pt[4], rr = 8191 & sr, fr = sr >>> 13, dr = 0 | pt[5], Sr = 8191 & dr, br = dr >>> 13, Er = 0 | pt[6], $r = 8191 & Er, yr = Er >>> 13, kr = 0 | pt[7], Tr = 8191 & kr, gr = kr >>> 13, _r = 0 | pt[8], Ar = 8191 & _r, wr = _r >>> 13, Rr = 0 | pt[9], Ir = 8191 & Rr, Br = Rr >>> 13;
      rt.negative = Ce.negative ^ nt.negative, rt.length = 19;
      var Pr = (vt + (it = Math.imul(kt, qt)) | 0) + ((8191 & (st = (st = Math.imul(kt, Pt)) + Math.imul(wt, qt) | 0)) << 13) | 0;
      vt = ((Oe = Math.imul(wt, Pt)) + (st >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, it = Math.imul(Rt, qt), st = (st = Math.imul(Rt, Pt)) + Math.imul(Mt, qt) | 0, Oe = Math.imul(Mt, Pt);
      var Mr = (vt + (it = it + Math.imul(kt, Ct) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, Lt) | 0) + Math.imul(wt, Ct) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, Lt) | 0) + (st >>> 13) | 0) + (Mr >>> 26) | 0, Mr &= 67108863, it = Math.imul(Kt, qt), st = (st = Math.imul(Kt, Pt)) + Math.imul(jt, qt) | 0, Oe = Math.imul(jt, Pt), it = it + Math.imul(Rt, Ct) | 0, st = (st = st + Math.imul(Rt, Lt) | 0) + Math.imul(Mt, Ct) | 0, Oe = Oe + Math.imul(Mt, Lt) | 0;
      var Or = (vt + (it = it + Math.imul(kt, Jt) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, Gt) | 0) + Math.imul(wt, Jt) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, Gt) | 0) + (st >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, it = Math.imul(Yt, qt), st = (st = Math.imul(Yt, Pt)) + Math.imul(Xt, qt) | 0, Oe = Math.imul(Xt, Pt), it = it + Math.imul(Kt, Ct) | 0, st = (st = st + Math.imul(Kt, Lt) | 0) + Math.imul(jt, Ct) | 0, Oe = Oe + Math.imul(jt, Lt) | 0, it = it + Math.imul(Rt, Jt) | 0, st = (st = st + Math.imul(Rt, Gt) | 0) + Math.imul(Mt, Jt) | 0, Oe = Oe + Math.imul(Mt, Gt) | 0;
      var xr = (vt + (it = it + Math.imul(kt, or) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, tr) | 0) + Math.imul(wt, or) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, tr) | 0) + (st >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, it = Math.imul(ur, qt), st = (st = Math.imul(ur, Pt)) + Math.imul(Qt, qt) | 0, Oe = Math.imul(Qt, Pt), it = it + Math.imul(Yt, Ct) | 0, st = (st = st + Math.imul(Yt, Lt) | 0) + Math.imul(Xt, Ct) | 0, Oe = Oe + Math.imul(Xt, Lt) | 0, it = it + Math.imul(Kt, Jt) | 0, st = (st = st + Math.imul(Kt, Gt) | 0) + Math.imul(jt, Jt) | 0, Oe = Oe + Math.imul(jt, Gt) | 0, it = it + Math.imul(Rt, or) | 0, st = (st = st + Math.imul(Rt, tr) | 0) + Math.imul(Mt, or) | 0, Oe = Oe + Math.imul(Mt, tr) | 0;
      var qr = (vt + (it = it + Math.imul(kt, rr) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, fr) | 0) + Math.imul(wt, rr) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, fr) | 0) + (st >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, it = Math.imul(pr, qt), st = (st = Math.imul(pr, Pt)) + Math.imul(cr, qt) | 0, Oe = Math.imul(cr, Pt), it = it + Math.imul(ur, Ct) | 0, st = (st = st + Math.imul(ur, Lt) | 0) + Math.imul(Qt, Ct) | 0, Oe = Oe + Math.imul(Qt, Lt) | 0, it = it + Math.imul(Yt, Jt) | 0, st = (st = st + Math.imul(Yt, Gt) | 0) + Math.imul(Xt, Jt) | 0, Oe = Oe + Math.imul(Xt, Gt) | 0, it = it + Math.imul(Kt, or) | 0, st = (st = st + Math.imul(Kt, tr) | 0) + Math.imul(jt, or) | 0, Oe = Oe + Math.imul(jt, tr) | 0, it = it + Math.imul(Rt, rr) | 0, st = (st = st + Math.imul(Rt, fr) | 0) + Math.imul(Mt, rr) | 0, Oe = Oe + Math.imul(Mt, fr) | 0;
      var Cr = (vt + (it = it + Math.imul(kt, Sr) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, br) | 0) + Math.imul(wt, Sr) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, br) | 0) + (st >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, it = Math.imul(bt, qt), st = (st = Math.imul(bt, Pt)) + Math.imul(At, qt) | 0, Oe = Math.imul(At, Pt), it = it + Math.imul(pr, Ct) | 0, st = (st = st + Math.imul(pr, Lt) | 0) + Math.imul(cr, Ct) | 0, Oe = Oe + Math.imul(cr, Lt) | 0, it = it + Math.imul(ur, Jt) | 0, st = (st = st + Math.imul(ur, Gt) | 0) + Math.imul(Qt, Jt) | 0, Oe = Oe + Math.imul(Qt, Gt) | 0, it = it + Math.imul(Yt, or) | 0, st = (st = st + Math.imul(Yt, tr) | 0) + Math.imul(Xt, or) | 0, Oe = Oe + Math.imul(Xt, tr) | 0, it = it + Math.imul(Kt, rr) | 0, st = (st = st + Math.imul(Kt, fr) | 0) + Math.imul(jt, rr) | 0, Oe = Oe + Math.imul(jt, fr) | 0, it = it + Math.imul(Rt, Sr) | 0, st = (st = st + Math.imul(Rt, br) | 0) + Math.imul(Mt, Sr) | 0, Oe = Oe + Math.imul(Mt, br) | 0;
      var Nr = (vt + (it = it + Math.imul(kt, $r) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, yr) | 0) + Math.imul(wt, $r) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, yr) | 0) + (st >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, it = Math.imul(xt, qt), st = (st = Math.imul(xt, Pt)) + Math.imul(Nt, qt) | 0, Oe = Math.imul(Nt, Pt), it = it + Math.imul(bt, Ct) | 0, st = (st = st + Math.imul(bt, Lt) | 0) + Math.imul(At, Ct) | 0, Oe = Oe + Math.imul(At, Lt) | 0, it = it + Math.imul(pr, Jt) | 0, st = (st = st + Math.imul(pr, Gt) | 0) + Math.imul(cr, Jt) | 0, Oe = Oe + Math.imul(cr, Gt) | 0, it = it + Math.imul(ur, or) | 0, st = (st = st + Math.imul(ur, tr) | 0) + Math.imul(Qt, or) | 0, Oe = Oe + Math.imul(Qt, tr) | 0, it = it + Math.imul(Yt, rr) | 0, st = (st = st + Math.imul(Yt, fr) | 0) + Math.imul(Xt, rr) | 0, Oe = Oe + Math.imul(Xt, fr) | 0, it = it + Math.imul(Kt, Sr) | 0, st = (st = st + Math.imul(Kt, br) | 0) + Math.imul(jt, Sr) | 0, Oe = Oe + Math.imul(jt, br) | 0, it = it + Math.imul(Rt, $r) | 0, st = (st = st + Math.imul(Rt, yr) | 0) + Math.imul(Mt, $r) | 0, Oe = Oe + Math.imul(Mt, yr) | 0;
      var Ur = (vt + (it = it + Math.imul(kt, Tr) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, gr) | 0) + Math.imul(wt, Tr) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, gr) | 0) + (st >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, it = Math.imul(zt, qt), st = (st = Math.imul(zt, Pt)) + Math.imul(nr, qt) | 0, Oe = Math.imul(nr, Pt), it = it + Math.imul(xt, Ct) | 0, st = (st = st + Math.imul(xt, Lt) | 0) + Math.imul(Nt, Ct) | 0, Oe = Oe + Math.imul(Nt, Lt) | 0, it = it + Math.imul(bt, Jt) | 0, st = (st = st + Math.imul(bt, Gt) | 0) + Math.imul(At, Jt) | 0, Oe = Oe + Math.imul(At, Gt) | 0, it = it + Math.imul(pr, or) | 0, st = (st = st + Math.imul(pr, tr) | 0) + Math.imul(cr, or) | 0, Oe = Oe + Math.imul(cr, tr) | 0, it = it + Math.imul(ur, rr) | 0, st = (st = st + Math.imul(ur, fr) | 0) + Math.imul(Qt, rr) | 0, Oe = Oe + Math.imul(Qt, fr) | 0, it = it + Math.imul(Yt, Sr) | 0, st = (st = st + Math.imul(Yt, br) | 0) + Math.imul(Xt, Sr) | 0, Oe = Oe + Math.imul(Xt, br) | 0, it = it + Math.imul(Kt, $r) | 0, st = (st = st + Math.imul(Kt, yr) | 0) + Math.imul(jt, $r) | 0, Oe = Oe + Math.imul(jt, yr) | 0, it = it + Math.imul(Rt, Tr) | 0, st = (st = st + Math.imul(Rt, gr) | 0) + Math.imul(Mt, Tr) | 0, Oe = Oe + Math.imul(Mt, gr) | 0;
      var Lr = (vt + (it = it + Math.imul(kt, Ar) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, wr) | 0) + Math.imul(wt, Ar) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, wr) | 0) + (st >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, it = Math.imul(Dt, qt), st = (st = Math.imul(Dt, Pt)) + Math.imul(Zt, qt) | 0, Oe = Math.imul(Zt, Pt), it = it + Math.imul(zt, Ct) | 0, st = (st = st + Math.imul(zt, Lt) | 0) + Math.imul(nr, Ct) | 0, Oe = Oe + Math.imul(nr, Lt) | 0, it = it + Math.imul(xt, Jt) | 0, st = (st = st + Math.imul(xt, Gt) | 0) + Math.imul(Nt, Jt) | 0, Oe = Oe + Math.imul(Nt, Gt) | 0, it = it + Math.imul(bt, or) | 0, st = (st = st + Math.imul(bt, tr) | 0) + Math.imul(At, or) | 0, Oe = Oe + Math.imul(At, tr) | 0, it = it + Math.imul(pr, rr) | 0, st = (st = st + Math.imul(pr, fr) | 0) + Math.imul(cr, rr) | 0, Oe = Oe + Math.imul(cr, fr) | 0, it = it + Math.imul(ur, Sr) | 0, st = (st = st + Math.imul(ur, br) | 0) + Math.imul(Qt, Sr) | 0, Oe = Oe + Math.imul(Qt, br) | 0, it = it + Math.imul(Yt, $r) | 0, st = (st = st + Math.imul(Yt, yr) | 0) + Math.imul(Xt, $r) | 0, Oe = Oe + Math.imul(Xt, yr) | 0, it = it + Math.imul(Kt, Tr) | 0, st = (st = st + Math.imul(Kt, gr) | 0) + Math.imul(jt, Tr) | 0, Oe = Oe + Math.imul(jt, gr) | 0, it = it + Math.imul(Rt, Ar) | 0, st = (st = st + Math.imul(Rt, wr) | 0) + Math.imul(Mt, Ar) | 0, Oe = Oe + Math.imul(Mt, wr) | 0;
      var jr = (vt + (it = it + Math.imul(kt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(kt, Br) | 0) + Math.imul(wt, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(wt, Br) | 0) + (st >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, it = Math.imul(Dt, Ct), st = (st = Math.imul(Dt, Lt)) + Math.imul(Zt, Ct) | 0, Oe = Math.imul(Zt, Lt), it = it + Math.imul(zt, Jt) | 0, st = (st = st + Math.imul(zt, Gt) | 0) + Math.imul(nr, Jt) | 0, Oe = Oe + Math.imul(nr, Gt) | 0, it = it + Math.imul(xt, or) | 0, st = (st = st + Math.imul(xt, tr) | 0) + Math.imul(Nt, or) | 0, Oe = Oe + Math.imul(Nt, tr) | 0, it = it + Math.imul(bt, rr) | 0, st = (st = st + Math.imul(bt, fr) | 0) + Math.imul(At, rr) | 0, Oe = Oe + Math.imul(At, fr) | 0, it = it + Math.imul(pr, Sr) | 0, st = (st = st + Math.imul(pr, br) | 0) + Math.imul(cr, Sr) | 0, Oe = Oe + Math.imul(cr, br) | 0, it = it + Math.imul(ur, $r) | 0, st = (st = st + Math.imul(ur, yr) | 0) + Math.imul(Qt, $r) | 0, Oe = Oe + Math.imul(Qt, yr) | 0, it = it + Math.imul(Yt, Tr) | 0, st = (st = st + Math.imul(Yt, gr) | 0) + Math.imul(Xt, Tr) | 0, Oe = Oe + Math.imul(Xt, gr) | 0, it = it + Math.imul(Kt, Ar) | 0, st = (st = st + Math.imul(Kt, wr) | 0) + Math.imul(jt, Ar) | 0, Oe = Oe + Math.imul(jt, wr) | 0;
      var Fr = (vt + (it = it + Math.imul(Rt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(Rt, Br) | 0) + Math.imul(Mt, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(Mt, Br) | 0) + (st >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, it = Math.imul(Dt, Jt), st = (st = Math.imul(Dt, Gt)) + Math.imul(Zt, Jt) | 0, Oe = Math.imul(Zt, Gt), it = it + Math.imul(zt, or) | 0, st = (st = st + Math.imul(zt, tr) | 0) + Math.imul(nr, or) | 0, Oe = Oe + Math.imul(nr, tr) | 0, it = it + Math.imul(xt, rr) | 0, st = (st = st + Math.imul(xt, fr) | 0) + Math.imul(Nt, rr) | 0, Oe = Oe + Math.imul(Nt, fr) | 0, it = it + Math.imul(bt, Sr) | 0, st = (st = st + Math.imul(bt, br) | 0) + Math.imul(At, Sr) | 0, Oe = Oe + Math.imul(At, br) | 0, it = it + Math.imul(pr, $r) | 0, st = (st = st + Math.imul(pr, yr) | 0) + Math.imul(cr, $r) | 0, Oe = Oe + Math.imul(cr, yr) | 0, it = it + Math.imul(ur, Tr) | 0, st = (st = st + Math.imul(ur, gr) | 0) + Math.imul(Qt, Tr) | 0, Oe = Oe + Math.imul(Qt, gr) | 0, it = it + Math.imul(Yt, Ar) | 0, st = (st = st + Math.imul(Yt, wr) | 0) + Math.imul(Xt, Ar) | 0, Oe = Oe + Math.imul(Xt, wr) | 0;
      var Dr = (vt + (it = it + Math.imul(Kt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(Kt, Br) | 0) + Math.imul(jt, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(jt, Br) | 0) + (st >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, it = Math.imul(Dt, or), st = (st = Math.imul(Dt, tr)) + Math.imul(Zt, or) | 0, Oe = Math.imul(Zt, tr), it = it + Math.imul(zt, rr) | 0, st = (st = st + Math.imul(zt, fr) | 0) + Math.imul(nr, rr) | 0, Oe = Oe + Math.imul(nr, fr) | 0, it = it + Math.imul(xt, Sr) | 0, st = (st = st + Math.imul(xt, br) | 0) + Math.imul(Nt, Sr) | 0, Oe = Oe + Math.imul(Nt, br) | 0, it = it + Math.imul(bt, $r) | 0, st = (st = st + Math.imul(bt, yr) | 0) + Math.imul(At, $r) | 0, Oe = Oe + Math.imul(At, yr) | 0, it = it + Math.imul(pr, Tr) | 0, st = (st = st + Math.imul(pr, gr) | 0) + Math.imul(cr, Tr) | 0, Oe = Oe + Math.imul(cr, gr) | 0, it = it + Math.imul(ur, Ar) | 0, st = (st = st + Math.imul(ur, wr) | 0) + Math.imul(Qt, Ar) | 0, Oe = Oe + Math.imul(Qt, wr) | 0;
      var Hr = (vt + (it = it + Math.imul(Yt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(Yt, Br) | 0) + Math.imul(Xt, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(Xt, Br) | 0) + (st >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, it = Math.imul(Dt, rr), st = (st = Math.imul(Dt, fr)) + Math.imul(Zt, rr) | 0, Oe = Math.imul(Zt, fr), it = it + Math.imul(zt, Sr) | 0, st = (st = st + Math.imul(zt, br) | 0) + Math.imul(nr, Sr) | 0, Oe = Oe + Math.imul(nr, br) | 0, it = it + Math.imul(xt, $r) | 0, st = (st = st + Math.imul(xt, yr) | 0) + Math.imul(Nt, $r) | 0, Oe = Oe + Math.imul(Nt, yr) | 0, it = it + Math.imul(bt, Tr) | 0, st = (st = st + Math.imul(bt, gr) | 0) + Math.imul(At, Tr) | 0, Oe = Oe + Math.imul(At, gr) | 0, it = it + Math.imul(pr, Ar) | 0, st = (st = st + Math.imul(pr, wr) | 0) + Math.imul(cr, Ar) | 0, Oe = Oe + Math.imul(cr, wr) | 0;
      var Wr = (vt + (it = it + Math.imul(ur, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(ur, Br) | 0) + Math.imul(Qt, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(Qt, Br) | 0) + (st >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, it = Math.imul(Dt, Sr), st = (st = Math.imul(Dt, br)) + Math.imul(Zt, Sr) | 0, Oe = Math.imul(Zt, br), it = it + Math.imul(zt, $r) | 0, st = (st = st + Math.imul(zt, yr) | 0) + Math.imul(nr, $r) | 0, Oe = Oe + Math.imul(nr, yr) | 0, it = it + Math.imul(xt, Tr) | 0, st = (st = st + Math.imul(xt, gr) | 0) + Math.imul(Nt, Tr) | 0, Oe = Oe + Math.imul(Nt, gr) | 0, it = it + Math.imul(bt, Ar) | 0, st = (st = st + Math.imul(bt, wr) | 0) + Math.imul(At, Ar) | 0, Oe = Oe + Math.imul(At, wr) | 0;
      var Vr = (vt + (it = it + Math.imul(pr, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(pr, Br) | 0) + Math.imul(cr, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(cr, Br) | 0) + (st >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, it = Math.imul(Dt, $r), st = (st = Math.imul(Dt, yr)) + Math.imul(Zt, $r) | 0, Oe = Math.imul(Zt, yr), it = it + Math.imul(zt, Tr) | 0, st = (st = st + Math.imul(zt, gr) | 0) + Math.imul(nr, Tr) | 0, Oe = Oe + Math.imul(nr, gr) | 0, it = it + Math.imul(xt, Ar) | 0, st = (st = st + Math.imul(xt, wr) | 0) + Math.imul(Nt, Ar) | 0, Oe = Oe + Math.imul(Nt, wr) | 0;
      var zr = (vt + (it = it + Math.imul(bt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(bt, Br) | 0) + Math.imul(At, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(At, Br) | 0) + (st >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, it = Math.imul(Dt, Tr), st = (st = Math.imul(Dt, gr)) + Math.imul(Zt, Tr) | 0, Oe = Math.imul(Zt, gr), it = it + Math.imul(zt, Ar) | 0, st = (st = st + Math.imul(zt, wr) | 0) + Math.imul(nr, Ar) | 0, Oe = Oe + Math.imul(nr, wr) | 0;
      var Gr = (vt + (it = it + Math.imul(xt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(xt, Br) | 0) + Math.imul(Nt, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(Nt, Br) | 0) + (st >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, it = Math.imul(Dt, Ar), st = (st = Math.imul(Dt, wr)) + Math.imul(Zt, Ar) | 0, Oe = Math.imul(Zt, wr);
      var Yr = (vt + (it = it + Math.imul(zt, Ir) | 0) | 0) + ((8191 & (st = (st = st + Math.imul(zt, Br) | 0) + Math.imul(nr, Ir) | 0)) << 13) | 0;
      vt = ((Oe = Oe + Math.imul(nr, Br) | 0) + (st >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863;
      var Jr = (vt + (it = Math.imul(Dt, Ir)) | 0) + ((8191 & (st = (st = Math.imul(Dt, Br)) + Math.imul(Zt, Ir) | 0)) << 13) | 0;
      return vt = ((Oe = Math.imul(Zt, Br)) + (st >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, gt[0] = Pr, gt[1] = Mr, gt[2] = Or, gt[3] = xr, gt[4] = qr, gt[5] = Cr, gt[6] = Nr, gt[7] = Ur, gt[8] = Lr, gt[9] = jr, gt[10] = Fr, gt[11] = Dr, gt[12] = Hr, gt[13] = Wr, gt[14] = Vr, gt[15] = zr, gt[16] = Gr, gt[17] = Yr, gt[18] = Jr, vt !== 0 && (gt[19] = vt, rt.length++), rt;
    };
    function dt(Ce, nt, rt) {
      rt.negative = nt.negative ^ Ce.negative, rt.length = Ce.length + nt.length;
      for (var it = 0, st = 0, Oe = 0; Oe < rt.length - 1; Oe++) {
        var ct = st;
        st = 0;
        for (var pt = 67108863 & it, gt = Math.min(Oe, nt.length - 1), vt = Math.max(0, Oe - Ce.length + 1); vt <= gt; vt++) {
          var Bt = Oe - vt, kt = (0 | Ce.words[Bt]) * (0 | nt.words[vt]), wt = 67108863 & kt;
          pt = 67108863 & (wt = wt + pt | 0), st += (ct = (ct = ct + (kt / 67108864 | 0) | 0) + (wt >>> 26) | 0) >>> 26, ct &= 67108863;
        }
        rt.words[Oe] = pt, it = ct, ct = st;
      }
      return it !== 0 ? rt.words[Oe] = it : rt.length--, rt._strip();
    }
    function lt(Ce, nt, rt) {
      return dt(Ce, nt, rt);
    }
    Math.imul || (ft = at), V.prototype.mulTo = function(Ce, nt) {
      var rt = this.length + Ce.length;
      return this.length === 10 && Ce.length === 10 ? ft(this, Ce, nt) : rt < 63 ? at(this, Ce, nt) : rt < 1024 ? dt(this, Ce, nt) : lt(this, Ce, nt);
    }, V.prototype.mul = function(Ce) {
      var nt = new V(null);
      return nt.words = new Array(this.length + Ce.length), this.mulTo(Ce, nt);
    }, V.prototype.mulf = function(Ce) {
      var nt = new V(null);
      return nt.words = new Array(this.length + Ce.length), lt(this, Ce, nt);
    }, V.prototype.imul = function(Ce) {
      return this.clone().mulTo(Ce, this);
    }, V.prototype.imuln = function(Ce) {
      var nt = Ce < 0;
      nt && (Ce = -Ce), K(typeof Ce == "number"), K(Ce < 67108864);
      for (var rt = 0, it = 0; it < this.length; it++) {
        var st = (0 | this.words[it]) * Ce, Oe = (67108863 & st) + (67108863 & rt);
        rt >>= 26, rt += st / 67108864 | 0, rt += Oe >>> 26, this.words[it] = 67108863 & Oe;
      }
      return rt !== 0 && (this.words[it] = rt, this.length++), nt ? this.ineg() : this;
    }, V.prototype.muln = function(Ce) {
      return this.clone().imuln(Ce);
    }, V.prototype.sqr = function() {
      return this.mul(this);
    }, V.prototype.isqr = function() {
      return this.imul(this.clone());
    }, V.prototype.pow = function(Ce) {
      var nt = function(Oe) {
        for (var ct = new Array(Oe.bitLength()), pt = 0; pt < ct.length; pt++) {
          var gt = pt / 26 | 0, vt = pt % 26;
          ct[pt] = Oe.words[gt] >>> vt & 1;
        }
        return ct;
      }(Ce);
      if (nt.length === 0) return new V(1);
      for (var rt = this, it = 0; it < nt.length && nt[it] === 0; it++, rt = rt.sqr()) ;
      if (++it < nt.length) for (var st = rt.sqr(); it < nt.length; it++, st = st.sqr()) nt[it] !== 0 && (rt = rt.mul(st));
      return rt;
    }, V.prototype.iushln = function(Ce) {
      K(typeof Ce == "number" && Ce >= 0);
      var nt, rt = Ce % 26, it = (Ce - rt) / 26, st = 67108863 >>> 26 - rt << 26 - rt;
      if (rt !== 0) {
        var Oe = 0;
        for (nt = 0; nt < this.length; nt++) {
          var ct = this.words[nt] & st, pt = (0 | this.words[nt]) - ct << rt;
          this.words[nt] = pt | Oe, Oe = ct >>> 26 - rt;
        }
        Oe && (this.words[nt] = Oe, this.length++);
      }
      if (it !== 0) {
        for (nt = this.length - 1; nt >= 0; nt--) this.words[nt + it] = this.words[nt];
        for (nt = 0; nt < it; nt++) this.words[nt] = 0;
        this.length += it;
      }
      return this._strip();
    }, V.prototype.ishln = function(Ce) {
      return K(this.negative === 0), this.iushln(Ce);
    }, V.prototype.iushrn = function(Ce, nt, rt) {
      var it;
      K(typeof Ce == "number" && Ce >= 0), it = nt ? (nt - nt % 26) / 26 : 0;
      var st = Ce % 26, Oe = Math.min((Ce - st) / 26, this.length), ct = 67108863 ^ 67108863 >>> st << st, pt = rt;
      if (it -= Oe, it = Math.max(0, it), pt) {
        for (var gt = 0; gt < Oe; gt++) pt.words[gt] = this.words[gt];
        pt.length = Oe;
      }
      if (Oe !== 0) if (this.length > Oe) for (this.length -= Oe, gt = 0; gt < this.length; gt++) this.words[gt] = this.words[gt + Oe];
      else this.words[0] = 0, this.length = 1;
      var vt = 0;
      for (gt = this.length - 1; gt >= 0 && (vt !== 0 || gt >= it); gt--) {
        var Bt = 0 | this.words[gt];
        this.words[gt] = vt << 26 - st | Bt >>> st, vt = Bt & ct;
      }
      return pt && vt !== 0 && (pt.words[pt.length++] = vt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, V.prototype.ishrn = function(Ce, nt, rt) {
      return K(this.negative === 0), this.iushrn(Ce, nt, rt);
    }, V.prototype.shln = function(Ce) {
      return this.clone().ishln(Ce);
    }, V.prototype.ushln = function(Ce) {
      return this.clone().iushln(Ce);
    }, V.prototype.shrn = function(Ce) {
      return this.clone().ishrn(Ce);
    }, V.prototype.ushrn = function(Ce) {
      return this.clone().iushrn(Ce);
    }, V.prototype.testn = function(Ce) {
      K(typeof Ce == "number" && Ce >= 0);
      var nt = Ce % 26, rt = (Ce - nt) / 26, it = 1 << nt;
      return !(this.length <= rt || !(this.words[rt] & it));
    }, V.prototype.imaskn = function(Ce) {
      K(typeof Ce == "number" && Ce >= 0);
      var nt = Ce % 26, rt = (Ce - nt) / 26;
      if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= rt) return this;
      if (nt !== 0 && rt++, this.length = Math.min(rt, this.length), nt !== 0) {
        var it = 67108863 ^ 67108863 >>> nt << nt;
        this.words[this.length - 1] &= it;
      }
      return this._strip();
    }, V.prototype.maskn = function(Ce) {
      return this.clone().imaskn(Ce);
    }, V.prototype.iaddn = function(Ce) {
      return K(typeof Ce == "number"), K(Ce < 67108864), Ce < 0 ? this.isubn(-Ce) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) <= Ce ? (this.words[0] = Ce - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(Ce), this.negative = 1, this) : this._iaddn(Ce);
    }, V.prototype._iaddn = function(Ce) {
      this.words[0] += Ce;
      for (var nt = 0; nt < this.length && this.words[nt] >= 67108864; nt++) this.words[nt] -= 67108864, nt === this.length - 1 ? this.words[nt + 1] = 1 : this.words[nt + 1]++;
      return this.length = Math.max(this.length, nt + 1), this;
    }, V.prototype.isubn = function(Ce) {
      if (K(typeof Ce == "number"), K(Ce < 67108864), Ce < 0) return this.iaddn(-Ce);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(Ce), this.negative = 1, this;
      if (this.words[0] -= Ce, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var nt = 0; nt < this.length && this.words[nt] < 0; nt++) this.words[nt] += 67108864, this.words[nt + 1] -= 1;
      return this._strip();
    }, V.prototype.addn = function(Ce) {
      return this.clone().iaddn(Ce);
    }, V.prototype.subn = function(Ce) {
      return this.clone().isubn(Ce);
    }, V.prototype.iabs = function() {
      return this.negative = 0, this;
    }, V.prototype.abs = function() {
      return this.clone().iabs();
    }, V.prototype._ishlnsubmul = function(Ce, nt, rt) {
      var it, st, Oe = Ce.length + rt;
      this._expand(Oe);
      var ct = 0;
      for (it = 0; it < Ce.length; it++) {
        st = (0 | this.words[it + rt]) + ct;
        var pt = (0 | Ce.words[it]) * nt;
        ct = ((st -= 67108863 & pt) >> 26) - (pt / 67108864 | 0), this.words[it + rt] = 67108863 & st;
      }
      for (; it < this.length - rt; it++) ct = (st = (0 | this.words[it + rt]) + ct) >> 26, this.words[it + rt] = 67108863 & st;
      if (ct === 0) return this._strip();
      for (K(ct === -1), ct = 0, it = 0; it < this.length; it++) ct = (st = -(0 | this.words[it]) + ct) >> 26, this.words[it] = 67108863 & st;
      return this.negative = 1, this._strip();
    }, V.prototype._wordDiv = function(Ce, nt) {
      var rt = (this.length, Ce.length), it = this.clone(), st = Ce, Oe = 0 | st.words[st.length - 1];
      (rt = 26 - this._countBits(Oe)) != 0 && (st = st.ushln(rt), it.iushln(rt), Oe = 0 | st.words[st.length - 1]);
      var ct, pt = it.length - st.length;
      if (nt !== "mod") {
        (ct = new V(null)).length = pt + 1, ct.words = new Array(ct.length);
        for (var gt = 0; gt < ct.length; gt++) ct.words[gt] = 0;
      }
      var vt = it.clone()._ishlnsubmul(st, 1, pt);
      vt.negative === 0 && (it = vt, ct && (ct.words[pt] = 1));
      for (var Bt = pt - 1; Bt >= 0; Bt--) {
        var kt = 67108864 * (0 | it.words[st.length + Bt]) + (0 | it.words[st.length + Bt - 1]);
        for (kt = Math.min(kt / Oe | 0, 67108863), it._ishlnsubmul(st, kt, Bt); it.negative !== 0; ) kt--, it.negative = 0, it._ishlnsubmul(st, 1, Bt), it.isZero() || (it.negative ^= 1);
        ct && (ct.words[Bt] = kt);
      }
      return ct && ct._strip(), it._strip(), nt !== "div" && rt !== 0 && it.iushrn(rt), { div: ct || null, mod: it };
    }, V.prototype.divmod = function(Ce, nt, rt) {
      return K(!Ce.isZero()), this.isZero() ? { div: new V(0), mod: new V(0) } : this.negative !== 0 && Ce.negative === 0 ? (Oe = this.neg().divmod(Ce, nt), nt !== "mod" && (it = Oe.div.neg()), nt !== "div" && (st = Oe.mod.neg(), rt && st.negative !== 0 && st.iadd(Ce)), { div: it, mod: st }) : this.negative === 0 && Ce.negative !== 0 ? (Oe = this.divmod(Ce.neg(), nt), nt !== "mod" && (it = Oe.div.neg()), { div: it, mod: Oe.mod }) : this.negative & Ce.negative ? (Oe = this.neg().divmod(Ce.neg(), nt), nt !== "div" && (st = Oe.mod.neg(), rt && st.negative !== 0 && st.isub(Ce)), { div: Oe.div, mod: st }) : Ce.length > this.length || this.cmp(Ce) < 0 ? { div: new V(0), mod: this } : Ce.length === 1 ? nt === "div" ? { div: this.divn(Ce.words[0]), mod: null } : nt === "mod" ? { div: null, mod: new V(this.modrn(Ce.words[0])) } : { div: this.divn(Ce.words[0]), mod: new V(this.modrn(Ce.words[0])) } : this._wordDiv(Ce, nt);
      var it, st, Oe;
    }, V.prototype.div = function(Ce) {
      return this.divmod(Ce, "div", !1).div;
    }, V.prototype.mod = function(Ce) {
      return this.divmod(Ce, "mod", !1).mod;
    }, V.prototype.umod = function(Ce) {
      return this.divmod(Ce, "mod", !0).mod;
    }, V.prototype.divRound = function(Ce) {
      var nt = this.divmod(Ce);
      if (nt.mod.isZero()) return nt.div;
      var rt = nt.div.negative !== 0 ? nt.mod.isub(Ce) : nt.mod, it = Ce.ushrn(1), st = Ce.andln(1), Oe = rt.cmp(it);
      return Oe < 0 || st === 1 && Oe === 0 ? nt.div : nt.div.negative !== 0 ? nt.div.isubn(1) : nt.div.iaddn(1);
    }, V.prototype.modrn = function(Ce) {
      var nt = Ce < 0;
      nt && (Ce = -Ce), K(Ce <= 67108863);
      for (var rt = (1 << 26) % Ce, it = 0, st = this.length - 1; st >= 0; st--) it = (rt * it + (0 | this.words[st])) % Ce;
      return nt ? -it : it;
    }, V.prototype.modn = function(Ce) {
      return this.modrn(Ce);
    }, V.prototype.idivn = function(Ce) {
      var nt = Ce < 0;
      nt && (Ce = -Ce), K(Ce <= 67108863);
      for (var rt = 0, it = this.length - 1; it >= 0; it--) {
        var st = (0 | this.words[it]) + 67108864 * rt;
        this.words[it] = st / Ce | 0, rt = st % Ce;
      }
      return this._strip(), nt ? this.ineg() : this;
    }, V.prototype.divn = function(Ce) {
      return this.clone().idivn(Ce);
    }, V.prototype.egcd = function(Ce) {
      K(Ce.negative === 0), K(!Ce.isZero());
      var nt = this, rt = Ce.clone();
      nt = nt.negative !== 0 ? nt.umod(Ce) : nt.clone();
      for (var it = new V(1), st = new V(0), Oe = new V(0), ct = new V(1), pt = 0; nt.isEven() && rt.isEven(); ) nt.iushrn(1), rt.iushrn(1), ++pt;
      for (var gt = rt.clone(), vt = nt.clone(); !nt.isZero(); ) {
        for (var Bt = 0, kt = 1; !(nt.words[0] & kt) && Bt < 26; ++Bt, kt <<= 1) ;
        if (Bt > 0) for (nt.iushrn(Bt); Bt-- > 0; ) (it.isOdd() || st.isOdd()) && (it.iadd(gt), st.isub(vt)), it.iushrn(1), st.iushrn(1);
        for (var wt = 0, Et = 1; !(rt.words[0] & Et) && wt < 26; ++wt, Et <<= 1) ;
        if (wt > 0) for (rt.iushrn(wt); wt-- > 0; ) (Oe.isOdd() || ct.isOdd()) && (Oe.iadd(gt), ct.isub(vt)), Oe.iushrn(1), ct.iushrn(1);
        nt.cmp(rt) >= 0 ? (nt.isub(rt), it.isub(Oe), st.isub(ct)) : (rt.isub(nt), Oe.isub(it), ct.isub(st));
      }
      return { a: Oe, b: ct, gcd: rt.iushln(pt) };
    }, V.prototype._invmp = function(Ce) {
      K(Ce.negative === 0), K(!Ce.isZero());
      var nt = this, rt = Ce.clone();
      nt = nt.negative !== 0 ? nt.umod(Ce) : nt.clone();
      for (var it, st = new V(1), Oe = new V(0), ct = rt.clone(); nt.cmpn(1) > 0 && rt.cmpn(1) > 0; ) {
        for (var pt = 0, gt = 1; !(nt.words[0] & gt) && pt < 26; ++pt, gt <<= 1) ;
        if (pt > 0) for (nt.iushrn(pt); pt-- > 0; ) st.isOdd() && st.iadd(ct), st.iushrn(1);
        for (var vt = 0, Bt = 1; !(rt.words[0] & Bt) && vt < 26; ++vt, Bt <<= 1) ;
        if (vt > 0) for (rt.iushrn(vt); vt-- > 0; ) Oe.isOdd() && Oe.iadd(ct), Oe.iushrn(1);
        nt.cmp(rt) >= 0 ? (nt.isub(rt), st.isub(Oe)) : (rt.isub(nt), Oe.isub(st));
      }
      return (it = nt.cmpn(1) === 0 ? st : Oe).cmpn(0) < 0 && it.iadd(Ce), it;
    }, V.prototype.gcd = function(Ce) {
      if (this.isZero()) return Ce.abs();
      if (Ce.isZero()) return this.abs();
      var nt = this.clone(), rt = Ce.clone();
      nt.negative = 0, rt.negative = 0;
      for (var it = 0; nt.isEven() && rt.isEven(); it++) nt.iushrn(1), rt.iushrn(1);
      for (; ; ) {
        for (; nt.isEven(); ) nt.iushrn(1);
        for (; rt.isEven(); ) rt.iushrn(1);
        var st = nt.cmp(rt);
        if (st < 0) {
          var Oe = nt;
          nt = rt, rt = Oe;
        } else if (st === 0 || rt.cmpn(1) === 0) break;
        nt.isub(rt);
      }
      return rt.iushln(it);
    }, V.prototype.invm = function(Ce) {
      return this.egcd(Ce).a.umod(Ce);
    }, V.prototype.isEven = function() {
      return !(1 & this.words[0]);
    }, V.prototype.isOdd = function() {
      return !(1 & ~this.words[0]);
    }, V.prototype.andln = function(Ce) {
      return this.words[0] & Ce;
    }, V.prototype.bincn = function(Ce) {
      K(typeof Ce == "number");
      var nt = Ce % 26, rt = (Ce - nt) / 26, it = 1 << nt;
      if (this.length <= rt) return this._expand(rt + 1), this.words[rt] |= it, this;
      for (var st = it, Oe = rt; st !== 0 && Oe < this.length; Oe++) {
        var ct = 0 | this.words[Oe];
        st = (ct += st) >>> 26, ct &= 67108863, this.words[Oe] = ct;
      }
      return st !== 0 && (this.words[Oe] = st, this.length++), this;
    }, V.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, V.prototype.cmpn = function(Ce) {
      var nt, rt = Ce < 0;
      if (this.negative !== 0 && !rt) return -1;
      if (this.negative === 0 && rt) return 1;
      if (this._strip(), this.length > 1) nt = 1;
      else {
        rt && (Ce = -Ce), K(Ce <= 67108863, "Number is too big");
        var it = 0 | this.words[0];
        nt = it === Ce ? 0 : it < Ce ? -1 : 1;
      }
      return this.negative !== 0 ? 0 | -nt : nt;
    }, V.prototype.cmp = function(Ce) {
      if (this.negative !== 0 && Ce.negative === 0) return -1;
      if (this.negative === 0 && Ce.negative !== 0) return 1;
      var nt = this.ucmp(Ce);
      return this.negative !== 0 ? 0 | -nt : nt;
    }, V.prototype.ucmp = function(Ce) {
      if (this.length > Ce.length) return 1;
      if (this.length < Ce.length) return -1;
      for (var nt = 0, rt = this.length - 1; rt >= 0; rt--) {
        var it = 0 | this.words[rt], st = 0 | Ce.words[rt];
        if (it !== st) {
          it < st ? nt = -1 : it > st && (nt = 1);
          break;
        }
      }
      return nt;
    }, V.prototype.gtn = function(Ce) {
      return this.cmpn(Ce) === 1;
    }, V.prototype.gt = function(Ce) {
      return this.cmp(Ce) === 1;
    }, V.prototype.gten = function(Ce) {
      return this.cmpn(Ce) >= 0;
    }, V.prototype.gte = function(Ce) {
      return this.cmp(Ce) >= 0;
    }, V.prototype.ltn = function(Ce) {
      return this.cmpn(Ce) === -1;
    }, V.prototype.lt = function(Ce) {
      return this.cmp(Ce) === -1;
    }, V.prototype.lten = function(Ce) {
      return this.cmpn(Ce) <= 0;
    }, V.prototype.lte = function(Ce) {
      return this.cmp(Ce) <= 0;
    }, V.prototype.eqn = function(Ce) {
      return this.cmpn(Ce) === 0;
    }, V.prototype.eq = function(Ce) {
      return this.cmp(Ce) === 0;
    }, V.red = function(Ce) {
      return new ut(Ce);
    }, V.prototype.toRed = function(Ce) {
      return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), Ce.convertTo(this)._forceRed(Ce);
    }, V.prototype.fromRed = function() {
      return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, V.prototype._forceRed = function(Ce) {
      return this.red = Ce, this;
    }, V.prototype.forceRed = function(Ce) {
      return K(!this.red, "Already a number in reduction context"), this._forceRed(Ce);
    }, V.prototype.redAdd = function(Ce) {
      return K(this.red, "redAdd works only with red numbers"), this.red.add(this, Ce);
    }, V.prototype.redIAdd = function(Ce) {
      return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Ce);
    }, V.prototype.redSub = function(Ce) {
      return K(this.red, "redSub works only with red numbers"), this.red.sub(this, Ce);
    }, V.prototype.redISub = function(Ce) {
      return K(this.red, "redISub works only with red numbers"), this.red.isub(this, Ce);
    }, V.prototype.redShl = function(Ce) {
      return K(this.red, "redShl works only with red numbers"), this.red.shl(this, Ce);
    }, V.prototype.redMul = function(Ce) {
      return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ce), this.red.mul(this, Ce);
    }, V.prototype.redIMul = function(Ce) {
      return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ce), this.red.imul(this, Ce);
    }, V.prototype.redSqr = function() {
      return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, V.prototype.redISqr = function() {
      return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, V.prototype.redSqrt = function() {
      return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, V.prototype.redInvm = function() {
      return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, V.prototype.redNeg = function() {
      return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, V.prototype.redPow = function(Ce) {
      return K(this.red && !Ce.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Ce);
    };
    var yt = { k256: null, p224: null, p192: null, p25519: null };
    function St(Ce, nt) {
      this.name = Ce, this.p = new V(nt, 16), this.n = this.p.bitLength(), this.k = new V(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    function mt() {
      St.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    function $t() {
      St.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    function It() {
      St.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    function Ut() {
      St.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    function ut(Ce) {
      if (typeof Ce == "string") {
        var nt = V._prime(Ce);
        this.m = nt.p, this.prime = nt;
      } else K(Ce.gtn(1), "modulus must be greater than 1"), this.m = Ce, this.prime = null;
    }
    function ht(Ce) {
      ut.call(this, Ce), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new V(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    St.prototype._tmp = function() {
      var Ce = new V(null);
      return Ce.words = new Array(Math.ceil(this.n / 13)), Ce;
    }, St.prototype.ireduce = function(Ce) {
      var nt, rt = Ce;
      do
        this.split(rt, this.tmp), nt = (rt = (rt = this.imulK(rt)).iadd(this.tmp)).bitLength();
      while (nt > this.n);
      var it = nt < this.n ? -1 : rt.ucmp(this.p);
      return it === 0 ? (rt.words[0] = 0, rt.length = 1) : it > 0 ? rt.isub(this.p) : rt.strip !== void 0 ? rt.strip() : rt._strip(), rt;
    }, St.prototype.split = function(Ce, nt) {
      Ce.iushrn(this.n, 0, nt);
    }, St.prototype.imulK = function(Ce) {
      return Ce.imul(this.k);
    }, W(mt, St), mt.prototype.split = function(Ce, nt) {
      for (var rt = 4194303, it = Math.min(Ce.length, 9), st = 0; st < it; st++) nt.words[st] = Ce.words[st];
      if (nt.length = it, Ce.length <= 9) return Ce.words[0] = 0, void (Ce.length = 1);
      var Oe = Ce.words[9];
      for (nt.words[nt.length++] = Oe & rt, st = 10; st < Ce.length; st++) {
        var ct = 0 | Ce.words[st];
        Ce.words[st - 10] = (ct & rt) << 4 | Oe >>> 22, Oe = ct;
      }
      Oe >>>= 22, Ce.words[st - 10] = Oe, Oe === 0 && Ce.length > 10 ? Ce.length -= 10 : Ce.length -= 9;
    }, mt.prototype.imulK = function(Ce) {
      Ce.words[Ce.length] = 0, Ce.words[Ce.length + 1] = 0, Ce.length += 2;
      for (var nt = 0, rt = 0; rt < Ce.length; rt++) {
        var it = 0 | Ce.words[rt];
        nt += 977 * it, Ce.words[rt] = 67108863 & nt, nt = 64 * it + (nt / 67108864 | 0);
      }
      return Ce.words[Ce.length - 1] === 0 && (Ce.length--, Ce.words[Ce.length - 1] === 0 && Ce.length--), Ce;
    }, W($t, St), W(It, St), W(Ut, St), Ut.prototype.imulK = function(Ce) {
      for (var nt = 0, rt = 0; rt < Ce.length; rt++) {
        var it = 19 * (0 | Ce.words[rt]) + nt, st = 67108863 & it;
        it >>>= 26, Ce.words[rt] = st, nt = it;
      }
      return nt !== 0 && (Ce.words[Ce.length++] = nt), Ce;
    }, V._prime = function(Ce) {
      if (yt[Ce]) return yt[Ce];
      var nt;
      if (Ce === "k256") nt = new mt();
      else if (Ce === "p224") nt = new $t();
      else if (Ce === "p192") nt = new It();
      else {
        if (Ce !== "p25519") throw new Error("Unknown prime " + Ce);
        nt = new Ut();
      }
      return yt[Ce] = nt, nt;
    }, ut.prototype._verify1 = function(Ce) {
      K(Ce.negative === 0, "red works only with positives"), K(Ce.red, "red works only with red numbers");
    }, ut.prototype._verify2 = function(Ce, nt) {
      K(!(Ce.negative | nt.negative), "red works only with positives"), K(Ce.red && Ce.red === nt.red, "red works only with red numbers");
    }, ut.prototype.imod = function(Ce) {
      return this.prime ? this.prime.ireduce(Ce)._forceRed(this) : (oe(Ce, Ce.umod(this.m)._forceRed(this)), Ce);
    }, ut.prototype.neg = function(Ce) {
      return Ce.isZero() ? Ce.clone() : this.m.sub(Ce)._forceRed(this);
    }, ut.prototype.add = function(Ce, nt) {
      this._verify2(Ce, nt);
      var rt = Ce.add(nt);
      return rt.cmp(this.m) >= 0 && rt.isub(this.m), rt._forceRed(this);
    }, ut.prototype.iadd = function(Ce, nt) {
      this._verify2(Ce, nt);
      var rt = Ce.iadd(nt);
      return rt.cmp(this.m) >= 0 && rt.isub(this.m), rt;
    }, ut.prototype.sub = function(Ce, nt) {
      this._verify2(Ce, nt);
      var rt = Ce.sub(nt);
      return rt.cmpn(0) < 0 && rt.iadd(this.m), rt._forceRed(this);
    }, ut.prototype.isub = function(Ce, nt) {
      this._verify2(Ce, nt);
      var rt = Ce.isub(nt);
      return rt.cmpn(0) < 0 && rt.iadd(this.m), rt;
    }, ut.prototype.shl = function(Ce, nt) {
      return this._verify1(Ce), this.imod(Ce.ushln(nt));
    }, ut.prototype.imul = function(Ce, nt) {
      return this._verify2(Ce, nt), this.imod(Ce.imul(nt));
    }, ut.prototype.mul = function(Ce, nt) {
      return this._verify2(Ce, nt), this.imod(Ce.mul(nt));
    }, ut.prototype.isqr = function(Ce) {
      return this.imul(Ce, Ce.clone());
    }, ut.prototype.sqr = function(Ce) {
      return this.mul(Ce, Ce);
    }, ut.prototype.sqrt = function(Ce) {
      if (Ce.isZero()) return Ce.clone();
      var nt = this.m.andln(3);
      if (K(nt % 2 == 1), nt === 3) {
        var rt = this.m.add(new V(1)).iushrn(2);
        return this.pow(Ce, rt);
      }
      for (var it = this.m.subn(1), st = 0; !it.isZero() && it.andln(1) === 0; ) st++, it.iushrn(1);
      K(!it.isZero());
      var Oe = new V(1).toRed(this), ct = Oe.redNeg(), pt = this.m.subn(1).iushrn(1), gt = this.m.bitLength();
      for (gt = new V(2 * gt * gt).toRed(this); this.pow(gt, pt).cmp(ct) !== 0; ) gt.redIAdd(ct);
      for (var vt = this.pow(gt, it), Bt = this.pow(Ce, it.addn(1).iushrn(1)), kt = this.pow(Ce, it), wt = st; kt.cmp(Oe) !== 0; ) {
        for (var Et = kt, Rt = 0; Et.cmp(Oe) !== 0; Rt++) Et = Et.redSqr();
        K(Rt < wt);
        var Mt = this.pow(vt, new V(1).iushln(wt - Rt - 1));
        Bt = Bt.redMul(Mt), vt = Mt.redSqr(), kt = kt.redMul(vt), wt = Rt;
      }
      return Bt;
    }, ut.prototype.invm = function(Ce) {
      var nt = Ce._invmp(this.m);
      return nt.negative !== 0 ? (nt.negative = 0, this.imod(nt).redNeg()) : this.imod(nt);
    }, ut.prototype.pow = function(Ce, nt) {
      if (nt.isZero()) return new V(1).toRed(this);
      if (nt.cmpn(1) === 0) return Ce.clone();
      var rt = new Array(16);
      rt[0] = new V(1).toRed(this), rt[1] = Ce;
      for (var it = 2; it < rt.length; it++) rt[it] = this.mul(rt[it - 1], Ce);
      var st = rt[0], Oe = 0, ct = 0, pt = nt.bitLength() % 26;
      for (pt === 0 && (pt = 26), it = nt.length - 1; it >= 0; it--) {
        for (var gt = nt.words[it], vt = pt - 1; vt >= 0; vt--) {
          var Bt = gt >> vt & 1;
          st !== rt[0] && (st = this.sqr(st)), Bt !== 0 || Oe !== 0 ? (Oe <<= 1, Oe |= Bt, (++ct == 4 || it === 0 && vt === 0) && (st = this.mul(st, rt[Oe]), ct = 0, Oe = 0)) : ct = 0;
        }
        pt = 26;
      }
      return st;
    }, ut.prototype.convertTo = function(Ce) {
      var nt = Ce.umod(this.m);
      return nt === Ce ? nt.clone() : nt;
    }, ut.prototype.convertFrom = function(Ce) {
      var nt = Ce.clone();
      return nt.red = null, nt;
    }, V.mont = function(Ce) {
      return new ht(Ce);
    }, W(ht, ut), ht.prototype.convertTo = function(Ce) {
      return this.imod(Ce.ushln(this.shift));
    }, ht.prototype.convertFrom = function(Ce) {
      var nt = this.imod(Ce.mul(this.rinv));
      return nt.red = null, nt;
    }, ht.prototype.imul = function(Ce, nt) {
      if (Ce.isZero() || nt.isZero()) return Ce.words[0] = 0, Ce.length = 1, Ce;
      var rt = Ce.imul(nt), it = rt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), st = rt.isub(it).iushrn(this.shift), Oe = st;
      return st.cmp(this.m) >= 0 ? Oe = st.isub(this.m) : st.cmpn(0) < 0 && (Oe = st.iadd(this.m)), Oe._forceRed(this);
    }, ht.prototype.mul = function(Ce, nt) {
      if (Ce.isZero() || nt.isZero()) return new V(0)._forceRed(this);
      var rt = Ce.mul(nt), it = rt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), st = rt.isub(it).iushrn(this.shift), Oe = st;
      return st.cmp(this.m) >= 0 ? Oe = st.isub(this.m) : st.cmpn(0) < 0 && (Oe = st.iadd(this.m)), Oe._forceRed(this);
    }, ht.prototype.invm = function(Ce) {
      return this.imod(Ce._invmp(this.m).mul(this.r2))._forceRed(this);
    };
  }(0, commonjsGlobal)), bn.exports;
}
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var B = requireBn(), L = browserExports;
  function K(V) {
    var J, re = V.modulus.byteLength();
    do
      J = new B(L(re));
    while (J.cmp(V.modulus) >= 0 || !J.umod(V.prime1) || !J.umod(V.prime2));
    return J;
  }
  function W(V, J) {
    var re = function(lt) {
      var yt = K(lt);
      return { blinder: yt.toRed(B.mont(lt.modulus)).redPow(new B(lt.publicExponent)).fromRed(), unblinder: yt.invm(lt.modulus) };
    }(J), ie = J.modulus.byteLength(), ne = new B(V).mul(re.blinder).umod(J.modulus), oe = ne.toRed(B.mont(J.prime1)), ce = ne.toRed(B.mont(J.prime2)), pe = J.coefficient, ke = J.prime1, ot = J.prime2, at = oe.redPow(J.exponent1).fromRed(), ft = ce.redPow(J.exponent2).fromRed(), dt = at.isub(ft).imul(pe).umod(ke).imul(ot);
    return ft.iadd(dt).imul(re.unblinder).umod(J.modulus).toArrayLike(Buffer$3, "be", ie);
  }
  return W.getr = K, browserifyRsa = W;
}
bn.exports;
var elliptic = {};
const name = "elliptic", version = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = ["lib"], scripts = { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository = { type: "git", url: "git@github.com:indutny/elliptic" }, keywords = ["EC", "Elliptic", "curve", "Cryptography"], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = { url: "https://github.com/indutny/elliptic/issues" }, homepage = "https://github.com/indutny/elliptic", devDependencies = { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies = { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" }, require$$0 = { name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies };
var utils$2 = {}, utils$1 = {}, hasRequiredUtils$2, hasRequiredUtils$1;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function() {
    var B = utils$1;
    function L(W) {
      return W.length === 1 ? "0" + W : W;
    }
    function K(W) {
      for (var V = "", J = 0; J < W.length; J++) V += L(W[J].toString(16));
      return V;
    }
    B.toArray = function(W, V) {
      if (Array.isArray(W)) return W.slice();
      if (!W) return [];
      var J = [];
      if (typeof W != "string") {
        for (var re = 0; re < W.length; re++) J[re] = 0 | W[re];
        return J;
      }
      if (V === "hex") for ((W = W.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (W = "0" + W), re = 0; re < W.length; re += 2) J.push(parseInt(W[re] + W[re + 1], 16));
      else for (re = 0; re < W.length; re++) {
        var ie = W.charCodeAt(re), ne = ie >> 8, oe = 255 & ie;
        ne ? J.push(ne, oe) : J.push(oe);
      }
      return J;
    }, B.zero2 = L, B.toHex = K, B.encode = function(W, V) {
      return V === "hex" ? K(W) : W;
    };
  }()), utils$1;
}
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function() {
    var B = utils$2, L = requireBn$1(), K = requireMinimalisticAssert(), W = requireUtils$2();
    B.assert = K, B.toArray = W.toArray, B.zero2 = W.zero2, B.toHex = W.toHex, B.encode = W.encode, B.getNAF = function(V, J, re) {
      var ie, ne = new Array(Math.max(V.bitLength(), re) + 1);
      for (ie = 0; ie < ne.length; ie += 1) ne[ie] = 0;
      var oe = 1 << J + 1, ce = V.clone();
      for (ie = 0; ie < ne.length; ie++) {
        var pe, ke = ce.andln(oe - 1);
        ce.isOdd() ? (pe = ke > (oe >> 1) - 1 ? (oe >> 1) - ke : ke, ce.isubn(pe)) : pe = 0, ne[ie] = pe, ce.iushrn(1);
      }
      return ne;
    }, B.getJSF = function(V, J) {
      var re = [[], []];
      V = V.clone(), J = J.clone();
      for (var ie, ne = 0, oe = 0; V.cmpn(-ne) > 0 || J.cmpn(-oe) > 0; ) {
        var ce, pe, ke = V.andln(3) + ne & 3, ot = J.andln(3) + oe & 3;
        ke === 3 && (ke = -1), ot === 3 && (ot = -1), ce = 1 & ke ? (ie = V.andln(7) + ne & 7) != 3 && ie !== 5 || ot !== 2 ? ke : -ke : 0, re[0].push(ce), pe = 1 & ot ? (ie = J.andln(7) + oe & 7) != 3 && ie !== 5 || ke !== 2 ? ot : -ot : 0, re[1].push(pe), 2 * ne === ce + 1 && (ne = 1 - ne), 2 * oe === pe + 1 && (oe = 1 - oe), V.iushrn(1), J.iushrn(1);
      }
      return re;
    }, B.cachedProperty = function(V, J, re) {
      var ie = "_" + J;
      V.prototype[J] = function() {
        return this[ie] !== void 0 ? this[ie] : this[ie] = re.call(this);
      };
    }, B.parseBytes = function(V) {
      return typeof V == "string" ? B.toArray(V, "hex") : V;
    }, B.intFromLE = function(V) {
      return new L(V, "hex", "le");
    };
  }()), utils$2;
}
var curve = {}, base$1, hasRequiredBase$1, short, hasRequiredShort, mont, hasRequiredMont, edwards, hasRequiredEdwards, hasRequiredCurve;
function requireBase$1() {
  if (hasRequiredBase$1) return base$1;
  hasRequiredBase$1 = 1;
  var B = requireBn$1(), L = requireUtils$1(), K = L.getNAF, W = L.getJSF, V = L.assert;
  function J(ie, ne) {
    this.type = ie, this.p = new B(ne.p, 16), this.red = ne.prime ? B.red(ne.prime) : B.mont(this.p), this.zero = new B(0).toRed(this.red), this.one = new B(1).toRed(this.red), this.two = new B(2).toRed(this.red), this.n = ne.n && new B(ne.n, 16), this.g = ne.g && this.pointFromJSON(ne.g, ne.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var oe = this.n && this.p.div(this.n);
    !oe || oe.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  function re(ie, ne) {
    this.curve = ie, this.type = ne, this.precomputed = null;
  }
  return base$1 = J, J.prototype.point = function() {
    throw new Error("Not implemented");
  }, J.prototype.validate = function() {
    throw new Error("Not implemented");
  }, J.prototype._fixedNafMul = function(ie, ne) {
    V(ie.precomputed);
    var oe = ie._getDoubles(), ce = K(ne, 1, this._bitLength), pe = (1 << oe.step + 1) - (oe.step % 2 == 0 ? 2 : 1);
    pe /= 3;
    var ke, ot, at = [];
    for (ke = 0; ke < ce.length; ke += oe.step) {
      ot = 0;
      for (var ft = ke + oe.step - 1; ft >= ke; ft--) ot = (ot << 1) + ce[ft];
      at.push(ot);
    }
    for (var dt = this.jpoint(null, null, null), lt = this.jpoint(null, null, null), yt = pe; yt > 0; yt--) {
      for (ke = 0; ke < at.length; ke++) (ot = at[ke]) === yt ? lt = lt.mixedAdd(oe.points[ke]) : ot === -yt && (lt = lt.mixedAdd(oe.points[ke].neg()));
      dt = dt.add(lt);
    }
    return dt.toP();
  }, J.prototype._wnafMul = function(ie, ne) {
    var oe = 4, ce = ie._getNAFPoints(oe);
    oe = ce.wnd;
    for (var pe = ce.points, ke = K(ne, oe, this._bitLength), ot = this.jpoint(null, null, null), at = ke.length - 1; at >= 0; at--) {
      for (var ft = 0; at >= 0 && ke[at] === 0; at--) ft++;
      if (at >= 0 && ft++, ot = ot.dblp(ft), at < 0) break;
      var dt = ke[at];
      V(dt !== 0), ot = ie.type === "affine" ? dt > 0 ? ot.mixedAdd(pe[dt - 1 >> 1]) : ot.mixedAdd(pe[-dt - 1 >> 1].neg()) : dt > 0 ? ot.add(pe[dt - 1 >> 1]) : ot.add(pe[-dt - 1 >> 1].neg());
    }
    return ie.type === "affine" ? ot.toP() : ot;
  }, J.prototype._wnafMulAdd = function(ie, ne, oe, ce, pe) {
    var ke, ot, at, ft = this._wnafT1, dt = this._wnafT2, lt = this._wnafT3, yt = 0;
    for (ke = 0; ke < ce; ke++) {
      var St = (at = ne[ke])._getNAFPoints(ie);
      ft[ke] = St.wnd, dt[ke] = St.points;
    }
    for (ke = ce - 1; ke >= 1; ke -= 2) {
      var mt = ke - 1, $t = ke;
      if (ft[mt] === 1 && ft[$t] === 1) {
        var It = [ne[mt], null, null, ne[$t]];
        ne[mt].y.cmp(ne[$t].y) === 0 ? (It[1] = ne[mt].add(ne[$t]), It[2] = ne[mt].toJ().mixedAdd(ne[$t].neg())) : ne[mt].y.cmp(ne[$t].y.redNeg()) === 0 ? (It[1] = ne[mt].toJ().mixedAdd(ne[$t]), It[2] = ne[mt].add(ne[$t].neg())) : (It[1] = ne[mt].toJ().mixedAdd(ne[$t]), It[2] = ne[mt].toJ().mixedAdd(ne[$t].neg()));
        var Ut = [-3, -1, -5, -7, 0, 7, 5, 1, 3], ut = W(oe[mt], oe[$t]);
        for (yt = Math.max(ut[0].length, yt), lt[mt] = new Array(yt), lt[$t] = new Array(yt), ot = 0; ot < yt; ot++) {
          var ht = 0 | ut[0][ot], Ce = 0 | ut[1][ot];
          lt[mt][ot] = Ut[3 * (ht + 1) + (Ce + 1)], lt[$t][ot] = 0, dt[mt] = It;
        }
      } else lt[mt] = K(oe[mt], ft[mt], this._bitLength), lt[$t] = K(oe[$t], ft[$t], this._bitLength), yt = Math.max(lt[mt].length, yt), yt = Math.max(lt[$t].length, yt);
    }
    var nt = this.jpoint(null, null, null), rt = this._wnafT4;
    for (ke = yt; ke >= 0; ke--) {
      for (var it = 0; ke >= 0; ) {
        var st = !0;
        for (ot = 0; ot < ce; ot++) rt[ot] = 0 | lt[ot][ke], rt[ot] !== 0 && (st = !1);
        if (!st) break;
        it++, ke--;
      }
      if (ke >= 0 && it++, nt = nt.dblp(it), ke < 0) break;
      for (ot = 0; ot < ce; ot++) {
        var Oe = rt[ot];
        Oe !== 0 && (Oe > 0 ? at = dt[ot][Oe - 1 >> 1] : Oe < 0 && (at = dt[ot][-Oe - 1 >> 1].neg()), nt = at.type === "affine" ? nt.mixedAdd(at) : nt.add(at));
      }
    }
    for (ke = 0; ke < ce; ke++) dt[ke] = null;
    return pe ? nt : nt.toP();
  }, J.BasePoint = re, re.prototype.eq = function() {
    throw new Error("Not implemented");
  }, re.prototype.validate = function() {
    return this.curve.validate(this);
  }, J.prototype.decodePoint = function(ie, ne) {
    ie = L.toArray(ie, ne);
    var oe = this.p.byteLength();
    if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 == 2 * oe) return ie[0] === 6 ? V(ie[ie.length - 1] % 2 == 0) : ie[0] === 7 && V(ie[ie.length - 1] % 2 == 1), this.point(ie.slice(1, 1 + oe), ie.slice(1 + oe, 1 + 2 * oe));
    if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === oe) return this.pointFromX(ie.slice(1, 1 + oe), ie[0] === 3);
    throw new Error("Unknown point format");
  }, re.prototype.encodeCompressed = function(ie) {
    return this.encode(ie, !0);
  }, re.prototype._encode = function(ie) {
    var ne = this.curve.p.byteLength(), oe = this.getX().toArray("be", ne);
    return ie ? [this.getY().isEven() ? 2 : 3].concat(oe) : [4].concat(oe, this.getY().toArray("be", ne));
  }, re.prototype.encode = function(ie, ne) {
    return L.encode(this._encode(ne), ie);
  }, re.prototype.precompute = function(ie) {
    if (this.precomputed) return this;
    var ne = { doubles: null, naf: null, beta: null };
    return ne.naf = this._getNAFPoints(8), ne.doubles = this._getDoubles(4, ie), ne.beta = this._getBeta(), this.precomputed = ne, this;
  }, re.prototype._hasDoubles = function(ie) {
    if (!this.precomputed) return !1;
    var ne = this.precomputed.doubles;
    return !!ne && ne.points.length >= Math.ceil((ie.bitLength() + 1) / ne.step);
  }, re.prototype._getDoubles = function(ie, ne) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var oe = [this], ce = this, pe = 0; pe < ne; pe += ie) {
      for (var ke = 0; ke < ie; ke++) ce = ce.dbl();
      oe.push(ce);
    }
    return { step: ie, points: oe };
  }, re.prototype._getNAFPoints = function(ie) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var ne = [this], oe = (1 << ie) - 1, ce = oe === 1 ? null : this.dbl(), pe = 1; pe < oe; pe++) ne[pe] = ne[pe - 1].add(ce);
    return { wnd: ie, points: ne };
  }, re.prototype._getBeta = function() {
    return null;
  }, re.prototype.dblp = function(ie) {
    for (var ne = this, oe = 0; oe < ie; oe++) ne = ne.dbl();
    return ne;
  }, base$1;
}
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var B = requireUtils$1(), L = requireBn$1(), K = requireInherits_browser(), W = requireBase$1(), V = B.assert;
  function J(ne) {
    W.call(this, "short", ne), this.a = new L(ne.a, 16).toRed(this.red), this.b = new L(ne.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ne), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  function re(ne, oe, ce, pe) {
    W.BasePoint.call(this, ne, "affine"), oe === null && ce === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new L(oe, 16), this.y = new L(ce, 16), pe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  function ie(ne, oe, ce, pe) {
    W.BasePoint.call(this, ne, "jacobian"), oe === null && ce === null && pe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new L(0)) : (this.x = new L(oe, 16), this.y = new L(ce, 16), this.z = new L(pe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return K(J, W), short = J, J.prototype._getEndomorphism = function(ne) {
    if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
      var oe, ce;
      if (ne.beta) oe = new L(ne.beta, 16).toRed(this.red);
      else {
        var pe = this._getEndoRoots(this.p);
        oe = (oe = pe[0].cmp(pe[1]) < 0 ? pe[0] : pe[1]).toRed(this.red);
      }
      if (ne.lambda) ce = new L(ne.lambda, 16);
      else {
        var ke = this._getEndoRoots(this.n);
        this.g.mul(ke[0]).x.cmp(this.g.x.redMul(oe)) === 0 ? ce = ke[0] : (ce = ke[1], V(this.g.mul(ce).x.cmp(this.g.x.redMul(oe)) === 0));
      }
      return { beta: oe, lambda: ce, basis: ne.basis ? ne.basis.map(function(ot) {
        return { a: new L(ot.a, 16), b: new L(ot.b, 16) };
      }) : this._getEndoBasis(ce) };
    }
  }, J.prototype._getEndoRoots = function(ne) {
    var oe = ne === this.p ? this.red : L.mont(ne), ce = new L(2).toRed(oe).redInvm(), pe = ce.redNeg(), ke = new L(3).toRed(oe).redNeg().redSqrt().redMul(ce);
    return [pe.redAdd(ke).fromRed(), pe.redSub(ke).fromRed()];
  }, J.prototype._getEndoBasis = function(ne) {
    for (var oe, ce, pe, ke, ot, at, ft, dt, lt, yt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), St = ne, mt = this.n.clone(), $t = new L(1), It = new L(0), Ut = new L(0), ut = new L(1), ht = 0; St.cmpn(0) !== 0; ) {
      var Ce = mt.div(St);
      dt = mt.sub(Ce.mul(St)), lt = Ut.sub(Ce.mul($t));
      var nt = ut.sub(Ce.mul(It));
      if (!pe && dt.cmp(yt) < 0) oe = ft.neg(), ce = $t, pe = dt.neg(), ke = lt;
      else if (pe && ++ht == 2) break;
      ft = dt, mt = St, St = dt, Ut = $t, $t = lt, ut = It, It = nt;
    }
    ot = dt.neg(), at = lt;
    var rt = pe.sqr().add(ke.sqr());
    return ot.sqr().add(at.sqr()).cmp(rt) >= 0 && (ot = oe, at = ce), pe.negative && (pe = pe.neg(), ke = ke.neg()), ot.negative && (ot = ot.neg(), at = at.neg()), [{ a: pe, b: ke }, { a: ot, b: at }];
  }, J.prototype._endoSplit = function(ne) {
    var oe = this.endo.basis, ce = oe[0], pe = oe[1], ke = pe.b.mul(ne).divRound(this.n), ot = ce.b.neg().mul(ne).divRound(this.n), at = ke.mul(ce.a), ft = ot.mul(pe.a), dt = ke.mul(ce.b), lt = ot.mul(pe.b);
    return { k1: ne.sub(at).sub(ft), k2: dt.add(lt).neg() };
  }, J.prototype.pointFromX = function(ne, oe) {
    (ne = new L(ne, 16)).red || (ne = ne.toRed(this.red));
    var ce = ne.redSqr().redMul(ne).redIAdd(ne.redMul(this.a)).redIAdd(this.b), pe = ce.redSqrt();
    if (pe.redSqr().redSub(ce).cmp(this.zero) !== 0) throw new Error("invalid point");
    var ke = pe.fromRed().isOdd();
    return (oe && !ke || !oe && ke) && (pe = pe.redNeg()), this.point(ne, pe);
  }, J.prototype.validate = function(ne) {
    if (ne.inf) return !0;
    var oe = ne.x, ce = ne.y, pe = this.a.redMul(oe), ke = oe.redSqr().redMul(oe).redIAdd(pe).redIAdd(this.b);
    return ce.redSqr().redISub(ke).cmpn(0) === 0;
  }, J.prototype._endoWnafMulAdd = function(ne, oe, ce) {
    for (var pe = this._endoWnafT1, ke = this._endoWnafT2, ot = 0; ot < ne.length; ot++) {
      var at = this._endoSplit(oe[ot]), ft = ne[ot], dt = ft._getBeta();
      at.k1.negative && (at.k1.ineg(), ft = ft.neg(!0)), at.k2.negative && (at.k2.ineg(), dt = dt.neg(!0)), pe[2 * ot] = ft, pe[2 * ot + 1] = dt, ke[2 * ot] = at.k1, ke[2 * ot + 1] = at.k2;
    }
    for (var lt = this._wnafMulAdd(1, pe, ke, 2 * ot, ce), yt = 0; yt < 2 * ot; yt++) pe[yt] = null, ke[yt] = null;
    return lt;
  }, K(re, W.BasePoint), J.prototype.point = function(ne, oe, ce) {
    return new re(this, ne, oe, ce);
  }, J.prototype.pointFromJSON = function(ne, oe) {
    return re.fromJSON(this, ne, oe);
  }, re.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ne = this.precomputed;
      if (ne && ne.beta) return ne.beta;
      var oe = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ne) {
        var ce = this.curve, pe = function(ke) {
          return ce.point(ke.x.redMul(ce.endo.beta), ke.y);
        };
        ne.beta = oe, oe.precomputed = { beta: null, naf: ne.naf && { wnd: ne.naf.wnd, points: ne.naf.points.map(pe) }, doubles: ne.doubles && { step: ne.doubles.step, points: ne.doubles.points.map(pe) } };
      }
      return oe;
    }
  }, re.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  }, re.fromJSON = function(ne, oe, ce) {
    typeof oe == "string" && (oe = JSON.parse(oe));
    var pe = ne.point(oe[0], oe[1], ce);
    if (!oe[2]) return pe;
    function ke(at) {
      return ne.point(at[0], at[1], ce);
    }
    var ot = oe[2];
    return pe.precomputed = { beta: null, doubles: ot.doubles && { step: ot.doubles.step, points: [pe].concat(ot.doubles.points.map(ke)) }, naf: ot.naf && { wnd: ot.naf.wnd, points: [pe].concat(ot.naf.points.map(ke)) } }, pe;
  }, re.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, re.prototype.isInfinity = function() {
    return this.inf;
  }, re.prototype.add = function(ne) {
    if (this.inf) return ne;
    if (ne.inf) return this;
    if (this.eq(ne)) return this.dbl();
    if (this.neg().eq(ne)) return this.curve.point(null, null);
    if (this.x.cmp(ne.x) === 0) return this.curve.point(null, null);
    var oe = this.y.redSub(ne.y);
    oe.cmpn(0) !== 0 && (oe = oe.redMul(this.x.redSub(ne.x).redInvm()));
    var ce = oe.redSqr().redISub(this.x).redISub(ne.x), pe = oe.redMul(this.x.redSub(ce)).redISub(this.y);
    return this.curve.point(ce, pe);
  }, re.prototype.dbl = function() {
    if (this.inf) return this;
    var ne = this.y.redAdd(this.y);
    if (ne.cmpn(0) === 0) return this.curve.point(null, null);
    var oe = this.curve.a, ce = this.x.redSqr(), pe = ne.redInvm(), ke = ce.redAdd(ce).redIAdd(ce).redIAdd(oe).redMul(pe), ot = ke.redSqr().redISub(this.x.redAdd(this.x)), at = ke.redMul(this.x.redSub(ot)).redISub(this.y);
    return this.curve.point(ot, at);
  }, re.prototype.getX = function() {
    return this.x.fromRed();
  }, re.prototype.getY = function() {
    return this.y.fromRed();
  }, re.prototype.mul = function(ne) {
    return ne = new L(ne, 16), this.isInfinity() ? this : this._hasDoubles(ne) ? this.curve._fixedNafMul(this, ne) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ne]) : this.curve._wnafMul(this, ne);
  }, re.prototype.mulAdd = function(ne, oe, ce) {
    var pe = [this, oe], ke = [ne, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(pe, ke) : this.curve._wnafMulAdd(1, pe, ke, 2);
  }, re.prototype.jmulAdd = function(ne, oe, ce) {
    var pe = [this, oe], ke = [ne, ce];
    return this.curve.endo ? this.curve._endoWnafMulAdd(pe, ke, !0) : this.curve._wnafMulAdd(1, pe, ke, 2, !0);
  }, re.prototype.eq = function(ne) {
    return this === ne || this.inf === ne.inf && (this.inf || this.x.cmp(ne.x) === 0 && this.y.cmp(ne.y) === 0);
  }, re.prototype.neg = function(ne) {
    if (this.inf) return this;
    var oe = this.curve.point(this.x, this.y.redNeg());
    if (ne && this.precomputed) {
      var ce = this.precomputed, pe = function(ke) {
        return ke.neg();
      };
      oe.precomputed = { naf: ce.naf && { wnd: ce.naf.wnd, points: ce.naf.points.map(pe) }, doubles: ce.doubles && { step: ce.doubles.step, points: ce.doubles.points.map(pe) } };
    }
    return oe;
  }, re.prototype.toJ = function() {
    return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
  }, K(ie, W.BasePoint), J.prototype.jpoint = function(ne, oe, ce) {
    return new ie(this, ne, oe, ce);
  }, ie.prototype.toP = function() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var ne = this.z.redInvm(), oe = ne.redSqr(), ce = this.x.redMul(oe), pe = this.y.redMul(oe).redMul(ne);
    return this.curve.point(ce, pe);
  }, ie.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ie.prototype.add = function(ne) {
    if (this.isInfinity()) return ne;
    if (ne.isInfinity()) return this;
    var oe = ne.z.redSqr(), ce = this.z.redSqr(), pe = this.x.redMul(oe), ke = ne.x.redMul(ce), ot = this.y.redMul(oe.redMul(ne.z)), at = ne.y.redMul(ce.redMul(this.z)), ft = pe.redSub(ke), dt = ot.redSub(at);
    if (ft.cmpn(0) === 0) return dt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var lt = ft.redSqr(), yt = lt.redMul(ft), St = pe.redMul(lt), mt = dt.redSqr().redIAdd(yt).redISub(St).redISub(St), $t = dt.redMul(St.redISub(mt)).redISub(ot.redMul(yt)), It = this.z.redMul(ne.z).redMul(ft);
    return this.curve.jpoint(mt, $t, It);
  }, ie.prototype.mixedAdd = function(ne) {
    if (this.isInfinity()) return ne.toJ();
    if (ne.isInfinity()) return this;
    var oe = this.z.redSqr(), ce = this.x, pe = ne.x.redMul(oe), ke = this.y, ot = ne.y.redMul(oe).redMul(this.z), at = ce.redSub(pe), ft = ke.redSub(ot);
    if (at.cmpn(0) === 0) return ft.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var dt = at.redSqr(), lt = dt.redMul(at), yt = ce.redMul(dt), St = ft.redSqr().redIAdd(lt).redISub(yt).redISub(yt), mt = ft.redMul(yt.redISub(St)).redISub(ke.redMul(lt)), $t = this.z.redMul(at);
    return this.curve.jpoint(St, mt, $t);
  }, ie.prototype.dblp = function(ne) {
    if (ne === 0) return this;
    if (this.isInfinity()) return this;
    if (!ne) return this.dbl();
    var oe;
    if (this.curve.zeroA || this.curve.threeA) {
      var ce = this;
      for (oe = 0; oe < ne; oe++) ce = ce.dbl();
      return ce;
    }
    var pe = this.curve.a, ke = this.curve.tinv, ot = this.x, at = this.y, ft = this.z, dt = ft.redSqr().redSqr(), lt = at.redAdd(at);
    for (oe = 0; oe < ne; oe++) {
      var yt = ot.redSqr(), St = lt.redSqr(), mt = St.redSqr(), $t = yt.redAdd(yt).redIAdd(yt).redIAdd(pe.redMul(dt)), It = ot.redMul(St), Ut = $t.redSqr().redISub(It.redAdd(It)), ut = It.redISub(Ut), ht = $t.redMul(ut);
      ht = ht.redIAdd(ht).redISub(mt);
      var Ce = lt.redMul(ft);
      oe + 1 < ne && (dt = dt.redMul(mt)), ot = Ut, ft = Ce, lt = ht;
    }
    return this.curve.jpoint(ot, lt.redMul(ke), ft);
  }, ie.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ie.prototype._zeroDbl = function() {
    var ne, oe, ce;
    if (this.zOne) {
      var pe = this.x.redSqr(), ke = this.y.redSqr(), ot = ke.redSqr(), at = this.x.redAdd(ke).redSqr().redISub(pe).redISub(ot);
      at = at.redIAdd(at);
      var ft = pe.redAdd(pe).redIAdd(pe), dt = ft.redSqr().redISub(at).redISub(at), lt = ot.redIAdd(ot);
      lt = (lt = lt.redIAdd(lt)).redIAdd(lt), ne = dt, oe = ft.redMul(at.redISub(dt)).redISub(lt), ce = this.y.redAdd(this.y);
    } else {
      var yt = this.x.redSqr(), St = this.y.redSqr(), mt = St.redSqr(), $t = this.x.redAdd(St).redSqr().redISub(yt).redISub(mt);
      $t = $t.redIAdd($t);
      var It = yt.redAdd(yt).redIAdd(yt), Ut = It.redSqr(), ut = mt.redIAdd(mt);
      ut = (ut = ut.redIAdd(ut)).redIAdd(ut), ne = Ut.redISub($t).redISub($t), oe = It.redMul($t.redISub(ne)).redISub(ut), ce = (ce = this.y.redMul(this.z)).redIAdd(ce);
    }
    return this.curve.jpoint(ne, oe, ce);
  }, ie.prototype._threeDbl = function() {
    var ne, oe, ce;
    if (this.zOne) {
      var pe = this.x.redSqr(), ke = this.y.redSqr(), ot = ke.redSqr(), at = this.x.redAdd(ke).redSqr().redISub(pe).redISub(ot);
      at = at.redIAdd(at);
      var ft = pe.redAdd(pe).redIAdd(pe).redIAdd(this.curve.a), dt = ft.redSqr().redISub(at).redISub(at);
      ne = dt;
      var lt = ot.redIAdd(ot);
      lt = (lt = lt.redIAdd(lt)).redIAdd(lt), oe = ft.redMul(at.redISub(dt)).redISub(lt), ce = this.y.redAdd(this.y);
    } else {
      var yt = this.z.redSqr(), St = this.y.redSqr(), mt = this.x.redMul(St), $t = this.x.redSub(yt).redMul(this.x.redAdd(yt));
      $t = $t.redAdd($t).redIAdd($t);
      var It = mt.redIAdd(mt), Ut = (It = It.redIAdd(It)).redAdd(It);
      ne = $t.redSqr().redISub(Ut), ce = this.y.redAdd(this.z).redSqr().redISub(St).redISub(yt);
      var ut = St.redSqr();
      ut = (ut = (ut = ut.redIAdd(ut)).redIAdd(ut)).redIAdd(ut), oe = $t.redMul(It.redISub(ne)).redISub(ut);
    }
    return this.curve.jpoint(ne, oe, ce);
  }, ie.prototype._dbl = function() {
    var ne = this.curve.a, oe = this.x, ce = this.y, pe = this.z, ke = pe.redSqr().redSqr(), ot = oe.redSqr(), at = ce.redSqr(), ft = ot.redAdd(ot).redIAdd(ot).redIAdd(ne.redMul(ke)), dt = oe.redAdd(oe), lt = (dt = dt.redIAdd(dt)).redMul(at), yt = ft.redSqr().redISub(lt.redAdd(lt)), St = lt.redISub(yt), mt = at.redSqr();
    mt = (mt = (mt = mt.redIAdd(mt)).redIAdd(mt)).redIAdd(mt);
    var $t = ft.redMul(St).redISub(mt), It = ce.redAdd(ce).redMul(pe);
    return this.curve.jpoint(yt, $t, It);
  }, ie.prototype.trpl = function() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var ne = this.x.redSqr(), oe = this.y.redSqr(), ce = this.z.redSqr(), pe = oe.redSqr(), ke = ne.redAdd(ne).redIAdd(ne), ot = ke.redSqr(), at = this.x.redAdd(oe).redSqr().redISub(ne).redISub(pe), ft = (at = (at = (at = at.redIAdd(at)).redAdd(at).redIAdd(at)).redISub(ot)).redSqr(), dt = pe.redIAdd(pe);
    dt = (dt = (dt = dt.redIAdd(dt)).redIAdd(dt)).redIAdd(dt);
    var lt = ke.redIAdd(at).redSqr().redISub(ot).redISub(ft).redISub(dt), yt = oe.redMul(lt);
    yt = (yt = yt.redIAdd(yt)).redIAdd(yt);
    var St = this.x.redMul(ft).redISub(yt);
    St = (St = St.redIAdd(St)).redIAdd(St);
    var mt = this.y.redMul(lt.redMul(dt.redISub(lt)).redISub(at.redMul(ft)));
    mt = (mt = (mt = mt.redIAdd(mt)).redIAdd(mt)).redIAdd(mt);
    var $t = this.z.redAdd(at).redSqr().redISub(ce).redISub(ft);
    return this.curve.jpoint(St, mt, $t);
  }, ie.prototype.mul = function(ne, oe) {
    return ne = new L(ne, oe), this.curve._wnafMul(this, ne);
  }, ie.prototype.eq = function(ne) {
    if (ne.type === "affine") return this.eq(ne.toJ());
    if (this === ne) return !0;
    var oe = this.z.redSqr(), ce = ne.z.redSqr();
    if (this.x.redMul(ce).redISub(ne.x.redMul(oe)).cmpn(0) !== 0) return !1;
    var pe = oe.redMul(this.z), ke = ce.redMul(ne.z);
    return this.y.redMul(ke).redISub(ne.y.redMul(pe)).cmpn(0) === 0;
  }, ie.prototype.eqXToP = function(ne) {
    var oe = this.z.redSqr(), ce = ne.toRed(this.curve.red).redMul(oe);
    if (this.x.cmp(ce) === 0) return !0;
    for (var pe = ne.clone(), ke = this.curve.redN.redMul(oe); ; ) {
      if (pe.iadd(this.curve.n), pe.cmp(this.curve.p) >= 0) return !1;
      if (ce.redIAdd(ke), this.x.cmp(ce) === 0) return !0;
    }
  }, ie.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ie.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), W = requireUtils$1();
  function V(re) {
    K.call(this, "mont", re), this.a = new B(re.a, 16).toRed(this.red), this.b = new B(re.b, 16).toRed(this.red), this.i4 = new B(4).toRed(this.red).redInvm(), this.two = new B(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  function J(re, ie, ne) {
    K.BasePoint.call(this, re, "projective"), ie === null && ne === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new B(ie, 16), this.z = new B(ne, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return L(V, K), mont = V, V.prototype.validate = function(re) {
    var ie = re.normalize().x, ne = ie.redSqr(), oe = ne.redMul(ie).redAdd(ne.redMul(this.a)).redAdd(ie);
    return oe.redSqrt().redSqr().cmp(oe) === 0;
  }, L(J, K.BasePoint), V.prototype.decodePoint = function(re, ie) {
    return this.point(W.toArray(re, ie), 1);
  }, V.prototype.point = function(re, ie) {
    return new J(this, re, ie);
  }, V.prototype.pointFromJSON = function(re) {
    return J.fromJSON(this, re);
  }, J.prototype.precompute = function() {
  }, J.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, J.fromJSON = function(re, ie) {
    return new J(re, ie[0], ie[1] || re.one);
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, J.prototype.dbl = function() {
    var re = this.x.redAdd(this.z).redSqr(), ie = this.x.redSub(this.z).redSqr(), ne = re.redSub(ie), oe = re.redMul(ie), ce = ne.redMul(ie.redAdd(this.curve.a24.redMul(ne)));
    return this.curve.point(oe, ce);
  }, J.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, J.prototype.diffAdd = function(re, ie) {
    var ne = this.x.redAdd(this.z), oe = this.x.redSub(this.z), ce = re.x.redAdd(re.z), pe = re.x.redSub(re.z).redMul(ne), ke = ce.redMul(oe), ot = ie.z.redMul(pe.redAdd(ke).redSqr()), at = ie.x.redMul(pe.redISub(ke).redSqr());
    return this.curve.point(ot, at);
  }, J.prototype.mul = function(re) {
    for (var ie = re.clone(), ne = this, oe = this.curve.point(null, null), ce = []; ie.cmpn(0) !== 0; ie.iushrn(1)) ce.push(ie.andln(1));
    for (var pe = ce.length - 1; pe >= 0; pe--) ce[pe] === 0 ? (ne = ne.diffAdd(oe, this), oe = oe.dbl()) : (oe = ne.diffAdd(oe, this), ne = ne.dbl());
    return oe;
  }, J.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, J.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, J.prototype.eq = function(re) {
    return this.getX().cmp(re.getX()) === 0;
  }, J.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, J.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var B = requireUtils$1(), L = requireBn$1(), K = requireInherits_browser(), W = requireBase$1(), V = B.assert;
  function J(ie) {
    this.twisted = (0 | ie.a) != 1, this.mOneA = this.twisted && (0 | ie.a) == -1, this.extended = this.mOneA, W.call(this, "edwards", ie), this.a = new L(ie.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new L(ie.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new L(ie.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), V(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | ie.c) == 1;
  }
  function re(ie, ne, oe, ce, pe) {
    W.BasePoint.call(this, ie, "projective"), ne === null && oe === null && ce === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new L(ne, 16), this.y = new L(oe, 16), this.z = ce ? new L(ce, 16) : this.curve.one, this.t = pe && new L(pe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return K(J, W), edwards = J, J.prototype._mulA = function(ie) {
    return this.mOneA ? ie.redNeg() : this.a.redMul(ie);
  }, J.prototype._mulC = function(ie) {
    return this.oneC ? ie : this.c.redMul(ie);
  }, J.prototype.jpoint = function(ie, ne, oe, ce) {
    return this.point(ie, ne, oe, ce);
  }, J.prototype.pointFromX = function(ie, ne) {
    (ie = new L(ie, 16)).red || (ie = ie.toRed(this.red));
    var oe = ie.redSqr(), ce = this.c2.redSub(this.a.redMul(oe)), pe = this.one.redSub(this.c2.redMul(this.d).redMul(oe)), ke = ce.redMul(pe.redInvm()), ot = ke.redSqrt();
    if (ot.redSqr().redSub(ke).cmp(this.zero) !== 0) throw new Error("invalid point");
    var at = ot.fromRed().isOdd();
    return (ne && !at || !ne && at) && (ot = ot.redNeg()), this.point(ie, ot);
  }, J.prototype.pointFromY = function(ie, ne) {
    (ie = new L(ie, 16)).red || (ie = ie.toRed(this.red));
    var oe = ie.redSqr(), ce = oe.redSub(this.c2), pe = oe.redMul(this.d).redMul(this.c2).redSub(this.a), ke = ce.redMul(pe.redInvm());
    if (ke.cmp(this.zero) === 0) {
      if (ne) throw new Error("invalid point");
      return this.point(this.zero, ie);
    }
    var ot = ke.redSqrt();
    if (ot.redSqr().redSub(ke).cmp(this.zero) !== 0) throw new Error("invalid point");
    return ot.fromRed().isOdd() !== ne && (ot = ot.redNeg()), this.point(ot, ie);
  }, J.prototype.validate = function(ie) {
    if (ie.isInfinity()) return !0;
    ie.normalize();
    var ne = ie.x.redSqr(), oe = ie.y.redSqr(), ce = ne.redMul(this.a).redAdd(oe), pe = this.c2.redMul(this.one.redAdd(this.d.redMul(ne).redMul(oe)));
    return ce.cmp(pe) === 0;
  }, K(re, W.BasePoint), J.prototype.pointFromJSON = function(ie) {
    return re.fromJSON(this, ie);
  }, J.prototype.point = function(ie, ne, oe, ce) {
    return new re(this, ie, ne, oe, ce);
  }, re.fromJSON = function(ie, ne) {
    return new re(ie, ne[0], ne[1], ne[2]);
  }, re.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, re.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, re.prototype._extDbl = function() {
    var ie = this.x.redSqr(), ne = this.y.redSqr(), oe = this.z.redSqr();
    oe = oe.redIAdd(oe);
    var ce = this.curve._mulA(ie), pe = this.x.redAdd(this.y).redSqr().redISub(ie).redISub(ne), ke = ce.redAdd(ne), ot = ke.redSub(oe), at = ce.redSub(ne), ft = pe.redMul(ot), dt = ke.redMul(at), lt = pe.redMul(at), yt = ot.redMul(ke);
    return this.curve.point(ft, dt, yt, lt);
  }, re.prototype._projDbl = function() {
    var ie, ne, oe, ce, pe, ke, ot = this.x.redAdd(this.y).redSqr(), at = this.x.redSqr(), ft = this.y.redSqr();
    if (this.curve.twisted) {
      var dt = (ce = this.curve._mulA(at)).redAdd(ft);
      this.zOne ? (ie = ot.redSub(at).redSub(ft).redMul(dt.redSub(this.curve.two)), ne = dt.redMul(ce.redSub(ft)), oe = dt.redSqr().redSub(dt).redSub(dt)) : (pe = this.z.redSqr(), ke = dt.redSub(pe).redISub(pe), ie = ot.redSub(at).redISub(ft).redMul(ke), ne = dt.redMul(ce.redSub(ft)), oe = dt.redMul(ke));
    } else ce = at.redAdd(ft), pe = this.curve._mulC(this.z).redSqr(), ke = ce.redSub(pe).redSub(pe), ie = this.curve._mulC(ot.redISub(ce)).redMul(ke), ne = this.curve._mulC(ce).redMul(at.redISub(ft)), oe = ce.redMul(ke);
    return this.curve.point(ie, ne, oe);
  }, re.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, re.prototype._extAdd = function(ie) {
    var ne = this.y.redSub(this.x).redMul(ie.y.redSub(ie.x)), oe = this.y.redAdd(this.x).redMul(ie.y.redAdd(ie.x)), ce = this.t.redMul(this.curve.dd).redMul(ie.t), pe = this.z.redMul(ie.z.redAdd(ie.z)), ke = oe.redSub(ne), ot = pe.redSub(ce), at = pe.redAdd(ce), ft = oe.redAdd(ne), dt = ke.redMul(ot), lt = at.redMul(ft), yt = ke.redMul(ft), St = ot.redMul(at);
    return this.curve.point(dt, lt, St, yt);
  }, re.prototype._projAdd = function(ie) {
    var ne, oe, ce = this.z.redMul(ie.z), pe = ce.redSqr(), ke = this.x.redMul(ie.x), ot = this.y.redMul(ie.y), at = this.curve.d.redMul(ke).redMul(ot), ft = pe.redSub(at), dt = pe.redAdd(at), lt = this.x.redAdd(this.y).redMul(ie.x.redAdd(ie.y)).redISub(ke).redISub(ot), yt = ce.redMul(ft).redMul(lt);
    return this.curve.twisted ? (ne = ce.redMul(dt).redMul(ot.redSub(this.curve._mulA(ke))), oe = ft.redMul(dt)) : (ne = ce.redMul(dt).redMul(ot.redSub(ke)), oe = this.curve._mulC(ft).redMul(dt)), this.curve.point(yt, ne, oe);
  }, re.prototype.add = function(ie) {
    return this.isInfinity() ? ie : ie.isInfinity() ? this : this.curve.extended ? this._extAdd(ie) : this._projAdd(ie);
  }, re.prototype.mul = function(ie) {
    return this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve._wnafMul(this, ie);
  }, re.prototype.mulAdd = function(ie, ne, oe) {
    return this.curve._wnafMulAdd(1, [this, ne], [ie, oe], 2, !1);
  }, re.prototype.jmulAdd = function(ie, ne, oe) {
    return this.curve._wnafMulAdd(1, [this, ne], [ie, oe], 2, !0);
  }, re.prototype.normalize = function() {
    if (this.zOne) return this;
    var ie = this.z.redInvm();
    return this.x = this.x.redMul(ie), this.y = this.y.redMul(ie), this.t && (this.t = this.t.redMul(ie)), this.z = this.curve.one, this.zOne = !0, this;
  }, re.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  }, re.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, re.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, re.prototype.eq = function(ie) {
    return this === ie || this.getX().cmp(ie.getX()) === 0 && this.getY().cmp(ie.getY()) === 0;
  }, re.prototype.eqXToP = function(ie) {
    var ne = ie.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ne) === 0) return !0;
    for (var oe = ie.clone(), ce = this.curve.redN.redMul(this.z); ; ) {
      if (oe.iadd(this.curve.n), oe.cmp(this.curve.p) >= 0) return !1;
      if (ne.redIAdd(ce), this.x.cmp(ne) === 0) return !0;
    }
  }, re.prototype.toP = re.prototype.normalize, re.prototype.mixedAdd = re.prototype.add, edwards;
}
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(B) {
    var L = B;
    L.base = requireBase$1(), L.short = requireShort(), L.mont = requireMont(), L.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var B = requireMinimalisticAssert(), L = requireInherits_browser();
  function K(re, ie) {
    return (64512 & re.charCodeAt(ie)) == 55296 && !(ie < 0 || ie + 1 >= re.length) && (64512 & re.charCodeAt(ie + 1)) == 56320;
  }
  function W(re) {
    return (re >>> 24 | re >>> 8 & 65280 | re << 8 & 16711680 | (255 & re) << 24) >>> 0;
  }
  function V(re) {
    return re.length === 1 ? "0" + re : re;
  }
  function J(re) {
    return re.length === 7 ? "0" + re : re.length === 6 ? "00" + re : re.length === 5 ? "000" + re : re.length === 4 ? "0000" + re : re.length === 3 ? "00000" + re : re.length === 2 ? "000000" + re : re.length === 1 ? "0000000" + re : re;
  }
  return utils.inherits = L, utils.toArray = function(re, ie) {
    if (Array.isArray(re)) return re.slice();
    if (!re) return [];
    var ne = [];
    if (typeof re == "string") if (ie) {
      if (ie === "hex") for ((re = re.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (re = "0" + re), ce = 0; ce < re.length; ce += 2) ne.push(parseInt(re[ce] + re[ce + 1], 16));
    } else for (var oe = 0, ce = 0; ce < re.length; ce++) {
      var pe = re.charCodeAt(ce);
      pe < 128 ? ne[oe++] = pe : pe < 2048 ? (ne[oe++] = pe >> 6 | 192, ne[oe++] = 63 & pe | 128) : K(re, ce) ? (pe = 65536 + ((1023 & pe) << 10) + (1023 & re.charCodeAt(++ce)), ne[oe++] = pe >> 18 | 240, ne[oe++] = pe >> 12 & 63 | 128, ne[oe++] = pe >> 6 & 63 | 128, ne[oe++] = 63 & pe | 128) : (ne[oe++] = pe >> 12 | 224, ne[oe++] = pe >> 6 & 63 | 128, ne[oe++] = 63 & pe | 128);
    }
    else for (ce = 0; ce < re.length; ce++) ne[ce] = 0 | re[ce];
    return ne;
  }, utils.toHex = function(re) {
    for (var ie = "", ne = 0; ne < re.length; ne++) ie += V(re[ne].toString(16));
    return ie;
  }, utils.htonl = W, utils.toHex32 = function(re, ie) {
    for (var ne = "", oe = 0; oe < re.length; oe++) {
      var ce = re[oe];
      ie === "little" && (ce = W(ce)), ne += J(ce.toString(16));
    }
    return ne;
  }, utils.zero2 = V, utils.zero8 = J, utils.join32 = function(re, ie, ne, oe) {
    var ce = ne - ie;
    B(ce % 4 == 0);
    for (var pe = new Array(ce / 4), ke = 0, ot = ie; ke < pe.length; ke++, ot += 4) {
      var at;
      at = oe === "big" ? re[ot] << 24 | re[ot + 1] << 16 | re[ot + 2] << 8 | re[ot + 3] : re[ot + 3] << 24 | re[ot + 2] << 16 | re[ot + 1] << 8 | re[ot], pe[ke] = at >>> 0;
    }
    return pe;
  }, utils.split32 = function(re, ie) {
    for (var ne = new Array(4 * re.length), oe = 0, ce = 0; oe < re.length; oe++, ce += 4) {
      var pe = re[oe];
      ie === "big" ? (ne[ce] = pe >>> 24, ne[ce + 1] = pe >>> 16 & 255, ne[ce + 2] = pe >>> 8 & 255, ne[ce + 3] = 255 & pe) : (ne[ce + 3] = pe >>> 24, ne[ce + 2] = pe >>> 16 & 255, ne[ce + 1] = pe >>> 8 & 255, ne[ce] = 255 & pe);
    }
    return ne;
  }, utils.rotr32 = function(re, ie) {
    return re >>> ie | re << 32 - ie;
  }, utils.rotl32 = function(re, ie) {
    return re << ie | re >>> 32 - ie;
  }, utils.sum32 = function(re, ie) {
    return re + ie >>> 0;
  }, utils.sum32_3 = function(re, ie, ne) {
    return re + ie + ne >>> 0;
  }, utils.sum32_4 = function(re, ie, ne, oe) {
    return re + ie + ne + oe >>> 0;
  }, utils.sum32_5 = function(re, ie, ne, oe, ce) {
    return re + ie + ne + oe + ce >>> 0;
  }, utils.sum64 = function(re, ie, ne, oe) {
    var ce = re[ie], pe = oe + re[ie + 1] >>> 0, ke = (pe < oe ? 1 : 0) + ne + ce;
    re[ie] = ke >>> 0, re[ie + 1] = pe;
  }, utils.sum64_hi = function(re, ie, ne, oe) {
    return (ie + oe >>> 0 < ie ? 1 : 0) + re + ne >>> 0;
  }, utils.sum64_lo = function(re, ie, ne, oe) {
    return ie + oe >>> 0;
  }, utils.sum64_4_hi = function(re, ie, ne, oe, ce, pe, ke, ot) {
    var at = 0, ft = ie;
    return at += (ft = ft + oe >>> 0) < ie ? 1 : 0, at += (ft = ft + pe >>> 0) < pe ? 1 : 0, re + ne + ce + ke + (at += (ft = ft + ot >>> 0) < ot ? 1 : 0) >>> 0;
  }, utils.sum64_4_lo = function(re, ie, ne, oe, ce, pe, ke, ot) {
    return ie + oe + pe + ot >>> 0;
  }, utils.sum64_5_hi = function(re, ie, ne, oe, ce, pe, ke, ot, at, ft) {
    var dt = 0, lt = ie;
    return dt += (lt = lt + oe >>> 0) < ie ? 1 : 0, dt += (lt = lt + pe >>> 0) < pe ? 1 : 0, dt += (lt = lt + ot >>> 0) < ot ? 1 : 0, re + ne + ce + ke + at + (dt += (lt = lt + ft >>> 0) < ft ? 1 : 0) >>> 0;
  }, utils.sum64_5_lo = function(re, ie, ne, oe, ce, pe, ke, ot, at, ft) {
    return ie + oe + pe + ot + ft >>> 0;
  }, utils.rotr64_hi = function(re, ie, ne) {
    return (ie << 32 - ne | re >>> ne) >>> 0;
  }, utils.rotr64_lo = function(re, ie, ne) {
    return (re << 32 - ne | ie >>> ne) >>> 0;
  }, utils.shr64_hi = function(re, ie, ne) {
    return re >>> ne;
  }, utils.shr64_lo = function(re, ie, ne) {
    return (re << 32 - ne | ie >>> ne) >>> 0;
  }, utils;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var B = requireUtils(), L = requireMinimalisticAssert();
  function K() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = K, K.prototype.update = function(W, V) {
    if (W = B.toArray(W, V), this.pending ? this.pending = this.pending.concat(W) : this.pending = W, this.pendingTotal += W.length, this.pending.length >= this._delta8) {
      var J = (W = this.pending).length % this._delta8;
      this.pending = W.slice(W.length - J, W.length), this.pending.length === 0 && (this.pending = null), W = B.join32(W, 0, W.length - J, this.endian);
      for (var re = 0; re < W.length; re += this._delta32) this._update(W, re, re + this._delta32);
    }
    return this;
  }, K.prototype.digest = function(W) {
    return this.update(this._pad()), L(this.pending === null), this._digest(W);
  }, K.prototype._pad = function() {
    var W = this.pendingTotal, V = this._delta8, J = V - (W + this.padLength) % V, re = new Array(J + this.padLength);
    re[0] = 128;
    for (var ie = 1; ie < J; ie++) re[ie] = 0;
    if (W <<= 3, this.endian === "big") {
      for (var ne = 8; ne < this.padLength; ne++) re[ie++] = 0;
      re[ie++] = 0, re[ie++] = 0, re[ie++] = 0, re[ie++] = 0, re[ie++] = W >>> 24 & 255, re[ie++] = W >>> 16 & 255, re[ie++] = W >>> 8 & 255, re[ie++] = 255 & W;
    } else for (re[ie++] = 255 & W, re[ie++] = W >>> 8 & 255, re[ie++] = W >>> 16 & 255, re[ie++] = W >>> 24 & 255, re[ie++] = 0, re[ie++] = 0, re[ie++] = 0, re[ie++] = 0, ne = 8; ne < this.padLength; ne++) re[ie++] = 0;
    return re;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon, _1, hasRequired_1, _256, hasRequired_256, _224, hasRequired_224, _512, hasRequired_512, _384, hasRequired_384, hasRequiredSha;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var B = requireUtils().rotr32;
  function L(V, J, re) {
    return V & J ^ ~V & re;
  }
  function K(V, J, re) {
    return V & J ^ V & re ^ J & re;
  }
  function W(V, J, re) {
    return V ^ J ^ re;
  }
  return common.ft_1 = function(V, J, re, ie) {
    return V === 0 ? L(J, re, ie) : V === 1 || V === 3 ? W(J, re, ie) : V === 2 ? K(J, re, ie) : void 0;
  }, common.ch32 = L, common.maj32 = K, common.p32 = W, common.s0_256 = function(V) {
    return B(V, 2) ^ B(V, 13) ^ B(V, 22);
  }, common.s1_256 = function(V) {
    return B(V, 6) ^ B(V, 11) ^ B(V, 25);
  }, common.g0_256 = function(V) {
    return B(V, 7) ^ B(V, 18) ^ V >>> 3;
  }, common.g1_256 = function(V) {
    return B(V, 17) ^ B(V, 19) ^ V >>> 10;
  }, common;
}
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var B = requireUtils(), L = requireCommon$1(), K = requireCommon(), W = B.rotl32, V = B.sum32, J = B.sum32_5, re = K.ft_1, ie = L.BlockHash, ne = [1518500249, 1859775393, 2400959708, 3395469782];
  function oe() {
    if (!(this instanceof oe)) return new oe();
    ie.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  return B.inherits(oe, ie), _1 = oe, oe.blockSize = 512, oe.outSize = 160, oe.hmacStrength = 80, oe.padLength = 64, oe.prototype._update = function(ce, pe) {
    for (var ke = this.W, ot = 0; ot < 16; ot++) ke[ot] = ce[pe + ot];
    for (; ot < ke.length; ot++) ke[ot] = W(ke[ot - 3] ^ ke[ot - 8] ^ ke[ot - 14] ^ ke[ot - 16], 1);
    var at = this.h[0], ft = this.h[1], dt = this.h[2], lt = this.h[3], yt = this.h[4];
    for (ot = 0; ot < ke.length; ot++) {
      var St = ~~(ot / 20), mt = J(W(at, 5), re(St, ft, dt, lt), yt, ke[ot], ne[St]);
      yt = lt, lt = dt, dt = W(ft, 30), ft = at, at = mt;
    }
    this.h[0] = V(this.h[0], at), this.h[1] = V(this.h[1], ft), this.h[2] = V(this.h[2], dt), this.h[3] = V(this.h[3], lt), this.h[4] = V(this.h[4], yt);
  }, oe.prototype._digest = function(ce) {
    return ce === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _1;
}
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var B = requireUtils(), L = requireCommon$1(), K = requireCommon(), W = requireMinimalisticAssert(), V = B.sum32, J = B.sum32_4, re = B.sum32_5, ie = K.ch32, ne = K.maj32, oe = K.s0_256, ce = K.s1_256, pe = K.g0_256, ke = K.g1_256, ot = L.BlockHash, at = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function ft() {
    if (!(this instanceof ft)) return new ft();
    ot.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = at, this.W = new Array(64);
  }
  return B.inherits(ft, ot), _256 = ft, ft.blockSize = 512, ft.outSize = 256, ft.hmacStrength = 192, ft.padLength = 64, ft.prototype._update = function(dt, lt) {
    for (var yt = this.W, St = 0; St < 16; St++) yt[St] = dt[lt + St];
    for (; St < yt.length; St++) yt[St] = J(ke(yt[St - 2]), yt[St - 7], pe(yt[St - 15]), yt[St - 16]);
    var mt = this.h[0], $t = this.h[1], It = this.h[2], Ut = this.h[3], ut = this.h[4], ht = this.h[5], Ce = this.h[6], nt = this.h[7];
    for (W(this.k.length === yt.length), St = 0; St < yt.length; St++) {
      var rt = re(nt, ce(ut), ie(ut, ht, Ce), this.k[St], yt[St]), it = V(oe(mt), ne(mt, $t, It));
      nt = Ce, Ce = ht, ht = ut, ut = V(Ut, rt), Ut = It, It = $t, $t = mt, mt = V(rt, it);
    }
    this.h[0] = V(this.h[0], mt), this.h[1] = V(this.h[1], $t), this.h[2] = V(this.h[2], It), this.h[3] = V(this.h[3], Ut), this.h[4] = V(this.h[4], ut), this.h[5] = V(this.h[5], ht), this.h[6] = V(this.h[6], Ce), this.h[7] = V(this.h[7], nt);
  }, ft.prototype._digest = function(dt) {
    return dt === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _256;
}
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var B = requireUtils(), L = require_256();
  function K() {
    if (!(this instanceof K)) return new K();
    L.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  return B.inherits(K, L), _224 = K, K.blockSize = 512, K.outSize = 224, K.hmacStrength = 192, K.padLength = 64, K.prototype._digest = function(W) {
    return W === "hex" ? B.toHex32(this.h.slice(0, 7), "big") : B.split32(this.h.slice(0, 7), "big");
  }, _224;
}
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var B = requireUtils(), L = requireCommon$1(), K = requireMinimalisticAssert(), W = B.rotr64_hi, V = B.rotr64_lo, J = B.shr64_hi, re = B.shr64_lo, ie = B.sum64, ne = B.sum64_hi, oe = B.sum64_lo, ce = B.sum64_4_hi, pe = B.sum64_4_lo, ke = B.sum64_5_hi, ot = B.sum64_5_lo, at = L.BlockHash, ft = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function dt() {
    if (!(this instanceof dt)) return new dt();
    at.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = ft, this.W = new Array(160);
  }
  function lt(it, st, Oe, ct, pt) {
    var gt = it & Oe ^ ~it & pt;
    return gt < 0 && (gt += 4294967296), gt;
  }
  function yt(it, st, Oe, ct, pt, gt) {
    var vt = st & ct ^ ~st & gt;
    return vt < 0 && (vt += 4294967296), vt;
  }
  function St(it, st, Oe, ct, pt) {
    var gt = it & Oe ^ it & pt ^ Oe & pt;
    return gt < 0 && (gt += 4294967296), gt;
  }
  function mt(it, st, Oe, ct, pt, gt) {
    var vt = st & ct ^ st & gt ^ ct & gt;
    return vt < 0 && (vt += 4294967296), vt;
  }
  function $t(it, st) {
    var Oe = W(it, st, 28) ^ W(st, it, 2) ^ W(st, it, 7);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function It(it, st) {
    var Oe = V(it, st, 28) ^ V(st, it, 2) ^ V(st, it, 7);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function Ut(it, st) {
    var Oe = W(it, st, 14) ^ W(it, st, 18) ^ W(st, it, 9);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function ut(it, st) {
    var Oe = V(it, st, 14) ^ V(it, st, 18) ^ V(st, it, 9);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function ht(it, st) {
    var Oe = W(it, st, 1) ^ W(it, st, 8) ^ J(it, st, 7);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function Ce(it, st) {
    var Oe = V(it, st, 1) ^ V(it, st, 8) ^ re(it, st, 7);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function nt(it, st) {
    var Oe = W(it, st, 19) ^ W(st, it, 29) ^ J(it, st, 6);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  function rt(it, st) {
    var Oe = V(it, st, 19) ^ V(st, it, 29) ^ re(it, st, 6);
    return Oe < 0 && (Oe += 4294967296), Oe;
  }
  return B.inherits(dt, at), _512 = dt, dt.blockSize = 1024, dt.outSize = 512, dt.hmacStrength = 192, dt.padLength = 128, dt.prototype._prepareBlock = function(it, st) {
    for (var Oe = this.W, ct = 0; ct < 32; ct++) Oe[ct] = it[st + ct];
    for (; ct < Oe.length; ct += 2) {
      var pt = nt(Oe[ct - 4], Oe[ct - 3]), gt = rt(Oe[ct - 4], Oe[ct - 3]), vt = Oe[ct - 14], Bt = Oe[ct - 13], kt = ht(Oe[ct - 30], Oe[ct - 29]), wt = Ce(Oe[ct - 30], Oe[ct - 29]), Et = Oe[ct - 32], Rt = Oe[ct - 31];
      Oe[ct] = ce(pt, gt, vt, Bt, kt, wt, Et, Rt), Oe[ct + 1] = pe(pt, gt, vt, Bt, kt, wt, Et, Rt);
    }
  }, dt.prototype._update = function(it, st) {
    this._prepareBlock(it, st);
    var Oe = this.W, ct = this.h[0], pt = this.h[1], gt = this.h[2], vt = this.h[3], Bt = this.h[4], kt = this.h[5], wt = this.h[6], Et = this.h[7], Rt = this.h[8], Mt = this.h[9], Ht = this.h[10], Kt = this.h[11], jt = this.h[12], Wt = this.h[13], Yt = this.h[14], Xt = this.h[15];
    K(this.k.length === Oe.length);
    for (var ir = 0; ir < Oe.length; ir += 2) {
      var ur = Yt, Qt = Xt, hr = Ut(Rt, Mt), pr = ut(Rt, Mt), cr = lt(Rt, 0, Ht, 0, jt), vr = yt(0, Mt, 0, Kt, 0, Wt), bt = this.k[ir], At = this.k[ir + 1], Tt = Oe[ir], xt = Oe[ir + 1], Nt = ke(ur, Qt, hr, pr, cr, vr, bt, At, Tt, xt), Ft = ot(ur, Qt, hr, pr, cr, vr, bt, At, Tt, xt);
      ur = $t(ct, pt), Qt = It(ct, pt), hr = St(ct, 0, gt, 0, Bt), pr = mt(0, pt, 0, vt, 0, kt);
      var zt = ne(ur, Qt, hr, pr), nr = oe(ur, Qt, hr, pr);
      Yt = jt, Xt = Wt, jt = Ht, Wt = Kt, Ht = Rt, Kt = Mt, Rt = ne(wt, Et, Nt, Ft), Mt = oe(Et, Et, Nt, Ft), wt = Bt, Et = kt, Bt = gt, kt = vt, gt = ct, vt = pt, ct = ne(Nt, Ft, zt, nr), pt = oe(Nt, Ft, zt, nr);
    }
    ie(this.h, 0, ct, pt), ie(this.h, 2, gt, vt), ie(this.h, 4, Bt, kt), ie(this.h, 6, wt, Et), ie(this.h, 8, Rt, Mt), ie(this.h, 10, Ht, Kt), ie(this.h, 12, jt, Wt), ie(this.h, 14, Yt, Xt);
  }, dt.prototype._digest = function(it) {
    return it === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _512;
}
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var B = requireUtils(), L = require_512();
  function K() {
    if (!(this instanceof K)) return new K();
    L.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  return B.inherits(K, L), _384 = K, K.blockSize = 1024, K.outSize = 384, K.hmacStrength = 192, K.padLength = 128, K.prototype._digest = function(W) {
    return W === "hex" ? B.toHex32(this.h.slice(0, 12), "big") : B.split32(this.h.slice(0, 12), "big");
  }, _384;
}
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd, hmac$1, hasRequiredHmac, hasRequiredHash, secp256k1$1, hasRequiredSecp256k1, hasRequiredCurves, hmacDrbg, hasRequiredHmacDrbg, key$1, hasRequiredKey$1, signature$1, hasRequiredSignature$1, ec, hasRequiredEc, key, hasRequiredKey, signature, hasRequiredSignature, eddsa, hasRequiredEddsa, hasRequiredElliptic;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var B = requireUtils(), L = requireCommon$1(), K = B.rotl32, W = B.sum32, V = B.sum32_3, J = B.sum32_4, re = L.BlockHash;
  function ie() {
    if (!(this instanceof ie)) return new ie();
    re.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  function ne(ft, dt, lt, yt) {
    return ft <= 15 ? dt ^ lt ^ yt : ft <= 31 ? dt & lt | ~dt & yt : ft <= 47 ? (dt | ~lt) ^ yt : ft <= 63 ? dt & yt | lt & ~yt : dt ^ (lt | ~yt);
  }
  function oe(ft) {
    return ft <= 15 ? 0 : ft <= 31 ? 1518500249 : ft <= 47 ? 1859775393 : ft <= 63 ? 2400959708 : 2840853838;
  }
  function ce(ft) {
    return ft <= 15 ? 1352829926 : ft <= 31 ? 1548603684 : ft <= 47 ? 1836072691 : ft <= 63 ? 2053994217 : 0;
  }
  B.inherits(ie, re), ripemd.ripemd160 = ie, ie.blockSize = 512, ie.outSize = 160, ie.hmacStrength = 192, ie.padLength = 64, ie.prototype._update = function(ft, dt) {
    for (var lt = this.h[0], yt = this.h[1], St = this.h[2], mt = this.h[3], $t = this.h[4], It = lt, Ut = yt, ut = St, ht = mt, Ce = $t, nt = 0; nt < 80; nt++) {
      var rt = W(K(J(lt, ne(nt, yt, St, mt), ft[pe[nt] + dt], oe(nt)), ot[nt]), $t);
      lt = $t, $t = mt, mt = K(St, 10), St = yt, yt = rt, rt = W(K(J(It, ne(79 - nt, Ut, ut, ht), ft[ke[nt] + dt], ce(nt)), at[nt]), Ce), It = Ce, Ce = ht, ht = K(ut, 10), ut = Ut, Ut = rt;
    }
    rt = V(this.h[1], St, ht), this.h[1] = V(this.h[2], mt, Ce), this.h[2] = V(this.h[3], $t, It), this.h[3] = V(this.h[4], lt, Ut), this.h[4] = V(this.h[0], yt, ut), this.h[0] = rt;
  }, ie.prototype._digest = function(ft) {
    return ft === "hex" ? B.toHex32(this.h, "little") : B.split32(this.h, "little");
  };
  var pe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], ke = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], ot = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], at = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  return ripemd;
}
function requireHmac() {
  if (hasRequiredHmac) return hmac$1;
  hasRequiredHmac = 1;
  var B = requireUtils(), L = requireMinimalisticAssert();
  function K(W, V, J) {
    if (!(this instanceof K)) return new K(W, V, J);
    this.Hash = W, this.blockSize = W.blockSize / 8, this.outSize = W.outSize / 8, this.inner = null, this.outer = null, this._init(B.toArray(V, J));
  }
  return hmac$1 = K, K.prototype._init = function(W) {
    W.length > this.blockSize && (W = new this.Hash().update(W).digest()), L(W.length <= this.blockSize);
    for (var V = W.length; V < this.blockSize; V++) W.push(0);
    for (V = 0; V < W.length; V++) W[V] ^= 54;
    for (this.inner = new this.Hash().update(W), V = 0; V < W.length; V++) W[V] ^= 106;
    this.outer = new this.Hash().update(W);
  }, K.prototype.update = function(W, V) {
    return this.inner.update(W, V), this;
  }, K.prototype.digest = function(W) {
    return this.outer.update(this.inner.digest()), this.outer.digest(W);
  }, hmac$1;
}
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(B) {
    var L = B;
    L.utils = requireUtils(), L.common = requireCommon$1(), L.sha = requireSha(), L.ripemd = requireRipemd(), L.hmac = requireHmac(), L.sha1 = L.sha.sha1, L.sha256 = L.sha.sha256, L.sha224 = L.sha.sha224, L.sha384 = L.sha.sha384, L.sha512 = L.sha.sha512, L.ripemd160 = L.ripemd.ripemd160;
  }(hash)), hash;
}
function requireSecp256k1() {
  return hasRequiredSecp256k1 ? secp256k1$1 : (hasRequiredSecp256k1 = 1, secp256k1$1 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } });
}
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(B) {
    var L, K = B, W = requireHash(), V = requireCurve(), J = requireUtils$1().assert;
    function re(ne) {
      ne.type === "short" ? this.curve = new V.short(ne) : ne.type === "edwards" ? this.curve = new V.edwards(ne) : this.curve = new V.mont(ne), this.g = this.curve.g, this.n = this.curve.n, this.hash = ne.hash, J(this.g.validate(), "Invalid curve"), J(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    function ie(ne, oe) {
      Object.defineProperty(K, ne, { configurable: !0, enumerable: !0, get: function() {
        var ce = new re(oe);
        return Object.defineProperty(K, ne, { configurable: !0, enumerable: !0, value: ce }), ce;
      } });
    }
    K.PresetCurve = re, ie("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: W.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), ie("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: W.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), ie("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: W.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), ie("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: W.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), ie("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: W.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), ie("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: W.sha256, gRed: !1, g: ["9"] }), ie("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: W.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    try {
      L = requireSecp256k1();
    } catch {
      L = void 0;
    }
    ie("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: W.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", L] });
  }(curves)), curves;
}
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var B = requireHash(), L = requireUtils$2(), K = requireMinimalisticAssert();
  function W(V) {
    if (!(this instanceof W)) return new W(V);
    this.hash = V.hash, this.predResist = !!V.predResist, this.outLen = this.hash.outSize, this.minEntropy = V.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var J = L.toArray(V.entropy, V.entropyEnc || "hex"), re = L.toArray(V.nonce, V.nonceEnc || "hex"), ie = L.toArray(V.pers, V.persEnc || "hex");
    K(J.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(J, re, ie);
  }
  return hmacDrbg = W, W.prototype._init = function(V, J, re) {
    var ie = V.concat(J).concat(re);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ne = 0; ne < this.V.length; ne++) this.K[ne] = 0, this.V[ne] = 1;
    this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, W.prototype._hmac = function() {
    return new B.hmac(this.hash, this.K);
  }, W.prototype._update = function(V) {
    var J = this._hmac().update(this.V).update([0]);
    V && (J = J.update(V)), this.K = J.digest(), this.V = this._hmac().update(this.V).digest(), V && (this.K = this._hmac().update(this.V).update([1]).update(V).digest(), this.V = this._hmac().update(this.V).digest());
  }, W.prototype.reseed = function(V, J, re, ie) {
    typeof J != "string" && (ie = re, re = J, J = null), V = L.toArray(V, J), re = L.toArray(re, ie), K(V.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(V.concat(re || [])), this._reseed = 1;
  }, W.prototype.generate = function(V, J, re, ie) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof J != "string" && (ie = re, re = J, J = null), re && (re = L.toArray(re, ie || "hex"), this._update(re));
    for (var ne = []; ne.length < V; ) this.V = this._hmac().update(this.V).digest(), ne = ne.concat(this.V);
    var oe = ne.slice(0, V);
    return this._update(re), this._reseed++, L.encode(oe, J);
  }, hmacDrbg;
}
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var B = requireBn$1(), L = requireUtils$1().assert;
  function K(W, V) {
    this.ec = W, this.priv = null, this.pub = null, V.priv && this._importPrivate(V.priv, V.privEnc), V.pub && this._importPublic(V.pub, V.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(W, V, J) {
    return V instanceof K ? V : new K(W, { pub: V, pubEnc: J });
  }, K.fromPrivate = function(W, V, J) {
    return V instanceof K ? V : new K(W, { priv: V, privEnc: J });
  }, K.prototype.validate = function() {
    var W = this.getPublic();
    return W.isInfinity() ? { result: !1, reason: "Invalid public key" } : W.validate() ? W.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(W, V) {
    return typeof W == "string" && (V = W, W = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), V ? this.pub.encode(V, W) : this.pub;
  }, K.prototype.getPrivate = function(W) {
    return W === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(W, V) {
    this.priv = new B(W, V || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(W, V) {
    if (W.x || W.y) return this.ec.curve.type === "mont" ? L(W.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || L(W.x && W.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(W.x, W.y));
    this.pub = this.ec.curve.decodePoint(W, V);
  }, K.prototype.derive = function(W) {
    return W.validate() || L(W.validate(), "public point not validated"), W.mul(this.priv).getX();
  }, K.prototype.sign = function(W, V, J) {
    return this.ec.sign(W, this, V, J);
  }, K.prototype.verify = function(W, V) {
    return this.ec.verify(W, V, this);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var B = requireBn$1(), L = requireUtils$1(), K = L.assert;
  function W(ne, oe) {
    if (ne instanceof W) return ne;
    this._importDER(ne, oe) || (K(ne.r && ne.s, "Signature without r or s"), this.r = new B(ne.r, 16), this.s = new B(ne.s, 16), ne.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ne.recoveryParam);
  }
  function V() {
    this.place = 0;
  }
  function J(ne, oe) {
    var ce = ne[oe.place++];
    if (!(128 & ce)) return ce;
    var pe = 15 & ce;
    if (pe === 0 || pe > 4 || ne[oe.place] === 0) return !1;
    for (var ke = 0, ot = 0, at = oe.place; ot < pe; ot++, at++) ke <<= 8, ke |= ne[at], ke >>>= 0;
    return !(ke <= 127) && (oe.place = at, ke);
  }
  function re(ne) {
    for (var oe = 0, ce = ne.length - 1; !ne[oe] && !(128 & ne[oe + 1]) && oe < ce; ) oe++;
    return oe === 0 ? ne : ne.slice(oe);
  }
  function ie(ne, oe) {
    if (oe < 128) ne.push(oe);
    else {
      var ce = 1 + (Math.log(oe) / Math.LN2 >>> 3);
      for (ne.push(128 | ce); --ce; ) ne.push(oe >>> (ce << 3) & 255);
      ne.push(oe);
    }
  }
  return signature$1 = W, W.prototype._importDER = function(ne, oe) {
    ne = L.toArray(ne, oe);
    var ce = new V();
    if (ne[ce.place++] !== 48) return !1;
    var pe = J(ne, ce);
    if (pe === !1 || pe + ce.place !== ne.length || ne[ce.place++] !== 2) return !1;
    var ke = J(ne, ce);
    if (ke === !1 || 128 & ne[ce.place]) return !1;
    var ot = ne.slice(ce.place, ke + ce.place);
    if (ce.place += ke, ne[ce.place++] !== 2) return !1;
    var at = J(ne, ce);
    if (at === !1 || ne.length !== at + ce.place || 128 & ne[ce.place]) return !1;
    var ft = ne.slice(ce.place, at + ce.place);
    if (ot[0] === 0) {
      if (!(128 & ot[1])) return !1;
      ot = ot.slice(1);
    }
    if (ft[0] === 0) {
      if (!(128 & ft[1])) return !1;
      ft = ft.slice(1);
    }
    return this.r = new B(ot), this.s = new B(ft), this.recoveryParam = null, !0;
  }, W.prototype.toDER = function(ne) {
    var oe = this.r.toArray(), ce = this.s.toArray();
    for (128 & oe[0] && (oe = [0].concat(oe)), 128 & ce[0] && (ce = [0].concat(ce)), oe = re(oe), ce = re(ce); !(ce[0] || 128 & ce[1]); ) ce = ce.slice(1);
    var pe = [2];
    ie(pe, oe.length), (pe = pe.concat(oe)).push(2), ie(pe, ce.length);
    var ke = pe.concat(ce), ot = [48];
    return ie(ot, ke.length), ot = ot.concat(ke), L.encode(ot, ne);
  }, signature$1;
}
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = requireBn$1(), L = requireHmacDrbg(), K = requireUtils$1(), W = requireCurves(), V = requireBrorand(), J = K.assert, re = requireKey$1(), ie = requireSignature$1();
  function ne(oe) {
    if (!(this instanceof ne)) return new ne(oe);
    typeof oe == "string" && (J(Object.prototype.hasOwnProperty.call(W, oe), "Unknown curve " + oe), oe = W[oe]), oe instanceof W.PresetCurve && (oe = { curve: oe }), this.curve = oe.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = oe.curve.g, this.g.precompute(oe.curve.n.bitLength() + 1), this.hash = oe.hash || oe.curve.hash;
  }
  return ec = ne, ne.prototype.keyPair = function(oe) {
    return new re(this, oe);
  }, ne.prototype.keyFromPrivate = function(oe, ce) {
    return re.fromPrivate(this, oe, ce);
  }, ne.prototype.keyFromPublic = function(oe, ce) {
    return re.fromPublic(this, oe, ce);
  }, ne.prototype.genKeyPair = function(oe) {
    oe || (oe = {});
    for (var ce = new L({ hash: this.hash, pers: oe.pers, persEnc: oe.persEnc || "utf8", entropy: oe.entropy || V(this.hash.hmacStrength), entropyEnc: oe.entropy && oe.entropyEnc || "utf8", nonce: this.n.toArray() }), pe = this.n.byteLength(), ke = this.n.sub(new B(2)); ; ) {
      var ot = new B(ce.generate(pe));
      if (!(ot.cmp(ke) > 0)) return ot.iaddn(1), this.keyFromPrivate(ot);
    }
  }, ne.prototype._truncateToN = function(oe, ce) {
    var pe = 8 * oe.byteLength() - this.n.bitLength();
    return pe > 0 && (oe = oe.ushrn(pe)), !ce && oe.cmp(this.n) >= 0 ? oe.sub(this.n) : oe;
  }, ne.prototype.sign = function(oe, ce, pe, ke) {
    typeof pe == "object" && (ke = pe, pe = null), ke || (ke = {}), ce = this.keyFromPrivate(ce, pe), oe = this._truncateToN(new B(oe, 16));
    for (var ot = this.n.byteLength(), at = ce.getPrivate().toArray("be", ot), ft = oe.toArray("be", ot), dt = new L({ hash: this.hash, entropy: at, nonce: ft, pers: ke.pers, persEnc: ke.persEnc || "utf8" }), lt = this.n.sub(new B(1)), yt = 0; ; yt++) {
      var St = ke.k ? ke.k(yt) : new B(dt.generate(this.n.byteLength()));
      if (!((St = this._truncateToN(St, !0)).cmpn(1) <= 0 || St.cmp(lt) >= 0)) {
        var mt = this.g.mul(St);
        if (!mt.isInfinity()) {
          var $t = mt.getX(), It = $t.umod(this.n);
          if (It.cmpn(0) !== 0) {
            var Ut = St.invm(this.n).mul(It.mul(ce.getPrivate()).iadd(oe));
            if ((Ut = Ut.umod(this.n)).cmpn(0) !== 0) {
              var ut = (mt.getY().isOdd() ? 1 : 0) | ($t.cmp(It) !== 0 ? 2 : 0);
              return ke.canonical && Ut.cmp(this.nh) > 0 && (Ut = this.n.sub(Ut), ut ^= 1), new ie({ r: It, s: Ut, recoveryParam: ut });
            }
          }
        }
      }
    }
  }, ne.prototype.verify = function(oe, ce, pe, ke) {
    oe = this._truncateToN(new B(oe, 16)), pe = this.keyFromPublic(pe, ke);
    var ot = (ce = new ie(ce, "hex")).r, at = ce.s;
    if (ot.cmpn(1) < 0 || ot.cmp(this.n) >= 0 || at.cmpn(1) < 0 || at.cmp(this.n) >= 0) return !1;
    var ft, dt = at.invm(this.n), lt = dt.mul(oe).umod(this.n), yt = dt.mul(ot).umod(this.n);
    return this.curve._maxwellTrick ? !(ft = this.g.jmulAdd(lt, pe.getPublic(), yt)).isInfinity() && ft.eqXToP(ot) : !(ft = this.g.mulAdd(lt, pe.getPublic(), yt)).isInfinity() && ft.getX().umod(this.n).cmp(ot) === 0;
  }, ne.prototype.recoverPubKey = function(oe, ce, pe, ke) {
    J((3 & pe) === pe, "The recovery param is more than two bits"), ce = new ie(ce, ke);
    var ot = this.n, at = new B(oe), ft = ce.r, dt = ce.s, lt = 1 & pe, yt = pe >> 1;
    if (ft.cmp(this.curve.p.umod(this.curve.n)) >= 0 && yt) throw new Error("Unable to find sencond key candinate");
    ft = yt ? this.curve.pointFromX(ft.add(this.curve.n), lt) : this.curve.pointFromX(ft, lt);
    var St = ce.r.invm(ot), mt = ot.sub(at).mul(St).umod(ot), $t = dt.mul(St).umod(ot);
    return this.g.mulAdd(mt, ft, $t);
  }, ne.prototype.getKeyRecoveryParam = function(oe, ce, pe, ke) {
    if ((ce = new ie(ce, ke)).recoveryParam !== null) return ce.recoveryParam;
    for (var ot = 0; ot < 4; ot++) {
      var at;
      try {
        at = this.recoverPubKey(oe, ce, ot);
      } catch {
        continue;
      }
      if (at.eq(pe)) return ot;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var B = requireUtils$1(), L = B.assert, K = B.parseBytes, W = B.cachedProperty;
  function V(J, re) {
    this.eddsa = J, this._secret = K(re.secret), J.isPoint(re.pub) ? this._pub = re.pub : this._pubBytes = K(re.pub);
  }
  return V.fromPublic = function(J, re) {
    return re instanceof V ? re : new V(J, { pub: re });
  }, V.fromSecret = function(J, re) {
    return re instanceof V ? re : new V(J, { secret: re });
  }, V.prototype.secret = function() {
    return this._secret;
  }, W(V, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), W(V, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), W(V, "privBytes", function() {
    var J = this.eddsa, re = this.hash(), ie = J.encodingLength - 1, ne = re.slice(0, J.encodingLength);
    return ne[0] &= 248, ne[ie] &= 127, ne[ie] |= 64, ne;
  }), W(V, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), W(V, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), W(V, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), V.prototype.sign = function(J) {
    return L(this._secret, "KeyPair can only verify"), this.eddsa.sign(J, this);
  }, V.prototype.verify = function(J, re) {
    return this.eddsa.verify(J, re, this);
  }, V.prototype.getSecret = function(J) {
    return L(this._secret, "KeyPair is public only"), B.encode(this.secret(), J);
  }, V.prototype.getPublic = function(J) {
    return B.encode(this.pubBytes(), J);
  }, key = V;
}
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var B = requireBn$1(), L = requireUtils$1(), K = L.assert, W = L.cachedProperty, V = L.parseBytes;
  function J(re, ie) {
    this.eddsa = re, typeof ie != "object" && (ie = V(ie)), Array.isArray(ie) && (K(ie.length === 2 * re.encodingLength, "Signature has invalid size"), ie = { R: ie.slice(0, re.encodingLength), S: ie.slice(re.encodingLength) }), K(ie.R && ie.S, "Signature without R or S"), re.isPoint(ie.R) && (this._R = ie.R), ie.S instanceof B && (this._S = ie.S), this._Rencoded = Array.isArray(ie.R) ? ie.R : ie.Rencoded, this._Sencoded = Array.isArray(ie.S) ? ie.S : ie.Sencoded;
  }
  return W(J, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), W(J, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), W(J, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), W(J, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), J.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, J.prototype.toHex = function() {
    return L.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = J;
}
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var B = requireHash(), L = requireCurves(), K = requireUtils$1(), W = K.assert, V = K.parseBytes, J = requireKey(), re = requireSignature();
  function ie(ne) {
    if (W(ne === "ed25519", "only tested with ed25519 so far"), !(this instanceof ie)) return new ie(ne);
    ne = L[ne].curve, this.curve = ne, this.g = ne.g, this.g.precompute(ne.n.bitLength() + 1), this.pointClass = ne.point().constructor, this.encodingLength = Math.ceil(ne.n.bitLength() / 8), this.hash = B.sha512;
  }
  return eddsa = ie, ie.prototype.sign = function(ne, oe) {
    ne = V(ne);
    var ce = this.keyFromSecret(oe), pe = this.hashInt(ce.messagePrefix(), ne), ke = this.g.mul(pe), ot = this.encodePoint(ke), at = this.hashInt(ot, ce.pubBytes(), ne).mul(ce.priv()), ft = pe.add(at).umod(this.curve.n);
    return this.makeSignature({ R: ke, S: ft, Rencoded: ot });
  }, ie.prototype.verify = function(ne, oe, ce) {
    if (ne = V(ne), (oe = this.makeSignature(oe)).S().gte(oe.eddsa.curve.n) || oe.S().isNeg()) return !1;
    var pe = this.keyFromPublic(ce), ke = this.hashInt(oe.Rencoded(), pe.pubBytes(), ne), ot = this.g.mul(oe.S());
    return oe.R().add(pe.pub().mul(ke)).eq(ot);
  }, ie.prototype.hashInt = function() {
    for (var ne = this.hash(), oe = 0; oe < arguments.length; oe++) ne.update(arguments[oe]);
    return K.intFromLE(ne.digest()).umod(this.curve.n);
  }, ie.prototype.keyFromPublic = function(ne) {
    return J.fromPublic(this, ne);
  }, ie.prototype.keyFromSecret = function(ne) {
    return J.fromSecret(this, ne);
  }, ie.prototype.makeSignature = function(ne) {
    return ne instanceof re ? ne : new re(this, ne);
  }, ie.prototype.encodePoint = function(ne) {
    var oe = ne.getY().toArray("le", this.encodingLength);
    return oe[this.encodingLength - 1] |= ne.getX().isOdd() ? 128 : 0, oe;
  }, ie.prototype.decodePoint = function(ne) {
    var oe = (ne = K.parseBytes(ne)).length - 1, ce = ne.slice(0, oe).concat(-129 & ne[oe]), pe = !!(128 & ne[oe]), ke = K.intFromLE(ce);
    return this.curve.pointFromY(ke, pe);
  }, ie.prototype.encodeInt = function(ne) {
    return ne.toArray("le", this.encodingLength);
  }, ie.prototype.decodeInt = function(ne) {
    return K.intFromLE(ne);
  }, ie.prototype.isPoint = function(ne) {
    return ne instanceof this.pointClass;
  }, eddsa;
}
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var L = B;
    L.version = require$$0.version, L.utils = requireUtils$1(), L.rand = requireBrorand(), L.curve = requireCurve(), L.curves = requireCurves(), L.ec = requireEc(), L.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify, hasRequiredApi;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, L) {
      if (B.indexOf) return B.indexOf(L);
      for (var K = 0; K < B.length; K++) if (B[K] === L) return K;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var L = [];
      for (var K in B) L.push(K);
      return L;
    }, forEach = function(B, L) {
      if (B.forEach) return B.forEach(L);
      for (var K = 0; K < B.length; K++) L(B[K], K, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, L, K) {
          Object.defineProperty(B, L, { writable: !0, enumerable: !1, configurable: !0, value: K });
        };
      } catch {
        return function(L, K, W) {
          L[K] = W;
        };
      }
    }(), globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context)) throw new TypeError("needs a 'context' argument.");
      var L = document.createElement("iframe");
      L.style || (L.style = {}), L.style.display = "none", document.body.appendChild(L);
      var K = L.contentWindow, W = K.eval, V = K.execScript;
      !W && V && (V.call(K, "null"), W = K.eval), forEach(Object_keys(B), function(ie) {
        K[ie] = B[ie];
      }), forEach(globals, function(ie) {
        B[ie] && (K[ie] = B[ie]);
      });
      var J = Object_keys(K), re = W.call(K, this.code);
      return forEach(Object_keys(K), function(ie) {
        (ie in B || indexOf(J, ie) === -1) && (B[ie] = K[ie]);
      }), forEach(globals, function(ie) {
        ie in B || defineProp(B, ie, K[ie]);
      }), document.body.removeChild(L), re;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var L = Script.createContext(B), K = this.runInContext(L);
      return B && forEach(Object_keys(L), function(W) {
        B[W] = L[W];
      }), K;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(L) {
        var K = Script(L);
        return K[B].apply(K, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var L = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(K) {
        L[K] = B[K];
      }), L;
    };
  }(vmBrowserify)), vmBrowserify;
}
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var L = requireAsn1$1(), K = requireInherits_browser();
    function W(V, J) {
      this.name = V, this.body = J, this.decoders = {}, this.encoders = {};
    }
    B.define = function(V, J) {
      return new W(V, J);
    }, W.prototype._createNamed = function(V) {
      var J;
      try {
        J = requireVmBrowserify().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
      } catch {
        J = function(ie) {
          this._initNamed(ie);
        };
      }
      return K(J, V), J.prototype._initNamed = function(re) {
        V.call(this, re);
      }, new J(this);
    }, W.prototype._getDecoder = function(V) {
      return V = V || "der", this.decoders.hasOwnProperty(V) || (this.decoders[V] = this._createNamed(L.decoders[V])), this.decoders[V];
    }, W.prototype.decode = function(V, J, re) {
      return this._getDecoder(J).decode(V, re);
    }, W.prototype._getEncoder = function(V) {
      return V = V || "der", this.encoders.hasOwnProperty(V) || (this.encoders[V] = this._createNamed(L.encoders[V])), this.encoders[V];
    }, W.prototype.encode = function(V, J, re) {
      return this._getEncoder(J).encode(V, re);
    };
  }(api)), api;
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var B = requireInherits_browser();
  function L(W) {
    this._reporterState = { obj: null, path: [], options: W || {}, errors: [] };
  }
  function K(W, V) {
    this.path = W, this.rethrow(V);
  }
  return reporter.Reporter = L, L.prototype.isError = function(W) {
    return W instanceof K;
  }, L.prototype.save = function() {
    var W = this._reporterState;
    return { obj: W.obj, pathLen: W.path.length };
  }, L.prototype.restore = function(W) {
    var V = this._reporterState;
    V.obj = W.obj, V.path = V.path.slice(0, W.pathLen);
  }, L.prototype.enterKey = function(W) {
    return this._reporterState.path.push(W);
  }, L.prototype.exitKey = function(W) {
    var V = this._reporterState;
    V.path = V.path.slice(0, W - 1);
  }, L.prototype.leaveKey = function(W, V, J) {
    var re = this._reporterState;
    this.exitKey(W), re.obj !== null && (re.obj[V] = J);
  }, L.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, L.prototype.enterObject = function() {
    var W = this._reporterState, V = W.obj;
    return W.obj = {}, V;
  }, L.prototype.leaveObject = function(W) {
    var V = this._reporterState, J = V.obj;
    return V.obj = W, J;
  }, L.prototype.error = function(W) {
    var V, J = this._reporterState, re = W instanceof K;
    if (V = re ? W : new K(J.path.map(function(ie) {
      return "[" + JSON.stringify(ie) + "]";
    }).join(""), W.message || W, W.stack), !J.options.partial) throw V;
    return re || J.errors.push(V), V;
  }, L.prototype.wrapResult = function(W) {
    var V = this._reporterState;
    return V.options.partial ? { result: this.isError(W) ? null : W, errors: V.errors } : W;
  }, B(K, Error), K.prototype.rethrow = function(W) {
    if (this.message = W + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, K), !this.stack) try {
      throw new Error(this.message);
    } catch (V) {
      this.stack = V.stack;
    }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer, node, hasRequiredNode, hasRequiredBase;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = requireInherits_browser(), L = requireBase().Reporter, K = require$$1$2.Buffer;
  function W(J, re) {
    L.call(this, re), K.isBuffer(J) ? (this.base = J, this.offset = 0, this.length = J.length) : this.error("Input not Buffer");
  }
  function V(J, re) {
    if (Array.isArray(J)) this.length = 0, this.value = J.map(function(ie) {
      return ie instanceof V || (ie = new V(ie, re)), this.length += ie.length, ie;
    }, this);
    else if (typeof J == "number") {
      if (!(0 <= J && J <= 255)) return re.error("non-byte EncoderBuffer value");
      this.value = J, this.length = 1;
    } else if (typeof J == "string") this.value = J, this.length = K.byteLength(J);
    else {
      if (!K.isBuffer(J)) return re.error("Unsupported type: " + typeof J);
      this.value = J, this.length = J.length;
    }
  }
  return B(W, L), buffer.DecoderBuffer = W, W.prototype.save = function() {
    return { offset: this.offset, reporter: L.prototype.save.call(this) };
  }, W.prototype.restore = function(J) {
    var re = new W(this.base);
    return re.offset = J.offset, re.length = this.offset, this.offset = J.offset, L.prototype.restore.call(this, J.reporter), re;
  }, W.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, W.prototype.readUInt8 = function(J) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(J || "DecoderBuffer overrun");
  }, W.prototype.skip = function(J, re) {
    if (!(this.offset + J <= this.length)) return this.error(re || "DecoderBuffer overrun");
    var ie = new W(this.base);
    return ie._reporterState = this._reporterState, ie.offset = this.offset, ie.length = this.offset + J, this.offset += J, ie;
  }, W.prototype.raw = function(J) {
    return this.base.slice(J ? J.offset : this.offset, this.length);
  }, buffer.EncoderBuffer = V, V.prototype.join = function(J, re) {
    return J || (J = new K(this.length)), re || (re = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ie) {
      ie.join(J, re), re += ie.length;
    }) : (typeof this.value == "number" ? J[re] = this.value : typeof this.value == "string" ? J.write(this.value, re) : K.isBuffer(this.value) && this.value.copy(J, re), re += this.length)), J;
  }, buffer;
}
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, L = requireBase().EncoderBuffer, K = requireBase().DecoderBuffer, W = requireMinimalisticAssert(), V = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], J = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(V);
  function re(ne, oe) {
    var ce = {};
    this._baseState = ce, ce.enc = ne, ce.parent = oe || null, ce.children = null, ce.tag = null, ce.args = null, ce.reverseArgs = null, ce.choice = null, ce.optional = !1, ce.any = !1, ce.obj = !1, ce.use = null, ce.useDecoder = null, ce.key = null, ce.default = null, ce.explicit = null, ce.implicit = null, ce.contains = null, ce.parent || (ce.children = [], this._wrap());
  }
  node = re;
  var ie = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  return re.prototype.clone = function() {
    var ne = this._baseState, oe = {};
    ie.forEach(function(pe) {
      oe[pe] = ne[pe];
    });
    var ce = new this.constructor(oe.parent);
    return ce._baseState = oe, ce;
  }, re.prototype._wrap = function() {
    var ne = this._baseState;
    J.forEach(function(oe) {
      this[oe] = function() {
        var ce = new this.constructor(this);
        return ne.children.push(ce), ce[oe].apply(ce, arguments);
      };
    }, this);
  }, re.prototype._init = function(ne) {
    var oe = this._baseState;
    W(oe.parent === null), ne.call(this), oe.children = oe.children.filter(function(ce) {
      return ce._baseState.parent === this;
    }, this), W.equal(oe.children.length, 1, "Root node can have only one child");
  }, re.prototype._useArgs = function(ne) {
    var oe = this._baseState, ce = ne.filter(function(pe) {
      return pe instanceof this.constructor;
    }, this);
    ne = ne.filter(function(pe) {
      return !(pe instanceof this.constructor);
    }, this), ce.length !== 0 && (W(oe.children === null), oe.children = ce, ce.forEach(function(pe) {
      pe._baseState.parent = this;
    }, this)), ne.length !== 0 && (W(oe.args === null), oe.args = ne, oe.reverseArgs = ne.map(function(pe) {
      if (typeof pe != "object" || pe.constructor !== Object) return pe;
      var ke = {};
      return Object.keys(pe).forEach(function(ot) {
        ot == (0 | ot) && (ot |= 0);
        var at = pe[ot];
        ke[at] = ot;
      }), ke;
    }));
  }, ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach(function(ne) {
    re.prototype[ne] = function() {
      var oe = this._baseState;
      throw new Error(ne + " not implemented for encoding: " + oe.enc);
    };
  }), V.forEach(function(ne) {
    re.prototype[ne] = function() {
      var oe = this._baseState, ce = Array.prototype.slice.call(arguments);
      return W(oe.tag === null), oe.tag = ne, this._useArgs(ce), this;
    };
  }), re.prototype.use = function(ne) {
    W(ne);
    var oe = this._baseState;
    return W(oe.use === null), oe.use = ne, this;
  }, re.prototype.optional = function() {
    return this._baseState.optional = !0, this;
  }, re.prototype.def = function(ne) {
    var oe = this._baseState;
    return W(oe.default === null), oe.default = ne, oe.optional = !0, this;
  }, re.prototype.explicit = function(ne) {
    var oe = this._baseState;
    return W(oe.explicit === null && oe.implicit === null), oe.explicit = ne, this;
  }, re.prototype.implicit = function(ne) {
    var oe = this._baseState;
    return W(oe.explicit === null && oe.implicit === null), oe.implicit = ne, this;
  }, re.prototype.obj = function() {
    var ne = this._baseState, oe = Array.prototype.slice.call(arguments);
    return ne.obj = !0, oe.length !== 0 && this._useArgs(oe), this;
  }, re.prototype.key = function(ne) {
    var oe = this._baseState;
    return W(oe.key === null), oe.key = ne, this;
  }, re.prototype.any = function() {
    return this._baseState.any = !0, this;
  }, re.prototype.choice = function(ne) {
    var oe = this._baseState;
    return W(oe.choice === null), oe.choice = ne, this._useArgs(Object.keys(ne).map(function(ce) {
      return ne[ce];
    })), this;
  }, re.prototype.contains = function(ne) {
    var oe = this._baseState;
    return W(oe.use === null), oe.contains = ne, this;
  }, re.prototype._decode = function(ne, oe) {
    var ce = this._baseState;
    if (ce.parent === null) return ne.wrapResult(ce.children[0]._decode(ne, oe));
    var pe, ke = ce.default, ot = !0, at = null;
    if (ce.key !== null && (at = ne.enterKey(ce.key)), ce.optional) {
      var ft = null;
      if (ce.explicit !== null ? ft = ce.explicit : ce.implicit !== null ? ft = ce.implicit : ce.tag !== null && (ft = ce.tag), ft !== null || ce.any) {
        if (ot = this._peekTag(ne, ft, ce.any), ne.isError(ot)) return ot;
      } else {
        var dt = ne.save();
        try {
          ce.choice === null ? this._decodeGeneric(ce.tag, ne, oe) : this._decodeChoice(ne, oe), ot = !0;
        } catch {
          ot = !1;
        }
        ne.restore(dt);
      }
    }
    if (ce.obj && ot && (pe = ne.enterObject()), ot) {
      if (ce.explicit !== null) {
        var lt = this._decodeTag(ne, ce.explicit);
        if (ne.isError(lt)) return lt;
        ne = lt;
      }
      var yt = ne.offset;
      if (ce.use === null && ce.choice === null) {
        ce.any && (dt = ne.save());
        var St = this._decodeTag(ne, ce.implicit !== null ? ce.implicit : ce.tag, ce.any);
        if (ne.isError(St)) return St;
        ce.any ? ke = ne.raw(dt) : ne = St;
      }
      if (oe && oe.track && ce.tag !== null && oe.track(ne.path(), yt, ne.length, "tagged"), oe && oe.track && ce.tag !== null && oe.track(ne.path(), ne.offset, ne.length, "content"), ce.any || (ke = ce.choice === null ? this._decodeGeneric(ce.tag, ne, oe) : this._decodeChoice(ne, oe)), ne.isError(ke)) return ke;
      if (ce.any || ce.choice !== null || ce.children === null || ce.children.forEach(function($t) {
        $t._decode(ne, oe);
      }), ce.contains && (ce.tag === "octstr" || ce.tag === "bitstr")) {
        var mt = new K(ke);
        ke = this._getUse(ce.contains, ne._reporterState.obj)._decode(mt, oe);
      }
    }
    return ce.obj && ot && (ke = ne.leaveObject(pe)), ce.key === null || ke === null && ot !== !0 ? at !== null && ne.exitKey(at) : ne.leaveKey(at, ce.key, ke), ke;
  }, re.prototype._decodeGeneric = function(ne, oe, ce) {
    var pe = this._baseState;
    return ne === "seq" || ne === "set" ? null : ne === "seqof" || ne === "setof" ? this._decodeList(oe, ne, pe.args[0], ce) : /str$/.test(ne) ? this._decodeStr(oe, ne, ce) : ne === "objid" && pe.args ? this._decodeObjid(oe, pe.args[0], pe.args[1], ce) : ne === "objid" ? this._decodeObjid(oe, null, null, ce) : ne === "gentime" || ne === "utctime" ? this._decodeTime(oe, ne, ce) : ne === "null_" ? this._decodeNull(oe, ce) : ne === "bool" ? this._decodeBool(oe, ce) : ne === "objDesc" ? this._decodeStr(oe, ne, ce) : ne === "int" || ne === "enum" ? this._decodeInt(oe, pe.args && pe.args[0], ce) : pe.use !== null ? this._getUse(pe.use, oe._reporterState.obj)._decode(oe, ce) : oe.error("unknown tag: " + ne);
  }, re.prototype._getUse = function(ne, oe) {
    var ce = this._baseState;
    return ce.useDecoder = this._use(ne, oe), W(ce.useDecoder._baseState.parent === null), ce.useDecoder = ce.useDecoder._baseState.children[0], ce.implicit !== ce.useDecoder._baseState.implicit && (ce.useDecoder = ce.useDecoder.clone(), ce.useDecoder._baseState.implicit = ce.implicit), ce.useDecoder;
  }, re.prototype._decodeChoice = function(ne, oe) {
    var ce = this._baseState, pe = null, ke = !1;
    return Object.keys(ce.choice).some(function(ot) {
      var at = ne.save(), ft = ce.choice[ot];
      try {
        var dt = ft._decode(ne, oe);
        if (ne.isError(dt)) return !1;
        pe = { type: ot, value: dt }, ke = !0;
      } catch {
        return ne.restore(at), !1;
      }
      return !0;
    }, this), ke ? pe : ne.error("Choice not matched");
  }, re.prototype._createEncoderBuffer = function(ne) {
    return new L(ne, this.reporter);
  }, re.prototype._encode = function(ne, oe, ce) {
    var pe = this._baseState;
    if (pe.default === null || pe.default !== ne) {
      var ke = this._encodeValue(ne, oe, ce);
      if (ke !== void 0 && !this._skipDefault(ke, oe, ce)) return ke;
    }
  }, re.prototype._encodeValue = function(ne, oe, ce) {
    var pe = this._baseState;
    if (pe.parent === null) return pe.children[0]._encode(ne, oe || new B());
    var ke = null;
    if (this.reporter = oe, pe.optional && ne === void 0) {
      if (pe.default === null) return;
      ne = pe.default;
    }
    var ot = null, at = !1;
    if (pe.any) ke = this._createEncoderBuffer(ne);
    else if (pe.choice) ke = this._encodeChoice(ne, oe);
    else if (pe.contains) ot = this._getUse(pe.contains, ce)._encode(ne, oe), at = !0;
    else if (pe.children) ot = pe.children.map(function(yt) {
      if (yt._baseState.tag === "null_") return yt._encode(null, oe, ne);
      if (yt._baseState.key === null) return oe.error("Child should have a key");
      var St = oe.enterKey(yt._baseState.key);
      if (typeof ne != "object") return oe.error("Child expected, but input is not object");
      var mt = yt._encode(ne[yt._baseState.key], oe, ne);
      return oe.leaveKey(St), mt;
    }, this).filter(function(yt) {
      return yt;
    }), ot = this._createEncoderBuffer(ot);
    else if (pe.tag === "seqof" || pe.tag === "setof") {
      if (!pe.args || pe.args.length !== 1) return oe.error("Too many args for : " + pe.tag);
      if (!Array.isArray(ne)) return oe.error("seqof/setof, but data is not Array");
      var ft = this.clone();
      ft._baseState.implicit = null, ot = this._createEncoderBuffer(ne.map(function(yt) {
        var St = this._baseState;
        return this._getUse(St.args[0], ne)._encode(yt, oe);
      }, ft));
    } else pe.use !== null ? ke = this._getUse(pe.use, ce)._encode(ne, oe) : (ot = this._encodePrimitive(pe.tag, ne), at = !0);
    if (!pe.any && pe.choice === null) {
      var dt = pe.implicit !== null ? pe.implicit : pe.tag, lt = pe.implicit === null ? "universal" : "context";
      dt === null ? pe.use === null && oe.error("Tag could be omitted only for .use()") : pe.use === null && (ke = this._encodeComposite(dt, at, lt, ot));
    }
    return pe.explicit !== null && (ke = this._encodeComposite(pe.explicit, !1, "context", ke)), ke;
  }, re.prototype._encodeChoice = function(ne, oe) {
    var ce = this._baseState, pe = ce.choice[ne.type];
    return pe || W(!1, ne.type + " not found in " + JSON.stringify(Object.keys(ce.choice))), pe._encode(ne.value, oe);
  }, re.prototype._encodePrimitive = function(ne, oe) {
    var ce = this._baseState;
    if (/str$/.test(ne)) return this._encodeStr(oe, ne);
    if (ne === "objid" && ce.args) return this._encodeObjid(oe, ce.reverseArgs[0], ce.args[1]);
    if (ne === "objid") return this._encodeObjid(oe, null, null);
    if (ne === "gentime" || ne === "utctime") return this._encodeTime(oe, ne);
    if (ne === "null_") return this._encodeNull();
    if (ne === "int" || ne === "enum") return this._encodeInt(oe, ce.args && ce.reverseArgs[0]);
    if (ne === "bool") return this._encodeBool(oe);
    if (ne === "objDesc") return this._encodeStr(oe, ne);
    throw new Error("Unsupported tag: " + ne);
  }, re.prototype._isNumstr = function(ne) {
    return /^[0-9 ]*$/.test(ne);
  }, re.prototype._isPrintstr = function(ne) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(ne);
  }, node;
}
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var L = B;
    L.Reporter = requireReporter().Reporter, L.DecoderBuffer = requireBuffer().DecoderBuffer, L.EncoderBuffer = requireBuffer().EncoderBuffer, L.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2, hasRequiredConstants;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var L = requireConstants();
    B.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, B.tagClassByName = L._reverse(B.tagClass), B.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, B.tagByName = L._reverse(B.tag);
  }(der)), der;
}
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var L = B;
    L._reverse = function(K) {
      var W = {};
      return Object.keys(K).forEach(function(V) {
        (0 | V) == V && (V |= 0);
        var J = K[V];
        W[J] = V;
      }), W;
    }, L.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1, pem$1, hasRequiredPem$1, hasRequiredDecoders;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = requireInherits_browser(), L = requireAsn1$1(), K = L.base, W = L.bignum, V = L.constants.der;
  function J(oe) {
    this.enc = "der", this.name = oe.name, this.entity = oe, this.tree = new re(), this.tree._init(oe.body);
  }
  function re(oe) {
    K.Node.call(this, "der", oe);
  }
  function ie(oe, ce) {
    var pe = oe.readUInt8(ce);
    if (oe.isError(pe)) return pe;
    var ke = V.tagClass[pe >> 6], ot = !(32 & pe);
    if (31 & ~pe) pe &= 31;
    else {
      var at = pe;
      for (pe = 0; !(128 & ~at); ) {
        if (at = oe.readUInt8(ce), oe.isError(at)) return at;
        pe <<= 7, pe |= 127 & at;
      }
    }
    return { cls: ke, primitive: ot, tag: pe, tagStr: V.tag[pe] };
  }
  function ne(oe, ce, pe) {
    var ke = oe.readUInt8(pe);
    if (oe.isError(ke)) return ke;
    if (!ce && ke === 128) return null;
    if (!(128 & ke)) return ke;
    var ot = 127 & ke;
    if (ot > 4) return oe.error("length octect is too long");
    ke = 0;
    for (var at = 0; at < ot; at++) {
      ke <<= 8;
      var ft = oe.readUInt8(pe);
      if (oe.isError(ft)) return ft;
      ke |= ft;
    }
    return ke;
  }
  return der_1$1 = J, J.prototype.decode = function(oe, ce) {
    return oe instanceof K.DecoderBuffer || (oe = new K.DecoderBuffer(oe, ce)), this.tree._decode(oe, ce);
  }, B(re, K.Node), re.prototype._peekTag = function(oe, ce, pe) {
    if (oe.isEmpty()) return !1;
    var ke = oe.save(), ot = ie(oe, 'Failed to peek tag: "' + ce + '"');
    return oe.isError(ot) ? ot : (oe.restore(ke), ot.tag === ce || ot.tagStr === ce || ot.tagStr + "of" === ce || pe);
  }, re.prototype._decodeTag = function(oe, ce, pe) {
    var ke = ie(oe, 'Failed to decode tag of "' + ce + '"');
    if (oe.isError(ke)) return ke;
    var ot = ne(oe, ke.primitive, 'Failed to get length of "' + ce + '"');
    if (oe.isError(ot)) return ot;
    if (!pe && ke.tag !== ce && ke.tagStr !== ce && ke.tagStr + "of" !== ce) return oe.error('Failed to match tag: "' + ce + '"');
    if (ke.primitive || ot !== null) return oe.skip(ot, 'Failed to match body of: "' + ce + '"');
    var at = oe.save(), ft = this._skipUntilEnd(oe, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return oe.isError(ft) ? ft : (ot = oe.offset - at.offset, oe.restore(at), oe.skip(ot, 'Failed to match body of: "' + ce + '"'));
  }, re.prototype._skipUntilEnd = function(oe, ce) {
    for (; ; ) {
      var pe = ie(oe, ce);
      if (oe.isError(pe)) return pe;
      var ke, ot = ne(oe, pe.primitive, ce);
      if (oe.isError(ot)) return ot;
      if (ke = pe.primitive || ot !== null ? oe.skip(ot) : this._skipUntilEnd(oe, ce), oe.isError(ke)) return ke;
      if (pe.tagStr === "end") break;
    }
  }, re.prototype._decodeList = function(oe, ce, pe, ke) {
    for (var ot = []; !oe.isEmpty(); ) {
      var at = this._peekTag(oe, "end");
      if (oe.isError(at)) return at;
      var ft = pe.decode(oe, "der", ke);
      if (oe.isError(ft) && at) break;
      ot.push(ft);
    }
    return ot;
  }, re.prototype._decodeStr = function(oe, ce) {
    if (ce === "bitstr") {
      var pe = oe.readUInt8();
      return oe.isError(pe) ? pe : { unused: pe, data: oe.raw() };
    }
    if (ce === "bmpstr") {
      var ke = oe.raw();
      if (ke.length % 2 == 1) return oe.error("Decoding of string type: bmpstr length mismatch");
      for (var ot = "", at = 0; at < ke.length / 2; at++) ot += String.fromCharCode(ke.readUInt16BE(2 * at));
      return ot;
    }
    if (ce === "numstr") {
      var ft = oe.raw().toString("ascii");
      return this._isNumstr(ft) ? ft : oe.error("Decoding of string type: numstr unsupported characters");
    }
    if (ce === "octstr" || ce === "objDesc") return oe.raw();
    if (ce === "printstr") {
      var dt = oe.raw().toString("ascii");
      return this._isPrintstr(dt) ? dt : oe.error("Decoding of string type: printstr unsupported characters");
    }
    return /str$/.test(ce) ? oe.raw().toString() : oe.error("Decoding of string type: " + ce + " unsupported");
  }, re.prototype._decodeObjid = function(oe, ce, pe) {
    for (var ke, ot = [], at = 0; !oe.isEmpty(); ) {
      var ft = oe.readUInt8();
      at <<= 7, at |= 127 & ft, 128 & ft || (ot.push(at), at = 0);
    }
    128 & ft && ot.push(at);
    var dt = ot[0] / 40 | 0, lt = ot[0] % 40;
    if (ke = pe ? ot : [dt, lt].concat(ot.slice(1)), ce) {
      var yt = ce[ke.join(" ")];
      yt === void 0 && (yt = ce[ke.join(".")]), yt !== void 0 && (ke = yt);
    }
    return ke;
  }, re.prototype._decodeTime = function(oe, ce) {
    var pe = oe.raw().toString();
    if (ce === "gentime") var ke = 0 | pe.slice(0, 4), ot = 0 | pe.slice(4, 6), at = 0 | pe.slice(6, 8), ft = 0 | pe.slice(8, 10), dt = 0 | pe.slice(10, 12), lt = 0 | pe.slice(12, 14);
    else {
      if (ce !== "utctime") return oe.error("Decoding " + ce + " time is not supported yet");
      ke = 0 | pe.slice(0, 2), ot = 0 | pe.slice(2, 4), at = 0 | pe.slice(4, 6), ft = 0 | pe.slice(6, 8), dt = 0 | pe.slice(8, 10), lt = 0 | pe.slice(10, 12), ke = ke < 70 ? 2e3 + ke : 1900 + ke;
    }
    return Date.UTC(ke, ot - 1, at, ft, dt, lt, 0);
  }, re.prototype._decodeNull = function(oe) {
    return null;
  }, re.prototype._decodeBool = function(oe) {
    var ce = oe.readUInt8();
    return oe.isError(ce) ? ce : ce !== 0;
  }, re.prototype._decodeInt = function(oe, ce) {
    var pe = oe.raw(), ke = new W(pe);
    return ce && (ke = ce[ke.toString(10)] || ke), ke;
  }, re.prototype._use = function(oe, ce) {
    return typeof oe == "function" && (oe = oe(ce)), oe._getDecoder("der").tree;
  }, der_1$1;
}
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = requireInherits_browser(), L = require$$1$2.Buffer, K = requireDer$1();
  function W(V) {
    K.call(this, V), this.enc = "pem";
  }
  return B(W, K), pem$1 = W, W.prototype.decode = function(V, J) {
    for (var re = V.toString().split(/[\r\n]+/g), ie = J.label.toUpperCase(), ne = /^-----(BEGIN|END) ([^-]+)-----$/, oe = -1, ce = -1, pe = 0; pe < re.length; pe++) {
      var ke = re[pe].match(ne);
      if (ke !== null && ke[2] === ie) {
        if (oe !== -1) {
          if (ke[1] !== "END") break;
          ce = pe;
          break;
        }
        if (ke[1] !== "BEGIN") break;
        oe = pe;
      }
    }
    if (oe === -1 || ce === -1) throw new Error("PEM section not found for: " + ie);
    var ot = re.slice(oe + 1, ce).join("");
    ot.replace(/[^a-z0-9\+\/=]+/gi, "");
    var at = new L(ot, "base64");
    return K.prototype.decode.call(this, at, J);
  }, pem$1;
}
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var L = B;
    L.der = requireDer$1(), L.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer, pem, hasRequiredPem, hasRequiredEncoders, hasRequiredAsn1$1, certificate, hasRequiredCertificate, hasRequiredAsn1;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = requireInherits_browser(), L = require$$1$2.Buffer, K = requireAsn1$1(), W = K.base, V = K.constants.der;
  function J(ne) {
    this.enc = "der", this.name = ne.name, this.entity = ne, this.tree = new re(), this.tree._init(ne.body);
  }
  function re(ne) {
    W.Node.call(this, "der", ne);
  }
  function ie(ne) {
    return ne < 10 ? "0" + ne : ne;
  }
  return der_1 = J, J.prototype.encode = function(ne, oe) {
    return this.tree._encode(ne, oe).join();
  }, B(re, W.Node), re.prototype._encodeComposite = function(ne, oe, ce, pe) {
    var ke, ot = function(lt, yt, St, mt) {
      var $t;
      if (lt === "seqof" ? lt = "seq" : lt === "setof" && (lt = "set"), V.tagByName.hasOwnProperty(lt)) $t = V.tagByName[lt];
      else {
        if (typeof lt != "number" || (0 | lt) !== lt) return mt.error("Unknown tag: " + lt);
        $t = lt;
      }
      return $t >= 31 ? mt.error("Multi-octet tag encoding unsupported") : (yt || ($t |= 32), $t |= V.tagClassByName[St || "universal"] << 6);
    }(ne, oe, ce, this.reporter);
    if (pe.length < 128) return (ke = new L(2))[0] = ot, ke[1] = pe.length, this._createEncoderBuffer([ke, pe]);
    for (var at = 1, ft = pe.length; ft >= 256; ft >>= 8) at++;
    (ke = new L(2 + at))[0] = ot, ke[1] = 128 | at, ft = 1 + at;
    for (var dt = pe.length; dt > 0; ft--, dt >>= 8) ke[ft] = 255 & dt;
    return this._createEncoderBuffer([ke, pe]);
  }, re.prototype._encodeStr = function(ne, oe) {
    if (oe === "bitstr") return this._createEncoderBuffer([0 | ne.unused, ne.data]);
    if (oe === "bmpstr") {
      for (var ce = new L(2 * ne.length), pe = 0; pe < ne.length; pe++) ce.writeUInt16BE(ne.charCodeAt(pe), 2 * pe);
      return this._createEncoderBuffer(ce);
    }
    return oe === "numstr" ? this._isNumstr(ne) ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : oe === "printstr" ? this._isPrintstr(ne) ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(oe) || oe === "objDesc" ? this._createEncoderBuffer(ne) : this.reporter.error("Encoding of string type: " + oe + " unsupported");
  }, re.prototype._encodeObjid = function(ne, oe, ce) {
    if (typeof ne == "string") {
      if (!oe) return this.reporter.error("string objid given, but no values map found");
      if (!oe.hasOwnProperty(ne)) return this.reporter.error("objid not found in values map");
      ne = oe[ne].split(/[\s\.]+/g);
      for (var pe = 0; pe < ne.length; pe++) ne[pe] |= 0;
    } else if (Array.isArray(ne)) for (ne = ne.slice(), pe = 0; pe < ne.length; pe++) ne[pe] |= 0;
    if (!Array.isArray(ne)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(ne));
    if (!ce) {
      if (ne[1] >= 40) return this.reporter.error("Second objid identifier OOB");
      ne.splice(0, 2, 40 * ne[0] + ne[1]);
    }
    var ke = 0;
    for (pe = 0; pe < ne.length; pe++) {
      var ot = ne[pe];
      for (ke++; ot >= 128; ot >>= 7) ke++;
    }
    var at = new L(ke), ft = at.length - 1;
    for (pe = ne.length - 1; pe >= 0; pe--) for (ot = ne[pe], at[ft--] = 127 & ot; (ot >>= 7) > 0; ) at[ft--] = 128 | 127 & ot;
    return this._createEncoderBuffer(at);
  }, re.prototype._encodeTime = function(ne, oe) {
    var ce, pe = new Date(ne);
    return oe === "gentime" ? ce = [ie(pe.getFullYear()), ie(pe.getUTCMonth() + 1), ie(pe.getUTCDate()), ie(pe.getUTCHours()), ie(pe.getUTCMinutes()), ie(pe.getUTCSeconds()), "Z"].join("") : oe === "utctime" ? ce = [ie(pe.getFullYear() % 100), ie(pe.getUTCMonth() + 1), ie(pe.getUTCDate()), ie(pe.getUTCHours()), ie(pe.getUTCMinutes()), ie(pe.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + oe + " time is not supported yet"), this._encodeStr(ce, "octstr");
  }, re.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, re.prototype._encodeInt = function(ne, oe) {
    if (typeof ne == "string") {
      if (!oe) return this.reporter.error("String int or enum given, but no values map");
      if (!oe.hasOwnProperty(ne)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(ne));
      ne = oe[ne];
    }
    if (typeof ne != "number" && !L.isBuffer(ne)) {
      var ce = ne.toArray();
      !ne.sign && 128 & ce[0] && ce.unshift(0), ne = new L(ce);
    }
    if (L.isBuffer(ne)) {
      var pe = ne.length;
      ne.length === 0 && pe++;
      var ke = new L(pe);
      return ne.copy(ke), ne.length === 0 && (ke[0] = 0), this._createEncoderBuffer(ke);
    }
    if (ne < 128) return this._createEncoderBuffer(ne);
    if (ne < 256) return this._createEncoderBuffer([0, ne]);
    pe = 1;
    for (var ot = ne; ot >= 256; ot >>= 8) pe++;
    for (ot = (ke = new Array(pe)).length - 1; ot >= 0; ot--) ke[ot] = 255 & ne, ne >>= 8;
    return 128 & ke[0] && ke.unshift(0), this._createEncoderBuffer(new L(ke));
  }, re.prototype._encodeBool = function(ne) {
    return this._createEncoderBuffer(ne ? 255 : 0);
  }, re.prototype._use = function(ne, oe) {
    return typeof ne == "function" && (ne = ne(oe)), ne._getEncoder("der").tree;
  }, re.prototype._skipDefault = function(ne, oe, ce) {
    var pe, ke = this._baseState;
    if (ke.default === null) return !1;
    var ot = ne.join();
    if (ke.defaultBuffer === void 0 && (ke.defaultBuffer = this._encodeValue(ke.default, oe, ce).join()), ot.length !== ke.defaultBuffer.length) return !1;
    for (pe = 0; pe < ot.length; pe++) if (ot[pe] !== ke.defaultBuffer[pe]) return !1;
    return !0;
  }, der_1;
}
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = requireInherits_browser(), L = requireDer();
  function K(W) {
    L.call(this, W), this.enc = "pem";
  }
  return B(K, L), pem = K, K.prototype.encode = function(W, V) {
    for (var J = L.prototype.encode.call(this, W).toString("base64"), re = ["-----BEGIN " + V.label + "-----"], ie = 0; ie < J.length; ie += 64) re.push(J.slice(ie, ie + 64));
    return re.push("-----END " + V.label + "-----"), re.join(`
`);
  }, pem;
}
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var L = B;
    L.der = requireDer(), L.pem = requirePem();
  }(encoders)), encoders;
}
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(B) {
    var L = B;
    L.bignum = requireBn$1(), L.define = requireApi().define, L.base = requireBase(), L.constants = requireConstants(), L.decoders = requireDecoders(), L.encoders = requireEncoders();
  }(asn1)), asn1;
}
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var B = requireAsn1$1(), L = B.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), K = B.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), W = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), V = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(W), this.key("subjectPublicKey").bitstr());
  }), J = B.define("RelativeDistinguishedName", function() {
    this.setof(K);
  }), re = B.define("RDNSequence", function() {
    this.seqof(J);
  }), ie = B.define("Name", function() {
    this.choice({ rdnSequence: this.use(re) });
  }), ne = B.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(L), this.key("notAfter").use(L));
  }), oe = B.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
  }), ce = B.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(W), this.key("issuer").use(ie), this.key("validity").use(ne), this.key("subject").use(ie), this.key("subjectPublicKeyInfo").use(V), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(oe).optional());
  }), pe = B.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(ce), this.key("signatureAlgorithm").use(W), this.key("signatureValue").bitstr());
  });
  return certificate = pe;
}
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var B = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var L = B.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  asn1$1.RSAPrivateKey = L;
  var K = B.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  asn1$1.RSAPublicKey = K;
  var W = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), V = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(W), this.key("subjectPublicKey").bitstr());
  });
  asn1$1.PublicKey = V;
  var J = B.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(W), this.key("subjectPrivateKey").octstr());
  });
  asn1$1.PrivateKey = J;
  var re = B.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  asn1$1.EncryptedPrivateKey = re;
  var ie = B.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  asn1$1.DSAPrivateKey = ie, asn1$1.DSAparam = B.define("DSAparam", function() {
    this.int();
  });
  var ne = B.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  }), oe = B.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ne), this.key("publicKey").optional().explicit(1).bitstr());
  });
  return asn1$1.ECPrivateKey = oe, asn1$1.signature = B.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  }), asn1$1;
}
const require$$1 = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
var fixProc, hasRequiredFixProc, parseAsn1, hasRequiredParseAsn1;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var B = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, L = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, K = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, W = requireEvp_bytestokey(), V = requireBrowser$6(), J = safeBufferExports.Buffer;
  return fixProc = function(re, ie) {
    var ne, oe = re.toString(), ce = oe.match(B);
    if (ce) {
      var pe = "aes" + ce[1], ke = J.from(ce[2], "hex"), ot = J.from(ce[3].replace(/[\r\n]/g, ""), "base64"), at = W(ie, ke.slice(0, 8), parseInt(ce[1], 10)).key, ft = [], dt = V.createDecipheriv(pe, at, ke);
      ft.push(dt.update(ot)), ft.push(dt.final()), ne = J.concat(ft);
    } else {
      var lt = oe.match(K);
      ne = J.from(lt[2].replace(/[\r\n]/g, ""), "base64");
    }
    return { tag: oe.match(L)[1], data: ne };
  }, fixProc;
}
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var B = requireAsn1(), L = require$$1, K = requireFixProc(), W = requireBrowser$6(), V = requireBrowser$7(), J = safeBufferExports.Buffer;
  function re(ie) {
    var ne;
    typeof ie != "object" || J.isBuffer(ie) || (ne = ie.passphrase, ie = ie.key), typeof ie == "string" && (ie = J.from(ie));
    var oe, ce, pe = K(ie, ne), ke = pe.tag, ot = pe.data;
    switch (ke) {
      case "CERTIFICATE":
        ce = B.certificate.decode(ot, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (ce || (ce = B.PublicKey.decode(ot, "der")), oe = ce.algorithm.algorithm.join(".")) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPublicKey.decode(ce.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return ce.subjectPrivateKey = ce.subjectPublicKey, { type: "ec", data: ce };
          case "1.2.840.10040.4.1":
            return ce.algorithm.params.pub_key = B.DSAparam.decode(ce.subjectPublicKey.data, "der"), { type: "dsa", data: ce.algorithm.params };
          default:
            throw new Error("unknown key id " + oe);
        }
      case "ENCRYPTED PRIVATE KEY":
        ot = function(at, ft) {
          var dt = at.algorithm.decrypt.kde.kdeparams.salt, lt = parseInt(at.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), yt = L[at.algorithm.decrypt.cipher.algo.join(".")], St = at.algorithm.decrypt.cipher.iv, mt = at.subjectPrivateKey, $t = parseInt(yt.split("-")[1], 10) / 8, It = V.pbkdf2Sync(ft, dt, lt, $t, "sha1"), Ut = W.createDecipheriv(yt, It, St), ut = [];
          return ut.push(Ut.update(mt)), ut.push(Ut.final()), J.concat(ut);
        }(ot = B.EncryptedPrivateKey.decode(ot, "der"), ne);
      case "PRIVATE KEY":
        switch (oe = (ce = B.PrivateKey.decode(ot, "der")).algorithm.algorithm.join(".")) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPrivateKey.decode(ce.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: ce.algorithm.curve, privateKey: B.ECPrivateKey.decode(ce.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return ce.algorithm.params.priv_key = B.DSAparam.decode(ce.subjectPrivateKey, "der"), { type: "dsa", params: ce.algorithm.params };
          default:
            throw new Error("unknown key id " + oe);
        }
      case "RSA PUBLIC KEY":
        return B.RSAPublicKey.decode(ot, "der");
      case "RSA PRIVATE KEY":
        return B.RSAPrivateKey.decode(ot, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: B.DSAPrivateKey.decode(ot, "der") };
      case "EC PRIVATE KEY":
        return { curve: (ot = B.ECPrivateKey.decode(ot, "der")).parameters.value, privateKey: ot.privateKey };
      default:
        throw new Error("unknown key type " + ke);
    }
  }
  return re.signature = B.signature, parseAsn1 = re;
}
const require$$4 = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
var hasRequiredSign, verify_1$1, hasRequiredVerify, browser$3, hasRequiredBrowser$3, browser$2, hasRequiredBrowser$2;
function requireSign() {
  if (hasRequiredSign) return sign$1.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports.Buffer, L = requireBrowser$8(), K = requireBrowserifyRsa(), W = requireElliptic().ec, V = requireBn(), J = requireParseAsn1(), re = require$$4;
  function ie(pe, ke, ot, at) {
    if ((pe = B.from(pe.toArray())).length < ke.byteLength()) {
      var ft = B.alloc(ke.byteLength() - pe.length);
      pe = B.concat([ft, pe]);
    }
    var dt = ot.length, lt = function(mt, $t) {
      mt = (mt = ne(mt, $t)).mod($t);
      var It = B.from(mt.toArray());
      if (It.length < $t.byteLength()) {
        var Ut = B.alloc($t.byteLength() - It.length);
        It = B.concat([Ut, It]);
      }
      return It;
    }(ot, ke), yt = B.alloc(dt);
    yt.fill(1);
    var St = B.alloc(dt);
    return St = L(at, St).update(yt).update(B.from([0])).update(pe).update(lt).digest(), yt = L(at, St).update(yt).digest(), { k: St = L(at, St).update(yt).update(B.from([1])).update(pe).update(lt).digest(), v: yt = L(at, St).update(yt).digest() };
  }
  function ne(pe, ke) {
    var ot = new V(pe), at = (pe.length << 3) - ke.bitLength();
    return at > 0 && ot.ishrn(at), ot;
  }
  function oe(pe, ke, ot) {
    var at, ft;
    do {
      for (at = B.alloc(0); 8 * at.length < pe.bitLength(); ) ke.v = L(ot, ke.k).update(ke.v).digest(), at = B.concat([at, ke.v]);
      ft = ne(at, pe), ke.k = L(ot, ke.k).update(ke.v).update(B.from([0])).digest(), ke.v = L(ot, ke.k).update(ke.v).digest();
    } while (ft.cmp(pe) !== -1);
    return ft;
  }
  function ce(pe, ke, ot, at) {
    return pe.toRed(V.mont(ot)).redPow(ke).fromRed().mod(at);
  }
  return sign$1.exports = function(pe, ke, ot, at, ft) {
    var dt = J(ke);
    if (dt.curve) {
      if (at !== "ecdsa" && at !== "ecdsa/rsa") throw new Error("wrong private key type");
      return function(mt, $t) {
        var It = re[$t.curve.join(".")];
        if (!It) throw new Error("unknown curve " + $t.curve.join("."));
        var Ut = new W(It).keyFromPrivate($t.privateKey).sign(mt);
        return B.from(Ut.toDER());
      }(pe, dt);
    }
    if (dt.type === "dsa") {
      if (at !== "dsa") throw new Error("wrong private key type");
      return function(mt, $t, It) {
        for (var Ut, ut = $t.params.priv_key, ht = $t.params.p, Ce = $t.params.q, nt = $t.params.g, rt = new V(0), it = ne(mt, Ce).mod(Ce), st = !1, Oe = ie(ut, Ce, mt, It); st === !1; ) rt = ce(nt, Ut = oe(Ce, Oe, It), ht, Ce), (st = Ut.invm(Ce).imul(it.add(ut.mul(rt))).mod(Ce)).cmpn(0) === 0 && (st = !1, rt = new V(0));
        return function(ct, pt) {
          ct = ct.toArray(), pt = pt.toArray(), 128 & ct[0] && (ct = [0].concat(ct)), 128 & pt[0] && (pt = [0].concat(pt));
          var gt = [48, ct.length + pt.length + 4, 2, ct.length];
          return gt = gt.concat(ct, [2, pt.length], pt), B.from(gt);
        }(rt, st);
      }(pe, dt, ot);
    }
    if (at !== "rsa" && at !== "ecdsa/rsa") throw new Error("wrong private key type");
    if (ke.padding !== void 0 && ke.padding !== 1) throw new Error("illegal or unsupported padding mode");
    pe = B.concat([ft, pe]);
    for (var lt = dt.modulus.byteLength(), yt = [0, 1]; pe.length + yt.length + 1 < lt; ) yt.push(255);
    yt.push(0);
    for (var St = -1; ++St < pe.length; ) yt.push(pe[St]);
    return K(yt, dt);
  }, sign$1.exports.getKey = ie, sign$1.exports.makeKey = oe, sign$1.exports;
}
function requireVerify() {
  if (hasRequiredVerify) return verify_1$1;
  hasRequiredVerify = 1;
  var B = safeBufferExports.Buffer, L = requireBn(), K = requireElliptic().ec, W = requireParseAsn1(), V = require$$4;
  function J(re, ie) {
    if (re.cmpn(0) <= 0) throw new Error("invalid sig");
    if (re.cmp(ie) >= 0) throw new Error("invalid sig");
  }
  return verify_1$1 = function(re, ie, ne, oe, ce) {
    var pe = W(ne);
    if (pe.type === "ec") {
      if (oe !== "ecdsa" && oe !== "ecdsa/rsa") throw new Error("wrong public key type");
      return function(yt, St, mt) {
        var $t = V[mt.data.algorithm.curve.join(".")];
        if (!$t) throw new Error("unknown curve " + mt.data.algorithm.curve.join("."));
        var It = new K($t), Ut = mt.data.subjectPrivateKey.data;
        return It.verify(St, yt, Ut);
      }(re, ie, pe);
    }
    if (pe.type === "dsa") {
      if (oe !== "dsa") throw new Error("wrong public key type");
      return function(yt, St, mt) {
        var $t = mt.data.p, It = mt.data.q, Ut = mt.data.g, ut = mt.data.pub_key, ht = W.signature.decode(yt, "der"), Ce = ht.s, nt = ht.r;
        J(Ce, It), J(nt, It);
        var rt = L.mont($t), it = Ce.invm(It);
        return Ut.toRed(rt).redPow(new L(St).mul(it).mod(It)).fromRed().mul(ut.toRed(rt).redPow(nt.mul(it).mod(It)).fromRed()).mod($t).mod(It).cmp(nt) === 0;
      }(re, ie, pe);
    }
    if (oe !== "rsa" && oe !== "ecdsa/rsa") throw new Error("wrong public key type");
    ie = B.concat([ce, ie]);
    for (var ke = pe.modulus.byteLength(), ot = [1], at = 0; ie.length + ot.length + 2 < ke; ) ot.push(255), at += 1;
    ot.push(0);
    for (var ft = -1; ++ft < ie.length; ) ot.push(ie[ft]);
    ot = B.from(ot);
    var dt = L.mont(pe.modulus);
    re = (re = new L(re).toRed(dt)).redPow(new L(pe.publicExponent)), re = B.from(re.fromRed().toArray());
    var lt = at < 8 ? 1 : 0;
    for (ke = Math.min(re.length, ot.length), re.length !== ot.length && (lt = 1), ft = -1; ++ft < ke; ) lt |= re[ft] ^ ot[ft];
    return lt === 0;
  }, verify_1$1;
}
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var B = safeBufferExports.Buffer, L = requireBrowser$9(), K = requireReadableBrowser(), W = requireInherits_browser(), V = requireSign(), J = requireVerify(), re = require$$6;
  function ie(pe) {
    K.Writable.call(this);
    var ke = re[pe];
    if (!ke) throw new Error("Unknown message digest");
    this._hashType = ke.hash, this._hash = L(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  function ne(pe) {
    K.Writable.call(this);
    var ke = re[pe];
    if (!ke) throw new Error("Unknown message digest");
    this._hash = L(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  function oe(pe) {
    return new ie(pe);
  }
  function ce(pe) {
    return new ne(pe);
  }
  return Object.keys(re).forEach(function(pe) {
    re[pe].id = B.from(re[pe].id, "hex"), re[pe.toLowerCase()] = re[pe];
  }), W(ie, K.Writable), ie.prototype._write = function(pe, ke, ot) {
    this._hash.update(pe), ot();
  }, ie.prototype.update = function(pe, ke) {
    return this._hash.update(typeof pe == "string" ? B.from(pe, ke) : pe), this;
  }, ie.prototype.sign = function(pe, ke) {
    this.end();
    var ot = this._hash.digest(), at = V(ot, pe, this._hashType, this._signType, this._tag);
    return ke ? at.toString(ke) : at;
  }, W(ne, K.Writable), ne.prototype._write = function(pe, ke, ot) {
    this._hash.update(pe), ot();
  }, ne.prototype.update = function(pe, ke) {
    return this._hash.update(typeof pe == "string" ? B.from(pe, ke) : pe), this;
  }, ne.prototype.verify = function(pe, ke, ot) {
    var at = typeof ke == "string" ? B.from(ke, ot) : ke;
    this.end();
    var ft = this._hash.digest();
    return J(at, ft, pe, this._signType, this._tag);
  }, browser$3 = { Sign: oe, Verify: ce, createSign: oe, createVerify: ce };
}
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var B = requireElliptic(), L = requireBn$1();
  browser$2 = function(J) {
    return new W(J);
  };
  var K = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  function W(J) {
    this.curveType = K[J], this.curveType || (this.curveType = { name: J }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  function V(J, re, ie) {
    Array.isArray(J) || (J = J.toArray());
    var ne = new Buffer$3(J);
    if (ie && ne.length < ie) {
      var oe = new Buffer$3(ie - ne.length);
      oe.fill(0), ne = Buffer$3.concat([oe, ne]);
    }
    return re ? ne.toString(re) : ne;
  }
  return K.p224 = K.secp224r1, K.p256 = K.secp256r1 = K.prime256v1, K.p192 = K.secp192r1 = K.prime192v1, K.p384 = K.secp384r1, K.p521 = K.secp521r1, W.prototype.generateKeys = function(J, re) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(J, re);
  }, W.prototype.computeSecret = function(J, re, ie) {
    return re = re || "utf8", Buffer$3.isBuffer(J) || (J = new Buffer$3(J, re)), V(this.curve.keyFromPublic(J).getPublic().mul(this.keys.getPrivate()).getX(), ie, this.curveType.byteLength);
  }, W.prototype.getPublicKey = function(J, re) {
    var ie = this.keys.getPublic(re === "compressed", !0);
    return re === "hybrid" && (ie[ie.length - 1] % 2 ? ie[0] = 7 : ie[0] = 6), V(ie, J);
  }, W.prototype.getPrivateKey = function(J) {
    return V(this.keys.getPrivate(), J);
  }, W.prototype.setPublicKey = function(J, re) {
    return re = re || "utf8", Buffer$3.isBuffer(J) || (J = new Buffer$3(J, re)), this.keys._importPublic(J), this;
  }, W.prototype.setPrivateKey = function(J, re) {
    re = re || "utf8", Buffer$3.isBuffer(J) || (J = new Buffer$3(J, re));
    var ie = new L(J);
    return ie = ie.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ie), this;
  }, browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf, xor, hasRequiredXor, withPublic_1, hasRequiredWithPublic, publicEncrypt, hasRequiredPublicEncrypt, privateDecrypt, hasRequiredPrivateDecrypt, hasRequiredBrowser$1;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var B = requireBrowser$9(), L = safeBufferExports.Buffer;
  function K(W) {
    var V = L.allocUnsafe(4);
    return V.writeUInt32BE(W, 0), V;
  }
  return mgf = function(W, V) {
    for (var J, re = L.alloc(0), ie = 0; re.length < V; ) J = K(ie++), re = L.concat([re, B("sha1").update(W).update(J).digest()]);
    return re.slice(0, V);
  }, mgf;
}
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(B, L) {
    for (var K = B.length, W = -1; ++W < K; ) B[W] ^= L[W];
    return B;
  }), xor;
}
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var B = requireBn$1(), L = safeBufferExports.Buffer;
  return withPublic_1 = function(K, W) {
    return L.from(K.toRed(B.mont(W.modulus)).redPow(new B(W.publicExponent)).fromRed().toArray());
  }, withPublic_1;
}
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var B = requireParseAsn1(), L = browserExports, K = requireBrowser$9(), W = requireMgf(), V = requireXor(), J = requireBn$1(), re = requireWithPublic(), ie = requireBrowserifyRsa(), ne = safeBufferExports.Buffer;
  return publicEncrypt = function(oe, ce, pe) {
    var ke;
    ke = oe.padding ? oe.padding : pe ? 1 : 4;
    var ot, at = B(oe);
    if (ke === 4) ot = function(ft, dt) {
      var lt = ft.modulus.byteLength(), yt = dt.length, St = K("sha1").update(ne.alloc(0)).digest(), mt = St.length, $t = 2 * mt;
      if (yt > lt - $t - 2) throw new Error("message too long");
      var It = ne.alloc(lt - yt - $t - 2), Ut = lt - mt - 1, ut = L(mt), ht = V(ne.concat([St, It, ne.alloc(1, 1), dt], Ut), W(ut, Ut)), Ce = V(ut, W(ht, mt));
      return new J(ne.concat([ne.alloc(1), Ce, ht], lt));
    }(at, ce);
    else if (ke === 1) ot = function(ft, dt, lt) {
      var yt, St = dt.length, mt = ft.modulus.byteLength();
      if (St > mt - 11) throw new Error("message too long");
      return yt = lt ? ne.alloc(mt - St - 3, 255) : function($t) {
        for (var It, Ut = ne.allocUnsafe($t), ut = 0, ht = L(2 * $t), Ce = 0; ut < $t; ) Ce === ht.length && (ht = L(2 * $t), Ce = 0), (It = ht[Ce++]) && (Ut[ut++] = It);
        return Ut;
      }(mt - St - 3), new J(ne.concat([ne.from([0, lt ? 1 : 2]), yt, ne.alloc(1), dt], mt));
    }(at, ce, pe);
    else {
      if (ke !== 3) throw new Error("unknown padding");
      if ((ot = new J(ce)).cmp(at.modulus) >= 0) throw new Error("data too long for modulus");
    }
    return pe ? ie(ot, at) : re(ot, at);
  }, publicEncrypt;
}
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var B = requireParseAsn1(), L = requireMgf(), K = requireXor(), W = requireBn$1(), V = requireBrowserifyRsa(), J = requireBrowser$9(), re = requireWithPublic(), ie = safeBufferExports.Buffer;
  return privateDecrypt = function(ne, oe, ce) {
    var pe;
    pe = ne.padding ? ne.padding : ce ? 1 : 4;
    var ke, ot = B(ne), at = ot.modulus.byteLength();
    if (oe.length > at || new W(oe).cmp(ot.modulus) >= 0) throw new Error("decryption error");
    ke = ce ? re(new W(oe), ot) : V(oe, ot);
    var ft = ie.alloc(at - ke.length);
    if (ke = ie.concat([ft, ke], at), pe === 4) return function(dt, lt) {
      var yt = dt.modulus.byteLength(), St = J("sha1").update(ie.alloc(0)).digest(), mt = St.length;
      if (lt[0] !== 0) throw new Error("decryption error");
      var $t = lt.slice(1, mt + 1), It = lt.slice(mt + 1), Ut = K($t, L(It, mt)), ut = K(It, L(Ut, yt - mt - 1));
      if (function(Ce, nt) {
        Ce = ie.from(Ce), nt = ie.from(nt);
        var rt = 0, it = Ce.length;
        Ce.length !== nt.length && (rt++, it = Math.min(Ce.length, nt.length));
        for (var st = -1; ++st < it; ) rt += Ce[st] ^ nt[st];
        return rt;
      }(St, ut.slice(0, mt))) throw new Error("decryption error");
      for (var ht = mt; ut[ht] === 0; ) ht++;
      if (ut[ht++] !== 1) throw new Error("decryption error");
      return ut.slice(ht);
    }(ot, ke);
    if (pe === 1) return function(dt, lt, yt) {
      for (var St = lt.slice(0, 2), mt = 2, $t = 0; lt[mt++] !== 0; ) if (mt >= lt.length) {
        $t++;
        break;
      }
      var It = lt.slice(2, mt - 1);
      if ((St.toString("hex") !== "0002" && !yt || St.toString("hex") !== "0001" && yt) && $t++, It.length < 8 && $t++, $t) throw new Error("decryption error");
      return lt.slice(mt);
    }(0, ke, ce);
    if (pe === 3) return ke;
    throw new Error("unknown padding");
  }, privateDecrypt;
}
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(B) {
    B.publicEncrypt = requirePublicEncrypt(), B.privateDecrypt = requirePrivateDecrypt(), B.privateEncrypt = function(L, K) {
      return B.publicEncrypt(L, K, !0);
    }, B.publicDecrypt = function(L, K) {
      return B.privateDecrypt(L, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser, hasRequiredCryptoBrowserify;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  function B() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  hasRequiredBrowser = 1;
  var L = safeBufferExports, K = browserExports, W = L.Buffer, V = L.kMaxLength, J = commonjsGlobal.crypto || commonjsGlobal.msCrypto, re = Math.pow(2, 32) - 1;
  function ie(ce, pe) {
    if (typeof ce != "number" || ce != ce) throw new TypeError("offset must be a number");
    if (ce > re || ce < 0) throw new TypeError("offset must be a uint32");
    if (ce > V || ce > pe) throw new RangeError("offset out of range");
  }
  function ne(ce, pe, ke) {
    if (typeof ce != "number" || ce != ce) throw new TypeError("size must be a number");
    if (ce > re || ce < 0) throw new TypeError("size must be a uint32");
    if (ce + pe > ke || ce > V) throw new RangeError("buffer too small");
  }
  function oe(ce, pe, ke, ot) {
    if (process$1.browser) {
      var at = ce.buffer, ft = new Uint8Array(at, pe, ke);
      return J.getRandomValues(ft), ot ? void process$1.nextTick(function() {
        ot(null, ce);
      }) : ce;
    }
    if (!ot) return K(ke).copy(ce, pe), ce;
    K(ke, function(dt, lt) {
      if (dt) return ot(dt);
      lt.copy(ce, pe), ot(null, ce);
    });
  }
  return J && J.getRandomValues || !process$1.browser ? (browser.randomFill = function(ce, pe, ke, ot) {
    if (!(W.isBuffer(ce) || ce instanceof commonjsGlobal.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof pe == "function") ot = pe, pe = 0, ke = ce.length;
    else if (typeof ke == "function") ot = ke, ke = ce.length - pe;
    else if (typeof ot != "function") throw new TypeError('"cb" argument must be a function');
    return ie(pe, ce.length), ne(ke, pe, ce.length), oe(ce, pe, ke, ot);
  }, browser.randomFillSync = function(ce, pe, ke) {
    if (pe === void 0 && (pe = 0), !(W.isBuffer(ce) || ce instanceof commonjsGlobal.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ie(pe, ce.length), ke === void 0 && (ke = ce.length - pe), ne(ke, pe, ce.length), oe(ce, pe, ke);
  }) : (browser.randomFill = B, browser.randomFillSync = B), browser;
}
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var B = requireAlgos(), L = Object.keys(B), K = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(L);
  cryptoBrowserify.getHashes = function() {
    return K;
  };
  var W = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = W.pbkdf2, cryptoBrowserify.pbkdf2Sync = W.pbkdf2Sync;
  var V = requireBrowser$5();
  cryptoBrowserify.Cipher = V.Cipher, cryptoBrowserify.createCipher = V.createCipher, cryptoBrowserify.Cipheriv = V.Cipheriv, cryptoBrowserify.createCipheriv = V.createCipheriv, cryptoBrowserify.Decipher = V.Decipher, cryptoBrowserify.createDecipher = V.createDecipher, cryptoBrowserify.Decipheriv = V.Decipheriv, cryptoBrowserify.createDecipheriv = V.createDecipheriv, cryptoBrowserify.getCiphers = V.getCiphers, cryptoBrowserify.listCiphers = V.listCiphers;
  var J = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = J.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = J.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = J.getDiffieHellman, cryptoBrowserify.createDiffieHellman = J.createDiffieHellman, cryptoBrowserify.DiffieHellman = J.DiffieHellman;
  var re = requireBrowser$3();
  cryptoBrowserify.createSign = re.createSign, cryptoBrowserify.Sign = re.Sign, cryptoBrowserify.createVerify = re.createVerify, cryptoBrowserify.Verify = re.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ie = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ie.publicEncrypt, cryptoBrowserify.privateEncrypt = ie.privateEncrypt, cryptoBrowserify.publicDecrypt = ie.publicDecrypt, cryptoBrowserify.privateDecrypt = ie.privateDecrypt;
  var ne = requireBrowser();
  return cryptoBrowserify.randomFill = ne.randomFill, cryptoBrowserify.randomFillSync = ne.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  }, cryptoBrowserify.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 }, cryptoBrowserify;
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const L = requireCryptoBrowserify(), K = BigInt(0), W = BigInt(1), V = BigInt(2), J = BigInt(3), re = BigInt(8), ie = Object.freeze({ a: K, b: BigInt(7), P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), h: W, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee") });
  B.CURVE = ie;
  const ne = (qt, Pt) => (qt + Pt / V) / Pt, oe = { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar(qt) {
    const { n: Pt } = ie, Ot = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ct = -W * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Lt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Vt = Ot, Jt = BigInt("0x100000000000000000000000000000000"), Gt = ne(Vt * qt, Pt), er = ne(-Ct * qt, Pt);
    let or = kt(qt - Gt * Ot - er * Lt, Pt), tr = kt(-Gt * Ct - er * Vt, Pt);
    const sr = or > Jt, rr = tr > Jt;
    if (sr && (or = Pt - or), rr && (tr = Pt - tr), or > Jt || tr > Jt) throw new Error("splitScalarEndo: Endomorphism failed, k=" + qt);
    return { k1neg: sr, k1: or, k2neg: rr, k2: tr };
  } }, ce = 32, pe = 32, ke = ce + 1, ot = 2 * ce + 1;
  function at(qt) {
    const { a: Pt, b: Ot } = ie, Ct = kt(qt * qt), Lt = kt(Ct * qt);
    return kt(Lt + Pt * qt + Ot);
  }
  const ft = ie.a === K;
  class dt extends Error {
    constructor(Pt) {
      super(Pt);
    }
  }
  function lt(qt) {
    if (!(qt instanceof yt)) throw new TypeError("JacobianPoint expected");
  }
  class yt {
    constructor(Pt, Ot, Ct) {
      this.x = Pt, this.y = Ot, this.z = Ct;
    }
    static fromAffine(Pt) {
      if (!(Pt instanceof $t)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Pt.equals($t.ZERO) ? yt.ZERO : new yt(Pt.x, Pt.y, W);
    }
    static toAffineBatch(Pt) {
      const Ot = function(Ct, Lt = ie.P) {
        const Vt = new Array(Ct.length), Jt = Ct.reduce((er, or, tr) => or === K ? er : (Vt[tr] = er, kt(er * or, Lt)), W), Gt = Et(Jt, Lt);
        return Ct.reduceRight((er, or, tr) => or === K ? er : (Vt[tr] = kt(er * Vt[tr], Lt), kt(er * or, Lt)), Gt), Vt;
      }(Pt.map((Ct) => Ct.z));
      return Pt.map((Ct, Lt) => Ct.toAffine(Ot[Lt]));
    }
    static normalizeZ(Pt) {
      return yt.toAffineBatch(Pt).map(yt.fromAffine);
    }
    equals(Pt) {
      lt(Pt);
      const { x: Ot, y: Ct, z: Lt } = this, { x: Vt, y: Jt, z: Gt } = Pt, er = kt(Lt * Lt), or = kt(Gt * Gt), tr = kt(Ot * or), sr = kt(Vt * er), rr = kt(kt(Ct * Gt) * or), fr = kt(kt(Jt * Lt) * er);
      return tr === sr && rr === fr;
    }
    negate() {
      return new yt(this.x, kt(-this.y), this.z);
    }
    double() {
      const { x: Pt, y: Ot, z: Ct } = this, Lt = kt(Pt * Pt), Vt = kt(Ot * Ot), Jt = kt(Vt * Vt), Gt = Pt + Vt, er = kt(V * (kt(Gt * Gt) - Lt - Jt)), or = kt(J * Lt), tr = kt(or * or), sr = kt(tr - V * er), rr = kt(or * (er - sr) - re * Jt), fr = kt(V * Ot * Ct);
      return new yt(sr, rr, fr);
    }
    add(Pt) {
      lt(Pt);
      const { x: Ot, y: Ct, z: Lt } = this, { x: Vt, y: Jt, z: Gt } = Pt;
      if (Vt === K || Jt === K) return this;
      if (Ot === K || Ct === K) return Pt;
      const er = kt(Lt * Lt), or = kt(Gt * Gt), tr = kt(Ot * or), sr = kt(Vt * er), rr = kt(kt(Ct * Gt) * or), fr = kt(kt(Jt * Lt) * er), dr = kt(sr - tr), Sr = kt(fr - rr);
      if (dr === K) return Sr === K ? this.double() : yt.ZERO;
      const br = kt(dr * dr), Er = kt(dr * br), $r = kt(tr * br), yr = kt(Sr * Sr - Er - V * $r), kr = kt(Sr * ($r - yr) - rr * Er), Tr = kt(Lt * Gt * dr);
      return new yt(yr, kr, Tr);
    }
    subtract(Pt) {
      return this.add(Pt.negate());
    }
    multiplyUnsafe(Pt) {
      const Ot = yt.ZERO;
      if (typeof Pt == "bigint" && Pt === K) return Ot;
      let Ct = Bt(Pt);
      if (Ct === W) return this;
      if (!ft) {
        let sr = Ot, rr = this;
        for (; Ct > K; ) Ct & W && (sr = sr.add(rr)), rr = rr.double(), Ct >>= W;
        return sr;
      }
      let { k1neg: Lt, k1: Vt, k2neg: Jt, k2: Gt } = oe.splitScalar(Ct), er = Ot, or = Ot, tr = this;
      for (; Vt > K || Gt > K; ) Vt & W && (er = er.add(tr)), Gt & W && (or = or.add(tr)), tr = tr.double(), Vt >>= W, Gt >>= W;
      return Lt && (er = er.negate()), Jt && (or = or.negate()), or = new yt(kt(or.x * oe.beta), or.y, or.z), er.add(or);
    }
    precomputeWindow(Pt) {
      const Ot = ft ? 128 / Pt + 1 : 256 / Pt + 1, Ct = [];
      let Lt = this, Vt = Lt;
      for (let Jt = 0; Jt < Ot; Jt++) {
        Vt = Lt, Ct.push(Vt);
        for (let Gt = 1; Gt < 2 ** (Pt - 1); Gt++) Vt = Vt.add(Lt), Ct.push(Vt);
        Lt = Vt.double();
      }
      return Ct;
    }
    wNAF(Pt, Ot) {
      !Ot && this.equals(yt.BASE) && (Ot = $t.BASE);
      const Ct = Ot && Ot._WINDOW_SIZE || 1;
      if (256 % Ct) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Lt = Ot && mt.get(Ot);
      Lt || (Lt = this.precomputeWindow(Ct), Ot && Ct !== 1 && (Lt = yt.normalizeZ(Lt), mt.set(Ot, Lt)));
      let Vt = yt.ZERO, Jt = yt.BASE;
      const Gt = 1 + (ft ? 128 / Ct : 256 / Ct), er = 2 ** (Ct - 1), or = BigInt(2 ** Ct - 1), tr = 2 ** Ct, sr = BigInt(Ct);
      for (let rr = 0; rr < Gt; rr++) {
        const fr = rr * er;
        let dr = Number(Pt & or);
        Pt >>= sr, dr > er && (dr -= tr, Pt += W);
        const Sr = fr, br = fr + Math.abs(dr) - 1, Er = rr % 2 != 0, $r = dr < 0;
        dr === 0 ? Jt = Jt.add(St(Er, Lt[Sr])) : Vt = Vt.add(St($r, Lt[br]));
      }
      return { p: Vt, f: Jt };
    }
    multiply(Pt, Ot) {
      let Ct, Lt, Vt = Bt(Pt);
      if (ft) {
        const { k1neg: Jt, k1: Gt, k2neg: er, k2: or } = oe.splitScalar(Vt);
        let { p: tr, f: sr } = this.wNAF(Gt, Ot), { p: rr, f: fr } = this.wNAF(or, Ot);
        tr = St(Jt, tr), rr = St(er, rr), rr = new yt(kt(rr.x * oe.beta), rr.y, rr.z), Ct = tr.add(rr), Lt = sr.add(fr);
      } else {
        const { p: Jt, f: Gt } = this.wNAF(Vt, Ot);
        Ct = Jt, Lt = Gt;
      }
      return yt.normalizeZ([Ct, Lt])[0];
    }
    toAffine(Pt) {
      const { x: Ot, y: Ct, z: Lt } = this, Vt = this.equals(yt.ZERO);
      Pt == null && (Pt = Vt ? re : Et(Lt));
      const Jt = Pt, Gt = kt(Jt * Jt), er = kt(Gt * Jt), or = kt(Ot * Gt), tr = kt(Ct * er), sr = kt(Lt * Jt);
      if (Vt) return $t.ZERO;
      if (sr !== W) throw new Error("invZ was invalid");
      return new $t(or, tr);
    }
  }
  function St(qt, Pt) {
    const Ot = Pt.negate();
    return qt ? Ot : Pt;
  }
  yt.BASE = new yt(ie.Gx, ie.Gy, W), yt.ZERO = new yt(K, W, K);
  const mt = /* @__PURE__ */ new WeakMap();
  class $t {
    constructor(Pt, Ot) {
      this.x = Pt, this.y = Ot;
    }
    _setWindowSize(Pt) {
      this._WINDOW_SIZE = Pt, mt.delete(this);
    }
    hasEvenY() {
      return this.y % V === K;
    }
    static fromCompressedHex(Pt) {
      const Ot = Pt.length === 32, Ct = gt(Ot ? Pt : Pt.subarray(1));
      if (!Wt(Ct)) throw new Error("Point is not on curve");
      let Lt = function(Gt) {
        const { P: er } = ie, or = BigInt(6), tr = BigInt(11), sr = BigInt(22), rr = BigInt(23), fr = BigInt(44), dr = BigInt(88), Sr = Gt * Gt * Gt % er, br = Sr * Sr * Gt % er, Er = wt(br, J) * br % er, $r = wt(Er, J) * br % er, yr = wt($r, V) * Sr % er, kr = wt(yr, tr) * yr % er, Tr = wt(kr, sr) * kr % er, gr = wt(Tr, fr) * Tr % er, _r = wt(gr, dr) * gr % er, Ar = wt(_r, fr) * Tr % er, wr = wt(Ar, J) * br % er, Rr = wt(wr, rr) * kr % er, Ir = wt(Rr, or) * Sr % er, Br = wt(Ir, V);
        if (Br * Br % er !== Gt) throw new Error("Cannot find square root");
        return Br;
      }(at(Ct));
      const Vt = (Lt & W) === W;
      Ot ? Vt && (Lt = kt(-Lt)) : !(1 & ~Pt[0]) !== Vt && (Lt = kt(-Lt));
      const Jt = new $t(Ct, Lt);
      return Jt.assertValidity(), Jt;
    }
    static fromUncompressedHex(Pt) {
      const Ot = gt(Pt.subarray(1, ce + 1)), Ct = gt(Pt.subarray(ce + 1, 2 * ce + 1)), Lt = new $t(Ot, Ct);
      return Lt.assertValidity(), Lt;
    }
    static fromHex(Pt) {
      const Ot = vt(Pt), Ct = Ot.length, Lt = Ot[0];
      if (Ct === ce) return this.fromCompressedHex(Ot);
      if (Ct === ke && (Lt === 2 || Lt === 3)) return this.fromCompressedHex(Ot);
      if (Ct === ot && Lt === 4) return this.fromUncompressedHex(Ot);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${ke} compressed bytes or ${ot} uncompressed bytes, not ${Ct}`);
    }
    static fromPrivateKey(Pt) {
      return $t.BASE.multiply(Xt(Pt));
    }
    static fromSignature(Pt, Ot, Ct) {
      const { r: Lt, s: Vt } = ur(Ot);
      if (![0, 1, 2, 3].includes(Ct)) throw new Error("Cannot recover: invalid recovery bit");
      const Jt = Rt(vt(Pt)), { n: Gt } = ie, er = Ct === 2 || Ct === 3 ? Lt + Gt : Lt, or = Et(er, Gt), tr = kt(-Jt * or, Gt), sr = kt(Vt * or, Gt), rr = 1 & Ct ? "03" : "02", fr = $t.fromHex(rr + it(er)), dr = $t.BASE.multiplyAndAddUnsafe(fr, tr, sr);
      if (!dr) throw new Error("Cannot recover signature: point at infinify");
      return dr.assertValidity(), dr;
    }
    toRawBytes(Pt = !1) {
      return pt(this.toHex(Pt));
    }
    toHex(Pt = !1) {
      const Ot = it(this.x);
      return Pt ? `${this.hasEvenY() ? "02" : "03"}${Ot}` : `04${Ot}${it(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Pt = "Point is not on elliptic curve", { x: Ot, y: Ct } = this;
      if (!Wt(Ot) || !Wt(Ct)) throw new Error(Pt);
      const Lt = kt(Ct * Ct);
      if (kt(Lt - at(Ot)) !== K) throw new Error(Pt);
    }
    equals(Pt) {
      return this.x === Pt.x && this.y === Pt.y;
    }
    negate() {
      return new $t(this.x, kt(-this.y));
    }
    double() {
      return yt.fromAffine(this).double().toAffine();
    }
    add(Pt) {
      return yt.fromAffine(this).add(yt.fromAffine(Pt)).toAffine();
    }
    subtract(Pt) {
      return this.add(Pt.negate());
    }
    multiply(Pt) {
      return yt.fromAffine(this).multiply(Pt, this).toAffine();
    }
    multiplyAndAddUnsafe(Pt, Ot, Ct) {
      const Lt = yt.fromAffine(this), Vt = Ot === K || Ot === W || this !== $t.BASE ? Lt.multiplyUnsafe(Ot) : Lt.multiply(Ot), Jt = yt.fromAffine(Pt).multiplyUnsafe(Ct), Gt = Vt.add(Jt);
      return Gt.equals(yt.ZERO) ? void 0 : Gt.toAffine();
    }
  }
  function It(qt) {
    return Number.parseInt(qt[0], 16) >= 8 ? "00" + qt : qt;
  }
  function Ut(qt) {
    if (qt.length < 2 || qt[0] !== 2) throw new Error(`Invalid signature integer tag: ${nt(qt)}`);
    const Pt = qt[1], Ot = qt.subarray(2, Pt + 2);
    if (!Pt || Ot.length !== Pt) throw new Error("Invalid signature integer: wrong length");
    if (Ot[0] === 0 && Ot[1] <= 127) throw new Error("Invalid signature integer: trailing length");
    return { data: gt(Ot), left: qt.subarray(Pt + 2) };
  }
  B.Point = $t, $t.BASE = new $t(ie.Gx, ie.Gy), $t.ZERO = new $t(K, K);
  class ut {
    constructor(Pt, Ot) {
      this.r = Pt, this.s = Ot, this.assertValidity();
    }
    static fromCompact(Pt) {
      const Ot = Pt instanceof Uint8Array, Ct = "Signature.fromCompact";
      if (typeof Pt != "string" && !Ot) throw new TypeError(`${Ct}: Expected string or Uint8Array`);
      const Lt = Ot ? nt(Pt) : Pt;
      if (Lt.length !== 128) throw new Error(`${Ct}: Expected 64-byte hex`);
      return new ut(ct(Lt.slice(0, 64)), ct(Lt.slice(64, 128)));
    }
    static fromDER(Pt) {
      const Ot = Pt instanceof Uint8Array;
      if (typeof Pt != "string" && !Ot) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Ct, s: Lt } = function(Vt) {
        if (Vt.length < 2 || Vt[0] != 48) throw new Error(`Invalid signature tag: ${nt(Vt)}`);
        if (Vt[1] !== Vt.length - 2) throw new Error("Invalid signature: incorrect length");
        const { data: Jt, left: Gt } = Ut(Vt.subarray(2)), { data: er, left: or } = Ut(Gt);
        if (or.length) throw new Error(`Invalid signature: left bytes after parsing: ${nt(or)}`);
        return { r: Jt, s: er };
      }(Ot ? Pt : pt(Pt));
      return new ut(Ct, Lt);
    }
    static fromHex(Pt) {
      return this.fromDER(Pt);
    }
    assertValidity() {
      const { r: Pt, s: Ot } = this;
      if (!jt(Pt)) throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!jt(Ot)) throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Pt = ie.n >> W;
      return this.s > Pt;
    }
    normalizeS() {
      return this.hasHighS() ? new ut(this.r, kt(-this.s, ie.n)) : this;
    }
    toDERRawBytes() {
      return pt(this.toDERHex());
    }
    toDERHex() {
      const Pt = It(Oe(this.s)), Ot = It(Oe(this.r)), Ct = Pt.length / 2, Lt = Ot.length / 2, Vt = Oe(Ct), Jt = Oe(Lt);
      return `30${Oe(Lt + Ct + 4)}02${Jt}${Ot}02${Vt}${Pt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return pt(this.toCompactHex());
    }
    toCompactHex() {
      return it(this.r) + it(this.s);
    }
  }
  function ht(...qt) {
    if (!qt.every((Ct) => Ct instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (qt.length === 1) return qt[0];
    const Pt = qt.reduce((Ct, Lt) => Ct + Lt.length, 0), Ot = new Uint8Array(Pt);
    for (let Ct = 0, Lt = 0; Ct < qt.length; Ct++) {
      const Vt = qt[Ct];
      Ot.set(Vt, Lt), Lt += Vt.length;
    }
    return Ot;
  }
  B.Signature = ut;
  const Ce = Array.from({ length: 256 }, (qt, Pt) => Pt.toString(16).padStart(2, "0"));
  function nt(qt) {
    if (!(qt instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    let Pt = "";
    for (let Ot = 0; Ot < qt.length; Ot++) Pt += Ce[qt[Ot]];
    return Pt;
  }
  const rt = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function it(qt) {
    if (typeof qt != "bigint") throw new Error("Expected bigint");
    if (!(K <= qt && qt < rt)) throw new Error("Expected number 0 <= n < 2^256");
    return qt.toString(16).padStart(64, "0");
  }
  function st(qt) {
    const Pt = pt(it(qt));
    if (Pt.length !== 32) throw new Error("Error: expected 32 bytes");
    return Pt;
  }
  function Oe(qt) {
    const Pt = qt.toString(16);
    return 1 & Pt.length ? `0${Pt}` : Pt;
  }
  function ct(qt) {
    if (typeof qt != "string") throw new TypeError("hexToNumber: expected string, got " + typeof qt);
    return BigInt(`0x${qt}`);
  }
  function pt(qt) {
    if (typeof qt != "string") throw new TypeError("hexToBytes: expected string, got " + typeof qt);
    if (qt.length % 2) throw new Error("hexToBytes: received invalid unpadded hex" + qt.length);
    const Pt = new Uint8Array(qt.length / 2);
    for (let Ot = 0; Ot < Pt.length; Ot++) {
      const Ct = 2 * Ot, Lt = qt.slice(Ct, Ct + 2), Vt = Number.parseInt(Lt, 16);
      if (Number.isNaN(Vt) || Vt < 0) throw new Error("Invalid byte sequence");
      Pt[Ot] = Vt;
    }
    return Pt;
  }
  function gt(qt) {
    return ct(nt(qt));
  }
  function vt(qt) {
    return qt instanceof Uint8Array ? Uint8Array.from(qt) : pt(qt);
  }
  function Bt(qt) {
    if (typeof qt == "number" && Number.isSafeInteger(qt) && qt > 0) return BigInt(qt);
    if (typeof qt == "bigint" && jt(qt)) return qt;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function kt(qt, Pt = ie.P) {
    const Ot = qt % Pt;
    return Ot >= K ? Ot : Pt + Ot;
  }
  function wt(qt, Pt) {
    const { P: Ot } = ie;
    let Ct = qt;
    for (; Pt-- > K; ) Ct *= Ct, Ct %= Ot;
    return Ct;
  }
  function Et(qt, Pt = ie.P) {
    if (qt === K || Pt <= K) throw new Error(`invert: expected positive integers, got n=${qt} mod=${Pt}`);
    let Ot = kt(qt, Pt), Ct = Pt, Lt = K, Vt = W;
    for (; Ot !== K; ) {
      const Jt = Ct % Ot, Gt = Lt - Vt * (Ct / Ot);
      Ct = Ot, Ot = Jt, Lt = Vt, Vt = Gt;
    }
    if (Ct !== W) throw new Error("invert: does not exist");
    return kt(Lt, Pt);
  }
  function Rt(qt, Pt = !1) {
    const Ot = function(Lt) {
      const Vt = 8 * Lt.length - 8 * pe, Jt = gt(Lt);
      return Vt > 0 ? Jt >> BigInt(Vt) : Jt;
    }(qt);
    if (Pt) return Ot;
    const { n: Ct } = ie;
    return Ot >= Ct ? Ot - Ct : Ot;
  }
  let Mt, Ht;
  class Kt {
    constructor(Pt, Ot) {
      if (this.hashLen = Pt, this.qByteLen = Ot, typeof Pt != "number" || Pt < 2) throw new Error("hashLen must be a number");
      if (typeof Ot != "number" || Ot < 2) throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Pt).fill(1), this.k = new Uint8Array(Pt).fill(0), this.counter = 0;
    }
    hmac(...Pt) {
      return B.utils.hmacSha256(this.k, ...Pt);
    }
    hmacSync(...Pt) {
      return Ht(this.k, ...Pt);
    }
    checkSync() {
      if (typeof Ht != "function") throw new dt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3) throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Pt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Pt), this.v = await this.hmac(this.v), Pt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Pt), this.v = await this.hmac(this.v));
    }
    reseedSync(Pt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Pt), this.v = this.hmacSync(this.v), Pt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Pt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Pt = 0;
      const Ot = [];
      for (; Pt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Ct = this.v.slice();
        Ot.push(Ct), Pt += this.v.length;
      }
      return ht(...Ot);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Pt = 0;
      const Ot = [];
      for (; Pt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Ct = this.v.slice();
        Ot.push(Ct), Pt += this.v.length;
      }
      return ht(...Ot);
    }
  }
  function jt(qt) {
    return K < qt && qt < ie.n;
  }
  function Wt(qt) {
    return K < qt && qt < ie.P;
  }
  function Yt(qt, Pt, Ot, Ct = !0) {
    const { n: Lt } = ie, Vt = Rt(qt, !0);
    if (!jt(Vt)) return;
    const Jt = Et(Vt, Lt), Gt = $t.BASE.multiply(Vt), er = kt(Gt.x, Lt);
    if (er === K) return;
    const or = kt(Jt * kt(Pt + Ot * er, Lt), Lt);
    if (or === K) return;
    let tr = new ut(er, or), sr = (Gt.x === tr.r ? 0 : 2) | Number(Gt.y & W);
    return Ct && tr.hasHighS() && (tr = tr.normalizeS(), sr ^= 1), { sig: tr, recovery: sr };
  }
  function Xt(qt) {
    let Pt;
    if (typeof qt == "bigint") Pt = qt;
    else if (typeof qt == "number" && Number.isSafeInteger(qt) && qt > 0) Pt = BigInt(qt);
    else if (typeof qt == "string") {
      if (qt.length !== 2 * pe) throw new Error("Expected 32 bytes of private key");
      Pt = ct(qt);
    } else {
      if (!(qt instanceof Uint8Array)) throw new TypeError("Expected valid private key");
      if (qt.length !== pe) throw new Error("Expected 32 bytes of private key");
      Pt = gt(qt);
    }
    if (!jt(Pt)) throw new Error("Expected private key: 0 < key < n");
    return Pt;
  }
  function ir(qt) {
    return qt instanceof $t ? (qt.assertValidity(), qt) : $t.fromHex(qt);
  }
  function ur(qt) {
    if (qt instanceof ut) return qt.assertValidity(), qt;
    try {
      return ut.fromDER(qt);
    } catch {
      return ut.fromCompact(qt);
    }
  }
  function Qt(qt) {
    const Pt = qt instanceof Uint8Array, Ot = typeof qt == "string", Ct = (Pt || Ot) && qt.length;
    return Pt ? Ct === ke || Ct === ot : Ot ? Ct === 2 * ke || Ct === 2 * ot : qt instanceof $t;
  }
  function hr(qt) {
    return gt(qt.length > ce ? qt.slice(0, ce) : qt);
  }
  function pr(qt) {
    const Pt = hr(qt), Ot = kt(Pt, ie.n);
    return cr(Ot < K ? Pt : Ot);
  }
  function cr(qt) {
    return st(qt);
  }
  function vr(qt, Pt, Ot) {
    if (qt == null) throw new Error(`sign: expected valid message hash, not "${qt}"`);
    const Ct = vt(qt), Lt = Xt(Pt), Vt = [cr(Lt), pr(Ct)];
    if (Ot != null) {
      Ot === !0 && (Ot = B.utils.randomBytes(ce));
      const Jt = vt(Ot);
      if (Jt.length !== ce) throw new Error(`sign: Expected ${ce} bytes of extra data`);
      Vt.push(Jt);
    }
    return { seed: ht(...Vt), m: hr(Ct), d: Lt };
  }
  function bt(qt, Pt) {
    const { sig: Ot, recovery: Ct } = qt, { der: Lt, recovered: Vt } = Object.assign({ canonical: !0, der: !0 }, Pt), Jt = Lt ? Ot.toDERRawBytes() : Ot.toCompactRawBytes();
    return Vt ? [Jt, Ct] : Jt;
  }
  B.getPublicKey = function(qt, Pt = !1) {
    return $t.fromPrivateKey(qt).toRawBytes(Pt);
  }, B.recoverPublicKey = function(qt, Pt, Ot, Ct = !1) {
    return $t.fromSignature(qt, Pt, Ot).toRawBytes(Ct);
  }, B.getSharedSecret = function(qt, Pt, Ot = !1) {
    if (Qt(qt)) throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Qt(Pt)) throw new TypeError("getSharedSecret: second arg must be public key");
    const Ct = ir(Pt);
    return Ct.assertValidity(), Ct.multiply(Xt(qt)).toRawBytes(Ot);
  }, B.sign = async function(qt, Pt, Ot = {}) {
    const { seed: Ct, m: Lt, d: Vt } = vr(qt, Pt, Ot.extraEntropy), Jt = new Kt(32, pe);
    let Gt;
    for (await Jt.reseed(Ct); !(Gt = Yt(await Jt.generate(), Lt, Vt, Ot.canonical)); ) await Jt.reseed();
    return bt(Gt, Ot);
  }, B.signSync = function(qt, Pt, Ot = {}) {
    const { seed: Ct, m: Lt, d: Vt } = vr(qt, Pt, Ot.extraEntropy), Jt = new Kt(32, pe);
    let Gt;
    for (Jt.reseedSync(Ct); !(Gt = Yt(Jt.generateSync(), Lt, Vt, Ot.canonical)); ) Jt.reseedSync();
    return bt(Gt, Ot);
  };
  const At = { strict: !0 };
  function Tt(qt) {
    return kt(gt(qt), ie.n);
  }
  B.verify = function(qt, Pt, Ot, Ct = At) {
    let Lt;
    try {
      Lt = ur(qt), Pt = vt(Pt);
    } catch {
      return !1;
    }
    const { r: Vt, s: Jt } = Lt;
    if (Ct.strict && Lt.hasHighS()) return !1;
    const Gt = Rt(Pt);
    let er;
    try {
      er = ir(Ot);
    } catch {
      return !1;
    }
    const { n: or } = ie, tr = Et(Jt, or), sr = kt(Gt * tr, or), rr = kt(Vt * tr, or), fr = $t.BASE.multiplyAndAddUnsafe(er, sr, rr);
    return !!fr && kt(fr.x, or) === Vt;
  };
  class xt {
    constructor(Pt, Ot) {
      this.r = Pt, this.s = Ot, this.assertValidity();
    }
    static fromHex(Pt) {
      const Ot = vt(Pt);
      if (Ot.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Ot.length}`);
      const Ct = gt(Ot.subarray(0, 32)), Lt = gt(Ot.subarray(32, 64));
      return new xt(Ct, Lt);
    }
    assertValidity() {
      const { r: Pt, s: Ot } = this;
      if (!Wt(Pt) || !jt(Ot)) throw new Error("Invalid signature");
    }
    toHex() {
      return it(this.r) + it(this.s);
    }
    toRawBytes() {
      return pt(this.toHex());
    }
  }
  class Nt {
    constructor(Pt, Ot, Ct = B.utils.randomBytes()) {
      if (Pt == null) throw new TypeError(`sign: Expected valid message, not "${Pt}"`);
      this.m = vt(Pt);
      const { x: Lt, scalar: Vt } = this.getScalar(Xt(Ot));
      if (this.px = Lt, this.d = Vt, this.rand = vt(Ct), this.rand.length !== 32) throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Pt) {
      const Ot = $t.fromPrivateKey(Pt), Ct = Ot.hasEvenY() ? Pt : ie.n - Pt;
      return { point: Ot, scalar: Ct, x: Ot.toRawX() };
    }
    initNonce(Pt, Ot) {
      return st(Pt ^ gt(Ot));
    }
    finalizeNonce(Pt) {
      const Ot = kt(gt(Pt), ie.n);
      if (Ot === K) throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Ct, x: Lt, scalar: Vt } = this.getScalar(Ot);
      return { R: Ct, rx: Lt, k: Vt };
    }
    finalizeSig(Pt, Ot, Ct, Lt) {
      return new xt(Pt.x, kt(Ot + Ct * Lt, ie.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Pt, d: Ot, px: Ct, rand: Lt } = this, Vt = B.utils.taggedHash, Jt = this.initNonce(Ot, await Vt(Zt.aux, Lt)), { R: Gt, rx: er, k: or } = this.finalizeNonce(await Vt(Zt.nonce, Jt, Ct, Pt)), tr = Tt(await Vt(Zt.challenge, er, Ct, Pt)), sr = this.finalizeSig(Gt, or, tr, Ot);
      return await nr(sr, Pt, Ct) || this.error(), sr;
    }
    calcSync() {
      const { m: Pt, d: Ot, px: Ct, rand: Lt } = this, Vt = B.utils.taggedHashSync, Jt = this.initNonce(Ot, Vt(Zt.aux, Lt)), { R: Gt, rx: er, k: or } = this.finalizeNonce(Vt(Zt.nonce, Jt, Ct, Pt)), tr = Tt(Vt(Zt.challenge, er, Ct, Pt)), sr = this.finalizeSig(Gt, or, tr, Ot);
      return lr(sr, Pt, Ct) || this.error(), sr;
    }
  }
  function Ft(qt, Pt, Ot) {
    const Ct = qt instanceof xt, Lt = Ct ? qt : xt.fromHex(qt);
    return Ct && Lt.assertValidity(), { ...Lt, m: vt(Pt), P: ir(Ot) };
  }
  function zt(qt, Pt, Ot, Ct) {
    const Lt = $t.BASE.multiplyAndAddUnsafe(Pt, Xt(Ot), kt(-Ct, ie.n));
    return !(!Lt || !Lt.hasEvenY() || Lt.x !== qt);
  }
  async function nr(qt, Pt, Ot) {
    try {
      const { r: Ct, s: Lt, m: Vt, P: Jt } = Ft(qt, Pt, Ot), Gt = Tt(await B.utils.taggedHash(Zt.challenge, st(Ct), Jt.toRawX(), Vt));
      return zt(Ct, Jt, Lt, Gt);
    } catch {
      return !1;
    }
  }
  function lr(qt, Pt, Ot) {
    try {
      const { r: Ct, s: Lt, m: Vt, P: Jt } = Ft(qt, Pt, Ot), Gt = Tt(B.utils.taggedHashSync(Zt.challenge, st(Ct), Jt.toRawX(), Vt));
      return zt(Ct, Jt, Lt, Gt);
    } catch (Ct) {
      if (Ct instanceof dt) throw Ct;
      return !1;
    }
  }
  B.schnorr = { Signature: xt, getPublicKey: function(qt) {
    return $t.fromPrivateKey(qt).toRawX();
  }, sign: async function(qt, Pt, Ot) {
    return new Nt(qt, Pt, Ot).calc();
  }, verify: nr, signSync: function(qt, Pt, Ot) {
    return new Nt(qt, Pt, Ot).calcSync();
  }, verifySync: lr }, $t.BASE._setWindowSize(8);
  const Dt = { node: L, web: typeof self == "object" && "crypto" in self ? self.crypto : void 0 }, Zt = { challenge: "BIP0340/challenge", aux: "BIP0340/aux", nonce: "BIP0340/nonce" }, ar = {};
  B.utils = { bytesToHex: nt, hexToBytes: pt, concatBytes: ht, mod: kt, invert: Et, isValidPrivateKey(qt) {
    try {
      return Xt(qt), !0;
    } catch {
      return !1;
    }
  }, _bigintTo32Bytes: st, _normalizePrivateKey: Xt, hashToPrivateKey: (qt) => {
    qt = vt(qt);
    const Pt = pe + 8;
    if (qt.length < Pt || qt.length > 1024) throw new Error("Expected valid bytes of private key as per FIPS 186");
    return st(kt(gt(qt), ie.n - W) + W);
  }, randomBytes: (qt = 32) => {
    if (Dt.web) return Dt.web.getRandomValues(new Uint8Array(qt));
    if (Dt.node) {
      const { randomBytes: Pt } = Dt.node;
      return Uint8Array.from(Pt(qt));
    }
    throw new Error("The environment doesn't have randomBytes function");
  }, randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(pe + 8)), precompute(qt = 8, Pt = $t.BASE) {
    const Ot = Pt === $t.BASE ? Pt : new $t(Pt.x, Pt.y);
    return Ot._setWindowSize(qt), Ot.multiply(J), Ot;
  }, sha256: async (...qt) => {
    if (Dt.web) {
      const Pt = await Dt.web.subtle.digest("SHA-256", ht(...qt));
      return new Uint8Array(Pt);
    }
    if (Dt.node) {
      const { createHash: Pt } = Dt.node, Ot = Pt("sha256");
      return qt.forEach((Ct) => Ot.update(Ct)), Uint8Array.from(Ot.digest());
    }
    throw new Error("The environment doesn't have sha256 function");
  }, hmacSha256: async (qt, ...Pt) => {
    if (Dt.web) {
      const Ot = await Dt.web.subtle.importKey("raw", qt, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Ct = ht(...Pt), Lt = await Dt.web.subtle.sign("HMAC", Ot, Ct);
      return new Uint8Array(Lt);
    }
    if (Dt.node) {
      const { createHmac: Ot } = Dt.node, Ct = Ot("sha256", qt);
      return Pt.forEach((Lt) => Ct.update(Lt)), Uint8Array.from(Ct.digest());
    }
    throw new Error("The environment doesn't have hmac-sha256 function");
  }, sha256Sync: void 0, hmacSha256Sync: void 0, taggedHash: async (qt, ...Pt) => {
    let Ot = ar[qt];
    if (Ot === void 0) {
      const Ct = await B.utils.sha256(Uint8Array.from(qt, (Lt) => Lt.charCodeAt(0)));
      Ot = ht(Ct, Ct), ar[qt] = Ot;
    }
    return B.utils.sha256(Ot, ...Pt);
  }, taggedHashSync: (qt, ...Pt) => {
    if (typeof Mt != "function") throw new dt("sha256Sync is undefined, you need to set it");
    let Ot = ar[qt];
    if (Ot === void 0) {
      const Ct = Mt(Uint8Array.from(qt, (Lt) => Lt.charCodeAt(0)));
      Ot = ht(Ct, Ct), ar[qt] = Ot;
    }
    return Mt(Ot, ...Pt);
  }, _JacobianPoint: yt }, Object.defineProperties(B.utils, { sha256Sync: { configurable: !1, get: () => Mt, set(qt) {
    Mt || (Mt = qt);
  } }, hmacSha256Sync: { configurable: !1, get: () => Ht, set(qt) {
    Ht || (Ht = qt);
  } } });
})(lib$1);
var necc = lib$1, hmac = hmac$2, sha256$1 = sha256$5;
function _interopNamespaceDefault(B) {
  var L = /* @__PURE__ */ Object.create(null);
  return B && Object.keys(B).forEach(function(K) {
    if (K !== "default") {
      var W = Object.getOwnPropertyDescriptor(B, K);
      Object.defineProperty(L, K, W.get ? W : { enumerable: !0, get: function() {
        return B[K];
      } });
    }
  }), L.default = B, Object.freeze(L);
}
var necc__namespace = _interopNamespaceDefault(necc);
const THROW_BAD_PRIVATE = "Expected Private", THROW_BAD_POINT = "Expected Point", THROW_BAD_TWEAK = "Expected Tweak", THROW_BAD_HASH = "Expected Hash", THROW_BAD_SIGNATURE = "Expected Signature", THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)", THROW_BAD_SCALAR = "Expected Scalar", THROW_BAD_RECOVERY_ID = "Bad Recovery Id";
necc__namespace.utils.hmacSha256Sync = (B, ...L) => hmac.hmac(sha256$1.sha256, B, necc__namespace.utils.concatBytes(...L)), necc__namespace.utils.sha256Sync = (...B) => sha256$1.sha256(necc__namespace.utils.concatBytes(...B));
const normalizePrivateKey = necc__namespace.utils._normalizePrivateKey, HASH_SIZE = 32, TWEAK_SIZE = 32, BN32_N = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65]), EXTRA_DATA_SIZE = 32, BN32_ZERO = new Uint8Array(32), BN32_P_MINUS_N = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95, 196, 64, 45, 161, 114, 47, 201, 186, 238]);
function isUint8Array(B) {
  return B instanceof Uint8Array;
}
function cmpBN32(B, L) {
  for (let K = 0; K < 32; ++K) if (B[K] !== L[K]) return B[K] < L[K] ? -1 : 1;
  return 0;
}
function isZero(B) {
  return cmpBN32(B, BN32_ZERO) === 0;
}
function isTweak(B) {
  return B instanceof Uint8Array && B.length === TWEAK_SIZE && !(cmpBN32(B, BN32_N) >= 0);
}
function isSignature(B) {
  return B instanceof Uint8Array && B.length === 64 && cmpBN32(B.subarray(0, 32), BN32_N) < 0 && cmpBN32(B.subarray(32, 64), BN32_N) < 0;
}
function isSigrLessThanPMinusN(B) {
  return isUint8Array(B) && B.length === 64 && cmpBN32(B.subarray(0, 32), BN32_P_MINUS_N) < 0;
}
function isSignatureNonzeroRS(B) {
  return !(isZero(B.subarray(0, 32)) || isZero(B.subarray(32, 64)));
}
function isHash(B) {
  return B instanceof Uint8Array && B.length === HASH_SIZE;
}
function isExtraData(B) {
  return B === void 0 || B instanceof Uint8Array && B.length === EXTRA_DATA_SIZE;
}
function hexToNumber(B) {
  if (typeof B != "string") throw new TypeError("hexToNumber: expected string, got " + typeof B);
  return BigInt(`0x${B}`);
}
function bytesToNumber(B) {
  return hexToNumber(necc__namespace.utils.bytesToHex(B));
}
function normalizeScalar(B) {
  let L;
  if (typeof B == "bigint") L = B;
  else if (typeof B == "number" && Number.isSafeInteger(B) && B >= 0) L = BigInt(B);
  else if (typeof B == "string") {
    if (B.length !== 64) throw new Error("Expected 32 bytes of private scalar");
    L = hexToNumber(B);
  } else {
    if (!(B instanceof Uint8Array)) throw new TypeError("Expected valid private scalar");
    if (B.length !== 32) throw new Error("Expected 32 bytes of private scalar");
    L = bytesToNumber(B);
  }
  if (L < 0) throw new Error("Expected private scalar >= 0");
  return L;
}
const _privateAdd = (B, L) => {
  const K = normalizePrivateKey(B), W = normalizeScalar(L), V = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(K + W, necc__namespace.CURVE.n));
  return necc__namespace.utils.isValidPrivateKey(V) ? V : null;
}, _privateSub = (B, L) => {
  const K = normalizePrivateKey(B), W = normalizeScalar(L), V = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(K - W, necc__namespace.CURVE.n));
  return necc__namespace.utils.isValidPrivateKey(V) ? V : null;
}, _privateNegate = (B) => {
  const L = normalizePrivateKey(B), K = necc__namespace.utils._bigintTo32Bytes(necc__namespace.CURVE.n - L);
  return necc__namespace.utils.isValidPrivateKey(K) ? K : null;
}, _pointAddScalar = (B, L, K) => {
  const W = necc__namespace.Point.fromHex(B), V = normalizeScalar(L), J = necc__namespace.Point.BASE.multiplyAndAddUnsafe(W, V, BigInt(1));
  if (!J) throw new Error("Tweaked point at infinity");
  return J.toRawBytes(K);
}, _pointMultiply = (B, L, K) => {
  const W = necc__namespace.Point.fromHex(B), V = typeof L == "string" ? L : necc__namespace.utils.bytesToHex(L), J = BigInt(`0x${V}`);
  return W.multiply(J).toRawBytes(K);
};
function assumeCompression(B, L) {
  return B === void 0 ? L === void 0 || isPointCompressed(L) : !!B;
}
function throwToNull(B) {
  try {
    return B();
  } catch {
    return null;
  }
}
function _isPoint(B, L) {
  if (B.length === 32 !== L) return !1;
  try {
    return !!necc__namespace.Point.fromHex(B);
  } catch {
    return !1;
  }
}
function isPoint(B) {
  return _isPoint(B, !1);
}
function isPointCompressed(B) {
  return _isPoint(B, !1) && B.length === 33;
}
function isPrivate(B) {
  return necc__namespace.utils.isValidPrivateKey(B);
}
function isXOnlyPoint(B) {
  return _isPoint(B, !0);
}
function xOnlyPointAddTweak(B, L) {
  if (!isXOnlyPoint(B)) throw new Error(THROW_BAD_POINT);
  if (!isTweak(L)) throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => {
    const K = _pointAddScalar(B, L, !0);
    return { parity: K[0] % 2 == 1 ? 1 : 0, xOnlyPubkey: K.slice(1) };
  });
}
function xOnlyPointFromPoint(B) {
  if (!isPoint(B)) throw new Error(THROW_BAD_POINT);
  return B.slice(1, 33);
}
function pointFromScalar(B, L) {
  if (!isPrivate(B)) throw new Error(THROW_BAD_PRIVATE);
  return throwToNull(() => necc__namespace.getPublicKey(B, assumeCompression(L)));
}
function xOnlyPointFromScalar(B) {
  if (!isPrivate(B)) throw new Error(THROW_BAD_PRIVATE);
  return xOnlyPointFromPoint(pointFromScalar(B));
}
function pointCompress(B, L) {
  if (!isPoint(B)) throw new Error(THROW_BAD_POINT);
  return necc__namespace.Point.fromHex(B).toRawBytes(assumeCompression(L, B));
}
function pointMultiply(B, L, K) {
  if (!isPoint(B)) throw new Error(THROW_BAD_POINT);
  if (!isTweak(L)) throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _pointMultiply(B, L, assumeCompression(K, B)));
}
function pointAdd(B, L, K) {
  if (!isPoint(B) || !isPoint(L)) throw new Error(THROW_BAD_POINT);
  return throwToNull(() => {
    const W = necc__namespace.Point.fromHex(B), V = necc__namespace.Point.fromHex(L);
    return W.equals(V.negate()) ? null : W.add(V).toRawBytes(assumeCompression(K, B));
  });
}
function pointAddScalar(B, L, K) {
  if (!isPoint(B)) throw new Error(THROW_BAD_POINT);
  if (!isTweak(L)) throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _pointAddScalar(B, L, assumeCompression(K, B)));
}
function privateAdd(B, L) {
  if (isPrivate(B) === !1) throw new Error(THROW_BAD_PRIVATE);
  if (isTweak(L) === !1) throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _privateAdd(B, L));
}
function privateSub(B, L) {
  if (isPrivate(B) === !1) throw new Error(THROW_BAD_PRIVATE);
  if (isTweak(L) === !1) throw new Error(THROW_BAD_TWEAK);
  return throwToNull(() => _privateSub(B, L));
}
function privateNegate(B) {
  if (isPrivate(B) === !1) throw new Error(THROW_BAD_PRIVATE);
  return _privateNegate(B);
}
function sign(B, L, K) {
  if (!isPrivate(L)) throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B)) throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(K)) throw new Error(THROW_BAD_EXTRA_DATA);
  return necc__namespace.signSync(B, L, { der: !1, extraEntropy: K });
}
function signRecoverable(B, L, K) {
  if (!isPrivate(L)) throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B)) throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(K)) throw new Error(THROW_BAD_EXTRA_DATA);
  const [W, V] = necc__namespace.signSync(B, L, { der: !1, extraEntropy: K, recovered: !0 });
  return { signature: W, recoveryId: V };
}
function signSchnorr(B, L, K = Buffer$3.alloc(32, 0)) {
  if (!isPrivate(L)) throw new Error(THROW_BAD_PRIVATE);
  if (!isHash(B)) throw new Error(THROW_BAD_SCALAR);
  if (!isExtraData(K)) throw new Error(THROW_BAD_EXTRA_DATA);
  return necc__namespace.schnorr.signSync(B, L, K);
}
function recover(B, L, K, W) {
  if (!isHash(B)) throw new Error(THROW_BAD_HASH);
  if (!isSignature(L) || !isSignatureNonzeroRS(L)) throw new Error(THROW_BAD_SIGNATURE);
  if (2 & K && !isSigrLessThanPMinusN(L)) throw new Error(THROW_BAD_RECOVERY_ID);
  if (!isXOnlyPoint(L.subarray(0, 32))) throw new Error(THROW_BAD_SIGNATURE);
  return necc__namespace.recoverPublicKey(B, L, K, assumeCompression(W));
}
function verify(B, L, K, W) {
  if (!isPoint(L)) throw new Error(THROW_BAD_POINT);
  if (!isSignature(K)) throw new Error(THROW_BAD_SIGNATURE);
  if (!isHash(B)) throw new Error(THROW_BAD_SCALAR);
  return necc__namespace.verify(K, B, L, { strict: W });
}
function verifySchnorr(B, L, K) {
  if (!isXOnlyPoint(L)) throw new Error(THROW_BAD_POINT);
  if (!isSignature(K)) throw new Error(THROW_BAD_SIGNATURE);
  if (!isHash(B)) throw new Error(THROW_BAD_SCALAR);
  return necc__namespace.schnorr.verifySync(K, B, L);
}
var isPoint_1 = dist.isPoint = isPoint, isPointCompressed_1 = dist.isPointCompressed = isPointCompressed, isPrivate_1 = dist.isPrivate = isPrivate, isXOnlyPoint_1 = dist.isXOnlyPoint = isXOnlyPoint, pointAdd_1 = dist.pointAdd = pointAdd, pointAddScalar_1 = dist.pointAddScalar = pointAddScalar, pointCompress_1 = dist.pointCompress = pointCompress, pointFromScalar_1 = dist.pointFromScalar = pointFromScalar, pointMultiply_1 = dist.pointMultiply = pointMultiply, privateAdd_1 = dist.privateAdd = privateAdd, privateNegate_1 = dist.privateNegate = privateNegate, privateSub_1 = dist.privateSub = privateSub, recover_1 = dist.recover = recover, sign_1 = dist.sign = sign, signRecoverable_1 = dist.signRecoverable = signRecoverable, signSchnorr_1 = dist.signSchnorr = signSchnorr, verify_1 = dist.verify = verify, verifySchnorr_1 = dist.verifySchnorr = verifySchnorr, xOnlyPointAddTweak_1 = dist.xOnlyPointAddTweak = xOnlyPointAddTweak, xOnlyPointFromPoint_1 = dist.xOnlyPointFromPoint = xOnlyPointFromPoint, xOnlyPointFromScalar_1 = dist.xOnlyPointFromScalar = xOnlyPointFromScalar;
const ecc = _mergeNamespaces({ __proto__: null, default: dist, isPoint: isPoint_1, isPointCompressed: isPointCompressed_1, isPrivate: isPrivate_1, isXOnlyPoint: isXOnlyPoint_1, pointAdd: pointAdd_1, pointAddScalar: pointAddScalar_1, pointCompress: pointCompress_1, pointFromScalar: pointFromScalar_1, pointMultiply: pointMultiply_1, privateAdd: privateAdd_1, privateNegate: privateNegate_1, privateSub: privateSub_1, recover: recover_1, sign: sign_1, signRecoverable: signRecoverable_1, signSchnorr: signSchnorr_1, verify: verify_1, verifySchnorr: verifySchnorr_1, xOnlyPointAddTweak: xOnlyPointAddTweak_1, xOnlyPointFromPoint: xOnlyPointFromPoint_1, xOnlyPointFromScalar: xOnlyPointFromScalar_1 }, [dist]);
var src = {}, ecpair = {}, networks$1 = {};
Object.defineProperty(networks$1, "__esModule", { value: !0 }), networks$1.testnet = networks$1.bitcoin = void 0, networks$1.bitcoin = { messagePrefix: `Bitcoin Signed Message:
`, bech32: "bc", bip32: { public: 76067358, private: 76066276 }, pubKeyHash: 0, scriptHash: 5, wif: 128 }, networks$1.testnet = { messagePrefix: `Bitcoin Signed Message:
`, bech32: "tb", bip32: { public: 70617039, private: 70615956 }, pubKeyHash: 111, scriptHash: 196, wif: 239 };
var types$1 = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.maybe = B.Boolean = B.Array = B.Buffer256bit = B.Network = B.typeforce = void 0, B.typeforce = typeforce_1, B.Network = B.typeforce.compile({ messagePrefix: B.typeforce.oneOf(B.typeforce.Buffer, B.typeforce.String), bip32: { public: B.typeforce.UInt32, private: B.typeforce.UInt32 }, pubKeyHash: B.typeforce.UInt8, scriptHash: B.typeforce.UInt8, wif: B.typeforce.UInt8 }), B.Buffer256bit = B.typeforce.BufferN(32), B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.maybe = B.typeforce.maybe;
})(types$1);
var testecc = {};
Object.defineProperty(testecc, "__esModule", { value: !0 }), testecc.testEcc = void 0;
const h = (B) => Buffer$3.from(B, "hex");
function testEcc(B) {
  assert(B.isPoint(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert(!B.isPoint(h("030000000000000000000000000000000000000000000000000000000000000005"))), assert(B.isPrivate(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert(B.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert(!B.isPrivate(h("0000000000000000000000000000000000000000000000000000000000000000"))), assert(!B.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), assert(!B.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), assert(Buffer$3.from(B.privateAdd(h("0000000000000000000000000000000000000000000000000000000000000001"), h("0000000000000000000000000000000000000000000000000000000000000000"))).equals(h("0000000000000000000000000000000000000000000000000000000000000001"))), assert(B.privateAdd(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h("0000000000000000000000000000000000000000000000000000000000000003")) === null), assert(Buffer$3.from(B.privateAdd(h("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"), h("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665"))).equals(h("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24"))), assert(Buffer$3.from(B.privateNegate(h("0000000000000000000000000000000000000000000000000000000000000001"))).equals(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), assert(Buffer$3.from(B.privateNegate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"))).equals(h("0000000000000000000000000000000000000000000000000000000000000003"))), assert(Buffer$3.from(B.privateNegate(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792"))), assert(Buffer$3.from(B.pointCompress(h("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"), !0)).equals(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert(Buffer$3.from(B.pointCompress(h("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"), !1)).equals(h("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"))), assert(Buffer$3.from(B.pointCompress(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), !0)).equals(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), assert(Buffer$3.from(B.pointCompress(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), !1)).equals(h("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"))), assert(Buffer$3.from(B.pointFromScalar(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99"))), assert(B.xOnlyPointAddTweak(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
  let L = B.xOnlyPointAddTweak(h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
  assert(Buffer$3.from(L.xOnlyPubkey).equals(h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) && L.parity === 1), L = B.xOnlyPointAddTweak(h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")), assert(Buffer$3.from(L.xOnlyPubkey).equals(h("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")) && L.parity === 0), assert(Buffer$3.from(B.sign(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))).equals(h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), assert(B.verify(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), B.signSchnorr && assert(Buffer$3.from(B.signSchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906"))).equals(h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"))), B.verifySchnorr && assert(B.verifySchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
testecc.testEcc = testEcc, Object.defineProperty(ecpair, "__esModule", { value: !0 }), ecpair.ECPairFactory = ecpair.networks = void 0;
const networks = networks$1;
ecpair.networks = networks;
const types = types$1, randomBytes = browserExports, wif = wif$2, testecc_1 = testecc, isOptions = types.typeforce.maybe(types.typeforce.compile({ compressed: types.maybe(types.Boolean), network: types.maybe(types.Network) })), toXOnly = (B) => B.length === 32 ? B : B.slice(1, 33);
function ECPairFactory(B) {
  function L(V, J) {
    if (types.typeforce(types.Buffer256bit, V), !B.isPrivate(V)) throw new TypeError("Private key not in range [1, n)");
    return types.typeforce(isOptions, J), new W(V, void 0, J);
  }
  function K(V, J) {
    return types.typeforce(B.isPoint, V), types.typeforce(isOptions, J), new W(void 0, V, J);
  }
  (0, testecc_1.testEcc)(B);
  class W {
    constructor(J, re, ie) {
      Xr(this, "__D");
      Xr(this, "__Q");
      Xr(this, "compressed");
      Xr(this, "network");
      Xr(this, "lowR");
      this.__D = J, this.__Q = re, this.lowR = !1, ie === void 0 && (ie = {}), this.compressed = ie.compressed === void 0 || ie.compressed, this.network = ie.network || networks.bitcoin, re !== void 0 && (this.__Q = Buffer$3.from(B.pointCompress(re, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const J = B.pointFromScalar(this.__D, this.compressed);
        this.__Q = Buffer$3.from(J);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error("Missing private key");
      return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(J) {
      return this.privateKey ? this.tweakFromPrivateKey(J) : this.tweakFromPublicKey(J);
    }
    sign(J, re) {
      if (!this.__D) throw new Error("Missing private key");
      if (re === void 0 && (re = this.lowR), re === !1) return Buffer$3.from(B.sign(J, this.__D));
      {
        let ie = B.sign(J, this.__D);
        const ne = Buffer$3.alloc(32, 0);
        let oe = 0;
        for (; ie[0] > 127; ) oe++, ne.writeUIntLE(oe, 0, 6), ie = B.sign(J, this.__D, ne);
        return Buffer$3.from(ie);
      }
    }
    signSchnorr(J) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (!B.signSchnorr) throw new Error("signSchnorr not supported by ecc library");
      return Buffer$3.from(B.signSchnorr(J, this.privateKey));
    }
    verify(J, re) {
      return B.verify(J, this.publicKey, re);
    }
    verifySchnorr(J, re) {
      if (!B.verifySchnorr) throw new Error("verifySchnorr not supported by ecc library");
      return B.verifySchnorr(J, this.publicKey.subarray(1, 33), re);
    }
    tweakFromPublicKey(J) {
      const re = toXOnly(this.publicKey), ie = B.xOnlyPointAddTweak(re, J);
      if (!ie || ie.xOnlyPubkey === null) throw new Error("Cannot tweak public key!");
      const ne = Buffer$3.from([ie.parity === 0 ? 2 : 3]);
      return K(Buffer$3.concat([ne, ie.xOnlyPubkey]), { network: this.network, compressed: this.compressed });
    }
    tweakFromPrivateKey(J) {
      const re = this.publicKey[0] !== 3 && (this.publicKey[0] !== 4 || 1 & ~this.publicKey[64]) ? this.privateKey : B.privateNegate(this.privateKey), ie = B.privateAdd(re, J);
      if (!ie) throw new Error("Invalid tweaked private key!");
      return L(Buffer$3.from(ie), { network: this.network, compressed: this.compressed });
    }
  }
  return { isPoint: function(V) {
    return B.isPoint(V);
  }, fromPrivateKey: L, fromPublicKey: K, fromWIF: function(V, J) {
    const re = wif.decode(V), ie = re.version;
    if (types.Array(J)) {
      if (J = J.filter((ne) => ie === ne.wif).pop(), !J) throw new Error("Unknown network version");
    } else if (J = J || networks.bitcoin, ie !== J.wif) throw new Error("Invalid network version");
    return L(re.privateKey, { compressed: re.compressed, network: J });
  }, makeRandom: function(V) {
    types.typeforce(isOptions, V), V === void 0 && (V = {});
    const J = V.rng || randomBytes;
    let re;
    do
      re = J(32), types.typeforce(types.Buffer256bit, re);
    while (!B.isPrivate(re));
    return L(re, V);
  } };
}
ecpair.ECPairFactory = ECPairFactory, function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.networks = B.ECPairFactory = B.default = void 0;
  var L = ecpair;
  Object.defineProperty(B, "default", { enumerable: !0, get: function() {
    return L.ECPairFactory;
  } }), Object.defineProperty(B, "ECPairFactory", { enumerable: !0, get: function() {
    return L.ECPairFactory;
  } }), Object.defineProperty(B, "networks", { enumerable: !0, get: function() {
    return L.networks;
  } });
}(src);
var __classPrivateFieldGet = function(B, L, K, W) {
  if (K === "a" && !W) throw new TypeError("Private accessor was defined without a getter");
  if (typeof L == "function" ? B !== L || !W : !L.has(B)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return K === "m" ? W : K === "a" ? W.call(B) : W ? W.value : L.get(B);
}, __classPrivateFieldSet = function(B, L, K, W, V) {
  if (W === "m") throw new TypeError("Private method is not writable");
  if (W === "a" && !V) throw new TypeError("Private accessor was defined without a setter");
  if (typeof L == "function" ? B !== L || !V : !L.has(B)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return W === "a" ? V.call(B, K) : V ? V.value = K : L.set(B, K), K;
}, _AppReadyEvent_detail;
let wallets;
const registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(B) {
  cachedWalletsArray = void 0, registeredWalletsSet.add(B);
}
function removeRegisteredWallet(B) {
  cachedWalletsArray = void 0, registeredWalletsSet.delete(B);
}
const listeners = {};
function getWallets() {
  if (wallets || (wallets = Object.freeze({ register, get, on }), typeof window > "u")) return wallets;
  const B = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: L }) => L(B));
  } catch {
  }
  try {
    window.dispatchEvent(new AppReadyEvent(B));
  } catch {
  }
  return wallets;
}
function register(...B) {
  var L;
  return (B = B.filter((K) => !registeredWalletsSet.has(K))).length ? (B.forEach((K) => addRegisteredWallet(K)), (L = listeners.register) == null || L.forEach((K) => guard(() => K(...B))), function() {
    var K;
    B.forEach((W) => removeRegisteredWallet(W)), (K = listeners.unregister) == null || K.forEach((W) => guard(() => W(...B)));
  }) : () => {
  };
}
let cachedWalletsArray;
function get() {
  return cachedWalletsArray || (cachedWalletsArray = [...registeredWalletsSet]), cachedWalletsArray;
}
function on(B, L) {
  var K;
  return (K = listeners[B]) != null && K.push(L) || (listeners[B] = [L]), function() {
    var W;
    listeners[B] = (W = listeners[B]) == null ? void 0 : W.filter((V) => L !== V);
  };
}
function guard(B) {
  try {
    B();
  } catch {
  }
}
class AppReadyEvent extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(L) {
    super("wallet-standard:app-ready", { bubbles: !1, cancelable: !1, composed: !1 }), _AppReadyEvent_detail.set(this, void 0), __classPrivateFieldSet(this, _AppReadyEvent_detail, L, "f");
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();
var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
function getValue(B, L) {
  return B == null ? void 0 : B[L];
}
function isHostObject(B) {
  var L = !1;
  if (B != null && typeof B.toString != "function") try {
    L = !!(B + "");
  } catch {
  }
  return L;
}
var funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : ""), uid, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Symbol$1 = root.Symbol, store2, store3, store4;
function baseIsNative(B) {
  return !(!isObject(B) || isMasked(B)) && (isFunction(B) || isHostObject(B) ? reIsNative : reIsHostCtor).test(toSource(B));
}
function getNative(B, L) {
  var K = getValue(B, L);
  return baseIsNative(K) ? K : void 0;
}
function isMasked(B) {
  return !!maskSrcKey && maskSrcKey in B;
}
function toSource(B) {
  if (B != null) {
    try {
      return funcToString.call(B);
    } catch {
    }
    try {
      return B + "";
    } catch {
    }
  }
  return "";
}
function isFunction(B) {
  var L = isObject(B) ? objectToString.call(B) : "";
  return L == funcTag || L == genTag;
}
function isObject(B) {
  var L = typeof B;
  return !!B && (L == "object" || L == "function");
}
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
function getSpecificMessage(B, L) {
  var K;
  return (K = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : K.get(L);
}
function _stringify(B) {
  var K, W;
  let L = typeof B;
  return L === "object" && (L = (B && ((W = (K = Object.getPrototypeOf(B)) == null ? void 0 : K.constructor) == null ? void 0 : W.name)) ?? "null"), L === "string" ? `"${B}"` : L === "number" || L === "bigint" || L === "boolean" ? `${B}` : L;
}
function _addIssue(B, L, K, W, V) {
  const J = V && "input" in V ? V.input : K.value, re = (V == null ? void 0 : V.expected) ?? B.expects ?? null, ie = (V == null ? void 0 : V.received) ?? _stringify(J), ne = { kind: B.kind, type: B.type, input: J, expected: re, received: ie, message: `Invalid ${L}: ${re ? `Expected ${re} but r` : "R"}eceived ${ie}`, requirement: B.requirement, path: V == null ? void 0 : V.path, issues: V == null ? void 0 : V.issues, lang: W.lang, abortEarly: W.abortEarly, abortPipeEarly: W.abortPipeEarly }, oe = B.kind === "schema", ce = (V == null ? void 0 : V.message) ?? B.message ?? getSpecificMessage(B.reference, ne.lang) ?? (oe ? getSchemaMessage(ne.lang) : null) ?? W.message ?? getGlobalMessage(ne.lang);
  ce && (ne.message = typeof ce == "function" ? ce(ne) : ce), oe && (K.typed = !1), K.issues ? K.issues.push(ne) : K.issues = [ne];
}
function _isValidObjectKey(B, L) {
  return Object.hasOwn(B, L) && L !== "__proto__" && L !== "prototype" && L !== "constructor";
}
function getDefault(B, L, K) {
  return typeof B.default == "function" ? B.default(L, K) : B.default;
}
function array(B, L) {
  return { kind: "schema", type: "array", reference: array, expects: "Array", async: !1, item: B, message: L, _run(K, W) {
    var J;
    const V = K.value;
    if (Array.isArray(V)) {
      K.typed = !0, K.value = [];
      for (let re = 0; re < V.length; re++) {
        const ie = V[re], ne = this.item._run({ typed: !1, value: ie }, W);
        if (ne.issues) {
          const oe = { type: "array", origin: "value", input: V, key: re, value: ie };
          for (const ce of ne.issues) ce.path ? ce.path.unshift(oe) : ce.path = [oe], (J = K.issues) == null || J.push(ce);
          if (K.issues || (K.issues = ne.issues), W.abortEarly) {
            K.typed = !1;
            break;
          }
        }
        ne.typed || (K.typed = !1), K.value.push(ne.value);
      }
    } else _addIssue(this, "type", K, W);
    return K;
  } };
}
function boolean(B) {
  return { kind: "schema", type: "boolean", reference: boolean, expects: "boolean", async: !1, message: B, _run(L, K) {
    return typeof L.value == "boolean" ? L.typed = !0 : _addIssue(this, "type", L, K), L;
  } };
}
function enum_(B, L) {
  const K = Object.entries(B).filter(([W]) => isNaN(+W)).map(([, W]) => W);
  return { kind: "schema", type: "enum", reference: enum_, expects: K.map(_stringify).join(" | ") || "never", async: !1, enum: B, options: K, message: L, _run(W, V) {
    return this.options.includes(W.value) ? W.typed = !0 : _addIssue(this, "type", W, V), W;
  } };
}
function literal(B, L) {
  return { kind: "schema", type: "literal", reference: literal, expects: _stringify(B), async: !1, literal: B, message: L, _run(K, W) {
    return K.value === this.literal ? K.typed = !0 : _addIssue(this, "type", K, W), K;
  } };
}
function looseObject(B, L) {
  return { kind: "schema", type: "loose_object", reference: looseObject, expects: "Object", async: !1, entries: B, message: L, _run(K, W) {
    var J;
    const V = K.value;
    if (V && typeof V == "object") {
      K.typed = !0, K.value = {};
      for (const re in this.entries) {
        const ie = V[re], ne = this.entries[re]._run({ typed: !1, value: ie }, W);
        if (ne.issues) {
          const oe = { type: "object", origin: "value", input: V, key: re, value: ie };
          for (const ce of ne.issues) ce.path ? ce.path.unshift(oe) : ce.path = [oe], (J = K.issues) == null || J.push(ce);
          if (K.issues || (K.issues = ne.issues), W.abortEarly) {
            K.typed = !1;
            break;
          }
        }
        ne.typed || (K.typed = !1), (ne.value !== void 0 || re in V) && (K.value[re] = ne.value);
      }
      if (!K.issues || !W.abortEarly) for (const re in V) _isValidObjectKey(V, re) && !(re in this.entries) && (K.value[re] = V[re]);
    } else _addIssue(this, "type", K, W);
    return K;
  } };
}
function nonOptional(B, L) {
  return { kind: "schema", type: "non_optional", reference: nonOptional, expects: "!undefined", async: !1, wrapped: B, message: L, _run(K, W) {
    return K.value === void 0 ? (_addIssue(this, "type", K, W), K) : this.wrapped._run(K, W);
  } };
}
function null_(B) {
  return { kind: "schema", type: "null", reference: null_, expects: "null", async: !1, message: B, _run(L, K) {
    return L.value === null ? L.typed = !0 : _addIssue(this, "type", L, K), L;
  } };
}
function nullish(B, ...L) {
  const K = { kind: "schema", type: "nullish", reference: nullish, expects: `${B.expects} | null | undefined`, async: !1, wrapped: B, _run(W, V) {
    return W.value !== null && W.value !== void 0 || ("default" in this && (W.value = getDefault(this, W, V)), W.value !== null && W.value !== void 0) ? this.wrapped._run(W, V) : (W.typed = !0, W);
  } };
  return 0 in L && (K.default = L[0]), K;
}
function number(B) {
  return { kind: "schema", type: "number", reference: number, expects: "number", async: !1, message: B, _run(L, K) {
    return typeof L.value != "number" || isNaN(L.value) ? _addIssue(this, "type", L, K) : L.typed = !0, L;
  } };
}
function object(B, L) {
  return { kind: "schema", type: "object", reference: object, expects: "Object", async: !1, entries: B, message: L, _run(K, W) {
    var J;
    const V = K.value;
    if (V && typeof V == "object") {
      K.typed = !0, K.value = {};
      for (const re in this.entries) {
        const ie = V[re], ne = this.entries[re]._run({ typed: !1, value: ie }, W);
        if (ne.issues) {
          const oe = { type: "object", origin: "value", input: V, key: re, value: ie };
          for (const ce of ne.issues) ce.path ? ce.path.unshift(oe) : ce.path = [oe], (J = K.issues) == null || J.push(ce);
          if (K.issues || (K.issues = ne.issues), W.abortEarly) {
            K.typed = !1;
            break;
          }
        }
        ne.typed || (K.typed = !1), (ne.value !== void 0 || re in V) && (K.value[re] = ne.value);
      }
    } else _addIssue(this, "type", K, W);
    return K;
  } };
}
function optional(B, ...L) {
  const K = { kind: "schema", type: "optional", reference: optional, expects: `${B.expects} | undefined`, async: !1, wrapped: B, _run(W, V) {
    return W.value === void 0 && ("default" in this && (W.value = getDefault(this, W, V)), W.value === void 0) ? (W.typed = !0, W) : this.wrapped._run(W, V);
  } };
  return 0 in L && (K.default = L[0]), K;
}
function picklist(B, L) {
  return { kind: "schema", type: "picklist", reference: picklist, expects: B.map(_stringify).join(" | ") || "never", async: !1, options: B, message: L, _run(K, W) {
    return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, W), K;
  } };
}
function string(B) {
  return { kind: "schema", type: "string", reference: string, expects: "string", async: !1, message: B, _run(L, K) {
    return typeof L.value == "string" ? L.typed = !0 : _addIssue(this, "type", L, K), L;
  } };
}
function undefined_(B) {
  return { kind: "schema", type: "undefined", reference: undefined_, expects: "undefined", async: !1, message: B, _run(L, K) {
    return L.value === void 0 ? L.typed = !0 : _addIssue(this, "type", L, K), L;
  } };
}
function _subIssues(B) {
  let L;
  if (B) for (const K of B) L ? L.push(...K.issues) : L = K.issues;
  return L;
}
function union(B, L) {
  return { kind: "schema", type: "union", reference: union, expects: [...new Set(B.map((K) => K.expects))].join(" | ") || "never", async: !1, options: B, message: L, _run(K, W) {
    let V, J, re;
    for (const ie of this.options) {
      const ne = ie._run({ typed: !1, value: K.value }, W);
      if (ne.typed) {
        if (!ne.issues) {
          V = ne;
          break;
        }
        J ? J.push(ne) : J = [ne];
      } else re ? re.push(ne) : re = [ne];
    }
    if (V) return V;
    if (J) {
      if (J.length === 1) return J[0];
      _addIssue(this, "type", K, W, { issues: _subIssues(J) }), K.typed = !0;
    } else {
      if ((re == null ? void 0 : re.length) === 1) return re[0];
      _addIssue(this, "type", K, W, { issues: _subIssues(re) });
    }
    return K;
  } };
}
function unknown() {
  return { kind: "schema", type: "unknown", reference: unknown, expects: "unknown", async: !1, _run: (B) => (B.typed = !0, B) };
}
Symbol$1 && Symbol$1.isConcatSpreadable, getNative(root, "Map"), getNative(Object, "create");
var lib = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength, base64Js.toByteArray = toByteArray, base64Js.fromByteArray = fromByteArray;
for (var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
function getLens(B) {
  var L = B.length;
  if (L % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  var K = B.indexOf("=");
  return K === -1 && (K = L), [K, K === L ? 0 : 4 - K % 4];
}
function byteLength(B) {
  var L = getLens(B), K = L[0], W = L[1];
  return 3 * (K + W) / 4 - W;
}
function _byteLength(B, L, K) {
  return 3 * (L + K) / 4 - K;
}
function toByteArray(B) {
  var L, K, W = getLens(B), V = W[0], J = W[1], re = new Arr(_byteLength(B, V, J)), ie = 0, ne = J > 0 ? V - 4 : V;
  for (K = 0; K < ne; K += 4) L = revLookup[B.charCodeAt(K)] << 18 | revLookup[B.charCodeAt(K + 1)] << 12 | revLookup[B.charCodeAt(K + 2)] << 6 | revLookup[B.charCodeAt(K + 3)], re[ie++] = L >> 16 & 255, re[ie++] = L >> 8 & 255, re[ie++] = 255 & L;
  return J === 2 && (L = revLookup[B.charCodeAt(K)] << 2 | revLookup[B.charCodeAt(K + 1)] >> 4, re[ie++] = 255 & L), J === 1 && (L = revLookup[B.charCodeAt(K)] << 10 | revLookup[B.charCodeAt(K + 1)] << 4 | revLookup[B.charCodeAt(K + 2)] >> 2, re[ie++] = L >> 8 & 255, re[ie++] = 255 & L), re;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[63 & B];
}
function encodeChunk(B, L, K) {
  for (var W, V = [], J = L; J < K; J += 3) W = (B[J] << 16 & 16711680) + (B[J + 1] << 8 & 65280) + (255 & B[J + 2]), V.push(tripletToBase64(W));
  return V.join("");
}
function fromByteArray(B) {
  for (var L, K = B.length, W = K % 3, V = [], J = 16383, re = 0, ie = K - W; re < ie; re += J) V.push(encodeChunk(B, re, re + J > ie ? ie : re + J));
  return W === 1 ? (L = B[K - 1], V.push(lookup[L >> 2] + lookup[L << 4 & 63] + "==")) : W === 2 && (L = (B[K - 2] << 8) + B[K - 1], V.push(lookup[L >> 10] + lookup[L >> 4 & 63] + lookup[L << 2 & 63] + "=")), V.join("");
}
revLookup[45] = 62, revLookup[95] = 63, Object.defineProperty(base64Url, "__esModule", { value: !0 }), base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
function encode(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
function decode$1(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.pad = pad, base64Url.escape = escape, base64Url.unescape = unescape, base64Url.encode = encode, base64Url.decode = decode$1;
var cryptoClients = {}, secp256k1 = {}, ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 }), ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 == 0 ? 0 : 1);
}
const paramBytesForAlg = { ES256: getParamSize(256), ES384: getParamSize(384), ES512: getParamSize(521) };
function getParamBytesForAlg(B) {
  const L = paramBytesForAlg[B];
  if (L) return L;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array) return B;
  if (typeof B == "string") return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, L) {
  const K = signatureAsBytes(B), W = getParamBytesForAlg(L), V = W + 1, J = K.length;
  let re = 0;
  if (K[re++] !== ENCODED_TAG_SEQ) throw new Error('Could not find expected "seq"');
  let ie = K[re++];
  if (ie === (1 | MAX_OCTET) && (ie = K[re++]), J - re < ie) throw new Error(`"seq" specified length of "${ie}", only "${J - re}" remaining`);
  if (K[re++] !== ENCODED_TAG_INT) throw new Error('Could not find expected "int" for "r"');
  const ne = K[re++];
  if (J - re - 2 < ne) throw new Error(`"r" specified length of "${ne}", only "${J - re - 2}" available`);
  if (V < ne) throw new Error(`"r" specified length of "${ne}", max of "${V}" is acceptable`);
  const oe = re;
  if (re += ne, K[re++] !== ENCODED_TAG_INT) throw new Error('Could not find expected "int" for "s"');
  const ce = K[re++];
  if (J - re !== ce) throw new Error(`"s" specified length of "${ce}", expected "${J - re}"`);
  if (V < ce) throw new Error(`"s" specified length of "${ce}", max of "${V}" is acceptable`);
  const pe = re;
  if (re += ce, re !== J) throw new Error(`Expected to consume entire array, but "${J - re}" bytes remain`);
  const ke = W - ne, ot = W - ce, at = new Uint8Array(ke + ne + ot + ce);
  for (re = 0; re < ke; ++re) at[re] = 0;
  at.set(K.subarray(oe + Math.max(-ke, 0), oe + ne), re), re = W;
  for (const ft = re; re < ft + ot; ++re) at[re] = 0;
  return at.set(K.subarray(pe + Math.max(-ot, 0), pe + ce), re), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(at));
}
function countPadding(B, L, K) {
  let W = 0;
  for (; L + W < K && B[L + W] === 0; ) ++W;
  return B[L + W] >= MAX_OCTET && --W, W;
}
function joseToDer(B, L) {
  B = signatureAsBytes(B);
  const K = getParamBytesForAlg(L), W = B.length;
  if (W !== 2 * K) throw new TypeError(`"${L}" signatures must be "${2 * K}" bytes, saw "${W}"`);
  const V = countPadding(B, 0, K), J = countPadding(B, K, B.length), re = K - V, ie = K - J, ne = 2 + re + 1 + 1 + ie, oe = ne < MAX_OCTET, ce = new Uint8Array((oe ? 2 : 3) + ne);
  let pe = 0;
  return ce[pe++] = ENCODED_TAG_SEQ, oe ? ce[pe++] = ne : (ce[pe++] = 1 | MAX_OCTET, ce[pe++] = 255 & ne), ce[pe++] = ENCODED_TAG_INT, ce[pe++] = re, V < 0 ? (ce[pe++] = 0, ce.set(B.subarray(0, K), pe), pe += K) : (ce.set(B.subarray(V, K), pe), pe += K - V), ce[pe++] = ENCODED_TAG_INT, ce[pe++] = ie, J < 0 ? (ce[pe++] = 0, ce.set(B.subarray(K), pe)) : ce.set(B.subarray(K + J), pe), ce;
}
ecdsaSigFormatter.derToJose = derToJose, ecdsaSigFormatter.joseToDer = joseToDer;
var errors = {};
Object.defineProperty(errors, "__esModule", { value: !0 }), errors.InvalidTokenError = errors.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(L) {
    super(), this.name = "MissingParametersError", this.message = L || "";
  }
}
errors.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(L) {
    super(), this.name = "InvalidTokenError", this.message = L || "";
  }
}
errors.InvalidTokenError = InvalidTokenError, Object.defineProperty(secp256k1, "__esModule", { value: !0 }), secp256k1.SECP256K1Client = void 0;
const hmac_1 = hmac$2, sha256_1$3 = sha256$5, secp = lib$1, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors, utils_1 = utils$5;
secp.utils.hmacSha256Sync = (B, ...L) => {
  const K = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return L.forEach((W) => K.update(W)), K.digest();
};
class SECP256K1Client {
  static derivePublicKey(L, K = !0) {
    return L.length === 66 && (L = L.slice(0, 64)), L.length < 64 && (L = L.padStart(64, "0")), (0, utils_1.bytesToHex)(secp.getPublicKey(L, K));
  }
  static signHash(L, K, W = "jose") {
    if (!L || !K) throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const V = secp.signSync(L, K.slice(0, 64), { der: !0, canonical: !1 });
    if (W === "der") return (0, utils_1.bytesToHex)(V);
    if (W === "jose") return (0, ecdsaSigFormatter_1.derToJose)(V, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(L) {
    return (0, ecdsaSigFormatter_1.joseToDer)(L, "ES256");
  }
  static verifyHash(L, K, W) {
    if (!L || !K || !W) throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(K, L, W, { strict: !1 });
  }
}
secp256k1.SECP256K1Client = SECP256K1Client, SECP256K1Client.algorithmName = "ES256K", function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const L = secp256k1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return L.SECP256K1Client;
  } });
  const K = { ES256K: L.SECP256K1Client };
  B.cryptoClients = K;
}(cryptoClients);
var sha256 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, L, K, W) {
  return new (K || (K = Promise))(function(V, J) {
    function re(oe) {
      try {
        ne(W.next(oe));
      } catch (ce) {
        J(ce);
      }
    }
    function ie(oe) {
      try {
        ne(W.throw(oe));
      } catch (ce) {
        J(ce);
      }
    }
    function ne(oe) {
      oe.done ? V(oe.value) : function(ce) {
        return ce instanceof K ? ce : new K(function(pe) {
          pe(ce);
        });
      }(oe.value).then(re, ie);
    }
    ne((W = W.apply(B, L || [])).next());
  });
};
Object.defineProperty(sha256, "__esModule", { value: !0 }), sha256.hashSha256Async = sha256.hashSha256 = void 0;
const sha256_1$2 = sha256$5;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && crypto.subtle !== void 0) {
        const L = typeof B == "string" ? new TextEncoder().encode(B) : B, K = yield crypto.subtle.digest("SHA-256", L);
        return new Uint8Array(K);
      }
      {
        const L = requireCryptoBrowserify();
        if (!L.createHash) throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(L.createHash("sha256").update(B).digest());
      }
    } catch {
      return Promise.resolve(hashSha256(B));
    }
  });
}
sha256.hashSha256 = hashSha256, sha256.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, L, K, W) {
  return new (K || (K = Promise))(function(V, J) {
    function re(oe) {
      try {
        ne(W.next(oe));
      } catch (ce) {
        J(ce);
      }
    }
    function ie(oe) {
      try {
        ne(W.throw(oe));
      } catch (ce) {
        J(ce);
      }
    }
    function ne(oe) {
      oe.done ? V(oe.value) : function(ce) {
        return ce instanceof K ? ce : new K(function(pe) {
          pe(ce);
        });
      }(oe.value).then(re, ie);
    }
    ne((W = W.apply(B, L || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 }), signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors, sha256_1$1 = sha256;
function createSigningInput(B, L) {
  const K = [], W = base64url$2.encode(JSON.stringify(L));
  K.push(W);
  const V = base64url$2.encode(JSON.stringify(B));
  return K.push(V), K.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(L, K) {
    if (!L || !K) throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof L != "string") throw new Error("signing algorithm parameter must be a string");
    if (L = L.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(L)) throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[L], this.rawPrivateKey = K;
  }
  header(L = {}) {
    const K = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, K, L);
  }
  sign(L, K = !1, W = {}) {
    const V = this.header(W), J = createSigningInput(L, V), re = (0, sha256_1$1.hashSha256)(J);
    return this.createWithSignedHash(L, K, V, J, re);
  }
  signAsync(L, K = !1, W = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const V = this.header(W), J = createSigningInput(L, V), re = yield (0, sha256_1$1.hashSha256Async)(J);
      return this.createWithSignedHash(L, K, V, J, re);
    });
  }
  createWithSignedHash(L, K, W, V, J) {
    const re = this.cryptoClient.signHash(J, this.rawPrivateKey);
    return K ? { header: [base64url$2.encode(JSON.stringify(W))], payload: JSON.stringify(L), signature: [re] } : [V, re].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 }), verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors, sha256_1 = sha256;
class TokenVerifier {
  constructor(L, K) {
    if (!L || !K) throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof L != "string") throw "signing algorithm parameter must be a string";
    if (L = L.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(L)) throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[L], this.rawPublicKey = K;
  }
  verify(L) {
    return typeof L == "string" ? this.verifyCompact(L, !1) : typeof L == "object" && this.verifyExpanded(L, !1);
  }
  verifyAsync(L) {
    return typeof L == "string" ? this.verifyCompact(L, !0) : typeof L == "object" ? this.verifyExpanded(L, !0) : Promise.resolve(!1);
  }
  verifyCompact(L, K) {
    const W = L.split("."), V = W[0] + "." + W[1], J = (re) => {
      const ie = this.cryptoClient.loadSignature(W[2]);
      return this.cryptoClient.verifyHash(re, ie, this.rawPublicKey);
    };
    if (K) return (0, sha256_1.hashSha256Async)(V).then((re) => J(re));
    {
      const re = (0, sha256_1.hashSha256)(V);
      return J(re);
    }
  }
  verifyExpanded(L, K) {
    const W = [L.header.join("."), base64url$1.encode(L.payload)].join(".");
    let V = !0;
    const J = (re) => (L.signature.map((ie) => {
      const ne = this.cryptoClient.loadSignature(ie);
      this.cryptoClient.verifyHash(re, ne, this.rawPublicKey) || (V = !1);
    }), V);
    if (K) return (0, sha256_1.hashSha256Async)(W).then((re) => J(re));
    {
      const re = (0, sha256_1.hashSha256)(W);
      return J(re);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode = {};
Object.defineProperty(decode, "__esModule", { value: !0 }), decode.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const L = B.split(".");
    return { header: JSON.parse(base64url.decode(L[0])), payload: JSON.parse(base64url.decode(L[1])), signature: L[2] };
  }
  if (typeof B == "object") {
    if (typeof B.payload != "string") throw new Error("Expected token payload to be a base64 or json string");
    let L = B.payload;
    B.payload[0] !== "{" && (L = base64url.decode(L));
    const K = [];
    return B.header.map((W) => {
      const V = JSON.parse(base64url.decode(W));
      K.push(V);
    }), { header: K, payload: JSON.parse(L), signature: B.signature };
  }
}
decode.decodeToken = decodeToken, function(B) {
  var L = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(W, V, J, re) {
    re === void 0 && (re = J);
    var ie = Object.getOwnPropertyDescriptor(V, J);
    ie && !("get" in ie ? !V.__esModule : ie.writable || ie.configurable) || (ie = { enumerable: !0, get: function() {
      return V[J];
    } }), Object.defineProperty(W, re, ie);
  } : function(W, V, J, re) {
    re === void 0 && (re = J), W[re] = V[J];
  }), K = commonjsGlobal && commonjsGlobal.__exportStar || function(W, V) {
    for (var J in W) J === "default" || Object.prototype.hasOwnProperty.call(V, J) || L(V, W, J);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), K(signer, B), K(verifier, B), K(decode, B), K(errors, B), K(cryptoClients, B);
}(lib);
var accountChangeEventName = "accountChange";
object({ type: literal(accountChangeEventName) });
var networkChangeEventName = "networkChange";
async function getProviderOrThrow(B) {
  var K;
  const L = await (B == null ? void 0 : B()) || ((K = window.XverseProviders) == null ? void 0 : K.BitcoinProvider) || window.BitcoinProvider;
  if (!L) throw new Error("No Bitcoin wallet installed");
  return L;
}
object({ type: literal(networkChangeEventName) });
var BitcoinNetworkType = ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Signet = "Signet", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({ jsonrpc: literal("2.0"), method: string(), params: optional(union([array(unknown()), looseObject({}), null_()])), id: RpcIdSchema }), rpcSuccessResponseMessageSchema = object({ jsonrpc: literal("2.0"), result: nonOptional(unknown()), id: RpcIdSchema }), rpcErrorResponseMessageSchema = object({ jsonrpc: literal("2.0"), error: nonOptional(unknown()), id: RpcIdSchema });
union([rpcSuccessResponseMessageSchema, rpcErrorResponseMessageSchema]);
var AddressPurpose = ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({ address: string(), publicKey: string(), purpose: enum_(AddressPurpose), addressType: enum_(AddressType) }), getAddress = async (B) => {
  var W, V;
  const L = await getProviderOrThrow(B.getProvider), { purposes: K } = B.payload;
  if (!K) throw new Error("Address purposes are required");
  try {
    const J = lib.createUnsecuredToken(B.payload), re = await L.connect(J);
    (W = B.onFinish) == null || W.call(B, re);
  } catch {
    (V = B.onCancel) == null || V.call(B);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(object({ message: optional(string()) }));
object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(stxGetAddressesMethodName), params: stxGetAddressesParamsSchema, id: string() }).entries });
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({ transaction: string(), pubkey: optional(string()), broadcast: optional(boolean()) });
object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(stxSignTransactionMethodName), params: stxSignTransactionParamsSchema, id: string() }).entries });
var walletTypes = ["software", "ledger"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({ version: string(), methods: optional(array(string())), supports: array(string()) }), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getInfoMethodName), params: getInfoParamsSchema, id: string() }).entries });
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({ purposes: array(enum_(AddressPurpose)), message: optional(string()) });
object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getAddressesMethodName), params: getAddressesParamsSchema, id: string() }).entries });
var signMessageMethodName = "signMessage", MessageSigningProtocols = ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({ address: string(), message: string(), protocol: optional(enum_(MessageSigningProtocols)) });
object({ signature: string(), messageHash: string(), address: string(), protocol: enum_(MessageSigningProtocols) }), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(signMessageMethodName), params: signMessageParamsSchema, id: string() }).entries });
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({ purposes: array(enum_(AddressPurpose)), message: optional(string()) });
array(object({ ...addressSchema.entries, ...object({ walletType: walletTypeSchema }).entries })), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getAccountsMethodName), params: getAccountsParamsSchema, id: string() }).entries });
var getBalanceMethodName = "getBalance";
nullish(null_()), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getBalanceMethodName), id: string() }).entries });
var requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = undefined_();
literal(!0), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(requestPermissionsMethodName), params: requestPermissionsParamsSchema, id: string() }).entries });
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = undefined_();
literal(!0), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(renouncePermissionsMethodName), params: renouncePermissionsParamsSchema, id: string() }).entries });
var getWalletTypeMethodName = "wallet_getWalletType";
nullish(null_()), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getWalletTypeMethodName), id: string() }).entries });
var getRunesBalanceMethodName = "runes_getBalance", getRunesBalanceParamsSchema = nullish(null_());
object({ balances: array(object({ runeName: string(), amount: string(), divisibility: number(), symbol: string(), inscriptionId: nullish(string()) })) }), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getRunesBalanceMethodName), params: getRunesBalanceParamsSchema, id: string() }).entries });
var transferRunesMethodName = "runes_transfer", transferRunesParamsSchema = object({ recipients: array(object({ runeName: string(), amount: string(), address: string() })) });
object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(transferRunesMethodName), params: transferRunesParamsSchema, id: string() }).entries });
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({ offset: number(), limit: number() });
object({ total: number(), limit: number(), offset: number(), inscriptions: array(object({ inscriptionId: string(), inscriptionNumber: string(), address: string(), collectionName: optional(string()), postage: string(), contentLength: string(), contentType: string(), timestamp: number(), offset: number(), genesisTransaction: string(), output: string() })) }), object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(getInscriptionsMethodName), params: getInscriptionsParamsSchema, id: string() }).entries });
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({ transfers: array(object({ address: string(), inscriptionId: string() })) });
object({ ...rpcRequestMessageSchema.entries, ...object({ method: literal(sendInscriptionsMethodName), params: sendInscriptionsParamsSchema, id: string() }).entries });
var signMessage = async (B) => {
  var V, J;
  const L = await getProviderOrThrow(B.getProvider), { address: K, message: W } = B.payload;
  if (!K) throw new Error("An address is required to sign a message");
  if (!W) throw new Error("A message to be signed is required");
  try {
    const re = lib.createUnsecuredToken(B.payload), ie = await L.signMessage(re);
    (V = B.onFinish) == null || V.call(B, ie);
  } catch {
    (J = B.onCancel) == null || J.call(B);
  }
}, serializer = (B) => B.map((L) => {
  const { address: K, amountSats: W } = L;
  return { address: K, amountSats: W.toString() };
}), sendBtcTransaction = async (B) => {
  var re, ie;
  const L = await getProviderOrThrow(B.getProvider), { recipients: K, senderAddress: W, network: V, message: J } = B.payload;
  if (!K || K.length === 0) throw new Error("At least one recipient is required");
  if (K.some((ne) => typeof ne.address != "string" || typeof ne.amountSats != "bigint")) throw new Error("Incorrect recipient format");
  if (!W) throw new Error("The sender address is required");
  try {
    const ne = { network: V, senderAddress: W, message: J, recipients: serializer(K) }, oe = lib.createUnsecuredToken(ne), ce = await L.sendBtcTransaction(oe);
    (re = B.onFinish) == null || re.call(B, ce);
  } catch {
    (ie = B.onCancel) == null || ie.call(B);
  }
}, signTransaction = async (B) => {
  var V, J;
  const L = await getProviderOrThrow(B.getProvider), { psbtBase64: K, inputsToSign: W } = B.payload;
  if (!K) throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!W) throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const re = lib.createUnsecuredToken(B.payload), ie = await L.signTransaction(re);
    (V = B.onFinish) == null || V.call(B, ie);
  } catch {
    (J = B.onCancel) == null || J.call(B);
  }
}, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var L, K, W, V, J, re, ie, ne, oe, ce, pe = ht.prototype = { constructor: ht, toString: null, valueOf: null }, ke = new ht(1), ot = 20, at = 4, ft = -7, dt = 21, lt = -1e7, yt = 1e7, St = !1, mt = 1, $t = 0, It = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, Ut = "0123456789abcdefghijklmnopqrstuvwxyz", ut = !0;
  function ht(Oe, ct) {
    var pt, gt, vt, Bt, kt, wt, Et, Rt, Mt = this;
    if (!(Mt instanceof ht)) return new ht(Oe, ct);
    if (ct == null) {
      if (Oe && Oe._isBigNumber === !0) return Mt.s = Oe.s, void (!Oe.c || Oe.e > yt ? Mt.c = Mt.e = null : Oe.e < lt ? Mt.c = [Mt.e = 0] : (Mt.e = Oe.e, Mt.c = Oe.c.slice()));
      if ((wt = typeof Oe == "number") && 0 * Oe == 0) {
        if (Mt.s = 1 / Oe < 0 ? (Oe = -Oe, -1) : 1, Oe === ~~Oe) {
          for (Bt = 0, kt = Oe; kt >= 10; kt /= 10, Bt++) ;
          return void (Bt > yt ? Mt.c = Mt.e = null : (Mt.e = Bt, Mt.c = [Oe]));
        }
        Rt = String(Oe);
      } else {
        if (!isNumeric.test(Rt = String(Oe))) return W(Mt, Rt, wt);
        Mt.s = Rt.charCodeAt(0) == 45 ? (Rt = Rt.slice(1), -1) : 1;
      }
      (Bt = Rt.indexOf(".")) > -1 && (Rt = Rt.replace(".", "")), (kt = Rt.search(/e/i)) > 0 ? (Bt < 0 && (Bt = kt), Bt += +Rt.slice(kt + 1), Rt = Rt.substring(0, kt)) : Bt < 0 && (Bt = Rt.length);
    } else {
      if (intCheck(ct, 2, Ut.length, "Base"), ct == 10 && ut) return it(Mt = new ht(Oe), ot + Mt.e + 1, at);
      if (Rt = String(Oe), wt = typeof Oe == "number") {
        if (0 * Oe != 0) return W(Mt, Rt, wt, ct);
        if (Mt.s = 1 / Oe < 0 ? (Rt = Rt.slice(1), -1) : 1, ht.DEBUG && Rt.replace(/^0\.0*|\./, "").length > 15) throw Error(tooManyDigits + Oe);
      } else Mt.s = Rt.charCodeAt(0) === 45 ? (Rt = Rt.slice(1), -1) : 1;
      for (pt = Ut.slice(0, ct), Bt = kt = 0, Et = Rt.length; kt < Et; kt++) if (pt.indexOf(gt = Rt.charAt(kt)) < 0) {
        if (gt == ".") {
          if (kt > Bt) {
            Bt = Et;
            continue;
          }
        } else if (!vt && (Rt == Rt.toUpperCase() && (Rt = Rt.toLowerCase()) || Rt == Rt.toLowerCase() && (Rt = Rt.toUpperCase()))) {
          vt = !0, kt = -1, Bt = 0;
          continue;
        }
        return W(Mt, String(Oe), wt, ct);
      }
      wt = !1, (Bt = (Rt = K(Rt, ct, 10, Mt.s)).indexOf(".")) > -1 ? Rt = Rt.replace(".", "") : Bt = Rt.length;
    }
    for (kt = 0; Rt.charCodeAt(kt) === 48; kt++) ;
    for (Et = Rt.length; Rt.charCodeAt(--Et) === 48; ) ;
    if (Rt = Rt.slice(kt, ++Et)) {
      if (Et -= kt, wt && ht.DEBUG && Et > 15 && (Oe > MAX_SAFE_INTEGER || Oe !== mathfloor(Oe))) throw Error(tooManyDigits + Mt.s * Oe);
      if ((Bt = Bt - kt - 1) > yt) Mt.c = Mt.e = null;
      else if (Bt < lt) Mt.c = [Mt.e = 0];
      else {
        if (Mt.e = Bt, Mt.c = [], kt = (Bt + 1) % LOG_BASE, Bt < 0 && (kt += LOG_BASE), kt < Et) {
          for (kt && Mt.c.push(+Rt.slice(0, kt)), Et -= LOG_BASE; kt < Et; ) Mt.c.push(+Rt.slice(kt, kt += LOG_BASE));
          kt = LOG_BASE - (Rt = Rt.slice(kt)).length;
        } else kt -= Et;
        for (; kt--; Rt += "0") ;
        Mt.c.push(+Rt);
      }
    } else Mt.c = [Mt.e = 0];
  }
  function Ce(Oe, ct, pt, gt) {
    var vt, Bt, kt, wt, Et;
    if (pt == null ? pt = at : intCheck(pt, 0, 8), !Oe.c) return Oe.toString();
    if (vt = Oe.c[0], kt = Oe.e, ct == null) Et = coeffToString(Oe.c), Et = gt == 1 || gt == 2 && (kt <= ft || kt >= dt) ? toExponential(Et, kt) : toFixedPoint(Et, kt, "0");
    else if (Bt = (Oe = it(new ht(Oe), ct, pt)).e, wt = (Et = coeffToString(Oe.c)).length, gt == 1 || gt == 2 && (ct <= Bt || Bt <= ft)) {
      for (; wt < ct; Et += "0", wt++) ;
      Et = toExponential(Et, Bt);
    } else if (ct -= kt, Et = toFixedPoint(Et, Bt, "0"), Bt + 1 > wt) {
      if (--ct > 0) for (Et += "."; ct--; Et += "0") ;
    } else if ((ct += Bt - wt) > 0) for (Bt + 1 == wt && (Et += "."); ct--; Et += "0") ;
    return Oe.s < 0 && vt ? "-" + Et : Et;
  }
  function nt(Oe, ct) {
    for (var pt, gt, vt = 1, Bt = new ht(Oe[0]); vt < Oe.length; vt++) (!(gt = new ht(Oe[vt])).s || (pt = compare(Bt, gt)) === ct || pt === 0 && Bt.s === ct) && (Bt = gt);
    return Bt;
  }
  function rt(Oe, ct, pt) {
    for (var gt = 1, vt = ct.length; !ct[--vt]; ct.pop()) ;
    for (vt = ct[0]; vt >= 10; vt /= 10, gt++) ;
    return (pt = gt + pt * LOG_BASE - 1) > yt ? Oe.c = Oe.e = null : pt < lt ? Oe.c = [Oe.e = 0] : (Oe.e = pt, Oe.c = ct), Oe;
  }
  function it(Oe, ct, pt, gt) {
    var vt, Bt, kt, wt, Et, Rt, Mt, Ht = Oe.c, Kt = POWS_TEN;
    if (Ht) {
      e: {
        for (vt = 1, wt = Ht[0]; wt >= 10; wt /= 10, vt++) ;
        if ((Bt = ct - vt) < 0) Bt += LOG_BASE, kt = ct, Et = Ht[Rt = 0], Mt = mathfloor(Et / Kt[vt - kt - 1] % 10);
        else if ((Rt = mathceil((Bt + 1) / LOG_BASE)) >= Ht.length) {
          if (!gt) break e;
          for (; Ht.length <= Rt; Ht.push(0)) ;
          Et = Mt = 0, vt = 1, kt = (Bt %= LOG_BASE) - LOG_BASE + 1;
        } else {
          for (Et = wt = Ht[Rt], vt = 1; wt >= 10; wt /= 10, vt++) ;
          Mt = (kt = (Bt %= LOG_BASE) - LOG_BASE + vt) < 0 ? 0 : mathfloor(Et / Kt[vt - kt - 1] % 10);
        }
        if (gt = gt || ct < 0 || Ht[Rt + 1] != null || (kt < 0 ? Et : Et % Kt[vt - kt - 1]), gt = pt < 4 ? (Mt || gt) && (pt == 0 || pt == (Oe.s < 0 ? 3 : 2)) : Mt > 5 || Mt == 5 && (pt == 4 || gt || pt == 6 && (Bt > 0 ? kt > 0 ? Et / Kt[vt - kt] : 0 : Ht[Rt - 1]) % 10 & 1 || pt == (Oe.s < 0 ? 8 : 7)), ct < 1 || !Ht[0]) return Ht.length = 0, gt ? (ct -= Oe.e + 1, Ht[0] = Kt[(LOG_BASE - ct % LOG_BASE) % LOG_BASE], Oe.e = -ct || 0) : Ht[0] = Oe.e = 0, Oe;
        if (Bt == 0 ? (Ht.length = Rt, wt = 1, Rt--) : (Ht.length = Rt + 1, wt = Kt[LOG_BASE - Bt], Ht[Rt] = kt > 0 ? mathfloor(Et / Kt[vt - kt] % Kt[kt]) * wt : 0), gt) for (; ; ) {
          if (Rt == 0) {
            for (Bt = 1, kt = Ht[0]; kt >= 10; kt /= 10, Bt++) ;
            for (kt = Ht[0] += wt, wt = 1; kt >= 10; kt /= 10, wt++) ;
            Bt != wt && (Oe.e++, Ht[0] == BASE && (Ht[0] = 1));
            break;
          }
          if (Ht[Rt] += wt, Ht[Rt] != BASE) break;
          Ht[Rt--] = 0, wt = 1;
        }
        for (Bt = Ht.length; Ht[--Bt] === 0; Ht.pop()) ;
      }
      Oe.e > yt ? Oe.c = Oe.e = null : Oe.e < lt && (Oe.c = [Oe.e = 0]);
    }
    return Oe;
  }
  function st(Oe) {
    var ct, pt = Oe.e;
    return pt === null ? Oe.toString() : (ct = coeffToString(Oe.c), ct = pt <= ft || pt >= dt ? toExponential(ct, pt) : toFixedPoint(ct, pt, "0"), Oe.s < 0 ? "-" + ct : ct);
  }
  return ht.clone = clone, ht.ROUND_UP = 0, ht.ROUND_DOWN = 1, ht.ROUND_CEIL = 2, ht.ROUND_FLOOR = 3, ht.ROUND_HALF_UP = 4, ht.ROUND_HALF_DOWN = 5, ht.ROUND_HALF_EVEN = 6, ht.ROUND_HALF_CEIL = 7, ht.ROUND_HALF_FLOOR = 8, ht.EUCLID = 9, ht.config = ht.set = function(Oe) {
    var ct, pt;
    if (Oe != null) {
      if (typeof Oe != "object") throw Error(bignumberError + "Object expected: " + Oe);
      if (Oe.hasOwnProperty(ct = "DECIMAL_PLACES") && (intCheck(pt = Oe[ct], 0, MAX, ct), ot = pt), Oe.hasOwnProperty(ct = "ROUNDING_MODE") && (intCheck(pt = Oe[ct], 0, 8, ct), at = pt), Oe.hasOwnProperty(ct = "EXPONENTIAL_AT") && ((pt = Oe[ct]) && pt.pop ? (intCheck(pt[0], -MAX, 0, ct), intCheck(pt[1], 0, MAX, ct), ft = pt[0], dt = pt[1]) : (intCheck(pt, -MAX, MAX, ct), ft = -(dt = pt < 0 ? -pt : pt))), Oe.hasOwnProperty(ct = "RANGE")) if ((pt = Oe[ct]) && pt.pop) intCheck(pt[0], -MAX, -1, ct), intCheck(pt[1], 1, MAX, ct), lt = pt[0], yt = pt[1];
      else {
        if (intCheck(pt, -MAX, MAX, ct), !pt) throw Error(bignumberError + ct + " cannot be zero: " + pt);
        lt = -(yt = pt < 0 ? -pt : pt);
      }
      if (Oe.hasOwnProperty(ct = "CRYPTO")) {
        if ((pt = Oe[ct]) !== !!pt) throw Error(bignumberError + ct + " not true or false: " + pt);
        if (pt) {
          if (typeof crypto > "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw St = !pt, Error(bignumberError + "crypto unavailable");
          St = pt;
        } else St = pt;
      }
      if (Oe.hasOwnProperty(ct = "MODULO_MODE") && (intCheck(pt = Oe[ct], 0, 9, ct), mt = pt), Oe.hasOwnProperty(ct = "POW_PRECISION") && (intCheck(pt = Oe[ct], 0, MAX, ct), $t = pt), Oe.hasOwnProperty(ct = "FORMAT")) {
        if (typeof (pt = Oe[ct]) != "object") throw Error(bignumberError + ct + " not an object: " + pt);
        It = pt;
      }
      if (Oe.hasOwnProperty(ct = "ALPHABET")) {
        if (typeof (pt = Oe[ct]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(pt)) throw Error(bignumberError + ct + " invalid: " + pt);
        ut = pt.slice(0, 10) == "0123456789", Ut = pt;
      }
    }
    return { DECIMAL_PLACES: ot, ROUNDING_MODE: at, EXPONENTIAL_AT: [ft, dt], RANGE: [lt, yt], CRYPTO: St, MODULO_MODE: mt, POW_PRECISION: $t, FORMAT: It, ALPHABET: Ut };
  }, ht.isBigNumber = function(Oe) {
    if (!Oe || Oe._isBigNumber !== !0) return !1;
    if (!ht.DEBUG) return !0;
    var ct, pt, gt = Oe.c, vt = Oe.e, Bt = Oe.s;
    e: if ({}.toString.call(gt) == "[object Array]") {
      if ((Bt === 1 || Bt === -1) && vt >= -MAX && vt <= MAX && vt === mathfloor(vt)) {
        if (gt[0] === 0) {
          if (vt === 0 && gt.length === 1) return !0;
          break e;
        }
        if ((ct = (vt + 1) % LOG_BASE) < 1 && (ct += LOG_BASE), String(gt[0]).length == ct) {
          for (ct = 0; ct < gt.length; ct++) if ((pt = gt[ct]) < 0 || pt >= BASE || pt !== mathfloor(pt)) break e;
          if (pt !== 0) return !0;
        }
      }
    } else if (gt === null && vt === null && (Bt === null || Bt === 1 || Bt === -1)) return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Oe);
  }, ht.maximum = ht.max = function() {
    return nt(arguments, -1);
  }, ht.minimum = ht.min = function() {
    return nt(arguments, 1);
  }, ht.random = (V = 9007199254740992, J = Math.random() * V & 2097151 ? function() {
    return mathfloor(Math.random() * V);
  } : function() {
    return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
  }, function(Oe) {
    var ct, pt, gt, vt, Bt, kt = 0, wt = [], Et = new ht(ke);
    if (Oe == null ? Oe = ot : intCheck(Oe, 0, MAX), vt = mathceil(Oe / LOG_BASE), St) if (crypto.getRandomValues) {
      for (ct = crypto.getRandomValues(new Uint32Array(vt *= 2)); kt < vt; ) (Bt = 131072 * ct[kt] + (ct[kt + 1] >>> 11)) >= 9e15 ? (pt = crypto.getRandomValues(new Uint32Array(2)), ct[kt] = pt[0], ct[kt + 1] = pt[1]) : (wt.push(Bt % 1e14), kt += 2);
      kt = vt / 2;
    } else {
      if (!crypto.randomBytes) throw St = !1, Error(bignumberError + "crypto unavailable");
      for (ct = crypto.randomBytes(vt *= 7); kt < vt; ) (Bt = 281474976710656 * (31 & ct[kt]) + 1099511627776 * ct[kt + 1] + 4294967296 * ct[kt + 2] + 16777216 * ct[kt + 3] + (ct[kt + 4] << 16) + (ct[kt + 5] << 8) + ct[kt + 6]) >= 9e15 ? crypto.randomBytes(7).copy(ct, kt) : (wt.push(Bt % 1e14), kt += 7);
      kt = vt / 7;
    }
    if (!St) for (; kt < vt; ) (Bt = J()) < 9e15 && (wt[kt++] = Bt % 1e14);
    for (vt = wt[--kt], Oe %= LOG_BASE, vt && Oe && (Bt = POWS_TEN[LOG_BASE - Oe], wt[kt] = mathfloor(vt / Bt) * Bt); wt[kt] === 0; wt.pop(), kt--) ;
    if (kt < 0) wt = [gt = 0];
    else {
      for (gt = -1; wt[0] === 0; wt.splice(0, 1), gt -= LOG_BASE) ;
      for (kt = 1, Bt = wt[0]; Bt >= 10; Bt /= 10, kt++) ;
      kt < LOG_BASE && (gt -= LOG_BASE - kt);
    }
    return Et.e = gt, Et.c = wt, Et;
  }), ht.sum = function() {
    for (var Oe = 1, ct = arguments, pt = new ht(ct[0]); Oe < ct.length; ) pt = pt.plus(ct[Oe++]);
    return pt;
  }, K = /* @__PURE__ */ function() {
    var Oe = "0123456789";
    function ct(pt, gt, vt, Bt) {
      for (var kt, wt, Et = [0], Rt = 0, Mt = pt.length; Rt < Mt; ) {
        for (wt = Et.length; wt--; Et[wt] *= gt) ;
        for (Et[0] += Bt.indexOf(pt.charAt(Rt++)), kt = 0; kt < Et.length; kt++) Et[kt] > vt - 1 && (Et[kt + 1] == null && (Et[kt + 1] = 0), Et[kt + 1] += Et[kt] / vt | 0, Et[kt] %= vt);
      }
      return Et.reverse();
    }
    return function(pt, gt, vt, Bt, kt) {
      var wt, Et, Rt, Mt, Ht, Kt, jt, Wt, Yt = pt.indexOf("."), Xt = ot, ir = at;
      for (Yt >= 0 && (Mt = $t, $t = 0, pt = pt.replace(".", ""), Kt = (Wt = new ht(gt)).pow(pt.length - Yt), $t = Mt, Wt.c = ct(toFixedPoint(coeffToString(Kt.c), Kt.e, "0"), 10, vt, Oe), Wt.e = Wt.c.length), Rt = Mt = (jt = ct(pt, gt, vt, kt ? (wt = Ut, Oe) : (wt = Oe, Ut))).length; jt[--Mt] == 0; jt.pop()) ;
      if (!jt[0]) return wt.charAt(0);
      if (Yt < 0 ? --Rt : (Kt.c = jt, Kt.e = Rt, Kt.s = Bt, jt = (Kt = L(Kt, Wt, Xt, ir, vt)).c, Ht = Kt.r, Rt = Kt.e), Yt = jt[Et = Rt + Xt + 1], Mt = vt / 2, Ht = Ht || Et < 0 || jt[Et + 1] != null, Ht = ir < 4 ? (Yt != null || Ht) && (ir == 0 || ir == (Kt.s < 0 ? 3 : 2)) : Yt > Mt || Yt == Mt && (ir == 4 || Ht || ir == 6 && 1 & jt[Et - 1] || ir == (Kt.s < 0 ? 8 : 7)), Et < 1 || !jt[0]) pt = Ht ? toFixedPoint(wt.charAt(1), -Xt, wt.charAt(0)) : wt.charAt(0);
      else {
        if (jt.length = Et, Ht) for (--vt; ++jt[--Et] > vt; ) jt[Et] = 0, Et || (++Rt, jt = [1].concat(jt));
        for (Mt = jt.length; !jt[--Mt]; ) ;
        for (Yt = 0, pt = ""; Yt <= Mt; pt += wt.charAt(jt[Yt++])) ;
        pt = toFixedPoint(pt, Rt, wt.charAt(0));
      }
      return pt;
    };
  }(), L = /* @__PURE__ */ function() {
    function Oe(gt, vt, Bt) {
      var kt, wt, Et, Rt, Mt = 0, Ht = gt.length, Kt = vt % SQRT_BASE, jt = vt / SQRT_BASE | 0;
      for (gt = gt.slice(); Ht--; ) Mt = ((wt = Kt * (Et = gt[Ht] % SQRT_BASE) + (kt = jt * Et + (Rt = gt[Ht] / SQRT_BASE | 0) * Kt) % SQRT_BASE * SQRT_BASE + Mt) / Bt | 0) + (kt / SQRT_BASE | 0) + jt * Rt, gt[Ht] = wt % Bt;
      return Mt && (gt = [Mt].concat(gt)), gt;
    }
    function ct(gt, vt, Bt, kt) {
      var wt, Et;
      if (Bt != kt) Et = Bt > kt ? 1 : -1;
      else for (wt = Et = 0; wt < Bt; wt++) if (gt[wt] != vt[wt]) {
        Et = gt[wt] > vt[wt] ? 1 : -1;
        break;
      }
      return Et;
    }
    function pt(gt, vt, Bt, kt) {
      for (var wt = 0; Bt--; ) gt[Bt] -= wt, wt = gt[Bt] < vt[Bt] ? 1 : 0, gt[Bt] = wt * kt + gt[Bt] - vt[Bt];
      for (; !gt[0] && gt.length > 1; gt.splice(0, 1)) ;
    }
    return function(gt, vt, Bt, kt, wt) {
      var Et, Rt, Mt, Ht, Kt, jt, Wt, Yt, Xt, ir, ur, Qt, hr, pr, cr, vr, bt, At = gt.s == vt.s ? 1 : -1, Tt = gt.c, xt = vt.c;
      if (!(Tt && Tt[0] && xt && xt[0])) return new ht(gt.s && vt.s && (Tt ? !xt || Tt[0] != xt[0] : xt) ? Tt && Tt[0] == 0 || !xt ? 0 * At : At / 0 : NaN);
      for (Xt = (Yt = new ht(At)).c = [], At = Bt + (Rt = gt.e - vt.e) + 1, wt || (wt = BASE, Rt = bitFloor(gt.e / LOG_BASE) - bitFloor(vt.e / LOG_BASE), At = At / LOG_BASE | 0), Mt = 0; xt[Mt] == (Tt[Mt] || 0); Mt++) ;
      if (xt[Mt] > (Tt[Mt] || 0) && Rt--, At < 0) Xt.push(1), Ht = !0;
      else {
        for (pr = Tt.length, vr = xt.length, Mt = 0, At += 2, (Kt = mathfloor(wt / (xt[0] + 1))) > 1 && (xt = Oe(xt, Kt, wt), Tt = Oe(Tt, Kt, wt), vr = xt.length, pr = Tt.length), hr = vr, ur = (ir = Tt.slice(0, vr)).length; ur < vr; ir[ur++] = 0) ;
        bt = xt.slice(), bt = [0].concat(bt), cr = xt[0], xt[1] >= wt / 2 && cr++;
        do {
          if (Kt = 0, (Et = ct(xt, ir, vr, ur)) < 0) {
            if (Qt = ir[0], vr != ur && (Qt = Qt * wt + (ir[1] || 0)), (Kt = mathfloor(Qt / cr)) > 1) for (Kt >= wt && (Kt = wt - 1), Wt = (jt = Oe(xt, Kt, wt)).length, ur = ir.length; ct(jt, ir, Wt, ur) == 1; ) Kt--, pt(jt, vr < Wt ? bt : xt, Wt, wt), Wt = jt.length, Et = 1;
            else Kt == 0 && (Et = Kt = 1), Wt = (jt = xt.slice()).length;
            if (Wt < ur && (jt = [0].concat(jt)), pt(ir, jt, ur, wt), ur = ir.length, Et == -1) for (; ct(xt, ir, vr, ur) < 1; ) Kt++, pt(ir, vr < ur ? bt : xt, ur, wt), ur = ir.length;
          } else Et === 0 && (Kt++, ir = [0]);
          Xt[Mt++] = Kt, ir[0] ? ir[ur++] = Tt[hr] || 0 : (ir = [Tt[hr]], ur = 1);
        } while ((hr++ < pr || ir[0] != null) && At--);
        Ht = ir[0] != null, Xt[0] || Xt.splice(0, 1);
      }
      if (wt == BASE) {
        for (Mt = 1, At = Xt[0]; At >= 10; At /= 10, Mt++) ;
        it(Yt, Bt + (Yt.e = Mt + Rt * LOG_BASE - 1) + 1, kt, Ht);
      } else Yt.e = Rt, Yt.r = +Ht;
      return Yt;
    };
  }(), re = /^(-?)0([xbo])(?=\w[\w.]*$)/i, ie = /^([^.]+)\.$/, ne = /^\.([^.]+)$/, oe = /^-?(Infinity|NaN)$/, ce = /^\s*\+(?=[\w.])|^\s+|\s+$/g, W = function(Oe, ct, pt, gt) {
    var vt, Bt = pt ? ct : ct.replace(ce, "");
    if (oe.test(Bt)) Oe.s = isNaN(Bt) ? null : Bt < 0 ? -1 : 1;
    else {
      if (!pt && (Bt = Bt.replace(re, function(kt, wt, Et) {
        return vt = (Et = Et.toLowerCase()) == "x" ? 16 : Et == "b" ? 2 : 8, gt && gt != vt ? kt : wt;
      }), gt && (vt = gt, Bt = Bt.replace(ie, "$1").replace(ne, "0.$1")), ct != Bt)) return new ht(Bt, vt);
      if (ht.DEBUG) throw Error(bignumberError + "Not a" + (gt ? " base " + gt : "") + " number: " + ct);
      Oe.s = null;
    }
    Oe.c = Oe.e = null;
  }, pe.absoluteValue = pe.abs = function() {
    var Oe = new ht(this);
    return Oe.s < 0 && (Oe.s = 1), Oe;
  }, pe.comparedTo = function(Oe, ct) {
    return compare(this, new ht(Oe, ct));
  }, pe.decimalPlaces = pe.dp = function(Oe, ct) {
    var pt, gt, vt, Bt = this;
    if (Oe != null) return intCheck(Oe, 0, MAX), ct == null ? ct = at : intCheck(ct, 0, 8), it(new ht(Bt), Oe + Bt.e + 1, ct);
    if (!(pt = Bt.c)) return null;
    if (gt = ((vt = pt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, vt = pt[vt]) for (; vt % 10 == 0; vt /= 10, gt--) ;
    return gt < 0 && (gt = 0), gt;
  }, pe.dividedBy = pe.div = function(Oe, ct) {
    return L(this, new ht(Oe, ct), ot, at);
  }, pe.dividedToIntegerBy = pe.idiv = function(Oe, ct) {
    return L(this, new ht(Oe, ct), 0, 1);
  }, pe.exponentiatedBy = pe.pow = function(Oe, ct) {
    var pt, gt, vt, Bt, kt, wt, Et, Rt, Mt = this;
    if ((Oe = new ht(Oe)).c && !Oe.isInteger()) throw Error(bignumberError + "Exponent not an integer: " + st(Oe));
    if (ct != null && (ct = new ht(ct)), kt = Oe.e > 14, !Mt.c || !Mt.c[0] || Mt.c[0] == 1 && !Mt.e && Mt.c.length == 1 || !Oe.c || !Oe.c[0]) return Rt = new ht(Math.pow(+st(Mt), kt ? Oe.s * (2 - isOdd(Oe)) : +st(Oe))), ct ? Rt.mod(ct) : Rt;
    if (wt = Oe.s < 0, ct) {
      if (ct.c ? !ct.c[0] : !ct.s) return new ht(NaN);
      (gt = !wt && Mt.isInteger() && ct.isInteger()) && (Mt = Mt.mod(ct));
    } else {
      if (Oe.e > 9 && (Mt.e > 0 || Mt.e < -1 || (Mt.e == 0 ? Mt.c[0] > 1 || kt && Mt.c[1] >= 24e7 : Mt.c[0] < 8e13 || kt && Mt.c[0] <= 9999975e7))) return Bt = Mt.s < 0 && isOdd(Oe) ? -0 : 0, Mt.e > -1 && (Bt = 1 / Bt), new ht(wt ? 1 / Bt : Bt);
      $t && (Bt = mathceil($t / LOG_BASE + 2));
    }
    for (kt ? (pt = new ht(0.5), wt && (Oe.s = 1), Et = isOdd(Oe)) : Et = (vt = Math.abs(+st(Oe))) % 2, Rt = new ht(ke); ; ) {
      if (Et) {
        if (!(Rt = Rt.times(Mt)).c) break;
        Bt ? Rt.c.length > Bt && (Rt.c.length = Bt) : gt && (Rt = Rt.mod(ct));
      }
      if (vt) {
        if ((vt = mathfloor(vt / 2)) === 0) break;
        Et = vt % 2;
      } else if (it(Oe = Oe.times(pt), Oe.e + 1, 1), Oe.e > 14) Et = isOdd(Oe);
      else {
        if ((vt = +st(Oe)) == 0) break;
        Et = vt % 2;
      }
      Mt = Mt.times(Mt), Bt ? Mt.c && Mt.c.length > Bt && (Mt.c.length = Bt) : gt && (Mt = Mt.mod(ct));
    }
    return gt ? Rt : (wt && (Rt = ke.div(Rt)), ct ? Rt.mod(ct) : Bt ? it(Rt, $t, at, void 0) : Rt);
  }, pe.integerValue = function(Oe) {
    var ct = new ht(this);
    return Oe == null ? Oe = at : intCheck(Oe, 0, 8), it(ct, ct.e + 1, Oe);
  }, pe.isEqualTo = pe.eq = function(Oe, ct) {
    return compare(this, new ht(Oe, ct)) === 0;
  }, pe.isFinite = function() {
    return !!this.c;
  }, pe.isGreaterThan = pe.gt = function(Oe, ct) {
    return compare(this, new ht(Oe, ct)) > 0;
  }, pe.isGreaterThanOrEqualTo = pe.gte = function(Oe, ct) {
    return (ct = compare(this, new ht(Oe, ct))) === 1 || ct === 0;
  }, pe.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, pe.isLessThan = pe.lt = function(Oe, ct) {
    return compare(this, new ht(Oe, ct)) < 0;
  }, pe.isLessThanOrEqualTo = pe.lte = function(Oe, ct) {
    return (ct = compare(this, new ht(Oe, ct))) === -1 || ct === 0;
  }, pe.isNaN = function() {
    return !this.s;
  }, pe.isNegative = function() {
    return this.s < 0;
  }, pe.isPositive = function() {
    return this.s > 0;
  }, pe.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, pe.minus = function(Oe, ct) {
    var pt, gt, vt, Bt, kt = this, wt = kt.s;
    if (ct = (Oe = new ht(Oe, ct)).s, !wt || !ct) return new ht(NaN);
    if (wt != ct) return Oe.s = -ct, kt.plus(Oe);
    var Et = kt.e / LOG_BASE, Rt = Oe.e / LOG_BASE, Mt = kt.c, Ht = Oe.c;
    if (!Et || !Rt) {
      if (!Mt || !Ht) return Mt ? (Oe.s = -ct, Oe) : new ht(Ht ? kt : NaN);
      if (!Mt[0] || !Ht[0]) return Ht[0] ? (Oe.s = -ct, Oe) : new ht(Mt[0] ? kt : at == 3 ? -0 : 0);
    }
    if (Et = bitFloor(Et), Rt = bitFloor(Rt), Mt = Mt.slice(), wt = Et - Rt) {
      for ((Bt = wt < 0) ? (wt = -wt, vt = Mt) : (Rt = Et, vt = Ht), vt.reverse(), ct = wt; ct--; vt.push(0)) ;
      vt.reverse();
    } else for (gt = (Bt = (wt = Mt.length) < (ct = Ht.length)) ? wt : ct, wt = ct = 0; ct < gt; ct++) if (Mt[ct] != Ht[ct]) {
      Bt = Mt[ct] < Ht[ct];
      break;
    }
    if (Bt && (vt = Mt, Mt = Ht, Ht = vt, Oe.s = -Oe.s), (ct = (gt = Ht.length) - (pt = Mt.length)) > 0) for (; ct--; Mt[pt++] = 0) ;
    for (ct = BASE - 1; gt > wt; ) {
      if (Mt[--gt] < Ht[gt]) {
        for (pt = gt; pt && !Mt[--pt]; Mt[pt] = ct) ;
        --Mt[pt], Mt[gt] += BASE;
      }
      Mt[gt] -= Ht[gt];
    }
    for (; Mt[0] == 0; Mt.splice(0, 1), --Rt) ;
    return Mt[0] ? rt(Oe, Mt, Rt) : (Oe.s = at == 3 ? -1 : 1, Oe.c = [Oe.e = 0], Oe);
  }, pe.modulo = pe.mod = function(Oe, ct) {
    var pt, gt, vt = this;
    return Oe = new ht(Oe, ct), !vt.c || !Oe.s || Oe.c && !Oe.c[0] ? new ht(NaN) : !Oe.c || vt.c && !vt.c[0] ? new ht(vt) : (mt == 9 ? (gt = Oe.s, Oe.s = 1, pt = L(vt, Oe, 0, 3), Oe.s = gt, pt.s *= gt) : pt = L(vt, Oe, 0, mt), (Oe = vt.minus(pt.times(Oe))).c[0] || mt != 1 || (Oe.s = vt.s), Oe);
  }, pe.multipliedBy = pe.times = function(Oe, ct) {
    var pt, gt, vt, Bt, kt, wt, Et, Rt, Mt, Ht, Kt, jt, Wt, Yt, Xt, ir = this, ur = ir.c, Qt = (Oe = new ht(Oe, ct)).c;
    if (!(ur && Qt && ur[0] && Qt[0])) return !ir.s || !Oe.s || ur && !ur[0] && !Qt || Qt && !Qt[0] && !ur ? Oe.c = Oe.e = Oe.s = null : (Oe.s *= ir.s, ur && Qt ? (Oe.c = [0], Oe.e = 0) : Oe.c = Oe.e = null), Oe;
    for (gt = bitFloor(ir.e / LOG_BASE) + bitFloor(Oe.e / LOG_BASE), Oe.s *= ir.s, (Et = ur.length) < (Ht = Qt.length) && (Wt = ur, ur = Qt, Qt = Wt, vt = Et, Et = Ht, Ht = vt), vt = Et + Ht, Wt = []; vt--; Wt.push(0)) ;
    for (Yt = BASE, Xt = SQRT_BASE, vt = Ht; --vt >= 0; ) {
      for (pt = 0, Kt = Qt[vt] % Xt, jt = Qt[vt] / Xt | 0, Bt = vt + (kt = Et); Bt > vt; ) pt = ((Rt = Kt * (Rt = ur[--kt] % Xt) + (wt = jt * Rt + (Mt = ur[kt] / Xt | 0) * Kt) % Xt * Xt + Wt[Bt] + pt) / Yt | 0) + (wt / Xt | 0) + jt * Mt, Wt[Bt--] = Rt % Yt;
      Wt[Bt] = pt;
    }
    return pt ? ++gt : Wt.splice(0, 1), rt(Oe, Wt, gt);
  }, pe.negated = function() {
    var Oe = new ht(this);
    return Oe.s = -Oe.s || null, Oe;
  }, pe.plus = function(Oe, ct) {
    var pt, gt = this, vt = gt.s;
    if (ct = (Oe = new ht(Oe, ct)).s, !vt || !ct) return new ht(NaN);
    if (vt != ct) return Oe.s = -ct, gt.minus(Oe);
    var Bt = gt.e / LOG_BASE, kt = Oe.e / LOG_BASE, wt = gt.c, Et = Oe.c;
    if (!Bt || !kt) {
      if (!wt || !Et) return new ht(vt / 0);
      if (!wt[0] || !Et[0]) return Et[0] ? Oe : new ht(wt[0] ? gt : 0 * vt);
    }
    if (Bt = bitFloor(Bt), kt = bitFloor(kt), wt = wt.slice(), vt = Bt - kt) {
      for (vt > 0 ? (kt = Bt, pt = Et) : (vt = -vt, pt = wt), pt.reverse(); vt--; pt.push(0)) ;
      pt.reverse();
    }
    for ((vt = wt.length) - (ct = Et.length) < 0 && (pt = Et, Et = wt, wt = pt, ct = vt), vt = 0; ct; ) vt = (wt[--ct] = wt[ct] + Et[ct] + vt) / BASE | 0, wt[ct] = BASE === wt[ct] ? 0 : wt[ct] % BASE;
    return vt && (wt = [vt].concat(wt), ++kt), rt(Oe, wt, kt);
  }, pe.precision = pe.sd = function(Oe, ct) {
    var pt, gt, vt, Bt = this;
    if (Oe != null && Oe !== !!Oe) return intCheck(Oe, 1, MAX), ct == null ? ct = at : intCheck(ct, 0, 8), it(new ht(Bt), Oe, ct);
    if (!(pt = Bt.c)) return null;
    if (gt = (vt = pt.length - 1) * LOG_BASE + 1, vt = pt[vt]) {
      for (; vt % 10 == 0; vt /= 10, gt--) ;
      for (vt = pt[0]; vt >= 10; vt /= 10, gt++) ;
    }
    return Oe && Bt.e + 1 > gt && (gt = Bt.e + 1), gt;
  }, pe.shiftedBy = function(Oe) {
    return intCheck(Oe, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER), this.times("1e" + Oe);
  }, pe.squareRoot = pe.sqrt = function() {
    var Oe, ct, pt, gt, vt, Bt = this, kt = Bt.c, wt = Bt.s, Et = Bt.e, Rt = ot + 4, Mt = new ht("0.5");
    if (wt !== 1 || !kt || !kt[0]) return new ht(!wt || wt < 0 && (!kt || kt[0]) ? NaN : kt ? Bt : 1 / 0);
    if ((wt = Math.sqrt(+st(Bt))) == 0 || wt == 1 / 0 ? (((ct = coeffToString(kt)).length + Et) % 2 == 0 && (ct += "0"), wt = Math.sqrt(+ct), Et = bitFloor((Et + 1) / 2) - (Et < 0 || Et % 2), pt = new ht(ct = wt == 1 / 0 ? "5e" + Et : (ct = wt.toExponential()).slice(0, ct.indexOf("e") + 1) + Et)) : pt = new ht(wt + ""), pt.c[0]) {
      for ((wt = (Et = pt.e) + Rt) < 3 && (wt = 0); ; ) if (vt = pt, pt = Mt.times(vt.plus(L(Bt, vt, Rt, 1))), coeffToString(vt.c).slice(0, wt) === (ct = coeffToString(pt.c)).slice(0, wt)) {
        if (pt.e < Et && --wt, (ct = ct.slice(wt - 3, wt + 1)) != "9999" && (gt || ct != "4999")) {
          +ct && (+ct.slice(1) || ct.charAt(0) != "5") || (it(pt, pt.e + ot + 2, 1), Oe = !pt.times(pt).eq(Bt));
          break;
        }
        if (!gt && (it(vt, vt.e + ot + 2, 0), vt.times(vt).eq(Bt))) {
          pt = vt;
          break;
        }
        Rt += 4, wt += 4, gt = 1;
      }
    }
    return it(pt, pt.e + ot + 1, at, Oe);
  }, pe.toExponential = function(Oe, ct) {
    return Oe != null && (intCheck(Oe, 0, MAX), Oe++), Ce(this, Oe, ct, 1);
  }, pe.toFixed = function(Oe, ct) {
    return Oe != null && (intCheck(Oe, 0, MAX), Oe = Oe + this.e + 1), Ce(this, Oe, ct);
  }, pe.toFormat = function(Oe, ct, pt) {
    var gt, vt = this;
    if (pt == null) Oe != null && ct && typeof ct == "object" ? (pt = ct, ct = null) : Oe && typeof Oe == "object" ? (pt = Oe, Oe = ct = null) : pt = It;
    else if (typeof pt != "object") throw Error(bignumberError + "Argument not an object: " + pt);
    if (gt = vt.toFixed(Oe, ct), vt.c) {
      var Bt, kt = gt.split("."), wt = +pt.groupSize, Et = +pt.secondaryGroupSize, Rt = pt.groupSeparator || "", Mt = kt[0], Ht = kt[1], Kt = vt.s < 0, jt = Kt ? Mt.slice(1) : Mt, Wt = jt.length;
      if (Et && (Bt = wt, wt = Et, Et = Bt, Wt -= Bt), wt > 0 && Wt > 0) {
        for (Bt = Wt % wt || wt, Mt = jt.substr(0, Bt); Bt < Wt; Bt += wt) Mt += Rt + jt.substr(Bt, wt);
        Et > 0 && (Mt += Rt + jt.slice(Bt)), Kt && (Mt = "-" + Mt);
      }
      gt = Ht ? Mt + (pt.decimalSeparator || "") + ((Et = +pt.fractionGroupSize) ? Ht.replace(new RegExp("\\d{" + Et + "}\\B", "g"), "$&" + (pt.fractionGroupSeparator || "")) : Ht) : Mt;
    }
    return (pt.prefix || "") + gt + (pt.suffix || "");
  }, pe.toFraction = function(Oe) {
    var ct, pt, gt, vt, Bt, kt, wt, Et, Rt, Mt, Ht, Kt, jt = this, Wt = jt.c;
    if (Oe != null && (!(wt = new ht(Oe)).isInteger() && (wt.c || wt.s !== 1) || wt.lt(ke))) throw Error(bignumberError + "Argument " + (wt.isInteger() ? "out of range: " : "not an integer: ") + st(wt));
    if (!Wt) return new ht(jt);
    for (ct = new ht(ke), Rt = pt = new ht(ke), gt = Et = new ht(ke), Kt = coeffToString(Wt), Bt = ct.e = Kt.length - jt.e - 1, ct.c[0] = POWS_TEN[(kt = Bt % LOG_BASE) < 0 ? LOG_BASE + kt : kt], Oe = !Oe || wt.comparedTo(ct) > 0 ? Bt > 0 ? ct : Rt : wt, kt = yt, yt = 1 / 0, wt = new ht(Kt), Et.c[0] = 0; Mt = L(wt, ct, 0, 1), (vt = pt.plus(Mt.times(gt))).comparedTo(Oe) != 1; ) pt = gt, gt = vt, Rt = Et.plus(Mt.times(vt = Rt)), Et = vt, ct = wt.minus(Mt.times(vt = ct)), wt = vt;
    return vt = L(Oe.minus(pt), gt, 0, 1), Et = Et.plus(vt.times(Rt)), pt = pt.plus(vt.times(gt)), Et.s = Rt.s = jt.s, Ht = L(Rt, gt, Bt *= 2, at).minus(jt).abs().comparedTo(L(Et, pt, Bt, at).minus(jt).abs()) < 1 ? [Rt, gt] : [Et, pt], yt = kt, Ht;
  }, pe.toNumber = function() {
    return +st(this);
  }, pe.toPrecision = function(Oe, ct) {
    return Oe != null && intCheck(Oe, 1, MAX), Ce(this, Oe, ct, 2);
  }, pe.toString = function(Oe) {
    var ct, pt = this, gt = pt.s, vt = pt.e;
    return vt === null ? gt ? (ct = "Infinity", gt < 0 && (ct = "-" + ct)) : ct = "NaN" : (Oe == null ? ct = vt <= ft || vt >= dt ? toExponential(coeffToString(pt.c), vt) : toFixedPoint(coeffToString(pt.c), vt, "0") : Oe === 10 && ut ? ct = toFixedPoint(coeffToString((pt = it(new ht(pt), ot + vt + 1, at)).c), pt.e, "0") : (intCheck(Oe, 2, Ut.length, "Base"), ct = K(toFixedPoint(coeffToString(pt.c), vt, "0"), 10, Oe, gt, !0)), gt < 0 && pt.c[0] && (ct = "-" + ct)), ct;
  }, pe.valueOf = pe.toJSON = function() {
    return st(this);
  }, pe._isBigNumber = !0, pe[Symbol.toStringTag] = "BigNumber", pe[Symbol.for("nodejs.util.inspect.custom")] = pe.valueOf, B != null && ht.set(B), ht;
}
function bitFloor(B) {
  var L = 0 | B;
  return B > 0 || B === L ? L : L - 1;
}
function coeffToString(B) {
  for (var L, K, W = 1, V = B.length, J = B[0] + ""; W < V; ) {
    for (L = B[W++] + "", K = LOG_BASE - L.length; K--; L = "0" + L) ;
    J += L;
  }
  for (V = J.length; J.charCodeAt(--V) === 48; ) ;
  return J.slice(0, V + 1 || 1);
}
function compare(B, L) {
  var K, W, V = B.c, J = L.c, re = B.s, ie = L.s, ne = B.e, oe = L.e;
  if (!re || !ie) return null;
  if (K = V && !V[0], W = J && !J[0], K || W) return K ? W ? 0 : -ie : re;
  if (re != ie) return re;
  if (K = re < 0, W = ne == oe, !V || !J) return W ? 0 : !V ^ K ? 1 : -1;
  if (!W) return ne > oe ^ K ? 1 : -1;
  for (ie = (ne = V.length) < (oe = J.length) ? ne : oe, re = 0; re < ie; re++) if (V[re] != J[re]) return V[re] > J[re] ^ K ? 1 : -1;
  return ne == oe ? 0 : ne > oe ^ K ? 1 : -1;
}
function intCheck(B, L, K, W) {
  if (B < L || B > K || B !== mathfloor(B)) throw Error(bignumberError + (W || "Argument") + (typeof B == "number" ? B < L || B > K ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var L = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == L && B.c[L] % 2 != 0;
}
function toExponential(B, L) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (L < 0 ? "e" : "e+") + L;
}
function toFixedPoint(B, L, K) {
  var W, V;
  if (L < 0) {
    for (V = K + "."; ++L; V += K) ;
    B = V + B;
  } else if (++L > (W = B.length)) {
    for (V = K, L -= W; --L; V += K) ;
    B += V;
  } else L < W && (B = B.slice(0, L) + "." + B.slice(L));
  return B;
}
var BigNumber = clone(), browserPonyfill = { exports: {} };
(function(B, L) {
  var K = typeof globalThis < "u" && globalThis || typeof self < "u" && self || commonjsGlobal !== void 0 && commonjsGlobal, W = function() {
    function J() {
      this.fetch = !1, this.DOMException = K.DOMException;
    }
    return J.prototype = K, new J();
  }();
  (function(J) {
    (function(re) {
      var ie = J !== void 0 && J || typeof self < "u" && self || ie !== void 0 && ie, ne = "URLSearchParams" in ie, oe = "Symbol" in ie && "iterator" in Symbol, ce = "FileReader" in ie && "Blob" in ie && function() {
        try {
          return new Blob(), !0;
        } catch {
          return !1;
        }
      }(), pe = "FormData" in ie, ke = "ArrayBuffer" in ie;
      if (ke) var ot = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], at = ArrayBuffer.isView || function(st) {
        return st && ot.indexOf(Object.prototype.toString.call(st)) > -1;
      };
      function ft(st) {
        if (typeof st != "string" && (st = String(st)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(st) || st === "") throw new TypeError('Invalid character in header field name: "' + st + '"');
        return st.toLowerCase();
      }
      function dt(st) {
        return typeof st != "string" && (st = String(st)), st;
      }
      function lt(st) {
        var Oe = { next: function() {
          var ct = st.shift();
          return { done: ct === void 0, value: ct };
        } };
        return oe && (Oe[Symbol.iterator] = function() {
          return Oe;
        }), Oe;
      }
      function yt(st) {
        this.map = {}, st instanceof yt ? st.forEach(function(Oe, ct) {
          this.append(ct, Oe);
        }, this) : Array.isArray(st) ? st.forEach(function(Oe) {
          this.append(Oe[0], Oe[1]);
        }, this) : st && Object.getOwnPropertyNames(st).forEach(function(Oe) {
          this.append(Oe, st[Oe]);
        }, this);
      }
      function St(st) {
        if (st.bodyUsed) return Promise.reject(new TypeError("Already read"));
        st.bodyUsed = !0;
      }
      function mt(st) {
        return new Promise(function(Oe, ct) {
          st.onload = function() {
            Oe(st.result);
          }, st.onerror = function() {
            ct(st.error);
          };
        });
      }
      function $t(st) {
        var Oe = new FileReader(), ct = mt(Oe);
        return Oe.readAsArrayBuffer(st), ct;
      }
      function It(st) {
        if (st.slice) return st.slice(0);
        var Oe = new Uint8Array(st.byteLength);
        return Oe.set(new Uint8Array(st)), Oe.buffer;
      }
      function Ut() {
        return this.bodyUsed = !1, this._initBody = function(st) {
          var Oe;
          this.bodyUsed = this.bodyUsed, this._bodyInit = st, st ? typeof st == "string" ? this._bodyText = st : ce && Blob.prototype.isPrototypeOf(st) ? this._bodyBlob = st : pe && FormData.prototype.isPrototypeOf(st) ? this._bodyFormData = st : ne && URLSearchParams.prototype.isPrototypeOf(st) ? this._bodyText = st.toString() : ke && ce && (Oe = st) && DataView.prototype.isPrototypeOf(Oe) ? (this._bodyArrayBuffer = It(st.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : ke && (ArrayBuffer.prototype.isPrototypeOf(st) || at(st)) ? this._bodyArrayBuffer = It(st) : this._bodyText = st = Object.prototype.toString.call(st) : this._bodyText = "", this.headers.get("content-type") || (typeof st == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : ne && URLSearchParams.prototype.isPrototypeOf(st) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, ce && (this.blob = function() {
          var st = St(this);
          if (st) return st;
          if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData) throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? St(this) || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)) : this.blob().then($t);
        }), this.text = function() {
          var st, Oe, ct, pt = St(this);
          if (pt) return pt;
          if (this._bodyBlob) return st = this._bodyBlob, ct = mt(Oe = new FileReader()), Oe.readAsText(st), ct;
          if (this._bodyArrayBuffer) return Promise.resolve(function(gt) {
            for (var vt = new Uint8Array(gt), Bt = new Array(vt.length), kt = 0; kt < vt.length; kt++) Bt[kt] = String.fromCharCode(vt[kt]);
            return Bt.join("");
          }(this._bodyArrayBuffer));
          if (this._bodyFormData) throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, pe && (this.formData = function() {
          return this.text().then(Ce);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      yt.prototype.append = function(st, Oe) {
        st = ft(st), Oe = dt(Oe);
        var ct = this.map[st];
        this.map[st] = ct ? ct + ", " + Oe : Oe;
      }, yt.prototype.delete = function(st) {
        delete this.map[ft(st)];
      }, yt.prototype.get = function(st) {
        return st = ft(st), this.has(st) ? this.map[st] : null;
      }, yt.prototype.has = function(st) {
        return this.map.hasOwnProperty(ft(st));
      }, yt.prototype.set = function(st, Oe) {
        this.map[ft(st)] = dt(Oe);
      }, yt.prototype.forEach = function(st, Oe) {
        for (var ct in this.map) this.map.hasOwnProperty(ct) && st.call(Oe, this.map[ct], ct, this);
      }, yt.prototype.keys = function() {
        var st = [];
        return this.forEach(function(Oe, ct) {
          st.push(ct);
        }), lt(st);
      }, yt.prototype.values = function() {
        var st = [];
        return this.forEach(function(Oe) {
          st.push(Oe);
        }), lt(st);
      }, yt.prototype.entries = function() {
        var st = [];
        return this.forEach(function(Oe, ct) {
          st.push([ct, Oe]);
        }), lt(st);
      }, oe && (yt.prototype[Symbol.iterator] = yt.prototype.entries);
      var ut = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function ht(st, Oe) {
        if (!(this instanceof ht)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        var ct, pt, gt = (Oe = Oe || {}).body;
        if (st instanceof ht) {
          if (st.bodyUsed) throw new TypeError("Already read");
          this.url = st.url, this.credentials = st.credentials, Oe.headers || (this.headers = new yt(st.headers)), this.method = st.method, this.mode = st.mode, this.signal = st.signal, gt || st._bodyInit == null || (gt = st._bodyInit, st.bodyUsed = !0);
        } else this.url = String(st);
        if (this.credentials = Oe.credentials || this.credentials || "same-origin", !Oe.headers && this.headers || (this.headers = new yt(Oe.headers)), this.method = (pt = (ct = Oe.method || this.method || "GET").toUpperCase(), ut.indexOf(pt) > -1 ? pt : ct), this.mode = Oe.mode || this.mode || null, this.signal = Oe.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && gt) throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(gt), !(this.method !== "GET" && this.method !== "HEAD" || Oe.cache !== "no-store" && Oe.cache !== "no-cache")) {
          var vt = /([?&])_=[^&]*/;
          vt.test(this.url) ? this.url = this.url.replace(vt, "$1_=" + (/* @__PURE__ */ new Date()).getTime()) : this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
        }
      }
      function Ce(st) {
        var Oe = new FormData();
        return st.trim().split("&").forEach(function(ct) {
          if (ct) {
            var pt = ct.split("="), gt = pt.shift().replace(/\+/g, " "), vt = pt.join("=").replace(/\+/g, " ");
            Oe.append(decodeURIComponent(gt), decodeURIComponent(vt));
          }
        }), Oe;
      }
      function nt(st, Oe) {
        if (!(this instanceof nt)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        Oe || (Oe = {}), this.type = "default", this.status = Oe.status === void 0 ? 200 : Oe.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = Oe.statusText === void 0 ? "" : "" + Oe.statusText, this.headers = new yt(Oe.headers), this.url = Oe.url || "", this._initBody(st);
      }
      ht.prototype.clone = function() {
        return new ht(this, { body: this._bodyInit });
      }, Ut.call(ht.prototype), Ut.call(nt.prototype), nt.prototype.clone = function() {
        return new nt(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new yt(this.headers), url: this.url });
      }, nt.error = function() {
        var st = new nt(null, { status: 0, statusText: "" });
        return st.type = "error", st;
      };
      var rt = [301, 302, 303, 307, 308];
      nt.redirect = function(st, Oe) {
        if (rt.indexOf(Oe) === -1) throw new RangeError("Invalid status code");
        return new nt(null, { status: Oe, headers: { location: st } });
      }, re.DOMException = ie.DOMException;
      try {
        new re.DOMException();
      } catch {
        re.DOMException = function(Oe, ct) {
          this.message = Oe, this.name = ct;
          var pt = Error(Oe);
          this.stack = pt.stack;
        }, re.DOMException.prototype = Object.create(Error.prototype), re.DOMException.prototype.constructor = re.DOMException;
      }
      function it(st, Oe) {
        return new Promise(function(ct, pt) {
          var gt = new ht(st, Oe);
          if (gt.signal && gt.signal.aborted) return pt(new re.DOMException("Aborted", "AbortError"));
          var vt = new XMLHttpRequest();
          function Bt() {
            vt.abort();
          }
          vt.onload = function() {
            var kt, wt, Et = { status: vt.status, statusText: vt.statusText, headers: (kt = vt.getAllResponseHeaders() || "", wt = new yt(), kt.replace(/\r?\n[\t ]+/g, " ").split("\r").map(function(Mt) {
              return Mt.indexOf(`
`) === 0 ? Mt.substr(1, Mt.length) : Mt;
            }).forEach(function(Mt) {
              var Ht = Mt.split(":"), Kt = Ht.shift().trim();
              if (Kt) {
                var jt = Ht.join(":").trim();
                wt.append(Kt, jt);
              }
            }), wt) };
            Et.url = "responseURL" in vt ? vt.responseURL : Et.headers.get("X-Request-URL");
            var Rt = "response" in vt ? vt.response : vt.responseText;
            setTimeout(function() {
              ct(new nt(Rt, Et));
            }, 0);
          }, vt.onerror = function() {
            setTimeout(function() {
              pt(new TypeError("Network request failed"));
            }, 0);
          }, vt.ontimeout = function() {
            setTimeout(function() {
              pt(new TypeError("Network request failed"));
            }, 0);
          }, vt.onabort = function() {
            setTimeout(function() {
              pt(new re.DOMException("Aborted", "AbortError"));
            }, 0);
          }, vt.open(gt.method, function(kt) {
            try {
              return kt === "" && ie.location.href ? ie.location.href : kt;
            } catch {
              return kt;
            }
          }(gt.url), !0), gt.credentials === "include" ? vt.withCredentials = !0 : gt.credentials === "omit" && (vt.withCredentials = !1), "responseType" in vt && (ce ? vt.responseType = "blob" : ke && gt.headers.get("Content-Type") && gt.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (vt.responseType = "arraybuffer")), !Oe || typeof Oe.headers != "object" || Oe.headers instanceof yt ? gt.headers.forEach(function(kt, wt) {
            vt.setRequestHeader(wt, kt);
          }) : Object.getOwnPropertyNames(Oe.headers).forEach(function(kt) {
            vt.setRequestHeader(kt, dt(Oe.headers[kt]));
          }), gt.signal && (gt.signal.addEventListener("abort", Bt), vt.onreadystatechange = function() {
            vt.readyState === 4 && gt.signal.removeEventListener("abort", Bt);
          }), vt.send(gt._bodyInit === void 0 ? null : gt._bodyInit);
        });
      }
      it.polyfill = !0, ie.fetch || (ie.fetch = it, ie.Headers = yt, ie.Request = ht, ie.Response = nt), re.Headers = yt, re.Request = ht, re.Response = nt, re.fetch = it;
    })({});
  })(W), W.fetch.ponyfill = !0, delete W.fetch.polyfill;
  var V = K.fetch ? K : W;
  (L = V.fetch).default = V.fetch, L.fetch = V.fetch, L.Headers = V.Headers, L.Request = V.Request, L.Response = V.Response, B.exports = L;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const fetch = getDefaultExportFromCjs(browserPonyfillExports);
var bufferReverse = function(B) {
  for (var L = new Buffer$3(B.length), K = 0, W = B.length - 1; K <= W; ++K, --W) L[K] = B[W], L[W] = B[K];
  return L;
};
const reverseBuffer = getDefaultExportFromCjs(bufferReverse);
export {
  Buffer$3 as B,
  O,
  _t as _,
  qe as a,
  src$4 as b,
  BitcoinNetworkType as c,
  signTransaction as d,
  ecc as e,
  signMessage as f,
  getAddress as g,
  getWallets as h,
  fetch as i,
  jsxRuntimeExports as j,
  BigNumber as k,
  sendBtcTransaction as l,
  qe$1 as q,
  reverseBuffer as r,
  src$2 as s,
  z
};
